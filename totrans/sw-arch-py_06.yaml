- en: Chapter 6. Security – Writing Secure Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Security of software applications (or lack of it) has been attracting a lot
    of importance in the past few years in the industry and the media. It looks like
    every other day, we hear about an instance or two of malicious hackers causing
    massive data breaches in software systems in different parts of the world, and
    causing millions of dollars worth of losses. The victims are either government
    departments, financial institutions, firms handling sensitive customer data such
    as passwords, credit cards, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Software security and secure coding has assumed more importance than ever due
    to the unprecedented amounts of data being shared across software and hardware
    systems—the explosion of smart personal technologies such as smart phones, smart
    watches, smart music players, and other smart systems has created and aided this
    immense traffic of data across the Internet in a big way. With the advent of IPV6
    and expected large scale adoption of **IoT** devices (**Internet of Things**)
    in the next few years, the amount of data is only going to increase exponentially.
  prefs: []
  type: TYPE_NORMAL
- en: As we discussed in the first chapter, security is an important aspect of software
    architecture. Apart from architecting systems with secure principles, an architect
    should also try to imbibe their team with secure coding principles to minimize
    security pitfalls in the code written by their team.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will look at the principles of architecting secure systems,
    and also look at tips and techniques for writing secure code in Python.
  prefs: []
  type: TYPE_NORMAL
- en: The topics we will be discussing can be summed up in the following list.
  prefs: []
  type: TYPE_NORMAL
- en: Information Security Architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Secure Coding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common Security Vulnerabilities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is Python Secure?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading Input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Evaluating arbitrary Input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overflow Errors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serializing Objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security issues with web applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Strategies for Security – Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Secure Coding Strategies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Information Security architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A secure architecture involves creating a system that is able to provide access
    to data, and information to authorized people and systems while preventing any
    unauthorized access. Creating an architecture for information security for your
    systems involves the following aspects:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Confidentiality**: A set of rules or procedures that restricts the envelope
    of access to information in the system. Confidentiality ensures that data is not
    exposed to unauthorized access or modification.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integrity**: Integrity is the property of the system which ensures that the
    information channels are trustworthy and reliable and that the system is free
    from external manipulations. In other words, Integrity ensures the data can be
    trusted as it flows through the system across its components.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Availability**: Property that the system will ensure a level of service to
    its authorized users according to its Service Level Agreements (SLAs). Availability
    ensures that the system will not deny service to its authorized users.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The three aspects of Confidentiality, Integrity, and Availability – often called
    the CIA triad form the corner stones of building an information security architecture
    for your system.
  prefs: []
  type: TYPE_NORMAL
- en: '![Information Security architecture](../Images/image00463.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: CIA triad of Information Security Architecture
  prefs: []
  type: TYPE_NORMAL
- en: 'These aspects are aided by other characteristics, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Authentication**: Verifies the identity of the participants of a transaction,
    and ensures that they are actually those who they purport to be. Examples are
    digital certificates used in e-mail, public keys used to log in to systems, and
    the like.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Authorization**: Gives rights to a specific user/role to perform a specific
    task or groups of related tasks. Authorization ensures that certain groups of
    users are tied to certain roles, which limit their access (read) and modification
    (write) rights in the system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Non-reputability**: Security techniques that guarantee that users involved
    in a transaction cannot later deny that the transaction happened. For example,
    a sender of an e-mail cannot later deny that they had sent the e-mail; a recipient
    of a bank funds transfer cannot later deny that they received the money, and so
    on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Secure coding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Secure coding is the practice of software development that guards programs against
    security vulnerabilities, and makes it resistant to malicious attacks right from
    program design to implementation. It is about writing code that is inherently
    secure as opposed to thinking of security as a layer which is added on later.
  prefs: []
  type: TYPE_NORMAL
- en: 'The philosophies behind secure coding include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Security is an aspect to be considered right from the design and development
    of a program or application; it is not an afterthought.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security requirements should be identified early in the development cycle, and
    these should be propagated to subsequent stages of development of the system to
    make sure that compliance is maintained.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Use threat modeling to anticipate security threats to the system from the beginning.
    Threat modeling involves the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identifying important assets (code/data).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Decomposing the application into components.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Identifying and categorizing threats to each asset or component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ranking the threats based on an established risk model.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Developing threat mitigation strategies.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The practice or strategies of secure coding include the following main tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Definition of areas of interest of the application**: Identify important
    assets in code/data of the application which are critical and needs to be secured.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Analysis of software architecture**: Analyze the software architecture for
    obvious security flaws. Secure interaction between components with a view for
    ensuring data confidentiality and integrity. Ensure confidential data is protected
    via proper authentication and authorization techniques. Ensure availability is
    built into the architecture from ground up.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Review of implementation details**: Review the code using secure coding techniques.
    Ensure peer review is done with a view to finding security holes. Provide feedback
    to the developer and ensure changes are made.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Verification of logic and syntax**: Review code logic and syntax to ensure
    there are no obvious loop holes in the implementation. Make sure programming is
    done keeping with commonly available secure coding guidelines of the programming
    language/platform.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Whitebox/Unit Testing**: The developer unit tests his code with security
    tests apart from tests ensuring functionality. Mock data and/or APIs can be used
    to virtualize third party data/API required for testing.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Blackbox Testing**: The application is tested by an experienced QA engineer
    who looks for security loop holes such as unauthorized access to data, path ways
    accidentally exposing code and or data, weak passwords or hashes etc. The testing
    reports are fed back the stakeholders including the architect to make sure the
    loopholes identified are fixed.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In reality, secure coding is a practice and a habit that software development
    organizations should inculcate through carefully developed and reviewed secure
    coding strategies such as the aforementioned over time.
  prefs: []
  type: TYPE_NORMAL
- en: Common security vulnerabilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So what are the common security vulnerabilities, a professional programmer
    today should be prepared to face and mitigate during the course of their career?
    Looking at the available literature, these can be organized into a few specific
    categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Overflow errors**: These include the popular and often abused **buffer overflow**
    errors, and the lesser known but still vulnerable **arithmetic or integer overflow**
    errors:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The buffer overflow**: The buffer overflows are produced by programming errors
    that allow an application to write past the end or beginning of a buffer. The
    buffer overflows allow attackers to take control over systems by gaining access
    to the applications stack or heap memory by carefully crafted attack data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The integer or arithmetic overflow**: These errors occur when an arithmetic
    or mathematical operation on integers produces a result that is too large for
    the maximum size of the type used to store it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integer overflows can create security vulnerabilities if they are not properly
    handled. In programming languages supporting signed and unsigned integers, overflows
    can cause the data to wrap and produce negative numbers, allowing the attacker
    with a result similar to buffer overflows to gain access to heap or stack memory
    outside the program execution limits.
  prefs: []
  type: TYPE_NORMAL
- en: '**Unvalidated/Improperly validated input**: A very common security issue with
    modern web applications, unvalidated input can cause major vulnerabilities, where
    attackers can trick a program into accepting malicious input such as code data
    or system commands, which, when executed, can compromise a system. A system that
    aims to mitigate this type of attack should have filters to check and remove content
    that is malicious, and only accept data that is reasonable and safe to the system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common subtypes of this type of attack include SQL injections, Server-Side Template
    Injections, **Cross-Site-Scripting** (**XSS**), and Shell Execution Exploits.
  prefs: []
  type: TYPE_NORMAL
- en: Modern web application frameworks are vulnerable to this kind of attack due
    to use of HTML templates which mix code and data, but many of them have standard
    mitigation procedures such as escaping or filtering of input.
  prefs: []
  type: TYPE_NORMAL
- en: '**Improper access control**: Modern day applications should define separate
    roles for their classes of users, such as regular users, and those with special
    privileges, such as superusers or administrators. When an application fails to
    do this or does it incorrectly, it can expose routes (URLs) or workflows (series
    of actions specified by specific URLs containing attack vectors), which can either
    expose sensitive data to attackers, or, in the worst case, allow an attacker to
    compromise and take control of the system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cryptography issues**: Simply ensuring that access control is in place is
    not enough for hardening and securing a system. Instead, the level and strength
    of security should be verified and ascertained, otherwise, your system can still
    be hacked or compromised. Some examples are as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**HTTP instead of HTTPS**: When implementing RestFUL web services, make sure
    you favor HTTPS (SSL/TLS) over HTTP. In HTTP, all communication is in plain text
    between the client and server, and can be easily captured by passive network sniffers
    or carefully crafted packet capture software or devices installed in routers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Projects like letsencrypt have made life easy for system administrators for
    procuring and updating free SSL certificates, so securing your servers using SSL/TLS
    is easier these days than ever before.
  prefs: []
  type: TYPE_NORMAL
- en: '**Insecure authentication**: Prefer secure authentication techniques on a web
    server over insecure ones. For example, prefer HTTP Digest authentication to Basic
    authentication on web servers, as in the latter, passwords are sent in the clear.
    Similarly, use **Kerberos** authentication in a large shared network over less
    secure alternatives such as **Lightweight Directory Access Protocol** (**LDAP**)
    or **NT LAN Manager** (**NTLM**).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use of weak passwords**: Easy-to-guess or default/trivial passwords are the
    bane of many modern-day web applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reuse of secure hashes/secret keys** – Secure hashes or secret keys are usually
    specific to an application or project and should never be reused across applications.
    Whenever required generate fresh hashes and or keys.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Weak encryption techniques**: Ciphers used in encrypting communication either
    on the server (SSL certificates) or personal computers (GPG/PGP keys) should use
    high-grade security – of at least 2048 bits and use peer-reviewed and crypto-safe
    algorithms.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Weak hashing techniques**: Just as in ciphers, hashing techniques used to
    keep secrets and salts of sensitive data such as passwords should be careful in
    choosing strong algorithms. For example, if one is writing an application that
    requires hashes to be computed and stored today, they would be better off using
    the SHA-1 or SHA-2 algorithms rather than the weaker MD5.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Invalid or expired certificates/keys**: Web masters often forget to keep
    their SSL certificates updated, and this can become a big problem, compromising
    the security of their web servers, as invalid certificates offer no protection.
    Similarly, personal keys such as GPG or PGP public/private key pairs used for
    e-mail communication should be kept updated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Password enabled SSH - SSH access to remote systems using clear text passwords
    is a security hole. Disable password based access and only enable access via authorized
    SSH keys for specific users only. Disable remote root SSH access.
  prefs: []
  type: TYPE_NORMAL
- en: '**Information leak**: A lot of web servers systems—mostly due to open configuration,
    or misconfiguration, or due to lack of validation of inputs—can reveal a lot of
    information about themselves to an attacker. Some examples are as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Server meta information**: Many web servers leak information about themselves
    via their 404 pages, and sometimes, via their landing pages. Here is an example:![Common
    security vulnerabilities](../Images/image00464.jpeg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 404 page of a web server exposing server meta information
  prefs: []
  type: TYPE_NORMAL
- en: By simply requesting for a non-existing page, we came to know that the site
    seen in the preceding screenshot runs Apache version 2.4.10 on a Debian Server.
    For a crafty attacker, this is often information enough to try out specific attacks
    for that particular web-server/OS combination.
  prefs: []
  type: TYPE_NORMAL
- en: '**Open index pages**: Many websites don''t protect their directory pages, and
    leave them open for world access. This following image shows an example:![Common
    security vulnerabilities](../Images/image00465.jpeg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Open index page of a web server
  prefs: []
  type: TYPE_NORMAL
- en: '**Open ports**: It is a common error to provide world-access to application''s
    ports running on remote web servers instead of limiting access to them by specific
    IP addresses or security groups by using firewalls – such as *iptables*. A similar
    error is to allow a service to run on 0.0.0.0 (all IP addresses on the server)
    for a service which is only consumed on the localhost. This makes it easy for
    attackers to scan for such ports using network reconnaissance tools such as *nmap/hping3*,
    and the like, and plan their attack.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Open access to files/folders/databases - A very poor practice is to provide
    open or world access to application configuration files, log files, process ID
    files, and other artifacts so that any logged-in user can access and obtain information
    from these files. Instead, such files should be part of security policies to ensure
    that only specific roles with the required privileges have access to the files.
  prefs: []
  type: TYPE_NORMAL
- en: '**Race conditions**: A race condition exists when a program has two or more
    actors trying to access a certain resource, but the output depends on the correct
    order of access, which cannot be ensured. An example is two threads trying to
    increment a numerical value in shared memory without proper synchronization.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Crafty attackers can take advantage of the situation to insert malicious code,
    change a filename, or sometimes, take advantage of small time gaps in the processing
    of code to interfere with the sequence of operations.
  prefs: []
  type: TYPE_NORMAL
- en: '**System clock drifts**: This is the phenomena where the system or local clock
    time on a server slowly drifts away from the reference time due to improper or
    missing synchronization. Over time, the clock drift can cause serious security
    flaws such as error in SSL certificate validation, which can be exploited by highly
    sophisticated techniques like *timing attacks* where an attacker tries to take
    control over the system by analyzing time taken to execute cryptographic algorithms.
    Time synchronization protocols like NTP can be used to mitigate this.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Insecure file/folder operations**: Programmers often make assumptions about
    the ownership, location, or attributes of a file or folder that might not be true
    in practice. This can result in conditions where a security flaw can occur or
    where we may not detect tampering with the system. Some examples are as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Failing to check results after a write operation assuming it succeeded
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assuming local file paths are always local files (whereas, they might be symbolic
    links to system files for which the application may not have access)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improperly using sudo in executing system commands, which, if not done correctly,
    can cause loopholes, which can be used to gain root access of the system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generous use of permissions on shared files or folders, for example, turning
    on all the execute bits of a program which should be limited to a group or open
    home folders which can be read by any logged in user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using unsafe serialization and deserialization of code or data objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is beyond the scope of this chapter to visit each and every type of vulnerability
    in this list. However, we will make an earnest attempt to review and explain the
    common classes of software vulnerabilities that affect Python, and some of its
    web frameworks in the coming section.
  prefs: []
  type: TYPE_NORMAL
- en: Is Python secure?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python is a very readable language with simple syntax, and typically, one clearly
    stated way to do things. It comes with a set of well-tested and compact standard
    library modules. All of this seems to indicate that Python should be a very secure
    language.
  prefs: []
  type: TYPE_NORMAL
- en: But is it so?
  prefs: []
  type: TYPE_NORMAL
- en: Let us look at a few examples in Python, and try to analyze the security aspect
    of Python and its standard libraries.
  prefs: []
  type: TYPE_NORMAL
- en: For the purposes of usefulness, we will demonstrate the code examples shown
    in this section using both Python 2.x and Python 3.x versions. This is because
    a number of security vulnerabilities that are present in Python 2.x versions are
    fixed in the recent 3.x versions. However, since many Python developers are still
    using some form or the other of Python 2.x, the code examples would be useful
    to them, and also illustrate the importance of migrating to Python 3.x.
  prefs: []
  type: TYPE_NORMAL
- en: 'All examples are executed on a machine running the Linux (Ubuntu 16.0), x86_64
    architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'NOTE: Python 3.x version used for these examples are Python 3.5.2 and the Python
    2.x version used is Python 2.7.12\. All examples are executed on a machine running
    the Linux (Ubuntu 16.0), 64 bit x86 architecture'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'NOTE: Most of the examples will use one version of code, which will run both
    in Python 2.x and Python 3.x. In cases where this is not possible, two versions
    of the code will be listed.'
  prefs: []
  type: TYPE_NORMAL
- en: Reading input
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let us look at this program that is a simple guessing game. It reads a number
    from the standard input, and compares it with a random number. If it matches,
    the user wins, otherwise, the user has to try again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is simple, except that it has some sensitive global data,
    which is the passwords of some users in the system. In a realistic example, these
    could be populated by some other functions, which read the passwords and cache
    them in memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us try the program with some standard inputs. We will initially run it
    with Python 2.7, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let us try a "non-standard" input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note how the preceding run exposed the global password data!
  prefs: []
  type: TYPE_NORMAL
- en: The problem is that in Python 2, the input value is evaluated as an expression
    without doing any check, and when it is printed, the expression prints its value.
    In this case, it happens to match a global variable, so its value is printed out.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let us look at this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now, not only has it exposed the passwords, it has exposed the complete global
    variables in the code including the passwords. Even if there were no sensitive
    data in the program, a hacker using this approach can reveal valuable information
    about the program such as variable names, function names, packages used, and so
    on.
  prefs: []
  type: TYPE_NORMAL
- en: 'What is the fix for this? For Python 2, one solution is to replace input, which
    evaluates its contents by passing directly to `eval`, with `raw_input`, which
    doesn''t evaluate the contents. Since `raw_input` doesn''t return a number, it
    needs to be converted to the target type. (This can be done by casting the return
    data to an `int`.) The following code does not only that, but also adds an exception
    handler for the type conversion for extra safety:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Let us see how this version fixes the security hole in evaluating inputs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The new program is now much more secure than the first version.
  prefs: []
  type: TYPE_NORMAL
- en: This problem is not there in Python 3.x as the following illustration shows.
    (We are using the original version to run this).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Evaluating arbitrary input
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `eval` function in Python is very powerful, but it is also dangerous, since
    it allows one to pass arbitrary strings to it, which can evaluate potentially
    dangerous code or commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us look at this rather silly piece of code as a test program to see what
    `eval` can do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Let us assume a scenario where an attacker is trying to exploit this piece of
    code to find out the contents of the directory where the application is running.
    (For time being you can assume the attacker can run this code via a web application,
    but hasn't got direct access to the machine itself).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assume the attacker tries to list the contents of the current folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This preceding attack doesn't work, because `eval` takes a second argument,
    which provides the global values to use during evaluation. Since in our code we
    are passing this second argument as an empty dictionary, we get the error, as
    Python is unable to resolve the `os` name.
  prefs: []
  type: TYPE_NORMAL
- en: So does this mean, `eval` is safe? No it's not. Let's see why.
  prefs: []
  type: TYPE_NORMAL
- en: What happens when we pass the following input to the code?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We can see that we are still able to coax `eval` to do our bidding by using
    the built-in function `__import__`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The reason why this works is because names such as `__import__` are available
    in the default built-in `__builtins__` global. We can deny `eval` this by specifically
    passing this as an empty dictionary via the second argument. Here is the modified
    version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the attacker is not able to exploit via the built-in `__import__`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'However, this doesn''t still make `eval` any safer, as it is open to slightly
    longer, but clever attacks. Here is one such attack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We are able to core dump the Python interpreter with a rather obscure looking
    piece of malicious code. How did this happen ?
  prefs: []
  type: TYPE_NORMAL
- en: Here is a somewhat detailed explanation of the steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s consider this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This is nothing but the base-class `object`. Since we don't have access to the
    built-ins, this is an indirect way to get access to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, the following line of code loads all the sub-classes of `object` currently
    loaded in the Python interpreter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Among them, what we want is the `code` object type. This can be accessed by
    checking the name of the item via the `__name__` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the same achieved by using an anonymous `lambda` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we want to execute this code object. However, `code` objects cannot be
    called directly. They need to be tied to a function in order for them to be called.
    This is achieved by wrapping the preceding `lambda` function in an outer `lambda`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now our inner `lambda` function can be called in two steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We finally invoke the `code` object via this outer `lambda` function by passing
    mostly default arguments. The code-string is passed as the string `BOOM`, which
    is, of course, a bogus code-string that causes the Python interpreter to segfault,
    producing a core-dump:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This shows that `eval` in any context, even bereft of built-in module support,
    is unsafe, and can be exploited by a clever and malicious hacker to crash the
    Python interpreter, and thereby, possibly gain control over the system.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the same exploit works in Python 3 as well, but we need some modification
    in the arguments to the `code` object, as in Python 3, `code` objects takes an
    extra argument. Also, the code-string and some arguments must be the `byte` type.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the exploit running on Python 3\. The end result is the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Overflow errors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Python 2, the `xrange()` function produces an overflow error if the range
    cannot fit into the integer range of Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The `range()` function also overflows with a slightly different error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The problem is that `xrange()` and `range()` use plain integer objects (type
    `<int>`) instead of automatically getting converted to the `long` type, which
    is limited only by the system memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, this problem is fixed in the Python 3.x versions, as types `int` and
    `long` are unified into one (`int` type), and the `range()` objects manage the
    memory internally. Also, there is no longer a separate `xrange()` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Here is another example of integer overflow errors in Python, this time for
    the `len` function.
  prefs: []
  type: TYPE_NORMAL
- en: In the following examples, we try the `len` function on instances of two classes
    A and B, whose magic method `__len__` has been over-ridden to provide support
    for the `len` function. Note that A is a new-style class, inheriting from `object`
    and B is an old-style class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output of the code when executed with Python2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The same code is executed in Python 3 as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The problem in the preceding code is that `len` returns `integer` objects, and
    in this case, the actual value is too large to fit inside an `int`, so Python
    raises an overflow error. In Python 2, however, for the case when the class is
    not derived from `object`, the code executed is slightly different, which anticipates
    an `int` object, but gets `long` and throws a `TypeError` instead. In Python 3,
    both examples return overflow errors.
  prefs: []
  type: TYPE_NORMAL
- en: Is there a security issue with integer overflow errors such as this?
  prefs: []
  type: TYPE_NORMAL
- en: On the ground, it depends on the application code and the dependent module code
    used, and how they are able to deal with or catch/mask the overflow errors.
  prefs: []
  type: TYPE_NORMAL
- en: However, since Python is written in C, any overflow errors which are not correctly
    handled in the underlying C code can lead to buffer overflow exceptions, where
    an attacker can write to the overflow buffer and hijack the underlying process/application.
  prefs: []
  type: TYPE_NORMAL
- en: Typically, if a module or data structure is able to handle the overflow error
    and raise exceptions preventing further code execution, the chances of code exploitation
    get reduced.
  prefs: []
  type: TYPE_NORMAL
- en: Serializing objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is very common for Python developers to use the `pickle` module and its C
    implementation cousin `cPickle` for serializing objects in Python. However, both
    these modules allow unchecked execution of code, as they don't enforce any kind
    of type check or rules on the objects being serialized to verify whether it is
    a benign Python object or a potential command that can exploit the system.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'NOTE: In Python3, both the `cPickle` and `pickle` modules are merged into a
    single `pickle` module.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an illustration via a shell exploit, which lists the contents of the
    root folder (`/`) in a Linux/POSIX system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The last code simply packages a `ShellExploit` class, which, upon pickling,
    returns the command for listing the contents of the root filesystem `/` by way
    of the `os.system()` method. The `Exploit` class thus masquerades malicious code
    into a `pickle` object, which, upon unpickling, executes the code, and exposes
    the contents of the root folder of the machine to the attacker. The output of
    the preceding code is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Serializing objects](../Images/image00466.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Output of the shell exploit code for serializing using pickle, exposing contents
    of / folder.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the output clearly lists the contents of the root folder.
  prefs: []
  type: TYPE_NORMAL
- en: What is the work-around to prevent such exploits?
  prefs: []
  type: TYPE_NORMAL
- en: First of all, don't use an unsafe module like `pickle` for serialization in
    your applications. Instead, rely on a safer alternative like `json` or `yaml`.
    If your application really is dependent on using the `pickle` module for some
    reason, then use sand-boxing software or `codeJail` to create safe environments
    that prevent execution of malicious code on the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, here is a slight modification of the earlier code, now with a
    simple chroot jail, which prevents code execution on the actual root folder. It
    uses a local `safe_root/` subfolder as the new root via a context-manager hook.
    Note that this is a simple-minded example. An actual jail would be much more elaborate
    than this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'With this jail in place, the code executes as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Serializing objects](../Images/image00467.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Output of the shell exploit code for serializing using pickle, with a simple
    chroot jail.
  prefs: []
  type: TYPE_NORMAL
- en: No output is produced now, because this is a fake jail, and Python cannot find
    the `ls` command in the new root. Of course, in order to make this work in a production
    system, a proper jail should be set up, which allows programs to execute, but
    at the same time, prevents or limits malicious program execution.
  prefs: []
  type: TYPE_NORMAL
- en: How about other serialization formats like JSON ? Can such exploits work with
    them ? Let us see using an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the same serialization code written using the `json` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Note how the default JSON encoder has been overridden using a custom encoder
    named `ExploitEncoder`. However, as the JSON format doesn''t support such serializations,
    it returns the correct serialization of the list passed as input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: With Python3, the exploit fails as Python3 raises an exception.
  prefs: []
  type: TYPE_NORMAL
- en: '![Serializing objects](../Images/image00468.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Output of the shell exploit code for serializing using json, with Python3
  prefs: []
  type: TYPE_NORMAL
- en: Security issues with web applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have seen four types of security issues with Python, namely, those
    with reading input, evaluating expressions, overflow errors, and serialization
    issues. All our examples so far have been with Python on the console.
  prefs: []
  type: TYPE_NORMAL
- en: However, almost all of us interact with web applications on a daily basis, many
    of which are written in Python web frameworks such as Django, Flask, Pyramid,
    and others. Hence, it is more likely that we are exposed to security issues in
    such applications. We will look at a few examples here.
  prefs: []
  type: TYPE_NORMAL
- en: Server Side Template Injection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Server Side Template Injection** (**SSTI**) is an attack using the server-side
    templates of common web frameworks as an attack vector. The attack uses weaknesses
    in the way user input is embedded on the templates. SSTI attacks can be used to
    figure out internals of a web application, execute shell commands, and even fully
    compromise the servers.'
  prefs: []
  type: TYPE_NORMAL
- en: We will see an example using a very popular web application framework in Python,
    namely, Flask.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the sample code for a rather simple-minded web application
    in Flask with an inline template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Running it on the console, and opening it in the browser allows us to play
    around with the `hello-ssti` route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'First, let us try some benign inputs:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Server Side Template Injection](../Images/image00469.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Here is another example.
  prefs: []
  type: TYPE_NORMAL
- en: '![Server Side Template Injection](../Images/image00470.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Next, let us try with some crafty inputs which an attacker may use.
  prefs: []
  type: TYPE_NORMAL
- en: '![Server Side Template Injection](../Images/image00471.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: What is happening here?
  prefs: []
  type: TYPE_NORMAL
- en: Since the template uses unsafe `%s` string templates, it evaluates anything
    that is passed to it into Python expressions. We passed `{{ person.secret }}`,
    which, in the Flask templating language (Flask uses Jinja2 templating), got evaluated
    to the value of the key secret in the dictionary `person`, effectively exposing
    the secret key of the app!
  prefs: []
  type: TYPE_NORMAL
- en: 'We can perform even more ambitious attacks, as this hole in the code allows
    an attacker to try the full power of Jinja templates, including for loops. Here
    is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Server Side Template Injection](../Images/image00472.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The URL used for the attack is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This goes through a for loop, and tries to print all contents of the `person`
    dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: This also allows an attacker easy access to the sensitive server-side configuration
    parameters. For example, he can print out the Flask configuration by passing the
    name parameter as `{{ config }}`.
  prefs: []
  type: TYPE_NORMAL
- en: Here is the image of the browser, printing the server configuration using this
    attack.
  prefs: []
  type: TYPE_NORMAL
- en: '![Server Side Template Injection](../Images/image00473.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Server-Side Template Injection – mitigation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We saw in the previous section some examples of using server side templates
    as an attack vector to expose sensitive information of the web application/server.
    In this section, we will see how the programmer can safeguard his code against
    such attacks.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this specific case, the fix for this is to use the specific variable that
    we want in the template rather than the dangerous, allow-all `%s` string. Here
    is the modified code with the fix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Now the earlier attacks all fizzle off.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the browser image for the first attack:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Server-Side Template Injection – mitigation](../Images/image00474.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Here is the browser image for the next attack.
  prefs: []
  type: TYPE_NORMAL
- en: '![Server-Side Template Injection – mitigation](../Images/image00475.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Denial of Service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now let us look at another attack that is commonly used by malicious hackers,
    namely, **Denial of Service** (**DOS**).
  prefs: []
  type: TYPE_NORMAL
- en: DoS attacks target vulnerable routes or URLs in a web application, and sends
    them crafty packets or URLs, which either force the server to perform infinite
    loops or CPU-intensive computations, or forces it to load huge amounts of data
    from databases, which puts a lot of load on the server CPU preventing the server
    from executing other requests.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A DDoS or distributed DoS attack is when the DoS attack is performed in a choreographed
    way using multiple systems targeting a single domain. Usually thousands of IP
    addresses are used, which are managed via botnets for a DDoS attack.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will see a minimal example of a DoS attack using a variation of our previous
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we use a global template variable named `TEMPLATE`, and
    use the `safer {{ person.name }}` template variable as the one used with the SSTI
    fix. However, the additional code here is a replacement of the holding name `FOO`
    with the name value.
  prefs: []
  type: TYPE_NORMAL
- en: This version has all the vulnerabilities of the original code, even with the
    `%s` code removed. For example, take a look at the following image of the browser
    exposing the `{{ person.secret }}` variable value in the body, but not in the
    title of the page.
  prefs: []
  type: TYPE_NORMAL
- en: '![Denial of Service](../Images/image00476.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This is due to this following line of code that we added as shown below.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Any expression passed is evaluated, including the arithmetic ones. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Denial of Service](../Images/image00477.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'This opens up pathways to simple DoS attacks by passing in CPU-intensive computations
    that the server cannot handle. For example, in the following attack we pass in
    a very large computation of a number, which occupies the CPU of the system, slows
    the system down and makes the application non-responsive:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Denial of Service](../Images/image00478.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: An example demonstrating a DoS style attack using computationally intensive
    code. The request never completes.
  prefs: []
  type: TYPE_NORMAL
- en: The URL used for this attack is `http://localhost:5000/hello-ssti?name=Tom`.
  prefs: []
  type: TYPE_NORMAL
- en: By passing in the arithmetical expression `{{ 100**100000000 }}`, which is computationally
    intensive, the server is overloaded and cannot handle other requests.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the previous image, the request never completes, and also
    prevents the server from responding to other requests; as you can see from how
    a normal request to the same application on a new tab opened on the right side
    is also held up causing the effect of a DoS style attack .
  prefs: []
  type: TYPE_NORMAL
- en: '![Denial of Service](../Images/image00479.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: A new tab opened on the right side of the tab with attack vector shows that
    the application has become unresponsive.
  prefs: []
  type: TYPE_NORMAL
- en: Cross-Site Scripting(XSS)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The code that we used in the earlier section to demonstrate a minimalistic
    DOS attack is also vulnerable to script injection. Here is an illustration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Cross-Site Scripting(XSS)](../Images/image00480.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: A simple demonstration of XSS scripting using server side templates and JavaScript
    injection
  prefs: []
  type: TYPE_NORMAL
- en: 'The URL used for this attack is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: These kinds of script injection vulnerabilities can lead to XSS, a common form
    of web exploit where attackers are able to inject malicious scripts into your
    server's code, which are loaded from other websites, and take control over it.
  prefs: []
  type: TYPE_NORMAL
- en: Mitigation – DoS and XSS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We saw a few examples of DoS attacks and simple XSS attacks in the previous
    section. Now let us look at how the programmer can take steps in his code to mitigate
    such attacks.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous specific example that we have used for illustration, the fix
    is to remove the line that replaces the string `FOO` with the name value, and
    to replace it with the parameter template itself. For good measure, we also make
    sure that the output is properly escaped by using the escape filter, `|e`, of
    Jinja 2\. Here is the rewritten code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Now that both of the vulnerabilities are mitigated, the attacks have no effect,
    and fail harmlessly.
  prefs: []
  type: TYPE_NORMAL
- en: Here is an image demonstrating the Dos attack .
  prefs: []
  type: TYPE_NORMAL
- en: '![Mitigation – DoS and XSS](../Images/image00481.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Here is the one, demonstrating the XSS attack.
  prefs: []
  type: TYPE_NORMAL
- en: '![Mitigation – DoS and XSS](../Images/image00482.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Similar vulnerabilities due to bad code in server side templates exist in other
    Python web frameworks such as Django, Pyramid, Tornado, and others. However, a
    step-by-step discussion on each of these is beyond the scope of this chapter.
    The interested reader is directed to security resources on the web discussing
    such issues.
  prefs: []
  type: TYPE_NORMAL
- en: Strategies for security – Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have discussed quite a few vulnerabilities that exist in the core Python
    programming language, and also taken a look at some of the common security issues
    affecting Python web applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'The time is ripe now to go through strategies—tips and techniques that a security
    architect can use so that their team can apply secure coding principles to mitigate
    security issues right from the stage of program design and development:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Reading input**: While reading console input, prefer rawinput over input,
    as the former doesn''t evaluate Python expressions, but returns input as plain
    strings. Any type conversions or validations should be done manually, and exceptions
    are thrown or errors returned if types don''t match. For reading passwords, use
    libraries such as getpass, and also perform validations on the returned data.
    Any evaluation of the data can be safely done once the validations succeed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Evaluating expressions**: As we''ve seen in our examples, eval always has
    loopholes whichever way it is used. Hence, the best strategy with Python is to
    avoid using evaland its evil cousin exec. If you have to use eval, make it a point
    to never use it with user input strings, or data read from third-party libraries,
    or APIs on which you have no control. Use eval only with input sources and return
    values from functions that you have control of and that you trust.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Serialization**: Don''t use `pickle` or `cPickle` for serialization. Favor
    other modules such JASON or YAML. If you absolutely have to use `pickle`/`cPickle`,
    use mitigation strategies such as a chroot jail or sandbox to avoid the bad effects
    of malicious code execution if any.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Overflow errors**: Guard against integer overflows by using exception handlers.
    Python doesn''t suffer from pure buffer overflow errors, as it always checks its
    containers for read/write access beyond the bounds and throws exceptions. For
    overridden `__len__` methods on classes, catch the overflow or `TypeError` exceptions
    as required.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**String formatting**: Prefer the newer and safer format method of template
    strings over the older and unsafe `%s` interpolation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '**Files**: When working with files, it is a good idea to use the with context
    managers to make sure that the file descriptors are closed after the operation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, favor this approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'And avoid the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: This will also ensure that the file descriptor is closed if any exception occurs
    during file read or write instead of keeping open file handles in the system.
  prefs: []
  type: TYPE_NORMAL
- en: '**Handling passwords and sensitive information**: When validating sensitive
    information like passwords, it is a good idea to compare cryptographic hashes
    rather than comparing the original data in memory:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This way, even if an attacker is able to pry out sensitive data from the program
    by exploits such as shell execution exploits or due to weaknesses in input data
    evaluation, the actual sensitive data is protected from immediate breach. Here
    is a simple approach for this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: A more cryptographically correct technique is to use strong password-hashing
    libraries with built-in salt and a fixed number of hashing rounds.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example using the `passlib` library in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'For the purpose of illustration, a `passwd.db` sqlite database has been created
    with two users and their passwords, as seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Strategies for security – Python](../Images/image00483.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here is the code in action:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that for purposes of clarity, the typed password is shown here—it won't
    be shown in the actual program, since it uses the `getpass` library.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '**Local data**: As much as possible, avoid storing sensitive data local to
    functions. Any input validation or evaluation loophole in the functions can be
    exploited then to gain access to the local stack, and hence, to the local data.
    Always store sensitive data encrypted or hashed separate modules.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is a simple illustration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The above function is unsafe for the secret key 'secret' as any attacker gaining
    access to the function's stack can gain access to the secret as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Such secrets are better kept in a separate module. If you are using the secret
    for hashing and verification the following code is much safer than the first,
    since it does not expose the original value of the ''secret'':'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '**Race conditions**: Python provides an excellent set of threading primitives.
    If your program uses multiple threads and shared resources, follow these guidelines
    to synchronize access to resources to avoid race conditions and deadlocks:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Protect resources that can be writeable concurrently by a mutex (`threading.Lock`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Protect resources that need to be serialized with respect to multiple, but limited,
    concurrent accesses by a semaphore (`threading.BoundedSemaphore`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use condition objects to wake up synchronize multiple threads waiting on a programmable
    condition or function ( threading.Condition)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid loops which sleep for a while, wake up and then poll for a condition or
    criterion. Instead synchronize using condition or event objects ( threading.Event)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For programs using multiple processes, similar counterparts provided by the
    `multiprocessing` library should be used to manage concurrent access to resources
  prefs: []
  type: TYPE_NORMAL
- en: '**Keep your system up to date**: Though this may sound cliched, keeping up
    to date with respect to security updates of packages in your system and with security
    news in general, especially on packages that impact your application, is a simple
    way to keep your system and application secure. A number of websites provide constant
    updates on the state of security of a number of opensource projects including
    Python and its standard library modules.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These reports usually go by the name of **Common Vulnerabilities and Exposures**
    (**CVEs**)—and sites such as Mitre ([http://cve.mitre.org](http://cve.mitre.org))
    provide a constant stream of updates.
  prefs: []
  type: TYPE_NORMAL
- en: 'A search for Python on this sites shows 213 results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Strategies for security – Python](../Images/image00484.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Results for 'python' keyword search on Mitre CVE list
  prefs: []
  type: TYPE_NORMAL
- en: Architects, devops engineers, and webmasters can also tune in to their system
    package updates, and keep security updates always enabled by default. For remote
    severs, upgrading to the latest security patches once in two to three months is
    highly recommended.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, the Python **Open Web Application Security Project** (**OWASP**)
    project is a free, third-party project aimed at creating a hardened version of
    Python more resilient to security threats than the standard Cpython. It is part
    of the larger OWASP initiative.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Python OWASP project makes available its Python bugreports, tools, and
    other artifacts via the website and associated GitHub projects. The main website
    for this is, and most of the code is available from the GitHub project page at:
    [https://github.com/ebranca/owasp-pysec/](https://github.com/ebranca/owasp-pysec/).![Strategies
    for security – Python](../Images/image00485.jpeg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Home page of the OWASP Python security project
  prefs: []
  type: TYPE_NORMAL
- en: It is a good idea for the stakeholders to keep track of this project, run their
    tests, and read their reports to keep up to date on Python security aspects.
  prefs: []
  type: TYPE_NORMAL
- en: Secure coding strategies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are coming towards the end of our discussion on the security aspects of software
    architecture. It is a good time to summarize the strategies that one should try
    and impart to a software development team from a security architect's point of
    view. The following is a table summarizing the top 10 of these. Some of these
    may seem repeated from our earlier discussions, as we have seen them before.
  prefs: []
  type: TYPE_NORMAL
- en: '| SL | Strategy | How it helps |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | Validate inputs | Validate inputs from all untrusted data sources. Proper
    input validation can eliminate a vast majority of software vulnerabilities. |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | Keep it simple | Keep program design as simple as possible. Complex designs
    increase the chances of security errors being made in their implementation, configuration,
    and deployment. |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | Principle of least privilege | Every process should execute with the
    least set of system privileges necessary to complete the work. For example, to
    read data from /tmp, one doesn''t need root permission, but any unprivileged user
    is fine. |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | Sanitize data | Sanitize data read from and sent to all third-party systems
    such as databases, command shells, COTs components, third-party middlewares, and
    so on. This lessens the chances of SQL injection, shell exploit, or other similar
    attacks. |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | Authorize access | Separate parts of your application by roles that need
    specific authentication via login or other privileges. Don''t mix different parts
    of applications together in the same code that requires different levels of access.
    Employ proper routing to make sure that no sensitive data is exposed via unprotected
    routes. |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | Perform effective QA | Good security testing techniques are effective
    in identifying and eliminating vulnerabilities. Fuzz testing, penetration testing,
    and source code audits should be performed as part of the program. |'
  prefs: []
  type: TYPE_TB
- en: '| 7 | Practice defense in layers | Mitigate risks with multiple layers of security.
    For example, combining secure programming techniques with secure runtime configuration
    will reduce the chances of any remaining code vulnerabilities being exposed in
    the runtime environment. |'
  prefs: []
  type: TYPE_TB
- en: '| 8 | Define security requirements | Identify and document the security constraints
    in the early lifecycle of the system, and keep updating them making sure that
    any further features down the line keep up with these requirements. |'
  prefs: []
  type: TYPE_TB
- en: '| 9 | Model threats | Use threat modeling to anticipate the threats to which
    the software will be subjected. |'
  prefs: []
  type: TYPE_TB
- en: '| 10 | Architect and design for security policies | Create and maintain a software
    architecture that enforces a pattern of consistent security policies across your
    system and its subsystems. |'
  prefs: []
  type: TYPE_TB
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we started with looking at the details of a system architecture
    that builds in security. We went on to define secure coding, and looked at the
    philosophies and principles behind the practice of secure coding.
  prefs: []
  type: TYPE_NORMAL
- en: We then studied the different types of common security vulnerabilities encountered
    in software systems, such as buffer overflows, input validation issues, access
    control issues, cryptographic weaknesses, information leaks, insecure file operations,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: We then went on to a detailed discussion on Python security issues with a lot
    of examples. We looked in detail at reading and evaluating input, overflow errors,
    and serialization issues. We then went on to look at the common vulnerabilities
    in Python web application frameworks with Flask being the candidate of choice.
    We saw how one can exploit the weaknesses on web application templates, and perform
    attacks such as SSTI, XSS, and DOS. We also saw multiple code examples of how
    to mitigate these attacks.
  prefs: []
  type: TYPE_NORMAL
- en: We then went on to list specific techniques in Python for writing secure code.
    We looked in detail at managing cryptographic hashes of passwords and other sensitive
    data in code, and discussed a couple of examples of doing this the right way.
    The importance of keeping oneself updated with security news and projects, and
    keeping the system updated with security patches was also mentioned.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we summarized the top 10 secure coding strategies that a security architect
    can impart to their team in order to create secure code and systems.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we take a look at one of the most interesting aspects of
    software engineering and design, namely that of design patterns.
  prefs: []
  type: TYPE_NORMAL
