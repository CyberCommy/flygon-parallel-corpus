- en: Chapter 6. Security – Writing Secure Code
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章 安全 - 编写安全代码
- en: Security of software applications (or lack of it) has been attracting a lot
    of importance in the past few years in the industry and the media. It looks like
    every other day, we hear about an instance or two of malicious hackers causing
    massive data breaches in software systems in different parts of the world, and
    causing millions of dollars worth of losses. The victims are either government
    departments, financial institutions, firms handling sensitive customer data such
    as passwords, credit cards, and so on.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 软件应用程序的安全性（或缺乏安全性）在过去几年在行业和媒体中引起了很大的重视。似乎每隔一天，我们都会听到恶意黑客在世界各地的软件系统中造成大规模数据泄露，并造成数百万美元的损失。受害者可能是政府部门、金融机构、处理敏感客户数据（如密码、信用卡等）的公司等。
- en: Software security and secure coding has assumed more importance than ever due
    to the unprecedented amounts of data being shared across software and hardware
    systems—the explosion of smart personal technologies such as smart phones, smart
    watches, smart music players, and other smart systems has created and aided this
    immense traffic of data across the Internet in a big way. With the advent of IPV6
    and expected large scale adoption of **IoT** devices (**Internet of Things**)
    in the next few years, the amount of data is only going to increase exponentially.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 由于软件和硬件系统之间共享的数据数量空前增加 - 智能个人技术（如智能手机、智能手表、智能音乐播放器等）的爆炸式增长，以及其他智能系统的出现和帮助，已经在互联网上大规模传播了大量数据。随着IPv6的出现和预计在未来几年大规模采用**物联网**设备（**物联网**）的数量将呈指数级增长，数据量只会不断增加。
- en: As we discussed in the first chapter, security is an important aspect of software
    architecture. Apart from architecting systems with secure principles, an architect
    should also try to imbibe their team with secure coding principles to minimize
    security pitfalls in the code written by their team.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在第一章中讨论的，安全是软件架构的一个重要方面。除了使用安全原则构建系统外，架构师还应该尝试灌输团队安全编码原则，以最小化团队编写的代码中的安全漏洞。
- en: In this chapter, we will look at the principles of architecting secure systems,
    and also look at tips and techniques for writing secure code in Python.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨构建安全系统的原则，并探讨在Python中编写安全代码的技巧和技术。
- en: The topics we will be discussing can be summed up in the following list.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论的主题可以总结如下列表。
- en: Information Security Architecture
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信息安全架构
- en: Secure Coding
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全编码
- en: Common Security Vulnerabilities
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见的安全漏洞
- en: Is Python Secure?
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python是否安全？
- en: Reading Input
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取输入
- en: Evaluating arbitrary Input
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评估任意输入
- en: Overflow Errors
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 溢出错误
- en: Serializing Objects
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 序列化对象
- en: Security issues with web applications
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web应用程序的安全问题
- en: Strategies for Security – Python
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全策略 - Python
- en: Secure Coding Strategies
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全编码策略
- en: Information Security architecture
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 信息安全架构
- en: 'A secure architecture involves creating a system that is able to provide access
    to data, and information to authorized people and systems while preventing any
    unauthorized access. Creating an architecture for information security for your
    systems involves the following aspects:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 安全架构涉及创建一个能够为授权人员和系统提供数据和信息访问权限的系统，同时防止任何未经授权的访问。为您的系统创建信息安全架构涉及以下方面：
- en: '**Confidentiality**: A set of rules or procedures that restricts the envelope
    of access to information in the system. Confidentiality ensures that data is not
    exposed to unauthorized access or modification.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**机密性**：一组规则或程序，限制对系统中信息的访问范围。机密性确保数据不会暴露给未经授权的访问或修改。'
- en: '**Integrity**: Integrity is the property of the system which ensures that the
    information channels are trustworthy and reliable and that the system is free
    from external manipulations. In other words, Integrity ensures the data can be
    trusted as it flows through the system across its components.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**完整性**：完整性是系统的属性，确保信息通道是可信赖和可靠的，并且系统没有外部操纵。换句话说，完整性确保数据在系统中的组件之间流动时是可信的。'
- en: '**Availability**: Property that the system will ensure a level of service to
    its authorized users according to its Service Level Agreements (SLAs). Availability
    ensures that the system will not deny service to its authorized users.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可用性**：系统将根据其服务级别协议（SLA）确保向其授权用户提供一定级别的服务的属性。可用性确保系统不会拒绝向其授权用户提供服务。'
- en: The three aspects of Confidentiality, Integrity, and Availability – often called
    the CIA triad form the corner stones of building an information security architecture
    for your system.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 机密性、完整性和可用性这三个方面，通常称为CIA三位一体，构成了为系统构建信息安全架构的基石。
- en: '![Information Security architecture](../Images/image00463.jpeg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![信息安全架构](../Images/image00463.jpeg)'
- en: CIA triad of Information Security Architecture
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 信息安全架构的CIA三位一体
- en: 'These aspects are aided by other characteristics, such as the following:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方面受到其他特征的支持，例如以下特征：
- en: '**Authentication**: Verifies the identity of the participants of a transaction,
    and ensures that they are actually those who they purport to be. Examples are
    digital certificates used in e-mail, public keys used to log in to systems, and
    the like.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**身份验证**：验证交易参与者的身份，并确保他们确实是他们所声称的人。例如，在电子邮件中使用的数字证书，用于登录系统的公钥等。'
- en: '**Authorization**: Gives rights to a specific user/role to perform a specific
    task or groups of related tasks. Authorization ensures that certain groups of
    users are tied to certain roles, which limit their access (read) and modification
    (write) rights in the system.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**授权**：授予特定用户/角色执行特定任务或相关任务组的权限。授权确保某些用户组与某些角色相关联，限制其在系统中的访问（读取）和修改（写入）权限。'
- en: '**Non-reputability**: Security techniques that guarantee that users involved
    in a transaction cannot later deny that the transaction happened. For example,
    a sender of an e-mail cannot later deny that they had sent the e-mail; a recipient
    of a bank funds transfer cannot later deny that they received the money, and so
    on.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Secure coding
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Secure coding is the practice of software development that guards programs against
    security vulnerabilities, and makes it resistant to malicious attacks right from
    program design to implementation. It is about writing code that is inherently
    secure as opposed to thinking of security as a layer which is added on later.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: 'The philosophies behind secure coding include the following:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Security is an aspect to be considered right from the design and development
    of a program or application; it is not an afterthought.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security requirements should be identified early in the development cycle, and
    these should be propagated to subsequent stages of development of the system to
    make sure that compliance is maintained.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Use threat modeling to anticipate security threats to the system from the beginning.
    Threat modeling involves the following:'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identifying important assets (code/data).
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Decomposing the application into components.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Identifying and categorizing threats to each asset or component.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ranking the threats based on an established risk model.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Developing threat mitigation strategies.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The practice or strategies of secure coding include the following main tasks:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '**Definition of areas of interest of the application**: Identify important
    assets in code/data of the application which are critical and needs to be secured.'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Analysis of software architecture**: Analyze the software architecture for
    obvious security flaws. Secure interaction between components with a view for
    ensuring data confidentiality and integrity. Ensure confidential data is protected
    via proper authentication and authorization techniques. Ensure availability is
    built into the architecture from ground up.'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Review of implementation details**: Review the code using secure coding techniques.
    Ensure peer review is done with a view to finding security holes. Provide feedback
    to the developer and ensure changes are made.'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Verification of logic and syntax**: Review code logic and syntax to ensure
    there are no obvious loop holes in the implementation. Make sure programming is
    done keeping with commonly available secure coding guidelines of the programming
    language/platform.'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Whitebox/Unit Testing**: The developer unit tests his code with security
    tests apart from tests ensuring functionality. Mock data and/or APIs can be used
    to virtualize third party data/API required for testing.'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Blackbox Testing**: The application is tested by an experienced QA engineer
    who looks for security loop holes such as unauthorized access to data, path ways
    accidentally exposing code and or data, weak passwords or hashes etc. The testing
    reports are fed back the stakeholders including the architect to make sure the
    loopholes identified are fixed.'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In reality, secure coding is a practice and a habit that software development
    organizations should inculcate through carefully developed and reviewed secure
    coding strategies such as the aforementioned over time.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Common security vulnerabilities
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So what are the common security vulnerabilities, a professional programmer
    today should be prepared to face and mitigate during the course of their career?
    Looking at the available literature, these can be organized into a few specific
    categories:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '**Overflow errors**: These include the popular and often abused **buffer overflow**
    errors, and the lesser known but still vulnerable **arithmetic or integer overflow**
    errors:'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The buffer overflow**: The buffer overflows are produced by programming errors
    that allow an application to write past the end or beginning of a buffer. The
    buffer overflows allow attackers to take control over systems by gaining access
    to the applications stack or heap memory by carefully crafted attack data.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The integer or arithmetic overflow**: These errors occur when an arithmetic
    or mathematical operation on integers produces a result that is too large for
    the maximum size of the type used to store it.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integer overflows can create security vulnerabilities if they are not properly
    handled. In programming languages supporting signed and unsigned integers, overflows
    can cause the data to wrap and produce negative numbers, allowing the attacker
    with a result similar to buffer overflows to gain access to heap or stack memory
    outside the program execution limits.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '**Unvalidated/Improperly validated input**: A very common security issue with
    modern web applications, unvalidated input can cause major vulnerabilities, where
    attackers can trick a program into accepting malicious input such as code data
    or system commands, which, when executed, can compromise a system. A system that
    aims to mitigate this type of attack should have filters to check and remove content
    that is malicious, and only accept data that is reasonable and safe to the system.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common subtypes of this type of attack include SQL injections, Server-Side Template
    Injections, **Cross-Site-Scripting** (**XSS**), and Shell Execution Exploits.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: Modern web application frameworks are vulnerable to this kind of attack due
    to use of HTML templates which mix code and data, but many of them have standard
    mitigation procedures such as escaping or filtering of input.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '**Improper access control**: Modern day applications should define separate
    roles for their classes of users, such as regular users, and those with special
    privileges, such as superusers or administrators. When an application fails to
    do this or does it incorrectly, it can expose routes (URLs) or workflows (series
    of actions specified by specific URLs containing attack vectors), which can either
    expose sensitive data to attackers, or, in the worst case, allow an attacker to
    compromise and take control of the system.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cryptography issues**: Simply ensuring that access control is in place is
    not enough for hardening and securing a system. Instead, the level and strength
    of security should be verified and ascertained, otherwise, your system can still
    be hacked or compromised. Some examples are as follows:'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**HTTP instead of HTTPS**: When implementing RestFUL web services, make sure
    you favor HTTPS (SSL/TLS) over HTTP. In HTTP, all communication is in plain text
    between the client and server, and can be easily captured by passive network sniffers
    or carefully crafted packet capture software or devices installed in routers.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Projects like letsencrypt have made life easy for system administrators for
    procuring and updating free SSL certificates, so securing your servers using SSL/TLS
    is easier these days than ever before.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '**Insecure authentication**: Prefer secure authentication techniques on a web
    server over insecure ones. For example, prefer HTTP Digest authentication to Basic
    authentication on web servers, as in the latter, passwords are sent in the clear.
    Similarly, use **Kerberos** authentication in a large shared network over less
    secure alternatives such as **Lightweight Directory Access Protocol** (**LDAP**)
    or **NT LAN Manager** (**NTLM**).'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use of weak passwords**: Easy-to-guess or default/trivial passwords are the
    bane of many modern-day web applications.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reuse of secure hashes/secret keys** – Secure hashes or secret keys are usually
    specific to an application or project and should never be reused across applications.
    Whenever required generate fresh hashes and or keys.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Weak encryption techniques**: Ciphers used in encrypting communication either
    on the server (SSL certificates) or personal computers (GPG/PGP keys) should use
    high-grade security – of at least 2048 bits and use peer-reviewed and crypto-safe
    algorithms.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**弱加密技术**：用于在服务器（SSL证书）或个人计算机（GPG/PGP密钥）上加密通信的密码应该使用高级别的安全性——至少2048位，并使用经过同行评审和加密安全的算法。'
- en: '**Weak hashing techniques**: Just as in ciphers, hashing techniques used to
    keep secrets and salts of sensitive data such as passwords should be careful in
    choosing strong algorithms. For example, if one is writing an application that
    requires hashes to be computed and stored today, they would be better off using
    the SHA-1 or SHA-2 algorithms rather than the weaker MD5.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**弱哈希技术**：就像密码一样，用于保持敏感数据（如密码）的哈希技术应该谨慎选择强大的算法。例如，如果今天编写一个需要计算和存储哈希的应用程序，最好使用SHA-1或SHA-2算法，而不是较弱的MD5。'
- en: '**Invalid or expired certificates/keys**: Web masters often forget to keep
    their SSL certificates updated, and this can become a big problem, compromising
    the security of their web servers, as invalid certificates offer no protection.
    Similarly, personal keys such as GPG or PGP public/private key pairs used for
    e-mail communication should be kept updated.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无效或过期的证书/密钥**：网站管理员经常忘记更新其SSL证书，这可能成为一个大问题，损害其Web服务器的安全性，因为无效的证书没有提供任何保护。类似地，用于电子邮件通信的个人密钥（如GPG或PGP公钥/私钥对）应该保持更新。'
- en: Password enabled SSH - SSH access to remote systems using clear text passwords
    is a security hole. Disable password based access and only enable access via authorized
    SSH keys for specific users only. Disable remote root SSH access.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 启用密码的SSH - 使用明文密码对远程系统进行SSH访问是一个安全漏洞。禁用基于密码的访问，只允许特定用户通过授权的SSH密钥进行访问。禁用远程root
    SSH访问。
- en: '**Information leak**: A lot of web servers systems—mostly due to open configuration,
    or misconfiguration, or due to lack of validation of inputs—can reveal a lot of
    information about themselves to an attacker. Some examples are as follows:'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**信息泄漏**：许多Web服务器系统——主要是由于开放配置、或配置错误、或由于缺乏对输入的验证——可以向攻击者泄露许多关于自身的信息。以下是一些例子：'
- en: '**Server meta information**: Many web servers leak information about themselves
    via their 404 pages, and sometimes, via their landing pages. Here is an example:![Common
    security vulnerabilities](../Images/image00464.jpeg)'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务器元信息**：许多Web服务器通过其404页面泄露有关自身的信息，有时还通过其登陆页面。以下是一个例子：![常见的安全漏洞](../Images/image00464.jpeg)'
- en: 404 page of a web server exposing server meta information
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 暴露服务器元信息的Web服务器404页面
- en: By simply requesting for a non-existing page, we came to know that the site
    seen in the preceding screenshot runs Apache version 2.4.10 on a Debian Server.
    For a crafty attacker, this is often information enough to try out specific attacks
    for that particular web-server/OS combination.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅通过请求一个不存在的页面，我们得知在前面截图中看到的网站在Debian服务器上运行Apache版本2.4.10。对于狡猾的攻击者来说，这通常已经足够提供特定攻击的信息，针对特定的Web服务器/操作系统组合。
- en: '**Open index pages**: Many websites don''t protect their directory pages, and
    leave them open for world access. This following image shows an example:![Common
    security vulnerabilities](../Images/image00465.jpeg)'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**打开索引页面**：许多网站不保护其目录页面，而是让它们对世界开放。以下图片显示了一个例子：![常见的安全漏洞](../Images/image00465.jpeg)'
- en: Open index page of a web server
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 打开Web服务器的索引页面
- en: '**Open ports**: It is a common error to provide world-access to application''s
    ports running on remote web servers instead of limiting access to them by specific
    IP addresses or security groups by using firewalls – such as *iptables*. A similar
    error is to allow a service to run on 0.0.0.0 (all IP addresses on the server)
    for a service which is only consumed on the localhost. This makes it easy for
    attackers to scan for such ports using network reconnaissance tools such as *nmap/hping3*,
    and the like, and plan their attack.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**打开端口**：常见的错误是在远程Web服务器上运行的应用程序端口提供全球访问权限，而不是通过使用防火墙（如*iptables*）限制它们的访问权限，例如特定IP地址或安全组。类似的错误是允许服务在0.0.0.0（服务器上的所有IP地址）上运行，而该服务仅在本地主机上使用。这使得攻击者可以使用网络侦察工具（如*nmap/hping3*等）扫描此类端口，并计划他们的攻击。'
- en: Open access to files/folders/databases - A very poor practice is to provide
    open or world access to application configuration files, log files, process ID
    files, and other artifacts so that any logged-in user can access and obtain information
    from these files. Instead, such files should be part of security policies to ensure
    that only specific roles with the required privileges have access to the files.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 对文件/文件夹/数据库开放访问 - 提供应用程序配置文件、日志文件、进程ID文件和其他文件的开放或全球访问是一个非常糟糕的做法，以便任何登录用户都可以访问并从这些文件中获取信息。相反，这些文件应该成为安全策略的一部分，以确保只有具有所需特权的特定角色可以访问这些文件。
- en: '**Race conditions**: A race condition exists when a program has two or more
    actors trying to access a certain resource, but the output depends on the correct
    order of access, which cannot be ensured. An example is two threads trying to
    increment a numerical value in shared memory without proper synchronization.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**竞争条件**：当程序有两个或更多的参与者试图访问某个资源，但输出取决于访问的正确顺序，而这不能得到保证时，就存在竞争条件。一个例子是两个线程试图在共享内存中递增一个数值而没有适当的同步。'
- en: Crafty attackers can take advantage of the situation to insert malicious code,
    change a filename, or sometimes, take advantage of small time gaps in the processing
    of code to interfere with the sequence of operations.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 狡猾的攻击者可以利用这种情况插入恶意代码，更改文件名，或者有时利用代码处理中的小时间间隙干扰操作的顺序。
- en: '**System clock drifts**: This is the phenomena where the system or local clock
    time on a server slowly drifts away from the reference time due to improper or
    missing synchronization. Over time, the clock drift can cause serious security
    flaws such as error in SSL certificate validation, which can be exploited by highly
    sophisticated techniques like *timing attacks* where an attacker tries to take
    control over the system by analyzing time taken to execute cryptographic algorithms.
    Time synchronization protocols like NTP can be used to mitigate this.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Insecure file/folder operations**: Programmers often make assumptions about
    the ownership, location, or attributes of a file or folder that might not be true
    in practice. This can result in conditions where a security flaw can occur or
    where we may not detect tampering with the system. Some examples are as follows:'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Failing to check results after a write operation assuming it succeeded
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assuming local file paths are always local files (whereas, they might be symbolic
    links to system files for which the application may not have access)
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improperly using sudo in executing system commands, which, if not done correctly,
    can cause loopholes, which can be used to gain root access of the system
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generous use of permissions on shared files or folders, for example, turning
    on all the execute bits of a program which should be limited to a group or open
    home folders which can be read by any logged in user
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using unsafe serialization and deserialization of code or data objects
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is beyond the scope of this chapter to visit each and every type of vulnerability
    in this list. However, we will make an earnest attempt to review and explain the
    common classes of software vulnerabilities that affect Python, and some of its
    web frameworks in the coming section.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: Is Python secure?
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python is a very readable language with simple syntax, and typically, one clearly
    stated way to do things. It comes with a set of well-tested and compact standard
    library modules. All of this seems to indicate that Python should be a very secure
    language.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: But is it so?
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: Let us look at a few examples in Python, and try to analyze the security aspect
    of Python and its standard libraries.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: For the purposes of usefulness, we will demonstrate the code examples shown
    in this section using both Python 2.x and Python 3.x versions. This is because
    a number of security vulnerabilities that are present in Python 2.x versions are
    fixed in the recent 3.x versions. However, since many Python developers are still
    using some form or the other of Python 2.x, the code examples would be useful
    to them, and also illustrate the importance of migrating to Python 3.x.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: 'All examples are executed on a machine running the Linux (Ubuntu 16.0), x86_64
    architecture:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'NOTE: Python 3.x version used for these examples are Python 3.5.2 and the Python
    2.x version used is Python 2.7.12\. All examples are executed on a machine running
    the Linux (Ubuntu 16.0), 64 bit x86 architecture'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'NOTE: Most of the examples will use one version of code, which will run both
    in Python 2.x and Python 3.x. In cases where this is not possible, two versions
    of the code will be listed.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: Reading input
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let us look at this program that is a simple guessing game. It reads a number
    from the standard input, and compares it with a random number. If it matches,
    the user wins, otherwise, the user has to try again:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The preceding code is simple, except that it has some sensitive global data,
    which is the passwords of some users in the system. In a realistic example, these
    could be populated by some other functions, which read the passwords and cache
    them in memory.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us try the program with some standard inputs. We will initially run it
    with Python 2.7, as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, let us try a "non-standard" input:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note how the preceding run exposed the global password data!
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: The problem is that in Python 2, the input value is evaluated as an expression
    without doing any check, and when it is printed, the expression prints its value.
    In this case, it happens to match a global variable, so its value is printed out.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于在Python 2中，输入值被评估为一个表达式而不进行任何检查，当它被打印时，表达式打印出它的值。在这种情况下，它恰好匹配一个全局变量，所以它的值被打印出来。
- en: 'Now let us look at this one:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看这个：
- en: '[PRE5]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now, not only has it exposed the passwords, it has exposed the complete global
    variables in the code including the passwords. Even if there were no sensitive
    data in the program, a hacker using this approach can reveal valuable information
    about the program such as variable names, function names, packages used, and so
    on.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，它不仅暴露了密码，还暴露了代码中的完整全局变量，包括密码。即使程序中没有敏感数据，使用这种方法的黑客也可以揭示有关程序的有价值的信息，如变量名、函数名、使用的包等等。
- en: 'What is the fix for this? For Python 2, one solution is to replace input, which
    evaluates its contents by passing directly to `eval`, with `raw_input`, which
    doesn''t evaluate the contents. Since `raw_input` doesn''t return a number, it
    needs to be converted to the target type. (This can be done by casting the return
    data to an `int`.) The following code does not only that, but also adds an exception
    handler for the type conversion for extra safety:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题的解决方案是什么？对于Python 2，一个解决方案是用`raw_input`替换`input`，`raw_input`不评估内容。由于`raw_input`不返回数字，需要将其转换为目标类型。（可以通过将返回数据转换为`int`来完成。）以下代码不仅完成了这一点，还为类型转换添加了异常处理程序以提高安全性：
- en: '[PRE6]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Let us see how this version fixes the security hole in evaluating inputs
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个版本如何修复评估输入的安全漏洞
- en: '[PRE7]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The new program is now much more secure than the first version.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 新程序现在比第一个版本安全得多。
- en: This problem is not there in Python 3.x as the following illustration shows.
    (We are using the original version to run this).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题在Python 3.x中不存在，如下图所示。（我们使用原始版本来运行这个）。
- en: '[PRE8]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Evaluating arbitrary input
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 评估任意输入
- en: The `eval` function in Python is very powerful, but it is also dangerous, since
    it allows one to pass arbitrary strings to it, which can evaluate potentially
    dangerous code or commands.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Python中的`eval`函数非常强大，但也很危险，因为它允许将任意字符串传递给它，这可能会评估潜在危险的代码或命令。
- en: 'Let us look at this rather silly piece of code as a test program to see what
    `eval` can do:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个相当愚蠢的代码作为一个测试程序，看看`eval`能做什么：
- en: '[PRE9]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Let us assume a scenario where an attacker is trying to exploit this piece of
    code to find out the contents of the directory where the application is running.
    (For time being you can assume the attacker can run this code via a web application,
    but hasn't got direct access to the machine itself).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设一个攻击者试图利用这段代码来查找应用程序运行的目录的内容。（暂时可以假设攻击者可以通过Web应用程序运行此代码，但没有直接访问机器本身）。
- en: 'Let''s assume the attacker tries to list the contents of the current folder:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 假设攻击者试图列出当前文件夹的内容：
- en: '[PRE10]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This preceding attack doesn't work, because `eval` takes a second argument,
    which provides the global values to use during evaluation. Since in our code we
    are passing this second argument as an empty dictionary, we get the error, as
    Python is unable to resolve the `os` name.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这个先前的攻击不起作用，因为`eval`需要一个第二个参数，在评估过程中提供要使用的全局值。由于在我们的代码中，我们将这个第二个参数作为空字典传递，我们会得到错误，因为Python无法解析`os`名称。
- en: So does this mean, `eval` is safe? No it's not. Let's see why.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这是否意味着`eval`是安全的？不，它不是。让我们看看为什么。
- en: What happens when we pass the following input to the code?
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将以下输入传递给代码时会发生什么？
- en: '[PRE11]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We can see that we are still able to coax `eval` to do our bidding by using
    the built-in function `__import__`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，我们仍然能够通过使用内置函数`__import__`来诱使`eval`执行我们的命令。
- en: 'The reason why this works is because names such as `__import__` are available
    in the default built-in `__builtins__` global. We can deny `eval` this by specifically
    passing this as an empty dictionary via the second argument. Here is the modified
    version:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的原因是因为像`__import__`这样的名称在默认内置的`__builtins__`全局中是可用的。我们可以通过将其作为空字典传递给第二个参数来拒绝`eval`。这是修改后的版本：
- en: '[PRE12]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now the attacker is not able to exploit via the built-in `__import__`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在攻击者无法通过内置的`__import__`进行利用：
- en: '[PRE13]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'However, this doesn''t still make `eval` any safer, as it is open to slightly
    longer, but clever attacks. Here is one such attack:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不意味着`eval`更安全，因为它容易受到稍长一点但聪明的攻击。以下是这样一种攻击：
- en: '[PRE14]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We are able to core dump the Python interpreter with a rather obscure looking
    piece of malicious code. How did this happen ?
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能够使用一个看起来相当晦涩的恶意代码来使Python解释器崩溃。这是怎么发生的？
- en: Here is a somewhat detailed explanation of the steps.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是步骤的一些详细解释。
- en: 'First, let''s consider this:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们考虑一下这个：
- en: '[PRE15]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This is nothing but the base-class `object`. Since we don't have access to the
    built-ins, this is an indirect way to get access to it.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是基类`object`。由于我们无法访问内置函数，这是一种间接访问它的方法。
- en: 'Next, the following line of code loads all the sub-classes of `object` currently
    loaded in the Python interpreter:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，以下代码行加载了Python解释器中当前加载的`object`的所有子类：
- en: '[PRE16]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Among them, what we want is the `code` object type. This can be accessed by
    checking the name of the item via the `__name__` attribute:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，我们想要的是`code`对象类型。这可以通过检查项目的名称通过`__name__`属性来访问：
- en: '[PRE17]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here is the same achieved by using an anonymous `lambda` function:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过使用匿名`lambda`函数实现的相同效果：
- en: '[PRE18]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Next, we want to execute this code object. However, `code` objects cannot be
    called directly. They need to be tied to a function in order for them to be called.
    This is achieved by wrapping the preceding `lambda` function in an outer `lambda`
    function:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们想要执行这个代码对象。然而，`code`对象不能直接调用。它们需要绑定到一个函数才能被调用。这是通过将前面的`lambda`函数包装在外部`lambda`函数中实现的：
- en: '[PRE19]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now our inner `lambda` function can be called in two steps:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的内部`lambda`函数可以分两步调用：
- en: '[PRE20]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We finally invoke the `code` object via this outer `lambda` function by passing
    mostly default arguments. The code-string is passed as the string `BOOM`, which
    is, of course, a bogus code-string that causes the Python interpreter to segfault,
    producing a core-dump:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过这个外部的`lambda`函数调用`code`对象，传递了大多数默认参数。代码字符串被传递为字符串`BOOM`，当然，这是一个虚假的代码字符串，会导致Python解释器崩溃，产生核心转储：
- en: '[PRE21]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This shows that `eval` in any context, even bereft of built-in module support,
    is unsafe, and can be exploited by a clever and malicious hacker to crash the
    Python interpreter, and thereby, possibly gain control over the system.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明在任何情况下，即使没有内置模块的支持，`eval`都是不安全的，并且可以被聪明而恶意的黑客利用来使Python解释器崩溃，从而可能控制系统。
- en: Note that the same exploit works in Python 3 as well, but we need some modification
    in the arguments to the `code` object, as in Python 3, `code` objects takes an
    extra argument. Also, the code-string and some arguments must be the `byte` type.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，相同的利用在Python 3中也有效，但是我们需要对`code`对象的参数进行一些修改，因为在Python 3中，`code`对象需要额外的参数。此外，代码字符串和一些参数必须是`byte`类型。
- en: 'The following is the exploit running on Python 3\. The end result is the same:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在Python 3上运行的利用。最终结果是相同的：
- en: '[PRE22]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Overflow errors
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 溢出错误
- en: 'In Python 2, the `xrange()` function produces an overflow error if the range
    cannot fit into the integer range of Python:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python 2中，如果`xrange()`函数的范围无法适应Python的整数范围，则会产生溢出错误：
- en: '[PRE23]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `range()` function also overflows with a slightly different error:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`range()`函数也会出现略有不同的溢出错误：'
- en: '[PRE24]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The problem is that `xrange()` and `range()` use plain integer objects (type
    `<int>`) instead of automatically getting converted to the `long` type, which
    is limited only by the system memory.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于`xrange()`和`range()`使用普通整数对象（类型`<int>`），而不是自动转换为仅受系统内存限制的`long`类型。
- en: 'However, this problem is fixed in the Python 3.x versions, as types `int` and
    `long` are unified into one (`int` type), and the `range()` objects manage the
    memory internally. Also, there is no longer a separate `xrange()` object:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在Python 3.x版本中，这个问题已经得到解决，因为类型`int`和`long`被统一为一个（`int`类型），而`range()`对象在内部管理内存。此外，不再有单独的`xrange()`对象：
- en: '[PRE25]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Here is another example of integer overflow errors in Python, this time for
    the `len` function.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Python中整数溢出错误的另一个例子，这次是针对`len`函数。
- en: In the following examples, we try the `len` function on instances of two classes
    A and B, whose magic method `__len__` has been over-ridden to provide support
    for the `len` function. Note that A is a new-style class, inheriting from `object`
    and B is an old-style class.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们尝试对两个类A和B的实例使用`len`函数，这两个类的魔术方法`__len__`已被覆盖以支持`len`函数。请注意，A是一个新式类，继承自`object`，而B是一个旧式类。
- en: '[PRE26]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Here is the output of the code when executed with Python2:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在Python2中执行代码时的输出：
- en: '[PRE27]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The same code is executed in Python 3 as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python 3中执行相同的代码如下：
- en: '[PRE28]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The problem in the preceding code is that `len` returns `integer` objects, and
    in this case, the actual value is too large to fit inside an `int`, so Python
    raises an overflow error. In Python 2, however, for the case when the class is
    not derived from `object`, the code executed is slightly different, which anticipates
    an `int` object, but gets `long` and throws a `TypeError` instead. In Python 3,
    both examples return overflow errors.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中的问题在于`len`返回`integer`对象，在这种情况下，实际值太大而无法适应`int`，因此Python引发了溢出错误。然而，在Python
    2中，对于未从`object`派生的类的情况，执行的代码略有不同，它预期一个`int`对象，但得到了`long`并抛出了`TypeError`。在Python
    3中，这两个示例都返回溢出错误。
- en: Is there a security issue with integer overflow errors such as this?
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的整数溢出错误是否存在安全问题？
- en: On the ground, it depends on the application code and the dependent module code
    used, and how they are able to deal with or catch/mask the overflow errors.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际情况中，这取决于应用程序代码和所使用的依赖模块代码，以及它们如何处理或捕获/掩盖溢出错误。
- en: However, since Python is written in C, any overflow errors which are not correctly
    handled in the underlying C code can lead to buffer overflow exceptions, where
    an attacker can write to the overflow buffer and hijack the underlying process/application.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于Python是用C编写的，任何在底层C代码中没有正确处理的溢出错误都可能导致缓冲区溢出异常，攻击者可以向溢出缓冲区写入并劫持底层进程/应用程序。
- en: Typically, if a module or data structure is able to handle the overflow error
    and raise exceptions preventing further code execution, the chances of code exploitation
    get reduced.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，如果一个模块或数据结构能够处理溢出错误并引发异常以阻止进一步的代码执行，那么代码利用的可能性就会减少。
- en: Serializing objects
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象序列化
- en: It is very common for Python developers to use the `pickle` module and its C
    implementation cousin `cPickle` for serializing objects in Python. However, both
    these modules allow unchecked execution of code, as they don't enforce any kind
    of type check or rules on the objects being serialized to verify whether it is
    a benign Python object or a potential command that can exploit the system.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Python开发人员来说，使用`pickle`模块及其C实现的`cPickle`来对Python中的对象进行序列化是非常常见的。然而，这两个模块都允许未经检查的代码执行，因为它们不对被序列化的对象进行任何类型检查或规则的强制，以验证它是一个良性的Python对象还是一个可能利用系统的潜在命令。
- en: Note
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'NOTE: In Python3, both the `cPickle` and `pickle` modules are merged into a
    single `pickle` module.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在Python3中，`cPickle`和`pickle`模块合并为一个单独的`pickle`模块。
- en: 'Here is an illustration via a shell exploit, which lists the contents of the
    root folder (`/`) in a Linux/POSIX system:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过shell利用的示例，它列出了Linux/POSIX系统中根文件夹（/）的内容：
- en: '[PRE29]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The last code simply packages a `ShellExploit` class, which, upon pickling,
    returns the command for listing the contents of the root filesystem `/` by way
    of the `os.system()` method. The `Exploit` class thus masquerades malicious code
    into a `pickle` object, which, upon unpickling, executes the code, and exposes
    the contents of the root folder of the machine to the attacker. The output of
    the preceding code is shown here:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '![Serializing objects](../Images/image00466.jpeg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
- en: Output of the shell exploit code for serializing using pickle, exposing contents
    of / folder.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the output clearly lists the contents of the root folder.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: What is the work-around to prevent such exploits?
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: First of all, don't use an unsafe module like `pickle` for serialization in
    your applications. Instead, rely on a safer alternative like `json` or `yaml`.
    If your application really is dependent on using the `pickle` module for some
    reason, then use sand-boxing software or `codeJail` to create safe environments
    that prevent execution of malicious code on the system.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, here is a slight modification of the earlier code, now with a
    simple chroot jail, which prevents code execution on the actual root folder. It
    uses a local `safe_root/` subfolder as the new root via a context-manager hook.
    Note that this is a simple-minded example. An actual jail would be much more elaborate
    than this:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'With this jail in place, the code executes as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '![Serializing objects](../Images/image00467.jpeg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
- en: Output of the shell exploit code for serializing using pickle, with a simple
    chroot jail.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: No output is produced now, because this is a fake jail, and Python cannot find
    the `ls` command in the new root. Of course, in order to make this work in a production
    system, a proper jail should be set up, which allows programs to execute, but
    at the same time, prevents or limits malicious program execution.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: How about other serialization formats like JSON ? Can such exploits work with
    them ? Let us see using an example.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the same serialization code written using the `json` module:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Note how the default JSON encoder has been overridden using a custom encoder
    named `ExploitEncoder`. However, as the JSON format doesn''t support such serializations,
    it returns the correct serialization of the list passed as input:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: With Python3, the exploit fails as Python3 raises an exception.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '![Serializing objects](../Images/image00468.jpeg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
- en: Output of the shell exploit code for serializing using json, with Python3
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Security issues with web applications
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have seen four types of security issues with Python, namely, those
    with reading input, evaluating expressions, overflow errors, and serialization
    issues. All our examples so far have been with Python on the console.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: However, almost all of us interact with web applications on a daily basis, many
    of which are written in Python web frameworks such as Django, Flask, Pyramid,
    and others. Hence, it is more likely that we are exposed to security issues in
    such applications. We will look at a few examples here.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: Server Side Template Injection
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Server Side Template Injection** (**SSTI**) is an attack using the server-side
    templates of common web frameworks as an attack vector. The attack uses weaknesses
    in the way user input is embedded on the templates. SSTI attacks can be used to
    figure out internals of a web application, execute shell commands, and even fully
    compromise the servers.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: We will see an example using a very popular web application framework in Python,
    namely, Flask.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the sample code for a rather simple-minded web application
    in Flask with an inline template:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Running it on the console, and opening it in the browser allows us to play
    around with the `hello-ssti` route:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'First, let us try some benign inputs:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '![Server Side Template Injection](../Images/image00469.jpeg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
- en: Here is another example.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '![Server Side Template Injection](../Images/image00470.jpeg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
- en: Next, let us try with some crafty inputs which an attacker may use.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '![Server Side Template Injection](../Images/image00471.jpeg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
- en: What is happening here?
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: Since the template uses unsafe `%s` string templates, it evaluates anything
    that is passed to it into Python expressions. We passed `{{ person.secret }}`,
    which, in the Flask templating language (Flask uses Jinja2 templating), got evaluated
    to the value of the key secret in the dictionary `person`, effectively exposing
    the secret key of the app!
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: 'We can perform even more ambitious attacks, as this hole in the code allows
    an attacker to try the full power of Jinja templates, including for loops. Here
    is an example:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '![Server Side Template Injection](../Images/image00472.jpeg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
- en: 'The URL used for the attack is as follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This goes through a for loop, and tries to print all contents of the `person`
    dictionary.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: This also allows an attacker easy access to the sensitive server-side configuration
    parameters. For example, he can print out the Flask configuration by passing the
    name parameter as `{{ config }}`.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: Here is the image of the browser, printing the server configuration using this
    attack.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '![Server Side Template Injection](../Images/image00473.jpeg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
- en: Server-Side Template Injection – mitigation
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We saw in the previous section some examples of using server side templates
    as an attack vector to expose sensitive information of the web application/server.
    In this section, we will see how the programmer can safeguard his code against
    such attacks.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: 'In this specific case, the fix for this is to use the specific variable that
    we want in the template rather than the dangerous, allow-all `%s` string. Here
    is the modified code with the fix:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Now the earlier attacks all fizzle off.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the browser image for the first attack:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '![Server-Side Template Injection – mitigation](../Images/image00474.jpeg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
- en: Here is the browser image for the next attack.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '![Server-Side Template Injection – mitigation](../Images/image00475.jpeg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
- en: Denial of Service
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now let us look at another attack that is commonly used by malicious hackers,
    namely, **Denial of Service** (**DOS**).
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: DoS attacks target vulnerable routes or URLs in a web application, and sends
    them crafty packets or URLs, which either force the server to perform infinite
    loops or CPU-intensive computations, or forces it to load huge amounts of data
    from databases, which puts a lot of load on the server CPU preventing the server
    from executing other requests.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A DDoS or distributed DoS attack is when the DoS attack is performed in a choreographed
    way using multiple systems targeting a single domain. Usually thousands of IP
    addresses are used, which are managed via botnets for a DDoS attack.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: 'We will see a minimal example of a DoS attack using a variation of our previous
    example:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In the preceding code, we use a global template variable named `TEMPLATE`, and
    use the `safer {{ person.name }}` template variable as the one used with the SSTI
    fix. However, the additional code here is a replacement of the holding name `FOO`
    with the name value.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: This version has all the vulnerabilities of the original code, even with the
    `%s` code removed. For example, take a look at the following image of the browser
    exposing the `{{ person.secret }}` variable value in the body, but not in the
    title of the page.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '![Denial of Service](../Images/image00476.jpeg)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
- en: This is due to this following line of code that we added as shown below.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Any expression passed is evaluated, including the arithmetic ones. For example:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '![Denial of Service](../Images/image00477.jpeg)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
- en: 'This opens up pathways to simple DoS attacks by passing in CPU-intensive computations
    that the server cannot handle. For example, in the following attack we pass in
    a very large computation of a number, which occupies the CPU of the system, slows
    the system down and makes the application non-responsive:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '![Denial of Service](../Images/image00478.jpeg)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
- en: An example demonstrating a DoS style attack using computationally intensive
    code. The request never completes.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: The URL used for this attack is `http://localhost:5000/hello-ssti?name=Tom`.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: By passing in the arithmetical expression `{{ 100**100000000 }}`, which is computationally
    intensive, the server is overloaded and cannot handle other requests.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the previous image, the request never completes, and also
    prevents the server from responding to other requests; as you can see from how
    a normal request to the same application on a new tab opened on the right side
    is also held up causing the effect of a DoS style attack .
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '![Denial of Service](../Images/image00479.jpeg)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
- en: A new tab opened on the right side of the tab with attack vector shows that
    the application has become unresponsive.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: Cross-Site Scripting(XSS)
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The code that we used in the earlier section to demonstrate a minimalistic
    DOS attack is also vulnerable to script injection. Here is an illustration:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '![Cross-Site Scripting(XSS)](../Images/image00480.jpeg)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
- en: A simple demonstration of XSS scripting using server side templates and JavaScript
    injection
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: 'The URL used for this attack is:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: These kinds of script injection vulnerabilities can lead to XSS, a common form
    of web exploit where attackers are able to inject malicious scripts into your
    server's code, which are loaded from other websites, and take control over it.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: Mitigation – DoS and XSS
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We saw a few examples of DoS attacks and simple XSS attacks in the previous
    section. Now let us look at how the programmer can take steps in his code to mitigate
    such attacks.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous specific example that we have used for illustration, the fix
    is to remove the line that replaces the string `FOO` with the name value, and
    to replace it with the parameter template itself. For good measure, we also make
    sure that the output is properly escaped by using the escape filter, `|e`, of
    Jinja 2\. Here is the rewritten code:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Now that both of the vulnerabilities are mitigated, the attacks have no effect,
    and fail harmlessly.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: Here is an image demonstrating the Dos attack .
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '![Mitigation – DoS and XSS](../Images/image00481.jpeg)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
- en: Here is the one, demonstrating the XSS attack.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '![Mitigation – DoS and XSS](../Images/image00482.jpeg)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
- en: Similar vulnerabilities due to bad code in server side templates exist in other
    Python web frameworks such as Django, Pyramid, Tornado, and others. However, a
    step-by-step discussion on each of these is beyond the scope of this chapter.
    The interested reader is directed to security resources on the web discussing
    such issues.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: Strategies for security – Python
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have discussed quite a few vulnerabilities that exist in the core Python
    programming language, and also taken a look at some of the common security issues
    affecting Python web applications.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: 'The time is ripe now to go through strategies—tips and techniques that a security
    architect can use so that their team can apply secure coding principles to mitigate
    security issues right from the stage of program design and development:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '**Reading input**: While reading console input, prefer rawinput over input,
    as the former doesn''t evaluate Python expressions, but returns input as plain
    strings. Any type conversions or validations should be done manually, and exceptions
    are thrown or errors returned if types don''t match. For reading passwords, use
    libraries such as getpass, and also perform validations on the returned data.
    Any evaluation of the data can be safely done once the validations succeed.'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Evaluating expressions**: As we''ve seen in our examples, eval always has
    loopholes whichever way it is used. Hence, the best strategy with Python is to
    avoid using evaland its evil cousin exec. If you have to use eval, make it a point
    to never use it with user input strings, or data read from third-party libraries,
    or APIs on which you have no control. Use eval only with input sources and return
    values from functions that you have control of and that you trust.'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Serialization**: Don''t use `pickle` or `cPickle` for serialization. Favor
    other modules such JASON or YAML. If you absolutely have to use `pickle`/`cPickle`,
    use mitigation strategies such as a chroot jail or sandbox to avoid the bad effects
    of malicious code execution if any.'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Overflow errors**: Guard against integer overflows by using exception handlers.
    Python doesn''t suffer from pure buffer overflow errors, as it always checks its
    containers for read/write access beyond the bounds and throws exceptions. For
    overridden `__len__` methods on classes, catch the overflow or `TypeError` exceptions
    as required.'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**String formatting**: Prefer the newer and safer format method of template
    strings over the older and unsafe `%s` interpolation.'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '**Files**: When working with files, it is a good idea to use the with context
    managers to make sure that the file descriptors are closed after the operation.'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, favor this approach:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'And avoid the following:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This will also ensure that the file descriptor is closed if any exception occurs
    during file read or write instead of keeping open file handles in the system.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '**Handling passwords and sensitive information**: When validating sensitive
    information like passwords, it is a good idea to compare cryptographic hashes
    rather than comparing the original data in memory:'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This way, even if an attacker is able to pry out sensitive data from the program
    by exploits such as shell execution exploits or due to weaknesses in input data
    evaluation, the actual sensitive data is protected from immediate breach. Here
    is a simple approach for this:'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: A more cryptographically correct technique is to use strong password-hashing
    libraries with built-in salt and a fixed number of hashing rounds.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example using the `passlib` library in Python:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'For the purpose of illustration, a `passwd.db` sqlite database has been created
    with two users and their passwords, as seen in the following screenshot:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '![Strategies for security – Python](../Images/image00483.jpeg)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
- en: 'Here is the code in action:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-302
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that for purposes of clarity, the typed password is shown here—it won't
    be shown in the actual program, since it uses the `getpass` library.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code in action:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '**Local data**: As much as possible, avoid storing sensitive data local to
    functions. Any input validation or evaluation loophole in the functions can be
    exploited then to gain access to the local stack, and hence, to the local data.
    Always store sensitive data encrypted or hashed separate modules.'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is a simple illustration:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The above function is unsafe for the secret key 'secret' as any attacker gaining
    access to the function's stack can gain access to the secret as well.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: 'Such secrets are better kept in a separate module. If you are using the secret
    for hashing and verification the following code is much safer than the first,
    since it does not expose the original value of the ''secret'':'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '**Race conditions**: Python provides an excellent set of threading primitives.
    If your program uses multiple threads and shared resources, follow these guidelines
    to synchronize access to resources to avoid race conditions and deadlocks:'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Protect resources that can be writeable concurrently by a mutex (`threading.Lock`)
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Protect resources that need to be serialized with respect to multiple, but limited,
    concurrent accesses by a semaphore (`threading.BoundedSemaphore`)
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use condition objects to wake up synchronize multiple threads waiting on a programmable
    condition or function ( threading.Condition)
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid loops which sleep for a while, wake up and then poll for a condition or
    criterion. Instead synchronize using condition or event objects ( threading.Event)
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For programs using multiple processes, similar counterparts provided by the
    `multiprocessing` library should be used to manage concurrent access to resources
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: '**Keep your system up to date**: Though this may sound cliched, keeping up
    to date with respect to security updates of packages in your system and with security
    news in general, especially on packages that impact your application, is a simple
    way to keep your system and application secure. A number of websites provide constant
    updates on the state of security of a number of opensource projects including
    Python and its standard library modules.'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These reports usually go by the name of **Common Vulnerabilities and Exposures**
    (**CVEs**)—and sites such as Mitre ([http://cve.mitre.org](http://cve.mitre.org))
    provide a constant stream of updates.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: 'A search for Python on this sites shows 213 results:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: '![Strategies for security – Python](../Images/image00484.jpeg)'
  id: totrans-321
  prefs: []
  type: TYPE_IMG
- en: Results for 'python' keyword search on Mitre CVE list
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: Architects, devops engineers, and webmasters can also tune in to their system
    package updates, and keep security updates always enabled by default. For remote
    severs, upgrading to the latest security patches once in two to three months is
    highly recommended.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, the Python **Open Web Application Security Project** (**OWASP**)
    project is a free, third-party project aimed at creating a hardened version of
    Python more resilient to security threats than the standard Cpython. It is part
    of the larger OWASP initiative.
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Python OWASP project makes available its Python bugreports, tools, and
    other artifacts via the website and associated GitHub projects. The main website
    for this is, and most of the code is available from the GitHub project page at:
    [https://github.com/ebranca/owasp-pysec/](https://github.com/ebranca/owasp-pysec/).![Strategies
    for security – Python](../Images/image00485.jpeg)'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Home page of the OWASP Python security project
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: It is a good idea for the stakeholders to keep track of this project, run their
    tests, and read their reports to keep up to date on Python security aspects.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: Secure coding strategies
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are coming towards the end of our discussion on the security aspects of software
    architecture. It is a good time to summarize the strategies that one should try
    and impart to a software development team from a security architect's point of
    view. The following is a table summarizing the top 10 of these. Some of these
    may seem repeated from our earlier discussions, as we have seen them before.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: '| SL | Strategy | How it helps |'
  id: totrans-330
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-331
  prefs: []
  type: TYPE_TB
- en: '| 1 | Validate inputs | Validate inputs from all untrusted data sources. Proper
    input validation can eliminate a vast majority of software vulnerabilities. |'
  id: totrans-332
  prefs: []
  type: TYPE_TB
- en: '| 2 | Keep it simple | Keep program design as simple as possible. Complex designs
    increase the chances of security errors being made in their implementation, configuration,
    and deployment. |'
  id: totrans-333
  prefs: []
  type: TYPE_TB
- en: '| 3 | Principle of least privilege | Every process should execute with the
    least set of system privileges necessary to complete the work. For example, to
    read data from /tmp, one doesn''t need root permission, but any unprivileged user
    is fine. |'
  id: totrans-334
  prefs: []
  type: TYPE_TB
- en: '| 4 | Sanitize data | Sanitize data read from and sent to all third-party systems
    such as databases, command shells, COTs components, third-party middlewares, and
    so on. This lessens the chances of SQL injection, shell exploit, or other similar
    attacks. |'
  id: totrans-335
  prefs: []
  type: TYPE_TB
- en: '| 5 | Authorize access | Separate parts of your application by roles that need
    specific authentication via login or other privileges. Don''t mix different parts
    of applications together in the same code that requires different levels of access.
    Employ proper routing to make sure that no sensitive data is exposed via unprotected
    routes. |'
  id: totrans-336
  prefs: []
  type: TYPE_TB
- en: '| 6 | Perform effective QA | Good security testing techniques are effective
    in identifying and eliminating vulnerabilities. Fuzz testing, penetration testing,
    and source code audits should be performed as part of the program. |'
  id: totrans-337
  prefs: []
  type: TYPE_TB
- en: '| 7 | Practice defense in layers | Mitigate risks with multiple layers of security.
    For example, combining secure programming techniques with secure runtime configuration
    will reduce the chances of any remaining code vulnerabilities being exposed in
    the runtime environment. |'
  id: totrans-338
  prefs: []
  type: TYPE_TB
- en: '| 8 | Define security requirements | Identify and document the security constraints
    in the early lifecycle of the system, and keep updating them making sure that
    any further features down the line keep up with these requirements. |'
  id: totrans-339
  prefs: []
  type: TYPE_TB
- en: '| 9 | Model threats | Use threat modeling to anticipate the threats to which
    the software will be subjected. |'
  id: totrans-340
  prefs: []
  type: TYPE_TB
- en: '| 10 | Architect and design for security policies | Create and maintain a software
    architecture that enforces a pattern of consistent security policies across your
    system and its subsystems. |'
  id: totrans-341
  prefs: []
  type: TYPE_TB
- en: Summary
  id: totrans-342
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we started with looking at the details of a system architecture
    that builds in security. We went on to define secure coding, and looked at the
    philosophies and principles behind the practice of secure coding.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: We then studied the different types of common security vulnerabilities encountered
    in software systems, such as buffer overflows, input validation issues, access
    control issues, cryptographic weaknesses, information leaks, insecure file operations,
    and so on.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: We then went on to a detailed discussion on Python security issues with a lot
    of examples. We looked in detail at reading and evaluating input, overflow errors,
    and serialization issues. We then went on to look at the common vulnerabilities
    in Python web application frameworks with Flask being the candidate of choice.
    We saw how one can exploit the weaknesses on web application templates, and perform
    attacks such as SSTI, XSS, and DOS. We also saw multiple code examples of how
    to mitigate these attacks.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: We then went on to list specific techniques in Python for writing secure code.
    We looked in detail at managing cryptographic hashes of passwords and other sensitive
    data in code, and discussed a couple of examples of doing this the right way.
    The importance of keeping oneself updated with security news and projects, and
    keeping the system updated with security patches was also mentioned.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we summarized the top 10 secure coding strategies that a security architect
    can impart to their team in order to create secure code and systems.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we take a look at one of the most interesting aspects of
    software engineering and design, namely that of design patterns.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
