- en: Chapter 7. Implementing Best Practices to Build Ajax Websites
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding HTML markup-specific coding
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building secure Ajax websites
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building Search Engine Optimization (SEO)-friendly Ajax websites
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preserving browser history or un-breaking the browser's back button
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing comet PHP and Ajax
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting things done is one thing and getting them done right is a whole other
    thing. JavaScript programmers often aim for best practices. As UI programming
    is gaining popularity, it demands better organization and practices. In this chapter,
    we'll see some common best practices.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding HTML markup-specific coding
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the unobtrusive JavaScript approach, where selector-based frameworks such
    as jQuery play major role, the interaction between HTML content and JavaScript
    is done through CSS selectors.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s assume we have a container with ID `alert` and our intention is to hide
    it and its neighbors—meaning, hide all elements of its parent:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: So far, so good. But, from the point of code maintainability, this approach
    is wrong.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the Web 2.0 world, where the design of the site has to change periodically
    to give a feel of freshness to customers, UI designers have to work hard to bring
    in freshness and as well as better usability. For the preceding markup, let''s
    assume that the UI designer has added an extra border around the `alert` container.
    The easier approach on the CSS programmer''s part is to wrap the `alert` container
    with another container to get the border:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now, the previous JavaScript functionality doesn't work as expected. The CSS
    programmer has unknowingly broken the site—even though they were able to add another
    border around the `alert` container.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: 'This illustrates the need for protocols and standards among JavaScript and
    CSS programmers—so they don''t break the site unknowingly. This can be done by:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Introducing protocols through naming conventions
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Approaching the situations differently
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll see how naming conventions and a different approach will help us here.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: 'Introducing protocols through naming conventions:'
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When the CSS programmer changes the HTML markup, there is no clue that the
    markup is associated with the JavaScript functionality. So, here come the naming
    convention and rules:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: All selectors that are used for Ajax purposes should be prefixed with `js-`
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whenever the markup is associated with JavaScript functionality, it has to be
    commented on at the PHP level (as a, HTML comment will be exposed to the end user)
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Note that we can introduce more such protocols after making mutual agreements
    with the CSS programmers. As per our introduced protocol, the HTML markup will
    have to be changed to:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Approaching the problem statement:'
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Instead of approaching the elements to be hidden through the parent of the
    `alert` container, if we directly refer the parent element, the issue probability
    is reduced:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note that, here, we haven't used the `parent()` method. In other words, if we
    can avoid markup-specific usage of the `parent()` and `children()` methods, we're
    relatively safe from getting a broken site.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In general, it would be easy to find the usage of `parent()` and `children()`
    through code search. But, in case if the usage is triggered from an unknown place,
    we may hack the jQuery code to throw notices into the Firebug console.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: console.warn()
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To warn the developer to not use it, we may peak into jQuery core''s `parent()`
    method and add a warning through Firebug''s console API:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Similarly, we may add a warning in the `children()` method:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Building secure Ajax websites
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ajax itself doesn't create any security risk, but the approaches in getting
    a website to be Ajaxified may open up security risks. The risks are common for
    all web applications.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll require a web browser with developer tools installed. Possible tools for
    this purpose are Firefox with Firebug.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some common security threats either in Ajax or non-Ajax web-based applications
    are XSS, SQL injection, and session hijacking. We'll see how they can be prevented.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '**XSS**'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'XSS or cross-site scripting attack capitalizes on the ability to add script
    to the website through user inputs or by some means of hacking the URL. Let''s
    take the popular Twitter website that allows users to enter their bio details.
    Consider the following input for the **Bio** field:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If Twitter engineers allowed HTML execution, or didn''t sanitize entries before
    displaying them, it would prompt with an alert box with the text **XSS**. In a
    real-world scenario, it won''t be an alert box, but may be malicious activities
    such as mimicking user input through a known URL or stealing of user data or hijacking
    of a session:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Usually, a hacker may not have direct access for the `updateUser.php` page;
    but the JavaScript code gets full access as it''s under current session scope.
    So, here, we must also look at our architectures:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: With the ability to execute this malicious code, the hacker may start stealing
    browser cookies. Through the session ID available in a cookie, the hacker may
    hijack the user's session.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution:**'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: 'Possible solutions for XSS are:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '`strip_tags()`'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: But, it may not be a good solution when we have to display HTML inputs.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: HTML Purifier library [http://htmlpurifier.org/](http://htmlpurifier.org/)
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This library can purify HTML codes and, so, is a better choice for XSS problems.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '**Session hijacking**'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As explained previously, the hacker may steal the cookie data and thus obtain
    the session ID of the user. When the hacker sets his/her browser's session value
    through cookie editing tools, the hacker will get access to the other user's session.
    This threat is usually common when the server or script is programmed to use same
    session ID for all communications.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution:**'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: 'A possible quick solution is to generate a new session ID for every request
    with:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '`session_regenerate_id()`'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '**SQL Injection**'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When an SQL query is acting upon user inputs to get some results, and if the
    user inputs are not properly sanitized, it opens up the possibility of changing
    the SQL query. For example:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The previous code is a newbie''s code for login validation for username and
    password combination. This fails terribly when:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As these expand the query to be true due to `OR 1=1` injection:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '**Solution:**'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: 'The only bulletproof solution for SQL injection is prepared statements available
    with the `mysqli` extension and PDO wrappers:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Also, we must never store passwords in plaintext—we must store only salted hashes
    in the database. This way, we can avoid the passwords being exposed to an attacker
    in plain text when he/she somehow gains access to the database. Previously, developers
    used MD5 and then SHA-512 hash functions, but now bcrypt alone is recommended.
    This is because, with bcrypt, more time is required to crack the original password
    than with any other hashing algorithms.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: Common mistakes on Ajax applications
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Client side-only decision:**'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: Client side-only validation, data binding, and decision making are the very
    common mistakes with Ajax applications.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: Client side-only validation can easily be broken by disabling JavaScript or
    attacking the URL through direct request via cURL.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: In the shopping cart, the discount for coupons or coupon validation has to be
    done at the server end. For example, if the shopping cart page offers a discount
    for coupon codes, the validity of the coupon code has to be decided at the server
    end. It would be a poor approach to check the pattern of the coupon code in the
    client-side JavaScript—the user could find out the coupon code pattern by looking
    at the JavaScript code and generate any number of coupons! Similarly, the final
    amount to be paid has to be decided at the server end. It is also a poor approach
    to keep the final payable amount in a hidden form field or read-only input field
    without validating the payable amount and paid amount on placing orders. It is
    very easy to change any form fields—either hidden or read-only—through browser
    extensions such as Firebug and Web Developer extension.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution:**'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: The solution is to always decide on the server end rather than on the client
    side. Remember that anything—even cryptic logic—wrapped in JavaScript is exposed
    to the world already.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '**Code architecture problem:**'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: Poorly architected code and code with poor logic are a great risk. They often
    expose unexpected data.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: Let's take`http://example.com/user.php?field=email&id=2`. This script is written
    to return the value of the field referred by the `field` param for a given `id`
    from the users table. The unexpected attack for this code architecture is the
    ability to expose any field, including password and other sensitive data by using,
    for example, `http://example.com/user.php?field=passwd&id=2`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: Other such data exposure possibilities arise through web services that are common
    in Web 2.0 websites. When there's no limit on access to data, users can steal
    it through web services, even when they can't access it in the main websites.
    Web services usually expose data in JSON or XML and that allows hackers to easily
    tap in.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution:**'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: 'The solutions for these issues are:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '**Whitelisting and blacklisting requests:**'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By maintaining a list of requests that can be allowed or denied, the attack
    can be minimized.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '**Throttling of requests:**'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The request can be rate-limited with access tokens so that hackers can't pull
    more data than allowed.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '**Improving the code architecture from the beginning:**'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the architecture and framework are planned from the beginning to target
    Ajax and Web 2.0, these issues can be minimized. Obviously, every architecture
    may have its own problems.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: XSS is the ability to execute JavaScript code on other domains when other users
    view the pages. Through this, an attacker may execute/trigger unexpected URLs.
    Also, an attacker can steal the session cookie and send it to their own webpage.
    Once the session cookie is available on the attacker's webpage, he or she can
    use it to hijack the session—without needing to know other users' login details.
    When SQL statements are not properly escaped, the original intended statement
    can be altered through form inputs; this is referred as SQL injection.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table shows the same origin policy followed in web browsers when
    handling Ajax requests from [http://www.example.com/page.html](http://www.example.com/page.html)
    to different URLs:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '| URL | Access |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
- en: '| `http://subdomain.example.com/page.htm` | Not allowed. Different host |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
- en: '| `http://example.com/page.html` | Not allowed. Different host |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
- en: '| `http://www.example.com:8080/page.html` | Not allowed. Different port |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
- en: '| `"http://www.example.com/dir/page.html"` | Allowed. Same domain, protocol,
    and port |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
- en: '| `https://www.example.com/page.html` | Not allowed. Different protocol |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
- en: The policy is rigidly followed in web browsers to avoid any direct security
    risks in Ajax. Other possible security risks are common for all web-based applications
    and arise out of common mistakes. Through proper security audits, we may avoid
    further risks.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is usually easier to avoid security risks through automated audit tools than
    manual code inspection. There are few open source tools available to mitigate
    the security issues.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Exploit-Me
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Exploit-Me, available at [http://labs.securitycompass.com/index.php/exploit-me/](http://labs.securitycompass.com/index.php/exploit-me/),
    is a set of security-related Firefox extensions for testing XSS, SQL injection,
    and access vulnerabilities. This is a powerful open source approach to quickly
    audit the website.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: WebInspect
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The WebInspect web security audit tool from HP is an enterprise audit tool that
    scans for a lot of vulnerabilities and security vectors. It's available at [https://www.fortify.com/products/web_inspect.html](http://https://www.fortify.com/products/web_inspect.html).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: Resources
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are few sites and tools dedicated to PHP security:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: PHP Security Consortium, found at [http://phpsec.org/](http://phpsec.org/),
    provides security-related information.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Suhosin of the Hardened-PHP Project, found at [http://www.hardened-php.org/suhosin/](http://www.hardened-php.org/suhosin/),
    provides a patch for common security vulnerabilities that are otherwise possible
    in a normal PHP build.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mod_security` Apache mod, available at [http://www.modsecurity.org/](http://www.modsecurity.org/),
    protects the server from common security attacks.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building SEO-friendly Ajax websites
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: On the Internet, websites and their business models mostly rely on search engines.
    Say, for example, when a user is searching for the keyword "book publishing" in
    the Google search engine, if Packt's website is listed on the first page of results,
    it will be an advantage for Packt—especially when its business model relies on
    Internet users.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: 'Search engines, such as Google, order the result page based on a number of
    factors, referred to as algorithms. These are: keyword density on the page, trusted
    inwards links to the page, popularity of the website, and so on. All these depend
    on how far the search engine''s spider can crawl (or reach) the website''s content.
    If the website''s index page doesn''t have links to the website''s inner pages,
    has restricted access to inner pages, or doesn''t expose the inner pages through
    the `sitemap.xml` file that the spider looks for when crawling, the contents will
    not be indexed and can''t be searched.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: The challenge with Web 2.0 websites that rely on search engine results for their
    business model is that they have to employ modern Ajax approaches for end-user
    usability and retention but also need to have content that is accessible and crawlable
    by search engine spiders. Enter Ajax and SEO.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll require progressive enhancement through an unobtrusive JavaScript approach
    for developing search engine-friendly websites. This approach and terminology
    are explained next.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The easier approach to adopt SEO-friendly Ajax is progressive enhancement. This
    facilitates the pages being accessible for anyone—including someone who doesn't
    use the JavaScript engine in their browser.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand the concept, let''s take a case where we have a tabbed Ajax UI
    and tabs are loaded from different remote pages:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As shown previously, each tab's contents are loaded from `page1.html, page2.html`,
    and so on. But, when checking the HTML source, the URL from where the contents
    are loaded is not known; the URLs are formed in JavaScript code, and content is
    dynamically loaded. As a majority of the search engine crawlers don't support
    the JavaScript engine, and can't support it at least for the moment, they'll miss
    out the content. Only when the crawler can "view" the content, can it be searchable.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: 'So, for the right search engine and SEO friendliness, we have the following
    approaches:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: 'Cloaking:'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is the terminology used for presenting different content to the search
    engine spider by sniffing the user agent. But, search engines such as Google ban
    sites that cloak their contents, to improve search engine quality.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '`Sitemap.xml:`'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Presenting links for all internal links in `Sitemap.xml` may improve search
    engine accessibility. `Sitemap.xml` is the standard for exposing site links to
    Google. But, this is not sufficient and shouldn't accidentally be mingled with
    cloaking.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: 'Inline tabs:'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By dumping all the content in a single entry page and employing hide and show,
    we can improve search engine accessibility. But, from the search engine optimization
    perspective, this solution fails as there won't be enough pages for the search
    engine spider to look for.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: 'Progressive enhancements:'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is the approach by which a website will be accessible by all browsers. Ajax
    enhancements won't hamper the visibility/accessibility for non-JavaScript browsers.
    So far, this is the best method and, when combined with `Sitemap.xml`, can give
    better search engine visibility.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s see how the tab system can be done by the progressive enhancement
    approach. For that, we''re going to use jQuery UI''s tabs library:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: How it works...
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As noted previously, we're not hiding the links and they're always accessible.
    When JavaScript is not enabled, clicking on the links will take you to separate
    pages. This is how the search engines "view" the site. Search engines will index
    pages with separate URLs, such as `http://example.com/page1.html, http://example.com/page2.html`,
    and so on.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Hijax, in simple terms, means Hijack + Ajax. It is a progressive enhancement
    technique where normal links are "hijacked" and Ajax effects are applied to give
    the website an Ajaxified feel.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: When JavaScript is enabled, jQuery UI tabs get hooked; it applies the Hijax
    approach and converts the links into a beautiful tabbed interface. It also Ajaxifies
    the tabbed links and, thereby, avoids a page refresh when a user clicks on the
    tab.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: More about jQuery UI tabs is covered in the *Creating tab navigation* recipe
    in [Chapter 3](ch03.html "Chapter 3. Useful Tools Using jQuery"),*Useful Tools
    Using jQuery*.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Google's proposal
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As of now, the previous, degradable Ajax approach is widely accepted practice
    for search-engine friendly Ajax. But, one thing to note is that when a user searches
    for the content of `page2.html`, the search engine will display the link as `http://example.com/page2.html`.
    For normal users with JavaScript-enabled browsers with Ajax experience, such direct
    links won''t be exposed. So, to have a consistent URL for all users, Google has
    proposed a solution. This technique, that is now referred to as **hashbang**,
    requires all Ajax URL hashes to be prefixed with `!` and a mechanism to access
    Ajax page content, as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '`http://example.com/index.html#page1` has to be changed to `http://example.com/index.html#!page1`.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When Google identifies an Ajax URL such as `http://example.com/index.html#!page1`
    it will crawl `http://example.com/index.html?_escaped_fragment_=page1`. This URL
    has to provide the Ajax content.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When Google lists the URL in a search result page, it will display the Ajax
    URL `http://example.com/index.html#!page1`.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this way, all users can use the same URL to access the site.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Preserving browser history or un-breaking the browser's back button
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![Preserving browser history or un-breaking the browser''s back button](graphics/3081_07_01.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
- en: 'By underlying concept, Ajax lets the user view pages without a whole browser
    refresh. The subsequent browser calls are routed through XHR requests and the
    results are pushed to the browser window. In this scenario, there are two major
    usability concerns from the user''s point of view: first, the particular content
    cannot be bookmarked—as we have only one URL from where we have browsed subsequent
    pages without a browser refresh; second, the user cannot click the back button
    to return to browse previous content—as the page state has not changed in the
    browser.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll require a browser with Ajax components to test the functionality and a
    browser that supports the `window.onhashchange` event and HTML5's `window.history.pushState()`
    method to compare.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are many jQuery plugins available to solve this issue. The jQuery History
    plugin by Benjamin Arthur Lupton, available at [http://www.balupton.com/projects/jquery-history](http://www.balupton.com/projects/jquery-history),
    handles history mechanism by all new methods and also provides a hack for older
    browsers.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this HTML snippet with links to subpages:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here''s the snippet to handle the state through jQuery History plugin:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The plugin offers other methods to manually change the state and also triggers
    the state handler.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note that when the user clicks the link `"#/about`" the state would change to
    `/about`. But, if we programmatically want to change the state, say when a user
    clicks on the `div` instead of `anchor`, as shown previously, the `go()` method
    can be used.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: 'When the state shouldn''t be visible to the user, but we require to trigger
    the state handler, the `trigger()` method is useful:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: How it works...
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we noted, the browsers don''t save the state of Ajax requests, and so, the
    back button, browser history, and bookmarking don''t work usually. A tempting
    quick fix is to use the following JavaScript code that changes the URL in the
    browser:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The problem with this code is that it will reload the browser window and, thus,
    will defeat the purpose of Ajax.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '**Easier pushState() approach:**'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: In browsers that support HTML5 specifications, we may use
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '`window.history.pushState()`'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`window.history.replaceState()`'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`window.onpopstate`'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`window.history.pushState()` allows us to change the URL in the browser but
    without letting the browser reload the page. The function takes three parameters:
    state object, title, and URL.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We also have `window.history.replaceState()` that will work similarly to `pushState()`,
    but without adding a new history entry, it will replace current URL.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: The `window.onpopstate` event gets triggered on every state change, that is,
    when a user hits the back and forward buttons. Once the page gets reloaded, the
    `popstate` event would stop fire for the previous state preserved before page
    reload. In order to access those states, we may use `window.history.state` that
    gives access to states before page reload.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: 'The following snippet shows how these methods can be clubbed for a quick browser
    history solution:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '**onhashchange approach:**'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: The prevailing approach to solve the browser history issue is through URL hashes
    that look like `#foo`. The major motivation to use a hash is that changing it
    through `location.hash` would not refresh the page (unlike `location.href)` and
    would also add an entry in browser history, for some browsers. But, when the user
    hit the back or forward button, there was no easy mechanism to see if the URL
    hash has been changed. The `window.onhashchange` event has been introduced in
    newer browsers and will get executed when a hash change occurs.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: The portability hack for the `hashchange` event is to constantly poll the hash
    changes through the `setInterval()` method. The shorter the polling interval,
    the better the responsiveness, but using too short a value will affect the performance.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '**iframe hack approach:**'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: Some browsers, especially IE6, don't save state on hash changes. So, here, the
    workaround is to create an invisible `iframe` element and change its `src` attribute
    to track state. This is because the browser tracks the state for `iframe src`
    changes. So, when a user hits the browser's back or forward button, they have
    to poll the `src` attribute of `iframe` to update the UI.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '**Combining all approaches:**'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: For better browser compatibility and performance, it's essential to combine
    all of the previous approaches. The jQuery History plugin abstracts all these
    approaches and provides better functionality.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Implementing comet PHP and Ajax
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In traditional client-server communication over HTTP, for every response from
    a server, a request is made by the client. In other words, there is no response
    without a request.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing comet PHP and Ajax](graphics/3081_07_02.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
- en: Comet, Ajax Push, Reverse Ajax, Two-way-web, HTTP Streaming, or HTTP server
    push are the collective terms used to refer to the implementation of instantaneous
    data changes pushed from the server. Unlike in traditional communication, here,
    the request from the client is made once and all the data/responses are pushed
    from the server—without further request calls from the client.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing comet PHP and Ajax](graphics/3081_07_03.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
- en: Through comet, we can create Ajax chat and other live applications. Before the
    introduction of HTML5's WebSocket API, JavaScript developers had to go for hacks,
    such as using `iframe`, long polling Ajax, and so on
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many comet technologies available, including a pure JavaScript approach
    over Apache web server. But, when looking at performance and approaches, the open
    source APE (Ajax Push Engine) technology looks promising. APE has two components:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: APE Server
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: APE JSF (APE JavaScript Framework)
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The server is written in C and the JavaScript framework is based on Mootools,
    but can also be used with other frameworks such as jQuery. APE Server modules
    are extensible through JavaScript code. It supports transport methods, such as
    Long Polling, XHR Streaming, JSONP, and Server Sent Events. Some of the mentioned
    advantages of APE Server are:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: Apache-based solutions cannot do a real push
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: APE can handle more than 100k users
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: APE is faster than an Apache comet-based solution
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: APE saves lot of bandwith
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: APE provides more options than simple comet solutions
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll require an APE Server for our comet experiments. An APE Server installed
    on Linux is recommended, though it can run on a Windows machine with VirutalBox.
    It can be downloaded from [http://www.ape-project.org/](http://www.ape-project.org/).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: We will have to configure the APE client script with server settings in `Build/uncompressed/apeClientJS.js:`
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: How to do it...
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll see how a simple comet client-server interaction can be done. We'll also
    see how the APE Server can be used to broadcast messages to clients over the comet
    setup. We need some basic understanding of APE terminologies before setting up
    the comet.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '**Pipe:**'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Pipes are communication conduits to exchange data between the client and server
    and they are the core of the communication system. There are two main types of
    pipes:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: Multi pipe or Channel
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uni pipe or User
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A pipe is identified by a 32-character unique ID generated by a server called
    pubid.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '**Channel:**'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A channel is a communication conduit that can be directly created by the server
    or by a user. It is automatically created if a user subscribes to a channel that
    doesn''t exist. Each channel has a list of properties and has two ways of working:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: Interactive Channel
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Non-Interactive Channel
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A user who subscribes to an existing interactive channel, will receive a list
    of all other users who have subscribed to that channel and can directly communicate
    with them via the channel pipe. In a non-interactive channel, the communication
    is read-only and users do not know each other, also, they can't communicate through
    the channel. The creation of a non-interactive channel can be initiated by prefixing
    the channel name with the * character.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '**User:**'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When a user connects to the APE, a pipe is created for communication with other
    entities, and a unique sessid is assigned to the pipe. That ID helps the server
    to identify the user that sends each command. A user can perform actions that
    allow them to:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: Post a message on a pipe for a channel or another user
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Subscribe/join a channel
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unsubscribe/leave a channel
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a channel
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, the code:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The preceding code connects the client with the server and joins the user with
    a channel named `myChannel`. When a user joins the channel, it sends a test message
    to other users on the channel `myChannel`. Note that the message is shared through
    the channel name.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: 'To push some messages from the server side, APE offers a mechanism called `inlinepush`.
    This `inlinepush` can be triggered by invoking the APE Server''s URL:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从服务器端推送一些消息，APE提供了一种称为`inlinepush`的机制。这个`inlinepush`可以通过调用APE服务器的URL来触发：
- en: '[PRE24]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: How it works...
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: APE's underlying protocol uses JSON for data transmission. Connection from client
    to server is initiated with APE's `start()` method. Joining a channel or creating
    a new channel is initiated with the `join()` method. Messages to other users available
    on the channel are then passed over the `send()` method. More than one browser
    window or tab should be opened to see the message transmitted from one window
    to the other windows.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: APE的底层协议使用JSON进行数据传输。从客户端到服务器的连接是通过APE的`start()`方法来初始化的。加入频道或创建新频道是通过`join()`方法来初始化的。然后通过`send()`方法将消息传递给频道上其他用户。应该打开多个浏览器窗口或标签页，以查看从一个窗口传输到其他窗口的消息。
- en: APE's `inlinepush` mechanism offers a way to push messages to the channel users
    without using a client. Such pushes can be initiated by invoking a JSON-encoded
    URL with commands. From PHP, such URLs can be triggered by cURL calls or a simple
    `file_get_contents()` call.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: APE的`inlinepush`机制提供了一种在不使用客户端的情况下向频道用户推送消息的方式。这样的推送可以通过调用带有命令的JSON编码的URL来启动。从PHP，这样的URL可以通过cURL调用或简单的`file_get_contents()`调用来触发。
