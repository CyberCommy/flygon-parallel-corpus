- en: Chapter 7. Implementing Best Practices to Build Ajax Websites
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding HTML markup-specific coding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building secure Ajax websites
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building Search Engine Optimization (SEO)-friendly Ajax websites
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preserving browser history or un-breaking the browser's back button
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing comet PHP and Ajax
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting things done is one thing and getting them done right is a whole other
    thing. JavaScript programmers often aim for best practices. As UI programming
    is gaining popularity, it demands better organization and practices. In this chapter,
    we'll see some common best practices.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding HTML markup-specific coding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the unobtrusive JavaScript approach, where selector-based frameworks such
    as jQuery play major role, the interaction between HTML content and JavaScript
    is done through CSS selectors.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s assume we have a container with ID `alert` and our intention is to hide
    it and its neighbors—meaning, hide all elements of its parent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: So far, so good. But, from the point of code maintainability, this approach
    is wrong.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the Web 2.0 world, where the design of the site has to change periodically
    to give a feel of freshness to customers, UI designers have to work hard to bring
    in freshness and as well as better usability. For the preceding markup, let''s
    assume that the UI designer has added an extra border around the `alert` container.
    The easier approach on the CSS programmer''s part is to wrap the `alert` container
    with another container to get the border:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now, the previous JavaScript functionality doesn't work as expected. The CSS
    programmer has unknowingly broken the site—even though they were able to add another
    border around the `alert` container.
  prefs: []
  type: TYPE_NORMAL
- en: 'This illustrates the need for protocols and standards among JavaScript and
    CSS programmers—so they don''t break the site unknowingly. This can be done by:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing protocols through naming conventions
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Approaching the situations differently
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll see how naming conventions and a different approach will help us here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Introducing protocols through naming conventions:'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When the CSS programmer changes the HTML markup, there is no clue that the
    markup is associated with the JavaScript functionality. So, here come the naming
    convention and rules:'
  prefs: []
  type: TYPE_NORMAL
- en: All selectors that are used for Ajax purposes should be prefixed with `js-`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whenever the markup is associated with JavaScript functionality, it has to be
    commented on at the PHP level (as a, HTML comment will be exposed to the end user)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Note that we can introduce more such protocols after making mutual agreements
    with the CSS programmers. As per our introduced protocol, the HTML markup will
    have to be changed to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Approaching the problem statement:'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Instead of approaching the elements to be hidden through the parent of the
    `alert` container, if we directly refer the parent element, the issue probability
    is reduced:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note that, here, we haven't used the `parent()` method. In other words, if we
    can avoid markup-specific usage of the `parent()` and `children()` methods, we're
    relatively safe from getting a broken site.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In general, it would be easy to find the usage of `parent()` and `children()`
    through code search. But, in case if the usage is triggered from an unknown place,
    we may hack the jQuery code to throw notices into the Firebug console.
  prefs: []
  type: TYPE_NORMAL
- en: console.warn()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To warn the developer to not use it, we may peak into jQuery core''s `parent()`
    method and add a warning through Firebug''s console API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, we may add a warning in the `children()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Building secure Ajax websites
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ajax itself doesn't create any security risk, but the approaches in getting
    a website to be Ajaxified may open up security risks. The risks are common for
    all web applications.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll require a web browser with developer tools installed. Possible tools for
    this purpose are Firefox with Firebug.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some common security threats either in Ajax or non-Ajax web-based applications
    are XSS, SQL injection, and session hijacking. We'll see how they can be prevented.
  prefs: []
  type: TYPE_NORMAL
- en: '**XSS**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'XSS or cross-site scripting attack capitalizes on the ability to add script
    to the website through user inputs or by some means of hacking the URL. Let''s
    take the popular Twitter website that allows users to enter their bio details.
    Consider the following input for the **Bio** field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If Twitter engineers allowed HTML execution, or didn''t sanitize entries before
    displaying them, it would prompt with an alert box with the text **XSS**. In a
    real-world scenario, it won''t be an alert box, but may be malicious activities
    such as mimicking user input through a known URL or stealing of user data or hijacking
    of a session:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Usually, a hacker may not have direct access for the `updateUser.php` page;
    but the JavaScript code gets full access as it''s under current session scope.
    So, here, we must also look at our architectures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: With the ability to execute this malicious code, the hacker may start stealing
    browser cookies. Through the session ID available in a cookie, the hacker may
    hijack the user's session.
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution:**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Possible solutions for XSS are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`strip_tags()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: But, it may not be a good solution when we have to display HTML inputs.
  prefs: []
  type: TYPE_NORMAL
- en: HTML Purifier library [http://htmlpurifier.org/](http://htmlpurifier.org/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This library can purify HTML codes and, so, is a better choice for XSS problems.
  prefs: []
  type: TYPE_NORMAL
- en: '**Session hijacking**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As explained previously, the hacker may steal the cookie data and thus obtain
    the session ID of the user. When the hacker sets his/her browser's session value
    through cookie editing tools, the hacker will get access to the other user's session.
    This threat is usually common when the server or script is programmed to use same
    session ID for all communications.
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution:**'
  prefs: []
  type: TYPE_NORMAL
- en: 'A possible quick solution is to generate a new session ID for every request
    with:'
  prefs: []
  type: TYPE_NORMAL
- en: '`session_regenerate_id()`'
  prefs: []
  type: TYPE_NORMAL
- en: '**SQL Injection**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When an SQL query is acting upon user inputs to get some results, and if the
    user inputs are not properly sanitized, it opens up the possibility of changing
    the SQL query. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous code is a newbie''s code for login validation for username and
    password combination. This fails terribly when:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'As these expand the query to be true due to `OR 1=1` injection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '**Solution:**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The only bulletproof solution for SQL injection is prepared statements available
    with the `mysqli` extension and PDO wrappers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Also, we must never store passwords in plaintext—we must store only salted hashes
    in the database. This way, we can avoid the passwords being exposed to an attacker
    in plain text when he/she somehow gains access to the database. Previously, developers
    used MD5 and then SHA-512 hash functions, but now bcrypt alone is recommended.
    This is because, with bcrypt, more time is required to crack the original password
    than with any other hashing algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: Common mistakes on Ajax applications
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Client side-only decision:**'
  prefs: []
  type: TYPE_NORMAL
- en: Client side-only validation, data binding, and decision making are the very
    common mistakes with Ajax applications.
  prefs: []
  type: TYPE_NORMAL
- en: Client side-only validation can easily be broken by disabling JavaScript or
    attacking the URL through direct request via cURL.
  prefs: []
  type: TYPE_NORMAL
- en: In the shopping cart, the discount for coupons or coupon validation has to be
    done at the server end. For example, if the shopping cart page offers a discount
    for coupon codes, the validity of the coupon code has to be decided at the server
    end. It would be a poor approach to check the pattern of the coupon code in the
    client-side JavaScript—the user could find out the coupon code pattern by looking
    at the JavaScript code and generate any number of coupons! Similarly, the final
    amount to be paid has to be decided at the server end. It is also a poor approach
    to keep the final payable amount in a hidden form field or read-only input field
    without validating the payable amount and paid amount on placing orders. It is
    very easy to change any form fields—either hidden or read-only—through browser
    extensions such as Firebug and Web Developer extension.
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution:**'
  prefs: []
  type: TYPE_NORMAL
- en: The solution is to always decide on the server end rather than on the client
    side. Remember that anything—even cryptic logic—wrapped in JavaScript is exposed
    to the world already.
  prefs: []
  type: TYPE_NORMAL
- en: '**Code architecture problem:**'
  prefs: []
  type: TYPE_NORMAL
- en: Poorly architected code and code with poor logic are a great risk. They often
    expose unexpected data.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take`http://example.com/user.php?field=email&id=2`. This script is written
    to return the value of the field referred by the `field` param for a given `id`
    from the users table. The unexpected attack for this code architecture is the
    ability to expose any field, including password and other sensitive data by using,
    for example, `http://example.com/user.php?field=passwd&id=2`.
  prefs: []
  type: TYPE_NORMAL
- en: Other such data exposure possibilities arise through web services that are common
    in Web 2.0 websites. When there's no limit on access to data, users can steal
    it through web services, even when they can't access it in the main websites.
    Web services usually expose data in JSON or XML and that allows hackers to easily
    tap in.
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution:**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The solutions for these issues are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Whitelisting and blacklisting requests:**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By maintaining a list of requests that can be allowed or denied, the attack
    can be minimized.
  prefs: []
  type: TYPE_NORMAL
- en: '**Throttling of requests:**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The request can be rate-limited with access tokens so that hackers can't pull
    more data than allowed.
  prefs: []
  type: TYPE_NORMAL
- en: '**Improving the code architecture from the beginning:**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the architecture and framework are planned from the beginning to target
    Ajax and Web 2.0, these issues can be minimized. Obviously, every architecture
    may have its own problems.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: XSS is the ability to execute JavaScript code on other domains when other users
    view the pages. Through this, an attacker may execute/trigger unexpected URLs.
    Also, an attacker can steal the session cookie and send it to their own webpage.
    Once the session cookie is available on the attacker's webpage, he or she can
    use it to hijack the session—without needing to know other users' login details.
    When SQL statements are not properly escaped, the original intended statement
    can be altered through form inputs; this is referred as SQL injection.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table shows the same origin policy followed in web browsers when
    handling Ajax requests from [http://www.example.com/page.html](http://www.example.com/page.html)
    to different URLs:'
  prefs: []
  type: TYPE_NORMAL
- en: '| URL | Access |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `http://subdomain.example.com/page.htm` | Not allowed. Different host |'
  prefs: []
  type: TYPE_TB
- en: '| `http://example.com/page.html` | Not allowed. Different host |'
  prefs: []
  type: TYPE_TB
- en: '| `http://www.example.com:8080/page.html` | Not allowed. Different port |'
  prefs: []
  type: TYPE_TB
- en: '| `"http://www.example.com/dir/page.html"` | Allowed. Same domain, protocol,
    and port |'
  prefs: []
  type: TYPE_TB
- en: '| `https://www.example.com/page.html` | Not allowed. Different protocol |'
  prefs: []
  type: TYPE_TB
- en: The policy is rigidly followed in web browsers to avoid any direct security
    risks in Ajax. Other possible security risks are common for all web-based applications
    and arise out of common mistakes. Through proper security audits, we may avoid
    further risks.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is usually easier to avoid security risks through automated audit tools than
    manual code inspection. There are few open source tools available to mitigate
    the security issues.
  prefs: []
  type: TYPE_NORMAL
- en: Exploit-Me
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Exploit-Me, available at [http://labs.securitycompass.com/index.php/exploit-me/](http://labs.securitycompass.com/index.php/exploit-me/),
    is a set of security-related Firefox extensions for testing XSS, SQL injection,
    and access vulnerabilities. This is a powerful open source approach to quickly
    audit the website.
  prefs: []
  type: TYPE_NORMAL
- en: WebInspect
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The WebInspect web security audit tool from HP is an enterprise audit tool that
    scans for a lot of vulnerabilities and security vectors. It's available at [https://www.fortify.com/products/web_inspect.html](http://https://www.fortify.com/products/web_inspect.html).
  prefs: []
  type: TYPE_NORMAL
- en: Resources
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are few sites and tools dedicated to PHP security:'
  prefs: []
  type: TYPE_NORMAL
- en: PHP Security Consortium, found at [http://phpsec.org/](http://phpsec.org/),
    provides security-related information.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Suhosin of the Hardened-PHP Project, found at [http://www.hardened-php.org/suhosin/](http://www.hardened-php.org/suhosin/),
    provides a patch for common security vulnerabilities that are otherwise possible
    in a normal PHP build.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mod_security` Apache mod, available at [http://www.modsecurity.org/](http://www.modsecurity.org/),
    protects the server from common security attacks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building SEO-friendly Ajax websites
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: On the Internet, websites and their business models mostly rely on search engines.
    Say, for example, when a user is searching for the keyword "book publishing" in
    the Google search engine, if Packt's website is listed on the first page of results,
    it will be an advantage for Packt—especially when its business model relies on
    Internet users.
  prefs: []
  type: TYPE_NORMAL
- en: 'Search engines, such as Google, order the result page based on a number of
    factors, referred to as algorithms. These are: keyword density on the page, trusted
    inwards links to the page, popularity of the website, and so on. All these depend
    on how far the search engine''s spider can crawl (or reach) the website''s content.
    If the website''s index page doesn''t have links to the website''s inner pages,
    has restricted access to inner pages, or doesn''t expose the inner pages through
    the `sitemap.xml` file that the spider looks for when crawling, the contents will
    not be indexed and can''t be searched.'
  prefs: []
  type: TYPE_NORMAL
- en: The challenge with Web 2.0 websites that rely on search engine results for their
    business model is that they have to employ modern Ajax approaches for end-user
    usability and retention but also need to have content that is accessible and crawlable
    by search engine spiders. Enter Ajax and SEO.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll require progressive enhancement through an unobtrusive JavaScript approach
    for developing search engine-friendly websites. This approach and terminology
    are explained next.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The easier approach to adopt SEO-friendly Ajax is progressive enhancement. This
    facilitates the pages being accessible for anyone—including someone who doesn't
    use the JavaScript engine in their browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand the concept, let''s take a case where we have a tabbed Ajax UI
    and tabs are loaded from different remote pages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As shown previously, each tab's contents are loaded from `page1.html, page2.html`,
    and so on. But, when checking the HTML source, the URL from where the contents
    are loaded is not known; the URLs are formed in JavaScript code, and content is
    dynamically loaded. As a majority of the search engine crawlers don't support
    the JavaScript engine, and can't support it at least for the moment, they'll miss
    out the content. Only when the crawler can "view" the content, can it be searchable.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, for the right search engine and SEO friendliness, we have the following
    approaches:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Cloaking:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is the terminology used for presenting different content to the search
    engine spider by sniffing the user agent. But, search engines such as Google ban
    sites that cloak their contents, to improve search engine quality.
  prefs: []
  type: TYPE_NORMAL
- en: '`Sitemap.xml:`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Presenting links for all internal links in `Sitemap.xml` may improve search
    engine accessibility. `Sitemap.xml` is the standard for exposing site links to
    Google. But, this is not sufficient and shouldn't accidentally be mingled with
    cloaking.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inline tabs:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By dumping all the content in a single entry page and employing hide and show,
    we can improve search engine accessibility. But, from the search engine optimization
    perspective, this solution fails as there won't be enough pages for the search
    engine spider to look for.
  prefs: []
  type: TYPE_NORMAL
- en: 'Progressive enhancements:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is the approach by which a website will be accessible by all browsers. Ajax
    enhancements won't hamper the visibility/accessibility for non-JavaScript browsers.
    So far, this is the best method and, when combined with `Sitemap.xml`, can give
    better search engine visibility.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s see how the tab system can be done by the progressive enhancement
    approach. For that, we''re going to use jQuery UI''s tabs library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As noted previously, we're not hiding the links and they're always accessible.
    When JavaScript is not enabled, clicking on the links will take you to separate
    pages. This is how the search engines "view" the site. Search engines will index
    pages with separate URLs, such as `http://example.com/page1.html, http://example.com/page2.html`,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Hijax, in simple terms, means Hijack + Ajax. It is a progressive enhancement
    technique where normal links are "hijacked" and Ajax effects are applied to give
    the website an Ajaxified feel.
  prefs: []
  type: TYPE_NORMAL
- en: When JavaScript is enabled, jQuery UI tabs get hooked; it applies the Hijax
    approach and converts the links into a beautiful tabbed interface. It also Ajaxifies
    the tabbed links and, thereby, avoids a page refresh when a user clicks on the
    tab.
  prefs: []
  type: TYPE_NORMAL
- en: More about jQuery UI tabs is covered in the *Creating tab navigation* recipe
    in [Chapter 3](ch03.html "Chapter 3. Useful Tools Using jQuery"),*Useful Tools
    Using jQuery*.
  prefs: []
  type: TYPE_NORMAL
- en: Google's proposal
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As of now, the previous, degradable Ajax approach is widely accepted practice
    for search-engine friendly Ajax. But, one thing to note is that when a user searches
    for the content of `page2.html`, the search engine will display the link as `http://example.com/page2.html`.
    For normal users with JavaScript-enabled browsers with Ajax experience, such direct
    links won''t be exposed. So, to have a consistent URL for all users, Google has
    proposed a solution. This technique, that is now referred to as **hashbang**,
    requires all Ajax URL hashes to be prefixed with `!` and a mechanism to access
    Ajax page content, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`http://example.com/index.html#page1` has to be changed to `http://example.com/index.html#!page1`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When Google identifies an Ajax URL such as `http://example.com/index.html#!page1`
    it will crawl `http://example.com/index.html?_escaped_fragment_=page1`. This URL
    has to provide the Ajax content.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When Google lists the URL in a search result page, it will display the Ajax
    URL `http://example.com/index.html#!page1`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this way, all users can use the same URL to access the site.
  prefs: []
  type: TYPE_NORMAL
- en: Preserving browser history or un-breaking the browser's back button
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![Preserving browser history or un-breaking the browser''s back button](graphics/3081_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'By underlying concept, Ajax lets the user view pages without a whole browser
    refresh. The subsequent browser calls are routed through XHR requests and the
    results are pushed to the browser window. In this scenario, there are two major
    usability concerns from the user''s point of view: first, the particular content
    cannot be bookmarked—as we have only one URL from where we have browsed subsequent
    pages without a browser refresh; second, the user cannot click the back button
    to return to browse previous content—as the page state has not changed in the
    browser.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll require a browser with Ajax components to test the functionality and a
    browser that supports the `window.onhashchange` event and HTML5's `window.history.pushState()`
    method to compare.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are many jQuery plugins available to solve this issue. The jQuery History
    plugin by Benjamin Arthur Lupton, available at [http://www.balupton.com/projects/jquery-history](http://www.balupton.com/projects/jquery-history),
    handles history mechanism by all new methods and also provides a hack for older
    browsers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this HTML snippet with links to subpages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the snippet to handle the state through jQuery History plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The plugin offers other methods to manually change the state and also triggers
    the state handler.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Note that when the user clicks the link `"#/about`" the state would change to
    `/about`. But, if we programmatically want to change the state, say when a user
    clicks on the `div` instead of `anchor`, as shown previously, the `go()` method
    can be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the state shouldn''t be visible to the user, but we require to trigger
    the state handler, the `trigger()` method is useful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we noted, the browsers don''t save the state of Ajax requests, and so, the
    back button, browser history, and bookmarking don''t work usually. A tempting
    quick fix is to use the following JavaScript code that changes the URL in the
    browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The problem with this code is that it will reload the browser window and, thus,
    will defeat the purpose of Ajax.
  prefs: []
  type: TYPE_NORMAL
- en: '**Easier pushState() approach:**'
  prefs: []
  type: TYPE_NORMAL
- en: In browsers that support HTML5 specifications, we may use
  prefs: []
  type: TYPE_NORMAL
- en: '`window.history.pushState()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`window.history.replaceState()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`window.onpopstate`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`window.history.pushState()` allows us to change the URL in the browser but
    without letting the browser reload the page. The function takes three parameters:
    state object, title, and URL.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We also have `window.history.replaceState()` that will work similarly to `pushState()`,
    but without adding a new history entry, it will replace current URL.
  prefs: []
  type: TYPE_NORMAL
- en: The `window.onpopstate` event gets triggered on every state change, that is,
    when a user hits the back and forward buttons. Once the page gets reloaded, the
    `popstate` event would stop fire for the previous state preserved before page
    reload. In order to access those states, we may use `window.history.state` that
    gives access to states before page reload.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following snippet shows how these methods can be clubbed for a quick browser
    history solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '**onhashchange approach:**'
  prefs: []
  type: TYPE_NORMAL
- en: The prevailing approach to solve the browser history issue is through URL hashes
    that look like `#foo`. The major motivation to use a hash is that changing it
    through `location.hash` would not refresh the page (unlike `location.href)` and
    would also add an entry in browser history, for some browsers. But, when the user
    hit the back or forward button, there was no easy mechanism to see if the URL
    hash has been changed. The `window.onhashchange` event has been introduced in
    newer browsers and will get executed when a hash change occurs.
  prefs: []
  type: TYPE_NORMAL
- en: The portability hack for the `hashchange` event is to constantly poll the hash
    changes through the `setInterval()` method. The shorter the polling interval,
    the better the responsiveness, but using too short a value will affect the performance.
  prefs: []
  type: TYPE_NORMAL
- en: '**iframe hack approach:**'
  prefs: []
  type: TYPE_NORMAL
- en: Some browsers, especially IE6, don't save state on hash changes. So, here, the
    workaround is to create an invisible `iframe` element and change its `src` attribute
    to track state. This is because the browser tracks the state for `iframe src`
    changes. So, when a user hits the browser's back or forward button, they have
    to poll the `src` attribute of `iframe` to update the UI.
  prefs: []
  type: TYPE_NORMAL
- en: '**Combining all approaches:**'
  prefs: []
  type: TYPE_NORMAL
- en: For better browser compatibility and performance, it's essential to combine
    all of the previous approaches. The jQuery History plugin abstracts all these
    approaches and provides better functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing comet PHP and Ajax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In traditional client-server communication over HTTP, for every response from
    a server, a request is made by the client. In other words, there is no response
    without a request.
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing comet PHP and Ajax](graphics/3081_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Comet, Ajax Push, Reverse Ajax, Two-way-web, HTTP Streaming, or HTTP server
    push are the collective terms used to refer to the implementation of instantaneous
    data changes pushed from the server. Unlike in traditional communication, here,
    the request from the client is made once and all the data/responses are pushed
    from the server—without further request calls from the client.
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing comet PHP and Ajax](graphics/3081_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Through comet, we can create Ajax chat and other live applications. Before the
    introduction of HTML5's WebSocket API, JavaScript developers had to go for hacks,
    such as using `iframe`, long polling Ajax, and so on
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many comet technologies available, including a pure JavaScript approach
    over Apache web server. But, when looking at performance and approaches, the open
    source APE (Ajax Push Engine) technology looks promising. APE has two components:'
  prefs: []
  type: TYPE_NORMAL
- en: APE Server
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: APE JSF (APE JavaScript Framework)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The server is written in C and the JavaScript framework is based on Mootools,
    but can also be used with other frameworks such as jQuery. APE Server modules
    are extensible through JavaScript code. It supports transport methods, such as
    Long Polling, XHR Streaming, JSONP, and Server Sent Events. Some of the mentioned
    advantages of APE Server are:'
  prefs: []
  type: TYPE_NORMAL
- en: Apache-based solutions cannot do a real push
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: APE can handle more than 100k users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: APE is faster than an Apache comet-based solution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: APE saves lot of bandwith
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: APE provides more options than simple comet solutions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll require an APE Server for our comet experiments. An APE Server installed
    on Linux is recommended, though it can run on a Windows machine with VirutalBox.
    It can be downloaded from [http://www.ape-project.org/](http://www.ape-project.org/).
  prefs: []
  type: TYPE_NORMAL
- en: We will have to configure the APE client script with server settings in `Build/uncompressed/apeClientJS.js:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll see how a simple comet client-server interaction can be done. We'll also
    see how the APE Server can be used to broadcast messages to clients over the comet
    setup. We need some basic understanding of APE terminologies before setting up
    the comet.
  prefs: []
  type: TYPE_NORMAL
- en: '**Pipe:**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Pipes are communication conduits to exchange data between the client and server
    and they are the core of the communication system. There are two main types of
    pipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Multi pipe or Channel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uni pipe or User
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A pipe is identified by a 32-character unique ID generated by a server called
    pubid.
  prefs: []
  type: TYPE_NORMAL
- en: '**Channel:**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A channel is a communication conduit that can be directly created by the server
    or by a user. It is automatically created if a user subscribes to a channel that
    doesn''t exist. Each channel has a list of properties and has two ways of working:'
  prefs: []
  type: TYPE_NORMAL
- en: Interactive Channel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Non-Interactive Channel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A user who subscribes to an existing interactive channel, will receive a list
    of all other users who have subscribed to that channel and can directly communicate
    with them via the channel pipe. In a non-interactive channel, the communication
    is read-only and users do not know each other, also, they can't communicate through
    the channel. The creation of a non-interactive channel can be initiated by prefixing
    the channel name with the * character.
  prefs: []
  type: TYPE_NORMAL
- en: '**User:**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When a user connects to the APE, a pipe is created for communication with other
    entities, and a unique sessid is assigned to the pipe. That ID helps the server
    to identify the user that sends each command. A user can perform actions that
    allow them to:'
  prefs: []
  type: TYPE_NORMAL
- en: Post a message on a pipe for a channel or another user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Subscribe/join a channel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unsubscribe/leave a channel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a channel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code connects the client with the server and joins the user with
    a channel named `myChannel`. When a user joins the channel, it sends a test message
    to other users on the channel `myChannel`. Note that the message is shared through
    the channel name.
  prefs: []
  type: TYPE_NORMAL
- en: 'To push some messages from the server side, APE offers a mechanism called `inlinepush`.
    This `inlinepush` can be triggered by invoking the APE Server''s URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: APE's underlying protocol uses JSON for data transmission. Connection from client
    to server is initiated with APE's `start()` method. Joining a channel or creating
    a new channel is initiated with the `join()` method. Messages to other users available
    on the channel are then passed over the `send()` method. More than one browser
    window or tab should be opened to see the message transmitted from one window
    to the other windows.
  prefs: []
  type: TYPE_NORMAL
- en: APE's `inlinepush` mechanism offers a way to push messages to the channel users
    without using a client. Such pushes can be initiated by invoking a JSON-encoded
    URL with commands. From PHP, such URLs can be triggered by cURL calls or a simple
    `file_get_contents()` call.
  prefs: []
  type: TYPE_NORMAL
