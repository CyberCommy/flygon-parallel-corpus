- en: SOLID and Other Principles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The world of software is riddled with principles and acronyms. There are many
    firm and entrenched ideas about how we should go about writing code. The sheer
    quantity of all of them can be overwhelming, making it especially hard to know
    which path to take when designing an abstraction. JavaScript's ability to accommodate
    many different paradigms is one of its strengths as a programming language, but
    it can also make our job harder. It's up to JavaScript programmers to implement
    their own paradigms.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter, in the hope of making things less complicated, will take various
    well-known principles and break them down so we can see their underlying intent.
    We will explore how these principles relate to the tenets of clean code that we
    have already discussed, enabling us to make our own informed decisions as to what
    approaches to use in pursuit of clean code.
  prefs: []
  type: TYPE_NORMAL
- en: We'll be covering both object-oriented and functional programming principles.
    By exploring this range of principles, we'll be able to craft, for ourselves,
    a map of guiding ideas that will enable us to think critically about how to write
    clean code in whatever paradigm we're engaged in.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The **Law of Demeter** (**LoD**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SOLID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The abstraction principle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functional programming principles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Law of Demeter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we delve into the SOLID arena, it''s useful to explore a less well-known
    principle, known as LoD, or the principle of least knowledge. This so-called law
    has three core ideas:'
  prefs: []
  type: TYPE_NORMAL
- en: A unit should have only limited knowledge about other units
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A unit should only talk to its immediate friends
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A unit should not talk to strangers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You may rightfully wonder what it means for a unit to *talk* to a *stranger*.
    A unit, in this context, is a specific coded abstraction: possibly a function,
    a module, or a class. And *talking* here means *interfacing with*, such as calling
    the code of another module or having that other module call your code.'
  prefs: []
  type: TYPE_NORMAL
- en: This is a very useful and simple law to learn and then apply to all our programming,
    whether we're writing an individual line of code or designing an entire architecture.
    It is, however, often forgotten or ignored.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take the example of the simple act of making a purchase in a shop. We
    can express this interaction with `Customer` and `Shopkeeper` abstractions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s also say that the `Customer` class has a wallet where they store their
    money:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'A simplified version of an interaction between the `Shopkeeper` and the `Customer`
    may go something like the following globally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This may look okay, but let's consider a real-life analogy of this interaction.
    The shopkeeper takes the wallet from the customer's pocket and then proceeds to
    open the wallet and take the desired amount without in any way interacting with
    the customer directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s immediately obvious that this would never be a socially appropriate interaction
    in real life, of course, but crucially, the shopkeeper is making assumptions outside
    of their remit. The customer may wish to pay using a different mechanism, or may
    not even have a wallet. The nature of the customer''s payment is their own business.
    This is what we mean when we say *only talk to friends*: you should only interface
    with abstractions that you should have knowledge of. The shopkeeper here should
    not (and would not) have knowledge of the customer''s wallet and so should not
    be *talking* to it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Taking this learnings on board, we can program a cleaner abstraction as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This now seems more reasonable. The `Shopkeeper` is talking to the `Customer`
    directly. The customer, in turn, will *talk to* their `CustomerWallet` instance,
    retrieving the desired amount and then handing it to the shopkeeper.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have all likely written code that somewhat violates the LoD. Of course,
    the code we write is not always as contrived or neatly exemplified by real-life
    as the interaction between a shopkeeper and a customer, but nonetheless, the LoD still
    applies. We can illustrate this further with a typical piece of JavaScript that
    is responsible for displaying a message to the user via the **document object
    model** (**DOM**):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This is quite typical and idiomatic frontend JavaScript. To display the `Birthday`
    message within a document, we first construct the string ourselves and place it
    in a text node, which itself is appended to a `<div>` element with `message `and
    `birthday-message` classes. We then take this DOM tree and append it to the document
    so it can be viewed by the user.
  prefs: []
  type: TYPE_NORMAL
- en: The DOM is a set of APIs that enables us to interface with a parsed HTML document,
    usually within the browser. The DOM, as a term, is also used to describe the tree
    of nodes generated by this parsing process. So, a DOM tree can be derived from
    a given HTML document, but we can also construct our own DOM trees and manipulate
    them freely.
  prefs: []
  type: TYPE_NORMAL
- en: 'Does the preceding code abide by the LoD? Our abstraction here, the `displayHappyBirthday` function,
    is concerned with the concept of a happy birthday message and is *talking* directly
    to the DOM. The DOM, however, is not its friend. The DOM is an implementation
    detail—a stranger—in the concept of a `Happy Birthday` message. The `Happy Birthday`
    message mechanism should not be required to have knowledge about the DOM. It would,
    therefore, be appropriate to build another abstraction that bridges these two
    strangers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have a more generic `displayMessage` function that is interfacing
    directly with the DOM—a friend. Our `displayHappyBirthday` function could then
    be changed so that it purely interacts with this `displayMessage` abstraction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This code can now be said to be more loosely coupled to the implementation
    of `displayMessage`. We could later decide to change the exact mechanism that
    we use to display messages without altering the `displayHappyBirthday` function
    at all. We''ve therefore bolstered the maintainability of code. By generalizing a
    common piece of functionality—displaying a message—we also make future features
    much more seamless—for example, displaying a `Happy New Year` message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The LoD*,* at its core, is concerned with which abstractions we feel should
    interface with other abstractions. It does not provide guidance as to what a *friend* or
    a *stranger* is or what it means for a unit to only have limited knowledge of
    other units. The law challenges us to define these terms for ourselves, alongside
    the abstractions we're building. It's our responsibility to stop and consider
    how our abstractions are interfacing, and whether perhaps we should design them
    differently.
  prefs: []
  type: TYPE_NORMAL
- en: I chose to write about this principle first as I feel it is the most memorable
    and most generally useful tool for writing clean code with clean abstractions.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we'll be discussing SOLID and other principles that all, in their own
    ways, complements the LoD.
  prefs: []
  type: TYPE_NORMAL
- en: SOLID
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'SOLID is a commonly packaged set of principles that are useful when constructing
    both individual modules or larger architectures. Specifically, it is an acronym
    that stands for five specific **object-oriented programming** (**OOP**) design
    principles:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Single responsibility principle**(**SRP**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Open-closed principle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Liskov substitution principle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interface segregation principle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependency inversion principle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is not vital to remember these names or even the acronym itself, but the
    ideas behind each of these principles are useful. In this section, we're going
    to explore each principle alongside JavaScript examples. It's important to note
    that, while SOLID relates mostly to OOP, there are deeper truths underlying it
    that are useful regardless of your programming paradigm.
  prefs: []
  type: TYPE_NORMAL
- en: Single responsibility principle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we write code, we are constantly building abstractions; when doing this,
    we are interested in building the right ones, delineated in the right way. The
    SRP helps us to figure out how to delineate these abstractions by looking at their
    responsibilities.
  prefs: []
  type: TYPE_NORMAL
- en: Responsibility, in this context, refers to the purpose and area of concern that
    your abstraction encompasses. A function that validates phone numbers can be said
    to have a singular responsibility. A function that both validates and normalizes
    those numbers with their country codes, however, can be said to have two responsibilities.
    The SRP would tell us that we need to split that abstraction into two separate
    ones.
  prefs: []
  type: TYPE_NORMAL
- en: 'The aims of the SRP are to arrive at code that is highly cohesive. Cohesiveness
    is when an abstraction''s parts are all functionally united in some way, where
    they can all be said to work together to fulfill the abstraction''s purpose. A
    useful question about discerning singular responsibility is: *how many reasons
    does your abstraction''s design have to change*?'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can explore this question using an example. Say that we are tasked with
    building a small calendar application. We might imagine, initially, that there
    are two distinct abstractions here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Event` class can be said to contain time and metainformation about an
    event, and the `Calendar` class can be said to contain events. The basic starting
    premise is that you can both add and remove one or more `Event` instances to and
    from a `Calendar` instance. Here, we express the methods used to add and remove
    events from `Calendar`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Over time, we have to add various other pieces of functionality to our `Calendar`,
    such as methods for retrieving events within specific dates, and methods to export
    events in various formats:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Even without implementations, you can see how the addition of all of these
    methods has created a far more complex class. Technically, all of these methods
    are related to the functionality of a calendar, so there is an argument for them
    to remain within one abstraction, but if we go back to the question we posed—*How
    many reasons does our abstraction''s design have to change?—*we can see that the
    `Calendar` class now has many possible reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: The way time is defined on events may need to change
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The way titles are defined on events may need to change
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The way events are searched for may need to change
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The XML schema may need to change
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The JSON schema may need to change
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Given the number of different reasons for potential change, it makes sense
    to split the change into more appropriate abstractions. The methods for setting
    the time and title of a particular event (`setTimeOfEvent`, `setTitleOfEvent`),
    for example, definitely make sense within the `Event` class itself, as they''re
    highly related to the purpose of the `Event` class: to contain details regarding
    a specific event. And the methods that export to both JSON and XML should also
    be moved, perhaps into their own class that is solely responsible for the export
    logic. The following code shows the changes that we''ve made:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As you can hopefully see, each of our abstractions seems inwardly cohesive,
    and each one encapsulates its responsibilities far more cohesively than would
    be the case if all of that functionality resided solely within the `Calendar`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: The SRP is not only about creating abstractions that are simple to use and maintain,
    it also allows us to write code that is more focused on its key purpose. Being
    more focused in this way gives us a clearer path to optimize and test our units
    of code, which benefits the reliability and efficiency of our codebase. The correct
    delineation of cohesive abstractions, guided by the SRP, is probably one of the
    most significant ways you can improve the cleanness of your code.
  prefs: []
  type: TYPE_NORMAL
- en: Open–closed principle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The **open–closed principle** (**OCP**) states the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Software entities (classes, modules, functions, and so on) should be open
    for extension, but closed for modification'
  prefs: []
  type: TYPE_NORMAL
- en: -Meyer, Bertrand (1988)*
  prefs: []
  type: TYPE_NORMAL
- en: When crafting abstractions, we should enable them to be open to extension so
    that other developers can come along and build upon their behavior, adapting the
    abstraction to suit their needs. Extension, in this context, is best thought of
    as a broad term that encompasses all types of adaptation. If a module or function
    does not behave as we require it to, it would be ideal for us to be able to adapt
    it to our needs without having to modify it or create our own alternative.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following `Event` class and `renderNotification` method from our
    `Calendar` application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We may wish to have a separate type of event that renders a notification prefixed
    with the word `Urgent!` to ensure that the user pays more attention to it. The
    simplest way to achieve this adaptation is via inheritance of the `Event` class,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We are prefixing our urgent message by overriding the `renderNotification` method
    and calling the super class's `renderNotification` to fill in the remainder of
    the notification string. Here, via inheritance, we have achieved extension, adapting
    the `Event` class to our needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inheritance is only one way that extension can be achieved. There are various
    other approaches that we could take. One possibility is that, in the original
    implementation of `Event`, we foresee the need for custom notification strings
    and implement a way to configure a `renderCustomNotifcation` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This code presumes that there is a `config` object available. We are optionally
    calling the `renderCustomNotification` and passing the default notification string.
    If it hasn't been configured, then the default notification string is used anyway.
    This is crucially different from the inheritance approach in that the `Event`
    class itself is prescribing the itself is prescribing the possibilities possibilities
    extension that exist.
  prefs: []
  type: TYPE_NORMAL
- en: 'Providing adaptability via configuration means that users don''t need to worry
    about the internal implementation knowledge required when extending classes. The
    path to adaptation is simplified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This approach requires that your implementation can foresee its most likely
    adaptations and that those adaptations are predictably internalized into the abstraction
    itself. However, it is impossible to foresee all needs, and even if we tried to,
    we would likely end up creating such a complicated and large configuration that
    users and maintainers would suffer. So there is a balance to strike here: adaptability
    is a good thing, but we also must balance it with a focused and cohesive abstraction
    that has a constrained purpose.'
  prefs: []
  type: TYPE_NORMAL
- en: Liskov substitution principle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Liskov substitution principle** states that types should be able to be
    replaced by their subtypes without altering the reliability of the program. This
    is, on the surface, an obscure principle, so it's worth explaining it in terms
    of a real-world analogy.
  prefs: []
  type: TYPE_NORMAL
- en: Many real-world technological innovations share this characteristic of substitution.
    A Volvo XC90 is a type of car, as is a Ford Focus. Both provide the common interfaces
    that we have come to expect from cars. For us, as human users of these vehicles,
    we can assume that their respective means of operation inherit from a common schema
    of vehicle operation, such as having a steering wheel, doors, a brake pedal, and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The human assumption is that these two models of car are subtypes of the supertype
    c*ar*, and so I as a human can rely on the aspects that they each inherit from
    their supertype (the car). Another way of phrasing the Liskov substitution principle
    is: *A consumer of a type should only be concerned with the least specific type
    necessary to operate it reliably*. To build on the analogy, if we were to program
    a `Driver` abstraction in code, we would want it to interface generally with all
    `Car` abstractions rather than writing specific code that relies on specific models
    of car (such as the Volvo XC90).'
  prefs: []
  type: TYPE_NORMAL
- en: 'To make the Liskov substitution principle a little more concrete, let''s dive
    back into our `Calendar` application example. In the preceding section on the
    open-closed principle, we explored how to extend the `Event` class via inheritance
    with a new `ImportantEvent` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The assumption implicit in our doing this is that our `Calendar` class and
    its implementation will not be concerned with whether events are `Events` or subclasses
    of `Events`. We expect that it will treat them the same. The `Calendar` class
    may have a `notifyUpcomingEvents` method, for example, that iterates through all
    upcoming events and calls `renderNotification` on each event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: What's crucial here is that the `Calendar` implementation makes no deliberations
    as to the type of `Event` instance that it is dealing with. In fact, the preceding
    code (which doesn't account for the entire implementation) only prescribes that
    event objects have a `startsWithinMinutes` method and a `renderNotification` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Related to the Liskov substitution principle is an idea that we''ve already
    discussed: the principle of least information (LoD), which drives us to ask: what
    is the least information that this abstraction requires in order to fulfill its
    purpose? In the case of `Calendar`, it only needs to prescribe that events have
    the methods and properties that it will use. There is no good reason for it to
    make deliberations beyond that. Not only can the `Calendar` implementation now
    deal with subclasses of events, but it can deal with any objects that supply the
    desired properties and methods.'
  prefs: []
  type: TYPE_NORMAL
- en: Interface segregation principle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **interface segregation principle** is concerned with keeping interfaces
    highly cohesive, engaged in only one task or a set of tasks that are highly related.
    It states that *no client should be forced to depend on methods that it does not
    use*.
  prefs: []
  type: TYPE_NORMAL
- en: 'This principle is similar in spirit to the principle of single responsibility:
    its goal is to ensure that you create focused and highly-cohesive abstractions
    that are only concerned with a single area of responsibility. But instead of making
    you consider the concept of responsibility itself, it makes you look at the interfaces
    that you''re creating and consider whether they''re appropriately segregated.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider a local government office. They have a paper form (let''s call it
    Form 1A) that it uses to change a person''s details. It is a form that''s existed
    for over 50 years. Via this form, a local citizen can change a number of their
    details, including, but not limited to, the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A change of name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A change of marital status
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A change of address
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A change of council tax discount status (student/elderly)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A change of disability status
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As you can imagine, it''s a very complex and dense form, with many independent
    sections that a citizen must ensure they fill out correctly. We''ve all likely
    been exposed to the bureaucratic complexity of government paperwork, as shown
    in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/902a31b4-da7b-4b0f-a33e-d522f264f486.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Form 1A provides a set of interfaces to the various change functions that are
    provided by the local government office. The interface segregation principle asks
    us to consider whether this form is forcing its clients to depend on methods that
    they don''t use. In this context, the clients are the users of the form, the citizens,
    and the methods are all of the available functions that the form provides: the
    ability to register a name change, an address change, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As is hopefully obvious by now, Form 1A does not follow the interface segregation
    principle very well. If we were to redesign it, we would likely separate out the
    individual functions it serves into their own independent forms. The way we''d
    do this is by employing something we learned at the beginning of the chapter:
    the principle of least information (LoD), which asks us a very simple question:
    What''s the least amount of information each abstraction (for example, changing
    one''s address) requires? We can then choose to only include in each form what
    is needed to fulfill its function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/1d39fbfe-ed00-4fcf-bf89-f089d45f1c06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To separate out and then only include the necessary fields in paper forms such
    as these may seem quite obvious, but it''s something programmers continually neglect
    to do effectively within their coded abstractions. The interface segregation principle
    reminds us of the importance of properly separating out our abstractions into
    interfaces that are distinct and internally cohesive. Doing so has the following
    benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Increased reliability**: Having properly isolated interfaces that are truly
    decoupled makes code easier to test and verify, thereby aiding its general reliability
    and stability over time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Increased maintainability**: Having segregated interfaces means that changes
    to one needn''t affect the others. As we saw in the layout of Form 1A, the positioning
    and space available are heavily dependent on each part of the form. Once we have
    decouple these dependencies, however, we are free to maintain and change each
    one as we see fit, without worrying about the others.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Increased usability**: Having interfaces that are separated according to
    their purpose and function means that users are able to understand and navigate
    the interfaces with far less time and cognitive effort. The users are the consumers
    of our interfaces, and so are the most dependent on the interfaces being clearly
    delineated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependency inversion principle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The dependency inversion principle states the following:'
  prefs: []
  type: TYPE_NORMAL
- en: High-level modules should not depend on low-level modules. Both should depend
    on abstractions (that is, interfaces)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Abstractions should not depend on details. Details (such as concrete implementations)
    should depend on abstractions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The first point may remind you of the LoD. It is largely talking about the
    same concept: the separation of high-level from low-level.'
  prefs: []
  type: TYPE_NORMAL
- en: Our abstractions should be separated (decoupled) in such a way that we can easily
    change low-level implementation details at a later date without having to refactor
    all of our code. The dependency inversion principle, in its second point, suggests
    that we do this via intermediary abstractions through which the high-level modules
    can interface with the low-level details. These intermediary abstractions are
    sometimes known as adapters, as they adapt a low-level abstraction for consumption
    by a high-level abstraction.
  prefs: []
  type: TYPE_NORMAL
- en: Why is it called dependency inversion?A high-level module may initially depend
    on a low-level module. In languages that provide OOP concepts such as abstract
    classes and interfaces *(*a type of schematic for classes*)*, such as Java, it
    can be said that a low-level module may end up depending upon the interface, as
    it is the interface that provides the scaffolding on which the low-level module
    is implemented. The high-level module also depends on this interface, so that
    it may utilize the low-level module. We can see here how the dependencies are
    inverted so that both high- and low-level modules depend on the same interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Considering our `Calendar` application once again, let''s say that we wanted
    to implement a way to retrieve events happening within a specific radius of a
    fixed location. We may choose to implement a method like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `getEventsAtLocation` method here is responsible for retrieving events that
    are within a certain radius (measured in kilometers) from a given location. As
    you can see, it uses both a `GeoCoder` class and a `DistanceCalculator` class
    to achieve its purpose.
  prefs: []
  type: TYPE_NORMAL
- en: The `Calendar` class is a high-level abstraction, concerned with the broad concepts
    of a calendar and its events. The `getEventsAtLocation` method, however, contains
    a lot of location-related details that are more of a low-level concern. The `Calendar`
    class here is  concerns itself with which formula to utilize on the `DistanceCalculator` and
    the units of measurement used in the calculation. You can see how, for example,
    the `kilometerRadius` argument must be divided by `1000` to get the distance in
    meters, which is then compared to the distance returned from the `haversineFormulaDistance`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'All of these details should not be the business of a high-level abstraction,
    such as `Calendar`. The dependency inversion principle asks us to consider how
    we can abstract away these concerns to an intermediary abstraction that acts as
    a bridge between high-level and low-level. One way in which we may accomplish
    this is via a new class, `EventLocationCalculator`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This class could then be utilized by the `Event` class in its own `isEventWithinRadiusOf`
    method. An example of this is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Therefore, all the `Calendar` class needs to concern itself with is the fact
    that `Event` instances have `isEventWithinRadiusOf` methods. It needs no information
    and makes no prescriptions as to the specific implementation that determines distances;
    the details of that are left to our lower-level `EventLocationCalculator` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The dependency inversion principle is similar to other principles that are
    related to the delineation of abstractions, such as the interface segregation
    principle, but is specifically concerned with dependencies and how these dependencies
    are directed. As we design and build abstractions, we are, implicitly, setting
    up a dependency graph. For example, if we were to map out the dependencies for
    the implementation that we arrived at, then it would look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a504d714-ae69-4ef8-a0d2-4c5ffdc9c8c3.png)'
  prefs: []
  type: TYPE_IMG
- en: It's incredibly useful to draw dependency graphs such as these. They are a useful
    way to explore the true complexity of your code, and can often highlight areas
    of possible improvement. Most importantly, they let us observe where, if anywhere,
    our low-level implementations (details) impact our high-level abstractions. Only
    when we see such situations can we remedy them. So, as you advance through this
    book and beyond, always have in your mind's eye a graph of the dependencies; it'll
    help to steer you toward more decoupled, and thus more reliable, code.
  prefs: []
  type: TYPE_NORMAL
- en: The dependency inversion principle is the very last of the SOLID acronym, and
    SOLID, as we've seen, is chiefly concerned with *how* we go about building abstractions.
    The next principle we'll cover binds together a lot of the content we've covered
    so far, as it is the principle of abstraction itself. If we remember nothing else
    from this chapter, then we should, at least, remember the **abstraction principle**.
  prefs: []
  type: TYPE_NORMAL
- en: The abstraction principle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the first chapter, we introduced the concept of a tower of abstractions,
    and the idea that every abstraction is a simplified lever to hidden complexity.
    The principle of abstraction within programming states the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Implementation should be separate from interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'An implementation is the complex underside of an abstraction: the part that
    it''s hiding. The interface is the simplified topside. That is why we say that
    abstraction is a simplified lever to hidden complexity. The craft of creating
    abstractions that separate implementation from interface to just the right degree
    is not as simple as it may seem. As such, the programming world provides two warnings for
    us:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Don''t repeat yourself** (**DRY**): A warning that tells us to avoid writing
    code that duplicates other code we have written. If you find yourself having to
    repeat yourself, then this indicates that you''ve failed to abstract something,
    or have under-abstracted something.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**You aren''t gonna need it** (**YAGNI**): Also known as **keep it simple,
    stupid!** (**KISS**), this warning tells us to be wary of over-abstracting code
    that does not need to be abstracted. It''s the polar opposite of DRY, and serves
    to remind us that we should not attempt abstraction unless it''s warranted (if
    we start to repeat ourselves, perhaps).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Between these two warnings, somewhere in the middle, lies the perfect abstraction.
    Designing abstractions so that they are maximally simple and maximally useful
    is a balancing act. On the one hand, we can say we have under-abstraction (DRY
    warns us about this) and, on the other hand, we have over-abstraction (YAGNI warns
    us about this).
  prefs: []
  type: TYPE_NORMAL
- en: Over-abstraction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Over-abstraction is when too much complexity has been removed or replaced, so
    that the underlying complexity becomes difficult to leverage. The risk with over-abstraction
    is that we either remove too much complexity in favor of simplicity or we add
    new unnecessary complexity that confuses the user of our abstraction.
  prefs: []
  type: TYPE_NORMAL
- en: For example, say that we are in need of a gallery abstraction that we want to
    use to display a gallery on both our website and various mobile applications.
    Depending on the platform, the gallery will use the interfaces available to produce
    the layout. On the web, it would produce HTML and DOM, but on a mobile application,
    it would use the various native UI SDKs available. The abstraction provides a
    lever to all that cross-platform complexity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our initial requirements for the gallery are quite simple:'
  prefs: []
  type: TYPE_NORMAL
- en: The ability to display one or more images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to display captions alongside images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to control the dimensions of individual images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An external team has created a Gallery component for us to use. We open the
    documentation and see that it has the following example code, showing us how to
    create a gallery with two images:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This interface seems very complex for the basic purpose of only displaying
    a couple of images. Considering our simple requirements, we can say that the preceding
    interface is evidence of over-abstraction: instead of simplifying the underlying
    complexity, it has introduced a whole new realm of complexity and various features
    that we don''t even need. It does technically fulfill our requirements, but we
    must navigate its realm of complexity to achieve what we want.'
  prefs: []
  type: TYPE_NORMAL
- en: An abstraction like this, which encodes new complexities and prescribes its
    own features and naming conventions, is at risk of not only failing to reduce
    complexity, but also of increasing it! An abstraction has no business in increasing
    complexity; that is antithetical to the entire point of abstraction.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that the appropriate level of abstraction is context-dependent.
    What may be over-abstracted for your use case may be under-abstracted for another.
    The driver of an F1 racing car would require different levels of abstraction over
    their engine than a Ford Focus driver. Abstraction, like many clean-code concepts,
    is audience- and user-dependent.
  prefs: []
  type: TYPE_NORMAL
- en: 'Over-abstraction can, curiously, also take the form of over-simplification,
    where levers to the underlying complexity are not made available to us. An oversimplified
    version of our `GalleryComponent` interface may look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This minimal interface may seem like the polar opposite of the previous code,
    and in some ways it is, but curiously, it is also an example of over-abstraction.
    Remember, abstraction is when we provide a lever to underlying complexity via
    an interface. In this case, the lever is just too simple, only providing very
    limited leverage for the complexity that we wish to harness. It does not allow
    us to add captions or control image dimensions; it only allows us to list a set
    of images, nothing more.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having gone through the two previous examples, you''ve seen how over-abstraction
    can come in two distinct flavors: one that over-complicates and one that over-simplifies.
    These are both undesirable.'
  prefs: []
  type: TYPE_NORMAL
- en: Under-abstraction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If over-abstraction is when *too much* complexity has been removed or replaced,
    then under-abstraction is when *too little* complexity has been removed or replaced.
    This results in a situation where the user of the abstraction then needs to concern
    themselves with the underlying complexity. Imagine that you have a car that you
    must drive without a steering wheel or dashboard. You must control it directly
    via the engine by pulling levers and cranking oily cogs with your bare hands while
    keeping an eye on the road. We can say that this car has an under-abstracted method
    of control.
  prefs: []
  type: TYPE_NORMAL
- en: 'We explored the over-abstracted versions of our gallery component, so let''s
    see what an under-abstracted version might look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This version of `GalleryComponent` seems to be forcing us to define web-specific
    HTML and Android-specific code. We were, ideally, depending on the abstraction
    to hide this complexity from us, giving us a simplified interface with which to
    harness—it hasn't done this.  The complexity of writing platform-specific code
    has not been sufficiently abstracted here, and so we can therefore say that this
    is an example of under-abstraction.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the previous code, you can also see that we are being made to repeat the
    source URL of our image and the caption text. This should remind us of one of
    the warnings we explored earlier: DRY, which indicates that we have not sufficiently
    abstracted something.'
  prefs: []
  type: TYPE_NORMAL
- en: If we keep an eye out for areas in which we are forced to repeat ourselves,
    then we can hope to build better abstractions. But be aware that under-abstraction
    is not always obvious.
  prefs: []
  type: TYPE_NORMAL
- en: 'Various abstractions can be said to be *leaky abstractions* because they *leak* parts
    of their complexity upwards, through their interfaces. The previous code is an
    example of this: we can say that it is leaking the implementation details of its
    cross-platform complexities upward.'
  prefs: []
  type: TYPE_NORMAL
- en: Balanced abstraction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Given what we''ve learned about under- and over-abstraction, we can say that
    a balanced abstraction is one that sits neatly in between these two undesirable
    opposites. The skill of creating a balanced abstraction is both an art and a science,
    and requires that we have a very good understanding of both the problem domain
    and the user''s capabilities and intents. By employing many of the principles
    and warnings in this chapter, we can hope to remain balanced in our code building.
    For the previous example of a `GalleryComponent`, we should, once again, explore
    the requirements of the abstraction:'
  prefs: []
  type: TYPE_NORMAL
- en: The ability to display one or more images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to display captions alongside images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to control the dimensions of individual images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These, we can say, are the *levers* that we must provide to the underlying
    cross-platform complexity. Our abstraction should solely aim to expose these levers
    and no other unnecessary complexity. The following is an example of such an abstraction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Via this interface, we can define one or more images, set their dimensions,
    and define captions for each image. It fulfills all of the requirements without
    inviting new complexities or leaking complexities from the underlying implementation.
    This is, therefore, a balanced abstraction.
  prefs: []
  type: TYPE_NORMAL
- en: Functional programming principles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JavaScript allows us to program in a variety of different ways. Many of the
    examples we've shared so far in this book have been more inclined towards OOP,
    which primarily uses objects to express problem domains. Functional programming is
    different in that it uses mostly pure functions and immutable data to express
    problem domains.
  prefs: []
  type: TYPE_NORMAL
- en: 'All programming paradigms are broadly interested in the same thing: making
    it easier to express problem domains, to communicate our intent as programmers,
    and to accommodate the creation of useful and usable abstractions. The best principles
    we adopt from one paradigm may still apply to another, so adopt an open-minded
    approach!'
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s easiest to observe and discuss the difference between OOP and functional
    programming by exploring an example. Let''s imagine that we wish to build a mechanism
    so that we can fetch paginated data from a server. To achieve this in an object-oriented
    way, we might create a `PaginatedDataFetcher` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is an example of how you would use the `PaginatedDataFetcher`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, with each call to `getNextPage`, we retrieve the next page of
    data. The `getNextPage` method relies on the remembered state of its objects,
    `endpoint` and `nextPage`, in order to know which URL to request next.
  prefs: []
  type: TYPE_NORMAL
- en: A **state** can be thought of as the underlying remembered data of any program
    or piece of code that its results or effects are derived from. The state of a
    car may mean its current upkeep, its fuel and oil levels, and so on. Likewise,
    the state of a running program is the underlying data that it derives its functionality
    from.
  prefs: []
  type: TYPE_NORMAL
- en: Functional programming, as distinct from OOP, is purely interested in the usage
    of functions and immutable state to achieve its goals. The first mental blocker
    that people usually encounter when exploring functional programming is related
    to states, raising questions such as *Where should I store my state?* and *How
    do I make things change without being able to mutate that state?* We can explore
    this question by looking at the functionally programmed equivalent of the paginated
    data fetcher.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have created a function, `getPage`, to which we will pass an `endpoint`
    and a `pageNumber`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'When called, the `getPage` function will return an object containing the response
    from the server, as well as the `endpoint` and `pageNumber` used. In addition
    to these properties, the object will also contain a function named `next`, which
    itself, if called, will fire off another request via a subsequent call to `getPage`*.*
    It can be used in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: You'll notice that, when using this pattern, we only need a reference to the
    last retrieved page in order to make the next request. Page 3 is retrieved via
    page 2's returned `next()` function. Page 4 is retrieved via page 3's returned
    `next()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `getPage` function does not mutate any data: it only uses the passed data
    to derive new data, and therefore, it can be said that it employs immutability.
    It can also be said that it is a pure function as well, in that, with a given
    set of input parameters (an `endpoint` and a `pageNumber`), it will always return
    the same thing. The `next` function returned by `getPage` is also pure, as it
    will always return the same thing: if I call `page2.next()` a million times, it''ll
    always fetch `page 3`.'
  prefs: []
  type: TYPE_NORMAL
- en: Functional purity and immutability are among the most vital functional concepts
    to understand, and, usefully, are principles that are applicable to all paradigms
    of programming. We're not looking to thoroughly explore functional programming
    here, but just to cover its most applicable principles in order to bolster our
    abstraction-crafting abilities.
  prefs: []
  type: TYPE_NORMAL
- en: Functional purity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Functions can be said to be pure when their return value is only derived from
    their input values (also called **idempotence**), and when there are no side-effects.
    These characteristics give us the following benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Predictability:** A function that does not have any side-effects on other
    areas of the program is a function that can be easily reasoned about. If a function
    mutates a state that it does not own, potentially creating cascades of changes
    in other areas of the code, it can be incredibly complicated to disentangle, creating
    maintenance and reliability issues.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Testability**: A pure function, thanks to the characteristic of always returning
    the same result when given the same inputs, is very easy to verify. Pure functions
    can become complex but, if kept pure, they will always be easily testable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Idempotence is the characteristic of always deriving the same result when provided
    with a certain input. An idempotent function is therefore highly deterministic.
    An idempotent function may still have side-effects, so it may not always be a *pure*
    function, but from the perspective of an abstraction user, idempotence is highly
    desirable, as it means that we always know what to expect.
  prefs: []
  type: TYPE_NORMAL
- en: 'Often in OOP, methods on objects cannot be said to be pure since they mutate
    the state (on the object) or return different results with the same input parameters.
    Consider, for example, the following `Adder` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The `add` method here is not pure. It returns different results even when given
    the same arguments, and it has a side-effect: mutating a state that it does not
    own (that is the total property of the object). We could instead create a functionally
    pure addition abstraction very simply:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This may seem contrived, but the concept behind functional purity is to, from
    complex needs, derive the truly pure primitives and functions that are needed
    to construct it. Functional purity teaches us a general lesson here: to break
    down functionality to its most primal parts until you have a truly testable standalone
    unit. We can then compose these smaller units into larger units that do more complex
    work.'
  prefs: []
  type: TYPE_NORMAL
- en: Immutability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter has largely been about how we structure and separate our abstractions,
    but it is equally important to consider the expectations of the data that passes *between* these
    abstractions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Immutability refers to the simple idea that data should not mutate. This means
    that, when we initialize an object, for example, we should not add new properties
    to it or change existing properties over time. Instead, we should derive a brand
    new object and only make changes to our own copy. Immutability is a characteristic
    of data, but is also a general tenet of functional programming. A language can
    also enforce immutability by disallowing the mutation of already declared variables
    or objects. JavaScript''s `const` is an example of this type of enforcement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Knowing that something is immutable means that we can rest assured that it will
    not change; we can rely on its characteristics without worrying that some other
    part of the program may change it without us knowing. This is especially pertinent
    in the asynchronous world of JavaScript, where data is shuttled between scopes
    and interfaces in complex ways.
  prefs: []
  type: TYPE_NORMAL
- en: Like many of the principles we've covered in this chapter, immutability does
    not have to be followed religiously to gain benefits from it. Immutability in
    some areas, and mutability in others, can be a viable approach. Imagine an official
    document being shuttled around a government building. Each department has the
    implicit assumption that the document has not been arbitrarily modified by unexpected
    people; a specific department may choose to make a copy of the document and then
    make various mutations to its own copy for its own unique purposes. A codebase
    is not so different from this. By crafting abstractions and letting them interdepend
    on each other, we are intentionally enabling them to manipulate each other's data
    and functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered a vast amount of theory and practical skills. We
    covered the LoD (or principle of least information), all SOLID principles, the
    principle of abstraction, and a couple of key principles from the paradigm of
    functional programming. Even if you don't remember all of the names, you will hopefully
    remember the underlying knowledge and key lessons that each principle encapsulates.
  prefs: []
  type: TYPE_NORMAL
- en: Programming is as much an art as it is a science. It involves balancing all
    of these principles in the pursuit of crafting truly balanced abstractions. None
    of these principles should be considered hard-and-fast rules. They are merely
    guidelines that will help us on our journey.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we continue this journey by exploring one of the most
    challenging aspects of programming, both in JavaScript and outside it: the problem
    of naming things.'
  prefs: []
  type: TYPE_NORMAL
