- en: SOLID and Other Principles
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SOLID和其他原则
- en: The world of software is riddled with principles and acronyms. There are many
    firm and entrenched ideas about how we should go about writing code. The sheer
    quantity of all of them can be overwhelming, making it especially hard to know
    which path to take when designing an abstraction. JavaScript's ability to accommodate
    many different paradigms is one of its strengths as a programming language, but
    it can also make our job harder. It's up to JavaScript programmers to implement
    their own paradigms.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 软件世界充斥着原则和首字母缩略词。关于我们应该如何编写代码有许多坚定和根深蒂固的想法。所有这些原则的数量之多可能令人不知所措，特别难以知道在设计抽象时应该选择哪条道路。JavaScript能够适应许多不同的范式是它作为一种编程语言的优势之一，但这也可能使我们的工作更加困难。JavaScript程序员需要实现自己的范式。
- en: This chapter, in the hope of making things less complicated, will take various
    well-known principles and break them down so we can see their underlying intent.
    We will explore how these principles relate to the tenets of clean code that we
    have already discussed, enabling us to make our own informed decisions as to what
    approaches to use in pursuit of clean code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在希望使事情变得不那么复杂的这一章中，我们将介绍各种众所周知的原则，并将它们分解，以便我们可以看到它们的基本意图。我们将探讨这些原则如何与我们已经讨论过的清晰代码的原则相关联，使我们能够做出自己的明智决定，以便在追求清晰代码时使用什么方法。
- en: We'll be covering both object-oriented and functional programming principles.
    By exploring this range of principles, we'll be able to craft, for ourselves,
    a map of guiding ideas that will enable us to think critically about how to write
    clean code in whatever paradigm we're engaged in.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖面向对象和函数式编程原则。通过探索这些原则范围，我们将能够为自己制定一张指导思想的地图，这将使我们能够批判性地思考如何在我们所从事的任何范式中编写清晰的代码。
- en: 'In this chapter, we will be covering the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: The **Law of Demeter** (**LoD**)
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**迪米特法则**（**LoD**）'
- en: SOLID
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SOLID
- en: The abstraction principle
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象原则
- en: Functional programming principles
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数式编程原则
- en: The Law of Demeter
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迪米特法则
- en: 'Before we delve into the SOLID arena, it''s useful to explore a less well-known
    principle, known as LoD, or the principle of least knowledge. This so-called law
    has three core ideas:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨SOLID领域之前，探索一个不太知名的原则是很有用的，即所谓的迪米特法则，或者最少知识原则。这个所谓的法则有三个核心思想：
- en: A unit should have only limited knowledge about other units
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个单元应该只对其他单元有有限的了解
- en: A unit should only talk to its immediate friends
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个单元只应该和它的直接朋友交谈
- en: A unit should not talk to strangers
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个单元不应该和陌生人交谈
- en: 'You may rightfully wonder what it means for a unit to *talk* to a *stranger*.
    A unit, in this context, is a specific coded abstraction: possibly a function,
    a module, or a class. And *talking* here means *interfacing with*, such as calling
    the code of another module or having that other module call your code.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道一个单元*与陌生人交谈*是什么意思。在这种情况下，一个单元是一个特定的编码抽象：可能是一个函数、一个模块或一个类。这里的*交谈*意味着*接口*，比如调用另一个模块的代码或让另一个模块调用你的代码。
- en: This is a very useful and simple law to learn and then apply to all our programming,
    whether we're writing an individual line of code or designing an entire architecture.
    It is, however, often forgotten or ignored.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常有用且简单的法则，可以应用于我们所有的编程，无论是编写一行代码还是设计整个架构。然而，它经常被遗忘或忽视。
- en: 'Let''s take the example of the simple act of making a purchase in a shop. We
    can express this interaction with `Customer` and `Shopkeeper` abstractions:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以在商店购物的简单行为为例。我们可以用`顾客`和`店主`的抽象来表达这种互动：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let''s also say that the `Customer` class has a wallet where they store their
    money:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以说`顾客`类有一个钱包，他们在里面存放他们的钱：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'A simplified version of an interaction between the `Shopkeeper` and the `Customer`
    may go something like the following globally:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`店主`和`顾客`之间的简化交互版本可能是这样的：'
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This may look okay, but let's consider a real-life analogy of this interaction.
    The shopkeeper takes the wallet from the customer's pocket and then proceeds to
    open the wallet and take the desired amount without in any way interacting with
    the customer directly.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来可能没问题，但让我们考虑一下这种互动的现实生活类比。店主从顾客口袋里拿走钱包，然后打开钱包，拿走所需的金额，而不以任何方式直接与顾客互动。
- en: 'It''s immediately obvious that this would never be a socially appropriate interaction
    in real life, of course, but crucially, the shopkeeper is making assumptions outside
    of their remit. The customer may wish to pay using a different mechanism, or may
    not even have a wallet. The nature of the customer''s payment is their own business.
    This is what we mean when we say *only talk to friends*: you should only interface
    with abstractions that you should have knowledge of. The shopkeeper here should
    not (and would not) have knowledge of the customer''s wallet and so should not
    be *talking* to it.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，这在现实生活中永远不会是一种社交上合适的互动，但至关重要的是，店主正在做出超出他们权限范围之外的假设。顾客可能希望使用不同的支付方式，或者甚至可能没有钱包。顾客的支付方式是他们自己的事情。这就是我们所说的*只和朋友交谈*：你只应该与你应该了解的抽象进行接口。这里的店主不应该（也不会）了解顾客的钱包，因此不应该*与之交谈*。
- en: 'Taking this learnings on board, we can program a cleaner abstraction as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 接受这些教训，我们可以按照以下方式编写一个更清晰的抽象：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This now seems more reasonable. The `Shopkeeper` is talking to the `Customer`
    directly. The customer, in turn, will *talk to* their `CustomerWallet` instance,
    retrieving the desired amount and then handing it to the shopkeeper.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看起来更合理了。`店主`直接与`顾客`交谈。顾客反过来将*与*他们的`顾客钱包`实例*交谈*，取回所需的金额，然后交给店主。
- en: 'We have all likely written code that somewhat violates the LoD. Of course,
    the code we write is not always as contrived or neatly exemplified by real-life
    as the interaction between a shopkeeper and a customer, but nonetheless, the LoD still
    applies. We can illustrate this further with a typical piece of JavaScript that
    is responsible for displaying a message to the user via the **document object
    model** (**DOM**):'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很可能都写过一些违反了迪米特法则的代码。当然，我们编写的代码并不总是像商店老板和顾客之间的互动那样刻意或整洁，但迪米特法则仍然适用。我们可以通过一个典型的
    JavaScript 代码来进一步说明这一点，该代码负责通过文档对象模型（DOM）向用户显示消息：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This is quite typical and idiomatic frontend JavaScript. To display the `Birthday`
    message within a document, we first construct the string ourselves and place it
    in a text node, which itself is appended to a `<div>` element with `message `and
    `birthday-message` classes. We then take this DOM tree and append it to the document
    so it can be viewed by the user.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这是典型和惯用的前端JavaScript。要在文档中显示`生日`消息，我们首先自己构建字符串，并将其放入文本节点，然后将其附加到具有`message`和`birthday-message`类的`<div>`元素中。然后，我们将这个DOM树附加到文档中，以便用户查看。
- en: The DOM is a set of APIs that enables us to interface with a parsed HTML document,
    usually within the browser. The DOM, as a term, is also used to describe the tree
    of nodes generated by this parsing process. So, a DOM tree can be derived from
    a given HTML document, but we can also construct our own DOM trees and manipulate
    them freely.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: DOM是一组API，使我们能够与解析的HTML文档进行交互，通常在浏览器中。DOM作为一个术语，也用来描述由此解析过程生成的节点树。因此，DOM树可以从给定的HTML文档中派生，但我们也可以构建自己的DOM树并自由地操纵它们。
- en: 'Does the preceding code abide by the LoD? Our abstraction here, the `displayHappyBirthday` function,
    is concerned with the concept of a happy birthday message and is *talking* directly
    to the DOM. The DOM, however, is not its friend. The DOM is an implementation
    detail—a stranger—in the concept of a `Happy Birthday` message. The `Happy Birthday`
    message mechanism should not be required to have knowledge about the DOM. It would,
    therefore, be appropriate to build another abstraction that bridges these two
    strangers:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码是否遵守了迪米特法则？我们的抽象，`displayHappyBirthday`函数，关注的是生日快乐消息的概念，并且直接与DOM进行交互。然而，DOM并不是它的朋友。DOM是一个实现细节——一个陌生人——在`生日快乐`消息的概念中。`生日快乐`消息的机制不应该需要了解DOM。因此，适当的做法是构建另一个抽象来连接这两个陌生人：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here, we have a more generic `displayMessage` function that is interfacing
    directly with the DOM—a friend. Our `displayHappyBirthday` function could then
    be changed so that it purely interacts with this `displayMessage` abstraction:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个更通用的`displayMessage`函数，直接与DOM进行交互。我们的`displayHappyBirthday`函数可以被改变，使其纯粹与这个`displayMessage`抽象进行交互：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This code can now be said to be more loosely coupled to the implementation
    of `displayMessage`. We could later decide to change the exact mechanism that
    we use to display messages without altering the `displayHappyBirthday` function
    at all. We''ve therefore bolstered the maintainability of code. By generalizing a
    common piece of functionality—displaying a message—we also make future features
    much more seamless—for example, displaying a `Happy New Year` message:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以说这段代码与`displayMessage`的实现更松散地耦合在一起。我们以后可以决定改变我们用来显示消息的确切机制，而不需要改变`displayHappyBirthday`函数。因此，我们增强了代码的可维护性。通过概括一个常见的功能——显示消息，我们还可以使未来的功能更加无缝——例如，显示`新年快乐`的消息：
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The LoD*,* at its core, is concerned with which abstractions we feel should
    interface with other abstractions. It does not provide guidance as to what a *friend* or
    a *stranger* is or what it means for a unit to only have limited knowledge of
    other units. The law challenges us to define these terms for ourselves, alongside
    the abstractions we're building. It's our responsibility to stop and consider
    how our abstractions are interfacing, and whether perhaps we should design them
    differently.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 迪米特法则，本质上关注的是我们认为应该与其他抽象进行接口的抽象。它并不提供关于*朋友*或*陌生人*是什么，或者一个单元只能有有限的其他单元知识的指导。这个法则挑战我们为自己定义这些术语，以及我们正在构建的抽象。我们有责任停下来考虑我们的抽象是如何进行接口的，也许我们应该以不同的方式设计它们。
- en: I chose to write about this principle first as I feel it is the most memorable
    and most generally useful tool for writing clean code with clean abstractions.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我选择首先写关于这个原则，因为我觉得它是最值得记住和最普遍有用的编写干净代码和干净抽象的工具。
- en: Next, we'll be discussing SOLID and other principles that all, in their own
    ways, complements the LoD.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论SOLID和其他原则，它们各自以不同的方式补充了迪米特法则。
- en: SOLID
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SOLID
- en: 'SOLID is a commonly packaged set of principles that are useful when constructing
    both individual modules or larger architectures. Specifically, it is an acronym
    that stands for five specific **object-oriented programming** (**OOP**) design
    principles:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: SOLID是一组常用的原则，用于构建单个模块或更大的架构。具体来说，它是一个缩写，代表五个特定的面向对象编程设计原则：
- en: '**Single responsibility principle**(**SRP**)'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单一职责原则（SRP）
- en: Open-closed principle
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开闭原则
- en: Liskov substitution principle
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 里氏替换原则
- en: Interface segregation principle
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口隔离原则
- en: Dependency inversion principle
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖倒置原则
- en: It is not vital to remember these names or even the acronym itself, but the
    ideas behind each of these principles are useful. In this section, we're going
    to explore each principle alongside JavaScript examples. It's important to note
    that, while SOLID relates mostly to OOP, there are deeper truths underlying it
    that are useful regardless of your programming paradigm.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 不必记住这些名字甚至是缩写本身，但这些原则背后的思想是有用的。在本节中，我们将探讨每个原则以及 JavaScript 示例。需要注意的是，虽然SOLID主要与面向对象编程有关，但其背后有更深层次的真理，无论你的编程范式如何，都是有用的。
- en: Single responsibility principle
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单一职责原则
- en: When we write code, we are constantly building abstractions; when doing this,
    we are interested in building the right ones, delineated in the right way. The
    SRP helps us to figure out how to delineate these abstractions by looking at their
    responsibilities.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编写代码时，我们不断地构建抽象；在这样做时，我们对构建正确的抽象、以正确的方式划分感兴趣。SRP通过查看它们的责任来帮助我们弄清楚如何划分这些抽象。
- en: Responsibility, in this context, refers to the purpose and area of concern that
    your abstraction encompasses. A function that validates phone numbers can be said
    to have a singular responsibility. A function that both validates and normalizes
    those numbers with their country codes, however, can be said to have two responsibilities.
    The SRP would tell us that we need to split that abstraction into two separate
    ones.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，责任指的是您的抽象所涵盖的目的和关注领域。验证电话号码的函数可以说具有单一责任。然而，同时验证和规范这些带有国家代码的号码的函数可以说具有两个责任。SRP会告诉我们需要将该抽象拆分为两个独立的抽象。
- en: 'The aims of the SRP are to arrive at code that is highly cohesive. Cohesiveness
    is when an abstraction''s parts are all functionally united in some way, where
    they can all be said to work together to fulfill the abstraction''s purpose. A
    useful question about discerning singular responsibility is: *how many reasons
    does your abstraction''s design have to change*?'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: SRP的目标是得到高度内聚的代码。内聚性是指抽象的各个部分在某种方式上都功能统一，它们可以说都共同工作以实现抽象的目的。关于识别单一责任的一个有用问题是：*您的抽象设计有多少个原因需要更改*？
- en: 'We can explore this question using an example. Say that we are tasked with
    building a small calendar application. We might imagine, initially, that there
    are two distinct abstractions here:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过一个例子来探讨这个问题。假设我们的任务是构建一个小型日历应用程序。最初，我们可能想象这里有两个不同的抽象：
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `Event` class can be said to contain time and metainformation about an
    event, and the `Calendar` class can be said to contain events. The basic starting
    premise is that you can both add and remove one or more `Event` instances to and
    from a `Calendar` instance. Here, we express the methods used to add and remove
    events from `Calendar`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: “事件”类可以说包含有关事件的时间和元信息，“日历”类可以说包含事件。基本的起始前提是您可以向“日历”实例添加和删除一个或多个“事件”实例。在这里，我们表达了用于向“日历”添加和删除事件的方法：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Over time, we have to add various other pieces of functionality to our `Calendar`,
    such as methods for retrieving events within specific dates, and methods to export
    events in various formats:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，我们必须向我们的“日历”添加各种其他功能，例如检索特定日期内的事件的方法，以及以各种格式导出事件的方法：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Even without implementations, you can see how the addition of all of these
    methods has created a far more complex class. Technically, all of these methods
    are related to the functionality of a calendar, so there is an argument for them
    to remain within one abstraction, but if we go back to the question we posed—*How
    many reasons does our abstraction''s design have to change?—*we can see that the
    `Calendar` class now has many possible reasons:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 即使没有实现，您也可以看到所有这些方法的添加已经创建了一个更加复杂的类。从技术上讲，所有这些方法都与日历的功能相关，因此有理由让它们保留在一个抽象中，但是如果我们回到我们提出的问题——*我们的抽象设计有多少个原因需要更改？*我们可以看到“日历”类现在有很多可能的原因：
- en: The way time is defined on events may need to change
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件上定义的时间可能需要更改
- en: The way titles are defined on events may need to change
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件上定义的标题的方式可能需要更改
- en: The way events are searched for may need to change
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 搜索事件的方式可能需要更改
- en: The XML schema may need to change
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XML模式可能需要更改
- en: The JSON schema may need to change
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSON模式可能需要更改
- en: 'Given the number of different reasons for potential change, it makes sense
    to split the change into more appropriate abstractions. The methods for setting
    the time and title of a particular event (`setTimeOfEvent`, `setTitleOfEvent`),
    for example, definitely make sense within the `Event` class itself, as they''re
    highly related to the purpose of the `Event` class: to contain details regarding
    a specific event. And the methods that export to both JSON and XML should also
    be moved, perhaps into their own class that is solely responsible for the export
    logic. The following code shows the changes that we''ve made:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于潜在变更的不同原因的数量，将变更分割为更合适的抽象是有意义的。例如，特定事件的时间和标题设置方法（`setTimeOfEvent`，`setTitleOfEvent`）绝对应该在“事件”类本身内部，因为它们与“事件”类的目的高度相关：包含有关特定事件的详细信息。导出到JSON和XML的方法也应该移动，可能移到一个专门负责导出逻辑的类中。以下代码显示了我们所做的更改：
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As you can hopefully see, each of our abstractions seems inwardly cohesive,
    and each one encapsulates its responsibilities far more cohesively than would
    be the case if all of that functionality resided solely within the `Calendar`
    class.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 希望你能看到，我们每个抽象都内部紧凑，并且每个抽象都比如果所有功能都仅驻留在“日历”类中要更紧凑地封装其责任。
- en: The SRP is not only about creating abstractions that are simple to use and maintain,
    it also allows us to write code that is more focused on its key purpose. Being
    more focused in this way gives us a clearer path to optimize and test our units
    of code, which benefits the reliability and efficiency of our codebase. The correct
    delineation of cohesive abstractions, guided by the SRP, is probably one of the
    most significant ways you can improve the cleanness of your code.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: SRP不仅仅是关于创建易于使用和维护的抽象，它还允许我们编写更专注于其主要目的的代码。以这种方式更加专注使我们更清晰地优化和测试我们的代码单元，这有利于我们代码库的可靠性和效率。由SRP指导的内聚抽象的正确划分可能是您改进代码清晰度的最重要方式之一。
- en: Open–closed principle
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开闭原则
- en: 'The **open–closed principle** (**OCP**) states the following:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**开闭原则**（OCP）陈述如下：'
- en: '*Software entities (classes, modules, functions, and so on) should be open
    for extension, but closed for modification'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*软件实体（类、模块、函数等）应该对扩展开放，但对修改关闭'
- en: -Meyer, Bertrand (1988)*
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: -梅耶，伯特兰（1988年）
- en: When crafting abstractions, we should enable them to be open to extension so
    that other developers can come along and build upon their behavior, adapting the
    abstraction to suit their needs. Extension, in this context, is best thought of
    as a broad term that encompasses all types of adaptation. If a module or function
    does not behave as we require it to, it would be ideal for us to be able to adapt
    it to our needs without having to modify it or create our own alternative.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建抽象时，我们应该使它们能够开放以便其他开发人员可以构建其行为，使抽象适应他们的需求。 在这种情况下，扩展最好被认为是一个广义术语，包括所有类型的适应。
    如果一个模块或函数的行为不符合我们的要求，最好能够使其适应我们的需求，而无需修改它或创建我们自己的替代品。
- en: 'Consider the following `Event` class and `renderNotification` method from our
    `Calendar` application:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑我们的日历应用程序中的`Event`类和`renderNotification`方法：
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We may wish to have a separate type of event that renders a notification prefixed
    with the word `Urgent!` to ensure that the user pays more attention to it. The
    simplest way to achieve this adaptation is via inheritance of the `Event` class,
    as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能希望有一种单独的事件类型，它会渲染一个以“紧急！”开头的通知，以确保用户更加关注它。 实现这种适应的最简单方法是通过继承`Event`类：
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We are prefixing our urgent message by overriding the `renderNotification` method
    and calling the super class's `renderNotification` to fill in the remainder of
    the notification string. Here, via inheritance, we have achieved extension, adapting
    the `Event` class to our needs.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过覆盖`renderNotification`方法来给我们紧急消息加上前缀，并调用超类的`renderNotification`来填充通知字符串的其余部分。
    在这里，通过继承，我们已经实现了扩展，使`Event`类适应我们的需求。
- en: 'Inheritance is only one way that extension can be achieved. There are various
    other approaches that we could take. One possibility is that, in the original
    implementation of `Event`, we foresee the need for custom notification strings
    and implement a way to configure a `renderCustomNotifcation` function:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 继承只是实现扩展的一种方式。 我们可以采取各种其他方法。 一种可能性是，在最初实现`Event`时，我们预见到需要自定义通知字符串，并实现了一种配置`renderCustomNotifcation`函数的方法：
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This code presumes that there is a `config` object available. We are optionally
    calling the `renderCustomNotification` and passing the default notification string.
    If it hasn't been configured, then the default notification string is used anyway.
    This is crucially different from the inheritance approach in that the `Event`
    class itself is prescribing the itself is prescribing the possibilities possibilities
    extension that exist.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码假设有一个`config`对象可用。 我们可以选择调用`renderCustomNotification`并传递默认通知字符串。 如果没有配置，则仍然使用默认通知字符串。
    这与继承方法有根本的不同，因为`Event`类本身规定了可能的扩展。
- en: 'Providing adaptability via configuration means that users don''t need to worry
    about the internal implementation knowledge required when extending classes. The
    path to adaptation is simplified:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 通过配置提供适应性意味着用户无需担心在扩展类时所需的内部实现知识。 适应的路径变得简化：
- en: '[PRE15]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This approach requires that your implementation can foresee its most likely
    adaptations and that those adaptations are predictably internalized into the abstraction
    itself. However, it is impossible to foresee all needs, and even if we tried to,
    we would likely end up creating such a complicated and large configuration that
    users and maintainers would suffer. So there is a balance to strike here: adaptability
    is a good thing, but we also must balance it with a focused and cohesive abstraction
    that has a constrained purpose.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法要求您的实现能够预见其最可能的适应性，并且这些适应性可预测地内部化到抽象本身。 但是，不可能预见所有需求，即使我们试图这样做，我们可能最终会创建一个如此复杂和庞大的配置，以至于用户和维护人员会受到影响。
    因此，在这里需要取得平衡：适应性是一件好事，但我们也必须平衡它与一个有限目的的专注和连贯的抽象。
- en: Liskov substitution principle
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 里斯科夫替换原则
- en: The **Liskov substitution principle** states that types should be able to be
    replaced by their subtypes without altering the reliability of the program. This
    is, on the surface, an obscure principle, so it's worth explaining it in terms
    of a real-world analogy.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '**里斯科夫替换原则**规定类型应能够被其子类型替换，而不会改变程序的可靠性。 这在表面上是一个晦涩的原则，因此值得用现实世界的类比来解释它。'
- en: Many real-world technological innovations share this characteristic of substitution.
    A Volvo XC90 is a type of car, as is a Ford Focus. Both provide the common interfaces
    that we have come to expect from cars. For us, as human users of these vehicles,
    we can assume that their respective means of operation inherit from a common schema
    of vehicle operation, such as having a steering wheel, doors, a brake pedal, and
    so on.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 许多现实世界的技术创新都具有替代的特点。 沃尔沃XC90是一种汽车，福特福克斯也是。 两者都提供了我们期望的汽车的常见接口。 对于我们作为这些车辆的人类用户，我们可以假设它们各自的操作方式都继承自一种常见的车辆操作模式，比如有方向盘，门，刹车踏板等。
- en: 'The human assumption is that these two models of car are subtypes of the supertype
    c*ar*, and so I as a human can rely on the aspects that they each inherit from
    their supertype (the car). Another way of phrasing the Liskov substitution principle
    is: *A consumer of a type should only be concerned with the least specific type
    necessary to operate it reliably*. To build on the analogy, if we were to program
    a `Driver` abstraction in code, we would want it to interface generally with all
    `Car` abstractions rather than writing specific code that relies on specific models
    of car (such as the Volvo XC90).'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 人类的假设是，这两种车型是超类型c*ar*的子类型，因此作为人类，我可以依赖于它们各自从超类型（汽车）继承的方面。 另一种表达里斯科夫替换原则的方式是：*类型的使用者只应关注操作它所需的最不具体的类型*。
    举个例子，如果我们要在代码中编写一个`Driver`抽象，我们希望它通常与所有`Car`抽象进行接口，而不是编写依赖于特定车型（如沃尔沃XC90）的特定代码。
- en: 'To make the Liskov substitution principle a little more concrete, let''s dive
    back into our `Calendar` application example. In the preceding section on the
    open-closed principle, we explored how to extend the `Event` class via inheritance
    with a new `ImportantEvent` class:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使里氏替换原则更具体一些，让我们回到我们的`Calendar`应用程序示例中。在前一节关于开闭原则的部分，我们探讨了如何通过继承将`Event`类扩展为新的`ImportantEvent`类：
- en: '[PRE16]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The assumption implicit in our doing this is that our `Calendar` class and
    its implementation will not be concerned with whether events are `Events` or subclasses
    of `Events`. We expect that it will treat them the same. The `Calendar` class
    may have a `notifyUpcomingEvents` method, for example, that iterates through all
    upcoming events and calls `renderNotification` on each event:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这样做的假设是，我们的`Calendar`类及其实现不会关心事件是`Events`还是`Events`的子类。我们期望它会对待它们一样。例如，`Calendar`类可能有一个`notifyUpcomingEvents`方法，它会遍历所有即将发生的事件，并在每个事件上调用`renderNotification`：
- en: '[PRE17]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: What's crucial here is that the `Calendar` implementation makes no deliberations
    as to the type of `Event` instance that it is dealing with. In fact, the preceding
    code (which doesn't account for the entire implementation) only prescribes that
    event objects have a `startsWithinMinutes` method and a `renderNotification` method.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 关键的是，`Calendar`的实现并不考虑它正在处理的`Event`实例的类型。事实上，前面的代码（并未涵盖整个实现）只规定了事件对象必须具有`startsWithinMinutes`方法和`renderNotification`方法。
- en: 'Related to the Liskov substitution principle is an idea that we''ve already
    discussed: the principle of least information (LoD), which drives us to ask: what
    is the least information that this abstraction requires in order to fulfill its
    purpose? In the case of `Calendar`, it only needs to prescribe that events have
    the methods and properties that it will use. There is no good reason for it to
    make deliberations beyond that. Not only can the `Calendar` implementation now
    deal with subclasses of events, but it can deal with any objects that supply the
    desired properties and methods.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 与里氏替换原则相关的是我们已经讨论过的一个概念：最少知识原则（LoD），它驱使我们问：这个抽象需要多少信息才能实现其目的？对于`Calendar`来说，它只需要规定事件具有它将使用的方法和属性。没有理由让它做出更多的考虑。`Calendar`的实现现在不仅可以处理事件的子类，还可以处理任何提供所需属性和方法的对象。
- en: Interface segregation principle
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口隔离原则
- en: The **interface segregation principle** is concerned with keeping interfaces
    highly cohesive, engaged in only one task or a set of tasks that are highly related.
    It states that *no client should be forced to depend on methods that it does not
    use*.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**接口隔离原则**关注的是保持接口高度内聚，只从事一个任务或一组高度相关的任务。它规定*不应该强迫客户端依赖它们不使用的方法*。'
- en: 'This principle is similar in spirit to the principle of single responsibility:
    its goal is to ensure that you create focused and highly-cohesive abstractions
    that are only concerned with a single area of responsibility. But instead of making
    you consider the concept of responsibility itself, it makes you look at the interfaces
    that you''re creating and consider whether they''re appropriately segregated.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这个原则在精神上类似于单一责任原则：它的目标是确保您创建专注且高度内聚的抽象，只关注一个责任领域。但它不是让您考虑责任本身的概念，而是让您看待您正在创建的接口，并考虑它们是否适当地隔离。
- en: 'Consider a local government office. They have a paper form (let''s call it
    Form 1A) that it uses to change a person''s details. It is a form that''s existed
    for over 50 years. Via this form, a local citizen can change a number of their
    details, including, but not limited to, the following:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个地方政府办公室。他们有一张纸质表格（让我们称之为1A表），用于更改个人信息。这是一张存在了50多年的表格。通过这张表格，当地公民可以更改他们的一些信息，包括但不限于以下内容：
- en: A change of name
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 姓名变更
- en: A change of marital status
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 婚姻状况变更
- en: A change of address
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 地址变更
- en: A change of council tax discount status (student/elderly)
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 地方税折扣状态变更（学生/老年人）
- en: A change of disability status
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 残疾状态变更
- en: 'As you can imagine, it''s a very complex and dense form, with many independent
    sections that a citizen must ensure they fill out correctly. We''ve all likely
    been exposed to the bureaucratic complexity of government paperwork, as shown
    in the following:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可以想象的那样，这是一张非常复杂和密集的表格，有许多独立的部分，公民必须确保填写正确。我们都可能接触过政府文书工作的官僚复杂性，如下所示：
- en: '![](assets/902a31b4-da7b-4b0f-a33e-d522f264f486.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/902a31b4-da7b-4b0f-a33e-d522f264f486.png)'
- en: 'Form 1A provides a set of interfaces to the various change functions that are
    provided by the local government office. The interface segregation principle asks
    us to consider whether this form is forcing its clients to depend on methods that
    they don''t use. In this context, the clients are the users of the form, the citizens,
    and the methods are all of the available functions that the form provides: the
    ability to register a name change, an address change, and so on.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 1A表提供了一组接口，用于地方政府办公室提供的各种更改功能。接口隔离原则要求我们考虑这张表格是否强迫其客户端依赖他们不使用的方法。在这个上下文中，客户端是表格的用户，也就是公民，而方法是表格提供的所有可用功能：注册姓名更改、地址更改等等。
- en: 'As is hopefully obvious by now, Form 1A does not follow the interface segregation
    principle very well. If we were to redesign it, we would likely separate out the
    individual functions it serves into their own independent forms. The way we''d
    do this is by employing something we learned at the beginning of the chapter:
    the principle of least information (LoD), which asks us a very simple question:
    What''s the least amount of information each abstraction (for example, changing
    one''s address) requires? We can then choose to only include in each form what
    is needed to fulfill its function:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/1d39fbfe-ed00-4fcf-bf89-f089d45f1c06.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
- en: 'To separate out and then only include the necessary fields in paper forms such
    as these may seem quite obvious, but it''s something programmers continually neglect
    to do effectively within their coded abstractions. The interface segregation principle
    reminds us of the importance of properly separating out our abstractions into
    interfaces that are distinct and internally cohesive. Doing so has the following
    benefits:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '**Increased reliability**: Having properly isolated interfaces that are truly
    decoupled makes code easier to test and verify, thereby aiding its general reliability
    and stability over time.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Increased maintainability**: Having segregated interfaces means that changes
    to one needn''t affect the others. As we saw in the layout of Form 1A, the positioning
    and space available are heavily dependent on each part of the form. Once we have
    decouple these dependencies, however, we are free to maintain and change each
    one as we see fit, without worrying about the others.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Increased usability**: Having interfaces that are separated according to
    their purpose and function means that users are able to understand and navigate
    the interfaces with far less time and cognitive effort. The users are the consumers
    of our interfaces, and so are the most dependent on the interfaces being clearly
    delineated.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependency inversion principle
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The dependency inversion principle states the following:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: High-level modules should not depend on low-level modules. Both should depend
    on abstractions (that is, interfaces)
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Abstractions should not depend on details. Details (such as concrete implementations)
    should depend on abstractions
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The first point may remind you of the LoD. It is largely talking about the
    same concept: the separation of high-level from low-level.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Our abstractions should be separated (decoupled) in such a way that we can easily
    change low-level implementation details at a later date without having to refactor
    all of our code. The dependency inversion principle, in its second point, suggests
    that we do this via intermediary abstractions through which the high-level modules
    can interface with the low-level details. These intermediary abstractions are
    sometimes known as adapters, as they adapt a low-level abstraction for consumption
    by a high-level abstraction.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Why is it called dependency inversion?A high-level module may initially depend
    on a low-level module. In languages that provide OOP concepts such as abstract
    classes and interfaces *(*a type of schematic for classes*)*, such as Java, it
    can be said that a low-level module may end up depending upon the interface, as
    it is the interface that provides the scaffolding on which the low-level module
    is implemented. The high-level module also depends on this interface, so that
    it may utilize the low-level module. We can see here how the dependencies are
    inverted so that both high- and low-level modules depend on the same interface.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: 'Considering our `Calendar` application once again, let''s say that we wanted
    to implement a way to retrieve events happening within a specific radius of a
    fixed location. We may choose to implement a method like so:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `getEventsAtLocation` method here is responsible for retrieving events that
    are within a certain radius (measured in kilometers) from a given location. As
    you can see, it uses both a `GeoCoder` class and a `DistanceCalculator` class
    to achieve its purpose.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: The `Calendar` class is a high-level abstraction, concerned with the broad concepts
    of a calendar and its events. The `getEventsAtLocation` method, however, contains
    a lot of location-related details that are more of a low-level concern. The `Calendar`
    class here is  concerns itself with which formula to utilize on the `DistanceCalculator` and
    the units of measurement used in the calculation. You can see how, for example,
    the `kilometerRadius` argument must be divided by `1000` to get the distance in
    meters, which is then compared to the distance returned from the `haversineFormulaDistance`
    method.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: 'All of these details should not be the business of a high-level abstraction,
    such as `Calendar`. The dependency inversion principle asks us to consider how
    we can abstract away these concerns to an intermediary abstraction that acts as
    a bridge between high-level and low-level. One way in which we may accomplish
    this is via a new class, `EventLocationCalculator`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This class could then be utilized by the `Event` class in its own `isEventWithinRadiusOf`
    method. An example of this is shown in the following code:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Therefore, all the `Calendar` class needs to concern itself with is the fact
    that `Event` instances have `isEventWithinRadiusOf` methods. It needs no information
    and makes no prescriptions as to the specific implementation that determines distances;
    the details of that are left to our lower-level `EventLocationCalculator` class:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The dependency inversion principle is similar to other principles that are
    related to the delineation of abstractions, such as the interface segregation
    principle, but is specifically concerned with dependencies and how these dependencies
    are directed. As we design and build abstractions, we are, implicitly, setting
    up a dependency graph. For example, if we were to map out the dependencies for
    the implementation that we arrived at, then it would look something like this:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a504d714-ae69-4ef8-a0d2-4c5ffdc9c8c3.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
- en: It's incredibly useful to draw dependency graphs such as these. They are a useful
    way to explore the true complexity of your code, and can often highlight areas
    of possible improvement. Most importantly, they let us observe where, if anywhere,
    our low-level implementations (details) impact our high-level abstractions. Only
    when we see such situations can we remedy them. So, as you advance through this
    book and beyond, always have in your mind's eye a graph of the dependencies; it'll
    help to steer you toward more decoupled, and thus more reliable, code.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: The dependency inversion principle is the very last of the SOLID acronym, and
    SOLID, as we've seen, is chiefly concerned with *how* we go about building abstractions.
    The next principle we'll cover binds together a lot of the content we've covered
    so far, as it is the principle of abstraction itself. If we remember nothing else
    from this chapter, then we should, at least, remember the **abstraction principle**.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: The abstraction principle
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the first chapter, we introduced the concept of a tower of abstractions,
    and the idea that every abstraction is a simplified lever to hidden complexity.
    The principle of abstraction within programming states the following:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: Implementation should be separate from interface.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: 'An implementation is the complex underside of an abstraction: the part that
    it''s hiding. The interface is the simplified topside. That is why we say that
    abstraction is a simplified lever to hidden complexity. The craft of creating
    abstractions that separate implementation from interface to just the right degree
    is not as simple as it may seem. As such, the programming world provides two warnings for
    us:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '**Don''t repeat yourself** (**DRY**): A warning that tells us to avoid writing
    code that duplicates other code we have written. If you find yourself having to
    repeat yourself, then this indicates that you''ve failed to abstract something,
    or have under-abstracted something.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不要重复自己**（**DRY**）：这是一个警告，告诉我们要避免编写重复我们已经编写的代码。如果你发现自己不得不重复自己，那么这表明你未能抽象出某些东西，或者抽象得不够。'
- en: '**You aren''t gonna need it** (**YAGNI**): Also known as **keep it simple,
    stupid!** (**KISS**), this warning tells us to be wary of over-abstracting code
    that does not need to be abstracted. It''s the polar opposite of DRY, and serves
    to remind us that we should not attempt abstraction unless it''s warranted (if
    we start to repeat ourselves, perhaps).'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**你不会需要它**（**YAGNI**）：也被称为**保持简单，愚蠢！**（**KISS**），这个警告告诉我们要警惕过度抽象不需要被抽象的代码。这与DRY截然相反，并提醒我们除非有必要（如果我们开始重复自己，也许），我们不应尝试抽象。'
- en: Between these two warnings, somewhere in the middle, lies the perfect abstraction.
    Designing abstractions so that they are maximally simple and maximally useful
    is a balancing act. On the one hand, we can say we have under-abstraction (DRY
    warns us about this) and, on the other hand, we have over-abstraction (YAGNI warns
    us about this).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个警告之间，中间某处，就是完美的抽象。设计抽象，使其尽可能简单和有用，是一种平衡。一方面，我们可以说我们有过度抽象（DRY警告我们要注意这一点），另一方面，我们有过度抽象（YAGNI警告我们要注意这一点）。
- en: Over-abstraction
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 过度抽象
- en: Over-abstraction is when too much complexity has been removed or replaced, so
    that the underlying complexity becomes difficult to leverage. The risk with over-abstraction
    is that we either remove too much complexity in favor of simplicity or we add
    new unnecessary complexity that confuses the user of our abstraction.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 过度抽象是指已经移除或替换了太多复杂性，以至于底层复杂性变得难以利用。过度抽象的风险在于，我们要么过度简化以求简单，要么添加新的不必要的复杂性，使抽象的用户感到困惑。
- en: For example, say that we are in need of a gallery abstraction that we want to
    use to display a gallery on both our website and various mobile applications.
    Depending on the platform, the gallery will use the interfaces available to produce
    the layout. On the web, it would produce HTML and DOM, but on a mobile application,
    it would use the various native UI SDKs available. The abstraction provides a
    lever to all that cross-platform complexity.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们需要一个画廊抽象，我们希望在网站和各种移动应用程序上都能使用它来显示画廊。根据平台的不同，画廊将使用可用的接口来生成布局。在网页上，它将生成HTML和DOM，但在移动应用程序上，它将使用各种可用的本机UI
    SDK。抽象为我们提供了所有这些跨平台复杂性的控制杆。
- en: 'Our initial requirements for the gallery are quite simple:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对画廊的最初要求非常简单：
- en: The ability to display one or more images
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够显示一个或多个图像
- en: The ability to display captions alongside images
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够在图像旁显示标题
- en: The ability to control the dimensions of individual images
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够控制单个图像的尺寸
- en: 'An external team has created a Gallery component for us to use. We open the
    documentation and see that it has the following example code, showing us how to
    create a gallery with two images:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 外部团队为我们创建了一个画廊组件。我们打开文档，看到它有以下示例代码，向我们展示如何创建一个包含两张图片的画廊：
- en: '[PRE22]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This interface seems very complex for the basic purpose of only displaying
    a couple of images. Considering our simple requirements, we can say that the preceding
    interface is evidence of over-abstraction: instead of simplifying the underlying
    complexity, it has introduced a whole new realm of complexity and various features
    that we don''t even need. It does technically fulfill our requirements, but we
    must navigate its realm of complexity to achieve what we want.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这个接口对于只显示几张图片的基本目的来说似乎非常复杂。考虑到我们简单的需求，我们可以说前面的接口是过度抽象的证据：它没有简化底层复杂性，而是引入了一整套我们甚至不需要的新的复杂性和各种功能。它在技术上满足了我们的要求，但我们必须在其复杂的领域中导航才能实现我们想要的东西。
- en: An abstraction like this, which encodes new complexities and prescribes its
    own features and naming conventions, is at risk of not only failing to reduce
    complexity, but also of increasing it! An abstraction has no business in increasing
    complexity; that is antithetical to the entire point of abstraction.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的抽象，编码了新的复杂性并规定了自己的特性和命名约定，有可能不仅无法减少复杂性，还可能增加复杂性！抽象不应增加复杂性；这与抽象的整个目的背道而驰。
- en: Keep in mind that the appropriate level of abstraction is context-dependent.
    What may be over-abstracted for your use case may be under-abstracted for another.
    The driver of an F1 racing car would require different levels of abstraction over
    their engine than a Ford Focus driver. Abstraction, like many clean-code concepts,
    is audience- and user-dependent.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，适当的抽象级别取决于上下文。对于您的用例来说可能是过度抽象的，对于另一个用例来说可能是不足抽象的。F1赛车手对引擎的抽象级别与福特福克斯车手不同。抽象，像许多清洁代码概念一样，取决于受众和用户。
- en: 'Over-abstraction can, curiously, also take the form of over-simplification,
    where levers to the underlying complexity are not made available to us. An oversimplified
    version of our `GalleryComponent` interface may look like the following:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 过度抽象还可以奇怪地采用过度简化的形式，其中对底层复杂性的控制杆并不向我们开放。我们的`GalleryComponent`接口的过度简化版本可能如下所示：
- en: '[PRE23]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This minimal interface may seem like the polar opposite of the previous code,
    and in some ways it is, but curiously, it is also an example of over-abstraction.
    Remember, abstraction is when we provide a lever to underlying complexity via
    an interface. In this case, the lever is just too simple, only providing very
    limited leverage for the complexity that we wish to harness. It does not allow
    us to add captions or control image dimensions; it only allows us to list a set
    of images, nothing more.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: 'Having gone through the two previous examples, you''ve seen how over-abstraction
    can come in two distinct flavors: one that over-complicates and one that over-simplifies.
    These are both undesirable.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: Under-abstraction
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If over-abstraction is when *too much* complexity has been removed or replaced,
    then under-abstraction is when *too little* complexity has been removed or replaced.
    This results in a situation where the user of the abstraction then needs to concern
    themselves with the underlying complexity. Imagine that you have a car that you
    must drive without a steering wheel or dashboard. You must control it directly
    via the engine by pulling levers and cranking oily cogs with your bare hands while
    keeping an eye on the road. We can say that this car has an under-abstracted method
    of control.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: 'We explored the over-abstracted versions of our gallery component, so let''s
    see what an under-abstracted version might look like:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This version of `GalleryComponent` seems to be forcing us to define web-specific
    HTML and Android-specific code. We were, ideally, depending on the abstraction
    to hide this complexity from us, giving us a simplified interface with which to
    harness—it hasn't done this.  The complexity of writing platform-specific code
    has not been sufficiently abstracted here, and so we can therefore say that this
    is an example of under-abstraction.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: 'From the previous code, you can also see that we are being made to repeat the
    source URL of our image and the caption text. This should remind us of one of
    the warnings we explored earlier: DRY, which indicates that we have not sufficiently
    abstracted something.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: If we keep an eye out for areas in which we are forced to repeat ourselves,
    then we can hope to build better abstractions. But be aware that under-abstraction
    is not always obvious.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: 'Various abstractions can be said to be *leaky abstractions* because they *leak* parts
    of their complexity upwards, through their interfaces. The previous code is an
    example of this: we can say that it is leaking the implementation details of its
    cross-platform complexities upward.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: Balanced abstraction
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Given what we''ve learned about under- and over-abstraction, we can say that
    a balanced abstraction is one that sits neatly in between these two undesirable
    opposites. The skill of creating a balanced abstraction is both an art and a science,
    and requires that we have a very good understanding of both the problem domain
    and the user''s capabilities and intents. By employing many of the principles
    and warnings in this chapter, we can hope to remain balanced in our code building.
    For the previous example of a `GalleryComponent`, we should, once again, explore
    the requirements of the abstraction:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: The ability to display one or more images
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to display captions alongside images
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to control the dimensions of individual images
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These, we can say, are the *levers* that we must provide to the underlying
    cross-platform complexity. Our abstraction should solely aim to expose these levers
    and no other unnecessary complexity. The following is an example of such an abstraction:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Via this interface, we can define one or more images, set their dimensions,
    and define captions for each image. It fulfills all of the requirements without
    inviting new complexities or leaking complexities from the underlying implementation.
    This is, therefore, a balanced abstraction.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: Functional programming principles
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JavaScript allows us to program in a variety of different ways. Many of the
    examples we've shared so far in this book have been more inclined towards OOP,
    which primarily uses objects to express problem domains. Functional programming is
    different in that it uses mostly pure functions and immutable data to express
    problem domains.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: 'All programming paradigms are broadly interested in the same thing: making
    it easier to express problem domains, to communicate our intent as programmers,
    and to accommodate the creation of useful and usable abstractions. The best principles
    we adopt from one paradigm may still apply to another, so adopt an open-minded
    approach!'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s easiest to observe and discuss the difference between OOP and functional
    programming by exploring an example. Let''s imagine that we wish to build a mechanism
    so that we can fetch paginated data from a server. To achieve this in an object-oriented
    way, we might create a `PaginatedDataFetcher` class:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The following is an example of how you would use the `PaginatedDataFetcher`
    class:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As you can see, with each call to `getNextPage`, we retrieve the next page of
    data. The `getNextPage` method relies on the remembered state of its objects,
    `endpoint` and `nextPage`, in order to know which URL to request next.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: A **state** can be thought of as the underlying remembered data of any program
    or piece of code that its results or effects are derived from. The state of a
    car may mean its current upkeep, its fuel and oil levels, and so on. Likewise,
    the state of a running program is the underlying data that it derives its functionality
    from.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Functional programming, as distinct from OOP, is purely interested in the usage
    of functions and immutable state to achieve its goals. The first mental blocker
    that people usually encounter when exploring functional programming is related
    to states, raising questions such as *Where should I store my state?* and *How
    do I make things change without being able to mutate that state?* We can explore
    this question by looking at the functionally programmed equivalent of the paginated
    data fetcher.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: 'We have created a function, `getPage`, to which we will pass an `endpoint`
    and a `pageNumber`, as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'When called, the `getPage` function will return an object containing the response
    from the server, as well as the `endpoint` and `pageNumber` used. In addition
    to these properties, the object will also contain a function named `next`, which
    itself, if called, will fire off another request via a subsequent call to `getPage`*.*
    It can be used in the following way:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: You'll notice that, when using this pattern, we only need a reference to the
    last retrieved page in order to make the next request. Page 3 is retrieved via
    page 2's returned `next()` function. Page 4 is retrieved via page 3's returned
    `next()` function.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `getPage` function does not mutate any data: it only uses the passed data
    to derive new data, and therefore, it can be said that it employs immutability.
    It can also be said that it is a pure function as well, in that, with a given
    set of input parameters (an `endpoint` and a `pageNumber`), it will always return
    the same thing. The `next` function returned by `getPage` is also pure, as it
    will always return the same thing: if I call `page2.next()` a million times, it''ll
    always fetch `page 3`.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: Functional purity and immutability are among the most vital functional concepts
    to understand, and, usefully, are principles that are applicable to all paradigms
    of programming. We're not looking to thoroughly explore functional programming
    here, but just to cover its most applicable principles in order to bolster our
    abstraction-crafting abilities.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Functional purity
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Functions can be said to be pure when their return value is only derived from
    their input values (also called **idempotence**), and when there are no side-effects.
    These characteristics give us the following benefits:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '**Predictability:** A function that does not have any side-effects on other
    areas of the program is a function that can be easily reasoned about. If a function
    mutates a state that it does not own, potentially creating cascades of changes
    in other areas of the code, it can be incredibly complicated to disentangle, creating
    maintenance and reliability issues.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Testability**: A pure function, thanks to the characteristic of always returning
    the same result when given the same inputs, is very easy to verify. Pure functions
    can become complex but, if kept pure, they will always be easily testable.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Idempotence is the characteristic of always deriving the same result when provided
    with a certain input. An idempotent function is therefore highly deterministic.
    An idempotent function may still have side-effects, so it may not always be a *pure*
    function, but from the perspective of an abstraction user, idempotence is highly
    desirable, as it means that we always know what to expect.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: 'Often in OOP, methods on objects cannot be said to be pure since they mutate
    the state (on the object) or return different results with the same input parameters.
    Consider, for example, the following `Adder` class:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `add` method here is not pure. It returns different results even when given
    the same arguments, and it has a side-effect: mutating a state that it does not
    own (that is the total property of the object). We could instead create a functionally
    pure addition abstraction very simply:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This may seem contrived, but the concept behind functional purity is to, from
    complex needs, derive the truly pure primitives and functions that are needed
    to construct it. Functional purity teaches us a general lesson here: to break
    down functionality to its most primal parts until you have a truly testable standalone
    unit. We can then compose these smaller units into larger units that do more complex
    work.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: Immutability
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter has largely been about how we structure and separate our abstractions,
    but it is equally important to consider the expectations of the data that passes *between* these
    abstractions.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: 'Immutability refers to the simple idea that data should not mutate. This means
    that, when we initialize an object, for example, we should not add new properties
    to it or change existing properties over time. Instead, we should derive a brand
    new object and only make changes to our own copy. Immutability is a characteristic
    of data, but is also a general tenet of functional programming. A language can
    also enforce immutability by disallowing the mutation of already declared variables
    or objects. JavaScript''s `const` is an example of this type of enforcement:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Knowing that something is immutable means that we can rest assured that it will
    not change; we can rely on its characteristics without worrying that some other
    part of the program may change it without us knowing. This is especially pertinent
    in the asynchronous world of JavaScript, where data is shuttled between scopes
    and interfaces in complex ways.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Like many of the principles we've covered in this chapter, immutability does
    not have to be followed religiously to gain benefits from it. Immutability in
    some areas, and mutability in others, can be a viable approach. Imagine an official
    document being shuttled around a government building. Each department has the
    implicit assumption that the document has not been arbitrarily modified by unexpected
    people; a specific department may choose to make a copy of the document and then
    make various mutations to its own copy for its own unique purposes. A codebase
    is not so different from this. By crafting abstractions and letting them interdepend
    on each other, we are intentionally enabling them to manipulate each other's data
    and functionality.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered a vast amount of theory and practical skills. We
    covered the LoD (or principle of least information), all SOLID principles, the
    principle of abstraction, and a couple of key principles from the paradigm of
    functional programming. Even if you don't remember all of the names, you will hopefully
    remember the underlying knowledge and key lessons that each principle encapsulates.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了大量的理论和实践技能。我们涵盖了LoD（或最少信息原则）、所有SOLID原则、抽象原则，以及函数式编程范式中的一些关键原则。即使你不记得所有的名字，希望你能记住每个原则所包含的基础知识和关键教训。
- en: Programming is as much an art as it is a science. It involves balancing all
    of these principles in the pursuit of crafting truly balanced abstractions. None
    of these principles should be considered hard-and-fast rules. They are merely
    guidelines that will help us on our journey.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 编程既是一门艺术，也是一门科学。它涉及在追求真正平衡的抽象时平衡所有这些原则。这些原则都不应被视为硬性规则。它们只是指导方针，将在我们的旅程中帮助我们。
- en: 'In the next chapter, we continue this journey by exploring one of the most
    challenging aspects of programming, both in JavaScript and outside it: the problem
    of naming things.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续探讨编程中最具挑战性的一个方面，无论是在JavaScript中还是在其他地方：命名事物的问题。
