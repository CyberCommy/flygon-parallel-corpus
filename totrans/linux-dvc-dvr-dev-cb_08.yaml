- en: 'Additional Information: Working with Char Drivers'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Exchanging data with a char driver
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Exchanging data with a peripheral means sending or receiving data to and from
    it, and, to do so, we have already seen that we have to use the `write()` and `read()` system
    calls, whose prototypes are defined in the kernel, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, their counterparts in user space look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The preceding prototypes (both in the kernel or user space) look similar but,
    of course, they have different meanings and, as driver developers we must know
    perfectly what these meanings are to do our job accurately.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with `write()`; when we call the `write()` system call from our
    user space program, we must supply a file descriptor, `fd`; a buffer, `buf`, filled
    with data to write; and the buffer size, `count`. Then, the system call returns
    a value that can be negative (if there are errors), positive (which refers to
    how many bytes have actually been written), or zero (which means that nothing
    has been written).
  prefs: []
  type: TYPE_NORMAL
- en: Note that `count` does **not** represent how many bytes we wish to write, but
    just the buffer size! In fact, `write()` can return a positive value that is smaller
    than `count`. That's why I enclosed the `write()` system call of the `chrdev_test.c` program inside
    a `for()` loop! In fact, if I have to write a buffer that is 10 bytes long and `write()` returns,
    for instance, 4 bytes, I have to recall it until all the remaining 6 bytes have
    been written.
  prefs: []
  type: TYPE_NORMAL
- en: From the kernel space perspective, we see the file descriptor, `fd`, as `struct
    file *filp` (where kernel information about our file descriptor is stored), while
    the data buffer is specified by the `buf` pointer and the `count` variable (for
    the moment, do not consider the `ppos` pointer; it will be explained soon).
  prefs: []
  type: TYPE_NORMAL
- en: 'As we can see from the `write()` kernel prototype, the `buf` parameter is marked
    with the `__user` attribute, which points out the fact that this buffer comes
    from the user space, so we cannot read directly from it. In fact, this memory
    area is virtual and, as such, it cannot actually be mapped into real physical
    memory when our driver''s `write()` method is executed! In order to address this
    situation, the kernel provides the `copy_from_user()` function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, this function takes data from the user space buffer, `from`,
    and then, after verifying that the memory area pointed by `from` is OK for reading,
    copies them to the buffer pointed by `to`. Once the data has been transferred
    to the kernel space (inside the buffer pointed by `to`), our driver can access
    it freely.
  prefs: []
  type: TYPE_NORMAL
- en: These same steps (even if in the opposite direction) are performed for the `read()` system
    call. We still have a file descriptor, `fd`; a buffer, `buf`, into which read
    data has to be placed, and its `count` size. Then, the system call returns a value
    that can be negative (if there are errors), positive (which means how many bytes
    have been actually read), or zero (which means we are at end-of-file).
  prefs: []
  type: TYPE_NORMAL
- en: Again, we should notice that `count` is **not** how many bytes we wish to read
    but just the buffer size. In fact, `read()` can return a positive value smaller
    than `count`, which is why I put it inside a `for()` loop in the `chrdev_test.c` program.
  prefs: []
  type: TYPE_NORMAL
- en: More significantly than in the preceding `write()` case, the `read()` system
    call can also return `0`, which means **end-of-file**; that is, no more data is
    available from this file descriptor and we should stop reading.
  prefs: []
  type: TYPE_NORMAL
- en: 'As for the preceding `write()` case, we still have the `__user` attribute associated
    with the buffer pointed by `buf`, which means that to read data from it, we must
    use the `copy_to_user()` function, which is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Both `copy_from_user()` and `copy_to_user()` are defined in the `linux/include/linux/uaccess.h` file.
  prefs: []
  type: TYPE_NORMAL
- en: Now, before the end of this section, we have to spend some time on the `ppos` pointer, which
    is present in both of the kernel prototypes.
  prefs: []
  type: TYPE_NORMAL
- en: When we wish to read some data stored in a file, we have to use the `read()` system
    call several times (especially if the file is quite big and our memory buffer
    is small). To do this, we'd like to simply call `read()` multiple times without
    bothering to keep track of where we arrived in each of the previous iterations;
    for example, if we have a file with a size of 16 KB and we wish to read it by
    using a 4 KB memory buffer, we simply call the `read()` system call four times,
    but how is each call supposed to know where the previous one finished its job?
    Well, this task is assigned to the `ppos` pointer: when the file is opened, it
    starts by pointing at the first byte of the file (at index 0) and then, each time `read()` is
    called, the system call itself moves it to the next position so that the following `read()` call
    knows exactly where it should start reading the next chunk of data.
  prefs: []
  type: TYPE_NORMAL
- en: Note that `ppos` is unique for both read and write operations, so if we perform `read()` first and
    then `write()`, the data will be written, not at beginning of the file, but exactly
    where the preceding `read()` call finished its operation!
  prefs: []
  type: TYPE_NORMAL
