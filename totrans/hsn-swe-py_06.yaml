- en: Development Tools and Best Practices
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发工具和最佳实践
- en: Before starting on the actual development of `hms_sys`, there are several decisions
    that need to be made. In a real-world scenario, some (maybe all) of these decisions
    might be made at a policy level, either by the development team or maybe by management
    above the team. Some, such as the IDE/code editor program, might be an individual
    decision by each individual team member; so long as there are no conflicts between
    different developers' choices, or any issues raised as a result, there's nothing
    wrong with that. On the other hand, having some consistency isn't a bad thing
    either; that way, every team member knows what to expect when they're working
    on code that someone else on the team has touched.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际开发`hms_sys`之前，需要做出几项决定。在现实世界的情况下，一些（也许全部）这些决定可能是由开发团队或者团队上面的管理层在政策层面上做出的。有些决定，比如IDE/代码编辑器程序，可能是每个团队成员个人的决定；只要不同开发人员的选择之间没有冲突，或者由此引起的任何问题，那就没有问题。另一方面，保持一些一致性也不是坏事；这样，每个团队成员在处理其他团队成员触及的代码时都知道可以期待什么。
- en: 'These choices fall into two main categories selection of development tools
    and what best practices (and standards) will be in play, specifically the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这些选择可以分为两大类：开发工具的选择和最佳实践（和标准）的运用，具体包括以下内容：
- en: Integrated Development Environment options
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成开发环境选项
- en: Source Control Management options
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源代码控制管理选项
- en: Code and development process standards, including organization of Python code
    into packages
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码和开发流程标准，包括将Python代码组织成包
- en: Setting up and using of Python virtual environments
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置和使用Python虚拟环境
- en: Development tools
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发工具
- en: The two most important tool-oriented decisions that need to be considered are,
    not surprisingly, centered around creating, editing, and managing the code through
    the development life cycle.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 需要考虑的两个最重要的工具导向决策，毫不奇怪地围绕着通过开发生命周期创建、编辑和管理代码。
- en: Integrated Development Environment (IDE) options
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成开发环境（IDE）选项
- en: It's certainly possible to write and edit code without using a full-blown **Integrated
    Development Environment** (**IDE**). Ultimately, anything that can read and write
    text files of arbitrary types or with arbitrary file extensions is technically
    usable. Many IDEs, though, provide additional, development-centric capabilities
    that can save time and effort—sometimes a lot of time and effort. The trade-off
    is, generally, that the more features and functionality that any given IDE provides,
    the less lightweight it is, and the more complicated it can become. Finding one
    that every member of a development team can agree on can be difficult, or even
    painful there are downsides to most of them, and there may not be a single, obvious
    right choice. It's very subjective.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在不使用完整的**集成开发环境**（**IDE**）的情况下编写和编辑代码是完全可能的。最终，任何能够读取和写入任意类型或带有任意文件扩展名的文本文件的东西在技术上都是可用的。然而，许多IDE提供额外的、面向开发的功能，可以节省时间和精力——有时甚至可以节省大量的时间和精力。一般来说，权衡是，任何给定的IDE提供的功能和功能越多，它就越不轻量级，也就越复杂。找到一个所有开发团队成员都能同意的IDE可能是困难的，甚至痛苦，大多数IDE都有缺点，可能没有一个单一、明显的正确选择。这是非常主观的。
- en: 'In looking at code editing and management tools, only real IDEs will be examined.
    As noted, text editors can be used to write code, and there are a fair few of
    them out there that recognize various language formats, including Python. However
    good they are (and there are some that are very good), if they don''t provide
    at least one of the following functional capabilities, they won''t be considered.
    It''s just a matter of time until something in this list is needed and not available,
    and at a minimum, that eventuality will be distracting, and at worst, it could
    be a critical issue (though that seems unlikely). The feature set criteria are
    as follows:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看代码编辑和管理工具时，只有真正的IDE将被考虑。正如前面所述，文本编辑器可以用来编写代码，市面上有很多识别各种语言格式的文本编辑器，包括Python。然而，无论它们有多好（有些确实非常好），如果它们没有提供以下至少一项功能能力，它们将不被考虑。这只是一个时间问题，直到列表中的某个功能是必需的，但却不可用，至少这种可能性会分散注意力，最坏的情况下，可能会成为一个关键问题（尽管这似乎不太可能）。功能集的标准如下：
- en: '**Large-project support**: A large project, for the purposes of discussion,
    involves the development of two or more distinct, installable Python packages
    that have different environmental requirements. An example might include a `business_objects`
    class library that''s used by two separate packages such as an `online_store`
    and `back_office` that provide different functionality for different users. The
    best-case scenario for this would include the following :'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**大型项目支持**：在讨论的目的上，大型项目涉及开发两个或更多个不同的可安装的Python包，这些包具有不同的环境要求。一个例子可能包括一个`business_objects`类库，它被两个独立的包如`online_store`和`back_office`所使用，为不同的用户提供不同的功能。这种情况的最佳情况将包括以下内容：'
- en: Support for different Python interpreters (possibly as individual virtual environments)
    in different package projects
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持不同的Python解释器（可能作为单独的虚拟环境）在不同的包项目中
- en: The ability to have and manage interproject references (in this example, the
    `online_store` and `back_office` packages would be able to have useful references
    to the `business_objects` library)
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有和管理项目间引用的能力（在这个例子中，`online_store` 和 `back_office` 包将能够对 `business_objects`
    库有有用的引用）
- en: Less important, but still highly useful, would be the ability to have multiple
    projects open and editable at the same time, so that as changes in one package
    project require corresponding changes in another, there's little or no context
    change needed by the developer making those changes
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不太重要，但仍然非常有用的是，能够同时打开和编辑多个项目，这样当一个包项目的更改需要在另一个包项目中进行相应的更改时，开发人员几乎不需要进行上下文的变化
- en: '**Refactoring support**: Given a long enough period of time, it''s inevitable
    that changes to a system''s code without changing how it behaves from an external
    perspective is going to be necessary. That''s a textbook definition of refactoring.
    Refactoring efforts tend to require, at a minimum, the ability to find and replace
    entity names in the code across multiple files, possibly across multiple libraries.
    At the more complex end of the range, refactoring can include the creation of
    new classes or members of classes to move functionality into a different location
    in the code, while maintaining the interface of the code.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重构支持**：在足够长的时间内，不改变系统行为的情况下对系统代码进行更改是不可避免的。这是重构的教科书定义。重构工作通常需要至少能够在多个文件中查找和替换实体名称，可能还涉及多个库。在更复杂的范围内，重构可能包括创建新的类或类的成员，将功能移动到代码的不同位置，同时保持代码的接口。'
- en: '**L****anguage exploration**: The ability to examine code that''s used by,
    but not a part of, a project is helpful, at least occasionally. This is more useful
    than it might sound, unless you are lucky enough to possess an eidetic memory,
    and thus never have to look up function signatures, module members and so on.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**语言探索**：检查项目使用但不是项目一部分的代码是有帮助的，至少偶尔是。这比听起来更有用，除非你很幸运拥有完美的记忆，因此从不必查找函数签名，模块成员等。'
- en: '**C****ode execution**: The ability to actually run the code being worked on
    is immensely helpful during development. Having to drop out of an editor into
    a terminal in order to run code, to test changes to it, is a context change, and
    those are tedious at the least, and can actually be disruptive to the process
    under the right circumstances.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码执行**：在开发过程中实际运行正在处理的代码是非常有帮助的。不得不从编辑器退出到终端以运行代码，测试对其进行更改，这是一种上下文的改变，至少是乏味的，而在适当的情况下，实际上可能会对过程产生破坏性影响。'
- en: 'These items will be rated on the following scale, from best to worst:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这些项目将按照以下标准进行评分，从好到坏：
- en: Superb
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 极好
- en: Great
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 很棒
- en: Good
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 好
- en: Fair
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公平
- en: Mediocre
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一般
- en: Poor
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 差
- en: Terrible
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 糟糕
- en: These are the author's opinion, obviously, so take these with an appropriately
    sized grain of salt. Your personal views on any or all of these, or your needs
    for any or all of them, may be substantially different.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是作者的观点，显然，所以要以适当的心态对待。你对这些任何或所有的个人观点，或者你对它们的需求，可能会有很大不同。
- en: 'Many IDEs have various bells and whistles functionality that helps, perhaps
    substantially, with the processes of writing or managing code, but isn''t something
    that''s really critical. Examples of these include the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 许多IDE具有各种花里胡哨的功能，可以在编写或管理代码的过程中帮助，但并非真正关键。这些功能的例子包括以下内容：
- en: The ability to navigate to where a code entity is defined from someplace where
    it's being used
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从某个地方导航到代码实体的定义位置
- en: Code completion and autosuggestion, which allows the developer to quickly and
    easily select from a list of entities based on the first few characters of an
    entity name that they've started typing
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码完成和自动建议，允许开发人员根据他们开始输入的实体名称的前几个字符，快速轻松地从列表中选择实体
- en: Code coloration and presentation, which provides an easy-to-understand visual
    indication of what a given block of code is – comments, class, function and variable
    names, that sort of thing
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码颜色和呈现，提供了一个易于理解的视觉指示，给出了代码块的内容 - 注释，类，函数和变量名称等
- en: These will also be rated on the same scale, but since they aren't critical functionality,
    they are presented merely as additional information items.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这些也将按照相同的标准进行评分，但由于它们不是关键功能，因此仅作为额外信息项呈现。
- en: All of the following IDEs are available across all the major operating systems
    – Windows, Macintosh, and Linux (and probably most UNIX systems, for that matter) – so
    that, an important criteria for evaluating the IDE part of a development toolkit
    is moot across the three discussed.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 所有以下IDE都适用于所有主要操作系统 - Windows，Macintosh和Linux（可能还包括大多数UNIX系统），因此，评估开发工具包的IDE部分的重要标准在这三个中都是无效的。
- en: IDLE
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IDLE
- en: IDLE is a simple IDE, written in Python and using the `Tkinter` GUI, which means
    that it should run on pretty much anything that Python can run on. It is often,
    but not always, part of a default Python installation but even when it's not included
    by default, it's easily installed and doesn't require much of anything in the
    way of external dependencies or other languages runtime environments.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: IDLE是一个简单的IDE，用Python编写，使用`Tkinter` GUI，这意味着它应该可以在Python可以运行的任何地方运行。它通常是默认Python安装的一部分，但即使默认情况下没有包含，也很容易安装，不需要外部依赖或其他语言运行环境。
- en: '**Large-project support**: Poor'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**大型项目支持**：差'
- en: '**Refactoring support**: Poor'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重构支持**：差'
- en: '**Language exploration**: Good'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**语言探索**：好'
- en: '**Code execution**: Good'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码执行**：好'
- en: '**Bells and whistles**: Fair'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**花里胡哨**：公平'
- en: Out of the box, IDLE doesn't provide any project management tools, though there
    may be plugins that provide some of this capability. Even so, unless there are
    also plugins available that allow for more than one file to be open at a time
    without requiring each to be in a separate window, working with code across multiple
    files will eventually be tedious, at best, and perhaps impractical to the point
    of being effectively impossible.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: IDLE默认情况下不提供任何项目管理工具，尽管可能有提供部分功能的插件。即使有插件可用，也可能需要每个文件都在单独的窗口中打开，这样在多个文件之间工作最终会变得乏味，甚至可能变得不切实际，甚至可能根本不可能。
- en: Although IDLE's search-and-replace functionality includes one nice feature –
    regular expression-based searches – that's about it as far as functionality that
    is meaningful or useful for refactoring purposes. Any significant refactoring
    effort, or even widespread but smaller scoped changes, will require a relatively
    high degree of manual effort.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管IDLE的搜索和替换功能包括一个不错的功能 - 基于正则表达式的搜索 - 但就重构目的而言，这就是有意义或有用的功能。任何重大的重构工作，甚至是广泛但范围较小的更改，都需要相对高程度的手动工作。
- en: Where IDLE really shines is in its ability to dig into the packages and modules
    available on the system. It provides both a class browser that allows direct exploration
    of any importable namespace in the Python path, and a path browser that allows
    exploration of all available namespaces. The only downsides to these are a lack
    of search capability and that each class browser has to reside in a separate window.
    Were these not concerns, a Great rating would not seem out of line.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: IDLE真正闪亮的地方在于它能够深入挖掘系统中可用的包和模块。它提供了一个类浏览器，允许直接探索Python路径中的任何可导入命名空间，以及一个路径浏览器，允许探索所有可用的命名空间。这些唯一的缺点是缺乏搜索功能，以及每个类浏览器都必须驻留在单独的窗口中。如果这些不是问题，那么给予一个很高的评价似乎也不过分。
- en: IDLE allows any open file to be executed with a single keystroke, with the results/output
    of that run displayed in a single, common Python shell window. There is no facility
    for passing arguments to those executions, but that's probably only a concern
    if a project involves some sort of command-line program that accepts arguments.
    IDLE also provides a syntax check that identifies the first syntax problem detected
    in the code, which could be of some use.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: IDLE允许通过按下一个键来执行任何打开的文件，执行的结果/输出显示在一个单独的Python shell窗口中。没有提供传递参数给这些执行的功能，但这可能只有在项目涉及接受参数的命令行程序时才是一个问题。IDLE还提供了一个语法检查，识别代码中检测到的第一个语法问题，这可能有些用处。
- en: The only reliably functional bells and whistles item that IDLE offers is coloration
    of code. There are extensions that are supposed to provide things such as auto-completion
    and some code authoring assistance (automatic generation of closing parenthesis,
    for example), but none of them appear to be functional.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: IDLE可靠的功能之一是代码的着色。有一些扩展可以提供诸如自动完成和一些代码编写辅助功能（例如自动生成闭合括号），但似乎没有一个是功能性的。
- en: 'The following is a screenshot of IDLE showing the console, a code editing window,
    class and path browser windows, and a search and replace window:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是IDLE的屏幕截图，显示了控制台，代码编辑窗口，类和路径浏览器窗口，以及搜索和替换窗口：
- en: '![](assets/cb6a9cc5-4e01-4b10-bd7c-fae5882d7abb.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/cb6a9cc5-4e01-4b10-bd7c-fae5882d7abb.png)'
- en: IDLE is probably a reasonable choice for small code efforts – anything that
    doesn't require having more files open than the user's comfortable with having
    displayed in their individual windows. It's lightweight, with a reasonably stable
    (if occasionally quirky) GUI. It's not something that feels like it would work
    well for projects that involve more than one distributable package, though.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: IDLE可能是小型代码项目的合理选择 - 任何不需要打开的文件比用户在其各自窗口中显示的更多的东西。它很轻量级，具有相当稳定（偶尔古怪）的GUI。但对于涉及多个可分发包的项目来说，它并不适合。
- en: Geany
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Geany
- en: '**G****eany** is a lightweight code editor and IDE with support for a number
    of languages, including Python. It''s available as an installable application
    across all the major operating systems, though it has some features that aren''t
    available on Windows. Geany is available as a free download from [www.geany.org](http://www.geany.org/):'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**Geany**是一个轻量级的代码编辑器和集成开发环境，支持多种语言，包括Python。它作为一个可安装的应用程序在所有主要操作系统上都可用，尽管在Windows上有一些功能是不可用的。Geany可以从[www.geany.org](http://www.geany.org/)免费下载：'
- en: '**Large-project support**: Fair'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**大型项目支持**：一般'
- en: '**Refactoring support**: Mediocre'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重构支持**：一般'
- en: '**Language exploration**: Mediocre'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**语言探索**：一般'
- en: '**Code execution**: Good'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码执行**：好'
- en: '**Bells and whistles**: Good'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**花里胡哨**：好'
- en: 'This is a screenshot of Geany showing one of several project plugins'' sidebars,
    an open code file, project settings, and search and replace windows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Geany的屏幕截图，显示了几个项目插件的侧边栏，一个打开的代码文件，项目设置以及搜索和替换窗口：
- en: '![](assets/04bcf30d-2150-4dfb-a864-6ac87529cc7b.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/04bcf30d-2150-4dfb-a864-6ac87529cc7b.png)'
- en: Geany's interface makes working with multiple concurrently open files a great
    deal easier than the same task would be in IDLE; each open file resides in a single
    tab in the UI, making multi-file editing quite a bit easier to deal with. It also
    supports a basic project structure even in its most basic installed configuration,
    and there are a few different project-oriented plugins that allow for easier/better
    management and visibility into the files of a project. What it lacks, generally,
    for large-project support is the ability to actually have multiple projects open
    at once, though multiple open files across different project source trees is supported.
    With some careful planning, and judicious configuration of individual projects'
    settings, it's possible to manage different execution requirements and even specific
    **Python virtual environments** across a set of related projects, though it requires
    some discipline to keep those well-isolated and efficient. As can be seen in the
    screen capture, Geany also provides settings for compilation and build/make commands
    at a project level, which can be very handy.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Geany的界面使得同时打开多个文件变得更加容易，而在IDLE中进行相同的任务将会更加困难；每个打开的文件都位于UI中的一个标签中，使得多文件编辑变得更加容易处理。即使在其最基本的安装配置中，它也支持基本的项目结构，并且有一些不同的面向项目的插件，可以更轻松/更好地管理和查看项目的文件。通常，对于大型项目的支持，它缺少实际上可以同时打开多个项目的能力，尽管支持跨不同项目源树打开多个文件。通过一些仔细的规划，并且审慎配置各个项目的设置，可以管理不同的执行要求，甚至是一组相关项目中特定的**Python虚拟环境**，尽管需要一些纪律来保持这些环境的隔离和高效。正如屏幕截图所示，Geany还提供了项目级别的编译和构建/制作命令设置，这可能非常方便。
- en: Geany's refactoring support is just slightly better than IDLE's, mostly because
    of its multi-file search and replace capabilities. There is no out-of-the box
    support for refactoring operations such as renaming a Python module file across
    an entire project or project set, leaving it as a wholly manual process, but with
    some care (and, again, discipline) even those aren't difficult to manage correctly,
    though they may be tedious and/or time consuming.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Geany的重构支持略优于IDLE，主要是因为它具有多文件搜索和替换功能。没有针对重构操作的开箱即用支持，例如在整个项目或项目集中重命名Python模块文件，因此这是一个完全手动的过程，但是通过一些小心（再次，纪律）甚至这些操作也不难正确管理，尽管可能会很乏味和/或耗时。
- en: Geany's language exploration capabilities don't look like they should warrant
    as high a rating as the *Mediocre* that was given. Short of actually opening every
    Python namespace that's tied to a given project, which would at least allow exploration
    of those packages in the Symbols panel, there really isn't much obviously available
    in the way of support for digging into the underlying language. Geany's redemption
    here is a very robust auto completion capability. Once the first four characters
    of an identifiable language element are entered – whether that element is part
    of an open file in the project or part of an imported module – all of the element
    names that match the currently entered text are shown and selectable, and if the
    selected item is a function or method, the code hint that comes up for the item
    includes that item's argument signature.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Geany的语言探索能力看起来似乎不应该获得如此高的评分，就像给出的*平庸*一样。除了实际打开与给定项目相关联的每个Python命名空间之外，这至少可以允许在符号面板中探索这些包之外，实际上并没有太多显而易见的支持来深入了解底层语言。Geany在这里的救赎是非常强大的自动完成功能。一旦输入了可识别语言元素的前四个字符
    - 无论该元素是项目中打开文件的一部分还是导入模块的一部分 - 所有与当前输入文本匹配的元素名称都会显示并可选择，如果所选项目是函数或方法，则为该项目提供的代码提示包括该项目的参数签名。
- en: Geany's code execution capabilities are pretty solid – slightly better than
    IDLE's in a few respects, if not enough so, or across enough areas, to warrant
    a higher rating. With some attention to needs and details early on in the project
    setup, it's possible to configure a given project's Execute settings to use a
    specific Python interpreter, such as one that's part of a specific virtual environment,
    and allow imports from other projects' virtual environment installations and code
    bases. The downside is that doing so does require a degree of planning, and it
    introduces additional complexity in managing the related virtual environments.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Geany的代码执行能力相当不错 - 在某些方面略优于IDLE，尽管在足够的程度或足够的领域内，这并不足以获得更高的评分。通过在项目设置的早期关注需求和细节，可以配置特定项目的执行设置以使用特定的Python解释器，例如作为特定虚拟环境的一部分，并允许从其他项目的虚拟环境安装和代码库中导入。不利的一面是这样做需要一定程度的规划，并且在管理相关虚拟环境时引入了额外的复杂性。
- en: Geany's out-of-the box bells and whistles are comparable to those provided by
    IDLE, with a single significant improvement;  a good number of readily-available
    plugins for a lot of common and useful tasks and needs.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Geany的开箱即用功能与IDLE提供的功能相当，但有一个重大改进；有许多常见和有用任务和需求的即用插件。
- en: Eclipse variations + PyDev
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Eclipse变体+ PyDev
- en: The Eclipse Platform, managed by the Eclipse Foundation ([www.eclipse.org](http://www.eclipse.org/)),
    is intended to provide a robust, customizable and fully featured IDE for any number
    of languages and development focuses. It's an open source project, and has spun
    off at least two distinct child variants (Aptana Studio, focused on web development), 
    and LiClipse , (focusing on Python development).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 由Eclipse基金会（[www.eclipse.org](http://www.eclipse.org/)）管理的Eclipse平台旨在为任何语言和开发重点提供强大，可定制和功能齐全的IDE。这是一个开源项目，并且至少产生了两个不同的子变体（专注于Web开发的Aptana
    Studio和专注于Python开发的LiClipse）。
- en: 'The LiClipse installation will be used as the basis of comparison here, since
    it requires no language-specific setup to begin writing Python code, but it''s
    perhaps worth noting that any Eclipse-derived installation that has access to
    the same plugins and extensions (PyDev for Python language support, and EGit for
    Git support) would provide the same functionality. All that said, Eclipse is not,
    perhaps, for everyone. It can be a very heavy IDE, especially if it''s providing
    support for more than a couple of languages, and can have a significant operational
    footprint memory and CPU usage – even if its supported languages and functionality
    set is fairly tightly controlled:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '**Large project support**: Great'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Refactoring support**: Good'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Language exploration**: Fair'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Code execution**: Good'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bells and whistles**: Good'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is a screenshot of LiClipse, showing a code outline view of the open code
    file, project properties, and a task list automatically generated from TODO comments
    in the open code files:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/296fff72-b10c-4674-af22-f78b46f8d40e.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
- en: 'Eclipse''s support for large Python projects is very good:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: Multiple projects can be defined and open for modification at the same time
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each project can have its own distinct Python interpreter, which can be a project-specific
    virtual environment, allowing distinct package requirements on a per-project basis,
    while still also allowing execution
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Projects can be set up to use other projects through the Project References
    settings as dependencies, and code execution will take those dependencies into
    account; that is, if code is run in a project that has a different project set
    up as a reference/dependency, the first project will still have access to the
    second's code and installed packages
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refactoring support across all the Eclipse-derived IDEs is also quite good,
    providing processes for the renaming of code elements including modules, the extraction
    of variables and methods, and facilities for the generation of properties and
    other code constructs. There may be other refactoring capabilities that are context
    dependent, and thus aren't obviously available at first glance.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: Once a Python environment has been associated with a project, the structure
    of that environment is completely available in the project's UI. By itself, that
    allows for drill-down exploration of what packages and functionality are available
    through the associated environment. Less obviously, control-clicking on a member
    of an installed package (for example, on `urllib.request` in the example code
    from [Chapter 5](https://cdp.packtpub.com/hands_on_software_engineering_with_python/wp-admin/post.php?post=29&action=edit), *The
    hms_sys System-Project,* or the `urlopen` function that module provides) will
    take the developer to the actual member (method or property) of the actual module
    that the project has in its installation.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: The Eclipse family of IDEs provides reasonably good execution capabilities for
    Python code, though it takes some getting used to. Any module or package file
    can be executed if or as needed, and any results, be they output or errors, will
    be displayed. The execution of a specific file also generates an internal run
    configuration that can be modified or removed as needed.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: 'The Eclipse/PyDev bells and whistles are, for the most part, comparable with
    those of Geany and IDLE  code and structure coloration is available and configurable,
    autosuggestion and autocompletion is available. The one potentially significant
    item that LiClipse in particular provides from the get-go is an integrated Git
    client. LiClipse''s Git integration, before any repositories have been cloned,
    is shown here:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c038b753-9ac2-4b49-9747-7c2eb1262aab.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
- en: Others
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These are not the only IDEs available for Python development, nor are they
    necessarily the best. Other popular options, based on various professional and
    semi-professional group polling, include:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '**PyCharm** (Community or Professional version): PyCharm shows up pretty consistently
    as a popular IDE for Python development. Its feature list includes most of the
    same bells and whistles that have been noted for Geany and Eclipse/PyDev tools,
    and it also features out-of-the box integration with Git, Subversion, and Mercurial
    version control systems, as well as UI and tools for working with various popular
    RDBMS, such as  MySQL and SQL Server in the Professional version. It''s probably
    a good first choice for the development of web applications in Python, provided
    that its project management functionality isn''t going to be overwhelmed by the
    code base. PyCharm can be downloaded at[ ](http://www.jetbrains.com/pycharm)[www.jetbrains.com/pycharm](http://www.jetbrains.com/pycharm)[.](http://www.jetbrains.com/pycharm)'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PyCharm**（社区版或专业版）：PyCharm一直是Python开发中受欢迎的IDE。其功能列表包括Geany和Eclipse/PyDev工具中已经注意到的大部分功能，还具有与Git、Subversion和Mercurial版本控制系统的开箱即用集成，以及专业版中用于与各种流行的RDBMS（如MySQL和SQL
    Server）一起使用的UI和工具。对于Python Web应用程序的开发来说，这可能是一个很好的首选，前提是其项目管理功能不会被代码库压倒。PyCharm可以在[www.jetbrains.com/pycharm](http://www.jetbrains.com/pycharm)下载。'
- en: '**Visual Studio Code**: VS Code is touted as being a lightning fast code editor,
    and has a lot of functionality available through a large collection of extensions
    for various languages and purposes. Although it''s one of the newer IDEs in the
    wild with Python support, it''s fast becoming a popular choice for scripting tasks,
    and has a lot of potential for larger, application-centric efforts as well. Visual
    Studio can be downloaded at[code.visualstudio.com](https://code.visualstudio.com/).'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Visual Studio Code**：VS Code被誉为是一个闪电般快速的代码编辑器，并且通过大量的扩展提供了许多功能，适用于各种语言和目的。虽然它是支持Python的较新的IDE之一，但它正在迅速成为脚本任务的热门选择，并且在更大的面向应用程序的努力方面具有很大的潜力。Visual
    Studio可以在[code.visualstudio.com](https://code.visualstudio.com/)下载。'
- en: '**Ninja IDE**: Judging by its feature list, Ninja has most of the same base
    features available through Geany, with the addition of a single, built-in project
    management subsystem that sounds useful and attractive. Ninja IDE can be downloaded
    at[ninja-ide.org](http://ninja-ide.org/)'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Ninja IDE**：根据其功能列表，Ninja具有Geany提供的大部分基本功能，还增加了一个单一的内置项目管理子系统，听起来很有用和吸引人。Ninja
    IDE可以在[ninja-ide.org](http://ninja-ide.org/)下载。'
- en: Source Code Management
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 源代码管理
- en: 'Whether described as a version or revision control system, **Source Code Management**
    (**SCM**), or some other name, the more common and more popular SCMs provide a
    host of features and capabilities to make certain aspects of the development process
    easier, faster, or at a minimum, more stable. These include the following:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 无论被描述为版本控制系统还是修订控制系统，**源代码管理**（**SCM**）或其他名称，更常见和更受欢迎的SCM提供了一系列功能和能力，使开发过程的某些方面更容易、更快或至少更稳定。这些包括以下内容：
- en: Allowing multiple developers to collaborate on the same parts of the same code
    base without having to worry (as much) about overwriting each other's work
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许多个开发人员在相同代码库的相同部分上合作，而无需过多担心彼此的工作被覆盖
- en: Keeping track of all versions of a code base, and who made what changes to it
    at each point that a new version was committed
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪代码库的所有版本，以及在每次提交新版本时谁做了什么更改
- en: Providing visibility into what changes were made as each new version was committed
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供对每个新版本提交时所做更改的可见性
- en: 'Maintaining different versions of the same code base for specific purposes,
    probably the most common variation of which is having versions for different environments
    that code changes are worked on and promoted through, which might include:'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为特定目的维护相同代码库的不同版本，其中最常见的变化可能是为不同环境创建版本，代码更改在其中进行并通过推广，这可能包括：
- en: Local development environments
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地开发环境
- en: A shared development environment, where all developers' local code changes first
    mix together
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 共享开发环境，所有开发人员的本地代码更改首先混合在一起
- en: A shared test server for QA and broader integration testing
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于QA和更广泛的集成测试的共享测试服务器
- en: A **User Acceptance Testing** server, using realistic, production-like data,
    which can be used to demonstrate functionality to whoever needs to give final
    approval for changes to be promoted to a live environment or build
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户验收测试**服务器，使用真实的、类似生产的数据，可以用来向需要最终批准变更推广到现场环境或构建的人演示功能'
- en: A staging environment that has full access to a complete copy of production
    data, with an eye towards being able to perform load and other tests that require
    access to that dataset
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有完整生产数据副本访问权限的暂存环境，以便能够执行需要访问该数据集的负载和其他测试
- en: The live environment/build code base
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现场环境/构建代码库
- en: 'While there are at least a few major variations in how such systems function
    under the hood, from a developer''s perspective, those functional differences
    may not really matter, so long as they function as expected and function well.
    Taken together, those basic capabilities, and the permutations of them with various
    manual efforts, allow the following:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些系统在内部功能上至少有几种主要变化，但从开发人员的角度来看，只要它们按预期运行并且运行良好，这些功能上的差异可能并不重要。这些基本功能以及它们与各种手动努力的变体一起，允许以下操作：
- en: 'Developers to roll back to an earlier version of a complete code base, make
    changes to it, and re-commit those as a new version, which can be useful for:'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发人员可以回滚到先前版本的完整代码库，对其进行更改，并将其重新提交为新版本，这对于以下情况可能很有用：
- en: Finding and removing or fixing changes that unexpectedly raised significant
    issues after being committed or even promoted
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找并删除或修复提交后甚至推广后意外引起重大问题的更改
- en: Creating new branches of the code to experiment with other approaches to committed
    functionality
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建代码的新分支，以尝试其他方法来实现已提交的功能
- en: Multiple developers with different areas of expertise to work on parts of the
    same problem and/or code, allowing them to get that problem solved, or that code
    written much faster
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多个具有不同专业领域专长的开发人员可以共同解决同一个问题和/或代码的部分，从而使他们能够更快地解决问题或编写代码。
- en: Developers with stronger architectural backgrounds or skill sets to define bare-bones
    code structures (classes and their members, perhaps), then commit them to be fully
    implemented by someone else
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有较强架构背景或技能集的开发人员可以定义基本的代码结构（例如类及其成员），然后将其提交给其他人完全实现。
- en: System domain experts to easily review changes to the code base, identifying
    risks to functionality or performance before those get promoted to an unforgiving
    environment
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统领域专家可以轻松审查代码库的更改，识别功能或性能风险，然后再将其推广到一个严苛的环境之前。
- en: Configuration managers to access and deploy different versions of the code base
    to their various target environments
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置管理器可以访问和部署代码库的不同版本到它们的各种目标环境
- en: There are probably a lot of other, more specific applications that a good SCM
    system, especially if it's got good ties to the development and code promotion
    processes, can help manage.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 可能还有许多其他更具体的应用程序，一个良好的SCM系统，特别是如果它与开发和代码推广流程有良好的联系，可以帮助管理。
- en: Typical SCM activities
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 典型的SCM活动
- en: 'Probably the most common use pattern for any SCM, no matter which one is in
    play, and regardless of the specific command variations, is the following sequence
    of operations:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 无论使用哪种SCM系统，也不管具体的命令变化，可能最常见的使用模式是以下操作序列：
- en: 'Fetching a version of a given code base:'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取给定代码库的版本：
- en: Usually, this will be the most recent version, perhaps from a specific branch
    for development, but any branch or version that needs to be retrieved could be
    fetched. In any event, the process will make a complete copy of the requested
    code base in some location on the local file-system, ready to be edited.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常，这将是最近的版本，可能来自特定的开发分支，但可以获取任何需要检索的分支或版本。无论如何，该过程将在本地文件系统的某个位置创建所请求的代码库的完整副本，准备进行编辑。
- en: Making changes to the local copy of the code.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对本地代码副本进行更改。
- en: 'Reconciling any differences prior to committing changes:'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在提交更改之前对任何差异进行对比：
- en: The goal with this step is to pull down any changes that have been made to the
    same code base, and find and resolve any conflicts between local changes and any
    that may have been made by others in the same code. Several current SCMs allow
    a local commit before committing to a shared repository. In these SCMs, this reconciliation
    is, perhaps, not as critical until code is being committed to the shared repository,
    but doing so with every local commit will often break the resolution of conflicts
    down into smaller, more manageable chunks.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这一步的目标是拉取对同一代码库所做的任何更改，并找到并解决本地更改与其他人可能在同一代码中所做的更改之间的任何冲突。一些当前的SCM允许在提交到共享存储库之前进行本地提交。在这些SCM中，这种对比可能在提交到共享存储库之前并不那么关键，但是在每次本地提交时这样做通常会将冲突的解决分解成更小、更易管理的部分。
- en: 'Committing to the shared repository:'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提交到共享存储库：
- en: Once this has been completed, the changes made are now available for other developers
    to retrieve (and reconcile conflicts against, if necessary).
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦完成了这一步，所做的更改现在可以供其他开发人员检索（如果需要，还可以与之对比冲突）。
- en: This use pattern will probably encompass most development efforts—anything that
    involves working on an established branch, and that doesn't require a new branch.
    Creation of new branches is also not unusual, especially if there are major changes
    expected to substantial portions of an existing code base. It's also not an unusual
    strategy to have nested branches for different environments, where the deeper
    branches are still pending some review or acceptance before being promoted up
    to the more stable branches.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这种使用模式可能涵盖了大多数开发工作，即任何涉及在已建立的分支上工作，并且不需要新分支的工作。创建新分支也并不少见，特别是如果预计对现有代码库的大部分进行重大更改。对于不同环境可能会有嵌套分支的策略也并不少见，其中更深层的分支在被推广到更稳定的分支之前仍在等待某些审查或接受。
- en: 'The branch structure is shown here:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 分支结构如下所示：
- en: '![](assets/a290b555-e718-42f7-971f-702003d4d233.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/a290b555-e718-42f7-971f-702003d4d233.png)'
- en: The process for promoting code, for example from the `[dev]` branch up to `[test]`,
    is reduced to an upwards merge, copying code from the lower branch to the higher,
    followed if necessary by branching from the higher branch back down to the lower
    again.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，从`[dev]`分支上升到`[test]`的代码推广过程被简化为向上合并，从较低的分支复制代码到较高的分支，然后如有必要，再从较高的分支分支回到较低的分支。
- en: 'It''s also not unusual to have separate branches created for specific projects—especially
    if there are two or more efforts underway that are likely to make widespread and/or
    significant changes, and most especially if those efforts are expected to conflict
    with each other. Project-specific branches will usually be taken from a shared
    development branch, as shown here:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 通常会为特定项目创建单独的分支，特别是如果有两个或更多正在进行的工作，可能会进行广泛和/或重大的更改，尤其是如果这些工作预计会相互冲突。项目特定的分支通常会从共享开发分支中获取，如下所示：
- en: '![](assets/07fcf23a-46e8-446d-b0b7-f4f25bad4f64.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/07fcf23a-46e8-446d-b0b7-f4f25bad4f64.png)'
- en: As code is completed for either `[project1]` or `[project2]` branches, it would
    be committed to its own branch, then merged up into the existing `[dev]` branch,
    checking for and resolving any conflicts in the process.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当`[project1]`或`[project2]`分支的代码完成时，它将被提交到自己的分支，然后合并到现有的`[dev]`分支中，在此过程中检查并解决任何冲突。
- en: 'There are dozens of SCMs available, about a dozen of which are open source
    systems and free of cost. The most popular systems are:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 有数十种SCM可用，其中约有十几种是开源系统，免费使用。最流行的系统有：
- en: Git (by a wide margin)
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Git（远远领先）
- en: Subversion
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Subversion
- en: Mercurial
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mercurial
- en: Git
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Git
- en: Git is, by a significant margin, the most popular SCM in use at present. It
    is a distributed SCM system that keeps local branches of code bases and other
    content very inexpensively, while still providing the ability to push locally
    committed code into a shared central repository that multiple users can then access
    and work from. Above all else, it's capable of handling a lot of concurrent commit
    (or patch) activity—not surprising since it was written to accommodate the Linux
    kernel development team's efforts, where there might be hundreds of such patches/commits
    at a time. It's fast and efficient, and the commands for basic functionality that
    covers most day-to-day needs are fairly easily committed to memory, if using the
    command line is the preferred approach.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Git是目前使用最广泛的SCM系统。它是一个分布式SCM系统，可以以非常低的成本保留代码库和其他内容的本地分支，同时仍然能够将本地提交的代码推送到共享的中央存储库，多个用户可以从中访问和工作。最重要的是，它能够处理大量并发的提交（或补丁）活动，这并不奇怪，因为它是为了适应Linux内核开发团队的工作而编写的，那里可能会有数百个这样的补丁/提交。它快速高效，基本功能的命令相对容易记忆，如果使用命令行是首选的话。
- en: 'Git has more functionality outside the normal commands and processes than in
    those processes themselves, that is, there are eight or nine commands that probably
    encompass the fetch/edit/reconcile/commit steps noted earlier, but Git has 21
    commands in total, with the other 12-13 providing functionality that is less commonly
    needed or used. Anecdotal evidence suggests that most developers, unless they
    are working on projects over a certain size or complexity, are probably closer
    to the end of the spectrum that these folks are at:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Git在正常命令和流程之外有更多的功能，也就是说，可能包括之前提到的获取/编辑/调和/提交步骤的八九个命令，但Git总共有21个命令，其他12-13个提供的功能通常不太需要或使用。有传闻称，除非他们在处理一定规模或复杂性的项目，否则大多数开发人员可能更接近这些人所在的那一端。
- en: '![](assets/aebd4069-95c3-407d-9394-5a6052b28ead.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/aebd4069-95c3-407d-9394-5a6052b28ead.png)'
- en: There's no shortage of GUI tools for Git either, though many IDEs, whether in
    an effort to minimize context switches, or for some other reason, provide some
    sort of interface to Git, even if it's through an optional plugin. The best of
    those will also detect when problems with some process (a commit or push, for
    example) crop up, and provide some instruction on how to resolve those problems.
    There are also free standing Git-GUI applications, and even integrations with
    built-in system tools such as TortoiseGit ([https://tortoisegit.org/](https://tortoisegit.org/))
    , which adds Git functionality to the Windows File Explorer.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Git也有不少GUI工具，尽管许多IDE，无论是为了最小化上下文切换，还是出于其他原因，都提供了一些与Git交互的界面，即使是通过可选插件。其中最好的工具还会在出现问题时（例如提交或推送）检测到，并提供一些解决问题的指导。还有独立的Git-GUI应用程序，甚至与内置系统工具集成，比如TortoiseGit（[https://tortoisegit.org/](https://tortoisegit.org/)），它将Git功能添加到Windows文件资源管理器中。
- en: Subversion
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Subversion
- en: Subversion (or SVN) is an older SCM that's been in play since early in 2004\.
    It's one of the most popular non-distributed SCMs still in use today. Like most
    SCMs before it, SVN stores a complete local copy of the code and content for each
    checked-out branch that it's tracking, and uploads those (perhaps in their entirety)
    during the commit process. It's also a centralized rather than a distributed system,
    which means that all branching and merging has to happen with respect to the master
    copy of the code base, wherever it might live.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Subversion（或SVN）是一种自2004年初以来就在使用的较老的SCM。它是今天仍在使用的最受欢迎的非分布式SCM之一。与它之前的大多数SCM一样，SVN存储了每个检出的分支的代码和内容的完整本地副本，并在提交过程中上传这些内容（可能是完整的）。它也是一个集中式而不是分布式系统，这意味着所有的分支和合并都必须相对于代码基础的主要副本进行，无论它可能存在于何处。
- en: The various under-the-hood differences and popularity of Git notwithstanding,
    SVN is a perfectly viable option for managing source code across a team, even
    if it's less efficient or less popular than Git. It fully supports the typical
    get-edit-commit work cycle, just not with the same degree of flexibility as Git
    provides.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Git的各种底层差异和流行程度，SVN仍然是管理团队源代码的一个完全可行的选择，即使它不如Git高效或受欢迎。它完全支持典型的获取-编辑-提交工作循环，只是没有Git提供的灵活性。
- en: Basic workflows for Git and SVN compared
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Git和SVN的基本工作流程比较
- en: Although the basic checkout, work, merge, and commit workflow is supported by
    all mainstream SCMs, it's worth looking at some of the additional process steps
    that Git requires. Each additional step is, obviously, an additional task that
    a developer will have to perform before code is fully committed, though none of
    them are necessarily long-running tasks, so the impact is rarely going to be substantial.
    On the other hand, each additional step involved provides an additional point
    where additional code modification can be made before it's attached to the master
    version of the code.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管所有主流SCM都支持基本的检出、工作、合并和提交工作流程，但值得看看Git需要的一些额外的流程步骤。显然，每个额外的步骤都是开发人员在代码完全提交之前必须执行的额外任务，尽管它们都不一定是长时间运行的任务，因此影响很少会是实质性的。另一方面，每个涉及的额外步骤都提供了一个额外的点，在这个点之前可以对代码进行额外的修改，然后再将其附加到代码的主要版本上。
- en: 'Compare the **Git Workflow** (left) and **SVN Workflow** (right):'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 比较**Git工作流**（左）和**SVN工作流**（右）：
- en: '![](assets/4c3c0c41-6776-47a9-9746-f6b285d72ba8.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/4c3c0c41-6776-47a9-9746-f6b285d72ba8.png)'
- en: The processes of getting the current version of the code and editing it are
    fundamentally the same.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取当前版本的代码并对其进行编辑的过程在根本上是相同的。
- en: Git allows the developer to **Stage Changes**. However, perhaps the modifications
    to the code in three out of five files are complete, and ready to be committed,
    at least locally, while there are significant efforts still needed on the other
    two. Since changes must be staged in Git prior to committing, the files that are
    done can be staged and then committed separately, leaving the others still in
    progress. Uncommitted staged files can still be edited and re-staged (or not)
    as needed as well; until a change-set is actually committed, everything is still
    in an in-progress state.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Git's **Commit Changes** is to a local repository, which again means that continued
    editing can happen, as well as manipulation of local commits, until everything
    is as it needs to be for the final master repository commit.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both provide the ability to perform a **Merge from Master** before the final
    **Push** or **Commit to Master** operations. Realistically, this can happen at
    any point prior to the final commit, but the granularity of Git's stage-then-commit
    approach lends itself well to doing so in smaller, more manageable chunks, which
    will often mean that any merges down from the master source code will also be
    smaller and easier to manage. There's no reason, on the SVN side, why similar
    periodic merges down can't be performed, it's just easier to remember to do so
    during a local commit routine during development.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other SCM options
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Git and SVN are not the only available options, by any means. The next most
    popular options are the following:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '**Mercurial**:A free, open source SCM, written in Python, that uses a distributed
    structure like Git, but doesn''t require the change staging operation that Git
    does. Mercurial has been adopted for internal use by Google and Facebook.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Perforce** **Helix Core**:A proprietary, distributed SCM that is at least
    somewhat compatible with Git commands, targeted for Enterprise clients and use.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Best practices
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are any number of standards and best practices that surround development,
    at least once the code base(s) involved gets above a certain level of complexity.
    They are considered as such because they solve (or prevent) various difficulties
    that will likely arise if they aren't followed. A fair number of them also focus,
    if indirectly, on some aspect of future-proofing code, at least from the perspective
    of trying to make it easier for a new developer (or the same developer, maybe
    years later) to understand what the code does, how to find specific chunks of
    code, or, perhaps, to extend or refactor it.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: 'Those guidelines fall, roughly, into two categories, no matter the programming
    language:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '**Standards for code:** Guidelines and concepts that focus on the structure
    and organization of code, though not necessarily on how that code functions – more
    on keeping it easily understood and navigable'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Process standards:** Guidelines and concepts that center around making sure
    that code is well behaved and that changes to it can be made with the minimum
    amount of hassle and disruption'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Python adds two more items into that mix that don''t quite fit into either
    of those language-agnostic categories; they are the results of capabilities and
    functional requirements in the context of Python specifically:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '**Package organization:** How best to structure code at a file-system level;
    where and when to generate new module files and package directories'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**When and how to use Python virtual environments:** What purposes they serve,
    and how best to leverage them for a given collection of code'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Standards for code
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Code level standards, at the end of the day, are as much about trying to ensure
    that the code itself is written and structured in a predictable and easily understood
    manner as anything else. When those standards are followed, and when they are
    reasonably well understood by the developers who are working with the code base,
    it''s not unreasonable to expect that any developer, even one who may never have
    seen a given chunk of code, will nevertheless be able to do the following:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Read and more easily understand the code and what it's doing
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Find a code element (a class, function, constant, or some other item) that may
    only be identified by name, or in terms of a namespace, quickly and easily
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create new code elements in an existing structure that also conform to those
    standards
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modify existing code elements and know what standards-related items need to
    be modified in concert with those changes (if any)
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Python community has one set of guidelines (PEP-8), but there may well be
    additional internal standards that are in place as well.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: PEP-8
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At least some of Python's DNA is bound to the observation that code is generally
    read more often that it is written. That is the basis for significant functional
    aspects of its syntax, particularly those that relate to the structure of Python
    code, such as the use of indentation to indicate blocks of functionality. It should,
    perhaps, then come as no great surprise that one of the earliest **Python Enhancement
    Proposals** (**PEPs**) is a focused look at how to maintain readability of code
    where variations in style have no functional significance. PEP-8 is a long specification,
    some 29 pages if printed directly from the current Python page ([www.python.org/dev/peps/pep-0008](http://www.python.org/dev/peps/pep-0008)),
    but the significant aspects are worth summarizing here.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: 'The first, and perhaps most significant, item therein is the recognition that
    while it''d be ideal if all Python code followed the same standards, there are
    a number of defensible reasons not to (see *A Foolish Consistency is the Hobgoblin
    of Little Minds* in PEP-8). Those include, but are not limited to, the following:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: When applying PEP-8 style guidelines would make the code less readable, even
    for someone who is used to reading code that follows the standards
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To be consistent with surrounding code that also does not adhere to them (maybe
    for historic reasons)
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because there is no reason other than the style guidelines to make changes to
    the code
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If adherence to the guidelines would break backwards compatibility (let alone
    functionality, though that seems unlikely)
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'PEP-8 notes specifically that it is a style guide, and as mentioned in the
    Style Guide Introduction of Solidity v0.3.0:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '"A style guide is about consistency. Consistency with this style guide is important.
    Consistency within a project is *more* important. Consistency within one module
    or function is the most important".'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: 'That implies that there may be good (or at least defensible) reasons to not
    adhere to some or all of the guidelines, even for new code. Examples might include
    the following:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Using naming conventions from another language because the functionality is
    equivalent, such as using JavaScript naming conventions in a Python class library
    that provides the same **Document Object Model** (**DOM**) manipulation functionality
    across a server-side class library for creating and working with DOM objects
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using very specific documentation string structures or formats to conform to
    a documentation management system's requirements that applies to all code (Python
    or otherwise) across the business
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conforming to other internal standards that contradict the ones advised by PEP-8
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ultimately though, since PEP-8 is a set of style guidelines, not functional
    ones, the worst that can happen is that someone will complain that the code doesn't
    stick to the publicly accepted standards. If your code is never going to be shared
    outside your organization, that may well never be a concern.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three loose groupings in PEP-8''s guidelines whose members can be
    summarized briefly:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '**Code layout**:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: 'Indentation should be four spaces per level:'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don't use tabs
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hanging indentation should use the same set of rules wherever possible, see
    the PEP-8 page for specifics and recommendations
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functional lines should not exceed 79 characters in length and long text strings
    should be limited to 72 characters per line, including indentation spaces
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a line has to break around an operator (+, -, *, and, or, and so on), break
    it before the operator
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Surround top-level functions and class definitions with two blank lines
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Comments**:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: Comments that contradict the code are worse than no comments—always make a priority
    of keeping the comments up-to-date when the code changes!
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comments should be complete sentences. The first word should be capitalized,
    unless it is an identifier that begins with a lowercase letter (never alter the
    case of identifiers!).
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Block comments generally consist of one or more paragraphs built out of complete
    sentences, with each sentence ending in a period.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Naming conventions**:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: Packages and modules should have short names, and use the `lowercase` or (if
    necessary) `lowercase_words` naming convention
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class names should use the `CapWords` naming convention
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions and methods should use the `lowercase_words` naming convention
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constants should use the `CAP_WORDS` naming convention
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Other items that are noted in PEP-8 but are too long to summarize usefully
    here include the following:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Source file encoding (which feels like it may soon stop being a concern)
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Imports
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whitespace in expressions and statements
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documentation strings (which have their own PEP:  [www.python.org/dev/peps/pep-0257](http://www.python.org/dev/peps/pep-0257))
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing for inheritance
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These, along with PEP-8's substantial *Programming Recommendations* section,
    will be followed in code during the development of the `hms_sys` project where
    they don't conflict with other standards.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Internal standards
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Any given development effort, team, or even company may have specific standards
    and expectations around how code is written or structured. There may also be functional
    standards as well, things such as policies that define what types of external
    systems will be used to provide various functionality that systems consume, which
    RDBMS engines are supported, what web servers will be used, and so on. For the
    purposes of this book, the functional standards will be determined during development,
    but some code structure and format standards will be defined here and now. As
    a starting point, the PEP-8 code layout, comments, and naming convention standards
    will apply. Over and above that, there are some code organization and class structure
    standards that will also be in play.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Code organization in modules
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The PEP-8 structure and sequence guidelines will be followed, with a module
    level doc string, imports from `__future__`, various dunder-names (an `__all__`
    list to support `from [module] import [member]` use of the module's members, and
    some standard `__author__`, `__copyright__` and `__status__` metadata about the
    module), then imports from standard libraries, then third-party libraries, and
    finally internal libraries.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, code will be organized and grouped by member types, in this order,
    with each element in alphabetical order (unless there are functional reasons why
    that order isn''t viable, such as classes depending on or inheriting from other
    classes that haven''t been defined yet if they are in strict order):'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: Module-level constants
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom exceptions defined in the module
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Abstract base classes that are intended to serve as formal interfaces
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Abstract base classes that are intended to serve as standard abstract classes,
    or as mixins
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Concrete classes
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The goal of all of these structure constraints is to provide some predictability
    across the entire code base, to make it easy to locate a given module member without
    having to search for it every single time. Modern IDEs, with the ability to control-click
    on a member name in code and jump straight to that member's definition, arguably
    make that unnecessary, but if code is going to be viewed or read by someone without
    access to such an IDE, organizing it this way still has some value.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: 'Accordingly, module and package header files follow a very specific structure,
    and that structure is set up in a set of template files, one for general purpose
    modules, and one for package header (`__init__.py`) modules. Structurally, they
    are identical, with only some slight variation between the two in the starting
    text/content. The `module.py` template then is the following:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The only real differences between a module''s template and one for a package
    header is the initial documentation and that there is a specific callout for including
    child package and module namespace members in the `__all__` list:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Having these available as template files for developer use also makes starting
    a new module or package a bit quicker and easier. Copying the file, or its contents,
    to a new file takes a few seconds longer than just creating a new, blank file,
    but having the structure ready to start coding in makes it a lot easier to maintain
    the relevant standards.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: Structure and standards for classes
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Class definitions, whether for concrete/instantiable classes or any of the
    ABC variants, have a similar structure defined, and will be arranged in sorted
    groups as follows:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: Class attributes and constants
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Property getter methods
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Property setter methods
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Property deleter methods
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instance property definitions
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Object initialization (`__init__`)
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Object deletion (`__del__`)
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instance methods (concrete or abstract)
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overrides of standard built-in methods (`__str__`)
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class methods
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Static methods
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The property getter, setter, and deleter methods approach was selected, rather
    than using method decoration, in order to make it easier to keep property documentation
    in a single location in the class definition. The use of properties (technically,
    they are managed attributes, but properties is a shorter name, and has the same
    meaning across several languages) as opposed to general attributes is a concession
    to unit testing requirements, and to a policy of raising errors as close to their
    cause as possible. Both will be discussed shortly, in the unit testing part of
    the *Process standards* section.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: 'The concrete class template then contains the following:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Apart from the `__init__` method, which will almost always be implemented, the
    actual functional elements, the properties and methods, are commented out. This
    allows the standards expected to be present in the template, and developers can,
    if they so choose, simply copy and paste whichever code stub(s) they need, uncomment
    the whole pasted block, rename what needs to be renamed, and start writing code.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: 'The template file for abstract classes is very similar to the concrete class
    template, with the addition of a few items to accommodate code elements that are
    not present in a concrete class:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'A similar template is also available for class definitions that are intended
    to serve as formal interfaces; classes that define functional requirements for
    an instance of a class, but that don''t provide any implementation of those requirements.
    It looks very much like the abstract class template, barring some name changes
    and the removal of anything that is or implies a concrete implementation:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Taken together, these five templates should provide solid starting points for
    writing code for any of the more commonly expected element types expected in most
    projects.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: Function and method annotation (hinting)
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you''ve worked with Python functions and methods before, you may have noticed
    and wondered about some unexpected syntax in some of the methods in the template
    files earlier, specifically the items in bold here:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: These are examples of type hints that are supported in Python 3\. One of the
    standards that `hms_sys` code will also adhere to is that all methods and functions
    should be type hinted. The resulting annotations may eventually be used to enforce
    type checking of arguments using a decorator, and even later on may be useful
    in streamlining unit testing. On a shorter-term basis, there is some expectation
    that an automatic documentation generation system will pay attention to those,
    so they're part of the internal standards now.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: 'Type hinting is probably new enough that it''s not in common use just yet,
    so a walk-through of what it does and how it works is probably worth examination.
    Consider the following unannotated function and its results when executed:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The results from executing that code look good:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/da5bef60-87f3-45c8-9f50-29ebc2ef05ca.png)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
- en: This is pretty straightforward, as Python functions go. The `my_function` function
    expects a `name` and `price`, and also allows for a `description` argument, but
    that is optional and defaults to `None`. The function itself just collects all
    those into a formatted string-value and returns it. The `price` argument should
    be a number value of some sort, and the others should be strings, if they exist.
    In this case, the expected types of those argument values are probably obvious
    based on the argument names.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: The price argument, though, could be any of several different numerical types,
    and still function—`int` and `float` values obviously work, since the code runs
    without error. So too would a `decimal.Decimal` value, or even a `complex` type,
    as nonsensical as that would be. The type hinting annotation syntax exists, then,
    to provide a way to indicate without requiring what type or types of values are
    expected or returned.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the same function, hinted:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The only differences here are the type hinting annotations after each argument
    and the return type hint at the end of the function''s first line, which indicate
    the expected types of each argument, and of the results of calling the function:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The output from the function call is identical, but the `__annotations__` attribute
    of the function is shown at the end of the output:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/5eace41e-d234-4549-85e7-277465066658.png)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
- en: All the type-hinting annotations really do is to populate the `__annotations__`
    property of `my_function`, as shown at the end of the preceding execution. Essentially,
    they are providing metadata about and attached to the function itself that can
    be used later.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: 'Taken together then, all of these standards are intended to do the following:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: Help keep code as readable as possible (baseline PEP-8 conventions)
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keep the structure and organization of code within files predictable (module
    and class element organization standards)
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make it easy to create new elements (modules, classes, and so on) that conform
    to those standards (the various templates)
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide some degree of future-proofing against efforts to allow automated documentation
    generation, type checking of methods and functions, and possibly some unit testing
    efficiencies to be explored later (type-hinting annotations)
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Process standards
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Process standards are concerned with what processes are executed against a
    code base towards any of several purposes. The two that are most common as separate
    entities are the following:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '**Unit testing:** Ensuring that code is tested and can be re-tested on demand,
    in an effort to ensure in turn that it works as expected'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Repeatable build processes:** Designed so that whatever build process you
    use and probably the installation process as a result, is automated, error free,
    and repeatable on demand while requiring as little developer time to execute as
    possible'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Taken together, these two also lead to the idea of **integrating unit tests
    and build processes**, so that, if needful or desired, a build process can ensure
    that its resulting output has been tested.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s not unusual for people, even developers, to think of unit testing as
    a process of making sure that bugs aren''t present in a code base. While there
    is a fair amount of truth to that, at least in smaller code bases, that''s actually
    more a result of the real purpose behind unit testing: unit testing is about ensuring
    that code behaves in a predictable fashion across all reasonably possible execution
    cases. The difference can be subtle, but it''s still a significant one.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take another look at the preceding `my_function`,  this time from a
    unit testing perspective. It''s got three arguments, one that is a required string
    value, one that is a required number value, and one that is an optional string
    value. It makes no decisions based on any of those values or their types, it just
    dumps them into a string and returns that string. Let''s assume that the arguments
    supplied are properties of a product (which is what the output implies, even if
    that''s not really the case). Even without any decision making involved, there
    are aspects to the functionality that will raise errors, or that probably should
    in that context:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: Passing a non-numeric `price `value will raise a `TypeError` because the string
    formatting won't format a non-numeric value with the `%0.2f` format specified
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing a negative `price` value probably should raise an error—unless it's
    actually possible for a product to have a negative price, it just doesn't make
    sense
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing a `price` value that is numeric, but isn't a real number (like a `complex`
    number) probably should raise an error
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing an empty `name` value probably should raise an error—it makes no sense
    to have what we presume to be a product name accept an empty value
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing a multi-line `name` value might be a case that should raise an error
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing a non-string `name` value probably ought to raise an error as well,
    for similar reasons, as would a non-string `description` value
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apart from the first item in the list, these are all potential flaws in the
    function itself, none of which will raise any errors at present, but all of which
    could very well lead to undesirable behavior.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: Bugs.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: The following basic test code is collected in the `test-my_function.py` module.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: 'Even without bringing a formal unit testing structure into play, it''s not
    difficult to write code that will test a representative set of all good argument
    values. First, those values have to be defined:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then, it''s a simple matter of iterating over all the good combinations and
    keeping track of any errors that surface as a result:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The results from executing that code look good:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c119726e-0acd-4486-ae24-6c187cf44232.png)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
- en: 'Next, a similar approach is taken for defining bad values for each argument,
    and checking each possible bad value with known good values:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Even with just the name argument tests in place, we already start seeing issues:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/0870e550-8c3c-4b42-bbea-31e3170ac59c.png)'
  id: totrans-288
  prefs: []
  type: TYPE_IMG
- en: 'And after adding in similar tests for price and description values:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The resulting list of issues is larger still, with a total of 15 items, any
    of which could lead to a production code bug if they aren''t addressed:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/3fad35b8-d5db-4a7a-ae38-1a9bb763e598.png)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
- en: 'It''s not enough, then, just to say that unit testing is a requirement in the
    development process; some thought has to be given to what those tests actually
    do, to what the relevant test policies look like, and what they are required to
    take into account. A good bare-bones starting point test policy would probably
    include, at a minimum the following:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: 'What values are used when testing arguments or properties of specific types:'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Numeric values should probably include even and odd variations, positive and
    negative values, and zero at a minimum
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: String values should include expected values, an empty string value, and strings 
    that are nothing more than whitespace (" ")
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some understanding of when each of those values is valid and when they are not,
    for each element being tested
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tests must be written for both passing and failing cases
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tests must be written such that they execute every branch in the element being
    tested
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That last item bears some explanation. Thus far, the code being tested made
    no decisions—it executes in exactly the same way, no matter what the values of
    the arguments are. A full unit test executed against code that does make decisions
    based on the values of arguments must be sure to pass test values for those arguments
    that invoke all of the decisions that the code can make. It is rare that this
    need will not be sufficiently accounted for by simply making sure that the good
    and bad test values are sufficiently varied, but it can become more difficult
    to ensure when complex class instances enter the picture, and those circumstances
    warrant closer, deeper attention.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: 'It was noted earlier, in the discussion around class templates, that formal
    properties (managed attributes) would be used, and that the reason behind that
    tied in to unit testing policies. We''ve seen that it''s relatively easy to generate
    tests that can check for specific error types during the execution of a function
    or method. Since properties are collections of methods, one each for get, set,
    and delete operation, packaged up by the `property` keyword, it follows that performing
    checks against a value passed to a setter method and raising errors if the value
    or type passed in is invalid (and thus probably going to raise errors elsewhere)
    is going to make unit testing implementation following the structure/pattern shown
    earlier at least somewhat faster and easier. A basic structure, using the `property_name`
    property from the `class-concrete.py` template, shows that it''s quite straightforward
    to implement such a property:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: There are 18 lines of code involved, which is at least 17 lines more than would
    be required if `property_name` was a simple, unmanaged attribute, and there are
    probably going to be at least two more lines of code in the `__init__` method
    of the class that uses this property if `property_name` is set during the creation
    of an instance. The trade-off, though, is that the managed attribute property
    is going to be self regulating, so there won't have to be much in the way of checking
    its type or value wherever else it might be used. The fact that it is accessible
    at all, that the instance it's a member of hasn't thrown an error before the property
    is being accessed, means that it's in a known (and valid) state.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: Repeatable build processes
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The idea of having a build process may have originated with languages that require
    compilation before their code can be executed, but there are advantages to establishing
    such a process even for languages such as Python that don't. In Python's case,
    specifically, such a process can collect code from multiple project code bases,
    define requirements without actually attaching them to the final package, and
    package code up in a consistent fashion, ready for installation. Since a build
    process is, itself, another program (or at least a script-like process), it also
    allows for the possibility of executing other code to whatever end is needed,
    which means that a build process can also execute automated tests, or even potentially
    deploy code to a designated destination, locally or remotely.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: 'Python''s default installation includes two packaging tools, `distutils` ,
    which is a collection of bare-bones functionality, and `setuptools`, which builds
    on top of that to provide a more powerful packaging solution. The output of a
    `setuptools` run, if packaging arguments are supplied, is a ready-to-install package
    (an egg). The conventional practice for the creation of a package is through a
    `setup.py` file that makes a call to the setup function that `setuptools` provides,
    which might look something like this:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The arguments shown all relate to specific aspects of the final package:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: '`name`: Defines the base name for the final package file (for example, `MyPackageName`)'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`version`: Defines the version of the package, a string that will also be part
    of the final package file''s name'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`author`: The name of the primary author of the package'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`description`: A short description of the package'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`long_description`: A long description of the package; this is often implemented
    by opening and reading a file containing the long description data, typically
    in Markdown format if the package is intended to be uploaded to the Python website''s 
    package repository'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`author_email`: The email address of the primary author of the package'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`url`: The home URL for the package'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`install_requires`: A list of package name and version requirements that need
    to be installed in order to use the code in the package – a collection of dependencies'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`package_dir`: A dictionary that maps package names to source directories;
    the `''package_name'':''project_root_directory''` value shown is typical for projects
    that have their source code organized under a `src` or `lib` directory, often
    at the same level in the filesystem as the `setup.py` file itself'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`packages`: A list of packages that will be added to the final output package;
    the `setuptools` module also provides a function, `find_packages`, that will search
    out and return that list, with provisions for explicit exclusion of package directories
    and files using a list of patterns to define what should be left out'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`package_data`: A collection of non-Python files that need to be included in
    the package directory that they are mapped to; that is, in the example shown,
    the `setup.py` run will look for a `package_name` package (from the packages list),
    and include the `file_name.ext` file in that package because it''s been listed
    for inclusion'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`entry_points`: Allows the installer to create command-line-executable aliases
    for specific functions in the code base; what it will actually do is create a
    small, standard Python script that knows how to find and load the specified function
    from the package, then execute it'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A far more detailed look at the creation, execution, and results from an actual
    `setup.py` will be undertaken with the first package created for `hms_sys`. There
    are also options for specifying, requiring, and executing automated unit tests
    that will be explored. If they provide the test execution and stop-on-failure
    functionality needed, then `setuptools.setup` will probably suffice for all the
    needs of `hms_sys`.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: If there are additional needs discovered that a standard Python setup process
    cannot manage for whatever reason, then a fallback build process will be needed,
    though it will almost certainly still use the results of a `setup.py` run as part
    of its process. In order to keep that fallback as (relatively) simple as possible,
    and to ensure that the solution is available across as many different platforms
    as possible, the fallback will use GNU Make.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: 'Make operates by executing command-line scripts for each target that is specified
    in a `Makefile`. A simple `Makefile`, with targets for testing and executing a
    `setup.py` file, is very simple:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Running a Make process from the command line is as simple as executing `make`,
    perhaps with a target specification:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c6164b64-9f8f-47cf-8a44-41abbb02a21f.png)'
  id: totrans-326
  prefs: []
  type: TYPE_IMG
- en: 'The first run (`make` without any target specified) executes the first target
    in the `Makefile`: `main`. The `main` target, in turn, has the `test` and `setup`
    targets specified as prerequisite targets to execute before moving ahead with
    its own processes. The same results would be returned if `make main` were executed.
    The second and third runs, `make test` and `make setup`, respectively, execute
    those specific targets.'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: Make, then, is a very flexible and powerful tool to have available. So long
    as a given build process step can be executed in the command line, it can be incorporated
    into a Make-based build. If different processes are needed for different environments
    (`dev`, `test`, `stage` , and `live`, for example), it's possible to set up Make
    targets that correspond to those environments, allowing one build process to handle
    those variations with nothing more complex than executing `make dev`, `…`, `make
    live`, though some care in target naming will be needed to avoid name collisions
    between two different but logically sound `test` targets in this case.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: Integrating unit tests and build processes
  id: totrans-329
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The build process, as hinted earlier, should allow the incorporation and execution
    of all available automated tests (unit tests at a minimum) that are created for
    a project. The goal of that integration is to prevent code that's failed its suite
    of tests from being buildable, and thus deployable, and thus to ensure that only
    demonstrably good code is available for installation, at least at a live or production
    code level.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: 'It may be necessary to allow broken code, code that fails its tests, to be
    buildable at a local or shared development build level, though, if only because
    developers may well want or need to install a broken build in order to troubleshoot
    issues. That will be very circumstantial, dependent on whatever policies and procedures
    are in place to handle circumstances like that. A possible policy set, based on
    five environments, might boil down to the following:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: '**Local development:** No testing required at all'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Shared development:** Test required, but failed tests do not kill the build
    process, so broken builds can be promoted to the common dev server(s); broken
    builds are logged, however, and those logs are easily available in case there''s
    a need to promote code in a hurry'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**QA/test:** As the shared development environment'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Staging** (and **User Acceptance Testing**) **environments:** Tests must
    execute and pass for code to be installed or promoted'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Live/production:** As staging'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the standard `setuptools`-based packaging process will allow tests to run,
    cause failed tests to abort the packaging effort, and won't require tests to execute
    during installation, then that provides adequate functional coverage of this sort
    of policy set, though use of a wrapper (such as Make) to provide environment-specific
    targets and build processes may be needed to deal with policy conformance/coverage.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: If unit testing and build process standards are in place and followed, the end
    result will tend to be code that is both easily built and deployed, no matter
    what state it might be in, and that behaves in a known (and provable) fashion
    under all known circumstances. That doesn't mean that it will be free of bugs,
    though; it's much less likely to have any significant bugs, so long as the test
    suite(s) are thorough and complete, but that's not a guarantee.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: There is some overhead involved in establishing the associated processes, and,
    particularly on the unit testing side, still more overhead in maintaining them,
    but the effects and impact on a system's stability can be amazing.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: The author once wrote an asset catalog system for an advertising firm that was
    in daily use by as many as 300 people every business day following these process
    guidelines. Over the course of four years, runtime, including an update to a new
    and significantly changed version of the system, the total number of errors reported
    that weren't user error, data entry errors, or enterprise-level access permissions
    was four. These process standards make a difference.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: Defining package structures for Python code
  id: totrans-341
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The package structure rules in Python are important, since they will determine
    what code is accessible when an attempt is made to import members from that package.
    Package structure is also a subset of the overall project structure that can have
    a significant impact on an automated build process, and it might also have an
    impact on unit testing setup and execution. Let''s start then by examining a possible
    top-level project structure first, as shown here, and then review what a Python
    package''s requirements are, and see how it fits into the project overall:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/f45a3c24-c8ce-41a4-8da5-36ea2ff5459d.png)'
  id: totrans-343
  prefs: []
  type: TYPE_IMG
- en: 'This project structure assumes that the final build will be installed on a
    POSIX system – most Linux installations, macOS, UNIX, and so  on. There may be
    different needs for, say, a Windows installation, and that will be explored during
    the `hms_sys` development cycle, when we start working out the remote desktop
    applications for it. Even so, the structure may still hold up:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: The `bin` directory is intended to collect code and programs that the end user
    can execute, whether from a command line, or through the GUI of the OS. Those
    items may or may not use the main package's code, though the odds are good that
    it will if they are Python executables.
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `etc` directory is where configuration files are stored, and the `example_project`
    directory beneath that would then be for a configuration that is very specific
    to the final installed instance of the project. It may be feasible, or even a
    better approach, to drop project-specific configurations in the top-level, and
    so on, directory—that decision will need to be evaluated on a project-by-project
    basis, and may depend on whether the end user installing the project has permissions
    to install to global directories.
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `scratch-space` directory is just a place to collect whatever random files
    might be useful during development – proof-of-concept code, note files, whatever.
    It's not intended to be part of a build and won't be deployable.
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `src` directory is where the project code lives. We'll dig deeper into that
    shortly.
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `var` directory is where POSIX systems store program data that needs to
    be persisted as files. The `cache` directory within it is a standard POSIX location
    for caching files, and the `example_project` directory within that would therefore
    be the location specifically for the project's code to cache files. It may be
    useful to have a dedicated, project-specific directory in `var` that's not in
    `cache`, and that's also provided.
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Packages in a project's context
  id: totrans-350
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Within the `src` directory is the package tree for the project. Each directory
    level at or under the `example_project` directory that has an `__init__.py` file
    is a formal Python package, and will be accessible through an import statement
    in Python code. Once this project is built and installed, then, and assuming that
    the code within it is written to accommodate the relevant import structure, all
    of the following would be legitimate imports from the project''s code:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: '| `import example_project` | Imports the entire `example_project` namespace
    |'
  id: totrans-352
  prefs: []
  type: TYPE_TB
- en: '| `import example_project.package` | Imports `example_project.package` and
    all its members |'
  id: totrans-353
  prefs: []
  type: TYPE_TB
- en: '| `from example_project import package` |'
  id: totrans-354
  prefs: []
  type: TYPE_TB
- en: '| `from example_project.package import member` | Assuming that `member` exists,
    imports it from `example_project.package` |'
  id: totrans-355
  prefs: []
  type: TYPE_TB
- en: '| `import example_project.package.subpackage` | Imports `example_project.package.subpackage`
    and all its members |'
  id: totrans-356
  prefs: []
  type: TYPE_TB
- en: '| `from example_project.package import subpackage` |'
  id: totrans-357
  prefs: []
  type: TYPE_TB
- en: '| `from example_project.package.subpackage import member` | Assuming that `member`
    exists, imports it from `example_project.package.subpackage` |'
  id: totrans-358
  prefs: []
  type: TYPE_TB
- en: 'A typical pattern for packages in Python is to group code elements around common
    realms of functionality. For example, a package that, at a very high level, is
    focused on DOM manipulation (HTML page structure), and supports XML, XHTML, and
    HTML5 might group things like so:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: '`dom (__init__.py)`'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`generic (__init__.py)`'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[General-purpose classes for working with elements]'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`html (__init__.py)`'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`generic (generic.py)`'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[General-purpose classes for working with HTML elements]'
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '``forms (forms.py)``'
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`html5 (__init__.py)`'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Classes for working with HTML-5-specific elements]'
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`forms (forms.py)`'
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`xhtml (__init__.py)`'
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Classes for working with XHTML-specific elements]'
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`forms (forms.py)`'
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`xml (__init__.py)`'
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A full implementation, then, of that structure might allow a developer to access
    an HTML5 Email field object by creating an instance of a class that lived at the
    `dom.html5.forms.EmailField` namespace, and whose code lived in `.../dom/html5/forms.py`
    as a class named `EmailField`.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: Deciding where specific classes, functions, constants, and so on should exist
    in the structure of a code base is a complex topic, and will be explored in greater
    depth as part of the early architecture and design of `hms_sys`.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: Using Python virtual environments
  id: totrans-376
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python allows a developer to create virtual environments that collect up all
    the baseline language facilities and functionality into a single location. Once
    set up, those virtual environments have packages installed in to or removed from
    them, which allows a project that's executing in the context of the environment
    to have access to packages and functionality that may not be needed in the base
    system. A virtual environment also provides a mechanism for keeping track of those
    installations, which in turn allows a developer to keep track of only those dependencies
    and requirements that are relevant to the project itself.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: Virtual environments can also be used, with some care and thought, to allow
    a project to be developed against a specific version of the Python language –
    one that's no longer supported, for example, or that's still too new to be available
    as a standard installation in the development machine's OS. This last aspect can
    be very useful in developing Python applications to run in various public clouds
    such as Amazon's AWS, where the Python version may be newer than what's generally
    available, and may also have significant syntax differences from earlier versions
    of the language.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: Breaking changes at the language level aren't very common, but they have happened
    in the past. Virtual environments won't solve those, but they will, at least,
    allow different versions of code to be maintained with more ease.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: 'Provided that the appropriate Python module (`venv` in Python 3) is already
    installed, creating a virtual environment, activating, and deactivating it at
    a command-line level is pretty straightforward:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/38b5c2fb-3d5a-421d-be9a-1e53fd809b99.png)'
  id: totrans-381
  prefs: []
  type: TYPE_IMG
- en: '[PRE16]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Creates a new, minimal virtual environment at the specified location (in this
    case, in a directory named `example_ve`, in a directory named `py_envs` in the
    user''s home directory):'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This activates the newly created virtual environment. At this point, launching
    `python` shows that it''s using version 3.5.2, and the command line interface
    prefaces each line with `(example_ve)` to show that the virtual environment is
    active:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This deactivates the active virtual environment. Launching `python` from the
    command-line now shows the default Python version, 2.7.12, for the system.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: 'Installing, updating, and removing packages, and showing what packages are
    installed, are equally straightforward:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/338a4a04-54ba-4f30-9a7e-84635fca9214.png)'
  id: totrans-389
  prefs: []
  type: TYPE_IMG
- en: 'This activates the virtual environment again:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This shows the list of currently installed packages. It does not show any of
    the packages that are part of the core Python distribution, only those that have
    been added.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The first run, in this case, also notes that the current version of `pip` in
    the environment is old and can be updated, which is done with this command:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `pip` package itself is part of the base Python installation, and even though
    it's just been updated, that has no effect on the list of packages returned by
    calling `pip freeze` again.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate how `pip` deals with installation of new packages, the `pillow`
    library, a Python API for working with graphics files, was installed with this:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Since `pillow` is not a standard library, it does appear in the results of
    another `pip freeze` call. The results of `pip freeze` can be dumped to a requirements
    file (`requirements.txt`, for the purposes of illustration) as part of a project
    structure, and stored with the project, so that package dependencies don''t actually
    have to live in the source tree of the project, or be stored with it in an SCM.
    That would allow a new developer on a project to simply create their own virtual
    environment, then install the dependencies with another `pip` call:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `pillow` library was then uninstalled to show what that looks like, with
    this:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `pip` program does a good job of keeping track of dependencies, but it may
    not be foolproof. Even if uninstalling a package removes something that it lists
    as a dependency, but that's still in use, it's easy enough to re-install it with
    another `pip` call.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: 'Virtual environments, then, allow for a lot of control over what third-party
    packages can be associated with a project. They come with a small price, though:
    they have to be maintained, if rarely, and as changes to those external packages
    are made by one developer, some discipline needs to be exerted to make sure that
    those changes are available for other developers working on the same code base.'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-405
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a fair few factors that can affect how code is written and managed,
    even before the first line of code is written. Each of them can have some impact
    on how smoothly a development effort progresses, or on how successful that effort
    is. Fortunately, there are a lot of options, and a fair amount of flexibility
    in making the decisions that determine which of them are in play, and how, even
    assuming that some team or managerial-level policies don't dictate them.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: 'Several of the decisions concerning these items for the `hms_sys` project have
    been noted, but since the next chapter starts on that development for real, they
    might be worth calling out once more:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: Code will be written using either Geany or LiClipse as the IDE. They both provide
    code project management facilities that should handle the multiple-project structure
    that's expected, and will provide enough of the bells and whistles needed to make
    navigating across projects relatively painless. Initially, the effort will use
    Geany, and LiClipse will be held in reserve if Geany becomes too troublesome to
    work with, or can't handle some aspect of the project after development has progressed.
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Source Code Management will be handled with Git, pointing at an external repository
    service such as GitHub or Bitbucket.
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code will follow PEP-8 recommendations until or unless there's a compelling
    reason not to, or they conflict with any of the internal standards noted.
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code will be written following the structure laid out in the various template
    files shown.
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Callables – functions and class methods – will use type-hinting annotations
    until or unless there is a compelling reason not to.
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All code will be unit tested, though test policy details have yet to be defined
    other than assuring that all public members are tested.
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each code project in the system will have its own build process, using standard
    `setup.py` mechanisms, with `Makefile`-based processes wrapped around them if
    needed.
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each build process will integrate unit test results in order to prevent a build
    from completing if any of the unit tests fail.
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Package structure within the projects has not yet been defined, but will unfold
    as development gets underway.
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each project will have and use its own distinct virtual environment, in order
    to keep the requirements and dependencies associated with each project separate.
    This may require some build process tweaking, but that remains to be seen.
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
