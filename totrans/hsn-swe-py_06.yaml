- en: Development Tools and Best Practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before starting on the actual development of `hms_sys`, there are several decisions
    that need to be made. In a real-world scenario, some (maybe all) of these decisions
    might be made at a policy level, either by the development team or maybe by management
    above the team. Some, such as the IDE/code editor program, might be an individual
    decision by each individual team member; so long as there are no conflicts between
    different developers' choices, or any issues raised as a result, there's nothing
    wrong with that. On the other hand, having some consistency isn't a bad thing
    either; that way, every team member knows what to expect when they're working
    on code that someone else on the team has touched.
  prefs: []
  type: TYPE_NORMAL
- en: 'These choices fall into two main categories selection of development tools
    and what best practices (and standards) will be in play, specifically the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Integrated Development Environment options
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Source Control Management options
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code and development process standards, including organization of Python code
    into packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up and using of Python virtual environments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Development tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The two most important tool-oriented decisions that need to be considered are,
    not surprisingly, centered around creating, editing, and managing the code through
    the development life cycle.
  prefs: []
  type: TYPE_NORMAL
- en: Integrated Development Environment (IDE) options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's certainly possible to write and edit code without using a full-blown **Integrated
    Development Environment** (**IDE**). Ultimately, anything that can read and write
    text files of arbitrary types or with arbitrary file extensions is technically
    usable. Many IDEs, though, provide additional, development-centric capabilities
    that can save time and effort—sometimes a lot of time and effort. The trade-off
    is, generally, that the more features and functionality that any given IDE provides,
    the less lightweight it is, and the more complicated it can become. Finding one
    that every member of a development team can agree on can be difficult, or even
    painful there are downsides to most of them, and there may not be a single, obvious
    right choice. It's very subjective.
  prefs: []
  type: TYPE_NORMAL
- en: 'In looking at code editing and management tools, only real IDEs will be examined.
    As noted, text editors can be used to write code, and there are a fair few of
    them out there that recognize various language formats, including Python. However
    good they are (and there are some that are very good), if they don''t provide
    at least one of the following functional capabilities, they won''t be considered.
    It''s just a matter of time until something in this list is needed and not available,
    and at a minimum, that eventuality will be distracting, and at worst, it could
    be a critical issue (though that seems unlikely). The feature set criteria are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Large-project support**: A large project, for the purposes of discussion,
    involves the development of two or more distinct, installable Python packages
    that have different environmental requirements. An example might include a `business_objects`
    class library that''s used by two separate packages such as an `online_store`
    and `back_office` that provide different functionality for different users. The
    best-case scenario for this would include the following :'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support for different Python interpreters (possibly as individual virtual environments)
    in different package projects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to have and manage interproject references (in this example, the
    `online_store` and `back_office` packages would be able to have useful references
    to the `business_objects` library)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Less important, but still highly useful, would be the ability to have multiple
    projects open and editable at the same time, so that as changes in one package
    project require corresponding changes in another, there's little or no context
    change needed by the developer making those changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Refactoring support**: Given a long enough period of time, it''s inevitable
    that changes to a system''s code without changing how it behaves from an external
    perspective is going to be necessary. That''s a textbook definition of refactoring.
    Refactoring efforts tend to require, at a minimum, the ability to find and replace
    entity names in the code across multiple files, possibly across multiple libraries.
    At the more complex end of the range, refactoring can include the creation of
    new classes or members of classes to move functionality into a different location
    in the code, while maintaining the interface of the code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**L****anguage exploration**: The ability to examine code that''s used by,
    but not a part of, a project is helpful, at least occasionally. This is more useful
    than it might sound, unless you are lucky enough to possess an eidetic memory,
    and thus never have to look up function signatures, module members and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**C****ode execution**: The ability to actually run the code being worked on
    is immensely helpful during development. Having to drop out of an editor into
    a terminal in order to run code, to test changes to it, is a context change, and
    those are tedious at the least, and can actually be disruptive to the process
    under the right circumstances.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These items will be rated on the following scale, from best to worst:'
  prefs: []
  type: TYPE_NORMAL
- en: Superb
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Great
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Good
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fair
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mediocre
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Poor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Terrible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are the author's opinion, obviously, so take these with an appropriately
    sized grain of salt. Your personal views on any or all of these, or your needs
    for any or all of them, may be substantially different.
  prefs: []
  type: TYPE_NORMAL
- en: 'Many IDEs have various bells and whistles functionality that helps, perhaps
    substantially, with the processes of writing or managing code, but isn''t something
    that''s really critical. Examples of these include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The ability to navigate to where a code entity is defined from someplace where
    it's being used
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code completion and autosuggestion, which allows the developer to quickly and
    easily select from a list of entities based on the first few characters of an
    entity name that they've started typing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code coloration and presentation, which provides an easy-to-understand visual
    indication of what a given block of code is – comments, class, function and variable
    names, that sort of thing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These will also be rated on the same scale, but since they aren't critical functionality,
    they are presented merely as additional information items.
  prefs: []
  type: TYPE_NORMAL
- en: All of the following IDEs are available across all the major operating systems
    – Windows, Macintosh, and Linux (and probably most UNIX systems, for that matter) – so
    that, an important criteria for evaluating the IDE part of a development toolkit
    is moot across the three discussed.
  prefs: []
  type: TYPE_NORMAL
- en: IDLE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: IDLE is a simple IDE, written in Python and using the `Tkinter` GUI, which means
    that it should run on pretty much anything that Python can run on. It is often,
    but not always, part of a default Python installation but even when it's not included
    by default, it's easily installed and doesn't require much of anything in the
    way of external dependencies or other languages runtime environments.
  prefs: []
  type: TYPE_NORMAL
- en: '**Large-project support**: Poor'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Refactoring support**: Poor'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Language exploration**: Good'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Code execution**: Good'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bells and whistles**: Fair'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Out of the box, IDLE doesn't provide any project management tools, though there
    may be plugins that provide some of this capability. Even so, unless there are
    also plugins available that allow for more than one file to be open at a time
    without requiring each to be in a separate window, working with code across multiple
    files will eventually be tedious, at best, and perhaps impractical to the point
    of being effectively impossible.
  prefs: []
  type: TYPE_NORMAL
- en: Although IDLE's search-and-replace functionality includes one nice feature –
    regular expression-based searches – that's about it as far as functionality that
    is meaningful or useful for refactoring purposes. Any significant refactoring
    effort, or even widespread but smaller scoped changes, will require a relatively
    high degree of manual effort.
  prefs: []
  type: TYPE_NORMAL
- en: Where IDLE really shines is in its ability to dig into the packages and modules
    available on the system. It provides both a class browser that allows direct exploration
    of any importable namespace in the Python path, and a path browser that allows
    exploration of all available namespaces. The only downsides to these are a lack
    of search capability and that each class browser has to reside in a separate window.
    Were these not concerns, a Great rating would not seem out of line.
  prefs: []
  type: TYPE_NORMAL
- en: IDLE allows any open file to be executed with a single keystroke, with the results/output
    of that run displayed in a single, common Python shell window. There is no facility
    for passing arguments to those executions, but that's probably only a concern
    if a project involves some sort of command-line program that accepts arguments.
    IDLE also provides a syntax check that identifies the first syntax problem detected
    in the code, which could be of some use.
  prefs: []
  type: TYPE_NORMAL
- en: The only reliably functional bells and whistles item that IDLE offers is coloration
    of code. There are extensions that are supposed to provide things such as auto-completion
    and some code authoring assistance (automatic generation of closing parenthesis,
    for example), but none of them appear to be functional.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a screenshot of IDLE showing the console, a code editing window,
    class and path browser windows, and a search and replace window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/cb6a9cc5-4e01-4b10-bd7c-fae5882d7abb.png)'
  prefs: []
  type: TYPE_IMG
- en: IDLE is probably a reasonable choice for small code efforts – anything that
    doesn't require having more files open than the user's comfortable with having
    displayed in their individual windows. It's lightweight, with a reasonably stable
    (if occasionally quirky) GUI. It's not something that feels like it would work
    well for projects that involve more than one distributable package, though.
  prefs: []
  type: TYPE_NORMAL
- en: Geany
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**G****eany** is a lightweight code editor and IDE with support for a number
    of languages, including Python. It''s available as an installable application
    across all the major operating systems, though it has some features that aren''t
    available on Windows. Geany is available as a free download from [www.geany.org](http://www.geany.org/):'
  prefs: []
  type: TYPE_NORMAL
- en: '**Large-project support**: Fair'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Refactoring support**: Mediocre'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Language exploration**: Mediocre'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Code execution**: Good'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bells and whistles**: Good'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is a screenshot of Geany showing one of several project plugins'' sidebars,
    an open code file, project settings, and search and replace windows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/04bcf30d-2150-4dfb-a864-6ac87529cc7b.png)'
  prefs: []
  type: TYPE_IMG
- en: Geany's interface makes working with multiple concurrently open files a great
    deal easier than the same task would be in IDLE; each open file resides in a single
    tab in the UI, making multi-file editing quite a bit easier to deal with. It also
    supports a basic project structure even in its most basic installed configuration,
    and there are a few different project-oriented plugins that allow for easier/better
    management and visibility into the files of a project. What it lacks, generally,
    for large-project support is the ability to actually have multiple projects open
    at once, though multiple open files across different project source trees is supported.
    With some careful planning, and judicious configuration of individual projects'
    settings, it's possible to manage different execution requirements and even specific
    **Python virtual environments** across a set of related projects, though it requires
    some discipline to keep those well-isolated and efficient. As can be seen in the
    screen capture, Geany also provides settings for compilation and build/make commands
    at a project level, which can be very handy.
  prefs: []
  type: TYPE_NORMAL
- en: Geany's refactoring support is just slightly better than IDLE's, mostly because
    of its multi-file search and replace capabilities. There is no out-of-the box
    support for refactoring operations such as renaming a Python module file across
    an entire project or project set, leaving it as a wholly manual process, but with
    some care (and, again, discipline) even those aren't difficult to manage correctly,
    though they may be tedious and/or time consuming.
  prefs: []
  type: TYPE_NORMAL
- en: Geany's language exploration capabilities don't look like they should warrant
    as high a rating as the *Mediocre* that was given. Short of actually opening every
    Python namespace that's tied to a given project, which would at least allow exploration
    of those packages in the Symbols panel, there really isn't much obviously available
    in the way of support for digging into the underlying language. Geany's redemption
    here is a very robust auto completion capability. Once the first four characters
    of an identifiable language element are entered – whether that element is part
    of an open file in the project or part of an imported module – all of the element
    names that match the currently entered text are shown and selectable, and if the
    selected item is a function or method, the code hint that comes up for the item
    includes that item's argument signature.
  prefs: []
  type: TYPE_NORMAL
- en: Geany's code execution capabilities are pretty solid – slightly better than
    IDLE's in a few respects, if not enough so, or across enough areas, to warrant
    a higher rating. With some attention to needs and details early on in the project
    setup, it's possible to configure a given project's Execute settings to use a
    specific Python interpreter, such as one that's part of a specific virtual environment,
    and allow imports from other projects' virtual environment installations and code
    bases. The downside is that doing so does require a degree of planning, and it
    introduces additional complexity in managing the related virtual environments.
  prefs: []
  type: TYPE_NORMAL
- en: Geany's out-of-the box bells and whistles are comparable to those provided by
    IDLE, with a single significant improvement;  a good number of readily-available
    plugins for a lot of common and useful tasks and needs.
  prefs: []
  type: TYPE_NORMAL
- en: Eclipse variations + PyDev
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Eclipse Platform, managed by the Eclipse Foundation ([www.eclipse.org](http://www.eclipse.org/)),
    is intended to provide a robust, customizable and fully featured IDE for any number
    of languages and development focuses. It's an open source project, and has spun
    off at least two distinct child variants (Aptana Studio, focused on web development), 
    and LiClipse , (focusing on Python development).
  prefs: []
  type: TYPE_NORMAL
- en: 'The LiClipse installation will be used as the basis of comparison here, since
    it requires no language-specific setup to begin writing Python code, but it''s
    perhaps worth noting that any Eclipse-derived installation that has access to
    the same plugins and extensions (PyDev for Python language support, and EGit for
    Git support) would provide the same functionality. All that said, Eclipse is not,
    perhaps, for everyone. It can be a very heavy IDE, especially if it''s providing
    support for more than a couple of languages, and can have a significant operational
    footprint memory and CPU usage – even if its supported languages and functionality
    set is fairly tightly controlled:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Large project support**: Great'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Refactoring support**: Good'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Language exploration**: Fair'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Code execution**: Good'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bells and whistles**: Good'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is a screenshot of LiClipse, showing a code outline view of the open code
    file, project properties, and a task list automatically generated from TODO comments
    in the open code files:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/296fff72-b10c-4674-af22-f78b46f8d40e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Eclipse''s support for large Python projects is very good:'
  prefs: []
  type: TYPE_NORMAL
- en: Multiple projects can be defined and open for modification at the same time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each project can have its own distinct Python interpreter, which can be a project-specific
    virtual environment, allowing distinct package requirements on a per-project basis,
    while still also allowing execution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Projects can be set up to use other projects through the Project References
    settings as dependencies, and code execution will take those dependencies into
    account; that is, if code is run in a project that has a different project set
    up as a reference/dependency, the first project will still have access to the
    second's code and installed packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refactoring support across all the Eclipse-derived IDEs is also quite good,
    providing processes for the renaming of code elements including modules, the extraction
    of variables and methods, and facilities for the generation of properties and
    other code constructs. There may be other refactoring capabilities that are context
    dependent, and thus aren't obviously available at first glance.
  prefs: []
  type: TYPE_NORMAL
- en: Once a Python environment has been associated with a project, the structure
    of that environment is completely available in the project's UI. By itself, that
    allows for drill-down exploration of what packages and functionality are available
    through the associated environment. Less obviously, control-clicking on a member
    of an installed package (for example, on `urllib.request` in the example code
    from [Chapter 5](https://cdp.packtpub.com/hands_on_software_engineering_with_python/wp-admin/post.php?post=29&action=edit), *The
    hms_sys System-Project,* or the `urlopen` function that module provides) will
    take the developer to the actual member (method or property) of the actual module
    that the project has in its installation.
  prefs: []
  type: TYPE_NORMAL
- en: The Eclipse family of IDEs provides reasonably good execution capabilities for
    Python code, though it takes some getting used to. Any module or package file
    can be executed if or as needed, and any results, be they output or errors, will
    be displayed. The execution of a specific file also generates an internal run
    configuration that can be modified or removed as needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Eclipse/PyDev bells and whistles are, for the most part, comparable with
    those of Geany and IDLE  code and structure coloration is available and configurable,
    autosuggestion and autocompletion is available. The one potentially significant
    item that LiClipse in particular provides from the get-go is an integrated Git
    client. LiClipse''s Git integration, before any repositories have been cloned,
    is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c038b753-9ac2-4b49-9747-7c2eb1262aab.png)'
  prefs: []
  type: TYPE_IMG
- en: Others
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These are not the only IDEs available for Python development, nor are they
    necessarily the best. Other popular options, based on various professional and
    semi-professional group polling, include:'
  prefs: []
  type: TYPE_NORMAL
- en: '**PyCharm** (Community or Professional version): PyCharm shows up pretty consistently
    as a popular IDE for Python development. Its feature list includes most of the
    same bells and whistles that have been noted for Geany and Eclipse/PyDev tools,
    and it also features out-of-the box integration with Git, Subversion, and Mercurial
    version control systems, as well as UI and tools for working with various popular
    RDBMS, such as  MySQL and SQL Server in the Professional version. It''s probably
    a good first choice for the development of web applications in Python, provided
    that its project management functionality isn''t going to be overwhelmed by the
    code base. PyCharm can be downloaded at[ ](http://www.jetbrains.com/pycharm)[www.jetbrains.com/pycharm](http://www.jetbrains.com/pycharm)[.](http://www.jetbrains.com/pycharm)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Visual Studio Code**: VS Code is touted as being a lightning fast code editor,
    and has a lot of functionality available through a large collection of extensions
    for various languages and purposes. Although it''s one of the newer IDEs in the
    wild with Python support, it''s fast becoming a popular choice for scripting tasks,
    and has a lot of potential for larger, application-centric efforts as well. Visual
    Studio can be downloaded at[code.visualstudio.com](https://code.visualstudio.com/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ninja IDE**: Judging by its feature list, Ninja has most of the same base
    features available through Geany, with the addition of a single, built-in project
    management subsystem that sounds useful and attractive. Ninja IDE can be downloaded
    at[ninja-ide.org](http://ninja-ide.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Source Code Management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Whether described as a version or revision control system, **Source Code Management**
    (**SCM**), or some other name, the more common and more popular SCMs provide a
    host of features and capabilities to make certain aspects of the development process
    easier, faster, or at a minimum, more stable. These include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Allowing multiple developers to collaborate on the same parts of the same code
    base without having to worry (as much) about overwriting each other's work
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keeping track of all versions of a code base, and who made what changes to it
    at each point that a new version was committed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing visibility into what changes were made as each new version was committed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Maintaining different versions of the same code base for specific purposes,
    probably the most common variation of which is having versions for different environments
    that code changes are worked on and promoted through, which might include:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Local development environments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A shared development environment, where all developers' local code changes first
    mix together
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A shared test server for QA and broader integration testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **User Acceptance Testing** server, using realistic, production-like data,
    which can be used to demonstrate functionality to whoever needs to give final
    approval for changes to be promoted to a live environment or build
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A staging environment that has full access to a complete copy of production
    data, with an eye towards being able to perform load and other tests that require
    access to that dataset
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The live environment/build code base
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'While there are at least a few major variations in how such systems function
    under the hood, from a developer''s perspective, those functional differences
    may not really matter, so long as they function as expected and function well.
    Taken together, those basic capabilities, and the permutations of them with various
    manual efforts, allow the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Developers to roll back to an earlier version of a complete code base, make
    changes to it, and re-commit those as a new version, which can be useful for:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding and removing or fixing changes that unexpectedly raised significant
    issues after being committed or even promoted
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating new branches of the code to experiment with other approaches to committed
    functionality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiple developers with different areas of expertise to work on parts of the
    same problem and/or code, allowing them to get that problem solved, or that code
    written much faster
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developers with stronger architectural backgrounds or skill sets to define bare-bones
    code structures (classes and their members, perhaps), then commit them to be fully
    implemented by someone else
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: System domain experts to easily review changes to the code base, identifying
    risks to functionality or performance before those get promoted to an unforgiving
    environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuration managers to access and deploy different versions of the code base
    to their various target environments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are probably a lot of other, more specific applications that a good SCM
    system, especially if it's got good ties to the development and code promotion
    processes, can help manage.
  prefs: []
  type: TYPE_NORMAL
- en: Typical SCM activities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Probably the most common use pattern for any SCM, no matter which one is in
    play, and regardless of the specific command variations, is the following sequence
    of operations:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Fetching a version of a given code base:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Usually, this will be the most recent version, perhaps from a specific branch
    for development, but any branch or version that needs to be retrieved could be
    fetched. In any event, the process will make a complete copy of the requested
    code base in some location on the local file-system, ready to be edited.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making changes to the local copy of the code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Reconciling any differences prior to committing changes:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The goal with this step is to pull down any changes that have been made to the
    same code base, and find and resolve any conflicts between local changes and any
    that may have been made by others in the same code. Several current SCMs allow
    a local commit before committing to a shared repository. In these SCMs, this reconciliation
    is, perhaps, not as critical until code is being committed to the shared repository,
    but doing so with every local commit will often break the resolution of conflicts
    down into smaller, more manageable chunks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Committing to the shared repository:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once this has been completed, the changes made are now available for other developers
    to retrieve (and reconcile conflicts against, if necessary).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This use pattern will probably encompass most development efforts—anything that
    involves working on an established branch, and that doesn't require a new branch.
    Creation of new branches is also not unusual, especially if there are major changes
    expected to substantial portions of an existing code base. It's also not an unusual
    strategy to have nested branches for different environments, where the deeper
    branches are still pending some review or acceptance before being promoted up
    to the more stable branches.
  prefs: []
  type: TYPE_NORMAL
- en: 'The branch structure is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a290b555-e718-42f7-971f-702003d4d233.png)'
  prefs: []
  type: TYPE_IMG
- en: The process for promoting code, for example from the `[dev]` branch up to `[test]`,
    is reduced to an upwards merge, copying code from the lower branch to the higher,
    followed if necessary by branching from the higher branch back down to the lower
    again.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s also not unusual to have separate branches created for specific projects—especially
    if there are two or more efforts underway that are likely to make widespread and/or
    significant changes, and most especially if those efforts are expected to conflict
    with each other. Project-specific branches will usually be taken from a shared
    development branch, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/07fcf23a-46e8-446d-b0b7-f4f25bad4f64.png)'
  prefs: []
  type: TYPE_IMG
- en: As code is completed for either `[project1]` or `[project2]` branches, it would
    be committed to its own branch, then merged up into the existing `[dev]` branch,
    checking for and resolving any conflicts in the process.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are dozens of SCMs available, about a dozen of which are open source
    systems and free of cost. The most popular systems are:'
  prefs: []
  type: TYPE_NORMAL
- en: Git (by a wide margin)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Subversion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mercurial
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Git
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Git is, by a significant margin, the most popular SCM in use at present. It
    is a distributed SCM system that keeps local branches of code bases and other
    content very inexpensively, while still providing the ability to push locally
    committed code into a shared central repository that multiple users can then access
    and work from. Above all else, it's capable of handling a lot of concurrent commit
    (or patch) activity—not surprising since it was written to accommodate the Linux
    kernel development team's efforts, where there might be hundreds of such patches/commits
    at a time. It's fast and efficient, and the commands for basic functionality that
    covers most day-to-day needs are fairly easily committed to memory, if using the
    command line is the preferred approach.
  prefs: []
  type: TYPE_NORMAL
- en: 'Git has more functionality outside the normal commands and processes than in
    those processes themselves, that is, there are eight or nine commands that probably
    encompass the fetch/edit/reconcile/commit steps noted earlier, but Git has 21
    commands in total, with the other 12-13 providing functionality that is less commonly
    needed or used. Anecdotal evidence suggests that most developers, unless they
    are working on projects over a certain size or complexity, are probably closer
    to the end of the spectrum that these folks are at:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/aebd4069-95c3-407d-9394-5a6052b28ead.png)'
  prefs: []
  type: TYPE_IMG
- en: There's no shortage of GUI tools for Git either, though many IDEs, whether in
    an effort to minimize context switches, or for some other reason, provide some
    sort of interface to Git, even if it's through an optional plugin. The best of
    those will also detect when problems with some process (a commit or push, for
    example) crop up, and provide some instruction on how to resolve those problems.
    There are also free standing Git-GUI applications, and even integrations with
    built-in system tools such as TortoiseGit ([https://tortoisegit.org/](https://tortoisegit.org/))
    , which adds Git functionality to the Windows File Explorer.
  prefs: []
  type: TYPE_NORMAL
- en: Subversion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Subversion (or SVN) is an older SCM that's been in play since early in 2004\.
    It's one of the most popular non-distributed SCMs still in use today. Like most
    SCMs before it, SVN stores a complete local copy of the code and content for each
    checked-out branch that it's tracking, and uploads those (perhaps in their entirety)
    during the commit process. It's also a centralized rather than a distributed system,
    which means that all branching and merging has to happen with respect to the master
    copy of the code base, wherever it might live.
  prefs: []
  type: TYPE_NORMAL
- en: The various under-the-hood differences and popularity of Git notwithstanding,
    SVN is a perfectly viable option for managing source code across a team, even
    if it's less efficient or less popular than Git. It fully supports the typical
    get-edit-commit work cycle, just not with the same degree of flexibility as Git
    provides.
  prefs: []
  type: TYPE_NORMAL
- en: Basic workflows for Git and SVN compared
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although the basic checkout, work, merge, and commit workflow is supported by
    all mainstream SCMs, it's worth looking at some of the additional process steps
    that Git requires. Each additional step is, obviously, an additional task that
    a developer will have to perform before code is fully committed, though none of
    them are necessarily long-running tasks, so the impact is rarely going to be substantial.
    On the other hand, each additional step involved provides an additional point
    where additional code modification can be made before it's attached to the master
    version of the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Compare the **Git Workflow** (left) and **SVN Workflow** (right):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/4c3c0c41-6776-47a9-9746-f6b285d72ba8.png)'
  prefs: []
  type: TYPE_IMG
- en: The processes of getting the current version of the code and editing it are
    fundamentally the same.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Git allows the developer to **Stage Changes**. However, perhaps the modifications
    to the code in three out of five files are complete, and ready to be committed,
    at least locally, while there are significant efforts still needed on the other
    two. Since changes must be staged in Git prior to committing, the files that are
    done can be staged and then committed separately, leaving the others still in
    progress. Uncommitted staged files can still be edited and re-staged (or not)
    as needed as well; until a change-set is actually committed, everything is still
    in an in-progress state.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Git's **Commit Changes** is to a local repository, which again means that continued
    editing can happen, as well as manipulation of local commits, until everything
    is as it needs to be for the final master repository commit.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both provide the ability to perform a **Merge from Master** before the final
    **Push** or **Commit to Master** operations. Realistically, this can happen at
    any point prior to the final commit, but the granularity of Git's stage-then-commit
    approach lends itself well to doing so in smaller, more manageable chunks, which
    will often mean that any merges down from the master source code will also be
    smaller and easier to manage. There's no reason, on the SVN side, why similar
    periodic merges down can't be performed, it's just easier to remember to do so
    during a local commit routine during development.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other SCM options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Git and SVN are not the only available options, by any means. The next most
    popular options are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Mercurial**:A free, open source SCM, written in Python, that uses a distributed
    structure like Git, but doesn''t require the change staging operation that Git
    does. Mercurial has been adopted for internal use by Google and Facebook.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Perforce** **Helix Core**:A proprietary, distributed SCM that is at least
    somewhat compatible with Git commands, targeted for Enterprise clients and use.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Best practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are any number of standards and best practices that surround development,
    at least once the code base(s) involved gets above a certain level of complexity.
    They are considered as such because they solve (or prevent) various difficulties
    that will likely arise if they aren't followed. A fair number of them also focus,
    if indirectly, on some aspect of future-proofing code, at least from the perspective
    of trying to make it easier for a new developer (or the same developer, maybe
    years later) to understand what the code does, how to find specific chunks of
    code, or, perhaps, to extend or refactor it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Those guidelines fall, roughly, into two categories, no matter the programming
    language:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Standards for code:** Guidelines and concepts that focus on the structure
    and organization of code, though not necessarily on how that code functions – more
    on keeping it easily understood and navigable'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Process standards:** Guidelines and concepts that center around making sure
    that code is well behaved and that changes to it can be made with the minimum
    amount of hassle and disruption'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Python adds two more items into that mix that don''t quite fit into either
    of those language-agnostic categories; they are the results of capabilities and
    functional requirements in the context of Python specifically:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Package organization:** How best to structure code at a file-system level;
    where and when to generate new module files and package directories'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**When and how to use Python virtual environments:** What purposes they serve,
    and how best to leverage them for a given collection of code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Standards for code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Code level standards, at the end of the day, are as much about trying to ensure
    that the code itself is written and structured in a predictable and easily understood
    manner as anything else. When those standards are followed, and when they are
    reasonably well understood by the developers who are working with the code base,
    it''s not unreasonable to expect that any developer, even one who may never have
    seen a given chunk of code, will nevertheless be able to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Read and more easily understand the code and what it's doing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Find a code element (a class, function, constant, or some other item) that may
    only be identified by name, or in terms of a namespace, quickly and easily
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create new code elements in an existing structure that also conform to those
    standards
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modify existing code elements and know what standards-related items need to
    be modified in concert with those changes (if any)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Python community has one set of guidelines (PEP-8), but there may well be
    additional internal standards that are in place as well.
  prefs: []
  type: TYPE_NORMAL
- en: PEP-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At least some of Python's DNA is bound to the observation that code is generally
    read more often that it is written. That is the basis for significant functional
    aspects of its syntax, particularly those that relate to the structure of Python
    code, such as the use of indentation to indicate blocks of functionality. It should,
    perhaps, then come as no great surprise that one of the earliest **Python Enhancement
    Proposals** (**PEPs**) is a focused look at how to maintain readability of code
    where variations in style have no functional significance. PEP-8 is a long specification,
    some 29 pages if printed directly from the current Python page ([www.python.org/dev/peps/pep-0008](http://www.python.org/dev/peps/pep-0008)),
    but the significant aspects are worth summarizing here.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first, and perhaps most significant, item therein is the recognition that
    while it''d be ideal if all Python code followed the same standards, there are
    a number of defensible reasons not to (see *A Foolish Consistency is the Hobgoblin
    of Little Minds* in PEP-8). Those include, but are not limited to, the following:'
  prefs: []
  type: TYPE_NORMAL
- en: When applying PEP-8 style guidelines would make the code less readable, even
    for someone who is used to reading code that follows the standards
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To be consistent with surrounding code that also does not adhere to them (maybe
    for historic reasons)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because there is no reason other than the style guidelines to make changes to
    the code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If adherence to the guidelines would break backwards compatibility (let alone
    functionality, though that seems unlikely)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'PEP-8 notes specifically that it is a style guide, and as mentioned in the
    Style Guide Introduction of Solidity v0.3.0:'
  prefs: []
  type: TYPE_NORMAL
- en: '"A style guide is about consistency. Consistency with this style guide is important.
    Consistency within a project is *more* important. Consistency within one module
    or function is the most important".'
  prefs: []
  type: TYPE_NORMAL
- en: 'That implies that there may be good (or at least defensible) reasons to not
    adhere to some or all of the guidelines, even for new code. Examples might include
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Using naming conventions from another language because the functionality is
    equivalent, such as using JavaScript naming conventions in a Python class library
    that provides the same **Document Object Model** (**DOM**) manipulation functionality
    across a server-side class library for creating and working with DOM objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using very specific documentation string structures or formats to conform to
    a documentation management system's requirements that applies to all code (Python
    or otherwise) across the business
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conforming to other internal standards that contradict the ones advised by PEP-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ultimately though, since PEP-8 is a set of style guidelines, not functional
    ones, the worst that can happen is that someone will complain that the code doesn't
    stick to the publicly accepted standards. If your code is never going to be shared
    outside your organization, that may well never be a concern.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three loose groupings in PEP-8''s guidelines whose members can be
    summarized briefly:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Code layout**:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Indentation should be four spaces per level:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don't use tabs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hanging indentation should use the same set of rules wherever possible, see
    the PEP-8 page for specifics and recommendations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functional lines should not exceed 79 characters in length and long text strings
    should be limited to 72 characters per line, including indentation spaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a line has to break around an operator (+, -, *, and, or, and so on), break
    it before the operator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Surround top-level functions and class definitions with two blank lines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Comments**:'
  prefs: []
  type: TYPE_NORMAL
- en: Comments that contradict the code are worse than no comments—always make a priority
    of keeping the comments up-to-date when the code changes!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comments should be complete sentences. The first word should be capitalized,
    unless it is an identifier that begins with a lowercase letter (never alter the
    case of identifiers!).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Block comments generally consist of one or more paragraphs built out of complete
    sentences, with each sentence ending in a period.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Naming conventions**:'
  prefs: []
  type: TYPE_NORMAL
- en: Packages and modules should have short names, and use the `lowercase` or (if
    necessary) `lowercase_words` naming convention
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class names should use the `CapWords` naming convention
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions and methods should use the `lowercase_words` naming convention
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constants should use the `CAP_WORDS` naming convention
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Other items that are noted in PEP-8 but are too long to summarize usefully
    here include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Source file encoding (which feels like it may soon stop being a concern)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Imports
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whitespace in expressions and statements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documentation strings (which have their own PEP:  [www.python.org/dev/peps/pep-0257](http://www.python.org/dev/peps/pep-0257))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing for inheritance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These, along with PEP-8's substantial *Programming Recommendations* section,
    will be followed in code during the development of the `hms_sys` project where
    they don't conflict with other standards.
  prefs: []
  type: TYPE_NORMAL
- en: Internal standards
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Any given development effort, team, or even company may have specific standards
    and expectations around how code is written or structured. There may also be functional
    standards as well, things such as policies that define what types of external
    systems will be used to provide various functionality that systems consume, which
    RDBMS engines are supported, what web servers will be used, and so on. For the
    purposes of this book, the functional standards will be determined during development,
    but some code structure and format standards will be defined here and now. As
    a starting point, the PEP-8 code layout, comments, and naming convention standards
    will apply. Over and above that, there are some code organization and class structure
    standards that will also be in play.
  prefs: []
  type: TYPE_NORMAL
- en: Code organization in modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The PEP-8 structure and sequence guidelines will be followed, with a module
    level doc string, imports from `__future__`, various dunder-names (an `__all__`
    list to support `from [module] import [member]` use of the module's members, and
    some standard `__author__`, `__copyright__` and `__status__` metadata about the
    module), then imports from standard libraries, then third-party libraries, and
    finally internal libraries.
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, code will be organized and grouped by member types, in this order,
    with each element in alphabetical order (unless there are functional reasons why
    that order isn''t viable, such as classes depending on or inheriting from other
    classes that haven''t been defined yet if they are in strict order):'
  prefs: []
  type: TYPE_NORMAL
- en: Module-level constants
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom exceptions defined in the module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Abstract base classes that are intended to serve as formal interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Abstract base classes that are intended to serve as standard abstract classes,
    or as mixins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Concrete classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The goal of all of these structure constraints is to provide some predictability
    across the entire code base, to make it easy to locate a given module member without
    having to search for it every single time. Modern IDEs, with the ability to control-click
    on a member name in code and jump straight to that member's definition, arguably
    make that unnecessary, but if code is going to be viewed or read by someone without
    access to such an IDE, organizing it this way still has some value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Accordingly, module and package header files follow a very specific structure,
    and that structure is set up in a set of template files, one for general purpose
    modules, and one for package header (`__init__.py`) modules. Structurally, they
    are identical, with only some slight variation between the two in the starting
    text/content. The `module.py` template then is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The only real differences between a module''s template and one for a package
    header is the initial documentation and that there is a specific callout for including
    child package and module namespace members in the `__all__` list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Having these available as template files for developer use also makes starting
    a new module or package a bit quicker and easier. Copying the file, or its contents,
    to a new file takes a few seconds longer than just creating a new, blank file,
    but having the structure ready to start coding in makes it a lot easier to maintain
    the relevant standards.
  prefs: []
  type: TYPE_NORMAL
- en: Structure and standards for classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Class definitions, whether for concrete/instantiable classes or any of the
    ABC variants, have a similar structure defined, and will be arranged in sorted
    groups as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Class attributes and constants
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Property getter methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Property setter methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Property deleter methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instance property definitions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Object initialization (`__init__`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Object deletion (`__del__`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instance methods (concrete or abstract)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overrides of standard built-in methods (`__str__`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Static methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The property getter, setter, and deleter methods approach was selected, rather
    than using method decoration, in order to make it easier to keep property documentation
    in a single location in the class definition. The use of properties (technically,
    they are managed attributes, but properties is a shorter name, and has the same
    meaning across several languages) as opposed to general attributes is a concession
    to unit testing requirements, and to a policy of raising errors as close to their
    cause as possible. Both will be discussed shortly, in the unit testing part of
    the *Process standards* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'The concrete class template then contains the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Apart from the `__init__` method, which will almost always be implemented, the
    actual functional elements, the properties and methods, are commented out. This
    allows the standards expected to be present in the template, and developers can,
    if they so choose, simply copy and paste whichever code stub(s) they need, uncomment
    the whole pasted block, rename what needs to be renamed, and start writing code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The template file for abstract classes is very similar to the concrete class
    template, with the addition of a few items to accommodate code elements that are
    not present in a concrete class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'A similar template is also available for class definitions that are intended
    to serve as formal interfaces; classes that define functional requirements for
    an instance of a class, but that don''t provide any implementation of those requirements.
    It looks very much like the abstract class template, barring some name changes
    and the removal of anything that is or implies a concrete implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Taken together, these five templates should provide solid starting points for
    writing code for any of the more commonly expected element types expected in most
    projects.
  prefs: []
  type: TYPE_NORMAL
- en: Function and method annotation (hinting)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you''ve worked with Python functions and methods before, you may have noticed
    and wondered about some unexpected syntax in some of the methods in the template
    files earlier, specifically the items in bold here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: These are examples of type hints that are supported in Python 3\. One of the
    standards that `hms_sys` code will also adhere to is that all methods and functions
    should be type hinted. The resulting annotations may eventually be used to enforce
    type checking of arguments using a decorator, and even later on may be useful
    in streamlining unit testing. On a shorter-term basis, there is some expectation
    that an automatic documentation generation system will pay attention to those,
    so they're part of the internal standards now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Type hinting is probably new enough that it''s not in common use just yet,
    so a walk-through of what it does and how it works is probably worth examination.
    Consider the following unannotated function and its results when executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The results from executing that code look good:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/da5bef60-87f3-45c8-9f50-29ebc2ef05ca.png)'
  prefs: []
  type: TYPE_IMG
- en: This is pretty straightforward, as Python functions go. The `my_function` function
    expects a `name` and `price`, and also allows for a `description` argument, but
    that is optional and defaults to `None`. The function itself just collects all
    those into a formatted string-value and returns it. The `price` argument should
    be a number value of some sort, and the others should be strings, if they exist.
    In this case, the expected types of those argument values are probably obvious
    based on the argument names.
  prefs: []
  type: TYPE_NORMAL
- en: The price argument, though, could be any of several different numerical types,
    and still function—`int` and `float` values obviously work, since the code runs
    without error. So too would a `decimal.Decimal` value, or even a `complex` type,
    as nonsensical as that would be. The type hinting annotation syntax exists, then,
    to provide a way to indicate without requiring what type or types of values are
    expected or returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the same function, hinted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The only differences here are the type hinting annotations after each argument
    and the return type hint at the end of the function''s first line, which indicate
    the expected types of each argument, and of the results of calling the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The output from the function call is identical, but the `__annotations__` attribute
    of the function is shown at the end of the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/5eace41e-d234-4549-85e7-277465066658.png)'
  prefs: []
  type: TYPE_IMG
- en: All the type-hinting annotations really do is to populate the `__annotations__`
    property of `my_function`, as shown at the end of the preceding execution. Essentially,
    they are providing metadata about and attached to the function itself that can
    be used later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Taken together then, all of these standards are intended to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Help keep code as readable as possible (baseline PEP-8 conventions)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keep the structure and organization of code within files predictable (module
    and class element organization standards)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make it easy to create new elements (modules, classes, and so on) that conform
    to those standards (the various templates)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide some degree of future-proofing against efforts to allow automated documentation
    generation, type checking of methods and functions, and possibly some unit testing
    efficiencies to be explored later (type-hinting annotations)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Process standards
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Process standards are concerned with what processes are executed against a
    code base towards any of several purposes. The two that are most common as separate
    entities are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Unit testing:** Ensuring that code is tested and can be re-tested on demand,
    in an effort to ensure in turn that it works as expected'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Repeatable build processes:** Designed so that whatever build process you
    use and probably the installation process as a result, is automated, error free,
    and repeatable on demand while requiring as little developer time to execute as
    possible'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Taken together, these two also lead to the idea of **integrating unit tests
    and build processes**, so that, if needful or desired, a build process can ensure
    that its resulting output has been tested.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s not unusual for people, even developers, to think of unit testing as
    a process of making sure that bugs aren''t present in a code base. While there
    is a fair amount of truth to that, at least in smaller code bases, that''s actually
    more a result of the real purpose behind unit testing: unit testing is about ensuring
    that code behaves in a predictable fashion across all reasonably possible execution
    cases. The difference can be subtle, but it''s still a significant one.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take another look at the preceding `my_function`,  this time from a
    unit testing perspective. It''s got three arguments, one that is a required string
    value, one that is a required number value, and one that is an optional string
    value. It makes no decisions based on any of those values or their types, it just
    dumps them into a string and returns that string. Let''s assume that the arguments
    supplied are properties of a product (which is what the output implies, even if
    that''s not really the case). Even without any decision making involved, there
    are aspects to the functionality that will raise errors, or that probably should
    in that context:'
  prefs: []
  type: TYPE_NORMAL
- en: Passing a non-numeric `price `value will raise a `TypeError` because the string
    formatting won't format a non-numeric value with the `%0.2f` format specified
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing a negative `price` value probably should raise an error—unless it's
    actually possible for a product to have a negative price, it just doesn't make
    sense
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing a `price` value that is numeric, but isn't a real number (like a `complex`
    number) probably should raise an error
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing an empty `name` value probably should raise an error—it makes no sense
    to have what we presume to be a product name accept an empty value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing a multi-line `name` value might be a case that should raise an error
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing a non-string `name` value probably ought to raise an error as well,
    for similar reasons, as would a non-string `description` value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apart from the first item in the list, these are all potential flaws in the
    function itself, none of which will raise any errors at present, but all of which
    could very well lead to undesirable behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Bugs.
  prefs: []
  type: TYPE_NORMAL
- en: The following basic test code is collected in the `test-my_function.py` module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even without bringing a formal unit testing structure into play, it''s not
    difficult to write code that will test a representative set of all good argument
    values. First, those values have to be defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, it''s a simple matter of iterating over all the good combinations and
    keeping track of any errors that surface as a result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The results from executing that code look good:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c119726e-0acd-4486-ae24-6c187cf44232.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, a similar approach is taken for defining bad values for each argument,
    and checking each possible bad value with known good values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Even with just the name argument tests in place, we already start seeing issues:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/0870e550-8c3c-4b42-bbea-31e3170ac59c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'And after adding in similar tests for price and description values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting list of issues is larger still, with a total of 15 items, any
    of which could lead to a production code bug if they aren''t addressed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/3fad35b8-d5db-4a7a-ae38-1a9bb763e598.png)'
  prefs: []
  type: TYPE_IMG
- en: 'It''s not enough, then, just to say that unit testing is a requirement in the
    development process; some thought has to be given to what those tests actually
    do, to what the relevant test policies look like, and what they are required to
    take into account. A good bare-bones starting point test policy would probably
    include, at a minimum the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'What values are used when testing arguments or properties of specific types:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Numeric values should probably include even and odd variations, positive and
    negative values, and zero at a minimum
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: String values should include expected values, an empty string value, and strings 
    that are nothing more than whitespace (" ")
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some understanding of when each of those values is valid and when they are not,
    for each element being tested
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tests must be written for both passing and failing cases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tests must be written such that they execute every branch in the element being
    tested
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That last item bears some explanation. Thus far, the code being tested made
    no decisions—it executes in exactly the same way, no matter what the values of
    the arguments are. A full unit test executed against code that does make decisions
    based on the values of arguments must be sure to pass test values for those arguments
    that invoke all of the decisions that the code can make. It is rare that this
    need will not be sufficiently accounted for by simply making sure that the good
    and bad test values are sufficiently varied, but it can become more difficult
    to ensure when complex class instances enter the picture, and those circumstances
    warrant closer, deeper attention.
  prefs: []
  type: TYPE_NORMAL
- en: 'It was noted earlier, in the discussion around class templates, that formal
    properties (managed attributes) would be used, and that the reason behind that
    tied in to unit testing policies. We''ve seen that it''s relatively easy to generate
    tests that can check for specific error types during the execution of a function
    or method. Since properties are collections of methods, one each for get, set,
    and delete operation, packaged up by the `property` keyword, it follows that performing
    checks against a value passed to a setter method and raising errors if the value
    or type passed in is invalid (and thus probably going to raise errors elsewhere)
    is going to make unit testing implementation following the structure/pattern shown
    earlier at least somewhat faster and easier. A basic structure, using the `property_name`
    property from the `class-concrete.py` template, shows that it''s quite straightforward
    to implement such a property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: There are 18 lines of code involved, which is at least 17 lines more than would
    be required if `property_name` was a simple, unmanaged attribute, and there are
    probably going to be at least two more lines of code in the `__init__` method
    of the class that uses this property if `property_name` is set during the creation
    of an instance. The trade-off, though, is that the managed attribute property
    is going to be self regulating, so there won't have to be much in the way of checking
    its type or value wherever else it might be used. The fact that it is accessible
    at all, that the instance it's a member of hasn't thrown an error before the property
    is being accessed, means that it's in a known (and valid) state.
  prefs: []
  type: TYPE_NORMAL
- en: Repeatable build processes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The idea of having a build process may have originated with languages that require
    compilation before their code can be executed, but there are advantages to establishing
    such a process even for languages such as Python that don't. In Python's case,
    specifically, such a process can collect code from multiple project code bases,
    define requirements without actually attaching them to the final package, and
    package code up in a consistent fashion, ready for installation. Since a build
    process is, itself, another program (or at least a script-like process), it also
    allows for the possibility of executing other code to whatever end is needed,
    which means that a build process can also execute automated tests, or even potentially
    deploy code to a designated destination, locally or remotely.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python''s default installation includes two packaging tools, `distutils` ,
    which is a collection of bare-bones functionality, and `setuptools`, which builds
    on top of that to provide a more powerful packaging solution. The output of a
    `setuptools` run, if packaging arguments are supplied, is a ready-to-install package
    (an egg). The conventional practice for the creation of a package is through a
    `setup.py` file that makes a call to the setup function that `setuptools` provides,
    which might look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The arguments shown all relate to specific aspects of the final package:'
  prefs: []
  type: TYPE_NORMAL
- en: '`name`: Defines the base name for the final package file (for example, `MyPackageName`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`version`: Defines the version of the package, a string that will also be part
    of the final package file''s name'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`author`: The name of the primary author of the package'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`description`: A short description of the package'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`long_description`: A long description of the package; this is often implemented
    by opening and reading a file containing the long description data, typically
    in Markdown format if the package is intended to be uploaded to the Python website''s 
    package repository'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`author_email`: The email address of the primary author of the package'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`url`: The home URL for the package'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`install_requires`: A list of package name and version requirements that need
    to be installed in order to use the code in the package – a collection of dependencies'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`package_dir`: A dictionary that maps package names to source directories;
    the `''package_name'':''project_root_directory''` value shown is typical for projects
    that have their source code organized under a `src` or `lib` directory, often
    at the same level in the filesystem as the `setup.py` file itself'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`packages`: A list of packages that will be added to the final output package;
    the `setuptools` module also provides a function, `find_packages`, that will search
    out and return that list, with provisions for explicit exclusion of package directories
    and files using a list of patterns to define what should be left out'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`package_data`: A collection of non-Python files that need to be included in
    the package directory that they are mapped to; that is, in the example shown,
    the `setup.py` run will look for a `package_name` package (from the packages list),
    and include the `file_name.ext` file in that package because it''s been listed
    for inclusion'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`entry_points`: Allows the installer to create command-line-executable aliases
    for specific functions in the code base; what it will actually do is create a
    small, standard Python script that knows how to find and load the specified function
    from the package, then execute it'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A far more detailed look at the creation, execution, and results from an actual
    `setup.py` will be undertaken with the first package created for `hms_sys`. There
    are also options for specifying, requiring, and executing automated unit tests
    that will be explored. If they provide the test execution and stop-on-failure
    functionality needed, then `setuptools.setup` will probably suffice for all the
    needs of `hms_sys`.
  prefs: []
  type: TYPE_NORMAL
- en: If there are additional needs discovered that a standard Python setup process
    cannot manage for whatever reason, then a fallback build process will be needed,
    though it will almost certainly still use the results of a `setup.py` run as part
    of its process. In order to keep that fallback as (relatively) simple as possible,
    and to ensure that the solution is available across as many different platforms
    as possible, the fallback will use GNU Make.
  prefs: []
  type: TYPE_NORMAL
- en: 'Make operates by executing command-line scripts for each target that is specified
    in a `Makefile`. A simple `Makefile`, with targets for testing and executing a
    `setup.py` file, is very simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Running a Make process from the command line is as simple as executing `make`,
    perhaps with a target specification:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c6164b64-9f8f-47cf-8a44-41abbb02a21f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The first run (`make` without any target specified) executes the first target
    in the `Makefile`: `main`. The `main` target, in turn, has the `test` and `setup`
    targets specified as prerequisite targets to execute before moving ahead with
    its own processes. The same results would be returned if `make main` were executed.
    The second and third runs, `make test` and `make setup`, respectively, execute
    those specific targets.'
  prefs: []
  type: TYPE_NORMAL
- en: Make, then, is a very flexible and powerful tool to have available. So long
    as a given build process step can be executed in the command line, it can be incorporated
    into a Make-based build. If different processes are needed for different environments
    (`dev`, `test`, `stage` , and `live`, for example), it's possible to set up Make
    targets that correspond to those environments, allowing one build process to handle
    those variations with nothing more complex than executing `make dev`, `…`, `make
    live`, though some care in target naming will be needed to avoid name collisions
    between two different but logically sound `test` targets in this case.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating unit tests and build processes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The build process, as hinted earlier, should allow the incorporation and execution
    of all available automated tests (unit tests at a minimum) that are created for
    a project. The goal of that integration is to prevent code that's failed its suite
    of tests from being buildable, and thus deployable, and thus to ensure that only
    demonstrably good code is available for installation, at least at a live or production
    code level.
  prefs: []
  type: TYPE_NORMAL
- en: 'It may be necessary to allow broken code, code that fails its tests, to be
    buildable at a local or shared development build level, though, if only because
    developers may well want or need to install a broken build in order to troubleshoot
    issues. That will be very circumstantial, dependent on whatever policies and procedures
    are in place to handle circumstances like that. A possible policy set, based on
    five environments, might boil down to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Local development:** No testing required at all'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Shared development:** Test required, but failed tests do not kill the build
    process, so broken builds can be promoted to the common dev server(s); broken
    builds are logged, however, and those logs are easily available in case there''s
    a need to promote code in a hurry'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**QA/test:** As the shared development environment'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Staging** (and **User Acceptance Testing**) **environments:** Tests must
    execute and pass for code to be installed or promoted'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Live/production:** As staging'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the standard `setuptools`-based packaging process will allow tests to run,
    cause failed tests to abort the packaging effort, and won't require tests to execute
    during installation, then that provides adequate functional coverage of this sort
    of policy set, though use of a wrapper (such as Make) to provide environment-specific
    targets and build processes may be needed to deal with policy conformance/coverage.
  prefs: []
  type: TYPE_NORMAL
- en: If unit testing and build process standards are in place and followed, the end
    result will tend to be code that is both easily built and deployed, no matter
    what state it might be in, and that behaves in a known (and provable) fashion
    under all known circumstances. That doesn't mean that it will be free of bugs,
    though; it's much less likely to have any significant bugs, so long as the test
    suite(s) are thorough and complete, but that's not a guarantee.
  prefs: []
  type: TYPE_NORMAL
- en: There is some overhead involved in establishing the associated processes, and,
    particularly on the unit testing side, still more overhead in maintaining them,
    but the effects and impact on a system's stability can be amazing.
  prefs: []
  type: TYPE_NORMAL
- en: The author once wrote an asset catalog system for an advertising firm that was
    in daily use by as many as 300 people every business day following these process
    guidelines. Over the course of four years, runtime, including an update to a new
    and significantly changed version of the system, the total number of errors reported
    that weren't user error, data entry errors, or enterprise-level access permissions
    was four. These process standards make a difference.
  prefs: []
  type: TYPE_NORMAL
- en: Defining package structures for Python code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The package structure rules in Python are important, since they will determine
    what code is accessible when an attempt is made to import members from that package.
    Package structure is also a subset of the overall project structure that can have
    a significant impact on an automated build process, and it might also have an
    impact on unit testing setup and execution. Let''s start then by examining a possible
    top-level project structure first, as shown here, and then review what a Python
    package''s requirements are, and see how it fits into the project overall:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/f45a3c24-c8ce-41a4-8da5-36ea2ff5459d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This project structure assumes that the final build will be installed on a
    POSIX system – most Linux installations, macOS, UNIX, and so  on. There may be
    different needs for, say, a Windows installation, and that will be explored during
    the `hms_sys` development cycle, when we start working out the remote desktop
    applications for it. Even so, the structure may still hold up:'
  prefs: []
  type: TYPE_NORMAL
- en: The `bin` directory is intended to collect code and programs that the end user
    can execute, whether from a command line, or through the GUI of the OS. Those
    items may or may not use the main package's code, though the odds are good that
    it will if they are Python executables.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `etc` directory is where configuration files are stored, and the `example_project`
    directory beneath that would then be for a configuration that is very specific
    to the final installed instance of the project. It may be feasible, or even a
    better approach, to drop project-specific configurations in the top-level, and
    so on, directory—that decision will need to be evaluated on a project-by-project
    basis, and may depend on whether the end user installing the project has permissions
    to install to global directories.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `scratch-space` directory is just a place to collect whatever random files
    might be useful during development – proof-of-concept code, note files, whatever.
    It's not intended to be part of a build and won't be deployable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `src` directory is where the project code lives. We'll dig deeper into that
    shortly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `var` directory is where POSIX systems store program data that needs to
    be persisted as files. The `cache` directory within it is a standard POSIX location
    for caching files, and the `example_project` directory within that would therefore
    be the location specifically for the project's code to cache files. It may be
    useful to have a dedicated, project-specific directory in `var` that's not in
    `cache`, and that's also provided.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Packages in a project's context
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Within the `src` directory is the package tree for the project. Each directory
    level at or under the `example_project` directory that has an `__init__.py` file
    is a formal Python package, and will be accessible through an import statement
    in Python code. Once this project is built and installed, then, and assuming that
    the code within it is written to accommodate the relevant import structure, all
    of the following would be legitimate imports from the project''s code:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `import example_project` | Imports the entire `example_project` namespace
    |'
  prefs: []
  type: TYPE_TB
- en: '| `import example_project.package` | Imports `example_project.package` and
    all its members |'
  prefs: []
  type: TYPE_TB
- en: '| `from example_project import package` |'
  prefs: []
  type: TYPE_TB
- en: '| `from example_project.package import member` | Assuming that `member` exists,
    imports it from `example_project.package` |'
  prefs: []
  type: TYPE_TB
- en: '| `import example_project.package.subpackage` | Imports `example_project.package.subpackage`
    and all its members |'
  prefs: []
  type: TYPE_TB
- en: '| `from example_project.package import subpackage` |'
  prefs: []
  type: TYPE_TB
- en: '| `from example_project.package.subpackage import member` | Assuming that `member`
    exists, imports it from `example_project.package.subpackage` |'
  prefs: []
  type: TYPE_TB
- en: 'A typical pattern for packages in Python is to group code elements around common
    realms of functionality. For example, a package that, at a very high level, is
    focused on DOM manipulation (HTML page structure), and supports XML, XHTML, and
    HTML5 might group things like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dom (__init__.py)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`generic (__init__.py)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[General-purpose classes for working with elements]'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`html (__init__.py)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`generic (generic.py)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[General-purpose classes for working with HTML elements]'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '``forms (forms.py)``'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`html5 (__init__.py)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Classes for working with HTML-5-specific elements]'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`forms (forms.py)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`xhtml (__init__.py)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Classes for working with XHTML-specific elements]'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`forms (forms.py)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`xml (__init__.py)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A full implementation, then, of that structure might allow a developer to access
    an HTML5 Email field object by creating an instance of a class that lived at the
    `dom.html5.forms.EmailField` namespace, and whose code lived in `.../dom/html5/forms.py`
    as a class named `EmailField`.
  prefs: []
  type: TYPE_NORMAL
- en: Deciding where specific classes, functions, constants, and so on should exist
    in the structure of a code base is a complex topic, and will be explored in greater
    depth as part of the early architecture and design of `hms_sys`.
  prefs: []
  type: TYPE_NORMAL
- en: Using Python virtual environments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python allows a developer to create virtual environments that collect up all
    the baseline language facilities and functionality into a single location. Once
    set up, those virtual environments have packages installed in to or removed from
    them, which allows a project that's executing in the context of the environment
    to have access to packages and functionality that may not be needed in the base
    system. A virtual environment also provides a mechanism for keeping track of those
    installations, which in turn allows a developer to keep track of only those dependencies
    and requirements that are relevant to the project itself.
  prefs: []
  type: TYPE_NORMAL
- en: Virtual environments can also be used, with some care and thought, to allow
    a project to be developed against a specific version of the Python language –
    one that's no longer supported, for example, or that's still too new to be available
    as a standard installation in the development machine's OS. This last aspect can
    be very useful in developing Python applications to run in various public clouds
    such as Amazon's AWS, where the Python version may be newer than what's generally
    available, and may also have significant syntax differences from earlier versions
    of the language.
  prefs: []
  type: TYPE_NORMAL
- en: Breaking changes at the language level aren't very common, but they have happened
    in the past. Virtual environments won't solve those, but they will, at least,
    allow different versions of code to be maintained with more ease.
  prefs: []
  type: TYPE_NORMAL
- en: 'Provided that the appropriate Python module (`venv` in Python 3) is already
    installed, creating a virtual environment, activating, and deactivating it at
    a command-line level is pretty straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/38b5c2fb-3d5a-421d-be9a-1e53fd809b99.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Creates a new, minimal virtual environment at the specified location (in this
    case, in a directory named `example_ve`, in a directory named `py_envs` in the
    user''s home directory):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This activates the newly created virtual environment. At this point, launching
    `python` shows that it''s using version 3.5.2, and the command line interface
    prefaces each line with `(example_ve)` to show that the virtual environment is
    active:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This deactivates the active virtual environment. Launching `python` from the
    command-line now shows the default Python version, 2.7.12, for the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Installing, updating, and removing packages, and showing what packages are
    installed, are equally straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/338a4a04-54ba-4f30-9a7e-84635fca9214.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This activates the virtual environment again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This shows the list of currently installed packages. It does not show any of
    the packages that are part of the core Python distribution, only those that have
    been added.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The first run, in this case, also notes that the current version of `pip` in
    the environment is old and can be updated, which is done with this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `pip` package itself is part of the base Python installation, and even though
    it's just been updated, that has no effect on the list of packages returned by
    calling `pip freeze` again.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate how `pip` deals with installation of new packages, the `pillow`
    library, a Python API for working with graphics files, was installed with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Since `pillow` is not a standard library, it does appear in the results of
    another `pip freeze` call. The results of `pip freeze` can be dumped to a requirements
    file (`requirements.txt`, for the purposes of illustration) as part of a project
    structure, and stored with the project, so that package dependencies don''t actually
    have to live in the source tree of the project, or be stored with it in an SCM.
    That would allow a new developer on a project to simply create their own virtual
    environment, then install the dependencies with another `pip` call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The `pillow` library was then uninstalled to show what that looks like, with
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The `pip` program does a good job of keeping track of dependencies, but it may
    not be foolproof. Even if uninstalling a package removes something that it lists
    as a dependency, but that's still in use, it's easy enough to re-install it with
    another `pip` call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Virtual environments, then, allow for a lot of control over what third-party
    packages can be associated with a project. They come with a small price, though:
    they have to be maintained, if rarely, and as changes to those external packages
    are made by one developer, some discipline needs to be exerted to make sure that
    those changes are available for other developers working on the same code base.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a fair few factors that can affect how code is written and managed,
    even before the first line of code is written. Each of them can have some impact
    on how smoothly a development effort progresses, or on how successful that effort
    is. Fortunately, there are a lot of options, and a fair amount of flexibility
    in making the decisions that determine which of them are in play, and how, even
    assuming that some team or managerial-level policies don't dictate them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Several of the decisions concerning these items for the `hms_sys` project have
    been noted, but since the next chapter starts on that development for real, they
    might be worth calling out once more:'
  prefs: []
  type: TYPE_NORMAL
- en: Code will be written using either Geany or LiClipse as the IDE. They both provide
    code project management facilities that should handle the multiple-project structure
    that's expected, and will provide enough of the bells and whistles needed to make
    navigating across projects relatively painless. Initially, the effort will use
    Geany, and LiClipse will be held in reserve if Geany becomes too troublesome to
    work with, or can't handle some aspect of the project after development has progressed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Source Code Management will be handled with Git, pointing at an external repository
    service such as GitHub or Bitbucket.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code will follow PEP-8 recommendations until or unless there's a compelling
    reason not to, or they conflict with any of the internal standards noted.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code will be written following the structure laid out in the various template
    files shown.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Callables – functions and class methods – will use type-hinting annotations
    until or unless there is a compelling reason not to.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All code will be unit tested, though test policy details have yet to be defined
    other than assuring that all public members are tested.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each code project in the system will have its own build process, using standard
    `setup.py` mechanisms, with `Makefile`-based processes wrapped around them if
    needed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each build process will integrate unit test results in order to prevent a build
    from completing if any of the unit tests fail.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Package structure within the projects has not yet been defined, but will unfold
    as development gets underway.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each project will have and use its own distinct virtual environment, in order
    to keep the requirements and dependencies associated with each project separate.
    This may require some build process tweaking, but that remains to be seen.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
