- en: Chapter 1. Introduction to Windows 8 Apps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Windows 8, Microsoft's latest client operating system, looks quite different
    than its Windows 7 predecessor. With a new Start (home) screen, it promises to
    be a redesigned system, not just on the UI front but also in the way applications
    are written. A new style of applications is available for Windows 8 (and later)
    that are quite different from the "normal" applications (that are still very much
    supported).
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we'll take a quick tour of the new Windows 8 features, specifically
    those related to the new application type, known as Windows Store apps (formerly
    "Metro").
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Windows 8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Windows 8 has been described by Microsoft as "Windows reimagined", which is
    not a false statement. From a user's perspective Windows 8 looks different; most
    notably, a new Start screen and the removal of the ubiquitous Start button that
    existed since Windows 95.
  prefs: []
  type: TYPE_NORMAL
- en: Under the covers, though, Windows is still the operating system we know and
    love; applications running on Windows 7 should continue to run just as well (and
    probably better) on Windows 8\. Many improvements went into the product, most
    of them invisible to the typical user; the visible changes are quite evident right
    from the Start (pun intended).
  prefs: []
  type: TYPE_NORMAL
- en: Touch everywhere
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Windows 8 targets touch-enabled devices, such as tablets. Microsoft itself is
    providing tablet devices under its own brand ("Surface") that are available starting
    from the Windows 8 **General Availability** (**GA**) date, October 26, 2012.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It's worth mentioning that in the same time frame, Microsoft has released Windows
    Phone 8, the successor of the Windows 7.5 mobile OS, with a similar look and feel
    to Windows 8\. Windows Phone 8 is based on the same kernel that powers Windows
    8, and shares portions of the Windows 8 runtime. Going forward, these platforms
    are likely to merge, or at least come closer together.
  prefs: []
  type: TYPE_NORMAL
- en: Windows 8 is optimized for touch-enabled devices. Swiping the edges of the screen
    (always towards the visible part of the screen) causes something to happen (the
    same effect can be achieved with the mouse by moving the cursor to the edges or
    by using certain keyboard shortcuts). For example, swiping from the right causes
    the Charms bar to appear (more on the Charms bar in *The Charms bar* section given
    later in the chapter); the same effect can be achieved by moving the mouse cursor
    to the right edge of the screen or using the keyboard shortcut Windows key + *C*.
  prefs: []
  type: TYPE_NORMAL
- en: The Start (Home) screen
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first thing to note about Windows 8 is the new **Start** screen. It's filled
    with tiles, mostly representing applications installed on the machine. The well-known
    desktop (from previous Windows versions) appears as a regular tile; clicking it
    (or tapping it using touch) transfers the user to the familiar desktop environment
    with largely the same functionality as in previous Windows versions, with shortcut
    icons, the taskbar, the notifications area, and so on, all except the Start button,
    which has gone away.
  prefs: []
  type: TYPE_NORMAL
- en: 'All installed applications are available from the new **Start** screen, whether
    they are the "normal" desktop applications or the new Store ("Metro") style applications:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Start (Home) screen](img/5022_01_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The AppBar
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Swiping from the bottom in the **Start** screen presents the AppBar. This piece
    of UI is the replacement for a right-click context menu popular with the mouse.
    In fact, right-clicking with the mouse anywhere in the **Start** screen shows
    the AppBar, just as if the screen was swiped from the bottom.
  prefs: []
  type: TYPE_NORMAL
- en: The AppBar provides relevant options depending on the selected object (or no
    selected object) and is used with the new Store apps just as on the **Start**
    screen; there is no built-in way to show the classic context menu in a Store application,
    even if a mouse device is used.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The fact that right-clicking in a Windows Store app (or the **Start** screen)
    causes the AppBar to appear even though the mouse is used is somewhat annoying,
    as the user is now forced to move the mouse from the intended object all the way
    to the bottom (or top for some applications) to select the required option.
  prefs: []
  type: TYPE_NORMAL
- en: The Charms bar
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Charms bar appears when swiping from the right (on a touch device), or
    by moving the mouse to one of the corners on the right-hand side of the screen.
    Charms are ways to communicate with other applications from a user''s perspective.
    The standard charms are **Search**, **Share**, **Start**, **Devices**, and **Settings**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Charms bar](img/5022_01_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The **Search** charm allows the user to not just search in the operating system's
    applications (such as Control Panel applications) and the user's personal files
    (documents, pictures, and so on), but also in any other Store application that
    indicates it supports the Search contract.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: From the **Start** screen you can start searching just by typing on the keyboard,
    no need to explicitly activate the **Search** charm.
  prefs: []
  type: TYPE_NORMAL
- en: The **Share** charm allows an app to communicate with other apps without knowing
    anything about those apps. This is achieved by implementing the Share contract—either
    as a provider and/or receiver (we'll cover contracts in [Chapter 8](ch08.html
    "Chapter 8. Contracts and Extensions"), *Contracts and Extensions*).
  prefs: []
  type: TYPE_NORMAL
- en: The **Start** charm simply takes the user to the **Start** screen.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Pressing the Windows key alone, at any time, shows the **Start** screen.
  prefs: []
  type: TYPE_NORMAL
- en: The **Devices** charm allows access to device-related activities (if supported
    by the app), such as printing. And finally, the **Settings** charm allows the
    user to customize the currently executing app (if supported by the app), or to
    customize general Windows features.
  prefs: []
  type: TYPE_NORMAL
- en: Desktop apps versus Store apps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the applications running on Windows systems prior to Windows 8 are called
    Desktop applications in Windows 8 terminology. These are the regular, normal applications,
    which can be built with any of the various Microsoft technologies, such as the
    Win32 API, **Microsoft Foundation Classes** (**MFC**), **Active Template Library**
    (**ATL**), .NET technologies (WPF, Silverlight, Windows Forms, and so on), and
    any logical combination of these. These types of applications are still very much
    supported in Windows 8, so there's really nothing special here.
  prefs: []
  type: TYPE_NORMAL
- en: The other type of applications supported in Windows 8 is the Store applications.
    These applications are unsupported in previous Windows versions. Windows Store
    apps are the focus of this book. We won't be dealing with desktop apps at all.
  prefs: []
  type: TYPE_NORMAL
- en: 'Store applications are different in many ways from desktop apps. Some of the
    differences are:'
  prefs: []
  type: TYPE_NORMAL
- en: Store apps are immersive, they are always full screen (except when snapped,
    see [Chapter 9](ch09.html "Chapter 9. Packaging and the Windows Store"), *Packaging
    and the Windows Store*); there is no window chrome (that is no caption, no close
    or minimize buttons, and so on). We'll discuss the user interface aspects of Store
    apps in [Chapters 3](ch03.html "Chapter 3. Building UI with XAML"), *Building
    UI with XAML* and [Chapter 4](ch04.html "Chapter 4. Layout, Elements, and Controls"),
    *Layout, Elements, and Controls*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Store apps life cycle is managed by Windows. If another application becomes
    the foreground app, the previous app is suspended (after a few seconds), consuming
    no CPU cycles. We'll discuss the application lifecycle in [Chapter 7](ch07.html
    "Chapter 7. Applications, Tiles, Tasks, and Notifications"), *Applications, Tiles,
    Tasks, and Notifications*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Only one instance of the app can run at any one time. Clicking on the app tile
    while the app is running simply switches to the running app. The user should not
    know, nor care, if the app was actually already in memory or just started up.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Store apps cannot directly communicate with other running apps, some forms of
    communication are possible through the idea of contracts. We'll discuss contracts
    in [Chapter 8](ch08.html "Chapter 8. Contracts and Extensions"), *Contracts and
    Extensions*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Store apps run on top of a new runtime, called **Windows Runtime** (**WinRT**)
    that is built upon native foundations and the **Component Object Model** (**COM**)
    technologies. We'll discuss WinRT and its relation to COM in [Chapter 2](ch02.html
    "Chapter 2. COM and C++ for Windows 8 Store Apps"), *COM and C++ for Windows 8
    Store Apps*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Store apps are distributed and installed via the Windows 8 Store only (except
    for special cases for enterprise customers), and not using traditional means of
    an installer package. We'll discuss the Store in [Chapter 9](ch09.html "Chapter 9. Packaging
    and the Windows Store"), *Packaging and the Windows Store*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Store apps must declare anything they want to use up front through capabilities
    (such as using the camera that may be present on the device). Anything not declared
    will cause a failure at runtime. When a user selects the app for downloading,
    he/she must accept the capabilities the app wants to use; otherwise, the app won't
    install.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What all this means is that Store apps are different, requiring a different
    knowledge set, quite unlike the knowledge for writing desktop apps.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Windows 8 on tablets comes in two main variants, based on the CPU architecture.
    One is based on Intel/AMD (with 32 bit and 64 bit variants), which is a full Windows
    8 that can run desktop apps, as well as Store apps. The second edition is based
    on the ARM family of processors and is named "Windows RT" (not to be confused
    with the Windows Runtime). This edition can only run Store apps (at least at the
    time of writing).
  prefs: []
  type: TYPE_NORMAL
- en: The Windows Runtime
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Store applications are built and execute against a new runtime called Windows
    Runtime (WinRT) that is not present on previous Windows versions. WinRT is built
    upon the well-established COM technology (with some WinRT-specific enhancements,
    such as the use of metadata). This means WinRT is entirely native (no .NET CLR
    anywhere), making C++ a natural and performant choice for targeting this runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'WinRT provides a set of services, on which apps can be built. The relationship
    between the WinRT and applications can be represented by the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Windows Runtime](img/5022_01_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'WinRT APIs have the following characteristics:'
  prefs: []
  type: TYPE_NORMAL
- en: Built as a set of types, implementing interfaces (as mandated by COM). These
    types are arranged in hierarchical namespaces, logically grouped for easy access
    and for preventing name clashes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every WinRT object handles its own lifetime by using (mostly) an internal reference
    count (as done in COM).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the raw WinRT may be pretty verbose, leading to language projections that
    implement the little details, such as decrementing the reference count automatically
    when an object is no longer needed by a client.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All public types are built with metadata, describing the public surface of the
    API. This is part of the magic that allows various languages to access WinRT relatively
    easily.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many APIs are asynchronous, they start an operation and notify when that operation
    completes. A general guideline in WinRT is that any operation that may take more
    than 50 milliseconds should be made asynchronous. This is important so that the
    UI does not get frozen which makes for a bad user experience.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll take a detailed look at WinRT core concepts in [Chapter 2](ch02.html "Chapter 2. COM
    and C++ for Windows 8 Store Apps"), COM and *C++ for Windows 8 Store Apps*.
  prefs: []
  type: TYPE_NORMAL
- en: Language projections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As WinRT uses COM, using it directly is only possible from a language that understands
    pointers and virtual tables natively, namely C++ (C is technically also possible,
    but we won't discuss it in this book).
  prefs: []
  type: TYPE_NORMAL
- en: Many developers working with Microsoft technologies work in non-C++ environments,
    namely .NET (mostly with the C# language, but other languages are used as well,
    such as Visual Basic and F#) and JavaScript, popular (and necessary) with web
    development.
  prefs: []
  type: TYPE_NORMAL
- en: Even in C++, using COM is not as easy as we'd like; a lot of details need to
    be taken care of (such as calling the `IUnknown` interface methods when appropriate),
    distracting the developer from his/her primary job—building the actual app functionality.
    This is why Microsoft has created language projections that expose WinRT in selected
    environments fairly consistently with that particular environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Microsoft currently provides three language projections over WinRT:'
  prefs: []
  type: TYPE_NORMAL
- en: C++ has the most lightweight and direct projection. These projections are made
    possible by a set of language extensions, known as C++/CX (Component Extensions).
    These make working with WinRT objects much easier than using the raw COM interfaces
    (we'll discuss this in length in [Chapter 2](ch02.html "Chapter 2. COM and C++
    for Windows 8 Store Apps"), *COM and C++ for Windows 8 Store Apps*).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using managed (.NET) languages such as C# and Visual Basic is possible through
    projections to the .NET runtime. These projections make it very easy for .NET
    developers to work with WinRT. **Runtime Callable Wrappers** (**RCWs**) are created
    automatically to bridge the managed-native boundary when transitioning to and
    from WinRT. This mechanism is very similar in principle to the usual way in which
    .NET code calls COM objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third supported projection is with the JavaScript language, popular in web
    development. Clever wrappers over WinRT make using JavaScript relatively easy,
    including making certain conventions automatic, such as using a lowercase letter
    for the first word of a method, even though the real WinRT method begins with
    a capital letter. Using JavaScript also brings in HTML for building the Store
    app user interface, again potentially leveraging existing knowledge for JavaScript
    developers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: JavaScript is limited to consuming WinRT types. It cannot create new types (.NET
    and C++ can).
  prefs: []
  type: TYPE_NORMAL
- en: C++ does not require the CLR (.NET runtime), which makes it the most lightweight,
    both in terms of execution speed and memory consumption. We'll take a detailed
    look at using C++ throughout this book, starting from the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Building the user interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JavaScript is the only language that has direct access to working with HTML,
    as the way to create the app's user interface. This is so that JavaScript developers
    have less to learn, they probably know HTML already. The Windows Library for JavaScript
    provides access to controls, CSS, and other helpers to bridge the gap to WinRT.
  prefs: []
  type: TYPE_NORMAL
- en: C++ and .NET developers use the XAML language to build user interfaces. XAML
    is an XML-based declarative language that allows (somewhat simplistically) creating
    objects and setting their properties. We'll take a closer look at XAML and UI
    in [Chapter 3](ch03.html "Chapter 3. Building UI with XAML"), *Building UI with
    XAML*.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Developers familiar with XAML from working in other technologies, such as WPF
    or Silverlight, will feel pretty much at home, as the same basic concepts apply
    to WinRT XAML.
  prefs: []
  type: TYPE_NORMAL
- en: A third option exists, primarily for C++ developers – DirectX. DirectX is the
    most low-level and powerful graphic API on the Windows platform; thus, it's used
    mostly for authoring games while utilizing the full potential of the machine by
    leveraging the power of the **Graphic Processing Unit** (**GPU**). As DirectX
    is, itself, built upon COM, it's naturally accessible from C++. Other languages
    must go through some wrapper library to gain direct access to the DirectX APIs
    (no such wrapper is provided by Microsoft at the time of writing, but there are
    third party libraries such as SharpDX).
  prefs: []
  type: TYPE_NORMAL
- en: Creating your first Store application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Enough talk. It's time to open Visual Studio and create a simple Store app in
    C++, looking at some of its characteristics. We'll delve deeper into the way a
    Windows Store app is built in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Store apps must be created using Visual Studio 2012 (or later) running on Windows
    8 (or later); although Visual Studio 2012 runs on Windows 7, it cannot be used
    for developing Store apps on that OS.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s open Visual Studio 2012 and create a new Store application project in
    C++ by selecting the **Windows Store** node under the **Visual** **C++** node:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating your first Store application](img/5022_01_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Select **Blank App (XAML)** on the right and enter `CH01.HelloLive` in the **Name**
    textbox and enter some location on your filesystem; then click **OK**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Visual Studio creates a project with several files. We''ll take a look at those
    files a bit later, but for now open the **MainPage.xaml** file. This is where
    the UI is located. It has a split view by default, the lower pane showing the
    XAML markup and the upper pane showing a preview. The XAML shows a `Page` root
    element with several attributes and a `Grid` element inside. We''ll discuss all
    the details in [Chapter 3](ch03.html "Chapter 3. Building UI with XAML"), *Building
    UI with XAML*, but for now we''ll create a simple addition calculator as our first
    "Hello World!" application. Add the following markup inside the `Grid` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Downloading the example code**'
  prefs: []
  type: TYPE_NORMAL
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.PacktPub.com](http://www.PacktPub.com). If you
    purchased this book elsewhere, you can visit [http://www.PacktPub.com/support](http://www.PacktPub.com/support)
    and register to have the files e-mailed directly to you.
  prefs: []
  type: TYPE_NORMAL
- en: 'The upper preview part should show something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating your first Store application](img/5022_01_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Two `TextBox` controls (named `_number1` and `_number2`) are used for user
    input and a `TextBlock` element (named `_result`) is used for the output. To make
    this work, we need to handle the `Button`''s `Click` event. To do that, simply
    double-click the button in the designer. This will add an event handler in the
    `MainPage.xaml.cpp` file (as well as the corresponding header file and a `Click`
    attribute for the button in the XAML). Visual Studio should automatically open
    `MainPage.xaml.cpp`. The generated event handler will look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'At the top of the file Visual Studio created some using namespace declarations
    that we can leverage to simplify the method signature (`CH01_HelloLive`, `Platform`,
    and `Windows::UI::XAML` namespaces):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The handler may seem strange at this time, at least due to the "hat" (`^`) symbol
    stuck to the `Object` and `RoutedEventArgs` classes. We'll discuss this in the
    next chapter (this is a C++/CX extension), but the hat basically means a "reference
    counted pointer" to a WinRT object.
  prefs: []
  type: TYPE_NORMAL
- en: All that's left to do now is implement the handler, so that the calculated result
    is shown in the result `TextBlock`.
  prefs: []
  type: TYPE_NORMAL
- en: It turns out that naming elements makes those names actual member variables
    of the class in question (`MainPage`) and, thus, are available for us to use where
    needed.
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to extract the numbers to add, but the content of the `TextBox`
    controls is a string. In fact, it's a WinRT string, `Platform::String`. How do
    we convert that to a number? Do we use some WinRT function for that?
  prefs: []
  type: TYPE_NORMAL
- en: No. We use plain old C++; we just need a way to turn a `Platform::String` into
    a normal `std::string` or `std::wstring` (`wstring` should be preferred, as all
    WinRT strings are Unicode). Fortunately, that's easy with the `Data()` member
    function of `Platform::String` that returns a simple `const` `wchar_t*` pointing
    to the string; note that a Unicode pointer is the only one available.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do the actual conversion, we can use old C-style functions such as `wtoi()`,
    but for a nicer, modern conversion, we''ll use string streams. Add an `#include`
    near the top of the file (after the existing includes) for `<sstream>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, inside the event handler, we''ll create two `wstringstream` objects to
    handle the conversion based on the content of the `TextBox` controls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice the arrow (`->`) operator at work. The "hat" references are dereferenced
    using the arrow dereferencing operator, but they are not pointers (Chapter 2,
    *COM and C++ for Windows 8 Store Apps* will explain further). Let''s continue
    with the conversion to integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can actually do the conversion faster with a new C++ 11 function, `std::stoi`
    that converts a `std::string` (or `std::wstring`) to an integer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we need to place the result of adding the numbers to the `TextBlock`
    named `_result`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `ToString()` call operating on an integer, provides the conversion to a
    `Platform::String`, which is very convenient in this case. How is it possible
    to have a member function on an `int`? It's possible, because it's WinRT's `int`,
    and all WinRT types derive from an ultimate base class named `Platform::Object`
    (this is not strictly true, as this is achieved by compiler trickery. A more detailed
    explanation is provided in the next chapter), which exposes a `ToString()` virtual
    method to be overridden by derived types. Still, `int` is a primitive type in
    C++, and should not derive from anything, so how could it have a `ToString()`
    method? We'll return to that in a moment.
  prefs: []
  type: TYPE_NORMAL
- en: For now, let's test the application. Build the project and run it with the debugger
    by selecting **Debug** | **Start Debugging** from the menu, click on the relevant
    toolbar button (with a green arrow and labeled **Local Machine** by default) or
    simply press *F5*.
  prefs: []
  type: TYPE_NORMAL
- en: 'A splash screen of a crossed rectangle should appear for a few seconds and
    then the application''s UI should come up. Type two numbers in the text boxes
    and click on the button to observe the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating your first Store application](img/5022_01_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Not too sophisticated, but a Store app nonetheless! Note the application is
    full screen, with no title bar, caption buttons, or even a close button for that
    matter. This is the way Store apps look.
  prefs: []
  type: TYPE_NORMAL
- en: Closing an application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: How do we close the application? One—not so convenient with a mouse—way is to
    grab the window at the top (where a title bar would have been) and drag it all
    the way to the bottom. This was mainly done because Store apps are not meant to
    be explicitly closed. An app will become suspended (consume no CPU) if not used
    and can be terminated if the memory pressure is high; this means a typical user
    should not care about closing an app.
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, we're not typical users. A simpler way to close the app is to *Alt*
    + *Tab* back to Visual Studio and select **Debug** | **Stop Debugging** from the
    menu (or *Shift* + *F5*). That's why it's better to test Store apps from Visual
    Studio with the debugger attached.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Pressing *Alt* + *F4* also works as a way to close an application.
  prefs: []
  type: TYPE_NORMAL
- en: Application deployment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Can we run the application without Visual Studio? We can navigate to the folder
    where the source code is built and locate the resulting `.exe` file. Double-clicking
    on that from Windows Explorer fails with the following message box:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Application deployment](img/5022_01_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The error message is basically saying that we cannot simply run the Store app
    just like a desktop app, there are several steps involved in starting a Store
    app, for which a simple double-click is not merely enough. So, how can we run
    the app without Visual Studio? The same way "normal" users do, through the **Start**
    screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we open the **Start** screen and navigate all the way to the right, we''ll
    find something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Application deployment](img/5022_01_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The application was deployed automatically by Visual Studio, as if it was downloaded
    from the Windows Store. It's actually possible to do deployment only without running
    by selecting **Build** | **Deploy Solution** from Visual Studio's menu. To remove
    the application, right-click it in the **Start** screen (or swipe from the bottom)
    and select **Uninstall**.
  prefs: []
  type: TYPE_NORMAL
- en: Where did int.ToString come from?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To find this out, we''ll set a breakpoint on the last line of the click event
    handler we implemented, and run the application until we reach the breakpoint.
    When the breakpoint hits, right-click at the breakpoint line in the editor and
    select **Go To Disassembly**. These are the first few lines of assembly code at
    that point:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Where did int.ToString come from?](img/5022_01_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The last line is the interesting one, calling some static function named `default::int32::ToString`.
    We can Step Over (*F10*) to that line and then Step Into (*F11*). After a few
    more Step Into, we finally reach the actual function. Right-clicking the window
    and selecting **Go To Source Code** leaves out the detailed assembly and shows
    code from a file called `basetypes.cpp` with the function implemented like the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: All this is in a namespace called `default`. The implementation is trivial,
    using a "safe" variant on the classic `swprintf` C function before turning that
    back into a WinRT string, namely `Platform::String`. The strange `ref new` will
    be discussed in the next chapter, but it essentially means "create an instance
    of a WinRT type".
  prefs: []
  type: TYPE_NORMAL
- en: Similar helpers exist throughout the C++/CX library to make using WinRT from
    C++ easier. We'll see a lot more on that in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Project structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s take a closer look at some of the files created as part of the project
    we created:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Project structure](img/5022_01_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Most of the files are new from a C++ developer's perspective, except the files
    `pch.h` and `pch.cpp`. These files constitute the precompiled header, which means
    a header that contains seldom changed headers, so it can be compiled just once,
    saving recompilations later. In other project types, such as a regular Win32 application,
    MFC, ATL, and so on, these files were named `StdAfx.h`/`StdAfx.cpp` (which have
    no real meaning) so their names changed for the better. Their use is exactly the
    same, placement of seldom changing header files to speed up compilation times.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It's important to keep the precompiled header file name `pch.h`; this is because
    some of the code generated by the build processes uses this hardcoded filename.
  prefs: []
  type: TYPE_NORMAL
- en: '`MainPage.xaml` holds the XAML markup for the `MainPage` class. The other two
    files that complete it are the H and CPP files. Note, that the CPP file has an
    `#include` to `MainPage.xaml.h` and that file has an `#include` to `MainPage.g.h`,
    which is generated (that''s what the "g" stands for) by the XAML compiler (in
    fact, it changes as needed by editing `MainPage.xaml`, without any actual compilation).
    There we can find the declarations for the three named elements we used, without
    declaring them ourselves:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '`MainPage.xaml` itself indicates which class it''s related to with the `x:Class`
    attribute on its root element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '`App.xaml` , `App.xaml.h` , and `App.xaml.cpp` have the same kind of connection
    among themselves as do the `MainPage.*` files, but their meaning is a bit different.
    `App.xaml.h` declares the single application class that provides an entry point
    for the app, as well as other services that will be discussed in later chapters.
    It may be curious as to why it has a XAML file. Could the application object have
    a UI? Not really. The XAML is there mostly to host resources, as we''ll see in
    [Chapter 3](ch03.html "Chapter 3. Building UI with XAML"), *Building UI with XAML*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Package.appxmanifest` file is where all the application''s metadata is
    stored. Internally it''s an XML file, but Visual Studio wraps it in a nice UI
    that is easier to use most of the time. Double-clicking the file opens Visual
    Studio''s view of the manifest:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Project structure](img/5022_01_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here, we can set the name of the app, description, supported orientations, various
    images (such as the splash screen image), and many other (more important) settings,
    such as the capabilities required by the application. We'll discuss the various
    options in the relevant chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'If a raw view of the file as XML is needed, we can right-click the file in
    the Solution Explorer, select **Open With**, and then select **XML Editor**. Here''s
    what the XML looks like for our calculator application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The root element is `Package`. Everything else are the settings that differ
    from the defaults. The `Capabilities` element, for example, shows the required
    capabilities needed by the app to function correctly. The only element inside
    is `internetClient`. Clicking on the **Capabilities** tab in the Visual Studio
    manifest UI shows this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Project structure](img/5022_01_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The **Internet (Client)** option is checked (the only capability that is requested
    by default), meaning the app can make outbound calls to the network.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the XML affects the Visual Studio UI and vice versa. Sometimes, it
    may be more convenient to edit changes in the XML mode.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Windows 8 Store applications are different in many ways from desktop apps. From
    the way they look, to the way they execute and, of course, the runtime they depend
    upon. The Windows Runtime provides a rich environment for creating apps that run
    on desktop and tablet platforms alike, but it is new and, thus, requires getting
    acquainted with the library and the platform as a whole.
  prefs: []
  type: TYPE_NORMAL
- en: The Windows Runtime is based on the COM programming model, making it possible
    to create projections for various languages and runtimes. Currently, C++, .NET,
    and JavaScript are supported, but more may be created in the future by Microsoft
    and/or other vendors.
  prefs: []
  type: TYPE_NORMAL
- en: C++ developers have the most fine-grained, direct access to WinRT. The C++/CX
    extensions that we'll see in more detail in the next chapter make developing with
    C++ almost as easy as with higher-level environments, while leveraging the powerful
    capabilities of existing C++ libraries and the C++ language.
  prefs: []
  type: TYPE_NORMAL
