- en: Ticket Management – Advanced CRUD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our application has to meet real-time business cases, such as Ticket management.
    This chapter will review most of the topics covered in the book's previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will create a real-time scenario and implement the business
    requirements for our scenario—Ticket management by the user, **customer service
    representative** (**CSR**), and admin.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our final chapter includes the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a ticket by customer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating the ticket by customer, CSR, and admin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deleting the ticket by customer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CSR/admin deletes multiple tickets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ticket management using CRUD operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before moving on to the Ticket Management System, we will cover business requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Let's say we have a banking web application that can be used by our customers,
    Peter and Kevin, and we have Sammy, our admin, and Chloe, the CSR, to help in
    case of any application issues.
  prefs: []
  type: TYPE_NORMAL
- en: Peter and Kevin are facing some problems in the payment process. When they try
    to click on the payment transaction submit button, it's not working. Also, the
    transaction view is in a web page. So our users (Peter and Kevin) will create
    a ticket to share their problem.
  prefs: []
  type: TYPE_NORMAL
- en: Once the ticket is created, it can be updated by customer/CSR/admin. Also, a
    customer can delete their own ticket. While updating, anyone can change the severity;
    however, only CSR and admin can change the status, as the ticket's status is related
    to official activities.
  prefs: []
  type: TYPE_NORMAL
- en: Customers can view their tickets in total or as a single ticket, but they can
    delete only one ticket at a time. The Multi-delete option is available for both
    CSR and admin. However, CSR can only delete three tickets at once. Admin will
    have full control in the Ticket management application and can delete any number
    of tickets at any time.
  prefs: []
  type: TYPE_NORMAL
- en: Registration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start our coding to fulfill the preceding requirements. At first, we need
    to start with customer, CSR, and admin registration. As these users have different
    roles, we will give different user types for each user.
  prefs: []
  type: TYPE_NORMAL
- en: User types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To differentiate users, we came up with three different user types so their
    authorization will be varied when they access our REST APIs. Here are the three
    different user types:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name** | **User type** |'
  prefs: []
  type: TYPE_TB
- en: '| General user/customer | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| CSR | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| Admin | 3 |'
  prefs: []
  type: TYPE_TB
- en: User POJO
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In our previous `User` class, we only had the `userid` and `username`. We may
    need two more variables to fulfill the business requirements we mentioned earlier.
    We will add `password` and `usertype` to our existing `User` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have just added `password` and `usertype`. Also, we
    have added getter and setter methods for our variables.
  prefs: []
  type: TYPE_NORMAL
- en: You can view the full `User` class on our GitHub repository ([https://github.com/PacktPublishing/Building-RESTful-Web-Services-with-Spring-5-Second-Edition](https://github.com/PacktPublishing/Building-RESTful-Web-Services-with-Spring-5-Second-Edition)).
  prefs: []
  type: TYPE_NORMAL
- en: You may be tired of adding getter and setter methods, so we will replace them
    with Lombok library, which we will discuss later in this chapter. However, Lombok
    library has some conflict issues with Eclipse or STS IDE, which you might need
    to be aware of. In certain versions of these IDEs, you won't get expected behavior
    on class creation because of Lombok library issues. Also, some developers mentioned
    that they have deployment issues with Lombok.
  prefs: []
  type: TYPE_NORMAL
- en: In order to automatically generate user ID from our `User` class, we will use
    a separate counter. We will keep a static variable to do that; it's not recommended
    in real application to keep a static counter. To simplify our implementation logic,
    we have used the static counter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code will be added to our `User` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We have started with `100` users. Whenever a new user is added, it will automatically
    increment the `userid` and assign it to the new user.
  prefs: []
  type: TYPE_NORMAL
- en: There is no restriction on the `userCounter` starting point. By keeping user
    series in `2` (2XX) and ticket in series `3` (3XX), it's easier for the reader
    to differentiate user and ticket.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we will create a new constructor to add the user to our application. Also,
    we shall increment the `usercounter` parameter and assign it as `userid` for each
    new user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The preceding constructor will fill all user details, including the `userid`
    (from `usercounter`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we will add a new user with `username`, `password`, and `usertype` in
    the `UserServiceImpl` class; `usertype` will vary for each user (for example,
    `usertype` for admin is `3`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have created a new user and added it to the existing
    user list.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding code, we didn't mention the abstract method in `UserService`.
    It is assumed that every concrete method will have an abstract method in the interface.
    Hereafter, consider adding all abstract methods in appropriate interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Customer registration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now it is time to add a customer. A new customer will have to create an account
    by adding a username and password details.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will talk about the customer registration API. This API will help any new
    customer to register their account with us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have added an API to register a customer. Whoever
    is calling this API will be considered a customer (not admin/CSR). As you can
    see, we have mentioned `1` as the `usertype`, so it will be considered a customer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the screenshot of SoapUI for customer registration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d9eac2ba-9b15-4ae9-a9ac-a42f13ec356d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Also, in the preceding code, we have used `getSuccessResult` from our `Util`
    class. We will see other `Util` methods, shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we created a `Util` class to keep generic methods that
    will be used in different controllers, such as `Ticket` and `User`. These `Util`
    methods are used to avoid code duplication in our application.
  prefs: []
  type: TYPE_NORMAL
- en: To simplify the flow, we haven't used any exception-handling mechanism in this
    code. You may need to implement the methods with proper exception handling-techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Admin registration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every application will have an admin to control all actions, such as deleting
    the customer and changing status. Here, we will talk about the admin registration
    API.
  prefs: []
  type: TYPE_NORMAL
- en: 'The admin registration API will also use the `createUser` method to create
    admin. Here''s the code for admin registration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have added code for admin registration while mentioning
    `3` (user type for admin) in the `createUser` constructor call. Also, you can
    see that we use the `POST` method for registration.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the screenshot for the `http://localhost:8080/user/register/admin`
    admin registration SoapUI API call:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0a8e6410-d5aa-4212-80d6-72cc3fda461c.png)'
  prefs: []
  type: TYPE_IMG
- en: In our Ticket management, we didn't have any restrictions on duplicating the
    user, which means we can have many users with the same name. We recommend that
    you avoid duplicating them, as this will disrupt the flow. To simplify our implementation
    as much as possible, we have ignored such restrictions. However, you can implement
    the restriction to improve the application.
  prefs: []
  type: TYPE_NORMAL
- en: CSR registration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will talk about CSR registration.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is only one difference in customer registration—`usertype`. Other than
    `usertype` and API path, nothing is different from the other registration calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'As we did with the other APIs, we have used `2` (user type for CSR) to register
    a CSR. Let''s see the API call in SoapUI, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/723a18ce-d4aa-4368-a785-d3f29bab0331.png)'
  prefs: []
  type: TYPE_IMG
- en: Login and token management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last section, we have covered user registration topics, such as customer,
    admin, and CSR. Once the user is successfully registered, they will have to log
    in to perform an action. So, let's create login- and session-related API and business
    implementations.
  prefs: []
  type: TYPE_NORMAL
- en: Before moving to login and session, we will talk about JSON Web Token, which
    will be used for session authentication. As we already have the `createToken`
    method in our `securityService` class, we will only talk about the `subject` used
    in token generation.
  prefs: []
  type: TYPE_NORMAL
- en: Generating a token
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We may need to use the JSON Web Token for session purposes. We will use our
    existing token generation method to keep our user details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We have used `user.getUserid()+"="+user.getUsertype()` as a subject. Also, we
    have mentioned `15` minutes as an expiry time, so the token will be valid for
    only `15` minutes.
  prefs: []
  type: TYPE_NORMAL
- en: Customer login
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create a login API for customers. The customer has to provide the username
    and password details as parameters. In a real application, these details might
    come from an HTML form as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have called the `getUser` method from `userService`
    by passing all the necessary parameters. As the user type is `1`, we have passed
    `1` in our method. Once we get the user, we have checked whether it's null or
    not. If null, we will simply throw the error. If the user is not null, we create
    a token subject (`user.getUserid()+"="+user.getUsertype()`) and create a token
    with `15` minutes expiry time, as we mentioned earlier.
  prefs: []
  type: TYPE_NORMAL
- en: If everything goes as we expected, we will create a result map and return the
    map as an API response. This map will be shown as a JSON response in our result
    when we call this API.
  prefs: []
  type: TYPE_NORMAL
- en: Also, in the preceding code, we have used `getUserNotAvailableError` to return
    error details. As we will be using this error in all session-related APIs, we
    have created a separate method to avoid code duplication.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we can see the customer login SoapUI screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a56d9b3e-92e6-4a2e-bfb3-6f202490f25b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In case of a successful user login, we will get a token in the response JSON.
    We will have to use the token for session-related APIs, such as add ticket.A sample
    token is given here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiIxMDM9MSIsImV4cCI6MTUxNTg5MDMzN30.v9wtiG-fNWlpjgJmou7w2oxA9XjXywsH32cDZ-P4zM4`'
  prefs: []
  type: TYPE_NORMAL
- en: In some methods, we may see the `<T> T` return type that is a part of Java generics.
    By keeping such generics, we can return any object by casting it properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a sample:'
  prefs: []
  type: TYPE_NORMAL
- en: The `return (T) map;` return type
  prefs: []
  type: TYPE_NORMAL
- en: Admin login
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have seen the customer login section, we will also have a login API for
    admin.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we will create an API for admin login and generate a token after successful
    authentication:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The preceding login API will be used only for admin purposes. We have used `usertype`
    as `3` to create an admin user. Also, we have used the `Util` method `getUserNotAvailableError`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the SoapUI screenshot for the admin login:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4d2b4240-5fc3-436e-a1b9-1aabac37f114.png)'
  prefs: []
  type: TYPE_IMG
- en: CSR login
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will talk about CSR login and token generation for CSR
    in `TicketController`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As usual, we will get the user from our list and check for null. If the user
    is not available, we will throw an error, otherwise the code will fall through.
    As we did with other user types, we will create a separate API for CSR and pass
    `usertype` as `1` to create a CSR.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see the CSR login API in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e554a0dc-aad3-4f8e-aa6c-2131061e3374.png)'
  prefs: []
  type: TYPE_IMG
- en: Ticket management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to create a ticket, we need to create a `Ticket` class and store the
    tickets in the list. We will talk more about the `Ticket` class, ticket list,
    and other ticket-related work, such as user Ticket management, admin Ticket management,
    and CSR Ticket management.
  prefs: []
  type: TYPE_NORMAL
- en: Ticket POJO
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will create a `Ticket` class with some basic variables involved to store
    all details related to ticket. The following code will help us understand the
    `Ticket` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code will store ticket details such as `ticketid`, `creatorid`,
    `createdat`, `content`, `severity`, and `status`. Also, we have used a static
    counter called `ticketCounter` to increment the `ticketid` upon ticket creation.
    By default, it will start with `300`.
  prefs: []
  type: TYPE_NORMAL
- en: Also, we have used a constructor and the `toString` method, as we will be using
    them in our implementation.
  prefs: []
  type: TYPE_NORMAL
- en: We will have to create the `TicketService` interface (for abstract methods)
    and the `TicketServiceImpl` concrete class for all ticket-related business logic
    implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code will show how to add a ticket:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Getting a user by token
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For all ticket-related operations, we need the user session. In the login method,
    we got the token after successful logging in. We can use the token to get the
    user details. If the token is not available, not matched, or expired, we won't
    be able to get the user details.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we will implement the method to get the user details from the token:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have used the token to get the user details. We are
    using JWT parser to get the claim first, and then we will get the subject. If
    you remember, we have used `user.getUserid()+"="+user.getUsertype()` as a subject
    when we created a token for all user login options. So the subject will be in
    the same format, for example, `101` (user ID)=`1` (user type) for a customer,
    as the customer's user type is `1`.
  prefs: []
  type: TYPE_NORMAL
- en: Also, we do check whether the subject is valid or not with `subject.split("=").length
    != 2`. In case we use a different token, it will simply return null.
  prefs: []
  type: TYPE_NORMAL
- en: Once we get the proper subject, we will get the `userid` and `usertype`, and
    then we will return the user by creating a `User` object.
  prefs: []
  type: TYPE_NORMAL
- en: Because `getUserByToken` is common for all users, it will be used for all of
    our user retrieval methods.
  prefs: []
  type: TYPE_NORMAL
- en: User Ticket management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First of all, to simplify our business requirements, we keep the rule that only
    customers can create a ticket. Neither admin nor CSR can create a ticket. In real-time
    situations, you may have different approaches to Ticket management. However, we
    will keep the business requirements as simple as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Ticket controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here, we will discuss creating a ticket by a customer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: When the user submits a ticket, they will send only the details about what problem
    they face in the application. We have provided the content variable for such details.
    Also, we get the user details from the token they pass in the header.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see the success response in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b5e4bc53-015e-4f74-8bdd-5814b033e219.png)'
  prefs: []
  type: TYPE_IMG
- en: In the previous API, we have used the `@UserTokenRequired` annotation to validate
    the user token. We will check the details of annotation and implementation here.
  prefs: []
  type: TYPE_NORMAL
- en: The UserTokenRequired interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here, we will introduce the `UserTokenRequired` interface and follow up with
    validation logic in the next section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The UserTokenRequiredAspect class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This class will check the user token for user ID and user type validation after
    decrypting it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding `UserTokenRequiredAspect` class, we have just got the token
    from the header and verified whether the token is valid or not. If the token is
    invalid, we will throw an exception.
  prefs: []
  type: TYPE_NORMAL
- en: If the user is null (perhaps there is a wrong or empty token), it will return
    `"User Not Available"` in the response. Once the necessary token is provided,
    we will add the ticket by calling the `addTicket` method in `TicketServiceImpl`,
    which we mentioned earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Severity levels are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Minor: Level 1'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Normal: Level 2'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Major: Level 3'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Critical: Level 4'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Level 1 is considered low, and level 4 is considered high, as seen here
  prefs: []
  type: TYPE_NORMAL
- en: '`@SuppressWarnings ("unchecked")`. In some places, we might have used the `@SuppressWarnings`
    annotation where we need to tell the compiler that it doesn''t need to worry about
    proper casting, as it will be taken care of.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If the user passes the wrong `JWT` in any session-related APIs, we will get
    the error, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The preceding error simply mentions that the `JWT` string is empty or null.
  prefs: []
  type: TYPE_NORMAL
- en: Getting my tickets – customer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once the ticket is created, the customer can see their tickets by calling the
    `/my/tickets` API. The following method will handle the get ticket requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we have validated the user session by token and got
    the tickets for the user available in the session:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/be7771c2-6b32-4669-9f88-738774ebb075.png)'
  prefs: []
  type: TYPE_IMG
- en: Allowing a user to view their single ticket
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Like viewing all customer tickets, customers also can view each of their own
    ticket details by calling the `/{ticketid}` API. Let''s see how his method works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding API, after validating the session, we have used the `getTicket`
    method in `TicketServiceImpl` to get the user ticket details.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can verify the result with the help of this screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/27a05da9-9e44-4918-8d49-0d71298d7545.png)'
  prefs: []
  type: TYPE_IMG
- en: You can clearly see that the token is used in our header. Without the token,
    the API will throw an exception, as it is a session-related transaction.
  prefs: []
  type: TYPE_NORMAL
- en: Allowing a customer to update a ticket
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's assume that the customer wants to update their own ticket for some reason,
    such as adding extra information. We will be given an option for the customer
    to update the ticket.
  prefs: []
  type: TYPE_NORMAL
- en: Updating a ticket – service (TicketServiceImpl)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For the updating option, we will add the `updateTicket` method to our `TicketServiceImpl`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding method, we retrieved the ticket by the `getTicket` method and
    then updated the necessary information such as `content`, `severity`, and `status`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can use the `updateTicket` method in our API, which is mentioned here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, after validating the session, we called `updateTicket`
    and passed the new content. Also, upon successful completion, we sent the proper
    response to the caller.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/39034ed5-a27c-4b1e-9233-bc2a16b5905f.png)'
  prefs: []
  type: TYPE_IMG
- en: For the updating option, we have used the `PUT` method, as it is the appropriate
    HTTP method for updating purposes. However, we can also use the `POST` method
    for such operations, as there is no restriction on it.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting a ticket
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have covered the create, read, and update actions of a ticket. In
    this section, we will talk about the delete option for the customer.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting a service – service (TicketServiceImpl)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will add the `deleteMyTicket` method in our `TicketServiceImpl` class, assuming
    that we have already added the abstract method to our interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have used the `removeIf` Java Streams option to find
    and remove the item from the stream. If the userid and ticket is matched, the
    item will automatically be removed from the stream.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting my ticket – API (ticket controller)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can call the `deleteMyTicket` method that we created earlier in our API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: As usual, we will check the session and call the `deleteTicketByUser` method
    in our `TicketServiceImpl` class. Once the delete option is finished, we will
    simply return the map that says `"success"` as a result.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the SoapUI response after deleting the ticket:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4e8498ff-5291-4cb1-9108-c9405564da10.png)'
  prefs: []
  type: TYPE_IMG
- en: In our ticket CRUD, we don't have an option to throw an exception when it is
    empty. If you delete all of your existing tickets and call get tickets, you will
    get a success message with empty values. You can improve the application by adding
    an empty check and restrictions.
  prefs: []
  type: TYPE_NORMAL
- en: Admin Ticket management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we saw Ticket management by the customer. The customer
    has control over their tickets alone and can't do anything with other customers'
    tickets. In the admin mode, we can have control over any tickets available in
    the application. In this section, we'll see Ticket management done by admin.
  prefs: []
  type: TYPE_NORMAL
- en: Allowing a admin to view all tickets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As admin has full control to view all tickets in the application, we keep the
    view ticket method very simple in `TicketServiceImpl` class without any restrictions.
  prefs: []
  type: TYPE_NORMAL
- en: Getting all tickets – service (TicketServiceImpl)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here we will discuss about the admin implementation part to get all the tickets
    in the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we don't have any specific restrictions and simply return
    all tickets from our ticket list.
  prefs: []
  type: TYPE_NORMAL
- en: Getting all tickets – API (ticket controller)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the ticket controller API, we will add a method to get all the tickets for
    admin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The preceding API, `/by/admin` will be called when the admin needs to view all
    tickets. We have called the `getAllTickets` method in our `TicketServiceImpl`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: We have used a simple AOP for validating the admin token called `@AdminTokenRequired`.
    Let's see the implementation part of this API.
  prefs: []
  type: TYPE_NORMAL
- en: The AdminTokenRequired interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `AdminTokenRequired` interface will be the base for our implementation,
    which we will cover later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we introduced the interface for validating an admin token.
    The validation method will follow up in the `AdminTokenRequiredAspect` class.
  prefs: []
  type: TYPE_NORMAL
- en: The AdminTokenRequiredAspect class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the aspect class, we will do the validation of an admin token:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have provided the token validation technique in the
    `AdminTokenRequiredAspect` class. This aspect component will be executed before
    the method execution. Also, in this method, we checked the token for empty and
    null as well as the user type of the token.
  prefs: []
  type: TYPE_NORMAL
- en: 'Check the SoapUI response for tickets view by admin:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/109ba20b-8859-4994-aed3-afbe8e2d7345.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If we use the wrong token or an empty token, we will get a response like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: By keeping an AOP annotation, we can have a few lines on each method, as the
    annotation will take care of the business logic.
  prefs: []
  type: TYPE_NORMAL
- en: Admin updates a ticket
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once the ticket is created, it can be viewed by the admin. Unlike a customer,
    admin has more control to update the ticket status and severity in addition to
    its content.
  prefs: []
  type: TYPE_NORMAL
- en: Updating a ticket by admin – service (TicketServiceImpl)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here we will implement the method for ticket update by admin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have used the `/by/admin` path in our API to differentiate
    this API from the customer's update method. Also, we get severity and status parameters
    from the request. Once the admin is validated by token, we will call the `updateTicket`
    method. If you see this `updateTicket` method, we haven't hard-coded anything.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the update process is done, we return the result `"success"` as a response,
    which you can check in the screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8a05a3ad-c4d4-4523-9e51-e1bcea63a61e.png)'
  prefs: []
  type: TYPE_IMG
- en: In real applications, admin might not have control over customers' content,
    such as problems. However, we have provided an option for admin to edit the content
    to make our business logic easy.
  prefs: []
  type: TYPE_NORMAL
- en: Allowing admin to view a single ticket
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As admin has full control of a ticket, they can also view any single ticket
    created by users. As we have already defined the `getTicket` API `/{ticketid}`,
    we can use the same API for admin viewing purposes as well.
  prefs: []
  type: TYPE_NORMAL
- en: Allowing admin to delete tickets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As admin has more control, we have given an unlimited multi-delete option for
    admin to delete in the application. This will be very handy when admin needs to
    delete a bunch of tickets in one shot.
  prefs: []
  type: TYPE_NORMAL
- en: 'Deleting tickets – service (TicketServiceImpl):'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the following code we will talk about multiple ticket delete option by admin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have given admin the power to delete multiple tickets.
    As admin has full control, there are no specific filters we applied here. We use
    Java Streams to get tickets as list and then match them with ticket ID to delete
    from the ticket list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Deleting tickets by admin – API (ticket controller):'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following method will forward the `ticketids` to the corresponding `TicketServiceImpl`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we first check the session by `@AdminTokenRequired` and
    then delete the ticket once the session is validated.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can check the API result with this SoapUI screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/94842506-c2a9-45ff-b19e-d6d2f8a9c111.png)'
  prefs: []
  type: TYPE_IMG
- en: In the multiple-ticket-delete option, we have used comma separated values to
    send multiple ticket IDs. A single `ticketid` also can be used to call this API.
  prefs: []
  type: TYPE_NORMAL
- en: CSR Ticket management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Finally, we will talk about CSR Ticket management in this section. CSR may not
    have controls like admin; however, in most cases, they have an option to match
    admin in Ticket management application. In the following section, we will talk
    about all CSR authorized CRUD operations on a ticket.
  prefs: []
  type: TYPE_NORMAL
- en: CSR updates a ticket
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will talk about updating a ticket by CSR with new content,
    severity, and status in Ticket management:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we get all the necessary information, such as content,
    severity, and status, and supply this information to the `updateTicket` method.
  prefs: []
  type: TYPE_NORMAL
- en: We have used a simple AOP for validating the admin token called `@CSRTokenRequired`.
    Let's look at the implementation part of this API.
  prefs: []
  type: TYPE_NORMAL
- en: CSRTokenRequired AOP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `AdminTokenRequired` interface will be the base for our implementation
    that we will go through later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we introduced the annotation for validating admin token.
    The validation method will follow up in the `CSRTokenRequiredAspect` class.
  prefs: []
  type: TYPE_NORMAL
- en: CSRTokenRequiredAspect
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the `CSRTokenRequiredAspect` class, we will do the validation of admin token:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have provided the token validation technique in our
    `CSRTokenRequiredAspect` class. This aspect component will be executed before
    the method execution. Also, in this method, we check the token for empty and null
    as well as the user type of the token.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the screenshot of our `/ticket/{ticketid}` update API:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7d526f83-2b48-42f1-aebc-c85ce3062793.png)'
  prefs: []
  type: TYPE_IMG
- en: CSR view all tickets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In terms of viewing all tickets, CSR has the same rights as admin, so we don't
    need to change the service implementation. However, we may need to validate the
    token to ensure that the user is CSR.
  prefs: []
  type: TYPE_NORMAL
- en: Viewing all tickets by CSR – API (ticket controller)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following will get all the tickets for CSR when it''s called by any CSR:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding API, we have used only `@CSRTokenRequired` to validate the
    user. Everything other than the API path and annotation is the same, as admin
    views all the tickets.
  prefs: []
  type: TYPE_NORMAL
- en: When we check the screenshot of SoapUI, we can clearly see two tickets created
    by customers.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/01b56fe6-7f3e-41e3-b07f-dd8c79d62dba.png)'
  prefs: []
  type: TYPE_IMG
- en: CSR view single ticket
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Other than the multi-delete option, CSR has equal rights as admin, we can use
    the same `/{ticketid}`, which we used for both CSR and admin view single ticket
    API here.
  prefs: []
  type: TYPE_NORMAL
- en: CSR delete tickets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Deleting tickets by CSR is almost like deleting tickets in admin mode. However,
    our business requirements say that CSR should not be able to delete more than
    three tickets at a time. We will add the specific logic to our existing method.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting tickets – service (TicketServivceImpl)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here comes the service implementation for deleting multiple tickets by CSR:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: For deleting multi-tickets, we have used the existing code in the `TicketServiceImpl`
    class. However, as per our business requirements, our CSR can't delete more than
    three tickets, so we have added extra logic to check the ticket size. If the ticket
    list size is more than three, we throw an exception, otherwise we will remove
    those tickets.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting tickets by CSR – API (ticket controller)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the API, we will simply call the `deleteTickets` method that we implemented
    earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Other than the max ticket restriction on the delete option, there is no big
    change needed for CSR to delete tickets. However, we have added the `@CSRTokenRequired`
    annotation used in our API.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the screenshot of SoapUI for CSR deletes multiple tickets:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5eb0c235-4419-4280-a7d1-d41b61629899.png)'
  prefs: []
  type: TYPE_IMG
- en: The Postman tool may have an issue with the `DELETE` option, including parameters
    (as of version 5.4.0), you may not get the expected results when you use multiple-delete
    API in both admin and CSR. For such scenarios, please use SoapUI client.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this final chapter, we have implemented a small Ticket Management System
    by meeting all the business requirements that we mentioned in the first section
    of this chapter. This implementation covers ticket CRUD operations by customer,
    CSR, and admin. Also, our implementation met the business requirements, such as
    why CSR can't delete more than three tickets at a time.
  prefs: []
  type: TYPE_NORMAL
