- en: Understanding the Core Components of a Kubernetes Cluster
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will be going through a 10,000-foot view of the main Kubernetes
    components, from what each controller is composed of to how a container in a pod
    is deployed and scheduled across each of the workers. It is crucial to understand
    the ins and outs of the Kubernetes cluster in order to be able to deploy and design
    a solution based on Kubernetes as an orchestrator for your containerized applications:'
  prefs: []
  type: TYPE_NORMAL
- en: Control plane components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Kubernetes workers' components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pods as basic building blocks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kubernetes services, load balancers, and Ingress controllers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kubernetes deployments and DaemonSets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Persistent storage in Kubernetes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Kubernetes control plane
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Kubernetes master nodes are where the core control plane services live;
    not all services have to reside on the same node; however, for centralization
    and practicality, they are often deployed this way. This obviously raises services
    availability questions; however, they can easily be overcome by having several
    nodes and providing load balancing requests to achieve a highly available set
    of **master nodes**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The master nodes are composed of four basic services:'
  prefs: []
  type: TYPE_NORMAL
- en: The kube-apiserver
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The kube-scheduler
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The kube-controller-manager
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The etcd database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Master nodes can either run on bare metal servers, virtual machines, or a private
    or public cloud, but it is not recommended to run container workloads on them.
    We will see more on this later.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the Kubernetes master nodes components:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7e921f9a-af2e-4baf-932e-7c58ac02a1ab.png)'
  prefs: []
  type: TYPE_IMG
- en: The kube-apiserver
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The API server is what ties everything together. It is the frontend REST API
    of the cluster that receives manifests to create, update, and delete API objects
    such as services, pods, Ingress, and others.
  prefs: []
  type: TYPE_NORMAL
- en: The **kube-apiserver** is the only service that we should be talking to; it
    is also the only one that writes and talks to the `etcd` database for registering
    the cluster state. With the `kubectl` command, we will send commands to interact
    with it. This will be our Swiss Army knife when it comes to Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: The kube-controller-manager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The **kube-controller-manager** daemon, in a nutshell, is a set of infinite
    control loops that is shipped for simplicity in a single binary. It watches for
    the defined desired state of the cluster and it makes sure that it is accomplished
    and satisfied by moving all the bits and pieces necessary to achieve it. The kube-controller-manager
    is not just one controller; it contains several different loops that watch different
    components in the cluster. Some of them are the service controller, the namespace
    controller, the service account controller, and many others. You can find each
    controller and its definition in the Kubernetes GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/kubernetes/kubernetes/tree/master/pkg/controller](https://github.com/kubernetes/kubernetes/tree/master/pkg/controller).'
  prefs: []
  type: TYPE_NORMAL
- en: The kube-scheduler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The **kube-scheduler** schedules your newly created pods to nodes with enough
    space to satisfy the pods'' resource needs. It basically listens to the kube-apiserver
    and the kube-controller-manager for newly created pods that are put into a queue
    and then scheduled to an available node by the scheduler. The kube-scheduler definition
    can be found here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/kubernetes/kubernetes/blob/master/pkg/scheduler](https://github.com/kubernetes/kubernetes/blob/master/pkg/scheduler/scheduler.go).'
  prefs: []
  type: TYPE_NORMAL
- en: Besides compute resources, the kube-scheduler also reads the nodes' affinity
    and anti-affinity rules to find out whether a node can or cannot run that pod.
  prefs: []
  type: TYPE_NORMAL
- en: The etcd database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **etcd** **database** is a very reliable consistent key-value store that's
    used to store the state of the Kubernetes cluster. It contains the current status
    of the pods in which the node is running on, how many nodes the cluster currently
    has, what the state of those nodes is, how many replicas of a deployment are running,
    services names, and others.
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned before, only the kube-apiserver talks to the `etcd` database.
    If the kube-controller-manager needs to check the state of the cluster, it will
    go through the API server in order to get the state from the `etcd` database,
    instead of querying the `etcd` store directly. The same happens with the kube-scheduler,
    if the scheduler needs to make it known that a pod has been stopped or allocated
    to another node; it will inform the API server, and the API server will store
    the current state in the etcd database.
  prefs: []
  type: TYPE_NORMAL
- en: With etcd, we have covered all the main components for our Kubernetes master
    nodes so that we are ready to manage our cluster. But a cluster is not only composed
    of masters; we still require the nodes that will be performing the heavy lifting
    by running our applications.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes worker nodes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The worker nodes that do this task in Kubernetes are simply called nodes. Previously,
    around 2014, they were called **minions**, but this term was later replaced with
    just nodes, as the name was confusing with Salt's terminologies and made people
    think that Salt was playing a major role in Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: These nodes are the only place that you will be running workloads, as it is
    not recommended to have containers or loads on the master nodes, as they need
    to be available to manage the entire cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'The nodes are very simple in terms of components; they only require three services
    to fulfill their task:'
  prefs: []
  type: TYPE_NORMAL
- en: Kubelet
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kube-proxy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Container runtime
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's explore these three components in a little bit more depth.
  prefs: []
  type: TYPE_NORMAL
- en: Container runtime
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To be able to spin up containers, we require a **container runtime**. This is
    the base engine that will create the containers in the nodes kernel for our pods
    to run. The kubelet will be talking to this runtime and will spin up or stop our
    containers on demand.
  prefs: []
  type: TYPE_NORMAL
- en: Currently, Kubernetes supports any OCI-compliant container runtime, such as
    Docker, `rkt`, `runc`, `runsc`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: You can learn more about all the specifications from the OCI GitHub page: [https://github.com/opencontainers/runtime-spec](https://github.com/opencontainers/runtime-spec).
  prefs: []
  type: TYPE_NORMAL
- en: The kubelet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **kubelet** is a low-level Kubernetes component and one of the most important
    ones after the kube-apiserver; both of these components are essential for the
    provisioning of pods/containers in the cluster. The kubelet is a service that
    runs on the Kubernetes nodes and listens to the API server for pod creation. The
    kubelet is only in charge of starting/stopping and making sure that containers
    in pods are healthy; the kubelet will not be able to manage any containers that
    were not created by it.
  prefs: []
  type: TYPE_NORMAL
- en: The kubelet achieves the goals by talking to the container runtime via something
    called the **container runtime interface** (**CRI**). The CRI provides pluggability
    to the kubelet via a gRPC client, which is able to talk to different container
    runtimes. As we mentioned earlier, Kubernetes supports multiple container runtimes
    to deploy containers, and this is how it achieves such diverse support for different
    engines.
  prefs: []
  type: TYPE_NORMAL
- en: You can check the kubelet's source code via the following GitHub link: [https://github.com/kubernetes/kubernetes/tree/master/pkg/kubelet](https://github.com/kubernetes/kubernetes/tree/master/pkg/kubelet).
  prefs: []
  type: TYPE_NORMAL
- en: The kube-proxy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **kube-proxy** is a service that resides on each node of the cluster, and
    is the one that makes communications between pods, containers, and nodes possible.
    This service watches the kube-apiserver for changes on defined services (a service
    is a sort of logical load balancer in Kubernetes; we will dive deeper into services
    later on in this chapter) and keeps the network up to date via `iptables` rules
    that forward traffic to the correct endpoints. Kube-proxy also sets up rules in
    `iptables` that do random load balancing across pods behind a service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of an `iptables` rule that was made by the kube-proxy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This is a service with no endpoints (no pods behind it).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have gone through all the core components that form a cluster, we
    can talk about what we can do with them and how Kubernetes is going to help us
    orchestrate and manage our containerized applications.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Kubernetes** **objects** are exactly that: they are logical persistent objects
    or abstractions that will represent the state of your cluster. You are the one
    in charge of telling Kubernetes what your desired state of that object is so that
    it can work to maintain it and make sure that the object exists.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To create an object, there are two things that it needs to have: a status and
    its spec. The status is provided by Kubernetes, and it is the current state of
    the object. Kubernetes will manage and update that status as needed to be in accordance
    to your desired state. The `spec` field, on the other hand, is what you provide
    to Kubernetes, and is what you tell it to describe the object you desire, for
    example, the image that you want the container to be running, the number of containers
    of that image that you want to run, and so on. Each object has specific `spec`
    fields for the type of task that they perform, and you will be providing these
    specifications on a YAML file that is sent to the kube-apiserver with `kubectl`,
    which that transforms it into JSON and sends it as an API request. We will dive
    deeper into each object and its spec fields later in this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of a YAML that was sent to `kubectl`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The basic fields of the object definition are the very first ones, and these
    ones will not vary from object to object and are very self-explanatory. Let''s
    take a quick look at them:'
  prefs: []
  type: TYPE_NORMAL
- en: '`kind`: The `kind` field tells Kubernetes what type of object you are defining:
    a pod, a service, a deployment, and so on'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`apiVersion`: Because Kubernetes supports multiple API versions, we need to
    specify a REST API path that we want to send our definition to'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`metadata`: This is a nested field, which means that you have several more
    subfields to metadata, where you will write basic definitions such as the name
    of your object, assigning it to a specific namespace, and also tag a label to
    it to relate your object to other Kubernetes objects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, we have now been through the most-used fields and their contents; you can
    learn more about the Kuberntes API conventions at the following GitHub page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md](https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md).'
  prefs: []
  type: TYPE_NORMAL
- en: Some of the fields of the object can later be modified after the object has
    been created, but that will depend on the object and the field that you want to
    modify.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a short list of the various Kubernetes objects that you can
    create:'
  prefs: []
  type: TYPE_NORMAL
- en: Pod
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Volume
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deployment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ingress
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Secret
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ConfigMap
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And there are many more.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a closer look at each one of these items.
  prefs: []
  type: TYPE_NORMAL
- en: Pods – the basis of Kubernetes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pods are the most basic objects in Kubernetes and also the most important ones.
    Everything revolves around them; we can say that Kubernetes is for the pods! All
    of the other objects are here to serve them, and all the tasks that they do are
    to make the pods achieve your desired state.
  prefs: []
  type: TYPE_NORMAL
- en: So, what is a pod and why are pods so important?
  prefs: []
  type: TYPE_NORMAL
- en: A pod is a logical object that runs one or more containers together on the same
    network namespace, the same **inter-process communication** (**IPC**) and, sometimes,
    depending on the version of Kubernetes, the same **process ID** (**PID**) namespace.
    This is because they are the ones that are going to run our containers and hence
    will be the center of attention. The whole point of Kubernetes is to be a container
    orchestrator, and with pods, we make orchestration possible.
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned before, containers on the same pod live in a "bubble" where
    they can talk to one another via localhost, as they are local to one another.
    One container in a pod has the same IP address as the other container because
    they are sharing a network namespace, but in most cases, you will be running on
    a one-on-one basis, that is to say, a single container per pod. Multiple containers
    per pod are only used on very specific scenarios, such as when an application
    requires a helper such as a data pusher or a proxy that needs to communicate in
    a fast and resilient way with the primary application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The way you define a pod is the same way you would do so for any other Kubernetes
    object: via a YAML that contains all the pod specs and definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s go through the basic pod definitions needed under the `spec` field to
    create our pod:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Containers:** Containers is an array; therefore, we have a set of several
    subfields under it. Basically, it''s what defines the containers that are going
    to be running on the pod. We can specify a name for the container, the image that
    is going to be spin-off from, and the arguments or command that we need it to
    run. The difference between arguments and commands is the same as the difference
    between `CMD` and `ENTRYPOINT` that we went through in [Chapter 6](6da53f60-978c-43a4-9dc9-f16b14405709.xhtml), *Creating
    a Highly Available Self-Healing Architecture,* when we talked about creating Docker
    images. Take note that all the fields that we just went through are for the `containers`
    array. They are not directly part of the `spec` of the pod.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**restartPolicy:** This field is exactly that: it tells Kubernetes what to
    do with a container, and it applies to all the containers in the pod in the case
    of a zero or non-zero exit code. You can choose from either option, Never, OnFailure
    or Always. Always will be the default in case a restartPolicy is not defined.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These are the most basic specs that you are going to declare on a pod; other
    specs will require that you have a little bit more background knowledge on how
    to use them and how they interact with various other Kubernetes objects. We will
    revisit them later on this chapter, some of them are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Volume
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Env
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ports
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: dnsPolicy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: initContainers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: nodeSelector
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resource limits and requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To view the pods that are currently running in your cluster, you can run `kubectl
    get pods`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can run `kubectl describe pods` without specifying any pod.
    This will print out a description of every pod running in the cluster. In this
    case, it will be only the `busybox` pod, as it is the only one that''s currently
    running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Pods are mortal, and this is the clue in knowing how to manage your application.
    You have to understand that once a pod dies or is deleted, there is no way to
    bring it back. Its IP and the containers that were running on it will be gone;
    they are totally ephemeral. The data on the pods that is mounted as a volume may
    or may not survive, depending on how you set it up; however, this is a discussion
    that we will have later in this chapter. If our pods die and we lose them, how
    do we ensure that all our microservices are running? Well, deployments are the
    answer.
  prefs: []
  type: TYPE_NORMAL
- en: Deployments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pods by themselves are not very useful, since it is not very efficient to have
    more than a single instance of our application running in a single pod. Provisioning
    hundreds of copies of our application on different pods without having a method
    to look for them all will get out of hand really quickly.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is where deployments come into play. With deployments, we can manage our
    pods with a controller. This allows us to not only decide how many we want to
    run, but we can also manage updates by changing the image version or the image
    itself that our containers are running. Deployments are what you will be working
    with most of the time. With deployments as well as pods and any other objects
    that we mentioned before, they have their own definition inside a YAML file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Let's start exploring their definition.
  prefs: []
  type: TYPE_NORMAL
- en: At the beginning of the YAML, we have more general fields, such as `apiVersion`,
    `kind`, and `metadata`. But under `spec` is where we will find the specific options
    for this API Object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Under `spec`, we can add the following fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Selector**: With the Selector field, the deployment will know which pods
    to target when changes are applied. There are two fields that you will be using
    under the selector: `matchLabels` and `matchExpressions`. With `matchLabels`,
    the selector will use the labels of the pods (key/value pairs). It is important
    to note that all the labels that you specify here will be `ANDed`. This means
    that the pod will require that it has all the labels that you specify under `matchLabels`.
    `matchExpressions` is rarely used, but you can learn more about by reading our
    recommended books in the *Further reading* section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Replicas**: This will state the number of pods that the deployment needs
    to keep running via the replication controller; for example, if you specify three
    replicas, and one of the pods dies, the replication controller will watch the
    replicas spec as the desired state and inform the scheduler to schedule a new
    pod, as the current status is now 2 since the pod died.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**RevisionHistoryLimit**: Every time you make a change to a deployment, this
    change is saved as a revision of the deployment, which you can later either revert
    to that previous state or keep a record of what was changed. You can consult your
    history with `kubectl` rollout history deployment/<name of deployment>. With `revisionHistoryLimit`,
    you can set up a number stating how many records you want to save.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Strategy**: This will let you decide how you want to handle any update or
    horizontal pod scale. To overwrite the default, which is `rollingUpdate`, you
    need to write the `type` key, where you can choose between two values: `recreate`
    or `rollingUpdate`. While `recreate` is a fast way to update your deployment,
    it will delete all the pods and replace them with new ones, but it will imply
    that you will have to take into consideration that a system downtime will be in
    place for this type of strategy. The `rollingUpdate`, on the other hand, is smoother
    and slower, and is ideal for stateful applications that can rebalance their data.
    The `rollingUpdate` opens the door for two more fields, which are `maxSurge` and
    `maxUnavailable`. The first one will be how many pods above your total amount
    you want when performing an update; for example, a deployment with 100 pods and
    a 20% `maxSurge` will grow up to a maximum of 120 pods while updating. The next
    option will let you select how many pods in the percentage you are willing to
    kill in order to replace them with new ones in a 100 pod scenario. In cases where
    there is 20% `maxUnavailable`, only 20 pods will be killed and replaced with new
    ones before continuing to replace the rest of the deployment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Template**: This is just a nested pod spec field where you will include all
    the specs and metadata of the pods that the deployment is going to manage.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have seen that, with deployments, we manage our pods, and they help us maintain
    them in a state that we desire. All these pods are still in something called the
    **cluster network**, which is a closed network in which only the Kubernetes cluster
    components can talk to one another, even having their own set of IP ranges. How
    do we talk to our pods from the outside? How do we reach our application? This
    is where services come into play.
  prefs: []
  type: TYPE_NORMAL
- en: Services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The name *service* doesn't fully describe what services actually do in Kubernetes.
    Kubernetes services are what route traffic to our pods. We can say that services
    are what tie pods together.
  prefs: []
  type: TYPE_NORMAL
- en: Let's imagine that we have a typical frontend/backend type of application where
    we have our frontend pods talking to our backend ones via the IP addresses of
    the pods. If a pod in the backend dies, we know that pods are ephemeral and therefore
    we lose communication with our backend, and so now we are in a world of hurt.
    This is not only because the new pod will not have the same IP address of the
    pod that died, but now we also have to reconfigure our app to use the new IP address.
    This issue and similar issues are solved with services.
  prefs: []
  type: TYPE_NORMAL
- en: A service is a logical object that tells the kube-proxy to create iptables rules
    based on which pods are behind the service. Services configure their endpoints,
    which is how the pods behind a service are called, the same way as deployments
    know which pods to control, the selector field, and the pods' labels.
  prefs: []
  type: TYPE_NORMAL
- en: 'This diagram shows you how services use labels to manage traffic:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1a03e05d-be3b-4a05-a7ff-7808314eb329.png)'
  prefs: []
  type: TYPE_IMG
- en: Services will not only make kube-proxy create rules to route traffic; it will
    also trigger something called **kube-dns**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Kube-dns is a set of pods with `SkyDNS` containers that run on the cluster that
    provides a DNS server and forwarder, which will create records for services and
    sometimes pods for ease of use. Whenever you create a service, a DNS record pointing
    to the service''s internal cluster ipaddress will be created with the form `service-name.namespace.svc.cluster.local`.
    You can learn more about the Kubernetes DNS specifications on the Kubernetes GitHub
    page: [https://github.com/kubernetes/dns/blob/master/docs/specification.md](https://github.com/kubernetes/dns/blob/master/docs/specification.md).'
  prefs: []
  type: TYPE_NORMAL
- en: Going back to our example, we will now only have to configure our application
    to talk to the service **fully qualified domain name** (**FQDN**) in order to
    talk to our backend pods. This way, it will not matter what IP address the pods
    and services have. If a pod behind the service dies, the service will take care
    of everything by using the A record, as we will be able to tell our frontend to
    route all traffic to my-svc. The logic of the service will take care of everything
    else.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several types of service that you can create whenever you are declaring
    the object to be created in Kubernetes. Let''s go through them to see which one
    will be best suited for the type of work we need:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ClusterIP**: This is the default service. Whenever you create a ClusterIP
    service, it will create a service with a cluster-internal IP address that will
    only be routable inside the Kubernetes cluster. This type is ideal for pods that
    only need to talk to one another and not go outside the cluster.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**NodePort**: When you create this type of service, by default a random port
    from `30000` to `32767` will be allocated to forward traffic to the endpoint pods
    of the service. You can override this behavior by specifying a node port in the
    `ports` array. Once this is defined you will be able to access your pods via `<Nodes-IP>`:`<Node-Port>`.
    This is useful to access your pods from outside the cluster via the Node IP address.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**LoadBalancer**: Most of the time, you will be running Kubernetes on a cloud
    provider. The LoadBalancer type is ideal for these situations, as you will be
    able to allocate public IP addresses to your service via your cloud provider''s
    API. This is the ideal service for when you want to communicate with your pods
    from outside your cluster. With LoadBalancer, you will be able to not only allocate
    a publicIP address but also, using Azure, allocate a private IP address from your
    virtual private network. So, you can talk to your pods from the internet or internally
    on your private subnet.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s review YAML''s definition of a service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'A service''s YAML is very simple, and the specs will vary, depending on the
    type of service that you are creating. But the most important thing you have to
    take into account is port definitions. Let''s take a look at these:'
  prefs: []
  type: TYPE_NORMAL
- en: '`port`: This is the service port that is exposed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`targetPort`: This is the port on the pods to where the service is sending
    traffic'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nodePort`: This is the port that will be exposed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although we now understand how we can communicate with the pods in our cluster,
    we still need to understand how we are going to manage the problem of losing our
    data every time a pod is terminated. This is where **Persistent Volumes** (**PV**)
    comes into play.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes and persistent storage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Persistent storage** in the container world is a serious issue. When we studied
    Docker images, we learned that the only storage that is persistent across container
    runs are the layers of the image, and they are read-only. The layer where the
    container runs is read/write, but all data in this layer is deleted when the container
    stops. With pods, this is the same. When a container dies, the data written to
    it is gone.'
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes has a set of objects to handle storage across pods. The first one
    that we will discuss is volumes.
  prefs: []
  type: TYPE_NORMAL
- en: Volumes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Volumes** solve one of the biggest problems when it comes to persistent storage.
    First of all, volumes are not actually objects, but a definition of a pod''s spec.
    When you create a pod, you can define a volume under the pod''s spec field. Containers
    in this pod will be able to mount the volume on their mount namespace, and the
    volume will be available across container restarts or crashes. Volumes are tied
    to the pods, though, and if the pod is deleted, the volume will be gone as well.
    The data on the volume is another story; data persistence will depend on the backend
    of that volume.'
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes supports several types of volumes or volume sources and how they
    are called in the API specifications, which range from filesystem maps from the
    local node, cloud providers' virtual disks, and software-defined storage-backed
    volumes. Local filesystem mounts are the most common ones that you will see when
    it comes to regular volumes. It's important to note that the disadvantage of using
    local node filesystems is that the data will not be available across all the nodes
    of the cluster, and just on that node where the pod was scheduled.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s examine how a pod with a volume is defined in YAML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note how there is a field called `volumes` under `spec` and then there is another
    one called `volumeMounts`.
  prefs: []
  type: TYPE_NORMAL
- en: The first field (`volumes`) is where you define the volume you want to create
    for that pod. This field will always require a name and then a volume source.
    Depending on the source, the requirements will be different. In this example,
    the source would be `hostPath`, which is a node's local filesystem. `hostPath`
    supports several types of mappings, ranging from directories, files, block devices,
    and even Unix sockets.
  prefs: []
  type: TYPE_NORMAL
- en: Under the second field, `volumeMounts`, we have `mountPath,` which is where
    you define the path inside the container where you want to mount your volume to.
    The `name` parameter is how you specify to the pod which volume to use. This is
    important because you can have several types of volumes defined under `volumes`,
    and the name will be the only way for the pod to know which volumes mount to which
    container.
  prefs: []
  type: TYPE_NORMAL
- en: We will not be going through all the different types of volumes because it is
    irrelevant to know about them unless you are going to use a specific one. The
    important part is to know that they exist and what type of sources we can have.
  prefs: []
  type: TYPE_NORMAL
- en: You can learn more about the different types of volumes in the volume definitions
    in the Kubernetes website ([https://kubernetes.io/docs/concepts/storage/volumes/#types-of-volumes](https://kubernetes.io/docs/concepts/storage/volumes/#types-of-volumes))
    and in the Kubernetes API reference document ([https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.11/#volume-v1-core](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.11/#volume-v1-core)).
  prefs: []
  type: TYPE_NORMAL
- en: Having volumes die with the pods is not ideal. We require storage that persists,
    and this is how the need for PVs came to be.
  prefs: []
  type: TYPE_NORMAL
- en: Persistent Volumes, Persistent Volume Claims, and Storage Classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main difference between volumes and PVs is that, unlike volumes, PVs are
    actually Kubernetes API objects, so you can manage them individually like separate
    entities, and therefore they persist even after a pod is deleted.
  prefs: []
  type: TYPE_NORMAL
- en: You might be wondering why this subsection has PV, **persistent volume claims**
    (**PVCs**), and storage classes all mixed in. This is because we can't talk about
    one without talking about the others; all of them depend on one another, and it
    is crucial to understand how they interact among one another to provision storage
    for our pods.
  prefs: []
  type: TYPE_NORMAL
- en: Let's begin with PVs and PVCs. Like volumes, PVs have a storage source, so the
    same mechanism that volumes have applies here. You will either have a software-defined
    storage cluster providing **logical unit number** (**LUNs**), a cloud provider
    giving virtual disks, or even a local filesystem to the Kubernetes node, but here,
    instead of being called volume sources, they are called **persistent volume types **instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'PVs are pretty much like LUNs in a storage array: you create them, but without
    a mapping; they are just a bunch of allocated storage waiting to be used. Here
    is where PVCs come into play. PVCs are like LUN mappings: they are backed or bound
    to a PV and also are what you actually define, relate, and make available to the
    pod that it can then use for its containers.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The way you use PVCs on pods is exactly the same as with normal volumes. You
    have two fields: one to specify which PVC you want to use, and the other one to
    tell the pod on which container to use that PVC.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The YAML for a PVC API object definition should have the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The YAML for `pod` should have the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'When a Kubernetes administrator creates a PVC, there are two ways that this
    request is satisfied:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Static**: Several PVs have already been created, and then when a user creates
    a PVC, any available PV that can satisfy the requirements will be bound to that
    PVC.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dynamic**: Some PV types can create PVs based on PVC definitions. When a
    PVC is created, the PV type will dynamically create a PV object and allocate the
    storage in the backend; this is dynamic provisioning. The catch with dynamic provisioning
    is that you require a third type of Kubernetes storage object, called a **storage
    class**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storage classes are like a way of **tiering** your storage. You can create a
    class that provisions slow storage volumes, or another one with hyper-fast SSD
    drives. However, storage classes are a little bit more complex than just tiering.
    As we mentioned in the two ways of creating a PVC, storage classes are what make
    dynamic provisioning possible. When working on a cloud environment, you don't
    want to be manually creating every backend disk for every PV. Storage classes
    will set up something called a **provisioner**, which invokes the volume plugin
    that's necessary to talk to your cloud provider's API. Every provisioner has its
    own settings so that it can talk to the specified cloud provider or storage provider.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can provision storage classes in the following way; this is an example
    of a storage class using Azure-disk as a disk provisioner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Each storage class provisioner and PV type will have different requirements
    and parameters, as well as volumes, and we have already had a general overview
    of how they work and what we can use them for. Learning about specific storage
    classes and PV types will depend on your environment; you can learn more about
    each one of them by clicking on the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://kubernetes.io/docs/concepts/storage/storage-classes/#provisioner](https://kubernetes.io/docs/concepts/storage/storage-classes/#provisioner)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://kubernetes.io/docs/concepts/storage/persistent-volumes/#types-of-persistent-volumes](https://kubernetes.io/docs/concepts/storage/persistent-volumes/#types-of-persistent-volumes)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about what Kubernetes is, its components, and what
    the advantages of using orchestration are.
  prefs: []
  type: TYPE_NORMAL
- en: You should now be able to identify each of the Kubernetes API objects, their
    purpose, and their use cases. You should be able to understand how the master
    nodes control the cluster and the scheduling of the containers in the worker nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is Kubernetes?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the components of Kubernetes?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are Kubernetes's API objects?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What can we do with Kubernetes?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a container orchestrator?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a pod?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a deployment?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Mastering Kubernetes*, by Packt Publishing: [https://prod.packtpub.com/in/virtualization-and-cloud/mastering-kubernetes](https://prod.packtpub.com/in/virtualization-and-cloud/mastering-kubernetes)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Kubernetes for Developers*, by Packt Publishing: [https://prod.packtpub.com/in/virtualization-and-cloud/kubernetes-developers](https://prod.packtpub.com/in/virtualization-and-cloud/kubernetes-developers)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Getting Started with Kubernetes*, by Packt Publishing: [https://prod.packtpub.com/in/virtualization-and-cloud/getting-started-kubernetes-third-edition](https://prod.packtpub.com/in/virtualization-and-cloud/getting-started-kubernetes-third-edition)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
