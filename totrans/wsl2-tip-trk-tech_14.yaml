- en: '*Chapter 11*: Productivity Tips with Command-Line Tools'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will cover some tips for working with a few different common
    command-line tools. We'll start by looking at ways to boost your productivity
    and improve the experience of working with Git in WSL. Git is used widely, and
    improving your productivity with it gives improvements in any project where you
    use it for source control. After this, we will look at two `az` for Azure and
    `kubectl` for Kubernetes. With each of these CLIs, we will deploy a simple example
    resource and then show some techniques for querying data with them. As is common
    with many CLIs, both `az` and `kubectl` provide an option for getting data in
    `az` or `kubectl`, the techniques covered in these sections may be relevant to
    other CLIs you are using. By learning how to manipulate JSON effectively, you
    open new possibilities for scripting and automation using a wide range of APIs
    and CLIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Working with Git
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with JSON
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with the Azure CLI (`az`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with the Kubernetes CLI (`kubectl`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's kick off by exploring some tips for working with Git.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Git
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Without a doubt, Git is a commonly used source control system. Originally written
    by Linus Torvalds to use for Linux kernel source code, it is now widely used,
    including by companies such as Microsoft, where it is used extensively, including
    for Windows development (see [https://docs.microsoft.com/en-us/azure/devops/learn/devops-at-microsoft/use-git-microsoft](https://docs.microsoft.com/en-us/azure/devops/learn/devops-at-microsoft/use-git-microsoft)
    for more information).
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will look at a few tips for working with Git in WSL. Some
    tips are covered in previous chapters and linked for further information, while
    others are new tips – both are tied together here for handy reference.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by looking at a quick win for most command-line tools: bash completion.'
  prefs: []
  type: TYPE_NORMAL
- en: Bash completion with Git
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When working with many command-line tools, bash completion can save you a lot
    of typing, and `git` is no exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, `git com<TAB>` will produce `git commit`, and `git chec<TAB>`
    will produce `git checkout`. If the partial command you have entered isn''t sufficient
    to specify a single command, then bash completion will appear not to do anything,
    but pressing *Tab* twice will show the options. Take the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Here, we see that `git co` could complete to either `git commit` or `git config`.
  prefs: []
  type: TYPE_NORMAL
- en: Bash completion doesn't just complete command names either; you can use `git
    checkout my<TAB>` to complete the branch name to `git checkout my-branch`.
  prefs: []
  type: TYPE_NORMAL
- en: Once you get used to bash completion, you will find it can be a big productivity
    boost!
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's look at options for authenticating with remote Git repos.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication with Git
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One powerful method of authentication with Git is through the use of **Secure
    Shell** (**SSH**) keys. This method of authentication reuses SSH keys that are
    typically used for making SSH connections to remote machines to authenticate via
    Git and is supported across the major Git source control providers. In [*Chapter
    5*](B16412_05_Final_JC_ePub.xhtml#_idTextAnchor054), *Linux to Windows Interoperability*,
    in the *SSH agent forwarding* section, we saw how to configure WSL to reuse SSH
    keys stored in Windows. If you have set this up, it also enables you to use SSH
    keys with Git in WSL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, if you are doing a mixture of development across Windows and
    WSL and want to share Git authentication between them, then you might want to
    configure Git Credential Manager for Windows for use in WSL. This also supports
    using two-factor authentication with providers such as GitHub or Bitbucket (see
    [https://github.com/Microsoft/Git-Credential-Manager-for-Windows](https://github.com/Microsoft/Git-Credential-Manager-for-Windows)
    for more information). To use this, you must have installed Git in Windows. To
    configure, run the following command from your **distribution** (**distro**):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This command sets the Git configuration to launch Git Credential Manager for
    Windows to handle the authentication with remote repos. Any credentials stored
    from accessing Git remotes via Windows will be reused by WSL (and vice versa).
    See [https://docs.microsoft.com/en-us/windows/wsl/tutorials/wsl-git#git-credential-manager-setup](https://docs.microsoft.com/en-us/windows/wsl/tutorials/wsl-git#git-credential-manager-setup)
    for more details.
  prefs: []
  type: TYPE_NORMAL
- en: With authentication taken care of, let's look at a few options for viewing history
    in Git.
  prefs: []
  type: TYPE_NORMAL
- en: Viewing Git history
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When working with Git in WSL, there are a number of different approaches to
    viewing the history of commits in a Git repo. Here, we will look at the following
    different options:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the `git` CLI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using graphical Git tools from Windows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Visual Studio Code Remote-WSL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The first of these options is to use the `git log` command in the CLI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In the output from `git log`, you can see the result of running the `git log`
    command with a number of additional switches to produce a concise output using
    text art to show branches. This approach can be handy as it can be used directly
    from the command line in WSL and requires nothing installed apart from Git in
    WSL. However, the command can be a bit tedious to type, so you might want to create
    a Git alias, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Here, we use the `git config` command to create an alias called `logtree` for
    the previous Git command. After creating this, we can now run `git logtree` to
    produce the previous output.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have a graphical tool for Windows that you use with Git, you can point
    it to your Git repo in WSL. In [*Chapter 9*](B16412_09_Final_JC_ePub.xhtml#_idTextAnchor111),
    *Visual Studio Code and WSL*, in the *Viewing Git history* section, we looked
    at how to use the `gitk` utility that is included with Git. As an example, we
    can run `gitk.exe --all` from a WSL shell in a Git repo folder to launch the Windows
    `gitk.exe` executable:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.1 – A screenshot showing the gitk utility in Windows showing a
    WSL Git repo'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_11.1_B16412.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.1 – A screenshot showing the gitk utility in Windows showing a WSL
    Git repo
  prefs: []
  type: TYPE_NORMAL
- en: In this screenshot, we can see the `gitk` utility running in Windows and showing
    the same Git repo we saw previously with `git log`. Because we launched it from
    a shell in WSL, it picked up the `\\wsl$` share that is used to access the shell's
    current folder in WSL from Windows (see [*Chapter 4*](B16412_04_Final_JC_ePub.xhtml#_idTextAnchor047),
    *Windows to Linux Interoperability*, the *Accessing Linux files from Windows*
    section, for more information on the `\\wsl$` share). One potential issue with
    this approach is that access to files via the `\\wsl$` share has a performance
    overhead, and for a large Git repo, this can make Windows Git utilities slow to
    load.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another option that we saw in [*Chapter 9*](B16412_09_Final_JC_ePub.xhtml#_idTextAnchor111),
    *Visual Studio Code and WSL*, in the *Viewing Git history* section, was to use
    Visual Studio Code. By using the Remote-WSL extension, we can install other extensions
    for Visual Studio Code so that they actually run in WSL. The **Git Graph extension**
    is a handy addition for Visual Studio Code that allows you to view Git history
    graphically and works well with Remote-WSL. You can see an example here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.2 – A screenshot showing the Git Graph extension in Visual Studio
    Code'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_11.2_B16412.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.2 – A screenshot showing the Git Graph extension in Visual Studio
    Code
  prefs: []
  type: TYPE_NORMAL
- en: This screenshot shows the same Git repo again, but this time using the Git Graph
    extension in Visual Studio Code. Because this extension is being loaded in WSL
    by Remote-WSL, all access to the Git repo is performed directly in WSL and it
    doesn't have the performance overhead of going via the `\\wsl$` share when querying
    Git.
  prefs: []
  type: TYPE_NORMAL
- en: We've seen a few approaches here, each with their benefits and each useful in
    their own context. The *Git CLI* approach is handy if you are already at the terminal,
    and it runs in WSL so has good performance. For inspecting complex branching and
    history, this is where a graphical tool often comes into its own. However, as
    mentioned, using graphical Git tools from Windows incurs the performance overhead
    of the `\\wsl$` share – normally, this isn't noticeable, but for a Git repo with
    a lot of files or history, it may start to be more significant. In these cases,
    or when I'm already working in the editor, I find a Visual Studio Code extension
    such as Git Graph really useful as a graphical visualization without the performance
    overhead.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we'll take a look at improving our bash prompt when working with Git.
  prefs: []
  type: TYPE_NORMAL
- en: Git information in the bash prompt
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When working in bash in a folder within a Git repository, the default prompt
    doesn''t give you any hints about the status of the Git repository. There are
    various options for adding context from a Git repository to bash, and we''ll look
    at a couple of those here. The first option is **bash-git-prompt** (https://github.com/magicmonty/bash-git-prompt),
    which customizes your bash prompt when in a Git repository. You can see an example
    of this here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.3 – A screenshot showing bash-git-prompt'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_11.3_B16412.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.3 – A screenshot showing bash-git-prompt
  prefs: []
  type: TYPE_NORMAL
- en: As this screenshot shows, `bash-git-prompt` shows which branch you are currently
    on (`main`, in this example). It also indicates whether your local branch has
    commits to push or whether there are commits to pull from the remote branch via
    the up and down arrows. The up arrow indicates commits to push, and the down arrow
    indicates commits to pull. Lastly, it shows whether you have local changes that
    haven't been committed – the `+1`, in this example.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install `bash-git-prompt`, first clone the repository with the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This `git clone` command clones the repo into a `.bash-git-prompt` folder in
    your user folder and uses `--depth=1` to only pull the latest commit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, add the following to `.bashrc` in your user folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This snippet sets the `GIT_PROMPT_ONLY_IN_REPO` variable to only use the custom
    prompt in folders with a Git repository, and then loads the `git` prompt. Now,
    re-open your terminal and change folders to a Git repository to see `bash-git-prompt`
    in action. For other configuration options, see the documentation at [https://github.com/magicmonty/bash-git-prompt](https://github.com/magicmonty/bash-git-prompt).
  prefs: []
  type: TYPE_NORMAL
- en: 'Another option for enriching your bash prompt is `bash-git-prompt` and takes
    over your general prompt experience, adding context to the prompt for things such
    as Git and Kubernetes. See an example of the Powerline prompt in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.4 – A screenshot showing a Powerline prompt'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_11.4_B16412.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.4 – A screenshot showing a Powerline prompt
  prefs: []
  type: TYPE_NORMAL
- en: As shown in this screenshot, Powerline uses some special font characters, and
    not all fonts have these characters set, so the first step is to ensure we have
    a suitable font. Windows Terminal ships with a font called `CascadiaCodePL.ttf`
    and `CascadiaMonoPL.ttf` from the `ttf` folder by right-clicking in **Windows
    Explorer** and selecting **Install**.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the Powerline font installed, we need to configure the terminal to use
    it. If you are using Windows Terminal, then launch it and press *Ctrl* + *,* to
    load the settings and add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are setting the default `fontFace` value to the `Cascadia Mono PL`
    (Powerline) font we just installed. To change the font for a single profile, see
    [*Chapter 3*](B16412_03_Final_JC_ePub.xhtml#_idTextAnchor037), *Getting Started
    with Windows Terminal*, the *Changing fonts* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have our terminal set up with a Powerline font, we can install
    Powerline. There are several variants, and we will use `powerline-go-linux-amd64`
    version from [https://github.com/justjanne/powerline-go/releases](https://github.com/justjanne/powerline-go/releases)
    and save it as `powerline-go` somewhere in `PATH` in the your WSL distro, for
    example, `/usr/local/bin`. (An alternative option is to install this via **Go**,
    but distro repositories can be stuck on old versions of Go leading to incompatibilities
    – if you prefer to try this option, then refer to the Windows Terminal docs: [https://docs.microsoft.com/en-us/windows/terminal/tutorials/powerline-setup](https://docs.microsoft.com/en-us/windows/terminal/tutorials/powerline-setup).)'
  prefs: []
  type: TYPE_NORMAL
- en: 'With `powerline-go` installed, we can configure bash to use it by adding the
    following to `bashrc`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have created an `_update_ps1` function that calls `powerline-go`.
    This is the place to add extra switches to control the behavior of `powerline-go`
    – see the documentation for more details: [https://github.com/justjanne/powerline-go#customization](https://github.com/justjanne/powerline-go#customization).'
  prefs: []
  type: TYPE_NORMAL
- en: When working with Git, tailoring your prompt to get context for the Git repository
    presented automatically can make life easier whichever option you pick. Combining
    this with setting up authentication in Git to be shared across Windows and WSL,
    and knowing how best to view Git history in different situations, you are well
    set up for being productive with Git in WSL.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll take a look at a couple of ways of working with JSON
    data.
  prefs: []
  type: TYPE_NORMAL
- en: Working with JSON
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Automating complex tasks can save hours of manual toil. In this section, we'll
    explore some techniques for working with JSON data, which is a common format that
    many command-line tools and APIs allow you to use. Later in the chapter, we'll
    show some examples of how you can use these techniques to easily create and publish
    content to a cloud website or Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this section, there is a sample JSON file in the accompanying code for
    the book. You can clone this code with Git from [https://github.com/PacktPublishing/Windows-Subsystem-for-Linux-2-WSL-2-Tips-Tricks-and-Techniques](https://github.com/PacktPublishing/Windows-Subsystem-for-Linux-2-WSL-2-Tips-Tricks-and-Techniques).
    The sample JSON is called `wsl-book.json` and is in the `chapter-11/02-working-with-json`
    folder, and is based around a JSON description of the chapters and headings for
    a book. A snippet of this JSON is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This snippet shows the structure of the sample JSON. It is worth taking a few
    moments to familiarize yourself with it as it is the basis for the examples in
    this section. Examples in this section assume that you have a shell open in the
    folder containing the sample JSON.
  prefs: []
  type: TYPE_NORMAL
- en: Let's get started with a popular utility, `jq`.
  prefs: []
  type: TYPE_NORMAL
- en: Using jq
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first tool we'll look at is `jq`, and it is a fantastically handy utility
    for working with JSON strings and is supported on the major platforms. Full installation
    options are listed on [https://stedolan.github.io/jq/download/](https://stedolan.github.io/jq/download/),
    but you can quickly get started on Debian/Ubuntu by running `sudo apt-get install
    jq`.
  prefs: []
  type: TYPE_NORMAL
- en: 'At its most basic, `jq` can be used to format input. As an example, we can
    pipe a JSON string into `jq`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In the output from this command, you can see that `jq` has taken the compact
    JSON input and turned it into a nicely formatted output. When working interactively
    with APIs that return compact JSON, this functionality alone can be useful. However,
    the real power of `jq` lies in its querying capabilities, and we will explore
    these as we work through this section. As a taster of what can be achieved, take
    a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This output shows `jq` extracting and outputting the `name` values for the
    parts in the sample JSON. This sort of capability is extremely useful when scripting
    with APIs and command-line tools that return JSON data, and we will start with
    some simple queries and build up to more complex ones. You can follow along with
    the examples using the `jq` CLI or with the **jq playground** at [https://jqplay.org](https://jqplay.org),
    as seen in the screenshot here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.5 – A screenshot showing the jq playground'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_11.5_B16412.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.5 – A screenshot showing the jq playground
  prefs: []
  type: TYPE_NORMAL
- en: This screenshot shows the previous example open in the `jq` playground. In the
    top left, you can see the filter (`.parts[].name`), under that is the input JSON,
    and on the right is the `jq` output. The playground can be a helpful environment
    when you are working on a complex query, and the **Command Line** section at the
    bottom even gives you the command line that you can copy and use in your scripts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you have a sense of what `jq` can do, let''s start with a simple query.
    The JSON we''re working with has two top-level properties: `title` and `parts`.
    If we want to extract the value of the `title` property, we can use the following
    query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have used the `.title` filter to extract the value of the `title`
    property. Notice that the value is quoted in the output because `jq` outputs JSON
    by default. To assign this to a variable in a script, we typically want the value
    without quotes, and we can use the `-r` option with `jq` to get the raw output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This output shows using the `-r` option to get raw (unquoted) output and assign
    it to a variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we used the `title` property, which is a simple string value.
    The other top-level property is `parts`, which is an array of JSON objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In the output of this command, we see that retrieving the `parts` property
    returns the full value of the property. We can change the filter to `.parts[0]`
    to pull back the first item in the `parts` array, and then extend the filter further
    if we want to get the name of the first part, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we see how we can build up a query to work down the hierarchy of JSON
    data, selecting properties and indexing into arrays to select a specific value.
    Sometimes it is useful to be able to get a list of data – for example, to retrieve
    the name of all the parts. We can do that with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in this example, we omitted the array index from the previous
    filter and `jq` has processed the rest of the filter (`.name`) against each item
    of the `parts` array. As with the single value output, we can add the `-r` option
    to get unquoted strings for ease of working with the output in a script. Alternatively,
    if we are working with APIs, we may want to build up JSON output – for example,
    to output the previous values as an array, we can wrap the filter in square brackets:
    `[.parts[].name]`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, we have only used a single filter expression, but `jq` allows us to
    chain multiple filters together and pipe the output from one as the input to the
    next. For example, we can rewrite `.parts[].name` as `.parts[] | .name`, which
    will produce the same output. From here, we can change the second filter to `{name}`
    to produce an object with a `name` property, rather than just the name value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we see that each value from the `.parts` array is now producing an object
    in the output, rather than just the simple string previously. The `{name}` syntax
    is actually a shorthand for `{name: .name}`. The full syntax makes it easier to
    see how you can control the property names in the output – for example, `{part_name:
    .name}`. With the full syntax, we can also see that the property value is another
    filter. In this example, we used the simple `.name` filter, but we can build up
    with richer filters as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we added `.chapters | length` as a filter to specify the value
    of the `chapter_count` property. The `.chapters` expression is applied to the
    value of the `parts` array that is currently being processed and selects the `chapters`
    array, and this is parsed to the `length` function, which returns the array length.
    For more information on the functions available in `jq`, check out the documentation
    at https://stedolan.github.io/jq/manual/#Builtinoperatorsandfunctions.
  prefs: []
  type: TYPE_NORMAL
- en: 'For one final example of `jq`, let''s pull together a summary of the parts
    showing the part name, along with a list of the chapter titles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, the `parts` array is piped into a filter that creates an object
    for each array item with the `name` and `chapters` properties. The `chapters`
    property is built up by piping the `chapters` array into a selector for the `title`
    property, and then wrapping that in an array: `[.chapters[] | title]`. The whole
    result is wrapped in an array (using square brackets again) to create a JSON array
    of these summary objects in the output.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: There are various ways to look up options with command-line tools such as `jq`.
    You can run `jq --help` for a brief help page or `man jq` to view the full man
    page. A handy alternative to these is `tldr` (see [https://tldr.sh](https://tldr.sh)
    for more details and installation instructions). The `tldr` utility describes
    itself as *simplified and community-driven man pages*, and running `tldr jq` will
    give a shorter output than the man pages, with useful examples included.
  prefs: []
  type: TYPE_NORMAL
- en: This whirlwind tour has shown you some of the power that `jq` offers, whether
    for formatting JSON output for readability when working interactively, for quickly
    selecting single values from JSON to use in a script, or for transforming JSON
    input into a new JSON document. When working with JSON, `jq` is an extremely useful
    tool to have to hand, and we will see some more examples of this in later sections
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will explore the options for using **PowerShell** to
    handle JSON data.
  prefs: []
  type: TYPE_NORMAL
- en: Using PowerShell to work with JSON
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we''ll explore some of the capabilities that PowerShell gives
    us for working with JSON data. PowerShell is a shell and scripting language that
    originated for Windows but is now available for Windows, Linux, and macOS. To
    install in WSL, follow the installation instructions for your distribution at
    https://docs.microsoft.com/en-us/powershell/scripting/install/installing-powershell-core-on-linux?view=powershell-7\.
    For example, for Ubuntu 18.04, we can use the following commands to install PowerShell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: These steps will register the Microsoft package repository and then install
    PowerShell from there. Once installed, you can launch PowerShell by running `pwsh`,
    and this will give you an interactive shell that we will use for the rest of the
    examples in this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can load and parse the example JSON file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we see the `Get-Content` cmdlet (commands in PowerShell are called `ConvertFrom-Json`
    used to parse the JSON object graph into PowerShell objects. At this point, we
    can use any of the PowerShell features for working with data. For example, we
    could get the title using the `Select-Object` cmdlet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Select-Object` cmdlet allows us to perform various manipulations on a
    set of objects, such as taking a specified number of items from the start or end
    of the set, or filtering to only unique items. In this example, we used it to
    select a property of the input object to output. An alternative approach for getting
    the title is to work directly with the converted JSON objects, as shown in the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we have saved the result of converting the data from JSON
    into the `$data` variable and then accessed the `title` property directly. Now
    that we have the `$data` variable, we can explore the `parts` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we directly access the `parts` property, which is an array
    of objects. We then pass this array of objects to `Select-Object` to expand the
    `name` property of each part. If we want to generate JSON output (as we did with
    `jq` in the previous section), we can use the `ConvertTo-Json` cmdlet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have used the same command as in the previous example (although we
    have used the `select` alias for `Select-Object` for conciseness) and then passed
    the output into the `ConvertTo-Json` cmdlet. This cmdlet performs the opposite
    of `ConvertFrom-Json` – in other words, it converts a set of PowerShell objects
    into JSON.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to output JSON objects with the part names, we can do that using
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Here, we use `ForEach-Object` instead of `Select-Object`. The `ForEach-Object`
    cmdlet allows us to provide a snippet of PowerShell that is executed for each
    object in the input data and the `$_` variable contains the item in the set for
    each execution. In the snippet inside `ForEach-Object`, we have used the `@{ }`
    syntax to create a new PowerShell object with a property called `Name` that is
    set to the `name` property of the current input object (which is the part name,
    in this case). Finally, we pass the resulting set of objects into `ConvertTo-Json`
    to convert to JSON output.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use this approach to build up richer output – for example, to include
    the name of the part along with the number of chapters it contains:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we have extended the snippet inside `ForEach-Object` to `@{
    "Name" = $_.name; "ChapterCount"=$_.chapters.Count }`. This creates an object
    with two properties: `Name` and `ChapterCount`. The `chapters` property is a PowerShell
    array and so we can use the array''s `Count` property for the value of the `ChapterCount`
    property in the output.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we wanted to output a summary with the chapter names for each part, we can
    combine the approaches we have seen so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have again used the `ForEach-Object` cmdlet to create PowerShell objects,
    this time with `Name` and `Chapters` properties. To create the `Chapters` property,
    we just want the name of each chapter, and we can use the `Select-Object` cmdlet
    just as we originally did to select part names earlier in this section, but this
    time we use it inside the `ForEach-Object` snippet. Being able to compose commands
    in this way gives us a lot of flexibility.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous examples, we have been working with data that we loaded from
    a local file with `Get-Content`. To download data from a URL, PowerShell provides
    a couple of handy cmdlets: `Invoke-WebRequest` and `Invoke-RestMethod`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use `Invoke-WebRequest` to download the sample data from GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we see that `Invoke-WebRequest` gives us access to various properties
    of the response, including the status code and content. To load the data as JSON,
    we could pass the `Content` property into `ConvertFrom-JSON`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we have used the `iwr` alias as a shorthand for `Invoke-WebRequest`,
    which can be handy when working interactively. We could have passed the output
    from `Invoke-WebRequest` into `Select-Object` to expand the `Content` property
    as we saw previously. Instead, we''ve wrapped the expression in parentheses to
    directly access the property to show an alternate syntax. This content is then
    passed to `ConvertFrom-Json`, which converts the data into PowerShell objects
    as we saw earlier. This composability is handy, but if you are only interested
    in the JSON content (and not in any other properties of the response), then you
    can use the `Invoke-RestMethod` cmdlet to achieve this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Here, we see the same output as before because the `Invoke-RestMethod` cmdlet
    has determined that the response contains JSON data and automatically performed
    the conversion.
  prefs: []
  type: TYPE_NORMAL
- en: Summarizing working with JSON
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the last two sections, you've seen how both `jq` and PowerShell give you
    rich capabilities for working with JSON input. In each case, you've seen how to
    extract simple values and to perform more complex manipulation to generate new
    JSON output. With JSON in common use across APIs and CLIs, being able to work
    effectively with JSON is a big productivity boost, as we will see in the rest
    of the chapter. Throughout the rest of the chapter, we will use `jq` in the examples
    where we need an extra tool to help process JSON, but be aware that you could
    also use PowerShell for this.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will see how to combine the techniques for working with
    JSON with another command-line tool, this time with some tips for working with
    the Azure CLI.
  prefs: []
  type: TYPE_NORMAL
- en: Working with the Azure CLI (az)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The drive toward cloud computing brings a number of benefits, among them the
    ability to stand up computing resources on demand. Being able to automate the
    creation, configuration, and deletion of these resources is a key part of the
    benefits, and this is often performed using the CLI provided by the relevant cloud
    vendor.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will create and publish a simple website, all from the command
    line, and use this as a way to take a look at some tips for working with the Azure
    CLI (`az`). We will see some ways to use `jq` that we saw earlier in the chapter,
    as well as the built-in querying capabilities of `az`. If you want to follow along
    but don't already have an Azure subscription, you can sign up for a free trial
    at https://azure.microsoft.com/free/. Let's get started by installing the CLI.
  prefs: []
  type: TYPE_NORMAL
- en: Installing and configuring the Azure CLI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is a range of options for installing the Azure CLI. The simplest is to
    open a terminal in the WSL distro where you want to install the CLI and run the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This command downloads the installation script and runs it in bash. If you
    prefer not to directly run scripts from the internet, you can either download
    the script first and inspect it or check out the individual installation steps
    here: [https://docs.microsoft.com/en-us/cli/azure/install-azure-cli-apt?view=azure-cli-latest](https://docs.microsoft.com/en-us/cli/azure/install-azure-cli-apt?view=azure-cli-latest).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once installed, you should be able to run `az` from your terminal. To connect
    to your Azure subscription so that you can manage it, run `az login`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In this output from the `az login` command, you can see that `az` has generated
    a code that we can use to log in by visiting [https://microsoft.com/devicelogin](https://microsoft.com/devicelogin).
    Open this URL in your browser and sign in with the account you use for your Azure
    subscription. Shortly after doing this, the `az login` command will output your
    subscription information and finish running.
  prefs: []
  type: TYPE_NORMAL
- en: If you have multiple subscriptions, you can list them with `az account list`
    and choose which subscription is the default subscription to work with using `az
    account set --subscription YourSubscriptionNameOrId`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we are signed in, we can start running commands. In Azure, resources
    live inside resource groups (a logical container), so let''s list our groups:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the output from the command shows that there are currently no resource
    groups in the subscription. Note that the output is `[]` – an empty JSON array.
    By default, `az` outputs results as JSON, so running the previous command against
    a subscription with some existing resource groups gives us the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding output has been truncated as it gets quite verbose. Fortunately,
    `az` allows us to choose from a number of output formats, including table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: In this output, we have used the `-o table` switch to configure table output.
    This output format is more concise and generally quite convenient for interactive
    usage of the CLI, but it can be tedious to have to keep adding the switch to commands.
    Fortunately, we can make the table output the default by running the `az configure`
    command. This will present you with a short set of interactive choices, including
    which output format to use by default. Because the default output format can be
    overridden, it is important to specify JSON output if that is what you want in
    scripts in case the user has configured a different default.
  prefs: []
  type: TYPE_NORMAL
- en: For more examples of using `az`, including how to create various resources in
    Azure, see the *Samples* section at [https://docs.microsoft.com/cli/azure](https://docs.microsoft.com/cli/azure).
    In the remainder of this section, we will look at some specific examples of working
    with the CLI for querying information about resources.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an Azure web app
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To demonstrate querying with `az`, we will create a simple Azure web app. Azure
    web apps allow you to host web applications written in various languages (including
    .NET, Node.js, PHP, Java, and Python), and have many options for deployment that
    you can pick from based on your preferences. We will keep this simple to ensure
    we focus on the CLI usage, so we will create a single-page static website and
    deploy it via FTP. To find out more about Azure web apps, see the documentation
    at [https://docs.microsoft.com/en-us/azure/app-service/overview](https://docs.microsoft.com/en-us/azure/app-service/overview).
  prefs: []
  type: TYPE_NORMAL
- en: 'Before creating the web app, we need to create a resource group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we use the `az group create` command to create a resource group to contain
    the resources that we will create. Note that we''ve used the line continuation
    character (`\`) to split the command across multiple lines for readability. To
    run a web app, we need an Azure App Service plan to host it in, so we will create
    that first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'In this snippet, we used the `az appservice plan create` command to create
    a free hosting plan in the resource group we just created. Now, we can create
    a web app using that hosting plan:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Here, we generate a random name for the site (as it needs to be unique) and
    store it in the `WEB_APP_NAME` variable. We then use this with the `az webapp
    create` command. Once this command completes, we have created a new website and
    are ready to start querying with the `az` CLI.
  prefs: []
  type: TYPE_NORMAL
- en: Querying single values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first thing we want to query for our web app is its URL. We can use the
    `az webapp show` command to list various properties for our web app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have passed the `--output json` switch to ensure that we get JSON output
    regardless of what default format is configured. In this cut-down output, we can
    see that there is a `defaultHostName` property that we can use to build up the
    URL for our site.
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to extract the `defaultHostName` property is to use `jq`, as we saw
    in the *Using jq* section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: In this snippet, we use `jq` to select the `defaultHostName` property and pass
    the `-r` switch to get raw output to avoid it being quoted, and then assign this
    to the `WEB_APP_URL` property so that we could use it in other scripts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `az` CLI also includes built-in querying capabilities using the `az` run
    a JMESPath query and output the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Here, we use the `--query` option to pass the `"defaultHostName"` JMESPath query,
    which selects the `defaultHostName` property. We also add `--output tsv` to use
    tab-separated output, which prevents the value from being wrapped in quotes. This
    retrieves the same value as the previous example with `jq`, but does it all with
    `az`. This can be useful when sharing scripts with others as it removes a required
    dependency.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: You can find more details about JMESPath, and an interactive query tool, at
    [https://jmespath.org](https://jmespath.org). There is a `jp` CLI for running
    JMESPath queries, which can be installed from [https://github.com/jmespath/jp](https://github.com/jmespath/jp).
    Additionally, there is a `jpterm` CLI that provides an interactive JMESPath in
    your terminal, which can be installed from [https://github.com/jmespath/jmespath.terminal](https://github.com/jmespath/jmespath.terminal).
  prefs: []
  type: TYPE_NORMAL
- en: 'These tools can provide a nice way to explore JMESPath when building up queries.
    Take the following example, with `jpterm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**az webapp show --name $WEB_APP_NAME --resource-group wsltips-chapter-11-03
    --output json | jpterm**'
  prefs: []
  type: TYPE_NORMAL
- en: Here, you can see piping JSON output to `jpterm`, which then allows you to interactively
    experiment with queries in your terminal.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve seen a couple of ways to retrieve the hostname via `az` and store it
    in the `WEB_APP_URL` variable. Now, either run `echo $WEB_APP_URL` to output the
    value and copy into your browser, or run `wslview https://$WEB_APP_URL` to launch
    the browser from WSL (for more details on `wslview`, see the *Using wslview to
    launch default Windows applications* section in [*Chapter 5*](B16412_05_Final_JC_ePub.xhtml#_idTextAnchor054),
    *Linux to Windows Interoperability*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.6 – A screenshot showing the Azure web app placeholder site'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_11.6_B16412.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.6 – A screenshot showing the Azure web app placeholder site
  prefs: []
  type: TYPE_NORMAL
- en: In this screenshot, you can see the placeholder site, loaded via the URL that
    we queried through the `az` CLI. Next, let's look at a more complex querying requirement
    as we add some content to our web app.
  prefs: []
  type: TYPE_NORMAL
- en: Querying and filtering multiple values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have a web app created, let''s upload a simple HTML page. There
    are many options for managing content with Azure web apps (see [https://docs.microsoft.com/en-us/azure/app-service/](https://docs.microsoft.com/en-us/azure/app-service/))
    but for simplicity, in this section, we will use `curl` to upload a single HTML
    page via FTP. To do this, we need to get the FTP URL along with the username and
    password. These values can be retrieved using the `az webapp deployment list-publishing-profiles`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'This truncated output shows a JSON array in the output. The values we need
    are in the second array item (the one with the `publishMethod` property set to
    `FTP`). Let''s look at how we can achieve this with the `--query` approach we
    saw in the previous section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have used a JMESPath query of `[?publishMethod == ''FTP'']|[0].publishUrl`.
    We can break the query down into a few parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[?publishMethod == ''FTP'']` is the syntax for filtering an array, and here
    we filter it to only return items that contain a `publishMethod` property with
    a value of `FTP`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The output from the preceding query is still an array of items, so we use `|[0]`
    to pipe the array into an array selector to take the first array item.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we use `.publishUrl` to select the `publishUrl` property.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Again, we've used the `--output tsv` switch to avoid the result being wrapped
    in quotes. This query retrieves the publish URL and we can repeat the query, changing
    the property selector to retrieve the username and password.
  prefs: []
  type: TYPE_NORMAL
- en: 'A downside of this approach is that we are issuing three queries to `az`, each
    of which returns the information we require, but throwing away all but one value.
    In many situations, this is acceptable, but sometimes the information we require
    is returned to us from a call to create a resource, and in these cases, repeating
    the call isn''t an option. In these situations, we can use a slight variation
    of the `jq` approach we saw previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are storing the JSON response from `az`, rather than piping it directly
    into `jq`. We can then pipe the JSON into `jq` multiple times to select the different
    properties we want to retrieve. In this way, we can make a single call to `az`
    and still capture multiple values. The `jq` query `map(select(.publishMethod =="FTP"))[0].publishUrl`
    can be broken down in a similar way to the JMESPath query we just saw. The first
    part (`map(select(.publishMethod =="FTP"))`) is the `jq` way to select items of
    the array where the `publishMethod` property has the value FTP. The remainder
    of the query selects the first array item and then captures the `publishUrl` property
    to output.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one more option that we''ll look at here, which is a variation of
    the `--query` approach, and allows us to issue a single query without requiring
    `jq`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: This snippet builds on the earlier `--query` approach but has a couple of differences
    to call out.
  prefs: []
  type: TYPE_NORMAL
- en: First, we are using `.[publishUrl,userName,userPWD]` instead of simply `.publishUrl`
    as the final selector in the JMESPath query. The result of this is to generate
    an array containing the values of the `publishUrl`, `userName,` and `userPWD`
    properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'This array of properties is output as tab-separated values, and the results
    are treated as a bash array by surrounding the results of executing the `az` command
    in parentheses: `CREDS_TEMP=($(az...))`.'
  prefs: []
  type: TYPE_NORMAL
- en: These two steps allow us to return multiple values from a single call to `az`
    using `--query` and store the results in an array. The last lines in the output
    show assigning the array items to the named variables for ease of use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Whichever option is used to set the publish environment variables, we can now
    upload the `index.html` file from a terminal in the `chapter-11/03-working-with-az`
    folder of the sample content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are using `curl` to upload the `index.html` file to FTP using the
    URL, username, and password we queried. Now we can go back to the browser and
    reload the page. We will get the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.7 – A screenshot showing the web app with our uploaded content'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16412_11.7.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.7 – A screenshot showing the web app with our uploaded content
  prefs: []
  type: TYPE_NORMAL
- en: This screenshot shows the web app we previously created now returning the simple
    HTML page we just uploaded.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''re finished with the web app (and App Service plan) we created,
    we can delete them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: This command will delete the `wsltips-chapter-11-03` resource group that we
    have been using and all the resources we created within it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The example in this section showed using `curl` to FTP a single page to the
    Azure web app we created, which provided a handy example for querying with `az`,
    but Azure web apps offer a wide range of options for deploying your content –
    see the following article for more details: [https://docs.microsoft.com/archive/msdn-magazine/2018/october/azure-deploying-to-azure-app-service-and-azure-functions](https://docs.microsoft.com/archive/msdn-magazine/2018/october/azure-deploying-to-azure-app-service-and-azure-functions).
    It is also worth noting that for hosting static websites, Azure Storage static
    site hosting can be a great option. For a walkthrough, see [https://docs.microsoft.com/en-us/azure/storage/blobs/storage-blob-static-website-how-to?tabs=azure-cli](https://docs.microsoft.com/en-us/azure/storage/blobs/storage-blob-static-website-how-to?tabs=azure-cli).'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you've seen a number of approaches to querying using the `az`
    CLI. You've seen how to set the default output to table format for readable interactive
    querying. When scripting, you've seen how you can use JSON output and handle it
    with `jq`. You've learned how to use JMESPath querying with the `--query` switch
    to filter and select values from the responses directly with `az` commands. In
    this section, we've only looked at a narrow slice of the `az` CLI (for web apps)
    – if you're interested in exploring more of the breadth of `az`, then see [https://docs.microsoft.com/cli/azure](https://docs.microsoft.com/cli/azure).
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll take a look at another CLI – this time for Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Working with the Kubernetes CLI (kubectl)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When building a containerized application, Kubernetes is a common choice of
    container orchestrator. For an introduction to Kubernetes, see the *Setting up
    Kubernetes in WSL* section in [*Chapter 7*](B16412_07_Final_JC_ePub.xhtml#_idTextAnchor082),
    *Working with Containers in WSL*. Kubernetes includes a CLI called `kubectl` for
    working with Kubernetes from the command line. In this section, we will deploy
    a basic website in Kubernetes and then look at different ways to query information
    about it using `kubectl`.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 7*](B16412_07_Final_JC_ePub.xhtml#_idTextAnchor082), *Working with
    Containers in WSL*, we saw how to set up Kubernetes on our local machine with
    Docker Desktop. Here, we will explore setting up a Kubernetes cluster using a
    cloud provider. The following instructions are for Azure, but if you are familiar
    with another cloud that has a Kubernetes service, then feel to work with that.
    If you want to follow along but don't already have an Azure subscription, you
    can sign up for a free trial at https://azure.microsoft.com/free/.
  prefs: []
  type: TYPE_NORMAL
- en: Let's get started by installing `kubectl`.
  prefs: []
  type: TYPE_NORMAL
- en: Installing and configuring kubectl
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are various options for installing `kubectl` (which can be found at [https://kubernetes.io/docs/tasks/tools/install-kubectl/#install-kubectl-binary-with-curl-on-linux](https://kubernetes.io/docs/tasks/tools/install-kubectl/#install-kubectl-binary-with-curl-on-linux))
    but the simplest is to run the following commands from your WSL distribution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'These commands download the latest `kubectl` binary, mark it as executable,
    and then move it to your `bin` folder. Once this is done, you should be able to
    run `kubectl version --client` to check that `kubectl` is installed correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have seen the output from `kubectl` showing that we have installed
    version `v1.19.2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `kubectl` utility has a wide range of commands and enabling bash completion
    can make you more productive. To do this, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: This adds a command to your `.bashrc` file to auto-load the `kubectl` bash completion
    when bash launches. To try it out, restart bash or run `source ~/.bashrc`. Now,
    you can type `kubectl ver<TAB> --cli<TAB>` to get the previous `kubectl version
    --client` command.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: 'If you find `kubectl` too much to type, you can create an alias by running
    the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '**echo ''alias k=kubectl'' >>~/.bashrc**'
  prefs: []
  type: TYPE_NORMAL
- en: '**echo ''complete -F __start_kubectl k'' >>~/.bashrc**'
  prefs: []
  type: TYPE_NORMAL
- en: These commands add to `.bashrc` to configure `k` as an alias for `kubectl` and
    set up bash completion for `k`.
  prefs: []
  type: TYPE_NORMAL
- en: With this, you can use commands such as `k version – client` and still get bash
    completion.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have `kubectl` installed and configured, let's create a Kubernetes
    cluster to use it with.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Kubernetes cluster
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following instructions will take you through creating a Kubernetes cluster
    using `az`). If you haven't got `az` installed, then refer to the *Installing
    and configuring the Azure CLI* section earlier in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to create a resource group to contain our cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are creating a resource group called `wsltips-chapter-11-04` in the
    `westeurope` region.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we create the AKS cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: This command creates a cluster called `wsltips` in the resource group we just
    created. This command will take a few minutes to run and when it has completed,
    we will have a Kubernetes cluster running with two worker nodes where we can run
    our container workloads.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final step is to set up `kubectl` so that it can connect to the cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Here, we use `az aks get-credentials` to get the credentials for the cluster
    we created and save them in the configuration file for `kubectl`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can run commands such as `kubectl get services` to list the defined
    services:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: This output shows the listing of Kubernetes services in the cluster we created,
    demonstrating that we have successfully connected to the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a Kubernetes cluster and `kubectl` is configured to connect
    to it, let's deploy a test website to it.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying a basic website
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To help explore `kubectl`, we will deploy a basic website. We can then use that
    to look at different ways of querying information with `kubectl`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The accompanying code for the book contains a folder for this section with
    the Kubernetes YAML files. You can get this code from [https://github.com/PacktPublishing/Windows-Subsystem-for-Linux-2-WSL-2-Tips-Tricks-and-Techniques](https://github.com/PacktPublishing/Windows-Subsystem-for-Linux-2-WSL-2-Tips-Tricks-and-Techniques).
    The content for this section is in the `chapter-11/04-working-with-kubectl` folder.
    The `manifests` folder contains a number of YAML files defining Kubernetes resources
    to deploy:'
  prefs: []
  type: TYPE_NORMAL
- en: A **ConfigMap** containing a simple HTML page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `nginx` image and configures it to load the HTML page from the ConfigMap
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `nginx` Deployment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To deploy the website, launch your WSL distro and navigate to the `chapter-11/04-working-with-kubectl`
    folder. Then, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Here, we used `kubectl apply -f manifests` to create the resources described
    by the YAML files in the `manifests` folder. The output of the command shows the
    three resources that have been created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can run `kubectl get services chapter-11-04` to see the status of the
    created service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Here, we see that the `chapter-11-04` service is of type `LoadBalancer`. With
    AKS, a `LoadBalancer` service will automatically be exposed using an *Azure load
    balancer* and this can take a few moments to provision – note the `<pending>`
    value for `EXTERNAL_IP` in the output showing that the load balancer is in the
    process of being provisioned. In the next section, we'll look at how to query
    this IP address.
  prefs: []
  type: TYPE_NORMAL
- en: Querying with JSONPath
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we just saw, the external IP address of the service isn''t available immediately
    after creating the service as the Azure load balancer needs to be provisioned
    and configured. We can see what this looks like in the underlying data structures
    by getting the service output in JSON format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we see the truncated JSON output from applying the `-o json` option.
    Note the empty value for the `loadBalancer` property under `status`. If we wait
    a short while and then re-run the command, we see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see that the `loadBalancer` property now contains an `ingress`
    property with an array of IP addresses.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the built-in `jsonpath` functionality of `kubectl` to directly query
    for the IP address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have used `-o jsonpath` to provide a JSONPath query: `{.status.loadBalancer.ingress[0].ip}`.
    This query maps directly onto the path into the JSON results that we want to query.
    For more details on JSONPath (including an online interactive evaluator), see
    [https://jsonpath.com/](https://jsonpath.com/). This technique is handy to use
    in scripts and the accompanying code has a `scripts/wait-for-load-balancer.sh`
    script that waits for the load balancer to be provisioned and then outputs the
    IP address.'
  prefs: []
  type: TYPE_NORMAL
- en: Using JSONPath directly with `kubectl` is convenient, but JSONPath can be somewhat
    limited compared to `jq` and there are times where we need to make the switch.
    We'll take a look at one of these scenarios next.
  prefs: []
  type: TYPE_NORMAL
- en: Scaling the website
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Deployment we just created only runs a single instance of the `nginx` Pod.
    We can see this by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Here, we list the Pods that match the `app=chapter-11-04` label selector, which
    is specified in the definition in the `deployment.yaml` we applied.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the features that Kubernetes Deployment resources provide is the ability
    to easily scale up the number of Pods for a Deployment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we specify the Deployment to scale and the number of instances (`replicas`)
    we want to scale it to. If we query the Pods again, we will now see three instances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: This output lists three Pods for the Deployment, but note that one of them is
    in the `Pending` state. The reason for this is that the Deployment definition
    requested a full CPU for each Pod, but the cluster only has two worker nodes.
    While the machine running each node has two CPUs, some of that is reserved for
    the worker node processes themselves. Although this scenario is deliberately constructed
    to illustrate querying with `kubectl`, it is common to encounter similar issues.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having found a Pod that isn''t running, we can investigate it further:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have requested the JSON for the Pod that isn't running, and the truncated
    output shows a `conditions` property. This has an entry that indicates that the
    Pod can't be scheduled (that is, Kubernetes couldn't find anywhere in the cluster
    to run it). In the next section, we will write a query to find any Pods that can't
    be scheduled from a list of Pods.
  prefs: []
  type: TYPE_NORMAL
- en: Querying with jq
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s look at how to write a query to find any Pods that have a condition
    with a type of `PodScheduled` with `status` set to `False`. Firstly, we can get
    the names of Pods with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have piped the JSON output from `kubectl` to `jq` and used a selector
    to extract `metadata.name` for each item in the input `items` array as the `name`
    property in the output. This uses the same techniques we saw earlier in the chapter
    – see the *Using jq* section for more details.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we want to include the conditions from the `status` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have included all of the conditions, but since we''re only looking
    for those that haven''t been scheduled, we want to only include specific conditions.
    To do this, we can use the `jq` `select` filter, which processes an array of values
    and passes through those that match the specified condition. Here, we will use
    it to filter the status conditions to only include those that have `type` set
    to `PodScheduled` and `status` set to `False`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Here, we applied `select(.type == "PodScheduled" and .status == "False")` to
    the set of conditions being assigned to the `conditions` property. The result
    of the query is just the single item that has the failure status condition.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can make a couple of final tweaks to the query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we''ve made a couple of last updates to the selector. The first is to
    pipe the result of the previous selector into `{name, reason: .conditions.reason,
    message: .conditions.message}` to pull out only the fields we''re interested in
    seeing in the output, making the output easier to read. The second is to wrap
    the whole selector in square brackets so that the output is a JSON array. This
    way, if there are multiple unschedulable pods, we will get valid output that could
    be further processed if we wanted.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you find yourself using this command regularly, you may want to save it
    as a bash script or even add it to your `.bashrc` file as an alias:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have created a `k-unschedulable` alias for the command to list pods
    that are unschedulable. Note that quotes (`"`) have been escaped with a backslash
    (`\"`).
  prefs: []
  type: TYPE_NORMAL
- en: This technique can be applied to various resources in Kubernetes. For example,
    nodes in Kubernetes have status conditions that indicate whether a node is running
    out of memory or disk space, and this query can be modified to make it easy to
    identify those nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, though, there is a general pattern that we've followed, which starts
    with getting the JSON output for the resource you are interested in. From there,
    if the value you want to retrieve is a simple value, then the JSONPath approach
    is a good one to consider. For more complex filtering or output formatting, `jq`
    is a handy tool in your toolkit. Kubernetes holds a rich set of information for
    its resources, and being comfortable working with `kubectl` and its JSON output
    gives you powerful querying capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''re finished with the cluster, we can delete the containing resource
    group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: This command will delete the `wsltips-chapter-11-04` resource group that we
    have been using and all the resources we created within it.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you've covered topics from setting up bash completion for `kubectl`
    to make you more productive when typing `kubectl` commands to approaches for using
    `kubectl` to query information about resources in your Kubernetes cluster. Whether
    you're querying a single value for a specific resource or filtering data over
    sets of resources, using the techniques here opens up great opportunities for
    scripting steps of your workflow.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you saw ways to improve how you work with Git in WSL. You saw
    how to configure Git Credential Manager for Windows to reuse saved Git credentials
    from Windows in WSL and to prompt you in Windows when new Git credentials are
    needed. After this, you saw a range of options for viewing Git history, with a
    discussion of their pros and cons to enable you to pick the right approach for
    you.
  prefs: []
  type: TYPE_NORMAL
- en: In the rest of the chapter, you saw how to work with JSON data in WSL, initially
    by diving into `jq` and the JSON capabilities of PowerShell. With this background,
    you then saw some examples of working with JSON through deployments using `az`
    and `kubectl`. As well as covering scenarios that you may face with each of these
    CLIs, the examples demonstrated techniques that can be applied to other CLIs (or
    APIs) that provide JSON data. Being able to work effectively with JSON data gives
    you powerful capabilities that you can use in your scripts to save you time.
  prefs: []
  type: TYPE_NORMAL
- en: This is the final chapter of the book, and I hope I've managed to impart some
    of my excitement around WSL 2 and the possibilities that it brings. Have fun with
    Linux on Windows!
  prefs: []
  type: TYPE_NORMAL
