- en: Chapter 6. Bringing Static Things to Life
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Stacking graphical layers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moving to an OOP perspective
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Animating independent layers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding an interactive legend
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a context-aware legend
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until now, the importance of keeping things organized and clean wasn't as great
    as that of getting our projects done as we had relatively small projects. This
    chapter will break us into a few new habits by first making everything dynamic
    followed by creating a more object-oriented program so it's easier for us to separate
    tasks and reduce our code footprint. After all this hard work, we will revisit
    our application and start adding extra logic geared at making our application
    animated layer by layer.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter is a great resourse for refactoring practice. In the first half
    of this chapter, we will be focused on improving our code structure to make it
    possible for us to have the level of control we will need in the second half of
    the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Stacking graphical layers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we can do any real animations on our canvas we really need to rethink
    the concept of building everything on one canvas layer. Once a canvas element
    is drawn, it's incredibly hard to create subtle small changes to it, such as fade-ins
    for specific elements. We will revisit one of our famous charts, the bar chart,
    which we played around with and enhanced many times throughout the earlier chapters.
    In this chapter, our goal will be to break the logic apart and make it more modular.
    In this recipe we will separate layers. Each layer will give us more control later
    when we are ready to animate.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Start by grabbing the latest files from the previous chapter: `05.02.line-revisit.html`
    and `05.02.line-revisit.js`.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following changes are made to the HTML file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the HTML file to incorporate more canvas elements (one per drawn line):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a CSS script so the layers will be stacked:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Let's move into the JavaScript file to update it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a `window.onload` callback function (changes highlighted in the code snippet):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Remove the variable `context` from global scope (delete the highlighted code
    snippet):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Consolidate all bar line information into one object for easier control (delete
    all the highlighted code snippets):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Remove all canvas logic from the `init` function and add it to the `drawChart`
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Update references to the new data object in the `init` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `drawChart` function, extract the logic of line creation to an external
    function (delete the highlighted code snippets):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Change the logic in the `onChangedRadio` callback function. Instead of what
    it was doing so far let''s have it trigger a call to the `changeLineView` function
    (we will create that function next):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the function `changeLineView`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: When you run your HTML file after all these changes, you should see exactly
    the same thing as you did before we started making all these changes. If that's
    true then you are in a great place. However, we can't visually see any change
    yet.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The heart of this recipe is our HTML file that enables us to layer canvas elements
    on top of each other, and as our canvas is by default transparent, we can see
    through to the elements that are under it. After our canvas is layered with four
    layers, it''s time for us to separate our background from our lines and as such
    we want to put all of our chart background information right into the base canvas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'With each line layer, we are using a preconfigured canvas element that is already
    set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The first parameter is both the ID of our canvas and the key we are using in
    our new object that stores our line information (to keep our code simple):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In this data object we have exactly the same number of elements as we do in
    our canvas with the exact same names. This way we can very easily fetch information
    without using extra variables or conditions. This ties in to the logic of creating/updating
    lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We didn''t change the core logic of our line but redirected the logic into
    the context of the current line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This way we can extract any direct mention of a year or element without referring
    to element names directly. This way we can add or remove elements and we would
    only need to add another canvas in our HTML file, add new properties, and finish
    off by adding the line in our creating function. That is still a lot, so how about
    we continue and optimize this code before we move on to more creative lands?
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our final goal is this recipe is to help minimize the number of changes the
    user needs to do to create lines. Currently to add more lines the user would need
    to make changes in three places. The next few optimization tricks will help us
    reduce the number of steps it takes to add/remove lines.
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing the drawChart function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Our `drawChart` function has been through a facelift, but right now, when we
    are creating our lines we are still referring directly to our current elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead, let''s take advantage of the `barData` object and use the data keys
    of this object. This way we can completely avoid the need to refer directly to
    our explicit elements and instead depend on our data source as the source of information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Perfect! Now any change in our `barData` object will define the elements that
    will get rendered initially when the application starts. We just cut down the
    number of changes users will need to do to two.
  prefs: []
  type: TYPE_NORMAL
- en: Further streamlining our code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We are in much better shape now than when we started. Originally there where
    three places in our code that referred directly to hardcoded values for our chart
    information. With the last update we reduced it to two (once within the HTML file
    and once in our data source).
  prefs: []
  type: TYPE_NORMAL
- en: It's time for us to remove one more hardcoded instance. Let's remove our extra
    canvases and create them dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: 'So let''s start by removing our chart canvas elements from the HTML file and
    setting up an ID to our `<div>` tag (delete the highlighted code snippet):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: By the way, we added an ID for our `<div>` containing the layers so we can easily
    access it and change things within JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that there isn''t any canvas for our layers, we want to dynamically create
    them only when we draw the chart for the first time (this happens in the `drawChart`
    function with the new `for` loop we just created in the *Optimizing the drawChart
    function* section in the previous recipe):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Refresh your HTML file and you will find our canvas elements looking exactly
    the way they did before. We have one last thing to sort out to truly make this
    application dynamic, and that is our controllers that right now are hardcoded
    in the HTML file.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the radio buttons dynamically
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Yet another section that could be dynamic is our creation of radio buttons.
    So let''s start with removing our radio buttons from the HTML file and adding
    an ID to our wrapper (delete the highlighted code snippet):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Back into our HTML file let''s create a function that creates new radio buttons.
    We will call it the `appendRadioButton` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Last but not the least let''s draw our new button right before we start interacting
    with it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we are not integrating the two `for` loops together. Even though
    it might look like the same thing, the separation is needed. It takes JavaScript
    some time, a few nanoseconds, to actually render the elements to the screen, and
    as such by separating our loops we are giving the browser a chance to catch up.
    The separation between creating the elements and manipulating the elements is
    present mainly to give JavaScript a chance to render the HTML file before interacting
    with the created elements.
  prefs: []
  type: TYPE_NORMAL
- en: Great job! We just finished updating our content to make it totally dynamic.
    Now that everything is controlled through one location, that is the data source,
    we are ready to start exploring layered canvas logic in the following recipes.
  prefs: []
  type: TYPE_NORMAL
- en: Moving to an OOP perspective
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our application has been developing with a growing momentum. It's time for us
    to stop that by changing our chart to be more OOP conducive. In this recipe we
    will clean up our code some more and convert some of it into objects. We will
    continue from where we left off in our previous recipe, *Stacking graphical layers*.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first step is to get our latest source files: `06.01.layers.optimized.html`
    and `06.01.layers.optimized.js`. We will rename them and add our animation logic.
    Beyond changing the references on our HTML file we will not change anything else
    in our HTML file but focus our attention into the JavaScript file.'
  prefs: []
  type: TYPE_NORMAL
- en: One of the simplest ways of creating objects in JavaScript is by using functions.
    We can create a function and refer within the function name to `this` and by doing
    that we can treat the function as an object (more details in the *How it works...*
    section of this recipe).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s jump right in and start converting our code to be more OOP friendly:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We start our code changes in the JavaScript file. Create the `LineChart` constructor
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s update all of our functions to be prototypes of the `LineChart` function
    (our pseudo class):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s take a look at the really difficult part. We need to refer to all
    functions and object variables with `this`. For a full list of changes please
    review the source files (as we don''t want to take up too many pages just for
    this). Here is a small sample:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'In our application so far, to deal with radio buttons we created only one callback
    function that is set to all the radio buttons. When the user clicks on our radio
    buttons, an event is triggered. One issue will arise as our scope inside the events
    will break because `this` will be a `this` reference of something else and not
    our main object. Radio buttons have their own scope (their own `this` reference).
    We want to force a scope change; to do that we will create a helper function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We will now rewrite the lines that trigger our event in our `LineChart` constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We will now rewrite our `init` function. We will create our data points in
    it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Delete all global variables.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Surprising but that's it; you have just moved all of your logic into an object.
    We don't have any global variables left in our application, making it much easier
    to have more than one chart at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We kept our changes at this stage to a minimum. JavaScript is an object-oriented
    programing language, and as such we can take advantage of that by wrapping all
    of our functions into a new class. We start by creating a constructor function.
    This function will be used as our object type/name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'To create object variables we will refer to the constructor variables with
    `this`. The `this` operator is a dynamic name that always refers to the current
    scope. The current scope within an object is the object itself; in our case the
    `MyFirstObject` function will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: You can still create variables using the regular variable definition inside
    of functions, but there, scope would not be an object scope but instead, the scope
    would be only within that function. As such whenever you want to create variables
    that are shared throughout an object you must create them and refer to them with
    a leading `this` reference.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to rename all of our functions to be prototypes of the new
    class (function) we created. This way our functions will belong to the new object
    we are creating. We want the transition of our global variables of the past to
    become object variables belonging to the current object. Each time we want to
    refer to an object variable (property), we need to explicitly let JavaScript know
    by directing JavaScript to our object using the `this` directive. For example,
    if we want to refer to the `sampleVar` variable we would approach it in the following
    way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We had only one problem and that was when we introduced other objects into our
    code. The directive `this` needs to know the scope of its location to know which
    object we are referring to. In the situation of using events, our expectations
    of `this` referring to our object will not be true. Actually when dealing with
    `this` within an event listener, the `this` directive would always refer to the
    element being listened to, also known as the one being manipulated. As such, adding
    events to a radio button will produce a result of breaking our scope. To solve
    this problem, we create a function that will bind our scope to the listener. The
    `bind` method binds our function to our current scope. Even though by default,
    a listener would have the scope of what it is listening to, we are forcing the
    scope to stay on our object making our code work better for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'This leaves us with our last task. We need to create a new instance of our
    object. By creating a new instance we will activate all the work we did so far.
    The steps involved with creating a new object are the same as creating other base
    objects, only this time around we are using our constructor function name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The real test of our object will be if we can create more than one instance
    of our chart. Right now we can't, so we will need to do a few more changes to
    our logic to make it work.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although right now we have a working OOP object, it's not really optimized and
    it can use some refining. As we are in one scope, we can revisit and rewire what
    can be sent and what can depend on internal variables. We will explore this next
    task in this section of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Moving our base canvas element into our constructor
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s start by moving from the `drawChart` function. The following logic will
    fetch the base canvas and create a global variable within our new constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This will be followed by replacing the associated lines in the `drawChart`
    method with a reference to our newly created `baseCanvas` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that we removed the function parameters from our `fillChart` method
    as we can pass them internally now within the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: I strongly encourage you to continue and optimize the rest of the functions
    in this same manner, but for our sample let's continue on to the next topic.
  prefs: []
  type: TYPE_NORMAL
- en: Creating all the HTML components dynamically
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Why would we want to create our controllers and base canvas dynamically as well?
    Because we created some of our classes in advance, we are forced to have only
    one object in every HTML page. If we had dynamically created the controllers or
    passed the class information, we could enable the creation of more than one controller
    in our application. As we have so many elements that we are creating dynamically,
    it seems logical to continue in this path. Let's first create the remaining two
    elements dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by removing the inner canvas details from our HTML page (delete
    the highlighted code snippet):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We are going to start inserting the controller class within our global `<div>`
    tag that will be used for our canvas. We need to update our CSS information for
    the controllers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'OK. We are now ready to do some code updates to our constructor. The highlighted
    code snippets are the updates that should be implemented next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We want to start our `LineChart` object by sending into it the `<div>` tag
    ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: If you refresh your screen, all this hard work should be invisible. If everything
    is still working the way it did before we started to make changes, then well done,
    you've just completed the conversion of your chart to be smart and dynamic.
  prefs: []
  type: TYPE_NORMAL
- en: Removing the lose ends
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Although we extracted all of our external canvas and controllers and everything
    is working, we still are referring to internal canvas elements and radio buttons
    in a way that can break them. If we try to create a mirror chart right next to
    them to solve this problem, we will need to look through all our new elements
    and append to their name a unique key (we can use the `div id` element as that
    key as there can only be one `<div>` tag with the same ID in any HTML application).
    To save us some pages, I''ll just show you the basic logic here but grab the latest
    code bundle to find all the updates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'I''ve created two helper functions and their role is simple: to rename `<div>`
    tag/class/radio buttons by adding the main `<div>` tag ID into their name. This
    way we won''t have duplicate elements. All that is left is to locate all the areas
    where we are creating elements (we are creating canvas in the `drawChart` function
    and radio buttons in our constructor, but we interact with them in a few functions).
    Search for the changes where the `this.extractID` or `this.wrapID` methods are
    called and understand why they are being called.'
  prefs: []
  type: TYPE_NORMAL
- en: Testing our work by creating two charts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To make life harder, we are going to create the same exact chart twice using
    the same data sources (as that is a good edge case, so if that works any chart
    would work). Update the HTML file and add two `<div>` tags and update the CSS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'In our `init` function let''s set up both charts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Yes! We have two interactive charts working at the same time based on the same
    code base. Good job! And don't worry, the rest of this chapter is going to be
    much easier.
  prefs: []
  type: TYPE_NORMAL
- en: Animating independent layers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After a few really hard recipes let's do something fun and easy; let's add some
    animation to our chart and add some fade-ins and delays.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The core logic of our application was built in the previous two recipes *Stacking
    graphical layers* and *Moving to an OPP perspective*. We are in great shape so
    it will be extremely easy for us to expand and create content and add it into
    our application. We will make few very slight updates to our latest HTML file,
    mainly deleting things we don't need and then it's all JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Grab the latest files from our last sample (`06.02.objects.optimized.html` and
    `06.02.objects.optimized.js`) and let's continue.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our goal in the next few steps is to remove the code that is not required and
    then build our layered animations. Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the HTML, CSS, and `<div>` tags that are not required (delete the highlighted
    code snippets):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the new `Animator` constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the `add` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the internal `_animate` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new `Animate` object within the `LineChart` constructor method and
    animate key components:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Add animation to canvas elements in the `drawChart` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: When you run the webpage again you will find a fade-in of the separate layers.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/3707OT_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start by looking into our `Animator` constructor. We start with a few
    variables in our constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: These variables are the key to everything else. The `animQue` array will store
    each new animation request we make. The `refreshRate` property will control how
    often our animation will update. The more often it updates the smoother our animation
    will be (the higher the value in the refresh rate the less stress on user's system).
    For example, if we want to have a few animations, one in a smoother setting and
    others with a lower refresh rate, we can set two separate `Animator` classes with
    different refresh rates.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `add` method takes in all the necessary information to animate a property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Each element sent in to animate is then converted into a reference object that
    will be used when animations are running and pushed into our `animQue` array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: storing within the queue all the information we will need to animate an element,
    from the object's current status to how much of a change should be made each interval.
    On top of that we added a delay option enabling us to start the animation later.
  prefs: []
  type: TYPE_NORMAL
- en: 'We control the creation of intervals only in this function so until this function
    is called, there will be no interval running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Now it''s time for the internal logic of our object. The `_animate` method
    is called internally for as long as there is something to animate. In other words,
    as long as there is something in the `animQue` array. It loops through all the
    `animQue` array elements and goes through a few tests per element:'
  prefs: []
  type: TYPE_NORMAL
- en: If the element has a delay set, it will downgrade the delay value by the `refreshRate`
    property such that the delay will become smaller during each loop until it will
    be zero or less. When that happens the next step will trigger.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that the delay is complete, the `_animate` method changes gear. It starts
    to animate the objects within the `animQue` array for as long as the value of
    `data.crt` is lesser than `data.to`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The interval will continue one more time before testing to remove our element
    from the array. The separate step here is to help us avoid adding an `if` statement
    within our core logic reducing the complexity of our `for` loop. As we only need
    to test this once, we can absorb the cost of one extra loop cycle. In this extra
    cycle, we force the exact final value to our object and remove it from the animation
    queue.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This is the only strange logic, where we force the value of our loop variable
    down:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: In this code we are removing our element. As soon as we remove our element our
    current value of `i` will be one value larger than it should be, as our object
    has shrunk. To solve this problem, we need to force down the value to reset it
    back to the new current index.
  prefs: []
  type: TYPE_NORMAL
- en: 'Last but not the least, at the end of each update we check to see if there
    is anything in our array. If the array is empty, it''s time for us to remove the
    interval. We want to avoid having an interval running when it''s not needed. Next
    time the `add` method is triggered, it will restart the interval:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: That's the core of our logic and now it's time to create a new `animator` object
    and start sending elements that we want to animate. Play around with it, animate
    other things, and find your favorite animation balance between speed, delay, and
    properties you want to animate. This `animator` class is the base of all animation
    libraries, although our sample is more minimal and has more chances of user overkill
    such as sending the same object multiple times.
  prefs: []
  type: TYPE_NORMAL
- en: Adding an interactive legend
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although we created a legend in the past, our legend was bound to be non-interactive
    as we had no way to move it around. In this sample, we will create a quick and
    easy legend that will update its position and fade in and fade out when a user
    rolls over our chart.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Grab the latest files from our previous recipe, `06.03.fade.html` and `06.03.fade.js`,
    and let's jump right in. We will hardcode our values in this example, but a more
    modular approach of extracting elements that would be dynamic is a great way to
    make this class reusable.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This time around we will create a method in the `LineChart` object that will
    create legends for us. Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `createLegend` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the `updateLegend` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step for us is to create a few methods that will be used as event
    listeners. Let''s add a few listeners to control our animation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The methods we created just now are ready to be linked to a callback method
    such as an `onmouseover` or `onmouseout` event of our `mainDiv`. We will bind
    our scope back into our main object and trigger the methods we created earlier
    when the user triggers these built-in events. Let''s register our listeners in
    the constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Add into the code a variable that will count how many bars are there in the
    chart in the `drawChart` update code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Well done! When you refresh your browser you will see a legend fading in/out
    and repositioning based on our mouse moves.
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/3707OT_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The logic this time around is simple as our application already is nicely set
    and optimized. Our `createLegend` method creates for us a new canvas area that
    we can use for our legend. I've added some hardcoded values into it, but it would
    be a good idea to extract them into our `chartInfo` variable.
  prefs: []
  type: TYPE_NORMAL
- en: The only thing that requires explanation is the logic involved with the layout
    of the legend. We need to know how many items our chart contains to avoid looping
    through the data source again or asking the user to add this information. We can
    calculate this information the first time we loop through the user-generated data
    and thus update it to have our total items within it.
  prefs: []
  type: TYPE_NORMAL
- en: We set up our method in a way that would make it easy for us to actually put
    dynamic data directly into our chart. I've left that challenge open for you to
    explore and set up the ground work for it.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One more thing to note is, if you search hard and stress test our `Animator`
    class in this example, you will find that its not hundred percent optimized. If
    we send to the `Animator` class the same object with conflicting instructions,
    it will not automatically terminate the conflict. Instead, it will run through
    both until completion (for example, it will fade-out and fade-in at the same time;
    it will not break our application but it will create unwanted outcomes). To solve
    problems such as this one, we would need to modify our `Animator` class to override
    animations that are in conflict.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s fix the animation conflicts by checking that our animation queue does
    not have the same object with the same property animating already. We will create
    a `find` function to help us find in the `animQue` property the index of a duplicate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'The function will scan through our `animQue` array and locate duplications.
    If a match is found, the index value will be returned. If not, `-1` will be returned.
    Now it''s time to update our `add` method to use this new `find` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Great! Problem solved! Although we have not addressed the dynamic legend in
    this example, we are going to create a new direction for our legend that will
    be just as dynamic and maybe a bit more in our next recipe, *Creating a context-aware
    legend*.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a context-aware legend
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our goal will be to create a legend that updates based on what is under the
    user's mouse cursor as they roll over our application. Based on the mouse position
    of the user, we will update our legend to reflect the information that is under
    the user's mouse.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Grab the latest files from the previous recipe: `06.04.legend.html` and `06.04.legend.js`.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We aren''t going to change anything in the HTML files so let''s jump right
    into the JavaScript and build out our dynamic legend:'
  prefs: []
  type: TYPE_NORMAL
- en: 'From the `ChartLine` constructor, remove rollover/rollout events as we want
    to keep our legend always visible:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the `createLegend` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the method `updateLegend`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Change the event listener `onMouseMoveArea`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to add the step size into our data. This variable should be calculated
    dynamically as there is no need for the user to know this information if we can
    calculate it. As such, we will add this calculation to our `chartInfo` object
    when we calculate the step size in the `fillChart` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Last but not the least, let''s add our canvas information directly into our
    `barData` object so we can easily interact with it (added in the `drawChart` function):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: We should be all set. When you run the page again, your mouse should be in control
    of the information provided by the legend based on the exact coordinate you are
    on.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the last two steps of the previous section of this recipe, we add a few helper
    variables to help us create our mouse move logic. This is an interesting part
    because in addition in this sample we are asking our canvas for pixel information
    for the first time. We will focus our attention mainly on the logic within the
    `onMouseMoveArea` event listener.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by establishing the boundaries of our canvas area:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'This will be followed by a quick calculation of the current area in the chart
    we are in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: If we are out of the area, our `currentXIndex` variable will remain `-1`, while
    if we are in the area, we will get a value between `0` and the highest possible
    value based on the number of steps in the data source. We will send this value
    to our newly updated `updateLegend` method that will append the actual value of
    that index information from the data source into the rendering of the legend.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is a `for` loop where we loop through our data to test our canvas
    elements to see if they are opaque or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Only if the data returned confirms that there is content under the mouse pointer,
    we will add that ID into the `renderList` object. The `renderList` object is going
    to be our hub; it will control the legend data fields to be sent to the `updateLegend`
    method. If our mouse is above an element that is drawn then we will showcase the
    legend information related to the user's rollover; if not, we won't.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will update the way we call the `updateLegend` method, but right before
    we send it to our new parameters, we want to confirm we are really sending something.
    If our helper (linker object) is empty, we will send instead the original object.
    That way, everything will render if no chart is under our mouse pointer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Time to take a peek at the changes within the `updateLegend` method. The first
    new thing comes right in the first line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: This is a nice coding trick that enables us to update our `ren` parameter. The
    way it works is very simple; the `||` operator will always return the first true
    value it sees. In our case if the `ren` parameter is empty, or zero, or false
    it would return the value in `this.barData`. The logic is simple, if the `ren`
    parameter has content, it will remain the same while if it's empty the `this.barData`
    property will be set within the `ren` variable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: This is really the magic of this whole recipe. Instead of looping through the
    `this.barData` property we are looping through the key object that contains all
    the items we want to render. All that is left to do is to add the data when adding
    the text if there is a valid index listed.
  prefs: []
  type: TYPE_NORMAL
- en: There you go! We just added a really cool dynamic legend that changes as the
    user explores our chart.
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/3707OT_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
