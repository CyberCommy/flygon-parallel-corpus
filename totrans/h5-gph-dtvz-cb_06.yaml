- en: Chapter 6. Bringing Static Things to Life
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Stacking graphical layers
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moving to an OOP perspective
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Animating independent layers
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding an interactive legend
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a context-aware legend
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until now, the importance of keeping things organized and clean wasn't as great
    as that of getting our projects done as we had relatively small projects. This
    chapter will break us into a few new habits by first making everything dynamic
    followed by creating a more object-oriented program so it's easier for us to separate
    tasks and reduce our code footprint. After all this hard work, we will revisit
    our application and start adding extra logic geared at making our application
    animated layer by layer.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: This chapter is a great resourse for refactoring practice. In the first half
    of this chapter, we will be focused on improving our code structure to make it
    possible for us to have the level of control we will need in the second half of
    the chapter.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Stacking graphical layers
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we can do any real animations on our canvas we really need to rethink
    the concept of building everything on one canvas layer. Once a canvas element
    is drawn, it's incredibly hard to create subtle small changes to it, such as fade-ins
    for specific elements. We will revisit one of our famous charts, the bar chart,
    which we played around with and enhanced many times throughout the earlier chapters.
    In this chapter, our goal will be to break the logic apart and make it more modular.
    In this recipe we will separate layers. Each layer will give us more control later
    when we are ready to animate.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Start by grabbing the latest files from the previous chapter: `05.02.line-revisit.html`
    and `05.02.line-revisit.js`.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following changes are made to the HTML file:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the HTML file to incorporate more canvas elements (one per drawn line):'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Add a CSS script so the layers will be stacked:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Let's move into the JavaScript file to update it.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a `window.onload` callback function (changes highlighted in the code snippet):'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Remove the variable `context` from global scope (delete the highlighted code
    snippet):'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Consolidate all bar line information into one object for easier control (delete
    all the highlighted code snippets):'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Remove all canvas logic from the `init` function and add it to the `drawChart`
    function:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Update references to the new data object in the `init` function:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the `drawChart` function, extract the logic of line creation to an external
    function (delete the highlighted code snippets):'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Change the logic in the `onChangedRadio` callback function. Instead of what
    it was doing so far let''s have it trigger a call to the `changeLineView` function
    (we will create that function next):'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Create the function `changeLineView`:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: When you run your HTML file after all these changes, you should see exactly
    the same thing as you did before we started making all these changes. If that's
    true then you are in a great place. However, we can't visually see any change
    yet.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The heart of this recipe is our HTML file that enables us to layer canvas elements
    on top of each other, and as our canvas is by default transparent, we can see
    through to the elements that are under it. After our canvas is layered with four
    layers, it''s time for us to separate our background from our lines and as such
    we want to put all of our chart background information right into the base canvas:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'With each line layer, we are using a preconfigured canvas element that is already
    set:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The first parameter is both the ID of our canvas and the key we are using in
    our new object that stores our line information (to keep our code simple):'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In this data object we have exactly the same number of elements as we do in
    our canvas with the exact same names. This way we can very easily fetch information
    without using extra variables or conditions. This ties in to the logic of creating/updating
    lines:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We didn''t change the core logic of our line but redirected the logic into
    the context of the current line:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This way we can extract any direct mention of a year or element without referring
    to element names directly. This way we can add or remove elements and we would
    only need to add another canvas in our HTML file, add new properties, and finish
    off by adding the line in our creating function. That is still a lot, so how about
    we continue and optimize this code before we move on to more creative lands?
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our final goal is this recipe is to help minimize the number of changes the
    user needs to do to create lines. Currently to add more lines the user would need
    to make changes in three places. The next few optimization tricks will help us
    reduce the number of steps it takes to add/remove lines.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing the drawChart function
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Our `drawChart` function has been through a facelift, but right now, when we
    are creating our lines we are still referring directly to our current elements:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Instead, let''s take advantage of the `barData` object and use the data keys
    of this object. This way we can completely avoid the need to refer directly to
    our explicit elements and instead depend on our data source as the source of information:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Perfect! Now any change in our `barData` object will define the elements that
    will get rendered initially when the application starts. We just cut down the
    number of changes users will need to do to two.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: Further streamlining our code
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We are in much better shape now than when we started. Originally there where
    three places in our code that referred directly to hardcoded values for our chart
    information. With the last update we reduced it to two (once within the HTML file
    and once in our data source).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: It's time for us to remove one more hardcoded instance. Let's remove our extra
    canvases and create them dynamically.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: 'So let''s start by removing our chart canvas elements from the HTML file and
    setting up an ID to our `<div>` tag (delete the highlighted code snippet):'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: By the way, we added an ID for our `<div>` containing the layers so we can easily
    access it and change things within JavaScript.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that there isn''t any canvas for our layers, we want to dynamically create
    them only when we draw the chart for the first time (this happens in the `drawChart`
    function with the new `for` loop we just created in the *Optimizing the drawChart
    function* section in the previous recipe):'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Refresh your HTML file and you will find our canvas elements looking exactly
    the way they did before. We have one last thing to sort out to truly make this
    application dynamic, and that is our controllers that right now are hardcoded
    in the HTML file.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: Creating the radio buttons dynamically
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Yet another section that could be dynamic is our creation of radio buttons.
    So let''s start with removing our radio buttons from the HTML file and adding
    an ID to our wrapper (delete the highlighted code snippet):'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Back into our HTML file let''s create a function that creates new radio buttons.
    We will call it the `appendRadioButton` function:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Last but not the least let''s draw our new button right before we start interacting
    with it:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Notice that we are not integrating the two `for` loops together. Even though
    it might look like the same thing, the separation is needed. It takes JavaScript
    some time, a few nanoseconds, to actually render the elements to the screen, and
    as such by separating our loops we are giving the browser a chance to catch up.
    The separation between creating the elements and manipulating the elements is
    present mainly to give JavaScript a chance to render the HTML file before interacting
    with the created elements.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: Great job! We just finished updating our content to make it totally dynamic.
    Now that everything is controlled through one location, that is the data source,
    we are ready to start exploring layered canvas logic in the following recipes.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: Moving to an OOP perspective
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our application has been developing with a growing momentum. It's time for us
    to stop that by changing our chart to be more OOP conducive. In this recipe we
    will clean up our code some more and convert some of it into objects. We will
    continue from where we left off in our previous recipe, *Stacking graphical layers*.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first step is to get our latest source files: `06.01.layers.optimized.html`
    and `06.01.layers.optimized.js`. We will rename them and add our animation logic.
    Beyond changing the references on our HTML file we will not change anything else
    in our HTML file but focus our attention into the JavaScript file.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: One of the simplest ways of creating objects in JavaScript is by using functions.
    We can create a function and refer within the function name to `this` and by doing
    that we can treat the function as an object (more details in the *How it works...*
    section of this recipe).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s jump right in and start converting our code to be more OOP friendly:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: 'We start our code changes in the JavaScript file. Create the `LineChart` constructor
    method:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Let''s update all of our functions to be prototypes of the `LineChart` function
    (our pseudo class):'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now let''s take a look at the really difficult part. We need to refer to all
    functions and object variables with `this`. For a full list of changes please
    review the source files (as we don''t want to take up too many pages just for
    this). Here is a small sample:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In our application so far, to deal with radio buttons we created only one callback
    function that is set to all the radio buttons. When the user clicks on our radio
    buttons, an event is triggered. One issue will arise as our scope inside the events
    will break because `this` will be a `this` reference of something else and not
    our main object. Radio buttons have their own scope (their own `this` reference).
    We want to force a scope change; to do that we will create a helper function:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We will now rewrite the lines that trigger our event in our `LineChart` constructor:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We will now rewrite our `init` function. We will create our data points in
    it:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Delete all global variables.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Surprising but that's it; you have just moved all of your logic into an object.
    We don't have any global variables left in our application, making it much easier
    to have more than one chart at the same time.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We kept our changes at this stage to a minimum. JavaScript is an object-oriented
    programing language, and as such we can take advantage of that by wrapping all
    of our functions into a new class. We start by creating a constructor function.
    This function will be used as our object type/name:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'To create object variables we will refer to the constructor variables with
    `this`. The `this` operator is a dynamic name that always refers to the current
    scope. The current scope within an object is the object itself; in our case the
    `MyFirstObject` function will look as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: You can still create variables using the regular variable definition inside
    of functions, but there, scope would not be an object scope but instead, the scope
    would be only within that function. As such whenever you want to create variables
    that are shared throughout an object you must create them and refer to them with
    a leading `this` reference.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to rename all of our functions to be prototypes of the new
    class (function) we created. This way our functions will belong to the new object
    we are creating. We want the transition of our global variables of the past to
    become object variables belonging to the current object. Each time we want to
    refer to an object variable (property), we need to explicitly let JavaScript know
    by directing JavaScript to our object using the `this` directive. For example,
    if we want to refer to the `sampleVar` variable we would approach it in the following
    way:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We had only one problem and that was when we introduced other objects into our
    code. The directive `this` needs to know the scope of its location to know which
    object we are referring to. In the situation of using events, our expectations
    of `this` referring to our object will not be true. Actually when dealing with
    `this` within an event listener, the `this` directive would always refer to the
    element being listened to, also known as the one being manipulated. As such, adding
    events to a radio button will produce a result of breaking our scope. To solve
    this problem, we create a function that will bind our scope to the listener. The
    `bind` method binds our function to our current scope. Even though by default,
    a listener would have the scope of what it is listening to, we are forcing the
    scope to stay on our object making our code work better for us.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: 'This leaves us with our last task. We need to create a new instance of our
    object. By creating a new instance we will activate all the work we did so far.
    The steps involved with creating a new object are the same as creating other base
    objects, only this time around we are using our constructor function name:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The real test of our object will be if we can create more than one instance
    of our chart. Right now we can't, so we will need to do a few more changes to
    our logic to make it work.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although right now we have a working OOP object, it's not really optimized and
    it can use some refining. As we are in one scope, we can revisit and rewire what
    can be sent and what can depend on internal variables. We will explore this next
    task in this section of the chapter.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Moving our base canvas element into our constructor
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s start by moving from the `drawChart` function. The following logic will
    fetch the base canvas and create a global variable within our new constructor:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This will be followed by replacing the associated lines in the `drawChart`
    method with a reference to our newly created `baseCanvas` object:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Notice that we removed the function parameters from our `fillChart` method
    as we can pass them internally now within the method:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: I strongly encourage you to continue and optimize the rest of the functions
    in this same manner, but for our sample let's continue on to the next topic.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: Creating all the HTML components dynamically
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Why would we want to create our controllers and base canvas dynamically as well?
    Because we created some of our classes in advance, we are forced to have only
    one object in every HTML page. If we had dynamically created the controllers or
    passed the class information, we could enable the creation of more than one controller
    in our application. As we have so many elements that we are creating dynamically,
    it seems logical to continue in this path. Let's first create the remaining two
    elements dynamically.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by removing the inner canvas details from our HTML page (delete
    the highlighted code snippet):'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We are going to start inserting the controller class within our global `<div>`
    tag that will be used for our canvas. We need to update our CSS information for
    the controllers:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'OK. We are now ready to do some code updates to our constructor. The highlighted
    code snippets are the updates that should be implemented next:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We want to start our `LineChart` object by sending into it the `<div>` tag
    ID:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: If you refresh your screen, all this hard work should be invisible. If everything
    is still working the way it did before we started to make changes, then well done,
    you've just completed the conversion of your chart to be smart and dynamic.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Removing the lose ends
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Although we extracted all of our external canvas and controllers and everything
    is working, we still are referring to internal canvas elements and radio buttons
    in a way that can break them. If we try to create a mirror chart right next to
    them to solve this problem, we will need to look through all our new elements
    and append to their name a unique key (we can use the `div id` element as that
    key as there can only be one `<div>` tag with the same ID in any HTML application).
    To save us some pages, I''ll just show you the basic logic here but grab the latest
    code bundle to find all the updates:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'I''ve created two helper functions and their role is simple: to rename `<div>`
    tag/class/radio buttons by adding the main `<div>` tag ID into their name. This
    way we won''t have duplicate elements. All that is left is to locate all the areas
    where we are creating elements (we are creating canvas in the `drawChart` function
    and radio buttons in our constructor, but we interact with them in a few functions).
    Search for the changes where the `this.extractID` or `this.wrapID` methods are
    called and understand why they are being called.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Testing our work by creating two charts
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To make life harder, we are going to create the same exact chart twice using
    the same data sources (as that is a good edge case, so if that works any chart
    would work). Update the HTML file and add two `<div>` tags and update the CSS:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In our `init` function let''s set up both charts:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Yes! We have two interactive charts working at the same time based on the same
    code base. Good job! And don't worry, the rest of this chapter is going to be
    much easier.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: Animating independent layers
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After a few really hard recipes let's do something fun and easy; let's add some
    animation to our chart and add some fade-ins and delays.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The core logic of our application was built in the previous two recipes *Stacking
    graphical layers* and *Moving to an OPP perspective*. We are in great shape so
    it will be extremely easy for us to expand and create content and add it into
    our application. We will make few very slight updates to our latest HTML file,
    mainly deleting things we don't need and then it's all JavaScript.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: Grab the latest files from our last sample (`06.02.objects.optimized.html` and
    `06.02.objects.optimized.js`) and let's continue.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our goal in the next few steps is to remove the code that is not required and
    then build our layered animations. Perform the following steps:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove the HTML, CSS, and `<div>` tags that are not required (delete the highlighted
    code snippets):'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Create the new `Animator` constructor:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Create the `add` method:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Create the internal `_animate` method:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Create a new `Animate` object within the `LineChart` constructor method and
    animate key components:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Add animation to canvas elements in the `drawChart` method:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: When you run the webpage again you will find a fade-in of the separate layers.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/3707OT_06_01.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
- en: How it works...
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start by looking into our `Animator` constructor. We start with a few
    variables in our constructor:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: These variables are the key to everything else. The `animQue` array will store
    each new animation request we make. The `refreshRate` property will control how
    often our animation will update. The more often it updates the smoother our animation
    will be (the higher the value in the refresh rate the less stress on user's system).
    For example, if we want to have a few animations, one in a smoother setting and
    others with a lower refresh rate, we can set two separate `Animator` classes with
    different refresh rates.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `add` method takes in all the necessary information to animate a property:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Each element sent in to animate is then converted into a reference object that
    will be used when animations are running and pushed into our `animQue` array:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: storing within the queue all the information we will need to animate an element,
    from the object's current status to how much of a change should be made each interval.
    On top of that we added a delay option enabling us to start the animation later.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: 'We control the creation of intervals only in this function so until this function
    is called, there will be no interval running:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now it''s time for the internal logic of our object. The `_animate` method
    is called internally for as long as there is something to animate. In other words,
    as long as there is something in the `animQue` array. It loops through all the
    `animQue` array elements and goes through a few tests per element:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: If the element has a delay set, it will downgrade the delay value by the `refreshRate`
    property such that the delay will become smaller during each loop until it will
    be zero or less. When that happens the next step will trigger.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that the delay is complete, the `_animate` method changes gear. It starts
    to animate the objects within the `animQue` array for as long as the value of
    `data.crt` is lesser than `data.to`.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The interval will continue one more time before testing to remove our element
    from the array. The separate step here is to help us avoid adding an `if` statement
    within our core logic reducing the complexity of our `for` loop. As we only need
    to test this once, we can absorb the cost of one extra loop cycle. In this extra
    cycle, we force the exact final value to our object and remove it from the animation
    queue.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This is the only strange logic, where we force the value of our loop variable
    down:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: In this code we are removing our element. As soon as we remove our element our
    current value of `i` will be one value larger than it should be, as our object
    has shrunk. To solve this problem, we need to force down the value to reset it
    back to the new current index.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: 'Last but not the least, at the end of each update we check to see if there
    is anything in our array. If the array is empty, it''s time for us to remove the
    interval. We want to avoid having an interval running when it''s not needed. Next
    time the `add` method is triggered, it will restart the interval:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: That's the core of our logic and now it's time to create a new `animator` object
    and start sending elements that we want to animate. Play around with it, animate
    other things, and find your favorite animation balance between speed, delay, and
    properties you want to animate. This `animator` class is the base of all animation
    libraries, although our sample is more minimal and has more chances of user overkill
    such as sending the same object multiple times.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Adding an interactive legend
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although we created a legend in the past, our legend was bound to be non-interactive
    as we had no way to move it around. In this sample, we will create a quick and
    easy legend that will update its position and fade in and fade out when a user
    rolls over our chart.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Grab the latest files from our previous recipe, `06.03.fade.html` and `06.03.fade.js`,
    and let's jump right in. We will hardcode our values in this example, but a more
    modular approach of extracting elements that would be dynamic is a great way to
    make this class reusable.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This time around we will create a method in the `LineChart` object that will
    create legends for us. Perform the following steps:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `createLegend` method:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Create the `updateLegend` method:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The next step for us is to create a few methods that will be used as event
    listeners. Let''s add a few listeners to control our animation:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The methods we created just now are ready to be linked to a callback method
    such as an `onmouseover` or `onmouseout` event of our `mainDiv`. We will bind
    our scope back into our main object and trigger the methods we created earlier
    when the user triggers these built-in events. Let''s register our listeners in
    the constructor:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Add into the code a variable that will count how many bars are there in the
    chart in the `drawChart` update code:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Well done! When you refresh your browser you will see a legend fading in/out
    and repositioning based on our mouse moves.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/3707OT_06_02.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
- en: How it works...
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The logic this time around is simple as our application already is nicely set
    and optimized. Our `createLegend` method creates for us a new canvas area that
    we can use for our legend. I've added some hardcoded values into it, but it would
    be a good idea to extract them into our `chartInfo` variable.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: The only thing that requires explanation is the logic involved with the layout
    of the legend. We need to know how many items our chart contains to avoid looping
    through the data source again or asking the user to add this information. We can
    calculate this information the first time we loop through the user-generated data
    and thus update it to have our total items within it.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: We set up our method in a way that would make it easy for us to actually put
    dynamic data directly into our chart. I've left that challenge open for you to
    explore and set up the ground work for it.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One more thing to note is, if you search hard and stress test our `Animator`
    class in this example, you will find that its not hundred percent optimized. If
    we send to the `Animator` class the same object with conflicting instructions,
    it will not automatically terminate the conflict. Instead, it will run through
    both until completion (for example, it will fade-out and fade-in at the same time;
    it will not break our application but it will create unwanted outcomes). To solve
    problems such as this one, we would need to modify our `Animator` class to override
    animations that are in conflict.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s fix the animation conflicts by checking that our animation queue does
    not have the same object with the same property animating already. We will create
    a `find` function to help us find in the `animQue` property the index of a duplicate:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The function will scan through our `animQue` array and locate duplications.
    If a match is found, the index value will be returned. If not, `-1` will be returned.
    Now it''s time to update our `add` method to use this new `find` method:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Great! Problem solved! Although we have not addressed the dynamic legend in
    this example, we are going to create a new direction for our legend that will
    be just as dynamic and maybe a bit more in our next recipe, *Creating a context-aware
    legend*.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: Creating a context-aware legend
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our goal will be to create a legend that updates based on what is under the
    user's mouse cursor as they roll over our application. Based on the mouse position
    of the user, we will update our legend to reflect the information that is under
    the user's mouse.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Grab the latest files from the previous recipe: `06.04.legend.html` and `06.04.legend.js`.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We aren''t going to change anything in the HTML files so let''s jump right
    into the JavaScript and build out our dynamic legend:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: 'From the `ChartLine` constructor, remove rollover/rollout events as we want
    to keep our legend always visible:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Update the `createLegend` method:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Update the method `updateLegend`:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Change the event listener `onMouseMoveArea`:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'We need to add the step size into our data. This variable should be calculated
    dynamically as there is no need for the user to know this information if we can
    calculate it. As such, we will add this calculation to our `chartInfo` object
    when we calculate the step size in the `fillChart` method:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Last but not the least, let''s add our canvas information directly into our
    `barData` object so we can easily interact with it (added in the `drawChart` function):'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: We should be all set. When you run the page again, your mouse should be in control
    of the information provided by the legend based on the exact coordinate you are
    on.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the last two steps of the previous section of this recipe, we add a few helper
    variables to help us create our mouse move logic. This is an interesting part
    because in addition in this sample we are asking our canvas for pixel information
    for the first time. We will focus our attention mainly on the logic within the
    `onMouseMoveArea` event listener.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节配方的最后两个步骤中，我们添加了一些辅助变量来帮助我们创建鼠标移动逻辑。这是一个有趣的部分，因为在这个示例中，我们首次向画布请求像素信息。我们将主要关注`onMouseMoveArea`事件侦听器内的逻辑。
- en: 'We start by establishing the boundaries of our canvas area:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先要确定画布区域的边界：
- en: '[PRE67]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'This will be followed by a quick calculation of the current area in the chart
    we are in:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来将是对我们所在图表的当前区域进行快速计算：
- en: '[PRE68]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: If we are out of the area, our `currentXIndex` variable will remain `-1`, while
    if we are in the area, we will get a value between `0` and the highest possible
    value based on the number of steps in the data source. We will send this value
    to our newly updated `updateLegend` method that will append the actual value of
    that index information from the data source into the rendering of the legend.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们离开区域，我们的`currentXIndex`变量将保持为`-1`，而如果我们在区域内，我们将得到一个值，介于`0`和数据源步数的最大可能值之间。我们将把这个值发送到我们新更新的`updateLegend`方法中，该方法将把该索引信息的实际值从数据源附加到图例的渲染中。
- en: 'The next step is a `for` loop where we loop through our data to test our canvas
    elements to see if they are opaque or not:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是一个`for`循环，我们通过循环遍历我们的数据来测试我们的画布元素，看它们是否是不透明的：
- en: '[PRE69]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Only if the data returned confirms that there is content under the mouse pointer,
    we will add that ID into the `renderList` object. The `renderList` object is going
    to be our hub; it will control the legend data fields to be sent to the `updateLegend`
    method. If our mouse is above an element that is drawn then we will showcase the
    legend information related to the user's rollover; if not, we won't.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 只有返回的数据确认鼠标指针下有内容，我们才会将该ID添加到`renderList`对象中。`renderList`对象将成为我们的中心；它将控制要发送到`updateLegend`方法的图例数据字段。如果我们的鼠标位于绘制的元素上方，我们将展示与用户悬停相关的图例信息；如果没有，我们将不展示。
- en: 'We will update the way we call the `updateLegend` method, but right before
    we send it to our new parameters, we want to confirm we are really sending something.
    If our helper (linker object) is empty, we will send instead the original object.
    That way, everything will render if no chart is under our mouse pointer:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将更新调用`updateLegend`方法的方式，但在将其发送到新参数之前，我们要确认我们确实发送了一些东西。如果我们的辅助（链接对象）为空，我们将发送原始对象。这样，如果鼠标指针下没有图表，一切都会渲染：
- en: '[PRE70]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Time to take a peek at the changes within the `updateLegend` method. The first
    new thing comes right in the first line:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候来看看`updateLegend`方法内的变化了。第一件新事情就在第一行出现：
- en: '[PRE71]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: This is a nice coding trick that enables us to update our `ren` parameter. The
    way it works is very simple; the `||` operator will always return the first true
    value it sees. In our case if the `ren` parameter is empty, or zero, or false
    it would return the value in `this.barData`. The logic is simple, if the `ren`
    parameter has content, it will remain the same while if it's empty the `this.barData`
    property will be set within the `ren` variable.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很好的编码技巧，它使我们能够更新我们的`ren`参数。它的工作方式非常简单；`||`运算符将始终返回它看到的第一个真值。在我们的情况下，如果`ren`参数为空，或为零，或为假，它将返回`this.barData`中的值。逻辑很简单，如果`ren`参数有内容，它将保持不变，而如果为空，则`this.barData`属性将在`ren`变量中设置。
- en: '[PRE72]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: This is really the magic of this whole recipe. Instead of looping through the
    `this.barData` property we are looping through the key object that contains all
    the items we want to render. All that is left to do is to add the data when adding
    the text if there is a valid index listed.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这确实是整个配方的魔力所在。我们不是通过`this.barData`属性进行循环，而是通过包含我们要渲染的所有项目的键对象进行循环。在添加文本时，只需在添加文本时添加数据，如果有列出有效索引。
- en: There you go! We just added a really cool dynamic legend that changes as the
    user explores our chart.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！我们刚刚添加了一个非常酷的动态图例，随着用户探索我们的图表而变化。
- en: '![How it works...](img/3707OT_06_03.jpg)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/3707OT_06_03.jpg)'
