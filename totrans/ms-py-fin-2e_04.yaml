- en: The Importance of Linearity in Finance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nonlinear dynamics play a vital role in our world. Linear models are often employed
    in economics due to being easier to study and their easier modeling capabilities.
    In finance, linear models are widely used to help price securities and perform
    optimal portfolio allocation, among other useful things. One significant aspect
    of linearity in financial modeling is its assurance that a problem terminates
    at a globally-optimal solution.
  prefs: []
  type: TYPE_NORMAL
- en: In order to perform prediction and forecasting, regression analysis is widely
    used in the field of statistics to estimate relationships among variables. With
    an extensive mathematics library being one of Python’s greatest strength, Python
    is frequently used as a scientific scripting language to aid in these problems.
    Modules such as the SciPy and NumPy packages contain a variety of linear regression
    functions for data scientists to work with.
  prefs: []
  type: TYPE_NORMAL
- en: In traditional portfolio management, the allocation of assets follows a linear
    pattern, and investors have individual styles of investing. We can describe the
    problem of portfolio allocation as a system of linear equations, containing either
    equalities or inequalities. These linear systems can then be represented in a
    matrix form as *Ax=B*, where *A* is our known coefficient value, *B* is the observed
    result, and *x* is the vector of values that we want to find out. More often than
    not, *x* contains the optimal security weights to maximize our utility. Using
    matrix algebra, we can efficiently solve for *x* using either direct or indirect
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Examining the Capital Asset Pricing Model and the security market line
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Solving for the security market line using regression
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examining the APT model and performing a multivariate linear regression
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding linear optimization in portfolio allocation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing linear optimization using the Pulp package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the outcomes of linear programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to integer programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a linear integer programming model with binary conditions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Solving systems of linear equations with equalities using matrix linear algebra
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Solving systems of linear equations directly with LU, Cholesky, and QR decomposition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Solving systems of linear equations indirectly with the Jacobi and Gauss-Seidel
    method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Capital Asset Pricing Model and the security market line
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A lot of the financial literature devotes exclusive discussions to the **Capital
    Asset Pricing Model** (**CAPM**). In this section, we will explore key concepts
    that highlight the importance of linearity in finance.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the famous CAPM, the relationship between risk and rates of return in a
    security is described as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/90b9951f-98de-427b-9d67-6b9bc56c0e71.png)'
  prefs: []
  type: TYPE_IMG
- en: 'For a security, *i*, its returns are defined as *R[i]* and its beta as *β[i]*.
    The CAPM defines the return of the security as the sum of the risk-free rate, *R[f]*,
    and the multiplication of its beta with the risk premium. The risk premium can
    be thought of as the market portfolio''s excess returns exclusive of the risk-free
    rate. The following is a visual representation of the CAPM:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/a8ce88b0-498f-4c1e-be55-8212d1ecabbb.png)'
  prefs: []
  type: TYPE_IMG
- en: Beta is a measure of the systematic risk of a stock – a risk that cannot be
    diversified away. In essence, it describes the sensitivity of stock returns with
    respect to movements in the market. For example, a stock with a beta of zero produces
    no excess returns regardless of the direction the market moves in. It can only
    grow at a risk-free rate. A stock with a beta of 1 indicates that the stock moves
    perfectly with the market.
  prefs: []
  type: TYPE_NORMAL
- en: The beta is mathematically derived by dividing the covariance of returns between
    the stock and the market by the variance of the market returns.
  prefs: []
  type: TYPE_NORMAL
- en: The CAPM model measures the relationship between risk and stock returns for
    every stock in the portfolio basket. By outlining the sum of this relationship,
    we obtain combinations or weights of risky securities that produce the lowest
    portfolio risk for every level of portfolio return. An investor who wishes to
    receive a particular return would own one such combination of an optimal portfolio
    that provides the least risk possible. Combinations of optimal portfolios lie
    along a line called the **efficient frontier**.
  prefs: []
  type: TYPE_NORMAL
- en: Along the efficient frontier, there exists a tangent point that denotes the
    best optimal portfolio available and gives the highest rate of return in exchange
    for the lowest risk possible. This optimal portfolio at the tangent point is known
    as the **market portfolio**.
  prefs: []
  type: TYPE_NORMAL
- en: 'There exists a straight line drawn from the market portfolio to the risk-free
    rate. This line is called the **Capital Market Line** (**CML**). The CML can be
    thought of as the highest Sharpe ratio available among all the other Sharpe ratios
    of optimal portfolios. The **Sharpe ratio** is a risk-adjusted performance measure
    defined as the portfolio''s excess returns over the risk-free rate per unit of
    its risk in standard deviations. Investors are particularly interested in holding
    combinations of assets along the CML line. The following diagram illustrates the
    efficient frontier, the market portfolio, and the CML:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/c344df85-44e8-4b9a-bab2-317311a22093.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Another line of interest in CAPM studies is the **Security Market Line** (**SML**).
    The SML plots the asset''s expected returns against its beta. For a security with
    a beta value of 1, its returns perfectly match the market''s returns. Any security
    priced above the SML is deemed to be undervalued since investors expect a higher
    return given the same amount of risk. Conversely, any security priced below the
    SML is deemed to be overvalued, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/1905e49e-f52c-4fd5-a639-e33fd1115c03.png)'
  prefs: []
  type: TYPE_IMG
- en: Suppose we are interested in finding the beta, *β[i]*, of a security. We can
    regress the company's stock returns, *R[i]*, against the market's returns, *R[M]*,
    along with an intercept, *α*, in the form of the *R[i]=α+βR[M]* equation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following set of stock return and market return data measured
    over five time periods:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Time period** | **Stock returns** | **Market returns** |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 0.065 | 0.055 |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | 0.0265 | -0.09 |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | -0.0593 | -0.041 |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | -0.001 | 0.045 |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | 0.0346 | 0.022 |'
  prefs: []
  type: TYPE_TB
- en: 'Using the `stats` module of SciPy, we will perform a least-squares regression
    on the CAPM model, and derive the values of α and *β[i]* by running the following
    code in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `scipty.stats.linregress` function returns five values: the slope of the
    regression line, the intercept of the regression line, the correlation coefficient,
    the p-value for a hypothesis test with a null hypothesis of a zero slope, and
    the standard error of the estimate. We are interested in finding the slope and
    intercept of the line by printing the values of `beta` and `alpha`, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The beta of the stock is 0.5077 and the alpha is nearly zero.
  prefs: []
  type: TYPE_NORMAL
- en: 'The equation that describes the SML can be written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/a5b59b68-c605-4528-87d7-5ca98588efb1.png)'
  prefs: []
  type: TYPE_IMG
- en: The term *E[R[M]]−R[f]* is the market risk premium, and *E[R[M]]* is the expected
    return on the market portfolio. *R[f]* is the return on the risk-free rate, *E[R[i]]*
    is the expected return on asset, *i*, and *β[i]* is the beta of the asset.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose the risk-free rate is 5% and the market risk premium is 8.5%. What is
    the expected return of the stock? Based on the CAPM, an equity with a beta of
    0.5077 would have a risk premium of 0.5077×8.5%, or 4.3%. The risk-free rate is
    5%, so the expected return on the equity is 9.3%.
  prefs: []
  type: TYPE_NORMAL
- en: If the security is observed in the same time period to have a higher return
    (for example, 10.5%) than the expected stock return, the security can be said
    to be undervalued, since the investor can expect a greater return for the same
    amount of risk.
  prefs: []
  type: TYPE_NORMAL
- en: Conversely, should the return of the security be observed to have a lower return
    (for example, 7%) than the expected return as implied by the SML, the security
    can be said to be overvalued. The investor receives a reduced return while assuming
    the same amount of risk.
  prefs: []
  type: TYPE_NORMAL
- en: The Arbitrage Pricing Theory model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The CAPM suffers from several limitations, such as the use of a mean-variance
    framework and the fact that returns are captured by one risk factor – the market
    risk factor. In a well-diversified portfolio, the unsystematic risk of various
    stocks cancels out and is essentially eliminated.
  prefs: []
  type: TYPE_NORMAL
- en: The **Arbitrage Pricing Theory** (**APT**) model was put forward to address
    these shortcomings and offers a general approach of determining the asset prices
    other than the mean and variances.
  prefs: []
  type: TYPE_NORMAL
- en: The APT model assumes that the security returns are generated according to multiple
    factor models, which consist of a linear combination of several systematic risk
    factors. Such factors could be the inflation rate, GDP growth rate, real interest
    rates, or dividends.
  prefs: []
  type: TYPE_NORMAL
- en: 'The equilibrium asset pricing equation according to the APT model is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/90170a01-87f1-4d7d-8966-6afcd2921d6c.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, *E[R[i]]* is the expected rate of return on the *i* security, *α[i]* is
    the expected return on the *i* stock if all factors are negligible, *β[i,j]* is
    the sensitivity of the *i*^(th) asset to the *j*^(th) factor, and *F[j]* is the
    value of the *j*^(th) factor that influences the return on the *i* security.
  prefs: []
  type: TYPE_NORMAL
- en: Since our goal is to find all values of *α[i]* and *β*, we will perform a **multivariate
    linear regression** on the APT model.
  prefs: []
  type: TYPE_NORMAL
- en: Multivariate linear regression of factor models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many Python packages, such as SciPy, come with several variants of regression
    functions. In particular, the `statsmodels` package is a complement to SciPy with
    descriptive statistics and the estimation of statistical models. The official
    page for Statsmodels is [https://www.statsmodels.org](https://www.statsmodels.org).
  prefs: []
  type: TYPE_NORMAL
- en: 'If Statsmodels is not yet installed in your Python environment, run the following
    command to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: If you have an existing package installed, the `-U` switch tells `pip` to upgrade
    the selected package to the newest available version.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we will use the `ols` function of the `statsmodels` module
    to perform an ordinary least-squares regression and view its summary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assume that you have implemented an APT model with seven factors that
    return the values of *Y*. Consider the following set of data collected over nine
    time periods, *t[1]* to *t[9]*. *X*[1] to *X[7]* are independent variables observed
    at each period. The regression problem is therefore structured as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/028272c7-3f1d-46e8-8845-32c433ca2f6b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'A simple ordinary least-squares regression on values of *X* and *Y* can be
    performed with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s view the detailed statistics of the regression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The OLS regression results will output a pretty long table of statistical information.
    However, our interest lies in one particular section that gives us the coefficients
    of our APT model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `coef` column gives us the coefficient values of our regression for the *c* constant,
    and *X[1]* until *X[7]*. Similarly, we can use the `params` property to display
    these coefficients of interest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Both the function calls produce the same coefficient values for the APT model
    in the same order.
  prefs: []
  type: TYPE_NORMAL
- en: Linear optimization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the CAPM and APT pricing theories, we assumed linearity in the models and
    solved for expected security prices using regressions in Python.
  prefs: []
  type: TYPE_NORMAL
- en: As the number of securities in our portfolio increases, certain limitations
    are introduced as well. Portfolio managers would find themselves constrained by
    these rules in pursuing certain objectives mandated by investors.
  prefs: []
  type: TYPE_NORMAL
- en: Linear optimization helps overcome the problem of portfolio allocation. Optimization
    focuses on minimizing or maximizing the value of objective functions. Some examples
    include maximizing returns and minimizing volatility. These objectives are usually
    governed by certain regulations, such as a no short-selling rule, or limits on
    the number of securities to be invested.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, in Python, there is no single official package that supports
    this solution. However, there are third-party packages available with an implementation
    of the simplex algorithm for linear programming. For the purpose of this demonstration,
    we will use Pulp, an open source linear programming modeler, to assist us in this
    particular linear programming problem.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Pulp
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can obtain Pulp from [https://github.com/coin-or/pulp](https://github.com/coin-or/pulp).
    The project page contains a comprehensive list of documentation to help you get
    started with your optimization process.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may also obtain the Pulp package with the `pip` package manager:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: A maximization example with linear programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Suppose that we are interested in investing in two securities, *X* and *Y*.
    We would like to find out the actual number of units to invest for every three
    units of the security *X* and two units of the security *Y*, such that the total
    number of units invested is maximized, where possible. However, there are certain
    constraints on our investment strategy:'
  prefs: []
  type: TYPE_NORMAL
- en: For every 2 units of the security *X* invested and 1 unit of the security *Y*
    invested, the total volume must not exceed 100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For every unit of the securities *X* and *Y* invested, the total volume must
    not exceed 80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The total volume allowed to invest in the security *X* must not exceed 40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Short-selling is not allowed for securities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The maximization problem can be mathematically represented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/02a2f49c-93e7-40f6-a947-208df527a4e2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'subject to:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/b97a3c75-ad70-4c84-a5de-f1b995473e4c.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](Images/752f3101-6e8c-4def-92ea-8edc58ffa41d.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](Images/12d846a0-8f99-4a3a-b8ea-54b0c0d05e39.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](Images/71b1620c-2dbb-4d04-924e-3fc006dfc30b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'By plotting the constraints on an *x* by *y* graph, a set of feasible solutions
    can be seen, given by the shaded area:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/178c4e94-bb47-4d90-97d3-e72dcee6b704.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The problem can be translated into Python with the `pulp` package, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `LpVariable` function declares a variable to be solved. The `LpProblem`
    function initializes the problem with a text description of the problem and the
    type of optimization, which in this case is the maximization method. The `+=`
    operation allows an arbitrary number of constraints to be added, along with a
    text description. Finally, the `.solve()` method is called to begin performing
    linear optimization. To show the values solved by the optimizer, use the `.variables()`
    method to loop through each variable and print out its `varValue`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following output is generated when the code runs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The results show that obtaining the maximum value of 180 is possible when the
    value of *x* is 20 and *y* is 60 while fulfilling the given set of constraints.
  prefs: []
  type: TYPE_NORMAL
- en: Outcomes of linear programs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are three outcomes in linear optimization, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A local optimal solution to a linear program is a feasible solution with a closer
    objective function value than all other feasible solutions close to it. It may
    or may not be the **global optimal solution**, a solution that is better than
    every feasible solution.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A linear program is **infeasible** if a solution cannot be found.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A linear program is **unbounded** if the optimal solution is unbounded or is
    infinite.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integer programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the simple optimization problem we investigated earlier, *A maximization
    example with linear programming*, the variables were allowed to be continuous
    or fractional. What if the use of fractional values or results is not realistic?
    This problem is called the **linear integer programming** problem, where all the
    variables are restricted as integers. A special case of an integer variable is
    a binary variable that can either be 0 or 1\. Binary variables are especially
    useful in model decision-making when given a set of choices.
  prefs: []
  type: TYPE_NORMAL
- en: Integer programming models are frequently used in operational research to model
    real-world working problems. More often than not, stating nonlinear problems in
    a linear or even binary fashion requires more art than science.
  prefs: []
  type: TYPE_NORMAL
- en: A minimization example with integer programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Suppose we must go for 150 contracts in a particular over-the-counter exotic
    security from three dealers. Dealer *X* quoted $500 per contract plus handling
    fees of $4,000, regardless of the number of contracts sold. Dealer *Y* charges
    $450 per contract plus a transaction fee of $2,000\. Dealer *Z* charges $450 per
    contract plus a fee of $6,000\. Dealer *X* will sell at most 100 contracts, dealer
    *Y* at most 90, and dealer *Z* at most 70\. The minimum transaction volume from
    any dealer is 30 contracts if any are transacted with that dealer. How should
    we minimize the cost of purchasing 150 contracts?
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the `pulp` package, let''s set up the required variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `dealers` variable simply contains the dictionary identifiers that are used
    to reference lists and dictionaries later on. The `variable_costs` and `fixed_costs` variables
    are dictionary objects that contain the respective contract cost and fees charged
    by each dealer. The Pulp solver solves for the values of `quantities` and `is_orders`,
    which are defined by the `LpVariable` function. The `dicts()` method tells Pulp
    to treat the assigned variable as a dictionary object, using the `dealers` variable
    for referencing. Note that the `quantities` variable has a lower boundary (0)
    that prevents us from entering a short position in any securities. The `is_orders`
    values are treated as binary objects, indicating whether we should enter into
    a transaction with any of the dealers.
  prefs: []
  type: TYPE_NORMAL
- en: 'What is the best approach to modeling this integer programming problem? At
    first glance, it seems fairly straightforward by applying this equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/938c9cac-ca49-43ab-bfd7-b3447d480a2c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Where the following is true:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/982dfb3a-3cc6-4858-8a10-336823094b9b.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](Images/1c0a8992-5668-4ac8-9504-0e7e4ad4a537.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](Images/2ab9139e-96e8-4a5b-8111-2a5fe54c6242.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](Images/ee23bb15-cf12-4f08-8675-dcfe7de1a8b7.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](Images/76571b12-5400-47c7-bf0d-ed4f8c7f1976.png)'
  prefs: []
  type: TYPE_IMG
- en: The equation simply states that we want to minimize the total costs with the
    binary variable, *isOrder[i]*, to determine whether to account for the costs associated
    with buying from a specific dealer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s implement this model in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'What happens when we run the solver? Check it out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As it turned out, we were trying to perform multiplication on two unknown variables,
    `quantities` and `is_order`, which unknowingly led us to perform nonlinear programming.
    Such are the pitfalls encountered when performing integer programming.
  prefs: []
  type: TYPE_NORMAL
- en: How should we solve this problem? We can consider using **binary variables**,
    as shown in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Integer programming with binary conditions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another method for formulating the minimization objective is to place all unknown
    variables in a linear fashion such that they are additive:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/59f4559c-4f21-4482-980f-92ca0b30d1ba.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Comparing with the previous objective equation, we would obtain the same fixed
    cost values. However, the unknown variable, *quantity[i]*, remains in the first
    term of the equation. Hence, the *quantity[i]* variable is required to be solved
    as a function of *isOrder[i]*, such that the constraints are stated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/6e531ad8-a8c9-4945-ad24-45c1f84efa0d.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](Images/11c3eecb-48e5-43ec-adc9-f49f534d4932.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](Images/2fbd74dc-0c7b-4ff5-a0aa-57a03a8788c7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s apply these formulas in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'What happens when we try to run the solver? Let''s see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The output tells us that buying 90 contracts from dealer *Y* and 60 contracts
    from dealer *Z* gives us the lowest possible cost of $66,500 while fulfilling
    all other constraints.
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, careful planning is required in the design of integer programming
    models to arrive at an accurate solution in order for them to be useful in decision-making.
  prefs: []
  type: TYPE_NORMAL
- en: Solving linear equations using matrices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we looked at solving a system of linear equations with
    inequality constraints. If a set of systematic linear equations has constraints
    that are deterministic, we can represent the problem as matrices and apply matrix
    algebra. Matrix methods represent multiple linear equations in a compact manner
    while using existing matrix library functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we would like to build a portfolio that consists of three securities: *a*,
    *b*, and *c*. The allocation of the portfolio must meet certain constraints: it
    must consist of six units of a long position in the security *a*. With every two
    units of the security *a*, one unit of the security *b*, and one unit of the security *c *invested,
    the net position must be long four units. With every one unit of the security
    *a*, three units of the security *b*, and two units of thesecurity *c*invested,
    the net position must be long five units.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To find out the number of securities to invest in, we can frame the problem
    mathematically, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/305091a5-a752-4963-8a03-8c4274cd3c76.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](Images/310d1491-85a1-4798-9e64-4ce19f7632c1.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](Images/72498221-ef19-42a8-95d0-cfc4d9d0744c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'With all of the coefficients visible, the equations are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/2357e60f-d857-4038-99ca-e1d6889e49d0.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](Images/c0c87d82-37a1-4d52-8ca1-1f0d6340d24e.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](Images/b45e50af-e151-40bd-ba08-776f7971b4b4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s take the coefficients of the equations and represent them in a matrix
    form:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/534ad0ee-7490-4bb7-aadd-da72c240ceda.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The linear equations can now be stated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/802ae3dc-26ee-47d7-a18e-7d64d42faea7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To solve for the *x* vector that contains the number of securities to invest
    in, the inverse of the *A* matrix is taken and the equation is written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/b0bb9923-d74f-4cbf-a228-a8956441ebf8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Using NumPy arrays, the *A* and *B* matrices are assigned as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use the `linalg.solve` function of NumPy to solve a system of linear
    scalar equations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The portfolio would require a long position of 6 units of the security *a*,
    15 units of the security  *b*, and a short position of 23 units of the security *c*.
  prefs: []
  type: TYPE_NORMAL
- en: In portfolio management, we can use the matrix system of equations to solve
    for optimal weight allocations of securities, given a set of constraints. As the
    number of securities in the portfolio increases, the size of the *A* matrix increases
    and it becomes computationally expensive to compute the matrix inversion of *A*.
    Thus, one may consider methods such as the Cholesky decomposition, LU decomposition,
    QR decomposition, the Jacobi method, or the Gauss-Seidel method to break down
    the *A* matrix into simpler matrices for factorization.
  prefs: []
  type: TYPE_NORMAL
- en: The LU decomposition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The **LU decomposition**, or also known as **lower-upper factorization**, is
    one of the methods that solve square systems of linear equations. As its name
    implies, the LU factorization decomposes the *A* matrixinto a product of two matrices:
    a lower triangular matrix, *L*, and an upper triangular matrix, *U*. The decomposition
    can be represented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/71af5750-4c95-4836-b774-46acd01886f2.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](Images/0243079e-6788-49c3-9ac0-1be05d2f85fa.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, we can see *a=l[11]u[11]*, *b=l[11]u[12]*, and so on. A lower triangular
    matrix is a matrix that contains values in its lower triangle with the remaining
    upper triangle populated with zeros. The converse is true for an upper triangular
    matrix.
  prefs: []
  type: TYPE_NORMAL
- en: The definite advantage of the LU decomposition method over the Cholesky decomposition
    method is that it works for any square matrices. The latter only works for symmetric
    and positive definite matrices.
  prefs: []
  type: TYPE_NORMAL
- en: 'Think back to the previous example in *Solving linear equations using matrices*
    of a 3 x 3 *A* matrix*.* This time, we will use the `linalg` package of the SciPy
    module to perform the LU decomposition with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'To view the values of `x`, execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We get the same values of `6`, `15`, and `-23` for *a*, *b*, and *c*,respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we used the `lu_factor()` method of `scipy.linalg` here, which gives
    the `LU` variable as the pivoted LU decomposition of the *A* matrix*.* We used
    the `lu_solve()` method, which takes in the pivoted LU decomposition and the `B` vector,
    to solve the equation system.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can display the LU decomposition of the A matrix using the `lu()` method
    of `scipy.linalg`. The `lu()` method returns three variables—the permutation matrix, *P*,
    the lower triangular matrix, *L*, and the upper triangular matrix, *U* – individually:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'When we print out these variables, we can conclude the relationship between
    the LU factorization and *A* matrix, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/226067c6-bb1e-447a-98b1-fa67ab8d1ac2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The LU decomposition can be viewed as the matrix form of Gaussian elimination
    performed on two simpler matrices: the upper triangular and lower triangular matrices.'
  prefs: []
  type: TYPE_NORMAL
- en: The Cholesky decomposition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Cholesky decomposition is another way of solving systems of linear equations.
    It can be significantly faster and uses a lot less memory than the LU decomposition,
    by exploiting the property of symmetric matrices. However, the matrix being decomposed
    must be Hermitian (or real-valued symmetric and thus square) and positive definite.
    This means that the *A* matrix is decomposed as *A=LL^T*, where *L* is a lower
    triangular matrix with real and positive numbers on the diagonals, and *L^T* is
    the conjugate transpose of *L*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider another example of a system of linear equations where the *A*
    matrixis both Hermitian and positive definite. Again, the equation is in the form
    of *Ax=B*, where *A* and *B* take the following values:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/8ff30e92-f62d-46ec-ab09-a60a2fa81f49.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s represent these matrices as NumPy arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The `cholesky()` function of `numpy.linalg` would compute the lower triangular
    factor of the *A* matrix. Let''s view the lower triangular matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'To verify that the Cholesky decomposition results are correct, we can use the
    definition of the Cholesky factorization by multiplying *L* by its conjugate transpose,
    which will lead us back to the values of the *A* matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Before solving for *x*, we need to solve for *L^Tx* as *y*. Let''s use the
    `solve()` method of `numpy.linalg`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'To solve for *x*, we need to solve again using the conjugate transpose of *L*
    and *y*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s print our result of *x*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The output gives us our values of *x* for *a*, *b*, *c*, and *d*.
  prefs: []
  type: TYPE_NORMAL
- en: 'To show that the Cholesky factorization gives us the correct values, we can
    verify the answer by multiplying the *A* matrix by the transpose of *x* to return
    the values of *B*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This shows that the values of *x* by the Cholesky decomposition would lead to
    the same values given by *B*.
  prefs: []
  type: TYPE_NORMAL
- en: The QR decomposition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **QR decomposition**, also known as the **QR factorization**, is another
    method of solving linear systems of equations using matrices, very much like the
    LU decomposition. The equation to solve is in the form of *Ax*=*B*, where matrix
    *A*=*QR*. However, in this case, *A* is a product of an orthogonal matrix, *Q*,
    and upper triangular matrix, *R*. The QR algorithm is commonly used to solve the
    linear least-squares problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'An orthogonal matrix exhibits the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: It is a square matrix.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Multiplying an orthogonal matrix by its transpose returns the identity matrix:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](Images/41efd8bc-3c81-4151-8192-8b66a4b75e01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The inverse of an orthogonal matrix equals its transpose:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](Images/f7719a52-7912-4827-b5d0-077d5a4f5f2a.png)'
  prefs: []
  type: TYPE_IMG
- en: An identity matrix is also a square matrix, with its main diagonal containing
    1s and 0s elsewhere.
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem of *Ax=B* can now be restated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/76ec1aa1-ad1a-4e44-a99b-6e2463dc3660.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](Images/97535969-d66b-4e3b-bbca-e2436beab295.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Using the same variables in the LU decomposition example, we will use the `qr()`
    method of `scipy.linalg` to compute our values of *Q* and *R*, and let the *y* variable
    represent our value of *BQ^T* with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that `Q.T` is simply the transpose of `Q`, which is also the same as the
    inverse of *Q*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We get the same answers as those in the LU decomposition example.
  prefs: []
  type: TYPE_NORMAL
- en: Solving with other matrix algebra methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we've looked at the use of matrix inversion, the LU decomposition, the
    Cholesky decomposition, and QR decomposition to solve for systems of linear equations.
    Should the size of our financial data in the *A* matrixbe large, it can be broken
    down by a number of schemes so that the solution can converge more quickly using
    matrix algebra. Quantitative portfolio analysts should be familiar with these
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: In some circumstances, the solution that we are looking for might not converge.
    Therefore, you might consider the use of iterative methods. Common methods to
    solve systems of linear equations iteratively are the Jacobi method, the Gauss-Seidel
    method, and the SOR method. We will take a brief look at examples of implementing
    the Jacobi and Gauss-Seidel methods.
  prefs: []
  type: TYPE_NORMAL
- en: The Jacobi method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Jacobi method solves a system of linear equations iteratively along its
    diagonal elements. The iteration procedure terminates when the solution converges.
    Again, the equation to solve is in the form of *Ax=B*, where the matrix  *A* can
    be decomposed into two matrices of the same size such that *A=D+R*. The matrix
    D consists of only the diagonal components of A, and the other matrix R consists
    of the remaining components. Let''s take a look at the example of a 4 x 4 *A* matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/7db794c0-7bda-4251-becc-1c94352bac6f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The solution is then obtained iteratively, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/406fc895-12fa-49cd-9169-65d220203f1c.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](Images/3a031bd8-7c92-4c0a-9fe5-c59071007046.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](Images/1adeeed4-2adf-41b1-9e41-b180888d6393.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](Images/f2e91e47-124e-4b15-9f34-1fd282f11b31.png)'
  prefs: []
  type: TYPE_IMG
- en: As opposed to the Gauss-Siedel method, the value of *x[n]* in the Jacobi method
    is needed during each iteration in order to compute *x[n+1]* and cannot be overwritten.
    This would take up twice the amount of storage. However, the computations for
    each element can be done in parallel, which is useful for faster computations.
  prefs: []
  type: TYPE_NORMAL
- en: If the *A* matrix is strictly irreducibly diagonally dominant, this method is
    guaranteed to converge. A strictly irreducibly diagonally dominant matrix is one
    where the absolute diagonal element in every row is greater than the sum of the
    absolute values of other terms.
  prefs: []
  type: TYPE_NORMAL
- en: 'In some circumstances, the Jacobi method can converge even if these conditions
    are not met. The Python code is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Consider the same matrix values in the Cholesky decomposition example. We will
    use 25 iterations in our `jacobi` function to find the values of *x*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'After initializing the values, we can now call the function and solve for *x*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: We solved for the values of *x*, which are similar to the answers from the Cholesky
    decomposition.
  prefs: []
  type: TYPE_NORMAL
- en: The Gauss-Seidel method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Gauss-Seidel method works very much like the Jacobi method. It is another
    way to solve a square system of linear equations using an iterative procedure
    with the equation in the form of *Ax**=**B*. Here, the *A* matrix is decomposed
    as *A**=**L+U*, where the *A* matrix is a sum of a lower triangular matrix, *L*,
    and an upper triangular matrix, *U*. Let''s take a look at the example of a 4
    x 4 *A* matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/28f828fb-7354-4f6e-98b6-8db9994b2d99.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The solution is then obtained iteratively, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/8f6c1a8f-b4a1-4edc-8a95-767c34a75cf2.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](Images/e0a8bd69-a01b-4f19-a603-b631e2cff6d8.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](Images/7a7694e0-2b36-4079-bdd6-d06dd8a942f1.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](Images/68f67be8-9055-459b-8819-0d824806c9e3.png)'
  prefs: []
  type: TYPE_IMG
- en: Using a lower triangular matrix, *L*, where zeroes fill up the upper triangle,
    the elements of *x[n]* can be overwritten in each iteration in order to compute
    *x[n+1]*. This results in the advantage of needing half the storage required when
    using the Jacobi method.
  prefs: []
  type: TYPE_NORMAL
- en: The rate of convergence in the Gauss-Seidel method largely lies in the properties
    of the *A* matrix, especially if the *A* matrix is needed to be strictly-diagonally
    dominant or symmetric positive definite. Even if these conditions are not met,
    the Gauss-Seidel method may converge.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Python implementation of the Gauss-Seidel method is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `tril()` method of NumPy returns the lower triangular *A* matrix,
    from which we can find the lower triangular *U* matrix. Plugging the remaining
    values into *x* iteratively would lead us to the following solution, with some
    tolerance defined by `tol`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider the same matrix values in the Jacobi method and Cholesky decomposition
    example. We will use a maximum of 100 iterations in our `gauss()` function to
    find the values of *x*, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see whether our *x* values match with those from the Jacobi method and
    Cholesky decomposition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: We solved for the values of *x*, which are similar to the answers from the Jacobi
    method and Cholesky decomposition.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we took a brief look at the use of the CAPM model and APT model
    in finance. In the CAPM model, we visited the efficient frontier with the CML
    to determine the optimal portfolio and the market portfolio. Then, we solved for
    the SML using regression, which helped us to determine whether an asset is undervalued
    or overvalued. In the APT model, we explored how various factors affect security
    returns other than using the mean-variance framework. We performed a multivariate
    linear regression to help us determine the coefficients of the factors that led
    to the valuation of our security price.
  prefs: []
  type: TYPE_NORMAL
- en: In portfolio allocation, portfolio managers are typically mandated by investors
    to achieve a set of objectives while following certain constraints. We can model
    this problem using linear programming. Using the Pulp Python package, we can define
    a minimization or maximization objective function, and add inequality constraints
    to our problems to solve for unknown variables. The three outcomes in linear optimization
    can be an unbounded solution, only one solution, or no solution at all.
  prefs: []
  type: TYPE_NORMAL
- en: Another form of linear optimization is integer programming, where all the variables
    are restricted to being integers instead of fractional values. A special case
    of an integer variable is a binary variable, which can either be 0 or 1, and it
    is especially useful to model decision-making when given a set of choices. We
    worked on a simple integer programming model that contains binary conditions and
    saw how easy it is to run into a pitfall. Careful planning on the design of integer
    programming models is required for them to be useful in decision-making.
  prefs: []
  type: TYPE_NORMAL
- en: The portfolio-allocation problem may also be represented as a system of linear
    equations with equalities, which can be solved using matrices in the form of *Ax=B*.
    To find the values of *x*, we solved for *A^(−1)B* using various types of decomposition
    of the *A* matrix. The two types of matrix decomposition method are the direct
    and indirect methods. The direct method performs matrix algebra in a fixed number
    of iterations, and includes the LU decomposition, Cholesky decomposition, and
    QR decomposition methods. The indirect or iterative method iteratively computes
    the next values of *x* until a certain tolerance of accuracy is reached. This
    method is particularly useful for computing large matrices, but it also faces
    the risk of not having the solution converge. The indirect methods we used are
    the Jacobi method and the Gauss-Seidel method.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at nonlinear modeling in finance.
  prefs: []
  type: TYPE_NORMAL
