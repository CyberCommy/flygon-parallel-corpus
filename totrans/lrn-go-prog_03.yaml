- en: Chapter 3. Go Control Flow
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Go borrows several of its control flow syntax from the C-family of languages.
    It supports all of the expected control structures, including `if...else`, `switch`,
    `for` loop, and even `goto`. Conspicuously absent, though, are `while` or `do...while`
    statements. The following topics in this chapter examine Go''s control flow elements,
    some of which you may already be familiar with, and others that bring a new set
    of functionalities not found in other languages:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: The `if` statement
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `switch` statement
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The type `Switch`
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `for` statement
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The if statement
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `if` statement, in Go, borrows its basic structural form from other C-like
    languages. The statement conditionally executes a code block when the Boolean
    expression that follows the `if` keyword evaluates to `true`, as illustrated in
    the following abbreviated program, which displays information about world currencies:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: golang.fyi/ch03/ifstmt.go
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: 'The `if` statement in Go looks similar to other languages. However, it sheds
    a few syntactic rules, while enforcing new ones:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: 'The parentheses around the test expression are not necessary. While the following
    `if` statement will compile, it is not idiomatic:'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Use the following instead:'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The curly braces for the code block are always required. The following snippet
    will not compile:'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'However, this will compile:'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'It is idiomatic, however, to write the `if` statement on multiple lines (no
    matter how simple the statement block may be). This encourages good style and
    clarity. The following snippet will compile with no issues:'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'However, the preferred idiomatic layout for the statement is to use multiple
    lines, as follows:'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `if` statement may include an optional `else` block, which is executed
    when the expression in the `if` block evaluates to `false`. The code in the `else`
    block must be wrapped in curly braces using multiple lines, as shown in the following
    snippet:'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `else` keyword may be immediately followed by another `if` statement forming
    an `if...else...if` chain, as used in the function `printCurr()` from the source
    code listed earlier:'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `if...else...if` statement chain can grow as long as needed and may be
    terminated by an optional `else` statement to express all other untested conditions.
    Again, this is done in the `printCurr()` function, which tests four conditions
    using the `if...else...if` blocks. Lastly, it includes an `else` statement block
    to catch any other untested conditions:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In Go, however, the idiomatic, and cleaner, way to write such a deep `if...else...if`
    code block is to use an expressionless `switch` statement. This is covered later,
    in the *Switch statement* section.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: The if statement initialization
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `if` statement supports a composite syntax where the tested expression
    is preceded by an initialization statement. At runtime, the initialization is
    executed before the test expression is evaluated, as illustrated in this code
    snippet (from the program listed earlier):'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The initialization statement follows normal variable declaration and initialization
    rules. The scope of the initialized variables is bound to the `if` statement block,
    beyond which they become unreachable. This is a commonly used idiom in Go and
    is supported in other flow control constructs covered in this chapter.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Switch statements
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Go also supports a `switch` statement similar to that found in other languages
    such as, C or Java. The `switch` statement in Go achieves multi-way branching
    by evaluating values or expressions from `case` clauses, as shown in the following,
    abbreviated, source code:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: golang.fyi/ch03/switchstmt.go
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: 'The `switch` statement in Go has some interesting properties and rules that
    make it easy to use and reason about:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: 'Semantically, Go''s `switch` statement can be used in two contexts:'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An expression`switch` statement
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A type`switch` statement
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `break` statement can be used to escape out of a switch code block early.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `switch` statement can include a default case when no other case expressions
    evaluate to a match. There can only be one default case and it may be placed anywhere
    within the switch block.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using expression switches
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Expression switches are flexible and can be used in many contexts where control
    flow of a program needs to follow multiple path. An expression switch supports
    many attributes, as outlined in the following bullets:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: 'Expression switches can test values of any types. For instance, the following
    code snippet (from the previous program listing) tests variable `Curr` of type
    `struct`:'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The expressions in `case` clauses are evaluated from left to right, top to bottom,
    until a value (or expression) is found that is equal to that of the `switch` expression.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Upon encountering the first case that matches the `switch` expression, the program
    will execute the statements for the `case` block and then immediately exit the
    `switch` block. Unlike other languages, the Go `case` statement does not need
    to use a break to avoid falling through the next case (see the *Fallthrough cases*
    section). For instance, calling `isDollar(Curr{"HKD", "Hong Kong Dollar", "Hong
    Kong", 344})` will match the second `case` statement in the preceding function.
    The code will set the result to `true` and exit the `switch` code block immediately.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Case` clauses can have multiple values (or expressions) separated by commas
    with a logical `OR` operator implied between them. For instance, in the following
    snippet, the `switch` expression `curr` is tested against values `currencies[2]`,
    `currencies[4]`, or `currencies[10]`, using one case clause until a match is found:'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `switch` statement is the cleaner and preferred idiomatic approach to writing
    complex conditional statements in Go. This is evident when the preceding snippet
    is compared to the following, which does the same comparison using `if` statements:'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The fallthrough cases
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is no automatic *fall through* in Go''s `case` clause as there is in
    the C or Java `switch` statements. Recall that a `switch` block will exit after
    executing its first matching case. The code must explicitly place the `fallthrough`
    keyword, as the last statement in a `case` block, to force the execution flow
    to fall through the successive `case` block. The following code snippet shows
    a `switch` statement with a `fallthrough` in each case block:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: golang.fyi/ch03/switchstmt.go
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: 'When a case is matched, the `fallthrough` statements cascade down to the first
    statement of the successive `case` block. So, if `curr = Curr{"AUD", "Australian
    Dollar", "Australia", 36}`, the first case will be matched. Then the flow cascades
    down to the first statement of the second case block, which is also a `fallthrough`
    statement. This causes the first statement, to return `true`, of the third case
    block to execute. This is functionally equivalent to the following snippet:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Expressionless switches
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Go supports a form of the `switch` statement that does not specify an expression.
    In this format, each `case` expression must evaluate to a Boolean value `true`.
    The following abbreviated source code illustrates the uses of an expressionless
    `switch` statement, as listed in function `find()`. The function loops through
    the slice of `Curr` values to search for a match based on field values in the
    `struct` function that''s passed in:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: golang.fyi/ch03/switchstmt2.go
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice in the previous example, the `switch` statement in function `find()`
    does not include an expression. Each `case` expression is separated by a comma
    and must be evaluated to a Boolean value with an implied `OR` operator between
    each. The previous `switch` statement is equivalent to the following use of an
    `if` statement to achieve the same logic:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Switch initializer
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `switch` keyword may be immediately followed by a simple initialization
    statement where variables, local to the `switch` code block, may be declared and
    initialized. This convenient syntax uses a semi-colon between the initializer
    statement and the `switch` expression to declare variables, which may appear anywhere
    in the `switch` code block. The following code sample shows how this is done by
    initializing two variables, `name` and `curr`, as part of the `switch` declaration:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: golang.fyi/ch03/switchstmt2.go
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: The previous code snippet uses an expressionless `switch` statement with an
    initializer. Notice the trailing semi-colon to indicate the separation between
    the initialization statement and the expression area for the switch. In the example,
    however, the `switch` expression is empty.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: Type switches
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Given Go's strong type support, it should be of little surprise that the language
    supports the ability to query type information. The type `switch` is a statement
    that uses the Go interface type to compare the underlying type information of
    values (or expressions). A full discussion on interface types and type assertion
    is beyond the scope of this section. You can find more details on the subject
    in [Chapter 8](ch08.html "Chapter 8. Methods, Interfaces, and Objects"), *Methods,
    Interfaces, and Objects*.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: 'Nevertheless, for the sake of completeness, a short discussion on type switches
    is provided here. For now, all you need to know is that Go offers the type `interface{}`,
    or empty interface, as a super type that is implemented by all other types in
    the type system. When a value is assigned type `interface{}`, it can be queried
    using the type `switch`, as shown in function `findAny()` in the following code
    snippet, to query information about its underlying type:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: golang.fyi/ch03/switchstmt2.go
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: 'The function `findAny()` takes an `interface{}` as its parameter. The type
    `switch` is used to determine the underlying type and value of the variable `val`
    using the type assertion expression:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Notice the use of the keyword `type` in the preceding type assertion expression.
    Each case clause will be tested against the type information queried from `val.(type)`.
    Variable `i` will be assigned the actual value of the underlying type and is used
    to invoke a function with the respective value. The default block is invoked to
    guard against any unexpected type assigned to the parameter `val` parameter. Function
    `findAny` may then be invoked with values of diverse types, as shown in the following
    code snippet:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The for statements
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As a language related to the C-family, Go also supports `for` loop style control
    structures. However, as you may have come to expect by now, Go''s `for` statements
    work interestingly differently and simply. The `for` statement in Go supports
    four distinct idioms, as summarized in the following table:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '| **For Statement** | **Usage** |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
- en: '| For condition | Used to semantically replace `while` and `do...while` loops:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '|'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '| Infinite loop | The conditional expression may be omitted to create an infinite
    loop:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '|'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '| Traditional | This is the traditional form of the C-family `for` loop with
    the initializer, test, and update clauses:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '|'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '| For range | Used to iterate over an expression representing a collection
    of items stored in an array, string (array of rune), slice, map, and channel:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '|'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: Notice, as with all other control statements in Go, the `for` statements do
    not use parentheses around their expressions. All statements for the loop code
    block must be enclosed within curly brackets or the compiler will produce an error.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: For condition
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `for` condition uses a construct that is semantically equivalent to the
    `while` loop found in other languages. It uses the keyword `for`, followed by
    a Boolean expression that allows the loop to proceed as long as it is evaluated
    to true. The following abbreviated source listing shows an example of this form
    of the `for` loop:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: golang.fyi/ch03/forstmt.go
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: The `for` statement, in function `listCurrs()`, iterates as long as the conditional
    expression `i < len(currencencies)` returns `true`. Care must be taken to ensure
    the value of `i` is updated with each iteration to avoid creating an accidental
    infinite loop.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: Infinite loop
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When the Boolean expression is omitted in the `for` statement, the loop runs
    indefinitely, as shown the following example:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This is equivalent to the `for(;;)` or the `while (true)` found in other languages,
    such as C or Java.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: The traditional for statement
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Go also supports the traditional form of the `for` statement, which includes
    an initialization statement, a conditional expression, and an update statement,
    all separated by a semi-colon. This is the form of the statement that is traditionally
    found in other C-like languages. The following source snippet illustrates the
    use of a traditional for statement in the function `sortByNumber`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: golang.fyi/ch03/forstmt.go
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous example implements a selection sort that sorts the `slice` currencies
    by comparing the `Number` field of each `struct` value. The different sections
    of the `for` statement are highlighted using the following snippet of code (from
    the preceding function):'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '![The traditional for statement](img/B03676_For-Loop.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
- en: 'It turns out that the traditional `for` statement is a superset of the other
    forms of the loop discussed so far, as summarized in the following table:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '| **For statement** | **Description** |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
- en: '|'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '| The initialization statement is omitted. Variable `k` is initialized outside
    of the `for` statement. The idiomatic way, however, is to initialize your variables
    with the `for` statement. |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
- en: '|'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '| The `update` statement (after the last semi-colon) is omitted here. The developer
    must provide update logic elsewhere or you risk creating an infinite loop. |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
- en: '|'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '| This is equivalent to the `for` condition form (discussed earlier) `for k
    < 10 { ... }`. Again, the variable `k` is expected to be declared prior to the
    loop. Care must be taken to update `k` or you risk creating an infinite loop.
    |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
- en: '|'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '| Here, the conditional expression is omitted. As before, this evaluates the
    conditional to `true`, which will produce an infinite loop if proper termination
    logic is not introduced in the loop. |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
- en: '|'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '| This is equivalent to the form `for{ ... }` and produces an infinite loop.
    |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
- en: 'The initialization and the `update` statements, in the `for` loop, are regular
    Go statements. As such, they can be used to initialize and update multiple variables,
    as is supported by Go. To illustrate this point, the next example initializes
    and updates two variables, `w1` and `w2`, at the same time in the statement clauses:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: golang.fyi/ch03/forstmt2.go
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: The initialization statements initialize variables `w1` and `w2` by calling
    the function `nextPair()`. The condition uses a compound logical expression that
    will keep the loop running as long as it is evaluated to true. Lastly, variables
    `w1` and `w2` are both updated with each iteration of the loop by calling `nextPair()`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: The for range
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Lastly, the `for` statement supports one additional form that uses the keyword
    `range` to iterate over an expression that evaluates to an array, slice, map,
    string, or channel. The for-range loop has this generic form:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '*for [<identifier-list> :=] range <expression> { ... }*'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: 'Depending on the type produced by the `range` expression, there can be up to
    two variables emitted by each iteration, as summarized in the following table:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '| **Range Expression** | **Range Variables** |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
- en: '| Loop over array or slice:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '| The range produces two values, where `i` is the loop index and `v` is the
    value `v[i]` from the collection. Further discussions on array and slice are covered
    in [Chapter 7](ch07.html "Chapter 7. Composite Types"), *Composite Types*. |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
- en: '| Loop over string value:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '| The range produces two values, where `i` is the index of byte in the string
    and `v` is the value of the UTF-8 encoded byte at `v[i]` returned as a rune. Further
    discussion on the string type is covered in in [Chapter 4](ch04.html "Chapter 4. Data
    Types"), *Data Types*. |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
- en: '| Loop over map:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '| The `range` produces two values, where `k` is assigned the value of the map
    key of type `K` and `v` gets stored at `map[k]` of type `V`. Further discussion
    on map is covered in [Chapter 7](ch07.html "Chapter 7. Composite Types"), *Composite
    Types*. |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
- en: '| Loop on channel values:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '| An adequate discussion of channels is covered in [Chapter 9](ch09.html "Chapter 9. Concurrency"),
    *Concurrency*. A channel is a two-way conduit able to receive and emit values.
    The `for...range` statement assigns each value received from the channel to variable
    `c` with each iteration. |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
- en: 'You should be aware that the value emitted with each iteration is a copy of
    the original item stored in the source. For instance, in the following program,
    the values in the slice do not get updated after the loop completes:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: To update the original value using the `for...range` loop, use the index expression
    to access the original value, as illustrated in the following.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In the previous example, value `i` is used in a slice index expression  `vals[i]`
    to update the original value stored in the slice. It is possible to omit the iteration
    value (the second variable in the assignment) if you only need access to the index
    value of an array, slice, or string (or key for a map). For instance, in the following
    example, the `for...range` statement only emits the current index value with each
    iteration:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: golang.fyi/ch03/for-range-stmt.go
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, there are some situations where you may not be interested in any of
    the values generated by the iteration, but rather the iteration mechanic itself.
    The next form of the for statement was introduced (as of Version 1.4 of Go) to
    express a for range without any variable declaration as shown in the following
    code snippet:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The previous code will print `"Looping"` four times on the standard output.
    This form of the `for...range` loop is used sometimes when the range expression
    is over a channel. It is used to simply notify of the presence of a value in the
    channel.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: The break, continue, and goto statements
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go supports a group of statements designed specifically to exit abruptly out
    of a running code block, such as switch and for statement, and transfer control
    to a different section of the code. All three statements can accept a label identifier
    that specifies a targeted location in the code where control is to be transferred.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: The label identifier
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before diving into the core of this section, it is worthwhile to look at the
    label used by these statements. Declaring a label in Go requires an identifier
    followed by a colon, as shown in the following snippet:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Naming your label is a matter of style. However, one should follow the identifier
    naming guidelines covered in the previous chapter. A label must be enclosed within
    a function. The Go compiler will not allow unused labels to dangle in the code.
    Similar to variables, if a label is declared, it must be referenced in the code.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: The break statement
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As in other C-like languages, the Go `break` statement terminates and exits
    the innermost enclosing `switch` or `for` statement code block and transfers control
    to another part of the running program. The `break` statement can accept an optional
    label identifier specifying a labeled location, in the enclosing function, where
    the flow of the program will resume. Here are some attributes of the label for
    the `break` statement to remember:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: The label must be declared within the same running function where the `break`
    statement is located
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A declared label must be followed immediately by the enclosing control statement
    (a `for` loop or `switch` statement) where the break is nested
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a `break` statement is followed by a label, control is transferred, not to
    the location where the label is, but rather to the statement immediately following
    the labeled block. If a label is not provided, the `break` statement abruptly
    exits and transfers control to the next statement following its enclosing `for`
    statement (or `switch` statement) block.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is an overly exaggerated linear search that illustrates
    the working of the `break` statement. It does a word search and exits once the
    first instance of the word is found in the slice:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: golang.fyi/ch03/breakstmt.go
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: In the previous code snippet, the `break DoSearch` statement will essentially
    exit out of the innermost `for` loop and cause the execution flow to continue
    after the outermost labeled `for` statement, which in this example, will simply
    end the program.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: The continue statement
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `continue` statement causes the control flow to immediately terminate the
    current iteration of the enclosing `for` loop and jump to the next iteration.
    The `continue` statement can take an optional label as well. The label has similar
    properties to that of the `break` statement:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: The label must be declared within the same running function where the `continue`
    statement is located
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The declared label must be followed immediately by an enclosing `for` loop statement
    where the continue statement is nested
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When present, the `continue` statement is reached within a `for` statement block,
    the `for` loop will be abruptly terminated and control will be transferred to
    the outermost labeled `for` loop block for continuation. If a label is not specified,
    the `continue` statement will simply transfer control to the start of its enclosing
    `for` loop block for continuation of the next iteration.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate, let us revisit the previous example of word search. This version
    uses a `continue` statement, which causes the search to find multiple occurrences
    of the searched word in the slice:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: golang.fyi/ch03/breakstmt2.go
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: The `continue DoSearch` statement causes the current iteration of the innermost
    loop to stop and transfer control to the labeled outer loop, causing it to continue
    with the next iteration.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: The goto statement
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `goto` statement is more flexible, in that it allows flow control to be
    transferred to an arbitrary location, inside a function, where a target label
    is defined. The `goto` statement causes an abrupt transfer of control to the label
    referenced by the `goto` statement. The following shows Go''s `goto` statement
    in action in a simple, but functional example:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: golang.fyi/ch03/gotostmt.go
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: 'The code uses the `goto` statement to jump to different sections of the `main()`
    function. Notice that the `goto` statement can target labels defined anywhere
    in the code. The superfluous usage of the `Start:` label is left in the code for
    completeness and is not necessary in this context (since continue, without the
    label, would have the same effect). The following provides some guidance when
    using the `goto` statement:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: Avoid using the `goto` statement unless the logic being implemented can only
    be achieved using `goto` branching. This is because overuse of the `goto` statement
    can make code harder to reason about and debug.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Place `goto` statements and their targeted label within the same enclosing code
    block when possible.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid placing labels where a `goto` statement will cause the flow to skip new
    variable declarations or cause them to be re-declared.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go will let you jump from inner to outer enclosing code blocks.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is a compilation error if you try to jump to a peer or to an enclosing code
    block.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter provided a walkthrough of the mechanism of control flow in Go,
    including `if`, `switch`, and `for` statements. While Go's flow control constructs
    appear simple and easy to use, they are powerful and implement all branching primitives
    expected of a modern language. Readers are introduced to each concept with ample
    detail and examples to ensure clarity of the topics. The next chapter continues
    our look into Go fundamentals by introducing the reader to the Go type systems.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了Go语言中控制流的机制，包括`if`、`switch`和`for`语句。虽然Go的流程控制结构看起来简单易用，但它们功能强大，实现了现代语言所期望的所有分支原语。读者通过丰富的细节和示例介绍了每个概念，以确保主题的清晰度。下一章将继续介绍Go基础知识，向读者介绍Go类型系统。
