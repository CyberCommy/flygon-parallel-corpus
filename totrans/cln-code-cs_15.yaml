- en: Assessments
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One outcome of bad code is that you can end up with a really badly written piece
    of code that is hard to understand. This can often lead to programmer stress and
    software that is buggy, hard to maintain, and hard to test and extend.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: One outcome of good code is that it is easy to read and understand, as you know
    the programmer's intent. This leads to less stress for programmers who must debug
    the code, test it, and extend it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you break a large project up into modular components and libraries, each
    module can be worked on by separate teams concurrently. Small modules are easy
    to test, code, document, deploy, extend, and maintain.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**DRY** stands for **Don''t Repeat Yourself**. Look for repeatable code, and
    refactor it so that you remove duplicate code. The advantage of this is smaller
    programs, because if such code contains bugs, you only have to change it in one
    place.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: KISS means simple code that will not confuse programmers, especially if you
    have juniors on your team. KISS code is easy to read and write tests for.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**S** is the **Single Responsibility Principle**, **O** is the **Open/Closed
    Principle**, **L** is **Liskov Substitution**, **I** is the **Interface Segregation
    Principle**, and **D** is the **Dependency Inversion Principle**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**YAGNI** is short for **You Aren''t Going to Need It**. In other words, don''t
    add code you don''t need. Only add the code you absolutely need, and no more.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Occam's Razor is the principle that states: *Entities must not be multiplied
    without necessity.* *Deal only in facts. Only make assumptions if absolutely necessary*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The two roles in the peer code review are reviewer and reviewee.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The project manager agrees on the people that will be involved in the peer code
    review.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can save your reviewer time and effort prior to requesting a peer code review
    by making sure your code and tests all work, that you perform code analysis on
    your project and fix any issues raised, and that your code adheres to the company
    coding guidelines.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When reviewing code, look out for naming, formatting, programming styles, potential
    bugs, correctness of code and tests, security, and performance issues.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The three categories of feedback are positive, optional, and critical.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can place our code in individual source files in folder structures and wrap
    classes, interfaces, structs, and enums in namespaces that map to the folder structure.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A class should have only one responsibility.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can comment in your code for document generators using XML comments placed
    directly above the public member to be documented.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Cohesion is the logical grouping together of code that works on the same responsibility.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Coupling refers to the dependencies between classes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Cohesion should be high.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Coupling should be low.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can use DI and IoC to design for change.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**DI** stands for **Dependency Injection**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**IoC** stands for **Inversion of Control**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Immutable objects are type-safe and so can be safely passed between threads.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Objects should expose methods and properties and hide data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Data structures should expose data and have no methods.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Methods with no parameters are called niladic methods.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Methods with only one parameter are called monadic methods.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Methods with two parameters are called dyadic methods.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Methods with three parameters are called triadic methods.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Methods with more than three parameters are called polyadic methods.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You should avoid duplicate code. It is not a productive way to program, can
    make programs unnecessarily large, and has the propensity to proliferate the same
    exception throughout your codebase.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Functional programming is a software coding methodology that treats computations
    as the mathematical evaluation of computations that does not modify state.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The advantages of functional programming include safe code in multithreaded
    applications and smaller, more meaningful methods that are easy to read and understand.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Input and output can be a problem for functional programs as it relies on side-effects.
    Functional programming does not allow for side-effects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: WET code is the opposite of DRY in that code is written each time it is needed.
    This produces duplication, and the same exception can occur in multiple locations
    within a program, making maintenance and support more difficult.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: DRY code is the opposite of WET in that code is only ever written once and is
    reused wherever it is needed. This reduces the code base and exception footprint,
    thus making programs easier to read and maintain.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You DRY out WET code by removing duplicate code using refactoring.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Long methods are cumbersome and prone to exceptions. The smaller they are, the
    easier they are to read and maintain. There is also less chance of the programmer
    introducing bugs, especially of a logical nature.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To avoid having to use try/catch blocks, you can write argument validators.
    You would then call the validators at the top of your method. If the parameters
    fail validation, then the appropriate exception is thrown, and the method is not
    executed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A checked exception is an exception that is checked at compile time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An unchecked exception is an exception that is not checked or simply ignored
    at compile time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An overflow exception is raised when high-order bits cannot be assigned to the
    destination type. In checked mode, `OverflowException` is raised. In unchecked
    mode, high-order bits that cannot be assigned are simply ignored.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An attempt made to access a property or a method on a null object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement a `Validator` class and an `Attribute` class that checks the parameter
    for null, and that throws `ArgumentNullException`. You would use the `Validator`
    class at the top of your methods so that you don't get halfway through the method
    before the exception is raised.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Business Rule Exception** (**BRE**).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: BREs are bad practice because they expect exceptions to be raised in order to
    control program flow.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Correct programming should never control the flow of a computer program by expecting
    exceptions as output. So, given that BREs are bad as they expect exceptional output
    and use it to control program flow, a better solution is to use conditional programming.
    With a conditional program, you use Boolean logic. Boolean logic allows for two
    possible paths of execution, and never raises exceptions. Conditional checks are
    explicit and make the programs easier to read and maintain. You can also easily
    extend such code, whereas with BREs, you can't.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: First, start with error trapping for known types of exceptions such as `ArgumentNullExceptions`
    and `OverflowExceptions` using known exception types in the Microsoft .NET Framework.
    But when these are insufficient and don't provide enough data for your particular
    situation, then you would write and use your own custom exceptions and apply meaningful
    exception messages.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Your custom exception must inherit from `System.Exception`, and implement three
    constructors: the default construct, a constructor that accepts a text message,
    and a constructor that accepts a text message and an inner exception.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A good unit test must be atomic, deterministic, repeatable, and fast.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A good unit test must not be inconclusive.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Test-driven development.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Behavioral-driven development.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A small unit of code whose only purpose is to test a single unit of code that
    only does one thing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A fake object used by the unit test to test the public methods and properties
    of a real object, but without testing the method or property dependencies.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A fake object is the same as a mock object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: MSTest, NUnit, and xUnit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rhino Mocks and Moq.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: SpecFlow.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unnecessary comments, dead code, and redundant tests.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The testing of a complete system from end to end. This can be performed manually,
    automatically, or by using both methods.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Integration testing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Manual testing of all features, all our unit tests should pass, and we should
    write automation tests to test the commands and data that are passed between two
    modules.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Factories are classes that implement the factory method pattern whose intention
    is to allow the creation of objects without specifying their classes. We would
    use them in the following scenarios:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The class is unable to anticipate the type of object that must be instantiated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The subclass must specify the type of object to instantiate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The class controls the instantiation of its objects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: DI is a method of producing loosely coupled code that is easy to maintain and
    extend.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using a container makes the management of dependency objects easy.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A thread is a process.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: One.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Background threads and foreground threads.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The background thread.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The foreground thread.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Thread.Sleep(500);`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`var thread = new Thread(Method1);`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set `IsBackground` equal to `true`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A deadlock is a situation when two threads are blocked and waiting on the other
    thread to release the resource.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Monitor.Exit(objectName);`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Multiple threads using the same resource generate different outputs based on
    the timings of each thread.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the TPL with `ContinueWith()`, and use `Wait()` to wait until the task has
    finished before exiting the method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using a member variable that is shared by other methods, and passing in reference
    variables.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Yes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The ThreadPool.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is an object that cannot be modified once it has been constructed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: They allow you to safely share data between threads.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Application Programming Interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Representational State Transfer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Uniform interface, client-server, stateless, cacheable, layered system, optional
    executable code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Hypermedia as the Engine of Application State** (**HATEOAS**).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: RapidApi.com.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Authorization and authentication.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Claims are statements that an entity makes about itself. These claims are then
    validated against a data store. They are particularly useful in role-based security
    to check whether the entity making the claim is authorized in regard to that claim.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Making API requests and examining their responses.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Because you can change your data store in keeping with your requirements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The correct partitioning of software into logical namespaces, interfaces, and
    classes, which aids the testing of software.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By understanding APIs, you can KISS your code and keep it DRY by not reinventing
    the wheel and writing code that already exists. This saves time, energy, and money.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Structs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Third-party APIs are written by software developers, and so subject to human
    error that introduces bugs. By testing third-party APIs, you can be confident
    they work as expected, and if not, then you can have the code fixed or write a
    wrapper for it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Your APIs are prone to errors. By testing them in keeping with the specification
    and its acceptance criteria, you can be sure you are delivering what the business
    wants at the agreed level of quality ready for public release.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The specification and acceptance criteria provide the normal program flow. From
    them, you can determine what to test in regard to the normal flow of execution,
    and you can determine what exceptional circumstances will be encountered and test
    for them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Namespaces, interfaces, and classes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cross-cutting concerns are those concerns that not part of the business requirements
    that form the core concerns, but that must be addressed in all areas of the code. **AOP**
    stands for **Aspect-Oriented Programming**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An aspect is an attribute that, when applied to a class, method, property, or
    parameter, injects code at compile time. You apply an aspect in square brackets
    before the item it is being applied to.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An attribute gives semantic meaning to an item. You apply an attribute in square
    brackets before the item it is being applied to.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Attributes give the code semantic meaning, while aspects remove the boilerplate
    code so that it is injected at compile time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the code is being built, the compiler will insert the boilerplate code
    that the aspect hides from the programmer. This process is known as code weaving.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Code metrics are several source code measurements that enable us to identify
    how complex our software is, and how maintainable it is. Such measurements enable
    us to identify areas of code that can be made less complex and more maintainable
    through refactoring.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Cyclomatic complexity, maintainability index, depth of inheritance, class coupling,
    lines of source code, and lines of executable code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Code analysis is the static analysis of source code with the intention of identifying
    design flaws, issues with globalization, security problems, issues with performance,
    and interoperability problems.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Quick actions are single commands identified by a screwdriver or lightbulb that
    will suppress warnings, add using statements, import missing libraries and add
    the using statements, correct errors, and implement language usage improvements
    aimed at simplifying code and reducing the number of lines in a method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: JetBrains' dotTrace utility is a profiling tool used for the purpose of profiling
    source code and compiled assemblies to identify potential issues with the software.
    With it you can perform sampling, tracing, line-by-line, and timeline profiling.
    You can profile execution time, thread time, real-time CPU instructions, and thread
    cycle time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: JetBrains' ReSharper utility is a code refactoring tool that helps developers
    identify and fix code issues and implement language features to improve and speed
    up the programmer's programming experience.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The decompilation of source code can be used to retrieve lost source code, generate
    PDBs for debugging, and for learning. You can also use the decompiler to see how
    well you have obfuscated your code to make it hard for hackers and other people
    to steal your code secrets.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Application-level, class-level, and method-level.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Boolean blindness, combinatorial explosion, contrived complexity, data clump,
    deodorant comments, duplicate code, lost intent, mutation of variables, oddball
    solution, shotgun surgery, solution sprawl, and uncontrolled side effects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Cyclomatic complexity, divergent change, downcasting, excessive literal use,
    feature envy, inappropriate intimacy, indecent exposure, large class (also known
    as God object), lazy class (also known as freeloader and lazy object), middleman
    class, an orphan class of variables and constants, primitive obsession, refused
    bequest, speculative generality, Tell, don't ask!, and temporary field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Black sheep, cyclomatic complexity, contrived complexity, dead code, excessive
    data return, feature envy, identifier size, inappropriate intimacy, long line
    aka God line, lazy method, long method (God method), long parameter list (too
    many parameters), message chains, middleman method, oddball solutions, and speculative
    generality.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use LINQ instead of loops. Make classes responsible for only one thing. Make
    methods do only one thing. Replace long lists of parameters with parameter objects.
    Use creational design patterns to improve the efficiency of expensive object creation
    and utilization. Keep methods to 10 lines or less. Use AOP to remove boilerplate
    code from methods. Decouple objects and make them testable. Make code highly cohesive.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A value that represents the amount of branching and looping.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Reduce the amount of branching and looping that takes place until such time
    as the cyclomatic complexity value becomes 10 or less.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Making things more complicated than they need to be.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Keep It Simple, Stupid** (**KISS**).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The same thing is done by different methods with different parameter combinations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create generic methods that can perform the same task on the different data
    types so that you only have the one method with one set of parameters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fix the bad code and remove the comment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ask for help.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Stack Overflow.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A long parameter list can be replaced with a parameter object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Refactor it into smaller methods that do only one thing, and remove boilerplate
    code into aspects using AOP.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: No more than 10 lines.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 0-10; anything beyond that and you are asking for trouble.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: One.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Variables, classes, properties, and methods that are not used. Get rid of them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose the best method of implementation, and then refactor the code to use
    just that method of implementation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Refactor the temporary field and the methods that operate on it into their own
    class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The same set of variables used in different classes. Refactor the variables
    into a class of their own, and then reference the class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A class inherits from another class but does not use all its methods.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Law of Demeter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Only allow classes to speak to their immediate neighbors.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A class or method spending too much time inside another class or method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Refactor dependencies in their own class or method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The factory method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inherit from a base class, and then create the new class that inherits from
    the base.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Single responsibility is implemented in different methods of different classes
    across different layers of the application. Refactor the responsibility into its
    own class so that it is only in a single location.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The data should be placed in the same object that operates on it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you create an object that asks another object for data so that it can perform
    operations on it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A single change requires changes in multiple locations. Remove duplication,
    remove the coupling, and improve cohesion.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Lost intent is when the reason for the class or method is unclear because there
    are lots of unrelated items clumped together. Refactor the code so that all methods
    are in the right class. That way, the intent of the class and the methods becomes
    clear.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can refactor loops with LINQ queries. LINQ is a functional language that
    does not alter location variables and can perform much faster than loops.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**GoF** is short for **Gang-of-Four** patterns. These are 23 patterns that
    are grouped into creational, structural, and behavioral design patterns. They
    are considered the foundation of all software design patterns. They work together
    to produce clean object-oriented code.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creational patterns enable abstraction and inheritance to provide an object-oriented
    way of removing code duplication and improving performance when object creation
    is expensive. The creational patterns are abstract factory, factory method, singleton,
    prototype, and builder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Structural patterns enable the correct management of relationships between objects.
    We can use structural patterns to enable incompatible interfaces to work together,
    decouple abstractions from their implementations, and improve performance. The
    structural patterns are adapter, bridge, composite, decorator, façade, flyweight,
    and proxy.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Behavioral patterns govern how objects interact and communicate with each other.
    We can use them to produce pipelines, encapsulate commands and information to
    be executed at a future point in time, mediate between objects, observe state
    changes in objects, and more. The behavior patterns are chain of responsibility,
    command, interpreter, iterator, mediator, memento, observer, state, strategy,
    template method, and visitor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Yes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The singleton only allows a single instance of an object throughout the lifetime
    of the application. The object is globally accessible to all objects that need
    it. We use this pattern when we need to ensure we have one centralized point of
    object creation and object access.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We use factory methods when we have a need to create objects without specifying
    the exact class to be instantiated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Façade.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the flyweight design pattern.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Bridge.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the builder pattern.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You would use the chain of responsibility pattern, as you can have a pipeline
    of handlers, each of which performs a task. If they are unable to handle the task,
    the handlers pass the task to their successor to handle.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
