- en: Chapter 12. Debugging with GDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Bugs happen. Identifying and fixing them is part of the development process.
    There are many different techniques for finding and characterizing program defects,
    including static and dynamic analysis, code review, tracing, profiling, and interactive
    debugging. I will look at tracers and profilers in the next chapter, but here
    I want to concentrate on the traditional approach of watching code execution through
    a debugger, in our case, the **GNU debugger**, **GDB**. GDB is a powerful and
    flexible tool. You can use it to debug applications, examine the postmortem files
    (`core` files) that are created after a program crash, and even step through kernel
    code.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I will show you how to use GDB to debug applications, how to
    look at core files and how to debug kernel code, in all cases, emphasizing the
    aspects that are relevant for embedded Linux.
  prefs: []
  type: TYPE_NORMAL
- en: The GNU debugger
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GDB is a source-level debugger for the compiled languages, primarily C and C++,
    although there is also support for a variety of other languages such as Go and
    Objective. You should read the notes for the version of GDB you are using to find
    out the current status of support for the various languages. The project website
    is [http://www.gnu.org/software/gdb](http://www.gnu.org/software/gdb) and contains
    a lot of useful information, including the GDB manual.
  prefs: []
  type: TYPE_NORMAL
- en: Out of the box, GDB has a command-line user interface which some people find
    off-putting although, in reality, it is easy to use with a little practice. If
    command-line interfaces are not to your liking, there are a lot of front-end user
    interfaces to GDB and I will describe three of them later.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing to debug
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You need to compile the code you want to debug with debug symbols. GCC offers
    two options for this: `-g` and `-ggdb`. The latter adds debug information that
    is specific to GDB, whereas the former generates information in an appropriate
    format for whichever target operating system you are using, making it the more
    portable option. In our particular case, the target operating system is always
    Linux and it makes little difference whether you use `-g` or `-ggdb`. Of more
    interest is the fact that both options allow you to specify the level of debug
    information, from 0 to 3:'
  prefs: []
  type: TYPE_NORMAL
- en: '0: This produces no debug information at all and is equivalent to omitting
    the `-g` or `-ggdb` switch'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '1: This produces little information but which includes function names and external
    variables which is enough to generate a back trace'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '2: This is the default and includes information about local variables and line
    numbers so that you can do source level debugging and a single step through the
    code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '3: This includes extra information which, among other things, means that GDB
    handles macro expansions correctly'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In most cases, `-g` suffices but reserve `-g3` or `-ggdb3` if you are having
    problems stepping through code, especially if it contains macros.
  prefs: []
  type: TYPE_NORMAL
- en: The next issue to consider is the level of code optimization. Compiler optimization
    tends to destroy the relationship between lines of source code and machine code,
    which makes stepping through the source unpredictable. If you experience problems
    like this you will most likely need to compile without optimization, leaving out
    the `-O` compile switch, or at least reduce it to level 1, using the compile switch
    `-O1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A related issue is that of stack frame pointers, which are needed by GDB to
    generate a back trace of function calls up to the current one. On some architectures,
    GCC will not generate stack frame pointers with higher levels of optimization
    (`-O2`). If you find yourself in the situation that you really have to compile
    with `-O2` but still want back traces, you can override the default behavior with
    `-fno-omit-frame-pointer`. Also look out for code that has been hand optimized
    to leave out frame pointers through the addition of `-fomit-frame-pointer`: you
    may want to temporarily remove them.'
  prefs: []
  type: TYPE_NORMAL
- en: Debugging applications using GDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can use GDB to debug applications in one of two ways. If you are developing
    code to run on desktops and servers, or indeed any environment where you compile
    and run the code on the same machine, it is natural to run GDB natively. However,
    most embedded development is done using a cross toolchain and hence you want to
    debug code running on the device, but control it from the cross-development environment
    where you have the source code and the tools. I will focus on the latter case
    since it is not so well documented and yet it is the most likely scenario for
    embedded developers. I am not going to describe the basics of using GDB here since
    there are many good references on that topic already, including the GDB manual
    and the suggested further reading at the end of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: I will begin with some details on working with gdbserver and then show you how
    to configure the Yocto Project and Buildroot for remote debug.
  prefs: []
  type: TYPE_NORMAL
- en: Remote debugging using gdbserver
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The key component for remote debugging is the debug agent, gdbserver, which
    runs on the target and controls execution of the program being debugged. Gdbserver
    connects to a copy of GDB running on the host machine via a network connection
    or an RS-232 serial interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Debugging through gdbserver is almost, but not quite, the same as debugging
    natively. The differences are mostly centered around the fact that there are two
    computers involved and they have to be in the right state for debugging to take
    place. Here are some things to look out for:'
  prefs: []
  type: TYPE_NORMAL
- en: At the start of a debug session you need to load the program you want to debug
    on the target using gdbserver and then separately load GDB from your cross toolchain
    on the host.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GDB and gdbserver need to connect to each other before a debug session can begin.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GDB, running onto the host, needs to be told where to look for debug symbols
    and source code, especially for shared libraries.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The GDB `run` command does not work as expected.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: gdbserver will terminate when the debug session ends and you will need to restart
    it if you want another debug session.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You need debug symbols and source code for the binaries you want to debug on
    the host, but not necessarily on the target. Often there is not enough storage
    space for them on the target and they will need to be stripped before deploying
    to the target.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The GDB/gdbserver combination does not have all the features of GDB running
    natively: for example, gdbserver cannot follow the child after `fork()` whereas
    native GDB can.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Odd things can happen if GDB and gdbserver are different versions or are the
    same version but configured differently. Ideally they should be built from the
    same source using your favorite build tool.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Debug symbols increase the size of executables dramatically, sometimes by a
    factor of 10\. As mentioned in [Chapter 5](ch05.html "Chapter 5. Building a Root
    Filesystem"), *Building a Root Filesystem*, it can be useful to remove debug symbols
    without recompiling everything. The tool for the job is strip from your cross
    toolchain. You can control the aggressiveness of the strip with these switches:'
  prefs: []
  type: TYPE_NORMAL
- en: '`--strip-all`: (default) removes all symbols'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--strip-unneeded`: removes symbols not needed for relocation processing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--strip-debug`: removes only debug symbols'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For applications and shared libraries, `--strip-all` (the default) is fine,
    but when it comes to kernel modules you will find that it will stop the module
    loading. Use `--strip-unneeded` instead. I am still working on a use case for
    `–strip-debug`.
  prefs: []
  type: TYPE_NORMAL
- en: With that in mind, let's look at the specifics involved in debugging with the
    Yocto Project and Buildroot.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the Yocto Project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Yocto Project builds a cross GDB for the host as part of the SDK, but you
    will have to make changes to your target configuration to include gdbserver in
    the target image. You can add the package explicitly, for example by adding this
    to `conf/local.conf`, noting once again that there must be a leading space at
    the start of this string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, you can `add tools-debug` to `EXTRA_IMAGE_FEATURES`, which will add both
    gdbserver and strace to the target image (I will talk about `strace` in the next
    chapter):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Setting up Buildroot
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With Buildroot, you need to enable options both to build the cross GDB for
    the host (assuming that you are using the Buildroot internal toolchain) and to
    build gdbserver for the target. Specifically you need to enable:'
  prefs: []
  type: TYPE_NORMAL
- en: '`BR2_PACKAGE_HOST_GDB`, in the menu **Toolchain** | **Build cross gdb for the
    host**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BR2_PACKAGE_GDB`, in the menu **Target packages** | **Debugging, profiling
    and benchmark** | **gdb**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BR2_PACKAGE_GDB_SERVER` in the menu **Target packages** | **Debugging, profiling
    and benchmark** | **gdbserver**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Starting to debug
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you have gdbserver installed on the target and a cross GDB on the host
    you can start a debug session.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting GDB and gdbserver
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The connection between GDB and gdbserver can be through a network or a serial
    interface. In the case of a network connection, you launch gdbserver with the
    TCP port number to listen on and, optionally, an IP address to accept connections
    from. In most cases you don''t care which IP address is going to connect, so you
    can just give the port number. In this example gdbserver waits for a connection
    on port `10000` from any host:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, start the copy of GDB from your toolchain, giving the same program as
    an argument so that GDB can load the symbol table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In GDB, you use the command `target remote` to make the connection, giving
    the IP address or host name of the target and the port it is waiting on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'When gdbserver sees the connection from the host it prints the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The procedure is similar for a serial connection. On the target, you tell gdbserver
    which serial port to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You may need to configure the port baud rate beforehand using `stty` or a similar
    program. A simple example would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'There are many other options to `stty`, please read the man page for more details.
    It is worthwhile noting that the port must not be used for anything else, for
    example, you can''t use a port that is being used as the system console. On the
    host, you make the connection to gdbserver using `target remote` plus the serial
    device at the host end of the cable. In most cases you will want to set the baud
    rate of the host serial port using the GDB command `set remotebaud`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Setting the sysroot
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: GDB needs to know where to find debug symbols and source code for shared libraries.
    When debugging natively the paths are well known and built in to GDB, but when
    using a cross toolchain, GDB has no way to guess where the root of the target
    filesystem is. You do so by setting the sysroot. The Yocto Project and Buildroot
    have different ways of handling library symbols so the location of the sysroot
    is quite different.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Yocto Project includes debug information in the target filesystem image,
    so you need to unpack the target image tar file that is generated in `build/tmp/deploy/images`,
    for which you would need to do something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Buildroot compiles libraries with minimal or full debug symbols, depending on
    `BR2_ENABLE_DEBUG`, puts them into the staging directory, then strips them as
    they are copied into target image. So, for Buildroot, the sysroot is always the
    staging area regardless of where the root filesystem is extracted.
  prefs: []
  type: TYPE_NORMAL
- en: GDB command files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are some things that you need to do each time you run GDB, for example,
    setting the sysroot. It is convenient to put such commands into a command file
    and run them each time GDB is started. GDB reads commands from `$HOME/.gdbinit`,
    then from `.gdbinit` in the current directory and then from files specified on
    the command line with the `-x` parameter. However, recent versions of GDB will
    refuse to load `.gdbinit` from the current directory for security reasons. You
    can override that behavior for a single directory by adding a line like this to
    your `$HOME/.gdbinit`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also disable the check globally by adding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: My personal preference is use the `-x` parameter to point to the command file,
    which exposes the location of the file so I don't forget about it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To help you set up GDB, Buildroot creates a GDB command file containing the
    correct sysroot command in `output/staging/usr/share/buildroot/gdbinit`. It will
    contain a command similar to this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Overview of GDB commands
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: GDB has a great many commands, which are described in the online manual and
    in the resources mentioned in the *Further Reading* section. To help you get going
    as quickly as possible, here is a list of the most commonly used commands. In
    most cases there is a short-hand for the command, which is listed underneath the
    full command.
  prefs: []
  type: TYPE_NORMAL
- en: Breakpoints
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following table shows the commands for breakpoints:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Commands | Use |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `break <location>``b <location>` | Set a breakpoint on a function name, line
    number or line. Examples are: `"main", "5", and "sortbug.c:42"` |'
  prefs: []
  type: TYPE_TB
- en: '| `info break``i b` | List breakpoints |'
  prefs: []
  type: TYPE_TB
- en: '| `delete break <N>``d b <N>` | Delete breakpoint `N` |'
  prefs: []
  type: TYPE_TB
- en: Running and stepping
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following table shows the commands for running and stepping:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Commands | Use |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `run``r` | Load a fresh copy of the program into memory and start it running.
    This does not work for remote debug using gdbserver |'
  prefs: []
  type: TYPE_TB
- en: '| `continue`c | Continue execution from a breakpoint |'
  prefs: []
  type: TYPE_TB
- en: '| `Ctrl-C` | Stop the program being debugged |'
  prefs: []
  type: TYPE_TB
- en: '| `step``s` | Step one line of code, stepping into any function that is called
    |'
  prefs: []
  type: TYPE_TB
- en: '| `next``n` | Step one line of code, stepping over a function call |'
  prefs: []
  type: TYPE_TB
- en: '| `finish` | Run until the current function returns |'
  prefs: []
  type: TYPE_TB
- en: Information commands
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following table shows the commands for getting information:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Commands | Use |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `backtrace``bt` | List the call stack |'
  prefs: []
  type: TYPE_TB
- en: '| `info threads` | Continue execution from a breakpoint |'
  prefs: []
  type: TYPE_TB
- en: '| `Info libs` | Stop the program |'
  prefs: []
  type: TYPE_TB
- en: '| `print <variable>``p <variable>` | Print the value of a variable, e.g. `print
    foo` |'
  prefs: []
  type: TYPE_TB
- en: '| `list` | List lines of code around the current program counter |'
  prefs: []
  type: TYPE_TB
- en: Running to a breakpoint
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Gdbserver loads the program into memory and sets a breakpoint at the first
    instruction, then waits for a connection from GDB. When the connection is made
    you enter into a debug session. However, you will find that if you try to single
    step immediately you will get this message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This is because the program is halted in code written in assembly that creates
    the run time environment for C and C++ programs. The first line of C or C++ code
    is the `main()` function. Supposing that you want to stop at `main()`, you would
    set a breakpoint there and then use the `continue` command (abbreviation `c`)
    to tell gdbserver to continue from the breakpoint at the start of the program
    and stop at main:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'If at this point you see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: That means that you have forgotten the set sysroot!
  prefs: []
  type: TYPE_NORMAL
- en: This is all very different to starting a program natively, where you just type
    `run`. In fact, if you try typing `run` in a remote debug session, you will either
    see a message saying that the remote target does not support `run`, or in older
    versions of GDB it will just hang without any explanation.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging shared libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To debug the libraries that are built by the build tool you will have to make
    a few changes to the build configuration. For libraries built outside the build
    environment you will have to do some extra work.
  prefs: []
  type: TYPE_NORMAL
- en: The Yocto Project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Yocto Project builds debug variants of binary packages and puts them into
    `build/tmp/deploy/<package manager>/<target architecture>`. Here is an example
    of the debug package, for the C library in this case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: You can add these debug packages selectively to your target image by adding
    `<package name-dbg>` to your target recipe. For `glibc`, the package is named
    `glibc-dbg`. Alternatively, you can simply tell the Yocto Project to install all
    debug packages by adding `dbg-pkgs` to `EXTRA_IMAGE_FEATURES`. Be warned that
    this will increase the size of the target image dramatically, perhaps by several
    hundred megabytes.
  prefs: []
  type: TYPE_NORMAL
- en: The Yocto Project places the debug symbols in a hidden directory named `.debug`
    in both the `lib` and `usr/lib`, directories. GDB knows to look for symbol information
    in these locations within the sysroot.
  prefs: []
  type: TYPE_NORMAL
- en: 'The debug packages also contain a copy of the source code which is installed
    into directory `usr/src/debug/<package name>` in the target image, which is one
    of the reasons for the increase in size. You can prevent it from happening by
    adding to your recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Remember, though, that when you are debugging remotely with gdbserver, you only
    need the debug symbols and source code on the host, not on the target. There is
    nothing to stop you from deleting the `lib/.debug`, `usr/lib/.debug` and `usr/src`
    directories from the copy of the image that is installed on the target.
  prefs: []
  type: TYPE_NORMAL
- en: Buildroot
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Buildroot is characteristically straightforward. You just need to rebuild with
    line-level debug symbols, for which you need to enable the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`BR2_ENABLE_DEBUG` in the menu **Build options** | **build packages with debugging
    symbols**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This will create the libraries with debug symbols in `output/host/usr/<arch>/sysroot`,
    but the copies in the target image are still stripped. If you need debug symbols
    on the target, perhaps to run GDB natively, you can disable stripping by setting
    **Build options** | **strip command for binaries on target** to `none`.
  prefs: []
  type: TYPE_NORMAL
- en: Other libraries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In addition to building with debug symbols you will have to tell GDB where
    to find the source code. GDB has a search path for source files, which you can
    see using the command `show directories`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'These are the default search paths: `$cdir` is the compile directory, which
    is the directory where the source was compiled; `$cwd` is the current working
    directory of GDB.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Normally these are sufficient, but if the source code has been moved you will
    have to use the directory command as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Just-in-time debugging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes a program will start to misbehave after it has been running for a
    while and you would like to know what it is doing. The GDB `attach` feature does
    exactly that. I call it just-in-time debugging. It is available with both native
    and remote debug sessions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of remote debugging, you need to find the PID of the process to
    be debugged and pass it to gdbserver with the `--attach` option. For example,
    if the PID is 109 you would type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: That forces the process to stop as if it were at a breakpoint, allowing you
    to start your cross GDB in the normal way and connect to gdbserver.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you are done you can detach, allowing the program to continue running
    without the debugger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Debugging forks and threads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What happens when the program you are debugging forks? Does the debug session
    follow the parent or the child? The behavior is controlled by `follow-fork-mode`
    which may be `parent` or `child`, with parent being the default. Unfortunately,
    current versions of gdbserver do not support this option, so it only works for
    native debugging. If you really need to debug the child process while using gdbserver,
    a workaround is to modify the code so that the child loops on a variable immediately
    after the fork, giving you the opportunity to attach a new gdbserver session to
    it and then to set the variable so that it drops out of the loop.
  prefs: []
  type: TYPE_NORMAL
- en: When a thread in a multithreaded process hits a breakpoint, the default behavior
    is for all threads to halt. In most cases this is the best thing to do as it allows
    you to look at static variables without them being changed by the other threads.
    When you recommence execution of the thread, all the stopped threads start up,
    even if you are single stepping, and it is especially this last case that can
    cause problems. There is a way to modify the way GDB handles stopped threads,
    through a parameter called `scheduler-locking`. Normally it is `off`, but if you
    set it to `on`, only the thread that was stopped at the breakpoint is resumed
    and the others remain stopped, giving you a chance to see what the thread alone
    does without interference. This continues to be the case until you turn scheduler-locking
    off. Gdbserver supports this feature.
  prefs: []
  type: TYPE_NORMAL
- en: Core files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Core files capture the state of a failing program at the point that it terminates.
    You don't even have to be in the room with a debugger when the bug manifests itself.
    So when you see `Segmentation fault (core dumped)`, don't shrug; investigate the
    core file and extract the goldmine of information in there.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first observation is that core files are not created by default, but only
    when the core file resource limit for the process is non-zero. You can change
    it for the current shell using `ulimit -c`. To remove all limits on the size of
    core files, type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: By default, the core file is named `core` and is placed in the current working
    directory of the process, which is the one pointed to by `/proc/<PID>/cwd`. There
    are a number of problems with this scheme. Firstly, when looking at a device with
    several files named `core` it is not obvious which program generated each one.
    Secondly, the current working directory of the process may well be in a read-only
    filesystem, or there may not be enough space to store the `core` file, or the
    process may not have permissions to write to the current working directory.
  prefs: []
  type: TYPE_NORMAL
- en: There are two files that control the naming and placement of `core` files. The
    first is `/proc/sys/kernel/core_uses_pid`. Writing a `1` to it causes the PID
    number of the dying process to be appended to the filename, which is somewhat
    useful as long as you can associate the PID number with a program name from log
    files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Much more useful is `/proc/sys/kernel/core_pattern`, which gives you a lot
    more control over `core` files. The default pattern is `core` but you can change
    it to a pattern composed of these meta characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`%p`: the PID'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%u`: the real UID of the dumped process'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%g`: the real GID of the dumped process'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%s`: number of the signal causing the dump'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%t`: the time of dump, expressed as seconds since the Epoch, 1970-01-01 00:00:00
    +0000 (UTC)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%h`: the hostname'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%e`: the executable filename'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%E`: the pathname of the executable, with slashes (`/`) replaced by exclamation
    marks (`!`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%c`: the core file size soft resource limit of the dumped process'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can also use a pattern that begins with an absolute directory name so that
    all `core` files are gathered together in one place. As an example, the following
    pattern puts all core files into the `/corefiles` directory and names them with
    the program name and the time of the crash:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Following a core dump, you would find something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: For more information, refer to the man page *core(5)*.
  prefs: []
  type: TYPE_NORMAL
- en: 'For more sophisticated processing of core files you can pipe them to a program
    that does some post processing. The core pattern begins with a pipe symbol `|`
    followed by the program name and parameters. My Ubuntu 14.04, for example, has
    this core pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Apport is the crash reporting tool used by Canonical. A crash reporting tool
    run in this way is run while the process is still in memory, and the kernel passes
    the core image data to it on standard input. Thus, this program can process the
    image, possibly stripping parts of it to reduce the size in the filesystem, or
    just scanning it at the time of the core dump for specific information. The program
    can look at various pieces of system data, for example, reading the `/proc` filesystem
    entries for the program, and can use ptrace system calls to operate on the program
    and read data from it. However, once the core image data is read from standard
    in, the kernel does various cleanups that make information about the process no
    longer available.
  prefs: []
  type: TYPE_NORMAL
- en: Using GDB to look at core files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here is a sample GDB session looking at a core file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'That shows that the program stopped at line 43\. The `list` command shows the
    code in the immediate vicinity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The `backtrace` command (shortened to `bt`) shows how we got to this point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'An obvious mistake: `addtree()` was called with a null pointer.'
  prefs: []
  type: TYPE_NORMAL
- en: GDB user interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GDB is controlled at a low level through the GDB machine interface, GDB/MI,
    which is used to wrap GDB in a user interface or as part of a larger program and
    considerably extends the range of options available to you.
  prefs: []
  type: TYPE_NORMAL
- en: I have only mentioned those which have features that are useful in embedded
    development.
  prefs: []
  type: TYPE_NORMAL
- en: Terminal user interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Terminal user interface** (**TUI**), is an optional part of the standard
    GDB package. The main feature is a code window which shows the line of code about
    to be executed, together with any breakpoints. It is a definite improvement on
    the `list` command in command-line mode GDB.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The attraction of TUI is that it just works and doesn''t need any extra set-up
    and, since it is in text mode, it is possible to use over an ssh terminal session
    when running `gdb` natively on a target. Most cross toolchains configure GDB with
    TUI. Simply add `-tui` to the command line and you will see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Terminal user interface](img/B03982_12_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Data display debugger
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Data display debugger** (**DDD**), is a simple standalone program that gives
    you a graphical user interface to GDB with minimal fuss and bother and, although
    the UI controls look dated, it does everything that is necessary.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `--debugger` option tells DDD to use GDB from your toolchain and you can
    use the `-x` argument for GDB command files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows off one of the nicest features: the data window
    which contains items in a grid that you can rearrange as you wish. If you double-click
    on a pointer, it is expanded into a new data item and the link is shown with an
    arrow:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Data display debugger](img/B03982_12_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Eclipse
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Eclipse, with the **C development toolkit** (**CDT**) plug-in, supports debugging
    with GDB, including remote debugging. If you use Eclipse for all your code development,
    this is the obvious tool to use but, if you are not a regular Eclipse user it
    is probably not worth the effort of setting it up just for this task. It would
    take me a whole chapter to explain adequately how to configure CDT to work with
    a cross toolchain and connect to a remote device, so I will refer you to the references
    at the end of the chapter for more information. The screenshot that follows shows
    the debug perspective of CDT. In the the top right window you see the stack frames
    for each of the threads in the process, and at the top right is the watch window
    showing variables. In the middle is the code window, showing the line of code
    where the debugger has stopped the program.
  prefs: []
  type: TYPE_NORMAL
- en: '![Eclipse](img/B03982_12_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Debugging kernel code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Debugging application code helps you gain insight into the way code works and
    what is happening when it misbehaves and you can do the same with the kernel,
    with some limitations.
  prefs: []
  type: TYPE_NORMAL
- en: You can use `kgdb` for source level debugging, in a manner similar to remote
    debugging with `gdbserver`. There is also a self-hosted kernel debugger, `kdb`,
    that is handy for lighter weight tasks such as seeing if an instruction is executed
    and getting the backtrace to find out how it got there. Finally, there are kernel
    oops messages and panics, which tell you a lot about the cause of a kernel exception.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging kernel code with kgdb
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When looking at kernel code using a source debugger, you must remember that
    the kernel is a complex system, with real-time behaviors. Don't expect debugging
    to be as easy as it is for applications. Stepping through code that changes the
    memory mapping or switches context is likely to produce odd results.
  prefs: []
  type: TYPE_NORMAL
- en: '`kgdb` is the name given to the kernel GDB stubs that have been part of mainline
    Linux for many years now. There is a user manual in the kernel DocBook and you
    can find an online version at [https://www.kernel.org/doc/htmldocs/kgdb/index.html](https://www.kernel.org/doc/htmldocs/kgdb/index.html).'
  prefs: []
  type: TYPE_NORMAL
- en: The widely supported way to connect to kgdb is over the serial interface, which
    is usually shared with the serial console, and so this implementation is called
    `kgdboc`, meaning kgdb over console. To work, it requires a platform tty driver
    that supports I/O polling instead of interrupts, since kgdb has to disable interrupts
    when communicating with GDB. A few platforms support kgdb over USB and there have
    been versions that work over Ethernet but, unfortunately, none of those have found
    their way into mainline Linux.
  prefs: []
  type: TYPE_NORMAL
- en: The same caveats about optimization and stack frames apply to the kernel, with
    the limitation that the kernel is written to assume an optimization level of at
    least `-O1`. You can override the kernel compile flags by setting `KCGLAGS` before
    running `make`.
  prefs: []
  type: TYPE_NORMAL
- en: 'These, then, are the kernel configuration options you will need for kernel
    debugging:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CONFIG_DEBUG_INFO` is in the **Kernel hacking** | **Compile-time checks and
    compiler options** | **Compile the kernel with debug info menu**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CONFIG_FRAME_POINTER` may be an option for your architecture, and is in the
    **Kernel hacking** | **Compile-time checks and compiler options** | **Compile
    the kernel with frame pointers menu**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CONFIG_KGDB` is in the **Kernel hacking** | **KGDB: kernel debugger menu**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CONFIG_KGDB_SERIAL_CONSOLE` is in the **Kernel hacking** | **KGDB: kernel
    debugger** | **KGDB: use kgdb over the serial console menu**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In addition to the `uImage` or `zImage` compressed kernel image, you will need
    the kernel image in ELF object format so that GDB can load the symbols into memory.
    That is the file called `vmlinux` that is generated in the directory where Linux
    is built. In the Yocto Project, you can request that a copy be included in the
    target image, which is convenient for this and other debug tasks. It is built
    into a package named `kernel-vmlinux`, which you can install like any other, for
    example by adding it to the `IMAGE_INSTALL_append` list. The file is put into
    the boot directory, with a name like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In Buildroot, you will find `vmlinux` in the directory where the kernel was
    built, which is in `output/build/linux-<version string>/vmlinux`.
  prefs: []
  type: TYPE_NORMAL
- en: A sample debug session
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The best way to show you how it works is with a simple example.
  prefs: []
  type: TYPE_NORMAL
- en: 'You need to tell `kgdb` which serial port to use, either through the kernel
    command line or at runtime via `sysfs`. For the first option, add `kgdboc=<tty>,<baud
    rate>` to the command line, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'For the second option, boot the device up and write the terminal name to the
    `/sys/module/kgdboc/parameters/kgdboc` file, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Note that you cannot set the baud rate in this way. If it is the same `tty`
    as the console then it is set already, if not use `stty` or a similar program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you can start GDB on the host, selecting the `vmlinux` file that matches
    the running kernel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: GDB loads the symbol table from `vmlinux` and waits for further input.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, close any terminal emulator that is attached to the console: you are
    about to use it for GDB and, if both are active at the same time, some of the
    debug strings might get corrupted.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you can return to GDB and attempt to connect to `kgdb`. However, you will
    find that the response you get from `target remote` at this time is unhelpful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The problem is that `kgdb` is not listening for a connection at this point.
    You need to interrupt the kernel before you can enter into an interactive GDB
    session with it. Unfortunately, just typing *Ctrl* + *C* in GDB, as you would
    with an application, does not work. You have to force a trap into the kernel by
    launching another shell on the target, via ssh, for example, and writing a `g`
    to `/proc/sysrq-trigger` on the target board:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The target stops dead at this point. Now you can connect to `kgdb` via the
    serial device at the host end of the cable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'At last, GDB is in charge. You can set breakpoints, examine variables, look
    at backtraces, and so on. As an example, set a break on `sys_sync`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Now the target comes back to life. Typing `sync` on the target calls `sys_sync`
    and hits the breakpoint.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'If you have finished the debug session and want to disable `kgdboc`, just set
    the `kgdboc` terminal to null:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Debugging early code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The preceding example works in cases where the code you are interested in is
    executed when the system is fully booted. If you need to get in early, you can
    tell the kernel to wait during boot by adding `kgdbwait` to the command line,
    after the `kgdboc` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when you boot, you will see this on the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: At this point, you can close the console and connect from GDB in the usual way.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Debugging kernel modules presents an additional challenge because the code is
    relocated at runtime and so you need to find out at what address it resides. The
    information is presented via `sysfs`. The relocation addresses for each section
    of the module are stored in `/sys/module/<module name>/sections`. Note that, since
    ELF sections begin with a dot, '.', they appear as hidden files and you will have
    to use `ls -a` if you want to list them. The important ones are `.text`, `.data`,
    and `.bss`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take as an example a module named `mbx`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can use these numbers in GDB to load the symbol table for the module
    at those addresses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Everything should now work as normal: you can set breakpoints and inspect global
    and local variables in the module just as you can in `vmlinux`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, force the device driver to call `mbx_write` and it will hit the breakpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Debugging kernel code with kdb
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although `kdb` does not have the features of `kgdb` and GDB, it does have its
    uses and, being self-hosted, there are no external dependencies to worry about.
    `kdb` has a simple command-line interface which you can use on a serial console.
    You can use it to inspect memory, registers, process lists, `dmesg`, and even
    set breakpoints to stop in a certain location.
  prefs: []
  type: TYPE_NORMAL
- en: 'To configure `kgd` for access via a serial console, enable `kgdb` as shown
    previously and then enable this additional option:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CONFIG_KGDB_KDB`, which is in the **KGDB:** **Kernel hacking** | **kernel
    debugger** | **KGDB_KDB: include kdb frontend for kgdb** menu'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, when you force the kernel to a trap, instead of entering into a GDB session,
    you will see the `kdb` shell on the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: There are quite a few things you can do in the `kdb` shell. The `help` command
    will print all of the options. Here is an overview.
  prefs: []
  type: TYPE_NORMAL
- en: 'Getting information:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ps`: displays active processes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ps A`: displays all processes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lsmod`: lists modules'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dmesg`: displays the kernel log buffer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Breakpoints:'
  prefs: []
  type: TYPE_NORMAL
- en: '`bp`: sets a breakpoint'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bl`: lists breakpoints'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bc`: clears a breakpoint'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bt`: prints a backtrace'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`go`: continues execution'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Inspect memory and registers:'
  prefs: []
  type: TYPE_NORMAL
- en: '`md`: displays memory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rd`: displays registers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is a quick example of setting a break point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The kernel returns to life and the console shows the normal bash prompt. If
    you type `sync`, it hits the breakpoint and enters `kdb` again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '`kdb` is not a source debugger so you can''t see the source code, or single
    step. However, you can display a backtrace using the `bt` command, which is useful
    to get an idea of program flow and call hierarchy.'
  prefs: []
  type: TYPE_NORMAL
- en: When the kernel performs an invalid memory access or executes an illegal instruction,
    a kernel oops message is written to the kernel log. The most useful part of this
    is the backtrace, and I want to show you how to use the information there to locate
    the line of code that caused the fault. I will also address the problem of preserving
    oops messages if they cause the system to crash.
  prefs: []
  type: TYPE_NORMAL
- en: Looking at an oops
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An oops message looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '`PC is at mbx_write+0x14/0x98 [mbx]` tells you most of what you want to know:
    the last instruction was in the `mbx_write` function in a kernel module named
    `mbx`. Furthermore, it was at offset `0x14` bytes from the start of the function,
    which is `0x98` bytes long.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, take a look at the backtrace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we don't learn much more, merely that `mbx_write` is called from
    the virtual filesystem code.
  prefs: []
  type: TYPE_NORMAL
- en: 'It would be very nice to find the line of code that relates to `mbx_write+0x14`,
    for which we can use `objdump`. We can see from `objdump -S` that `mbx_write`
    is at offset `0x8c` in `mbx.ko`, so that last instruction executed is at `0x8c
    + 0x14 = 0xa0`. Now, we just need to look at that offset and see what is there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'This shows the instruction where it stopped. The last line of code is shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see that `m` has the type `struct mbx_data *`. Here is the place where
    that structure is defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: So, it looks like the `m` variable is a null pointer, and that is causing the
    oops.
  prefs: []
  type: TYPE_NORMAL
- en: Preserving the oops
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Decoding an oops is only possible if you can capture it in the first place.
    If the system crashes during boot before the console is enabled, or after a suspend,
    you won't see it. There are mechanisms to log kernel oops and messages to an MTD
    partition or to persistent memory, but here is a simple technique that works in
    many cases and needs little prior thought.
  prefs: []
  type: TYPE_NORMAL
- en: 'So long as the contents of memory are not corrupted during a reset (and usually
    they are not), you can reboot into the bootloader and use it to display memory.
    You need to know the location of the kernel log buffer, remembering that it is
    a simple ring buffer of text messages. The symbol is `__log_buf`. Look this up
    in `System.map` for the kernel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Then, map that kernel logical address into a physical address that U-Boot can
    understand by subtracting `PAGE_OFFSET`, `0xc0000000`, and adding the physical
    start of RAM, `0x80000000` on a BeagleBone, so `c0f72428 – 0xc0000000 + 0x80000000
    = 80f72428`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then use the U-Boot `md` command to show the log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: From Linux 3.5 onwards, there is a 16-byte binary header for each line in the
    kernel log buffer which encodes a timestamp, a log level and other things. There
    is a discussion about it in the Linux Weekly News titled *Toward more reliable
    logging* at [https://lwn.net/Articles/492125/](https://lwn.net/Articles/492125/).
  prefs: []
  type: TYPE_NORMAL
- en: Additional reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following resources have further information about the topics introduced
    in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '*The Art of Debugging with GDB, DDD, and Eclipse*, by *Norman Matloff* and
    *Peter Jay Salzman*, *No Starch Press*; 1 edition (28 Sept. 2008), ISBN 978-1593271749'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*GDB Pocket Reference* by *Arnold Robbins*, *O''Reilly Media*; 1st edition
    (12 May 2005), ISBN 978-0596100278'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Getting to grips with Eclipse: cross compiling*, [http://2net.co.uk/tutorial/eclipse-cross-compile](http://2net.co.uk/tutorial/eclipse-cross-compile)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Getting to grips with Eclipse: remote access and debugging*, [http://2net.co.uk/tutorial/eclipse-rse](http://2net.co.uk/tutorial/eclipse-rse)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GDB for interactive debugging is a useful tool in the embedded developer's tool
    chest. It is a stable, well-documented and well-known entity. It has the ability
    to debug remotely by placing an agent on the target, be it `gdbserver` for applications
    or `kgdb` for kernel code and, although the default command-line user interface
    takes a while to get used to, there are many alternative front-ends. The three
    I mentioned were TUI, DDD, and Eclipse, which should cover most situations, but
    there are other front-ends around that you can try.
  prefs: []
  type: TYPE_NORMAL
- en: A second and equally important way to approach debugging is to collect crash
    reports and analyze them offline. In this category, I have looked at application
    core dumps and kernel oops messages.
  prefs: []
  type: TYPE_NORMAL
- en: However, this is only one way of identifying flaws in programs. In the next
    chapter, I will talk about profiling and tracing as ways of analyzing and optimizing
    programs.
  prefs: []
  type: TYPE_NORMAL
