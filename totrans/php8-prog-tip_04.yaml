- en: '*Chapter 3*: Taking Advantage of Error-Handling Enhancements'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you've been a PHP developer for any length of time, you will have noticed
    that as the language continues to mature, more safeguards are put into place that
    ultimately enforce good coding practices. Along these lines, one of the key improvements
    in PHP 8 is its advanced error-handling capabilities. In this chapter, you will
    learn which `Notices` have been upgraded to `Warnings`, and which `Warnings` have
    been upgraded to `Errors`.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter gives you an excellent understanding of the background and intent
    of the security enhancements, allowing you to better control the use of your code.
    In addition, it's critical to be aware of error conditions that formerly only
    generated `Warnings` but now also generate `Errors`, in order to take measures
    to prevent your applications from failing following an upgrade to PHP 8.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics are covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding PHP 8 error handling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dealing with warnings that are now errors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding notices promoted to warnings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling the `@` error control operator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To examine and run the code examples provided in this chapter, the minimum
    recommended hardware is listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: x86_64 based desktop PC or laptop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 **gigabyte** (**GB**) free disk space
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 4 GB of **random-access memory** (**RAM**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 500 **kilobits per second** (**Kbps**) or faster internet connection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In addition, you will need to install the following software:'
  prefs: []
  type: TYPE_NORMAL
- en: Docker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker Compose
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Please refer to the *Technical requirements* section of [*Chapter 1*](B16992_01_Final_JC_ePub.xhtml#_idTextAnchor013),
    *Introducing New PHP 8 OOP Features,* for more information on Docker and Docker
    Compose installation, as well as how to build the Docker container used to demonstrate
    the code explained in this book. Throughout this book, we refer to the directory
    in which you restored the sample code for this book as `/repo`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The source code for this chapter is located here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/PHP-8-Programming-Tips-Tricks-and-Best-Practices](https://github.com/PacktPublishing/PHP-8-Programming-Tips-Tricks-and-Best-Practices)'
  prefs: []
  type: TYPE_NORMAL
- en: We can now begin our discussion by examining new PHP 8 operators.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding PHP 8 error handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Historically, many PHP error conditions were assigned an error level far below
    their actual severity. This gave developers a false sense of security as seeing
    *only* a `Notice` led them to believe that their code was not deficient. Many
    situations only formerly generated a `Notice` or a `Warning` when in fact their
    seriousness merited greater attention.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we look at a number of error-handling enhancements in PHP 8
    that continue with the overall trend of enforcing good coding practices. The discussion
    in this chapter will help you to re-examine your code, with an eye toward greater
    efficiency and fewer maintenance issues down the road.
  prefs: []
  type: TYPE_NORMAL
- en: In the next several subsections, we have a look at changes to certain `Notice`
    and `Warning` error conditions that could have an impact on your code. Let's first
    have a look at changes in how PHP 8 handles undefined variables.
  prefs: []
  type: TYPE_NORMAL
- en: Undefined variable handling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One notorious feature of PHP is how it treats **undefined variables**. Have
    a look at this simple block of code. Note that the `$a` and `$b` variables have
    not been defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Running under PHP 7, here''s the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from the output, PHP 7 emits a `Notice`, letting us know we
    are using variables that have not been defined. If we run exactly the same code
    using PHP 8, you can quickly see that what was previously a `Notice` has been
    promoted to a `Warning`, as illustrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The reasoning behind this error-level promotion in PHP 8 is that the use of
    undefined variables, thought by many developers to be a harmless practice, is
    actually **quite dangerous**! *Why?*, you might ask. The answer is that PHP silently,
    without your explicit direction, assigns a value of `NULL` to any undefined variable.
    Effectively, your program is relying upon a default behavior of PHP that could
    change in future upgrades to the language.
  prefs: []
  type: TYPE_NORMAL
- en: We cover other error-level promotions in the next few sections of this chapter.
    Please note, however, that situations where `Notices` are promoted to `Warnings`
    *will not affect the functioning of your code*. It might serve to bring more potential
    problems to your attention, however, and if so, serves the purpose of producing
    better code. Unlike undefined variables, undefined constants' errors have now
    been even further promoted, as you'll see in the next subsection.
  prefs: []
  type: TYPE_NORMAL
- en: Undefined constant handling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The treatment of **undefined constants** has changed when running under PHP
    8\. However, in this case, what was previously a `Warning` is now an `Error` in
    PHP 8\. Have a look at this innocuous-looking block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The first line echoes a `PHP_OS` **pre-defined constant** that identifies the
    operating system. In PHP 7, a `Notice` is generated; however, the last line of
    output is `Program Continues ...`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The same code now produces a *fatal error* when running in PHP 8, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Accordingly, any bad code you have lying around that fails to first define any
    constants before use will crash and burn in PHP 8! A good habit is to assign a
    default value to all variables at the start of your application code. If you plan
    to use constants, it's also a good idea to define them as soon as possible, preferably
    in one place.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: One idea is to define all constants in an *included file*. If this is the case,
    be sure that any program script using such constants has loaded the file containing
    the constant definition.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: '**Best practice**: Assign default values to all variables at the beginning
    of your program code before use. Be sure to define any custom constants before
    they are used. If this is the case, be sure that any program script using such
    constants has loaded the file containing the constant definition.'
  prefs: []
  type: TYPE_NORMAL
- en: Error-level defaults
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It''s useful to note that the error-level defaults assigned to the `php.ini`
    file `error_reporting` directive have been updated in PHP 8\. In PHP 7, the default
    `error_reporting` level was as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In PHP 8, the new level is much simpler, as you can see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: It's also worth noting that the `php.ini` file setting `display_startup_errors`
    is now enabled by default. This might be an issue for production servers, as your
    website might start to unintentionally reveal error information upon PHP startup.
  prefs: []
  type: TYPE_NORMAL
- en: The key takeaway from this section is that in the past, PHP has allowed you
    to *get away with* certain bad practices by only issuing `Notices` or `Warnings`.
    As you've learned in this section, however, the danger in not addressing the issues
    behind the `Warning` or `Notice` generation lies in the actions PHP silently takes
    on your behalf. Not relying upon PHP to make decisions on your behalf leads to
    fewer hidden logic errors. Following good coding practices, such as that of assigning
    defaults to all variables before they are used, helps you to avoid such errors.
    Let's now have a closer look at error situations where `Warnings` have been promoted
    to `Errors` in PHP 8.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with warnings that are now errors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we look at upgraded PHP 8 error handling pertaining to objects,
    arrays, and strings. We also examine situations where, in the past, PHP issued
    a `Warning` but where PHP 8 now throws an `Error`. It is critical that you become
    aware of any of the potential error situations addressed in this section. The
    reason is simple: if you fail to address the situations described in this section,
    when your server is upgraded to PHP 8 your code will break.'
  prefs: []
  type: TYPE_NORMAL
- en: Developers are often pressed for time. It could be that there's a massive queue
    of new features or other changes that must be made. In other cases, resources
    have been pulled away to other projects, meaning fewer developers are available
    to perform maintenance. `Warnings` are often ignored because the application continues
    to run, so many developers simply turn off the error display and hope for the
    best.
  prefs: []
  type: TYPE_NORMAL
- en: Over the years, mountains upon mountains of badly written code have accumulated.
    Unfortunately, the PHP community is now paying the price, in the form of mysterious
    runtime errors that take hours to track down. By promoting to `Error` certain
    dangerous practices previously raising only a `Warning`, bad coding practices
    quickly become apparent in PHP 8 as `Errors` are fatal and cause the application
    to stop running.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by examining error promotion in object error handling.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: As a general rule, in PHP 8, `Warnings` are promoted to `Errors` when an attempt
    is made to *write* data. On the other hand, for the same general circumstance
    (for example, attempting to read/write properties of non-existent objects), a
    `Notice` is promoted to a `Warning` in PHP 8 when an attempt is made to *read*
    data. The overall rationale is that write attempts could result in loss or corruption
    of data, whereas read attempts do not.
  prefs: []
  type: TYPE_NORMAL
- en: Promoted warnings in object error handling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here is a brief summation of `Warnings` that are now `Errors` pertaining to
    the treatment of objects. PHP 8 will throw an `Error` if you attempt to do the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: Increment/decrement a property of a non-object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modify a property of a non-object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assign a value to a property of a non-object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a default object from an empty value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s have a look at a simple example. In the following code snippet, a value
    is assigned to a non-existent object, `$a`. This value is then incremented:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the PHP 7 output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, in PHP 7 a `stdClass()` instance is silently created and a
    `Warning` is issued, but the operation is allowed to continue. If we run the same
    code under PHP 8, notice here the difference in output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The good news is in PHP 8 the `Error` is **thrown**, which means we could easily
    catch it by implementing a `try()/catch()` block. As an example, here''s how the
    code shown previously might be rewritten:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, any problems with the three lines are now wrapped safely inside
    a `try()/catch()` block, meaning that recovery is possible. We now turn our attention
    to array error-handling enhancements.
  prefs: []
  type: TYPE_NORMAL
- en: Promoted warnings in array handling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A number of bad practices regarding arrays, allowed in PHP 7 and earlier versions,
    now throw an `Error`. As discussed in the previous subsection, PHP 8 array error-handling
    changes serve to give you a more forceful response to the error situations we
    describe here. The ultimate goal of these enhancements is to nudge developers
    toward good coding practices.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is brief list of array-handling warnings promoted to errors:'
  prefs: []
  type: TYPE_NORMAL
- en: Cannot add an element to the array as the next element is already occupied
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cannot unset the offset in a non-array variable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Only `array` and `Traversable` types can be unpacked
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Illegal offset types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's now examine each of the error conditions on this list, one by one.
  prefs: []
  type: TYPE_NORMAL
- en: Next element already occupied
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In order to illustrate one possible scenario where the next array element cannot
    be assigned as it''s already occupied, have a look at this simple code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Assume that, for some reason, an assignment is made to an array element whose
    numeric key is the largest-sized integer possible (represented by the `PHP_INT_MAX`
    pre-defined constant). If we subsequently attempt to assign a value to the next
    element, we have a problem!
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the result of running this block of code in PHP 7:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In PHP 8, however, the `Warning` has been promoted to an `Error`, with this
    output as a result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Next, we turn our attention to the use of offsets in non-array variables.
  prefs: []
  type: TYPE_NORMAL
- en: Offsets in non-array variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Treating a non-array variable as an array can produce unexpected results, with
    the exception of certain object classes that implement a `Traversable` (`ArrayObject`
    or `ArrayIterator` as examples). A case in point is using array-style offsets
    on a string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Accessing string characters using array syntax can be useful in some cases.
    One example is checking to see if a **Uniform Resource Locator** (**URL**) ends
    with a trailing comma or slash. In the following code example, we check to see
    if a URL ends with a trailing slash. If so, we chop it off using `substr()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In the example shown previously, the `$url[-1]` array syntax gives you access
    to the last character in the string.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: You could also use the new PHP 8 `str_ends_with()` function to do the same thing!
  prefs: []
  type: TYPE_NORMAL
- en: However, strings are definitely **not** arrays and should not be treated as
    such. In order to avoid bad code potentially leading to unexpected results, minor
    abuse of the ability to reference string characters using array syntax has been
    curtailed in PHP 8.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code example, we attempt to use `unset()` on a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code example will actually generate a fatal error in both PHP
    7 and 8\. Likewise, do not use a non-array (or non-`Traversable` object) as an
    argument to a `foreach()` loop. In the example shown next, a string is supplied
    as an argument to `foreach()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In PHP 7 and earlier versions, a `Warning` is generated but the code continues.
    Here is the output when running in PHP 7.1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Interestingly, PHP 8 also allows the code to continue, but the `Warning` message
    is slightly more detailed, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Next, we have a look at situations where in the past you could get away with
    unpacking non-array/non-`Traversable` types.
  prefs: []
  type: TYPE_NORMAL
- en: Array unpacking
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'After seeing this sub-section title, you may well ask: *what is array unpacking?*
    Much like the concept of de-referencing, **unpacking** an array is simply a term
    for extracting values from an array into discrete variables. As an example, consider
    the following simple code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We start the example by defining a simple function that adds two numbers, as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'For the sake of the following illustration, assume that the data is in the
    form of an array of number pairs, each to be added:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In a loop, we use the variadics operator (`...`) to unpack the array pairs
    in the call to the `add()` function, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The example just shown demonstrates how a developer can force unpacking by
    using the variadics operator. However, many PHP array functions perform an unpacking
    operation internally. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we define an array whose elements comprise letters of the alphabet.
    If we echo the return value of `array_pop()` we see the letter `Z` as output,
    as illustrated in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We can achieve the same result using `implode()` to flatten the array into
    a string, and use string de-referencing to return the last letter, as illustrated
    in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if we attempt to use `array_pop()` on a string as shown here, in PHP
    7 and earlier versions we get a `Warning`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`echo array_pop($alpha);`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the output when running under PHP 7.1:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'And here is the output from the same code file but when running under PHP 8:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: As we have mentioned, here is yet another example of where a situation formerly
    resulting in a `Warning` now results in `TypeError` in PHP 8\. However, both sets
    of output also illustrate the fact that although you can de-reference a string
    as you would an array, strings cannot be unpacked in the same manner as arrays.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we examine illegal offset types.
  prefs: []
  type: TYPE_NORMAL
- en: Illegal offset types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'According to the PHP documentation ([https://www.php.net/manual/en/language.types.array.php](https://www.php.net/manual/en/language.types.array.php)),
    an array is an ordered list of key/value pairs. The array keys, also called **indices**
    or **offsets**, can be one of two data types: `integer` or `string`. If an array
    consists only of `integer` keys, it is often referred to as a **numeric array**.
    An **associative array**, on the other hand, is a term used where `string` indices
    are used. An **illegal offset** would be where the array key is of a data type
    other than `integer` or `string`.'
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: 'Interestingly, the following code snippet does not generate a `Warning` or
    an `Error`: `$x = (float) 22/7; $arr[$x] = ''Value of Pi'';`. The value of `$x`
    is first converted to an `integer`, truncating any decimal component, before the
    array assignment is made.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, have a look at this code fragment. Note that the index key for
    the last array element is an object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The output running under PHP 7 produces the `var_dump()` output with a `Warning`,
    as illustrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'In PHP 8, however, `var_dump()` is never executed as a `TypeError` is thrown,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The same principle regarding illegal array offsets is present when using `unset()`,
    as illustrated in this code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The stricter control of array index keys is also seen when using illegal offsets
    in `empty()` or `isset()`, as shown in this code fragment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In both of the previous code examples, in PHP 7 and earlier the code example
    completes with a `Warning`, whereas in PHP 8 an `Error` is thrown. Unless the
    `Error` is caught, the code example will not complete.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: '**Best practice**: When initializing an array, be sure that the array index
    data type is either an `integer` or a `string`.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we have a look at error promotions in string handling.
  prefs: []
  type: TYPE_NORMAL
- en: Promoted warnings in string handling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The same discussion about promoted warnings pertaining to objects and arrays
    also applies to PHP 8 string error handling. In this subsection, we examine two
    string-handling `Warnings` promoted to `Errors`, outlined here:'
  prefs: []
  type: TYPE_NORMAL
- en: Offset not contained in the string
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Empty string offset
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start by examining offsets not contained in a string.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Offset not contained in the string.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As an example of the first situation, have a look at the following code sample.
    Here, we start with a string assigned all letters of the alphabet. We then use
    `strpos()` to return the position of the letter `Z`, starting at offset `0`. On
    the next line, we do the same thing; however, the offset of `27` is off the end
    of the string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'In PHP 7, as expected, an output of `Z` is returned, with a `Warning` from
    `strpos()` and a `Notice` that an offset cast (more on that in the next section)
    occurred. Here is the PHP 7 output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'In PHP 8, however, a fatal `ValueError` is thrown, as seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The key point we need to convey in this situation is that allowing such bad
    coding to remain was marginally acceptable in the past. Following a PHP 8 upgrade,
    however, as you can clearly see from the output, your code will fail. Now, let's
    have a look at empty string offsets.
  prefs: []
  type: TYPE_NORMAL
- en: Empty string offset error handling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Believe it or not, in versions of PHP prior to PHP 7, developers were allowed
    to remove characters from a string by assigning an empty value to the target offset.
    As an example, have a look at this block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The intent of this code example is to remove the letter `F` from the string
    represented by `$str`. Amazingly, in PHP 5.6, you can see from this screenshot
    that the attempt is entirely successful:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – PHP 5.6 output showing successful character removal'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_3.1_B16992.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.1 – PHP 5.6 output showing successful character removal
  prefs: []
  type: TYPE_NORMAL
- en: Please note that the virtual environments we use to demonstrate code in this
    book allow access to both PHP 7.1 and PHP 8\. In order to properly demonstrate
    how PHP 5 behaved, we mounted a PHP 5.6 Docker image and took a screenshot of
    the result.
  prefs: []
  type: TYPE_NORMAL
- en: 'In PHP 7, however, this practice is prohibited and a `Warning` is issued, as
    seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from the preceding output, the script is allowed to execute;
    however, the attempt to remove the letter `F` is unsuccessful. In PHP 8, as we
    have discussed, the `Warning` is promoted to an `Error` and the entire script
    aborts, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We next examine situations where former `Notices` are promoted to `Warnings`
    in PHP 8.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding notices promoted to warnings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a number of situations that are considered less critical to the stability
    of the PHP engine during runtime that were underrated in versions of PHP prior
    to PHP 7\. Unfortunately, it was customary for new (or perhaps lazy!) PHP developers
    to simply ignore `Notices` in their rush to get their code into production.
  prefs: []
  type: TYPE_NORMAL
- en: PHP standards have dramatically tightened over the years, leading the PHP core
    team to upgrade certain error conditions from `Notice` to `Warning`. Neither error
    reporting level will cause the code to stop working. However, it is felt by the
    PHP core team that the *Notice-to-Warning* promotion will make bad programming
    practices keenly visible. `Warnings` are much less likely to be ignored, ultimately
    leading to better code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a brief list of error conditions leading to a `Notice` being issued
    in earlier versions of PHP, where the same condition now generates a `Warning`
    in PHP 8:'
  prefs: []
  type: TYPE_NORMAL
- en: Non-existent object property access attempts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Non-existent static property access attempts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attempt to access an array element using a non-existent key
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Misusing a resource as an array offset
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ambiguous string offset cast
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Non-existent or uninitialized string offset
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's first have a look at `Notice` promotions in cases involving objects.
  prefs: []
  type: TYPE_NORMAL
- en: Non-existent object property access handling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In earlier versions of PHP, a `Notice` was issued when attempting to access
    non-existent properties. The only exception is when it's a custom class where
    you defined the magic `__get()` and/or `__set()` methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code example, we define a `Test` class with two properties,
    one being marked `static`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We then attempt to `echo` existing and non-existent properties, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Unsurprisingly, the output in PHP 7 returns a `Notice` when the non-existent
    property `echo` attempt is made, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The same code file, in PHP 8, now returns a `Warning`, as seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The `Test::$does_not_exist` error message does not mean we attempted static
    access. It simply means that a `$does_not_exist` property is associated with a
    `Test` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now add lines of code attempting to access a non-existent static property,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Interestingly, both PHP 7 and PHP 8 now issue a fatal error, as seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Anytime a block of code that previously issued a `Warning` now issues an `Error`
    is cause for concern. If possible, scan your code for static references to static
    class properties and make sure they are defined. Otherwise, after a PHP 8 upgrade,
    your code will fail.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now have a look at non-existent offset handling.
  prefs: []
  type: TYPE_NORMAL
- en: Non-existent offset handling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned in the previous section, in general, `Notices` have been promoted
    to `Warnings` where data is read, whereas `Warnings` have been promoted to `Errors`
    where data is written (and could conceivably result in *lost* data). The handling
    of non-existent offsets follows this logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, an array key is drawn from a string. In both cases,
    the offset doesn''t exist:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'In PHP 7, the result is a `Notice`, as seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'In PHP 8, the result is a `Warning`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'This example further illustrates the general rationale behind PHP 8 error handling
    enhancements: if your code *writes* data to a non-existent offset, what was previously
    a `Warning` is an `Error` in PHP 8\. The preceding output shows where an attempt
    made to *read* data from a non-existent offset in PHP 8, a `Warning` is now issued.
    The next `Notice` promotion to examine deals with misuse of resource IDs.'
  prefs: []
  type: TYPE_NORMAL
- en: Misusing resource IDs as array offsets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A **resource** is generated when creating a connection to a service external
    to your application code. A classic example of this data type would be a file
    handle. In the following code example, we open a file handle (thus creating `resource`)
    to a `gettysburg.txt` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we echo the `resource` directly in the last line. This reveals the
    resource ID number. If we now try to use the resource ID as an array offset, however,
    PHP 7 generates a `Notice`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'PHP 8, as expected, generates a `Warning`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Note that in PHP 8, many functions that formerly produced a `resource` now produce
    an object instead. This topic is covered in [*Chapter 7*](B16992_07_Final_JC_ePub.xhtml#_idTextAnchor162)*,
    Avoiding Traps When Using PHP 8 Extensions*.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: '**Best practice**: Do not use resource IDs as array offsets!'
  prefs: []
  type: TYPE_NORMAL
- en: We now turn our attention to string-related `Notices` promoted to `Warnings`
    in the case of ambiguous string offsets.
  prefs: []
  type: TYPE_NORMAL
- en: Ambiguous string offset cast
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Turning our attention to string handling, we once again revisit the idea of
    identifying a single character in a string using array syntax. An **ambiguous
    string offset cast** might occur if PHP has to perform an internal type cast in
    order to evaluate a string offset, but where in that type-cast is not clear.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this very simple example, we define a string that contains all the letters
    of the alphabet. We then define an array of keys with these values: `NULL`; a
    Boolean, `TRUE`; and a float, `22/7` (the approximate value of *Pi*). We then
    loop through the keys and attempt to use the key as a string offset, as illustrated
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'As you might have anticipated, the output running in PHP 7 produces the output
    `A`, `B`, and `D`, along with a series of `Notices`, shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'PHP 8 consistently produces the same results, but here, a `Warning` has taken
    the place of the `Notice`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Let's now have a look at non-existent offset handling.
  prefs: []
  type: TYPE_NORMAL
- en: Uninitialized or non-existent string offsets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This type of error is designed to trap access to strings using offsets, where
    the offset is out of bounds. Here''s a very simple code example that illustrates
    this situation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this code in PHP 7 results in a `Notice`. Here''s the output from PHP
    7:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Predictably, the output from PHP 8 produces a `Warning`, as seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: All of the examples in this section confirm the general trend in PHP 8 toward
    enforcing best coding practices.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information on promoted `Notices` and `Warnings`, have a look at this
    article: [https://wiki.php.net/rfc/engine_warnings](https://wiki.php.net/rfc/engine_warnings).'
  prefs: []
  type: TYPE_NORMAL
- en: Now, we turn our attention to the (infamous) `@` warning suppressor.
  prefs: []
  type: TYPE_NORMAL
- en: Handling the @ error control operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For years and years, many PHP developers have used the `@` **error control operator**
    to mask errors. This was especially true when using unreliable PHP libraries with
    badly written code. Unfortunately, the net effect of this usage only serves to
    propagate bad code!
  prefs: []
  type: TYPE_NORMAL
- en: 'Many PHP developers are exercising *wishful thinking*, believing that when
    they use the `@` operator to prevent errors from being displayed, this makes it
    *seem* as if the problem has magically gone away! Trust me when I say this: *it
    hasn''t!* In this section, we first examine traditional use of the `@` operator,
    after which we examine `@` operator changes in PHP 8.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information on traditional `@` operator syntax and usage, have a look
    at this documentation reference page: [https://www.php.net/manual/en/language.operators.errorcontrol.php](https://www.php.net/manual/en/language.operators.errorcontrol.php).'
  prefs: []
  type: TYPE_NORMAL
- en: '@ operator usage'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before presenting a code example, once again it's extremely important to emphasize
    that we are **not** promoting the usage of this mechanism! On the contrary—you
    should avoid this usage in every case. If an error message appears, the best solution
    is to *fix the error*, not to silence it!
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code example, two functions are defined. The `bad()` function
    deliberately triggers an error. The `worse()` function includes a file in which
    there is a parse error. Note that when the functions are called, the `@` symbol
    precedes the function name, causing the error output to be suppressed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'In PHP 7, there''s simply no output at all, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'What''s interesting to note is that the program is actually not allowed to
    continue in PHP 7: we never saw the `Last Line` output. This is because, although
    masked, a fatal error was nonetheless generated, causing the program to fail.
    In PHP 8, however, the fatal error is not masked, as seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Let's now have a look at another difference in PHP 8 regarding the `@` operator.
  prefs: []
  type: TYPE_NORMAL
- en: '@ operator and error_reporting()'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `error_reporting()` function is normally used to override the `error_reporting`
    directive set in the `php.ini` file. Another use of this function, however, is
    to return the latest error code. However, an odd exception was present in versions
    of PHP prior to PHP 8, in that `error_reporting()` returned a value of `0` if
    the `@` operator was used.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code example, we define an error handler that reports on the
    received error number and string when it''s invoked. In addition, we also display
    the value returned by `error_reporting()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'As before, we define a `bad()` function that deliberately triggers an error,
    and then call the function using the `@` operator, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'In PHP 7, you''ll note that `error_reporting()` returns `0`, thus causing `IF
    statement works!` to appear in the output, as illustrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Running in PHP 8, on the other hand, `error_reporting()` returns the value
    of the last error—in this case, `4437`. Also, of course, the `if()` expression
    fails, causing no additional output. Here is the result of the same code running
    in PHP 8:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: This concludes consideration of the differences in `@` operator usage in PHP
    8.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: '**Best practice**: Do not use the `@` error control operator! The intent of
    the `@` operator is to suppress the display of an error message, but you need
    to consider why this error message is appearing in the first place. By using the
    `@` operator, you are only avoiding providing a solution to a problem!'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you received an overview of major changes in error handling
    in PHP 8\. You were also given examples of situations where error conditions might
    arise, and now have an idea of how to properly manage errors in PHP 8\. You now
    have a solid path toward refactoring code that under PHP 8 now produces errors.
    If your code could potentially lead to any of the conditions described where former
    `Warnings` are now `Errors`, you risk having your code break.
  prefs: []
  type: TYPE_NORMAL
- en: In a like manner, although the second set of error conditions described only
    produced `Notices` in the past, these same conditions now cause a `Warning`. The
    new set of `Warnings` gives you a chance to adjust faulty code and prevent having
    your application devolve into a seriously unstable condition.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you learned how use of the `@` operator is strongly discouraged. In
    PHP 8, this syntax will no longer mask fatal errors. In the next chapter, you
    will learn how to create C-language structures and make direct calls to C-language
    functions in PHP 8.
  prefs: []
  type: TYPE_NORMAL
