- en: Reactive Programming Model – Overview and History
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The X Windows system, Microsoft Windows, and IBM OS/2 Presentation Manager
    made GUI programming popular on the PC platform. This was a major shift from the
    character mode user interface and batch process style programming models that
    existed before them. Responding to events became a major concern for software
    developers worldwide and platform vendors resorted to the creation of low-level
    C-based APIs that relied on function pointers and callbacks to enable programmers
    to handle the events. The programming models were mostly based on the co-operative
    multithreaded model, and with the advent of better microprocessors, most platforms
    began to support pre-emptive multithreading. Handling events (and other asynchronous
    tasks) became more complex and responding to events in the traditional way became
    less scalable. Even though excellent C++-based GUI toolkits made their appearance,
    event handling was done mostly using message IDs, function pointer based dispatches,
    and other low-level techniques. A prominent compiler vendor even tried adding
    language extensions to the C++ language to enable better Windows programming.
    Handling events, asynchrony, and associated issues require a fresh look at the
    problem. Luckily, the Modern C++ standard has support for Functional Programming,
    language-level concurrency (with a memory model), and better memory management
    techniques to enable programmers to work with asynchronous data streams (by treating
    events as streams). This is achieved using a programming model called reactive
    programming. To put things in perspective, this chapter will outline the following
    topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Event-driven programming model and how it has been implemented in various platforms.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is reactive programming?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different models of reactive programming.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some simple programs to make conceptual understanding better.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The philosophy of our book.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Event-driven programming model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Event-driven programming is a programming model where flow control is determined
    by events. Examples of events are mouse clicks, key presses, gestures, sensor
    data, messages from other programs, and so on. An event-driven application has
    the mechanism to detect events on a near real-time basis, and respond or react
    to them by invoking the appropriate event handling procedure. Since the bulk of
    the earlier event processing programs were written using C/C++, they resorted
    to low-level techniques such as callbacks (using function pointers) to write those
    event handlers. Later systems such as Visual Basic, Delphi, and other rapid application
    development tools did add native support for event-driven programming. To make
    matters more clear, we will take a tour of the event handling mechanism of the
    various platforms. This will help readers appreciate the issues that reactive
    programming models are solving (from a GUI programming context).
  prefs: []
  type: TYPE_NORMAL
- en: Reactive programming treats data as streams and events in windowing systems
    can be treated as streams to be processed in a uniform manner. The Reactive programming
    model provides support for gathering events from different sources as streams,
    filtering streams, the transformation of streams, performing actions on streams,
    and so on. The programming model handles asynchrony, scheduling details as part
    of the framework. This chapter is mostly based on the key data structures of the
    Reactive programming model and how we can implement basic Reactive programs. In
    an industrial-strength reactive program, the code written will be asynchronous
    and the examples from this chapter are synchronous. We give the necessary background
    information and language constructs in the following chapters before out of order
    execution and schedules are discussed. These implementations are here for elucidation
    and can be treated as learning examples.
  prefs: []
  type: TYPE_NORMAL
- en: Event-driven programming on X Windows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The X Windows programming model is a cross-platform API, is mostly supported
    on POSIX systems, and has even been ported to Microsoft Windows. In fact, X is
    a network windowing protocol, which required a Window manager to manage the Windows
    stack. The screen contents are managed by the X server and the client library
    will pull the contents and display them on the local machine. In desktop environments,
    the server runs locally on the same machine. The following program will help the
    reader understand the gist of the XLib programming model and how events are handled
    in the platform:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code snippet includes the proper header files that a programmer
    is supposed to include to get the function prototypes provided by the XLib C library.
    There are some data structures that a programmer should be aware of while writing
    XLib programs from scratch. Nowadays, people use libraries such as Qt, WxWidgets,
    Gtk+, Fox toolkit, and so on to write commercial-quality X Programs.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code snippet initializes the server and creates a window to certain
    specifications. Traditionally, most X Windows programs run under a window manager
    that manages the cascading windows. We selected the messages that are of interest
    to us by invoking the `XSelectInput` API call before displaying the window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, the program goes to an infinite loop while polling for any events, and
    the appropriate Xlib API will be used to draw a string on the Window. In Windowing
    parlance, it is called a **message** loop. The retrieval of events will be done
    by the `XNextEvent` API call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Once we are out of the infinite message loop, the connection to the server will
    be closed.
  prefs: []
  type: TYPE_NORMAL
- en: Event-driven programming on Microsoft Windows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Microsoft Corporation created a GUI programming model, which can be considered
    as the most successful windowing system in the world. The third edition of the
    Windows software was a runaway success (in 1990) and Microsoft followed this with
    the Windows NT and Windows 95/98/ME series. Let us look at the event-driven programming
    model of Microsoft Windows (consult Microsoft documentation for a detailed look
    at how this programming model works). The following program will help us understand
    the gist of what is involved in writing Windows Programming using C/C++:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code snippet initializes a structure by the name of `WNDCLASS`
    (or `WNDCLASSEX` for modern systems) with a necessary template for a Window. The
    most important field in the structure is `lpfnWndProc`, which is the address of
    the function that responds to the event inside an instance of this Window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We will invoke the `CreateWindow` (or `CreateWindowEx` on modern systems) API
    call to create a window based on the class name provided in the `WNDCLASS.lpszClassname`
    parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code snippet gets into an infinite loop where messages will be
    retrieved from the message queue until we get a `WM_QUIT` message. The `WM_QUIT`
    message takes us out of the infinite loop. The Messages will sometimes be translated
    before calling the `DispatchMessage` API call. `DispatchMessage` invokes the Window
    callback procedure (`lpfnWndProc`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code snippet is a minimalist `callback` function. You can consult
    Microsoft documentation to learn about Windows API programming and how events
    are handled in those programs
  prefs: []
  type: TYPE_NORMAL
- en: Event-driven programming under Qt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Qt Framework is an industrial-strength, cross-platform, and multi-platform
    GUI toolkit that runs on Windows, GNU Linux, macOS X, and other Mac systems. The
    toolkit has been compiled into embedded systems and mobile devices. The C++ Programming
    model has leveraged something called **Meta Object Compiler** (**MOC**), which
    will peruse the source code for directives (a bunch of macros and language extensions
    embedded in the source code) and generate appropriate additional source code to
    generate event handlers. So, before the C++ compiler gets the source code, the
    MOC pass has to run to generate legal ANSI C++ by removing those extra linguistic
    constructs specific to the Qt system. Consult the Qt documentation to learn more
    about this. The following simple Qt program will demonstrate the key aspects of
    Qt programming and its event processing system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The macro `Q_OBJECT` is a directive to the MOC to generate an `Event Dispatch`
    table. When we connect the event source to an event sink, an entry will be given
    to the `Event Dispatch` table. The generated code will be compiled along with
    the C++ code to produce an executable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The language extension *public slots* will be stripped away by the MOC (after
    doing the job of source code generation) to a form compatible with the ANSI C/C++
    compiler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code snippet initializes the Qt application object and displays
    the main window. For all practical purposes, Qt is the most prominent application
    development framework for the C++ language and it also has got a good binding
    to the Python Programming language.
  prefs: []
  type: TYPE_NORMAL
- en: Event-driven programming under MFC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Microsoft Foundation class library is still a popular library with which
    to write Microsoft Windows-based desktop programs. It does have some support for
    web programming if we mix **ActiveX Template Library** (**ATL**) along with it.
    Being a C++ library, MFC uses a mechanism called Message Mapping to handle events.
    A sample event handling table given as macros is part of every MFC program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The preceding message map will respond to `OnCreate`, `OnPaint`, and `Ontimer`
    standard Windows API messages. Deep down these message maps are arrays on to which
    we will use `message id` as an index for dispatching the events. On closer examination,
    it is not much different from the standard Windows API messaging model.
  prefs: []
  type: TYPE_NORMAL
- en: The code listing is not given here because we have globally a GUI implementation
    of one of the key interfaces for the Reactive Programming model using MFC. The
    implementation is based on the MFC library and the reader can go through the annotated
    listing to gain an understanding of non-trivial event processing in MFC.
  prefs: []
  type: TYPE_NORMAL
- en: Other event-driven programming models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Distributed object processing frameworks such as COM+ and CORBA do have their
    own event processing framework. The COM+ event model is based on the notion of
    Connection Points (modeled by `IConnectionPointContainer`/`IConnectionPoint` interfaces)
    and CORBA does have its own event service model. The CORBA standard provides both
    pull-based and push-based event notifications. COM+ and CORBA are beyond the scope
    of this book and the reader is expected to consult the respective documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Limitations of classical event processing models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The whole purpose of making a tour of the event processing supported by various
    platforms was to put things into the proper perspective. The event response logic
    in these platforms is mostly coupled with the platform where the code is written.
    With the advent of multi-core programming, writing low-level multi-threaded code
    is difficult and declarative task-based programming models are available with
    the C++ programming language. But the event sources are mostly outside the C++
    standard! The C++ language does not have a standard GUI programming library, an
    interface standard to access external devices, and so on. What is the way out?
    Luckily, events and data from external sources can be aggregated into streams
    (or sequences) and by using functional programming constructs such as Lambda functions
    can be processed very efficiently. The added bonus is that if we resort to some
    kind of restrictions regarding the mutability of variables and streams, concurrency,
    and parallelism are built into the stream processing model.
  prefs: []
  type: TYPE_NORMAL
- en: Reactive programming model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Simply put, reactive programming is nothing but programming with asynchronous
    data streams. By applying various operations on stream, we can achieve different
    computational goals. The primary task in a reactive program is to convert data
    into streams, regardless of what the source of the data is. While writing modern
    graphical user interface applications, we process mouse move-and-click events.
    Currently, most systems get a callback and process these events as and when they
    happen. Most of the time, the handler does a series of filtering operations before
    it invokes the action methods associated with the event calls. In this particular
    context, reactive programming helps us in aggregating the mouse move-and-click
    events into a collection and sets a filter on them before notifying the handler
    logic. In this way, the application/handler logic does not get executed unnecessarily.
  prefs: []
  type: TYPE_NORMAL
- en: The stream-processing model is well known, and it is very easy to encode by
    application developers. Pretty much anything can be converted into a stream. Such
    candidates include messages, logs, properties, Twitter feeds, blog posts, RSS
    feeds, and so on. Functional programming techniques are really good at processing
    streams. A language such as Modern C++, with excellent support for Object/Functional
    programming, is a natural choice for writing reactive programs. The basic idea
    behind reactive programming is that there are certain datatypes that represent
    a value over time. These datatypes (or rather data sequences) are represented
    as Observable sequences in this programming paradigm. Computations that involve
    these changing (time-dependent) values will, in turn, themselves have values that
    change over time, and will need to asynchronously receive notifications (as and
    when the dependent data changes).
  prefs: []
  type: TYPE_NORMAL
- en: Functional reactive programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Almost all modern programming languages support functional programming constructs.
    Functional programming constructs such as Transform, Apply, Filter, Fold, and
    so on are good for processing streams. Programming asynchronous data streams using
    functional programming constructs are generally called functional reactive programming
    (for all practical purposes). The definition given here is an operational one.
    Consult the work done by Conal Elliott and Paul Hudak as part of the Haskell community
    to understand the strict definition. Mixing Reactive Programming with FP is gaining
    traction among developers these days. The Emergence of libraries such as Rx.Net, RxJava,
    RxJs, and RxCpp and so on is a testimony to this.
  prefs: []
  type: TYPE_NORMAL
- en: Even though reactive programming is the core subject of this book, in this chapter
    we will be sticking to an OOP approach. This is necessitated because of the fact
    that we need to introduce some standard interfaces (emulated in C++ using virtual
    functions) necessary for doing Reactive programming. Later on, after learning
    about FP constructs supported by C++ , readers can do some mental model mapping
    from OOP to FP constructs. We will also keep away from concurrency stuff to focus
    on software interfaces in this chapter. [Chapters 2](e1c95513-a3a7-40f2-ac25-9f95cbd9a2e6.xhtml),
    *A Tour of the Modern C++ and Its Key Idioms*, [Chapter 3](16bbadb9-c545-44b1-8edb-82ab82a83394.xhtml),
    *Language-Level Concurrency and Parallelism in C++*, and [Chapter 4](80c4a483-89c7-45fc-a83f-736a1817126e.xhtml),
    *Asynchronous and Lock-Free Programming in C++*, will give the necessary background
    to understand reactive programming using FP constructs.
  prefs: []
  type: TYPE_NORMAL
- en: The key interfaces of a reactive program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To help you understand what is really happening inside a reactive program,
    we will write some toy programs to put things in proper context. From a software
    design point of view, if you keep concurrency/parallelism aside to focus on software
    interfaces, a reactive Program should have:'
  prefs: []
  type: TYPE_NORMAL
- en: An event source that implements `IObservable<T>`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An event sink that implements `IObserver<T>`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A mechanism to add subscribers to an event source
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When data appears at the source, subscribers will be notified
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this particular chapter, we have written code using classic C++ constructs.
    This is because we have not yet introduced Modern C++ constructs. We have also
    used raw pointers, something which we can mostly avoid while writing Modern C++
    code. The code in this chapter is written to conform to the ReactiveX documentation
    in general. In C++, we do not use inheritance-based techniques like we do in Java
    or C#.
  prefs: []
  type: TYPE_NORMAL
- en: 'To kickstart, let us define Observer, Observable, and a `CustomException` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The `CustomException` class is just a placeholder to make the interface complete.
    Since we have decided that we will only use classic C++ in this chapter, we are
    not deviating from the `std::exception` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `Enumerable` interface is used by the data source from which we can enumerate
    data and `IEnuerator<T>` will be used for iteration by the client.
  prefs: []
  type: TYPE_NORMAL
- en: 'The purpose of defining interfaces for Iterator (`IEnuerable<T>`/`IEnumerator<T>`)
    is to make the reader understand that they are very closely related to the `Observer<T>`/`Observable<T>`
    pattern. We will define `Observer<T>`/`Observable<T>` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '`IObserver<T>` is the interface that the data sink will use to receive notifications
    from the data source. The data source will implement the `IObservable<T>` interface.'
  prefs: []
  type: TYPE_NORMAL
- en: We have defined the `IObserver<T>` interface and it has got three methods. They
    are `OnNext` (when the item is notified to the Observer), `OnCompleted` (when
    there is no more data), and `OnError` (when an exception is encountered). `Observable<T>`
    is implemented by the event source and event sinks can insert objects that implement `IObserver<T>`
    to receive notifications.
  prefs: []
  type: TYPE_NORMAL
- en: Pull-versus push-based reactive programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reactive programs can be classified as **push-based** and **pull-based**. The
    pull-based system waits for a demand to push the data streams to the requestor
    (or subscriber in our case). This is the classic case where the data source is
    actively polled for more information. This employs the iterator pattern, and `IEnumerable
    <T>`/`IEnumerator <T>` interfaces are specifically designed for such scenarios
    that are synchronous in nature (the application can block while pulling data).
    On the other hand, a push-based system aggregates events and pushes through a
    signal network to achieve the computation. In this case, unlike the pull-based
    system, data and related updates are handed to the subscriber from the source
    (Observable sequences in this case). This asynchronous nature is achieved by not
    blocking the subscriber, but rather making it react to the changes. As you can
    see, employing this push pattern is more beneficial in rich UI environments where
    you wouldn't want to block the main UI thread while waiting for some events. This
    becomes ideal, thus making reactive programs responsive.
  prefs: []
  type: TYPE_NORMAL
- en: The IEnumerable/IObservable duality
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you take a closer look, there is only a subtle difference between these
    two patterns. `IEnumerable<T>` can be considered the pull-based equivalent of
    the push-based `IObservable<T>`. In fact, they are duals. When two entities exchange
    information, one entity''s pull corresponds to another entity pushing the information.
    This duality is illustrated in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a4538551-7bd5-4fcc-8a04-e2b682f92a84.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s understand this duality by looking at this sample code, a number sequence
    generator:'
  prefs: []
  type: TYPE_NORMAL
- en: We have striven to use classic C++ constructs to write programs for this particular
    chapter as there are chapters on Modern C++ language features, language level
    concurrency, lock-free programming, and related topics for implementing Reactive
    constructs in Modern C++.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding class takes an array of integers as a parameter and we can enumerate
    over the elements as we have implemented the `IEnumerable<T>` interface. The `Enumeration`
    logic is implemented by the nested class, which implements the `IEnumerator<T>`
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The main program instantiates an implementation of the `ConcreteEnuerable` class
    and walks through each element.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will write an even number sequence generator to demonstrate how these data
    types work together in converting a pull-based program to a push program. The
    robustness aspect is given low priority to keep the listing terse:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding program takes an array of integers, filters out of the odd numbers,
    and notifies `Observer<T>` if an even integer is encountered. In this particular
    case, the data source is pushing data to `observer`. The implementation of `Observer<T>`
    is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `SimpleObserver` class implements the `IObserver<T>` interface and it has
    the capability to receive notifications and react to them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: From the preceding example, you see how one can naturally subscribe for even
    numbers from an Observable sequence of natural numbers. The system will automatically
    `push` (`publish`) the values to the `observer` (`subscriber`) when an even number
    is detected. The code gives explicit implementations for key interfaces so that
    one can understand, or speculate what really happens under the hood.
  prefs: []
  type: TYPE_NORMAL
- en: Converting events to IObservable<T>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have now understood how one can convert an `IEnumerable<T>`-based pull program
    to an `IObservable<T>`/`IObserver<T>`-based push program. In real life, the event
    source is not as simple as we found in the number stream example given earlier.
    Let us see how we can convert a `MouseMove` event into a stream with a small MFC
    program:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have chosen MFC for this particular implementation because we have a chapter
    dedicated to Qt-based reactive programming. In that chapter, we will be implementing
    Reactive programs in idiomatic asynchronous push-based streams. In this MFC program,
    we simply do a filtering operation to see whether the mouse is moving in a bounding
    rectangle and, if so, notify the `observer`. We are using synchronous dispatch
    here. This example is synchronous too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding part of the code defines a `Frame` class that derives from the
    `MFC` library the `CFrameWnd` class and also implements the `IObservable<T>` interface
    to force the programmer to implement the `Subscribe` method. A vector of `IObserver<T>`
    will store the list of `observers` or `Subscribers`. For this example, we will
    have only one `observer`. There is no restriction on the number of `observer` in
    the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Subscribe` method just stores the reference to the `observer` onto a vector
    and returns `true`: when the mouse is moved, we get notification from the `MFC`
    library and if it is in a rectangular area, `observer` will be notified (the notification
    code is as follows):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The `FireEvent` method walks through the `observer`''s and calls the `OnNext`
    method of the `observer`. It also calls the `OnCompleted` method of each instance
    of Observer''s: The Rx dispatching mechanism follows certain rules while calling
    the `observer` methods. If `OnComplete` method is called, no more `OnNext` will
    be called on the same `observer`. Similarly, if `OnError` is called, no further
    messages will be dispatched to the `observer`. If we need to follow the conventions
    stipulated by the Rx model here, the listing will get complicated. The purpose
    of the code given here is to show how the Rx programming model works in a schematic
    manner.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The `SetCurrentPoint` method is invoked by `observer` to set the current point
    where the text has to be drawn. The `Invalidate` method is invoked to trigger
    a `WM_PAINT` message and the `MFC` subsystem will route it to `OnPaint` (as it
    is wired in the `Message` maps):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The `OnPaint` method is invoked by the `MFC` framework when the `Invalidate`
    call is made. The method draws the `literal` string, `Hello Reactive C++`, on
    the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Transform` method computes the bound of the client area of the `Frame`
    and converts `Cartesian` coordinates to devise coordinates. This computation can
    be better done through world coordinate transformations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The `OnMouseMove` method checks whether the mouse position is within a rectangle
    centered inside the screen and fires the notification to the `observer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding class `WindowHandler` implements the `IObserver<T>` interface
    and handles the event notified by `CMouseFrame`, which implements the `IObservable<CPoint>`
    interface. In this canned example, we set the current point by invoking the `SetCurrentPoint`
    method to draw the string at the mouse position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The philosophy of our book
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The purpose of this chapter is to introduce readers to the key interfaces of
    the reactive programming mode they are—`IObservable<T>` and `IObserver<T>.` They
    are in fact the duals of the `IEnumerable<T>` and `IEnumerator<T>` interface.
    We learned how to model those interfaces in classic C++ (well, mostly) and had
    toy implementations of all of them. Finally, we implemented a GUI program that
    captures mouse movements and notifies a list of Observers. These toy implementations
    are to get our feet wet with the ideas and ideals of the Reactive programming
    model. Our implementations can be considered as implementing of OOP-based reactive
    programming.
  prefs: []
  type: TYPE_NORMAL
- en: 'To be proficient in C++ reactive programming, a programmer has to be comfortable
    with the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Advanced linguistic constructs provided by Modern C++
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functional programming constructs provided by Modern C++
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Asynchronous programming (RxCpp handles it for you!) model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Event stream processing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Knowledge of industrial-strength libraries such as RxCpp
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applications of RxCpp in GUI and web programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advanced reactive programming constructs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling errors and exceptions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter was mostly about key idioms and why we require a robust model for
    handling asynchronous data. The next three chapters will cover language features
    of Modern C++, handling concurrency/parallelism with C++ standard constructs,
    and lock-free programming (made possible by memory model guarantees). The preceding
    topics will give the user a firm foundation from which to master functional reactive
    programming.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](c73fa9f3-6f2b-47f6-946d-155446d3225f.xhtml), *Introduction to
    Observables*, we will once again return to the topic of Observables and implement
    interfaces in a functional manner to reiterate some of the concepts. In [Chapter
    6](9f5e24eb-c2fd-4cfe-b812-c961e350fd9a.xhtml), *Introduction to Event Stream
    Programming Using C++*, we will move towards the advanced event stream processing
    topics with the help of two industrial-strength libraries that use the **Domain
    Specific Embedded Language** (**DSEL**) approach towards event stream processing.
  prefs: []
  type: TYPE_NORMAL
- en: By now, the stage will be set for the user to be exposed to the industrial-strength
    RxCpp library and its nuances to write professional-quality Modern C++ programs.
    In Chapter 7, *Introduction to Data Flow Computation and the RxCpp Library* and
    Chapter 8, *RxCpp – the Key Elements*, we will cover this wonderful library. The
    following chapters will cover Reactive GUI programming using the Qt library and
    advanced operators in RxCpp.
  prefs: []
  type: TYPE_NORMAL
- en: The last three chapters cover advanced topics of Reactive design patterns, micro-services
    in C++, and handling errors/exceptions. By the end of the book, the reader who
    started with classic C++ will have covered a lot of ground, not only in writing
    Reactive programs but in the C++ language itself. Because of the nature of the
    topic, we will cover most of the features of C++ 17 (at the time of writing).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about some key data structures of the Rx programming
    model. We implemented toy versions of them to familiarize us with the conceptual
    nuances underpinning them. We started with how GUI events were handled by Windows
    API, XLib API, MFC, and Qt. We briefly touched upon how events are handled in
    COM+/CORBA as well. Then, a quick overview of Reactive programming was given.
    After introducing some interfaces, we implemented them from scratch. Finally,
    a GUI version of these interfaces on top of MFC was implemented for the sake of
    completeness. We also dealt with the key philosophical aspects of the book.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will make a whirlwind tour of the key features of Modern
    C++ (C++ Versions 11/14/17) by emphasizing on move semantics, Lambdas, type inference,
    range-based loops, pipe-able operators, smart pointers, and so on. This is essential
    for writing even basic code for Reactive Programming.
  prefs: []
  type: TYPE_NORMAL
