- en: Chapter 2. Preparing the Raspberry Pi
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Raspberry Pi should be considered an underpowered platform for security
    assessments. This is because it has been designed as a low-cost, portable computer
    primarily targeting educationalists and hobbyists. This open platform may be limited
    in computing power, but it does provide many powerful use cases that security
    professionals can leverage for penetration testing and other service engagements.
    The focus of this chapter will be on how to prepare a Raspberry Pi running Kali
    Linux (or other platforms) for a penetration test.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Raspberry Pi use cases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Command and Control server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preparing for a penetration test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overclocking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up wireless cards
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up a 3G USB modem with Kali Linux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the SSH service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SSH default keys and management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reverse shell through SSH
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stunnel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wrapping up with an example
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Raspberry Pi use cases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Raspberry Pi is a common requirement for security professionals to gather information
    from remote sites in large distributed organizations. Many people leverage commercial
    tools that specialize in vulnerability assessments for this situation; however,
    you may not have access to such tools due to a limited budget or vendor partnership
    requirements. An example of this situation is when the authors of this book had
    to take part in a security assessment that included multiple locations all over
    the world. For this project, it was not feasible to travel to every location to
    deliver local penetration testing services. To overcome this, we sent Raspberry
    Pi devices configured with Kali Linux to each location and remotely assessed the
    network for vulnerabilities at a very affordable price. We will cover this engagement
    example in more detail at the end of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Another valuable use case for a Raspberry Pi is when a security professional
    wants to leave a device on-site for a long period of time. In the previous example,
    it was not cost-effective to ship and leave a high-end system at each location.
    The Raspberry Pi also has a stealth value using its small form factor through
    a portable device with a modest power requirement over a larger, more powerful
    system. It is less likely people will identify or tamper with a smaller, unknown
    black box such as a Raspberry Pi hidden in a printer power cable versus a random
    laptop placed in an inconspicuous area. For **black-box** testing, the opportunity
    to conceal a Raspberry Pi in common office supplies such as clocks, lamps, and
    printers is extremely useful. In this chapter, we will discuss how to make this
    concept more effective by explaining how you can use one or many Raspberry Pi
    systems to exploit remote locations from a centralized attack standpoint.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following image shows a Raspberry Pi placed in a cat clock:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Raspberry Pi use cases](img/6435OT_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The Command and Control server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have stated in other chapters, the Raspberry Pi is not a powerful machine.
    To overcome this weakness, it is best practice to capture data in a controlled
    manner or leverage offline computing when using Kali Linux on a Raspberry Pi.
    We found that not doing so would either overwhelm the processors when using most
    of the attack tools or quickly consume the limited local storage space when viewing
    captured data. We will cover filtering captured data in [Chapter 3](ch03.html
    "Chapter 3. Penetration Testing"), *Penetration Testing*, under the *Tuning your
    network capture* section.
  prefs: []
  type: TYPE_NORMAL
- en: When planning to remotely access multiple Raspberry Pi systems, we recommend
    setting up a central **Command and Control** (**C&C**) server rather than accessing
    each box individually. The C&C server should be a more powerful system such as
    a traditional server so it can focus on CPU intensive tasks such as breaking passwords
    through brute force. More importantly, tasks can also include using the C&C server
    to perform the actual analysis and exploitation rather than locally on the Raspberry
    Pi. An example is having a **Phishing** attack send user traffic hitting the Raspberry
    Pi to the C&C server to be analyzed for vulnerabilities and exploitation.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing for a penetration test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Kali Linux ARM image we covered in [Chapter 1](ch01.html "Chapter 1. Raspberry
    Pi and Kali Linux Basics"), *Raspberry Pi and Kali Linux Basics*, has already
    been optimized for a Raspberry Pi. We found however that it is recommended to
    perform a few additional steps to ensure you are using Kali Linux in the most
    stable mode to avoid crashing the Raspberry Pi. The steps are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The first recommended step is to perform the OS updates as described in detail
    in [Chapter 1](ch01.html "Chapter 1. Raspberry Pi and Kali Linux Basics"), *Raspberry
    Pi and Kali Linux Basics*. We won't repeat the steps here, so if you have not
    updated your OS, please go back to [Chapter 1](ch01.html "Chapter 1. Raspberry
    Pi and Kali Linux Basics"), *Raspberry Pi and Kali Linux Basics*, and follow the
    instructions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next step you should perform is to properly identify your Raspberry Pi.
    The Kali Linux image ships with a generic hostname. To change the hostname, use
    the `vi` editor (although feel free to use any editor of your choice; even if
    you are a fan of nano, we won't judge you much) with the `vi /etc/hostname` command
    as shown in the following screenshot:![Preparing for a penetration test](img/6435OT_02_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The only thing in this file should be your hostname. You can see from my example
    that I am changing my hostname from `Kali` to `RaspberryPi` as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Preparing for a penetration test](img/6435OT_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You will also want to edit the `/etc/hosts` file to modify the hostnames. This
    can also be done using the `vi` editor. You want to confirm whether your hostname
    is set correctly in your `hosts` file. The following screenshot shows how I changed
    my default hostname from `Kali` to `RaspberryPi`.![Preparing for a penetration
    test](img/6435OT_02_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure you save the files after making edits. Once saved, reboot the system.
    You will notice the hostname has changed and will be reflected in the new command
    prompt.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using common names such as HP Jetdirect as a means to blend into the network
    could be beneficial in a black-box testing environment.
  prefs: []
  type: TYPE_NORMAL
- en: Overclocking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overclocking the Raspberry Pi can improve the performance. The risk of doing
    this can also greatly reduce the life of the hardware. Overclocking may require
    more power from the Raspberry Pi, so if you are powering it from a weak power
    source, overclocking could cause issues. We have had some problems resulting in
    what appears to be corruption in microSD cards and operating systems when overclocking
    the Raspberry Pi.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Only overclock the Raspberry Pi if you can accept the risk that you may permanently
    damage your system.
  prefs: []
  type: TYPE_NORMAL
- en: 'To overclock the Raspberry Pi, you can use the raspi-config application for
    advanced hardware manipulation. Unfortunately, this application does not come
    with the Kali Linux image and requires some configuration. Don''t worry; we have
    made the following steps pretty easy for you to follow. They are:'
  prefs: []
  type: TYPE_NORMAL
- en: 'From your Raspberry Pi command line, type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can also use the official links to download the necessary files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://rageweb.info/2013/06/16/updated-raspi-config-in-kali/](http://rageweb.info/2013/06/16/updated-raspi-config-in-kali/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://rageweb.info/2013/11/07/bootconfig-txt-in-kali/](http://rageweb.info/2013/11/07/bootconfig-txt-in-kali/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following screenshot shows the launch of the preceding command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Overclocking](img/6435OT_02_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You will need to unzip the files using the `unzip` command as shown in the following
    screenshot:![Overclocking](img/6435OT_02_06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, navigate to the directory you just unzipped and you will see a few files
    in it as shown in the following screenshot:![Overclocking](img/6435OT_02_07.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Type in the following commands in the terminal window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now you will be able to launch the raspi-config utility. This utility will let
    you control some very specific hardware features on the Raspberry Pi. You should
    only change things if you absolutely know what you are doing, as stated in the
    earlier warnings.
  prefs: []
  type: TYPE_NORMAL
- en: We personally found no issue running our Raspberry Pi Model B+ at 1000 MHz.
    Your mileage will vary, and don't be surprised if this will end up causing some
    permanent damage to your Raspberry Pi. It also voids every warranty you might
    have.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the **Raspi-config** menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Overclocking](img/6435OT_02_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Our specific configuration is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The **arm_freq** is `1000`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **gpu_freq** is `400`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **sdram_freq** is `500`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **over_voltage** is `6`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **gpu_mem** is `128`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You should issue the `dmesg` command from the command line after changing your
    hardware settings to check whether there are any error logs. We have seen most
    configurations change the GPU frequency rate to 500 MHz; however, we continuously
    got errors on our system from the `dmesg` output after a few days. We found we
    had no issue when we dialed it back to 400 MHz.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up wireless cards
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you purchase a Wi-Fi adapter for your Raspberry Pi, you want to make sure
    it not only works with the Raspberry Pi, but also works with Kali Linux. Luckily,
    almost every Wi-Fi adapter we used works with both the Raspberry Pi and Kali Linux.
    In this book, we are using the CanaKit Wi-Fi dongle, as shown in the following
    image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up wireless cards](img/6435OT_02_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: CanaKit makes an extremely popular Raspberry Pi kit that ships with this version
    of the Wi-Fi adapter. You can also purchase an adapter separately. If you need
    to purchase a separate card, make sure it is one that works with Debian Linux.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A good resource for compatible cards is [http://elinux.org/RPi_USB_Wi-Fi_Adapters](http://elinux.org/RPi_USB_Wi-Fi_Adapters).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you connect your Wi-Fi adapter, you should first verify that the system
    shows it is functioning properly. You can do this by issuing the `iwconfig` command
    in a terminal window as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up wireless cards](img/6435OT_02_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You should see a `wlan0` interface representing your new wireless interface.
    The next step is to enable the interface. We do this by issuing the `ifconfig
    wlan0` command followed by the `up` keyword as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up wireless cards](img/6435OT_02_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At this point, your wireless interface should be up and ready to scan the area
    for wireless networks. This will allow us to test the wireless card to make sure
    it works, as well as evaluate the wireless spectrum in the area. We will do this
    by issuing the `iwlist wlan0 scanning` command as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up wireless cards](img/6435OT_02_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is important to remember most wireless networks you will identify will be
    in the 2.4 GHz range. This is because most common adapters are 2.4 GHz 802.11
    b/g. You may need to change adapters depending upon your requirements.
  prefs: []
  type: TYPE_NORMAL
- en: The `iwlist wlan0 scanning` command will show the SSID and the MAC address associated
    with the access points found in the area. You can see in the following screenshot
    that we scanned a `Wireless Lab` network and it has a MAC address of `0E:18:1A:36:D6:22`.
    You can also see the Wi-Fi channel the AP is transmitting on, which is `Channel
    36`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up wireless cards](img/6435OT_02_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We have now set up wireless on our Raspberry Pi running Kali Linux.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a 3G USB modem with Kali Linux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can use 3G USB modem cards with Kali Linux and connect to your Raspberry
    Pi over cellular for stealthy remote access. Each card is manufactured a little
    differently, and therefore the setup may vary based on the type of 3G card and
    service provider. Our recommendation is using a **MiFi** (short for **Mobile Wi-Fi**)
    hotspot and connecting Kali Linux through a Wi-Fi adapter; however, if you want
    to use a 3G USB modem, make sure you verify it works with Debian.
  prefs: []
  type: TYPE_NORMAL
- en: In our next example, we use the Huawei 3G USB modem connect card. This is a
    3G GSM card that works with most frequencies around the globe.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the steps to set up this card:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open up a terminal window and type in the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Unzip the file issuing the `unzip` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make changes in the directory you just unzipped.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make the file an executable by typing in `chmod +x 3gusbm*`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the script by typing `./3gusbmodem –interactive`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The script takes a few minutes to run, so be patient. Please select the **Kernel**
    module when prompted.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will need to select your **Access Point Name** (**APN**) from your mobile
    provider. You may also need to know the username and password for the APN login
    for your mobile provider.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes a username and password is not needed. If this is the case, type in
    anything for the username and password. This should be done even if a username
    and password is not required by your mobile provider.
  prefs: []
  type: TYPE_NORMAL
- en: Select **OK** when the process is completed. After a minute, you should see
    that you have successfully connected to the 3G network.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the SSH service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Secure Shell** (**SSH**) gives you full access to the Kali Linux operating
    system on a Raspberry Pi from a remote location. It is the most common way to
    manage Linux systems using a command line. Since the Kali Linux GUI is not needed
    for most penetration testing exercises, we recommend that you use SSH or command-line
    utilities whenever possible. We found some installations of Kali Linux have SSH
    enabled while others may need you to install the OpenSSH server.
  prefs: []
  type: TYPE_NORMAL
- en: You should first verify whether the SSH service is installed. Type in the `service
    --status-all` command to check whether the SSH service is running. If you see
    **+** as shown in the following screenshot, you are good to go. If you see a **-**
    sign, then you will need to install the OpenSSH server.
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up the SSH service](img/6435OT_02_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To install the OpenSSH server, open a command-line terminal and type `apt-get
    install openssh-server` to install the SSH services. You will need to start the
    SSH services by issuing the `service ssh start` command as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up the SSH service](img/6435OT_02_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once you enable the SSH service, you should enable the SSH service to start
    running after a reboot. To do this, first remove the run level settings for SSH
    using the `update-rc.d -f ssh remove` command as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up the SSH service](img/6435OT_02_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, load SSH defaults by using the `update-rc.d -f ssh defaults` command
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up the SSH service](img/6435OT_02_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now you should have SSH permanently enabled on your Kali Linux system. You can
    reboot the system at any time without needing to reconfigure the system to run
    SSH.
  prefs: []
  type: TYPE_NORMAL
- en: SSH default keys and management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, you have a Raspberry Pi ready for remote management using SSH.
    This is good; however, the keys that are installed by default are extremely predictable
    with every other default installation for OpenSSH. Although this is optional,
    best practice is changing the default keys. After all, it would be embarrassing
    if your penetration testing machine got hacked.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the steps to create a new SSH key for your Kali Linux system:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Make sure you use a keyboard and console for the following steps. Do not attempt
    to perform the following steps over an existing SSH session.
  prefs: []
  type: TYPE_NORMAL
- en: 'Move the default SSH keys by typing the following into the terminal or command
    line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Generate a new key by using the following command and watching the prompts:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the launch of the preceding commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '![SSH default keys and management](img/6435OT_02_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The final step is restarting the SSH services on your Kali Linux system using
    the `service ssh restart` command.
  prefs: []
  type: TYPE_NORMAL
- en: Reverse shell through SSH
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already covered the advantages of using a Raspberry Pi at remote locations.
    The important thing to consider is how you should control the Raspberry Pi once
    you have placed the Raspberry Pi on the target's network. The most obvious and
    flexible way would be to SSH into Kali Linux.
  prefs: []
  type: TYPE_NORMAL
- en: Since Kali Linux is a fully featured Linux operating system, you can control
    the entire environment through SSH; however, your incoming SSH connections may
    be blocked by firewalls or other security solutions. Many organizations have security
    measures in place to block incoming connections with the goal of preventing backdoors
    into their network. In a **white-box** assessment, you may be explicitly able
    to open up a firewall to permit SSH to your Raspberry Pi as shown in the following
    image. The bad news is even if this is possible from a policy standpoint, it may
    be difficult to achieve when dealing with multiple sites under multiple administrative
    controls. Reverse SSH is a good alternative to manage a Raspberry Pi running Kali
    Linux.
  prefs: []
  type: TYPE_NORMAL
- en: In a reverse connection, the client connects and initiates the connection to
    the server instead of the server connecting to the client. In both cases, the
    server controls the client. This is the same technique as many backdoor programs.
    For our purposes, we will use this as a management utility.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Many intrusion detection and prevention solutions can detect SSH based on the
    network traffic looking different regardless of the port. For example, using port
    443 would still look different from common HTTPS traffic.
  prefs: []
  type: TYPE_NORMAL
- en: '![Reverse shell through SSH](img/6435OT_02_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We will use the `R` switch in the `ssh` command to create a reverse connection
    to the listener. A listener is the device listening to accept reverse SSH connections.
    In our case, the C&C server is the listener. The syntax for the commands used
    on the remote host (Raspberry Pi) is `ssh -R [bind_address:]port:host:hostport`.
  prefs: []
  type: TYPE_NORMAL
- en: The `R` switch defines the port that the remote side will connect over or how
    it will initiate the connection. In other words, we need to pick a port that our
    remote Raspberry Pi will be able to connect on. Most organizations do not have
    strict outbound filtering policies, making this approach more effective than a
    standard SSH connection. We find common ports open are TCP ports 22, 80, 443,
    or 53, meaning clients may be able to freely connect to the outside world using
    these ports.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Strict outbound protocol inspection devices such as next-generation firewalls,
    next-generation **IPS** (short for **Intrusion Prevention System**), and advanced
    proxy servers may block these types of connections.
  prefs: []
  type: TYPE_NORMAL
- en: The **hostport** is the port on your Raspberry Pi that has a service setup for
    listening. In our case, we are running an SSH server so the hostport by default
    will be `22`. You could change the default port to be more stealthy or leverage
    stunnel, which is covered next in this chapter. To summarize, the port will be
    the TCP port and the server is accepting incoming connections from the Raspberry
    Pi. The hostport is the port the server is running the SSH service.
  prefs: []
  type: TYPE_NORMAL
- en: 'On our Raspberry Pi example, we will enter the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This assumes port `7000` is allowed out from the network our Raspberry Pi is
    connected on. If that does not work, try different ports. Most organizations will
    allow outbound port `443` as shown in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Reverse shell through SSH](img/6435OT_02_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To try again with a different port on your Raspberry Pi, use the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'On your C&C central server, open up a command-line terminal and enter the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You will be prompted for the root password of your Kali Linux Raspberry Pi.
    You can see from the last command-line example that the command prompt has changed.
    We are now on our remote server and have full control of our Raspberry Pi as shown
    in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Reverse shell through SSH](img/6435OT_02_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You will need to make sure the OpenSSH server is installed and running or this
    process will fail. You will most likely see the failure by a connection refused
    error message. It is also important that you have modified the startup variables
    so your Raspberry Pi has SSH running after a reboot.
  prefs: []
  type: TYPE_NORMAL
- en: This technique is called reverse shell tunneling. Pick any port as your source
    port, such as port `53`, which is the same port as DNS, or port `80` to use the
    same port as HTTP. It is important to keep in mind that changing the port numbers
    does not necessarily mean you are changing the underlining protocols.
  prefs: []
  type: TYPE_NORMAL
- en: Stunnel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many administrators will have detection technologies such as IDS/IPS to detect
    and prevent open VPN connections. One method to get around this is levering stunnel.
    Stunnel creates secure communication between a TCP client and server by hiding
    inside another SSL envelope. This is done by acting like an SSL encryption wrapper
    between the remote client and server using industry-standard crypto libraries
    such as OpenSSL. What makes stunnel cool is it adds SSL functionality to commonly
    used daemons like POP2, POP3, and IMAP servers without any changes in the program's
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use stunnel, you first need to download the code using the `apt-get install
    stunnel4 –y` command as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Stunnel](img/6435OT_02_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You may get a message that the latest version of stunnel is already installed.
  prefs: []
  type: TYPE_NORMAL
- en: You will need to create a file called `stunnel.conf` inside the `/etc/stunnel/`
    directory. You can use your favorite text editor such as nano or `vi` to create
    the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following will be configured and entered into the `stunnel.conf` file.
    Note that you can change the ports to something that better suits you:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the configurations in the `stunnel.conf` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Stunnel](img/6435OT_02_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, you need to generate your private key using the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Once installed, you need to configure stunnel using the `sudo nano /etc/default/stunnel4`
    command.
  prefs: []
  type: TYPE_NORMAL
- en: 'This opens the `.conf` file. Change `enable = 0` to `enable = 1`. Next, open
    a file called `stunnel.conf` and add the following configuration to the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, add a firewall setting on the Raspberry Pi by creating the `firewall.sh`
    file using the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to restart the stunnel services by issuing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The final step is installing the Squid proxy on your Kali Linux Raspberry Pi
    by issuing the `apt-get install squid3 –y` command.
  prefs: []
  type: TYPE_NORMAL
- en: Installing a Stunnel client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we need to install a stunnel client. We can do this by downloading the Windows
    stunnel client application available at [https://www.stunnel.org/downloads.html](https://www.stunnel.org/downloads.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following image shows a stunnel-installer executable file icon:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Installing a Stunnel client](img/6435OT_02_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you have completed the install, open the stunnel install directory on Windows
    (it is usually located at `C:\Program Files\stunnel`).
  prefs: []
  type: TYPE_NORMAL
- en: Copy the `stunnel.pem` certificate you created on Kali to your Windows client
    inside the same directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should then open the `stunnel.conf` file and replace the contents with
    the following (please adjust any port settings you might have changed from our
    example):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Save and close the file. Next, run the `stunnel.exe` application. You will
    see the configuration page displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Installing a Stunnel client](img/6435OT_02_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now you can connect to your Raspberry Pi securely using the **IP address**
    and **Port** specified in the configuration''s `accept` parameter you defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Installing a Stunnel client](img/6435OT_02_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Wrapping it up with an example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Going back to our example from the beginning of the chapter, let's see how the
    topics covered in this chapter would apply to the real world. To recap on the
    situation, we had a customer with multiple international locations requiring on-site
    penetration testing services at an affordable price. To meet this challenge, we
    put together a Raspberry Pi hosting Kali Linux kit that cost us under a hundred
    dollars to construct per location. We sent a kit to each location and had a local
    person connect the Raspberry Pi to the local network. The method of connection
    and the tools that we ran will be covered in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Each local site was not aware of our service engagement, so we had to work around
    existing security such as firewalls configured to block outbound connections.
    To do this, we set up stunnel over a mail port and accessed all Raspberry Pi kits
    from a MacBook running Kali Linux. This gave us a centralized command and control
    point for each Raspberry Pi and a method to offload anything requiring heavy processes.
    At this point, we started launching various attacks from each Raspberry Pi from
    our home office in USA.
  prefs: []
  type: TYPE_NORMAL
- en: The total cost of this approach versus charging for travel and on-site services,
    which was night and day based, was as per initial budget expectations. The customer
    was happy to pay a few hundred dollars for hardware cost per site since we had
    a markup for time for construction and shipping. Outside of that, we charged for
    our services and that was it, making the overall project affordable and successful.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to customize a Raspberry Pi running Kali Linux
    for penetration testing environments. We covered best practices to tune the performance
    and to limit the use of GUI tools using command-line configurations.
  prefs: []
  type: TYPE_NORMAL
- en: One major point covered was how to set up a remote C&C server to offload all
    possible tasks from the Raspberry Pi as well as exporting data (exporting data
    is covered in [Chapter 3](ch03.html "Chapter 3. Penetration Testing"), *Penetration
    Testing*). This included establishing communication between the Raspberry Pi and
    the C&C server. We did this using SSH, HTTPS, and other types of tunnels. We also
    covered how to deal with placing a Raspberry Pi behind a firewall and still being
    able to manage it using reverse shell tunneling back to the C&C server.
  prefs: []
  type: TYPE_NORMAL
- en: After this chapter, you should be ready to start your penetration test. In the
    next chapter, we will cover how to perform penetration testing exercises from
    the Raspberry Pi hosting Kali Linux.
  prefs: []
  type: TYPE_NORMAL
