- en: Git, Configuration Management, and Infrastructure as Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will examine the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What is Git?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up a Git server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Committing to our Git repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Branching our Git repository and committing changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing Ansible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Ansible to install Java from a role
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing our Ansible configuration in Git
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring options for IaC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There was a time when a system administrator knew their server intimately. They
    could tell you every fan noise, the meaning of every beep, and what it sounded
    like when the metal expanded as the server got hot.
  prefs: []
  type: TYPE_NORMAL
- en: As with the hardware, the software was almost supernaturally indexed in the
    system administrator's head, and they could tell you at the drop of a pin what
    version of OpenSSL, Apache, or Midnight Commander they were running.
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s an obvious problem with this: the *hit by a bus* effect.'
  prefs: []
  type: TYPE_NORMAL
- en: If a sysadmin were to be unfortunately mowed down one morning, his Walkman being
    thrown to the road alongside the shattered remains of his Game Boy Color, all
    the knowledge of the server would be lost in a singular moment. The knowledge
    of the strange way in which the server was set to boot, meaning it has to have
    the keyboard unplugged at just the right moment, will be gone forever.
  prefs: []
  type: TYPE_NORMAL
- en: You don't want one person to be intimately aware of everything to do with a
    server—you want multiple people, and to take it one step further, you want it
    written down in a format that's not only easily reproduced and modified, but also
    preferably so simple that even a computer could understand it.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we're going to look at three things that are relatively close
    together in the software world—a version control system, called Git; the concept
    of configuration management, mostly in the form of Ansible; and Infrastructure
    as Code, featuring everyone's favorites, Terraform and Packer.
  prefs: []
  type: TYPE_NORMAL
- en: We've actually already done a lot of this by using Vagrant as we have been doing.
    Vagrant is effectively a method of having infrastructure as code, though on a
    very small scale. The small scripts that we've put into a couple of our Vagrantfiles
    could easily be considered configuration management, though at a base level.
  prefs: []
  type: TYPE_NORMAL
- en: These tools are some of the best you'll come across on your journey, and Git
    especially is used pretty much universally, so it's good to understand.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we're going to need a couple of **virtual machines** (**VMs**).
  prefs: []
  type: TYPE_NORMAL
- en: 'Feel free to use the `Vagrantfile` that follows. We''re mostly going to work
    across the private network, between the VMs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: What is Git?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we're going to look at the supreme overlord when it comes to
    **version control systems** (**VCSs**). There have been others, and there will
    be more to come, but right now, there's Git, and it's by far the most widely used
    and most popular (though not without its fair share of criticism).
  prefs: []
  type: TYPE_NORMAL
- en: Git was initially developed by Linus Torvalds—yes, that same Linus Torvalds
    who kick-started Linux kernel development, though these days it's primarily developed
    by Junio C Hamano, and many other talented hackers. It's found in software development
    primarily, but is increasingly used to store configuration for things like Ansible,
    Terraform, and any other infrastructure as code tool, enabling a historic and
    versioned picture of your infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To understand Git, we''re going to install it and start your VMs and jump onto
    your first CentOS box:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Installing Git is simple, as it''s in most default repositories (in fact, I''ve
    yet to come across a Linux distribution where it wasn''t in the default repositories):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Warning: You will most likely get Perl, and while this is not inherently a
    bad thing, the very mention of the word perl can make developers and sysadmins
    alike cringe.'
  prefs: []
  type: TYPE_NORMAL
- en: We should now have Git, so let's run through some basics.
  prefs: []
  type: TYPE_NORMAL
- en: Cloning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Fundamentally, Git is a version control system that's primarily used for source
    code versioning (though it has other uses, too).
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate how it works, let''s clone a smallish repository (in this case,
    Ansible):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This may take a couple of minutes based on your connection, but, once finished,
    you''ll be left with an `ansible` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Exploring and making changes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now have a like-for-like copy of the `devel` Ansible code branch. It's `devel`
    because that's what the repository owners want the default branch to be, though
    frequently it will be `master` or `develop`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Taking a look inside the folder, we''ll see a lot of files with a lot of code
    inside:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As with any good source code, there should be a `README` file, which is generally
    a good place to start, but we're not here for Ansible right now—we're here for
    Git.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run a `git status`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This tells us that we've made no changes and, as a result, our working directory
    is clean, given that we've done nothing yet.
  prefs: []
  type: TYPE_NORMAL
- en: 'Make the following change to the `README` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we apply `git status` again, we''ll see our change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As the message suggests, we could add and commit our changes, and then attempt
    to get them merged upstream (don't), but for now, we're going to simply revert
    the change we've just done that mangled the `README` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s take a look at what we did:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Oh dear—let''s fix that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note how, when we checked out the `README` file, we basically reset the file
    to its default state, meaning that git doesn't think we have anything to commit,
    and the file is back to normal.
  prefs: []
  type: TYPE_NORMAL
- en: Checking out is the act of overwriting our uncommitted local changes with the
    Git repository's version.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see the fact that these changes have been reverted by once again catting
    the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Neat, eh?
  prefs: []
  type: TYPE_NORMAL
- en: It's worth remembering, though, that any changes you made prior to overwriting
    the file will be lost (because they weren't staged, and the repository wasn't
    made aware of them).
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Fundamentally, Git is a version control system, meaning that it controls the
    versions of the files under its care.
  prefs: []
  type: TYPE_NORMAL
- en: Most folders can theoretically be made into a Git repository, though it's usually
    code or configuration that gets this privilege.
  prefs: []
  type: TYPE_NORMAL
- en: When you check out a repository, you get a snapshot of where the code on the
    branch is at the time you check it out. If you then make changes, those changes
    need to be staged and either kept in a separate branch or merged into the branch
    you changed.
  prefs: []
  type: TYPE_NORMAL
- en: Don't worry too much about this yet—I was incredibly confused the first time
    someone told me about Git.
  prefs: []
  type: TYPE_NORMAL
- en: In the real world, there are a few different ways that people tend to use Git,
    and some relatively popular tools and practices that have been developed. The
    kernel method of using Git, for example, is extremely different to the GitFlow
    method.
  prefs: []
  type: TYPE_NORMAL
- en: We'll be going over examples of changes in the rest of this chapter, but for
    now, you just need to understand that if you commit and push something into a
    Git repository, it will have a record of that change, meaning that you can go
    back to an earlier version of your code at any point in the life cycle of the
    repository, and either copy old fixes or back-port changes into stable branches.
  prefs: []
  type: TYPE_NORMAL
- en: Sadly, Git doesn't have the ability to import code you haven't written yet from
    some weird future file, but I'm still holding out hope for this feature.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your configuration per repository is stored in the `.git` folder that''s created
    upon a repository being imported/created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This folder also contains the history (in a binary format) of your repository.
    It is the place that's searched for when you're trying to look for changes and
    differences in files that aren't in your checked-out branch. Therefore, it can
    also be quite large.
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking into the configuration file, we can see the defaults drawn down when
    we cloned the repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Note the remote sections, detailing where our `origin` resides.
  prefs: []
  type: TYPE_NORMAL
- en: There's also a `global` configuration file and a `system` file that can be used
    to make changes that affect every repository your user interacts with, along with
    every repository any user on the system interacts with.
  prefs: []
  type: TYPE_NORMAL
- en: This should give you a good indication as to why Git is so great—it allows easy
    collaboration because people can work on different branches or even the same branch,
    and there are functions in place to stop you stamping over each other's work.
    You can also make changes safe in the knowledge that the history of a file is
    there, meaning that when you inevitably break something, you can fix it with a
    few keystrokes.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Git is extremely powerful, but it also has some functionality that is just plain
    nice.
  prefs: []
  type: TYPE_NORMAL
- en: '`log`, for example, can be useful for reading commit messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should look like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ff6c981d-7bbd-454e-8418-ed7de204081c.png)'
  prefs: []
  type: TYPE_IMG
- en: '`tag` can be useful for listing the tags people have added to different points-in-time
    of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '`branch` can be used to see all the different branches that Git is aware of:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Here, we used `-a`, so remote branches are included, as well as your single
    local one (`devel`).
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a Git server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we're going to look at setting up a small Git server, literally
    using what we got when we installed `git` from the CentOS repositories.
  prefs: []
  type: TYPE_NORMAL
- en: We'll create a basic repository on centos2 and work with it from centos1.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this section, we're going to be using both of our machines, using centos2
    as a server, and centos1 as the client.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this instance, ensure that `git` is installed on both your machines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'On `centos2`, let''s create our empty repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, on our `centos1` machine, we can clone the repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: You'll be prompted for the `vagrant` user password (`vagrant` by default), and
    then you'll see a message informing you that you've cloned an empty repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is fine, though, as you should now see a new `example` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you initialize your repository on centos2, you're creating the first of
    a repository that can exist on any number of devices, and that don't necessarily
    have to be cloned from your central location (centos2).
  prefs: []
  type: TYPE_NORMAL
- en: If, for some reason, you're in a situation where you can't clone from the initial
    server (centos2), you could also clone the repository from another machine that
    already had the repository checked out (though you do run the risk of that repository
    not being up to date with the first node).
  prefs: []
  type: TYPE_NORMAL
- en: When you clone the repository, you're actually communicating over SSH with the
    `centos2` box, and Git sends specific commands that are understood by the repository
    on the other side and answered.
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, if we check out the `.git` repository on `centos1`, within the cloned
    repository, we can see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Note the URL printed as the remote `origin`. Also be aware that this isn't a
    `bare` repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the `config` file on the server (`centos2`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: It's considerably smaller, with `bare` set to `true` here.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is the simplest of Git repositories, and there's a bit more you can do
    if you want to make it a bit more interesting.
  prefs: []
  type: TYPE_NORMAL
- en: First, you might consider creating a dedicated `git` user on your system, and
    using this as the user that manages and owns the Git repositories. This is generally
    a pretty standard approach, and one shared by the off-the-shelf Git solutions,
    like GitLab and GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: Secondly, you could think about setting up a `cgit` server, which is a small
    server that can be used to visualize a Git repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most famous `cgit` instance is probably [git.kernel.org](https://git.kernel.org/):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/50656c38-f1d5-431e-8307-6138b86432bb.png)'
  prefs: []
  type: TYPE_IMG
- en: Committing to our Git repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we're going to put together a small file, add it to the files
    being tracked by Git, commit our changes, and push them to the origin server.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you haven't already, set up a Git server based on the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: Ensure that you've checked out your repository on `centos1`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s give our new repository a bit of information and push this to the server
    (proving it works):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s start by running a `git status` to see where we''re at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Good—it's empty.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s echo out some text to a file, stage the file, and commit it with
    a message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Ah! Now, because this is a new installation, Git prompts us to set some defaults:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s try that commit again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Okay, we've committed our file, meaning that the local version of `master` is
    up to date.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, this means that we''re now out of sync with our origin repository,
    so we need to `push` our changes up to there, too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Woo! Another prompt—we should set it. Personally, I chose the new behavior,
    because while CentOS 7 ships with an old version of Git, the march of progress
    continues:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Phew! Alright, let''s try a push again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Here, you can see that we were prompted for our password, but once that's entered,
    the changes are written to the origin server.
  prefs: []
  type: TYPE_NORMAL
- en: This means that when we clone the repository from the origin again, our changes
    will come with it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try the following from your home directory to prove this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Excelsior!
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here, we're doing a few things.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, after we''ve created our foo file with some text in, we `add` that file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In this small command, we're actually adding the `README` file to Git's index.
  prefs: []
  type: TYPE_NORMAL
- en: 'Anything we stage in this manner is added in the next commit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Here, we're committing (as the name suggests) our added changes to the repository.
    We also include a message as part of the command (with `-m`) instead of letting
    `git commit` drop us into whatever our default editor is set to (because every
    commit should have a message, since it prompts you to write one).
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, we pushed our change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In technical terms, we're informing the remote repository (on `192.168.33.11`)
    that some references have changed, and we tell it which ones. We also push any
    associated objects with these referenced changes.
  prefs: []
  type: TYPE_NORMAL
- en: Matching versus simple
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A quick word on this, as we set our default in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Had we set our option as matching, we would push all of our branches at once
    when running a `git push` command. This means that not only your current branch,
    but also `master`, `develop`, and any others you might have will also get pushed.
  prefs: []
  type: TYPE_NORMAL
- en: Simple, on the other hand, will only push the branch that you're currently working
    on. From a logic point of view, it's understandable that simple would be the default
    behavior, as it assumes that most people will only work in one branch at any one
    time.
  prefs: []
  type: TYPE_NORMAL
- en: Branching our Git repository and committing changes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we're going to look at branching our cloned repository and
    pushing those changes to our server.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ensure that you've run through at least the *setup* section, but preferably
    the section where you committed your first file, too.
  prefs: []
  type: TYPE_NORMAL
- en: All work will be done on `centos1`, in the `example` repository.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Change into the `example` repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, check that you''re on `master` to start:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Your current branch is denoted with an asterisk.
  prefs: []
  type: TYPE_NORMAL
- en: 'Good! Now, we''re going to `branch` off from `master`, and make some changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Run `git branch` again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that now, we have two branches, but we''re still on the `master` branch.
    We need to run a different command to flip to our new branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, list what''s in this branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: We've effectively made a copy of the `master` branch, meaning that all of the
    files committed to that branch are available in our new one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a new file and give it some content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Running `git status` again informs us of our untracked changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'As it says, let''s `add` and `commit` this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: We've now got a branch locally, with a committed file that doesn't exist on
    the origin server at all.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try to `push` our branch to `192.168.33.11`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Oh no!
  prefs: []
  type: TYPE_NORMAL
- en: Because our local `develop` branch has no upstream counterpart configured, the
    `push` fails.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, you already knew that because you''re a diligent sysadmin and you
    actually read the error message, along with the helpful command it gave us to
    rectify this problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Okay, so we've now got a `develop` and `master` branch locally, as well as a
    copy on the upstream server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s check out `master` to see what it looks like now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: What? Where's our file? It was in this directory!
  prefs: []
  type: TYPE_NORMAL
- en: Ah, but no, this is a different branch of the same directory, and, in this dark,
    dark timeline, our work doesn't exist.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s just check the differences between our two branches:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: There's our work!
  prefs: []
  type: TYPE_NORMAL
- en: Okay, so what if we want to merge our changes in from `develop`?
  prefs: []
  type: TYPE_NORMAL
- en: 'Git does that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Boom! We're still on our `master` branch, but the file is back.
  prefs: []
  type: TYPE_NORMAL
- en: 'Confusingly, though, if we now run `git status`, we see a new message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Thankfully, again, the message is nice and explanatory. Our local `master` branch
    is fine, but `upstream` isn't yet aware of our changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can prove this with another `diff`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s get our changes up there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Magic.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Okay, so it's not really magic, just the product of some extremely brilliant
    coding.
  prefs: []
  type: TYPE_NORMAL
- en: When we branched from `master` (or any branch, for that matter), we created
    a point-in-time clone of that branch in our new one. We then made changes to the
    branch, doing things like testing configuration changes, or purposefully breaking
    things, without affecting the `master` branch (and our known good configuration).
  prefs: []
  type: TYPE_NORMAL
- en: That much is easy to understand (I think), but the problems begin when we want
    to make sure that our changes are pushed to the server.
  prefs: []
  type: TYPE_NORMAL
- en: We ran `git push`, which complained. This was because we didn't have a section
    in our .git/config file that told git where to push our local branch.
  prefs: []
  type: TYPE_NORMAL
- en: 'After we run the suggested command, our `.git/config` now looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Note the inclusion of a new branch definition.
  prefs: []
  type: TYPE_NORMAL
- en: So, the push is done, and remote looks good.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then flipped back to `master` and performed our `git diff` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: This should be reasonably self-explanatory, but we're performing a `diff` against
    the branch we're on right now, as well as the designated branch.
  prefs: []
  type: TYPE_NORMAL
- en: 'You could achieve the same thing with the following syntax, which is a bit
    more explicit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you could even check the two branches you''re not on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: In this way, we start to see how powerful Git can be as a development tool.
  prefs: []
  type: TYPE_NORMAL
- en: It also neatly segues me into talking about `origin` branches.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we compared our local master with `origin/master`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'From our `.git/config`, we learned that `origin` is the name of the remote
    repository, as far as Git is concerned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Ergo, `origin/master` is the `master` branch on the `remote` server.
  prefs: []
  type: TYPE_NORMAL
- en: Our pushing to the `origin/master` (in the form of `git push`) keeps our code
    up to date.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You might be wondering why you'd bother pushing to a `remote` branch if you're
    just going to locally merge your branch into `master` anyway.
  prefs: []
  type: TYPE_NORMAL
- en: 'The answer is simple: in most environments, you end up working with a lot of
    other people, and it''s a good development tool to be able to show what you''ve
    changed and what you''re working on. It also allows for things such as in-branch
    collaboration prior to merging, as anyone else is able to check out your branch
    for themselves.'
  prefs: []
  type: TYPE_NORMAL
- en: It's also true that most people don't just use a Git server in their infrastructure,
    instead looking for solutions such as Gogs and GitLab, which are Git servers with
    added functionality (like user management).
  prefs: []
  type: TYPE_NORMAL
- en: You could also be thinking about the server, and appreciating that in this section,
    it dragged along a bit, and wasn't really needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a quick look at the changes to our server by first creating and
    checking out a new branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: I used the shorthand for creating and checking out a branch here, adding `-b`
    to the `git checkout` command. There's hundreds of little tricks with Git, and
    people tend to have their favorites.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this branch, let''s create a new file and `push` it `upstream`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, flip on to `centos2` and nip into the repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'By running `ls`, you won''t see your actual files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead, your files are in the `objects` directory, unreadable in their current
    format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see our branches by their `ref`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: You wouldn't work in the bare repository on the server—you'd clone and adjust
    your repository on another machine—but it's neat to look into the inner working
    occasionally.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You might want to install GitLab, or Gogs, or any of the other GUI-Git implementations
    so that you can play around with them. Personally, I find them to be reasonably
    intuitive, and teams of people tend to work better when they have a GUI to jointly
    despise than a series of console commands.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we're going to look at one of the most popular configuration
    management tools in the form of Ansible. Like others (such as Chef, Puppet, and
    Salt), Ansible is a way of codifying your server configuration, by which I mean
    that any changes you want to make can be written into a file and applied to a
    server, or a collection of servers, programatically.
  prefs: []
  type: TYPE_NORMAL
- en: The configuration files you put together can be saved to a central store, most
    commonly Git, and you can build things such as automatic pipelines around your
    configuration so that changes to that configuration are applied automatically.
  prefs: []
  type: TYPE_NORMAL
- en: In the default scenario, your Ansible is run from a designated box in your infrastructure
    (usually a GitLab, Jenkins, or Ansible Tower install), or in smaller environments.
    It's not unusual to see engineers making changes from their own machines.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible isn't just for servers with modules that cover a wide range of scenarios,
    such as cloud provider configuration, switch configuration, and even certificate
    management.
  prefs: []
  type: TYPE_NORMAL
- en: We're going to run through some small Ansible commands on centos1, applying
    changes to centos2.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Open a connection to your `centos1` machine, installing Ansible at the same
    time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we''re going to just check the version of Ansible that we''ve got installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: This is version `2.4.2.0`.
  prefs: []
  type: TYPE_NORMAL
- en: As with a lot of packages from the standard repositories, they tend to be a
    stable (older) version. If you wanted to, it's also possible to install `pip`
    (covered in [Chapter 11](373b755f-2d54-4d28-9259-cc91d1893cf6.xhtml), Web Servers,
    Databases, and Mail Servers) and use it to install a more recent version of Ansible.
    For now, we're going to stick with `2.4.2.0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test whether our connectivity is there, we can use a default Ansible module
    called `ping` (though this isn''t ICMP). You will be prompted for an `SSH password`
    (vagrant):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: We add the 'ANSIBLE_HOST_KEY_CHECKING=false' variable to ensure the remote machine's
    SSH host key get's accepted when we run our command. Subsequent commands shouldn't
    require this. In a production scenario, you should always confirm you trust the
    remote machine's key.
  prefs: []
  type: TYPE_NORMAL
- en: Awesome! Our `centos2` box responded, and better still, our command tells us
    that this didn't result in a change to the remote machine (more on this later).
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's try installing something using a different module. We want to install
    a package, but we don't know how.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this, you could either go to the Ansible website ([https://docs.ansible.com/ansible/latest/modules/list_of_all_modules.html](https://docs.ansible.com/ansible/latest/modules/list_of_all_modules.html))
    and search for `package`, or you could use `ansible-doc`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'When run, you will be dropped into a pager, along with a list of all the Ansible
    modules available. Run a search (typing the `/` character, followed by the search
    string) for `package` and keep going until you find a module of that name:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4825c804-0d1f-4b06-b2c1-392d931370a4.png)'
  prefs: []
  type: TYPE_IMG
- en: There's no guarantee that a module exists for the functionality you want, but
    there's also a good chance it does. Search for keywords that relate to what you're
    trying to do, and, nine times out of ten, you might be pleasantly surprised.
  prefs: []
  type: TYPE_NORMAL
- en: Assuming you've found out that the package module is called `package`, you can
    quit out of this pager.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s see what the syntax is for `package`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: This looks good, and what it tells us is that the requirements are just what
    we need in order to `name` the package, and dictate what state it should be in.
  prefs: []
  type: TYPE_NORMAL
- en: 'Excellent! We can use this knowledge:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: We could have also included `-K` if the sudo action required a password on the
    remote machine, ours didn't.
  prefs: []
  type: TYPE_NORMAL
- en: Cool! So we managed to use Ansible to install the `zip` package on our remote
    machine (I'll leave it up to the reader to guess what this package does). Let's
    run that command again—what's going to happen? Will it reinstall the package?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: As it turns out, no, Ansible won't reinstall the package. This is one of the
    fundamental ideals, if you will, of Ansible. Jobs run against a remote host should
    be idempotent, that is, they shouldn't make any changes when they don't need to.
  prefs: []
  type: TYPE_NORMAL
- en: It is good practice, when writing Ansible, to ensure that the code you write
    is idempotent, rather than having it making a change each time it's run. The code
    won't be idempotent if changes are constantly made, and you can't ever guarantee
    the state of your systems.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, especially when executing straight commands on a remote system, idempotence
    will have to be thought about carefully, and occasionally manually constructed
    into the logic of your Ansible runs, though this is a more advanced discipline.
    Even I occasionally defer to far smarter friends on the subject.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the sake of completeness, let''s do one last thing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Can you spot the difference between this command and our last?
  prefs: []
  type: TYPE_NORMAL
- en: It's yum!
  prefs: []
  type: TYPE_NORMAL
- en: Specifically, what we've now done is used the Ansible `yum` module in place
    of `package`, meaning that we've not made it so that our command will only work
    on YUM-based systems. This highlights that there's more than one way to accomplish
    the same goals, and we'll talk about why you might want to use either module soon.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we''ve had a quick look at how Ansible can be used to run jobs on
    remote machines, let''s break down what we did, starting with the `ping` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s go over those arguments in order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `-k` means that Ansible will know to prompt us for a password, with which
    we''re going to connect to the remote machine (our Vagrant user''s SSH password):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we''re telling Ansible that we want to use the `ping` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Here, we're building an inventory, though admittedly an inventory of one machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ansible needs to know the list of hosts it can work with—its inventory—but
    here, we only have one, so we''re using that (being sure to end with a comma):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we end with the IP of the host we're trying to hit, which, somewhat
    counter-intuitively, we have to repeat.
  prefs: []
  type: TYPE_NORMAL
- en: One thing we are missing here is the `-u` flag, which we would use if we wanted
    to `SSH` to the remote host as a user that wasn't `vagrant`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we''re here, we''re going to also take a look at our second `ansible-doc`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Here, we wanted to see a snippet of the code that we could write for use with
    the `package` module. This is extremely useful on a server in a pinch, or in an
    exam situation where you may not have access to the wider internet.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, let''s break down our final command (though the same principles can
    be applied to the `package` example):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, there are a couple of differences:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: We use `-b` here because we're making a change that requires us to "become"
    on the remote machine. This means running a command with privilege escalation
    (becoming root).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Here, we've added `-a` to our list of arguments, specifically because the `yum`
    module requires arguments of its own, which we then place inside quotes.
  prefs: []
  type: TYPE_NORMAL
- en: These arguments can get quite long based on the module you're using, but here
    it's a relatively small amount.
  prefs: []
  type: TYPE_NORMAL
- en: We used `yum` the second time, specifically to highlight that while the same
    goals were achieved (the installation of the `zip` package), we have the option
    to tie our command to particular distributions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The reason for this is simple when you look at the list of arguments available
    to the `package` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '`name`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`state`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`use`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can also look at those available to the `yum` module to help with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`allow_downgrade`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`conf_file`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`disable_gpg_check`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`disablerepo`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`enablerepo`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`exclude`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`installroot`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`list`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`name`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`security`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`skip_broken`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`state`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`update_cache`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`validate_certs`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hopefully, you can see how the `yum` module could be used to craft much more
    specific and detailed instructions for Ansible to follow.
  prefs: []
  type: TYPE_NORMAL
- en: In the real world, I have seen engineers write code that attempts to satisfy
    all use cases with one role, that is, a role can be applied and accomplish the
    same thing on a Debian, CentOS, or Alpine system. This is perhaps a noble goal,
    but it usually results in immense frustration on the part of the engineer, or
    the engineer who comes next, due to inflexibility. Generally, I have found it
    easier to simply use the distro-specific modules, and get Ansible to check what
    sort of distro it's running on prior to choosing which commands to execute or,
    better yet, just use one distribution in your infrastructure instead of a mixture.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There's a couple more small things to be aware of.
  prefs: []
  type: TYPE_NORMAL
- en: The raw module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this case, centos2 already had Python installed (which Ansible needs in order
    to run modules on remote machines). However, if it hadn't, you would have had
    to install it on the machine first, or use Ansible's built-in `raw` module prior
    to any others.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you use `raw`, you''re actually running commands directly on the remote
    machine. This is most commonly seen with a line similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Note that the remote machine simply responded with `SUCCESS` and the resulting
    command.
  prefs: []
  type: TYPE_NORMAL
- en: 'We would use this to install `python`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: It's not nicely formatted, but as we now have `python` on the `remote` machine,
    we will be able to use proper Ansible modules instead of relying on simple `SSH`
    executions.
  prefs: []
  type: TYPE_NORMAL
- en: The shell and command modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like `raw`, you can pass native commands to a remote machine using Ansible (in
    fact, you could translate an entire bash script into an Ansible role remarkably
    easily), though usually this type of functionality is reserved for instances where
    you absolutely can't achieve what you're trying to do with dedicated Ansible modules.
  prefs: []
  type: TYPE_NORMAL
- en: These two do, however, require Python to be on the remote machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s look at the `shell` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Note that I'm basically running a small one-liner within my Ansible command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s use the `command` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Ah... this failed.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is because `command` doesn''t explicitly run a shell (such as Bash), so
    when we tried to use a bashism in the form of >, it failed. The `command` module
    is only really good for short commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here, we used an `SSH` passphrase to run remote commands on our box, but this
    is not usually done (especially in automated environments). Generally, SSH keys
    are used, with privileges being carefully controlled.
  prefs: []
  type: TYPE_NORMAL
- en: Using Ansible to install Java from a role
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ansible is great for doing what we just did, running easy-to-understand commands
    by using modules on remote machines.
  prefs: []
  type: TYPE_NORMAL
- en: But that isn't its bread and butter. Instead, Ansible really shines when it
    comes to running a whole slew of commands against a remote machine, and making
    vast configuration changes in seconds.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we're going to write a small Ansible Playbook to import an
    Ansible Role from a public repository, and apply that role to our centos2 machine.
  prefs: []
  type: TYPE_NORMAL
- en: Hang on to your hats!
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this section, we are again using our `Vagrantfile` and two CentOS VMs.
  prefs: []
  type: TYPE_NORMAL
- en: It would be a good idea to complete the previous section before working on this
    one.
  prefs: []
  type: TYPE_NORMAL
- en: '`SSH` to your `centos1` machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start by creating a directory in which we''re going to work and dropping
    into it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we said we''re going to use a public Ansible role for this job, so let''s
    run a search for one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'You could also use the [https://galaxy.ansible.com/](https://galaxy.ansible.com/) website:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bfcbda58-16c4-4465-bae2-f7b45a14d722.png)'
  prefs: []
  type: TYPE_IMG
- en: Searching for java on Ansible Galaxy
  prefs: []
  type: TYPE_NORMAL
- en: I actually tend to use the website more than the command line, simply because
    it gives you a good overview of role popularity at a glance. I already knew that
    the one written by `geerlingguy` was very popular, so I chose to explicitly include
    his name in the search.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we know what role we want to use, let''s download it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Awesome! We have our role.
  prefs: []
  type: TYPE_NORMAL
- en: Now how do we apply it?
  prefs: []
  type: TYPE_NORMAL
- en: With a Playbook, of course!
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following on your system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, run our `playbook` against centos2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see a stream of information run across your screen, as the role
    we downloaded earlier is applied to the remote machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5e5e3019-191f-40bc-8e21-09d5b32c2b29.png)'
  prefs: []
  type: TYPE_IMG
- en: Note `ok=6` and `changed=1` at the bottom of the run. If you now run the playbook
    a second time, you should get `changed=0` since the role is idempotent.
  prefs: []
  type: TYPE_NORMAL
- en: And there you have it! With only three commands (realistically), you've got
    a Java installation on your remote machine.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Running through what we did in this section, command by command, we'll break
    down what happened.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: Initially, we needed to know whether someone had already written an Ansible
    role to install Java on a box. As it happens, we were able to search for Java
    for Linux while passing in an author's name, resulting in seven roles being found.
  prefs: []
  type: TYPE_NORMAL
- en: I have a friend who likes to write his own Ansible for a job, but I've always
    been of the opinion that if a solution already exists (and it's suitable), there's
    no harm in adopting work that others have written, providing that its license
    allows you to do so, and your company is fine with it. The open source community
    is good, and if someone's already invented the wheel, try putting down the hammer
    and chisel.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: Once we knew of the role we wanted, we ran the `install` command. Specifically,
    we had to use `sudo` for this, as the role in question is pulled onto your box
    and placed in the shared `/etc/ansible/roles/` directory, which our user doesn't
    have write access to.
  prefs: []
  type: TYPE_NORMAL
- en: You can see this role (and copy or tweak it required) by looking in the directory.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: The actual role starts in `tasks/main.yml`, so it's a good idea to take a look
    in there, too.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: Next, we created a small `playbook.yml` file to dictate which role we should
    install where.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: Of note here is the fact that we listed the `hosts` as `all` rather than a specific
    hostname or IP, and the roles are in the form of a YAML list.
  prefs: []
  type: TYPE_NORMAL
- en: You can make a playbook into quite a complex beast by adding different variables,
    different rules on where to apply different roles, and a variety of other options.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we used `ansible-playbook` to actually apply the contents of `playbook.yml`
    to `centos2`. We used the common options `-k`, `-b`, and `-i` to build up our
    command.
  prefs: []
  type: TYPE_NORMAL
- en: This now goes to `centos2`, and executes every line of the `geerlingguy.java`
    role.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It might seem like overkill to put together a playbook for the sake of one role,
    but the beauty of playbooks is that they're not bound to one role. You can include
    as many as you want in the list within the `playbook.yml` file, and, as long as
    they don't conflict with each other, you should have a very smooth Ansible experience.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at this `playbook.yml` file instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'We also used `galaxy` in a very specific way, using `ansible-galaxy` to install
    the role from the internet first. You could also include a `requirements.yml`
    file with your code, which `ansible-galaxy` is able to read so that it might download
    any listed roles it finds, prior to attempting to apply them to a remote box:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, prior to your `playbook` run, you would first run `galaxy`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'This means that when you do run `ansible-playbook`, you''ve got your roles
    ready:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As I mentioned in the *How to do it...* section, I was already aware of `geerlingguy.java` because
    the author (`geerlingguy`) is prolific in the Ansible he writes. There's a good
    chance you'll see the name again, regardless of the institution you end up working
    for.
  prefs: []
  type: TYPE_NORMAL
- en: Storing our Ansible configuration in Git
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's combine what we've learned so far and store the Ansible configuration
    we wrote in the last section on our Git server.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we're going to primarily use `centos1`, but we're going to
    upload our configuration to `centos2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'SSH to both of your virtual machines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'On centos2, create another bare `Git repository` from your home directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'On `centos1`, switch to your `ansible-example` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, initialize the directory to be a `Git repository`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the files we had in the directory already, and `commit` them to the repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: Once done, your local repository is good, but we still want to `push` them to
    a remote destination.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add your remote with the alias `origin`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can `push` our changes to the `remote` repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All we''ve done here is combine what we''ve done in the last few sections:'
  prefs: []
  type: TYPE_NORMAL
- en: We created a Git repository on the centos2 machine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We took the Ansible configuration we'd written and initialized a repository
    around it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We set our `remote` destination to be centos2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We pushed our configuration to the remote machine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, even if centos1 were to go away, you'll have a copy of your configuration
    on centos2, and others can clone that information down, make changes, and push
    back up.
  prefs: []
  type: TYPE_NORMAL
- en: There's a reason you traditionally see a  "build server" of some description
    or other in the land of system administration. This is because you can claim it
    as a focal point for distribution configuration and managing your infrastructure.
    It's easy to see how out of sync you could get were five people in a team to work
    on one project at the same time, each in a different branch, with their own changes.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring options for IaC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll be downloading some binaries from Hashicorp's site, and
    also using our `centos1` VM.
  prefs: []
  type: TYPE_NORMAL
- en: Completely automating your infrastructure is beyond the scope of this book,
    but there's no reason we can't talk about a couple of the most popular tools on
    the market at the moment.
  prefs: []
  type: TYPE_NORMAL
- en: Both Terraform and Packer are made by Hashicorp, who have a reputation for making
    life easier for system administrators, or never releasing a version 1.0.0 of their
    products, depending on who you ask.
  prefs: []
  type: TYPE_NORMAL
- en: Hashicorp are also the people who maintain Vagrant, though they did once try
    to replace it with a program called Otto—we don't talk about Otto.
  prefs: []
  type: TYPE_NORMAL
- en: Terraform is a way of writing your infrastructure as declarative code, with
    a wide range of providers to choose from, including AWS, Azure, Scaleway, Digital
    Ocean, and more.
  prefs: []
  type: TYPE_NORMAL
- en: Packer, on the other hand, is a way of building your base image for your provider
    of choice, baking all the software you think you're going to need globally into
    a default image, that you can then expand on with programs such as Chef, Ansible,
    or Puppet.
  prefs: []
  type: TYPE_NORMAL
- en: If you've ever clicked your way through a provider's online portal for provisioning
    VMs, object storage, or networking, you probably already appreciate why Terraform
    and Packer sound amazing.
  prefs: []
  type: TYPE_NORMAL
- en: Neither of these tools were the first to do what they intended to do, but they
    do them well, and, at the time of writing, they have a vast, vast chunk of the
    collective mind-share.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'SSH to `centos1` and download both Terraform and Packer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to unzip these binaries, so first install the appropriate tool.
    Then, unzip both of our applications and move them to `/usr/local/bin/`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: Terraform and Packer evolve so quickly that remarkably few repositories will
    actually have them. The programs also complain if you use a version that's out
    of date, displaying a large banner every time you use them. The only repository
    I've come across that seems to consistently package Terraform is the FreeBSD default
    repo (and even that's out of date).
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re also going to be using `docker` for this, so if you haven''t got it
    installed on your virtual machine, run the following (this was covered in more
    detail earlier in this book):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll go over our two programs in turn.
  prefs: []
  type: TYPE_NORMAL
- en: Terraform
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Starting at the top, we're going to use Terraform to create a small Docker deployment
    locally. This is the easiest to show as we have all of the tools we need on our
    VM, and it doesn't mean I have to tell you to go out and start a free trial on
    some cloud provider.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by creating a directory for us to work in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, shove the following configuration into a `main.tf` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, initialize Terraform:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: We're using `sudo` here because our user isn't in the group that can control
    Docker and, as a result, Terraform won't be able to talk to Docker either when
    invoked by us.
  prefs: []
  type: TYPE_NORMAL
- en: Once initialized, you should now be able to apply our configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at `docker ps` first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, run `terraform apply`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see a breakdown of the actions about to be taken, and a prompt to
    get you to type `yes`. Do so and hit *Enter*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: Excellent!
  prefs: []
  type: TYPE_NORMAL
- en: 'Run `docker ps` again to find out what you''ve just created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s `destroy` our container, again using Terraform:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: Once again, we're prompted to type `yes` in the field provided. Do so and hit
    *Enter:*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: Boom! Our container is gone.
  prefs: []
  type: TYPE_NORMAL
- en: Packer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Say we don't want to just use the container from Docker Hub. Say we want to
    tweak it slightly before we deploy it using Terraform.
  prefs: []
  type: TYPE_NORMAL
- en: This is where Packer comes in, which is a very versatile tool. Packer has builders
    for AWS, Scaleway, LXC, VirtualBox, QEMU, and others, but the one we're interested
    in is Docker.
  prefs: []
  type: TYPE_NORMAL
- en: 'Head back into your home directory and create an `example-packer` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, output the following to a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: 'Once done, you should be able to run `packer` to `build` and tweak your container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'Great! We''ve now got an image we can use elsewhere:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's break this down a bit, starting with Terraform.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we defined what we wanted our infrastructure to look like
    by writing the configuration to a `main.tf` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: 'Specifically, what we''re doing here is giving Terraform its provider and the
    necessary information to connect with said provider (in this case, a Unix socket):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re then informing Terraform of the image we want to use as the base of
    our container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we''re saying that the container should be called `nginx-example`
    and that it should use the image that we defined previously (note the use of a
    referencing variable to the preceding block):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we saved it, we ran a command to initialize the directory for Terraform
    use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: 'This downloads the provider (docker) and sets up the directory for us to use
    it. We then applied our configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: Terraform looks for any files ending in `.tf` within the directory it's invoked
    from.
  prefs: []
  type: TYPE_NORMAL
- en: 'Afterward, we destroyed our setup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: 'Your directory will end up looking something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: Note the `state` file. This is important as it contains the known state of the
    infrastructure you've provisioned. Looking inside, you'll see a JSON-like syntax,
    though this can change. The Terraform state file shouldn't be altered by hand.
  prefs: []
  type: TYPE_NORMAL
- en: I have horror stories revolving around having to manually recover the state
    of infrastructure, as I'm sure many others do too, and believe me when I tell
    you that losing a state file is not fun, nor is it going to be a quick recovery
    process. Needless to say, it's a good idea to keep this file backed up.
  prefs: []
  type: TYPE_NORMAL
- en: It's also worth noting that you can store the Terraform state file in a remote
    location. This can be configured to "lock" when in use (to avoid conflicting changes
    from two users trying to access the state file at once.) It also means the state
    file doesn't live on your local machine, or a Jenkins slave, making distributed
    building easier.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding `terraform` directory contains the actual plugin that we downloaded
    when we initialized the repository.
  prefs: []
  type: TYPE_NORMAL
- en: On to Packer!
  prefs: []
  type: TYPE_NORMAL
- en: 'With Packer, things are a little different. First, we set up this configuration
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: It's a very vanilla example, but it serves its purpose.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing you might notice is that it's JSON formatted, rather than using
    HCL (as Terraform does for its configuration). Secondly, you might note that while
    we have a builder configured (docker), we also have a provisioner (shell).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: Starting with the builder, you can see that we're using `docker` as the type
    so that Packer knows what builder this is, and we're also using the `nginx` image
    we used previously as the base.
  prefs: []
  type: TYPE_NORMAL
- en: 'We apply some metadata changes in the form of a label and expose a different
    port to the default in the image (80). We can see these in the resulting Docker
    image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we proceed to the meat of the Packer job, the provisioning step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: This is the part in which you would make changes to the container such as here,
    where we used `shell` to `echo` a poignant statement to the screen, and then aggressively
    removed the container's sole purpose in protest.
  prefs: []
  type: TYPE_NORMAL
- en: Packer has other provisioners, such as Ansible, Chef, and Puppet, but `shell`
    is the easiest to understand and implement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, we built our image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: Packer pulled the designated image from Docker Hub and then proceeded to make
    the changes we specified to both metadata and contents, before finally packing
    up the image and storing it locally.
  prefs: []
  type: TYPE_NORMAL
- en: We could have introduced a post-processor step too, to variously tag and upload
    our new image to somewhere for safe keeping.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here''s a small but interesting titbit. Terraform has a built-in command for
    making sure that all of your syntax is nicely formatted (meaning that everyone
    can conform to the same standard, without getting into silly arguments about spacing):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: Honestly, I think this is one of the greatest things about Terraform, because
    it means that no one can have an opinion of their own, and if there's a world
    I want to live in, it's that one.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Hashicorp make a lot of stuff, and while it's important to remember that there
    are several options out there when it comes to Infrastructure as Code, it's undeniable
    to say that at the moment, if you know their suite well, you'll be seriously bolstering
    your chances of getting a job.
  prefs: []
  type: TYPE_NORMAL
- en: 'Other tools from Hashicorp include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Vagrant, as we know and love
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vault, for secret storage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consul, for service discovery
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Roundup - Git, Configuration Management, and Infrastructure as Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is not a book on Ansible, and while I'm tempted to write one, there are
    already a considerable number out there (though truth be told, Ansible is so fast
    paced that you're better off learning as you go, and I don't usually advocate
    that). That said, I do like Ansible, and, along with the other tools listed in
    this chapter (Git, Terraform, Packer), it has made my life so much easier over
    the last couple of years that I've been using it.
  prefs: []
  type: TYPE_NORMAL
- en: There's something to be said for the idea that administrators are lazy, because
    all we really want to do is make our jobs easier, by automating away the tedious
    bits. We all used to joke that we'd end up automating ourselves out of a job one
    day, but some of the less lazy in our clan didn't like that idea, and seemingly
    decided that they were going to develop a new thing on an almost monthly basis,
    just so we could pick up the thing and decide we desperately needed to use it
    in our infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: Git is magical making our needs around source control and distribution seamless
    (except when you forget how to recover from the complete mess you've got yourself
    in, and decide it's easier to just delete the directory and clone it again).
  prefs: []
  type: TYPE_NORMAL
- en: Ansible is a savior, meaning that we no longer have to call up long-retired
    graybeards in the early hours of the morning just to find out how the heck they
    managed to get half of that old snowflake server running in RAM, and the rest
    seemingly pulling itself in from a network drive.
  prefs: []
  type: TYPE_NORMAL
- en: 'Don''t assume that just because somewhere uses Ansible, and they claim to be
    fully automated, that they don''t have one server kicking around somewhere that
    no one wants to touch because it does something silly like handle the IVR for
    the phone server. In these cases, you can do one of two things. Either option
    A: offer to automate the old and crusty snowflake, bringing it in line with the
    rest of the infrastructure; or option B: stick your head in the sand like everyone
    else, and hope it doesn''t break while you''re on shift (though it will... it
    will...).'
  prefs: []
  type: TYPE_NORMAL
- en: Terraform is a headache in code form, though for all of the grievances users
    occasionally have with it, there's no denying that in a cloud-orientated world,
    having a tool that can automatically provision hundreds of boxes in your Azure
    subscription is a must, and if it means that you don't have to learn PowerShell—so
    much the better. It is worth saying, though, that I have a friend who insists
    Terraform isn't ready yet, and, as a result, he wraps the generation of Terraform
    files in an Ansible role... don't ask.
  prefs: []
  type: TYPE_NORMAL
- en: Packer removes tedium and ensures that your Ansible playbooks don't take an
    age to apply because you've done the sensible thing and incorporated all your
    sane defaults into a base image (hint, hint!).
  prefs: []
  type: TYPE_NORMAL
- en: To round off this chapter, let's talk about the age of the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: All the tools we've mentioned are great in an ephemeral world, where servers
    can spin up for a few minutes, complete their purpose in life, and then be unceremoniously
    removed from existence by an omnipotent cronjob. They do have their drawbacks,
    though, and it's important to be careful when using tools such as Terraform to
    manage an estate.
  prefs: []
  type: TYPE_NORMAL
- en: There's a reason why Terraform prompts you with an effective "are you really
    sure" message before it'll let you delete infrastructure. I would always advise
    being one hundred percent confident in what you're about to do, before you do
    it. You don't want to be the one responsible for destroying production (make sure
    you have good backups).
  prefs: []
  type: TYPE_NORMAL
- en: In the old days, when I accidentally turned off a server because I got it confused
    with a different server of a similar name, and it was down for twelve hours before
    anyone noticed, the ramifications were minimal. I could simply turn the box back
    on while apologising profusely to the client.
  prefs: []
  type: TYPE_NORMAL
- en: Now, if you accidentally run `terraform destroy` against prod, and it also takes
    the data with it, you've done more than just flipped the boxes off. They're gone,
    kaput, Avada Kedavra'd, so be careful. We have these tools to make our lives easier,
    but sometimes I wonder if we're not also giving ourselves the capability for so
    much more accidental destruction.
  prefs: []
  type: TYPE_NORMAL
- en: That story about me turning off a box may or may not be true......it's true.
  prefs: []
  type: TYPE_NORMAL
