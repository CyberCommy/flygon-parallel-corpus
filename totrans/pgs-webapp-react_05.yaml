- en: Routing with React
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"We''ve expanded the feature list."'
  prefs: []
  type: TYPE_NORMAL
- en: You suppress a groan and wait.
  prefs: []
  type: TYPE_NORMAL
- en: '"We want to give our users everything. Everything they need, everything they
    want, everything they could possibly ever desire."'
  prefs: []
  type: TYPE_NORMAL
- en: '"Okay," you say. "But this is a prototype…"'
  prefs: []
  type: TYPE_NORMAL
- en: '"A page for analytics, a page for their profile, a page for their friend''s
    analytics, a page for taking notes, a page for the weather."'
  prefs: []
  type: TYPE_NORMAL
- en: You quietly show yourself out, repeating under your breath, "It's a prototype."
  prefs: []
  type: TYPE_NORMAL
- en: The plan
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've now arrived at the point where our application is technically working
    (in that we allow users to log in) but is lacking in real, useful content. It's
    time to change that.
  prefs: []
  type: TYPE_NORMAL
- en: To do so, however, we need to add additional pages to our application. Some
    of you may have heard the term **Single-Page Application** (**SPA**), which is
    used to refer to React apps and therefore may be confused by this talk of more
    pages. We'll cover that distinction as we move further on, and then move into
    our actual routing setup using React Router.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s what we''ll learn:'
  prefs: []
  type: TYPE_NORMAL
- en: How to install and use React Router v4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to add additional routes to additional components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to move between routes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pages on pages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Luckily, saner heads prevail and the head product designer (the highest ranked
    of the five designers now employed by the company) says that they need only three
    views for the prototype: the login view (done!), the main chat view, and the user
    profile view.'
  prefs: []
  type: TYPE_NORMAL
- en: Still, we clearly need a robust and extensible way to move between different
    screens in our app. We need a good solid routing solution.
  prefs: []
  type: TYPE_NORMAL
- en: Traditionally, routing has been a question of which HTML/CSS/JavaScript files
    are served up. You hit the URL at [static-site.com](http://static-site.com) and
    get the main `index.html`, then go to [static-site.com/resources](http://static-site.com/resources)
    and get the `resources.html`.
  prefs: []
  type: TYPE_NORMAL
- en: In this model, the server gets a request for a certain URL and returns the appropriate
    files.
  prefs: []
  type: TYPE_NORMAL
- en: Increasingly, however, routing is moving to the client side. In a React world,
    we only ever serve up our `index.html` and `bundle.js`. Our JavaScript takes in
    the URL from the browser and then decides what JSX to render.
  prefs: []
  type: TYPE_NORMAL
- en: Hence the term Single-Page App--our user technically only ever sits on one page
    (if we look at it from the traditional model). However, they're able to navigate
    between other views, and do so in a much more streamlined way, without having
    to request more files from the server.
  prefs: []
  type: TYPE_NORMAL
- en: Our top-level container component (`App.js`) will always be rendered, but what
    changes is what is rendered inside it.
  prefs: []
  type: TYPE_NORMAL
- en: The React Router difference
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For some React routing solutions, the model will look something like the following.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will render our initial screen, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This will fit with the URL of `chatastrophe.com/login`. When the user completes
    the login, we will send them to `chatastrophe.com/chat`. At that point, we will
    call `ReactDOM.render` with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: React's reconciliation engine will then compare the old app with the new app
    and swap out the components that have changes; in this case, it will swap `LoginContainer`
    for `ChatContainer`, without rerendering `App`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a very simple example of what that may look like, using a basic routing
    solution called `page.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This solution works fine. We're able to navigate between multiple views, and
    React's reconciliation ensures that there's no wasteful rerendering of unchanged
    components.
  prefs: []
  type: TYPE_NORMAL
- en: However, this solution is not very React-y. We're passing our entire application
    to `ReactDOM.render` each time we change the page, which leads to lots of repeated
    code in our `router.js` file. We're defining multiple versions of our application,
    rather than choosing precisely which components should render at which time.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, this solution imposes a holistic approach to routing, rather
    than one split up by components.
  prefs: []
  type: TYPE_NORMAL
- en: Enter `React Router v4`, a complete rewrite of the library, which used to be
    a more traditional routing solution. The difference is that routes are now components
    that render based on the URL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s talk about what that means exactly by rewriting our earlier example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now, we only call `ReactDOM.render` once. We render our application, and within
    it, render two `Route` components wrapping our two containers.
  prefs: []
  type: TYPE_NORMAL
- en: Each `Route` takes a `path` prop. If the URL in the browser matches that `path`,
    the `Route` will render its child component (the container); otherwise, it will
    render nothing.
  prefs: []
  type: TYPE_NORMAL
- en: We never try to rerender our `App`. As it should be, it stays static. Furthermore,
    our routing solution is no longer kept separate from our components in a `router.js`
    file. Now, it lives within our components.
  prefs: []
  type: TYPE_NORMAL
- en: We can also nest our routes further within our components. Inside `LoginContainer`,
    we can add two routes--one for `/login`, and one for `/login/new`--if we wanted
    to have separate login and signup views.
  prefs: []
  type: TYPE_NORMAL
- en: In this model, every component can make a decision about what to render, based
    on the current URL.
  prefs: []
  type: TYPE_NORMAL
- en: I'll be honest, this approach is a bit weird to get used to, and I did not like
    it one bit when I started using it. For experienced developers, it requires thinking
    about your routing in a different way, rather than as a top-down, whole-page decision
    about what to render, you're now encouraged to make decisions at a component level,
    which can be difficult.
  prefs: []
  type: TYPE_NORMAL
- en: After some time working with it, however, I think this paradigm is exactly what's
    needed for a React approach to routing, and will give developers far more flexibility
    down the line.
  prefs: []
  type: TYPE_NORMAL
- en: Okay, enough talk. Let's create our second view--the chat screen--where users
    can view and send messages to everyone in the world at once ("global interconnectivity",
    you know). First, we'll create a basic component, and then we can get started
    with our routing solution.
  prefs: []
  type: TYPE_NORMAL
- en: Our ChatContainer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating a component should be old news by now. Our `ChatContainer` will be
    a class-based component, since we’ll need to tap into some lifecycle methods down
    the line (more on that later).
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside our `components` folder, create a file called `ChatContainer.js`. Then,
    set up our skeleton:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s continue our pattern of wrapping our component in a `div` with an `id`
    of the component name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Just as at the top of our `LoginContainer`, we will want to render our beautiful
    logo and title for our user to see. If only we had some sort of reuseable component
    so that we didn''t have to rewrite that code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This is beautiful. Okay, let's just add `<h1>Hello from ChatContainer</h1>`
    after the `Header` and move on to routing so that we can actually see what we're
    doing as we work. Right now, our `ChatContainer` isn't visible. To change that,
    we need to set up React Router.
  prefs: []
  type: TYPE_NORMAL
- en: Installing React Router
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start with the basics. Run the following in the Terminal from the project
    root.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `react-router-dom` contains all the React components we could want for routing
    our user through our application. You can view the full documentation for it at
    [https://reacttraining.com/react-router](https://reacttraining.com/react-router).
    The only components we’ll be interested in, however, are `Route` and `BrowserRouter`.
  prefs: []
  type: TYPE_NORMAL
- en: It's important to ensure that you install `react-router-dom` and not `react-router`.
    Since version 4 was released, the package has been split into various branches.
    `React-router-dom` is specifically geared towards providing routing components,
    which is what we’re interested in. Note that it installed `react-router` as a
    peer dependency, though.
  prefs: []
  type: TYPE_NORMAL
- en: The `Route` component is rather simple; it takes a prop called `path`, which
    is a string such as `/` or `/login`. When the URL in the browser matches that
    string ([http://chatastrophe.com/login](http://chatastrophe.com/login)), the `Route`
    component renders the component, which is passed in via the `component` prop;
    otherwise, it renders nothing.
  prefs: []
  type: TYPE_NORMAL
- en: As with anything in web development, there's a lot of additional complexity
    to how you can use the `Route` component. We'll dive into it a bit more later
    on. For now, however, we only want to conditionally render either `ChatContainer`
    or `LoginContainer`, based on whether our path is `/` or `/login`.
  prefs: []
  type: TYPE_NORMAL
- en: '`BrowserRouter` is more complicated, but for our purposes, it will be simple
    to use. Essentially, it ensures that our `Route` components are kept in sync (either
    rendering or not rendering) with the URL. It uses the HTML5 history API to do
    so.'
  prefs: []
  type: TYPE_NORMAL
- en: Our BrowserRouter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first thing we need to do is wrap our entire application in the `BrowserRouter`
    component, then we can add our `Route` components.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we want to have our router around our entire application, the easiest
    place to add it is in our `src/index.js`. At the top, we require the following
    component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we render our `App` as a child of `BrowserRouter`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'You should also do the same inside our hot re-loader configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Done! Now we can actually start adding routes.
  prefs: []
  type: TYPE_NORMAL
- en: Our first two Routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Inside our `App` component, we currently render `LoginContainer`, no matter
    what:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We want to change this logic so that we render either `LoginContainer` only
    or we render `ChatContainer`. To do that, let's require it in our `ChatContainer`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll also require our `Route` component from `react-router-dom`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: I put the `Route` import above the two `Container` imports. Best practices say
    you should put absolute imports (imports from `node_modules`) before relative
    imports (files imported from within `src`). This keeps things clean.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can replace our containers with `Route` components that take a `component`
    prop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We pass in our component prop as `LoginContainer`, and not as `<LoginContainer
    />`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our app reloads and we see… a mess:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00033.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We're currently rendering both containers at once! Oops. The problem is that
    we failed to give our `Route` a `path` prop that tells them when to render (and
    when not to). Let's do that now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our first `Route`, the `LoginContainer`, is to be rendered when we''re at the
    `/login` route, so we add a path as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Our other container, `ChatContainer`, will be shown when the user is at the
    root, "`/`" (at `localhost:8080/` currently, or [https://chatastrophe-77bac.firebaseapp.com/](https://chatastrophe-77bac.firebaseapp.com/)
    for our deployed app), so we add a path as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Save, check the app, and you get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00034.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Nice! Our `LoginContainer` no longer renders. Let''s head over to `/login`
    and ensure that we only see our `LoginContainer` there:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00033.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Augh!
  prefs: []
  type: TYPE_NORMAL
- en: We're rendering both containers at `/login`. What happened?
  prefs: []
  type: TYPE_NORMAL
- en: Well, long story short, React Router uses a **RegEx** pattern to match routes
    and determine what to render. Our current path (`/login`) matches the prop passed
    to our login `Route`, but it also technically matches `/`. In fact, everything
    matches `/`, which is great if you have a component you want to render on every
    page, but we want our `ChatContainer` to only render when the path is `/` (with
    nothing else).
  prefs: []
  type: TYPE_NORMAL
- en: In other words, we want to render the `ChatContainer` route when the path is
    an exact match for `/`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The good news is that React Router is prepared for this problem; simply add
    a prop `exact` to our `Route`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding is the same as writing:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<Route exact={true} path="/" component={ChatContainer} />`'
  prefs: []
  type: TYPE_NORMAL
- en: When we check `/login`, we should only see our `LoginContainer`. Great! We have
    our first two routes.
  prefs: []
  type: TYPE_NORMAL
- en: The next thing we want to do is add a bit of forced routing; when the user logs
    in, we want to redirect them to the main chat screen. Let's do it!
  prefs: []
  type: TYPE_NORMAL
- en: Redirecting on login
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here, things will get a bit more tricky. First, we'll do some preparation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside our `LoginContainer`, when it comes to our `signup` and `login` methods,
    we currently just `console.log` out the result in our `then` statement. In other
    words, we don''t actually do anything once our user logs in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s change this bit (in both `signup` and `login`) to call another method,
    `onLogin`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can define our `onLogin` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: So, how do we redirect to the root path?
  prefs: []
  type: TYPE_NORMAL
- en: We know that our `Route` components will render based on the URL in the browser.
    We can be confident that if we modify the URL correctly, our app will rerender
    to display the appropriate component. The trick is to modify that URL from within
    `LoginContainer`.
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned earlier, React Router uses the HTML5 history API to move between
    URLs. In this model, there's an object called `history` with certain methods that
    allow you to push a new URL into the current state of the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, if we''re at `/login`, and want to go to `/`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'React Router lets us interact with the HTML5 history object in a more streamlined
    way (avoiding the null arguments, for example). The way it does so is simple:
    every component passed to a `Route` (via the `component` prop) receives another
    prop called `history`, which has a method called `push`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If that sounds confusing, don''t worry, it''ll all be clear in a moment. All
    we have to do is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Try it out by going to `/login` and logging in. You'll be redirected to the
    `ChatContainer`. Magic!
  prefs: []
  type: TYPE_NORMAL
- en: 'What''s happening is the `history` prop, when `push` is called, is updating
    the browser''s URL, which then causes our `Route` components to render their component
    (or render nothing):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that this is a rather revolutionary way of navigating around a website.
    Previously, it was much different:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Welcome to the world of routing single-page applications. Feels good, doesn't
    it?
  prefs: []
  type: TYPE_NORMAL
- en: Logging out
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Okay, we've handled our user logging in, but what about when they want to log
    out?
  prefs: []
  type: TYPE_NORMAL
- en: Let's build them a button at the top of `ChatContainer` to allow them to log
    out. It'll fit best in the `Header` component, so why don't we build it in there?
  prefs: []
  type: TYPE_NORMAL
- en: Well, hold up. We currently use the `Header` on our `/login` path, in the `LoginContainer`.
    If we add a `Logout` button, it'll appear on the sign-in screen as well, which
    is just confusing. We need a way to only render the `Logout` button on the `ChatContainer`.
  prefs: []
  type: TYPE_NORMAL
- en: We can take advantage of the `Route history` prop and use that to do a conditional
    rendering of the Logout button based on the URL (if the path is "`/`", render
    the button, otherwise don't!). However, that can be messy and hard to understand
    for future developers as we add more routes. Let's make it super explicit when
    we want the Logout button to appear.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, we want to render the Logout button inside `Header`, but only
    when `Header` is inside `ChatContainer`. Does this make sense?
  prefs: []
  type: TYPE_NORMAL
- en: 'The way to do so is with React children. Children are actually super easy to
    understand, if you look at it from an HTML standpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '`h1` is the child of `div`. In the case of a React component the `Parent` component
    will receive a prop called `children`, which equals the `h1` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'To render that within `Parent`, we just do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Let's see this in action and, hopefully, it'll make much more sense (and give
    you an idea of its power).
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside `ChatContainer`, let''s replace our `<Header />` tag with an opening
    and closing tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside that, we''ll define our button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Check our page and we see that nothing has changed. This is because we haven't
    told `Header` to actually render its `children`. Let's hop over to `Header.js`
    and change that.
  prefs: []
  type: TYPE_NORMAL
- en: 'Underneath our `h1`, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'What are we doing here? First, we''re defining `props` as our argument to our
    functional component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: All functional React components receive the `props` object as their first argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, within that object, we''re accessing the `children` property, which is
    equal to our button. Now, our `Logout` button should appear:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00035.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Awesome! If you check the `/login` path, you'll notice that our button does
    not appear. That's because in `LoginContainer`, `Header` has no `children`, so
    nothing is rendered.
  prefs: []
  type: TYPE_NORMAL
- en: Children make React components super composable and extra reuseable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, let''s make our button actually work. We want to call a method called
    `firebase.auth().signOut`. Let''s make a click handler for our button that calls
    this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Now, when we press the button, nothing happens, but we are being logged out.
    We're missing one last piece of the login puzzle.
  prefs: []
  type: TYPE_NORMAL
- en: 'When our user logs out, we want to redirect them to the login screen. If only
    we had some way of telling the status of Firebase''s authorization:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00036.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This is perfect. After we click on the logout button, when our user logs out,
    Firebase will call `firebase.auth().onAuthStateChanged` with a null argument for
    the user.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, we already have everything we need; we just need to add an `else`
    to our `if` statement to cover situations where there is no user found.
  prefs: []
  type: TYPE_NORMAL
- en: 'The flow will go like this:'
  prefs: []
  type: TYPE_NORMAL
- en: When the user clicks on the logout button, Firebase will log them out.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It will then call the `onAuthStateChanged` method with a null argument.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If `onAuthStateChanged` is called with a null user, we will redirect the user
    to the login page using the `history` prop.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's put this in place by jumping over to `App.js`.
  prefs: []
  type: TYPE_NORMAL
- en: Our `App` isn't the child of a `Route`, so it doesn't get access to the `history`
    prop that we used in `LoginContainer`, but there's a little workaround we can
    use.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top of `App.js`, add the following to our `react-router-dom` import:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, at the bottom, replace our `export default` statement with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: What's happening here? Essentially, `withRouter` is a function that takes a
    component as an argument and returns that component exactly as it was, except
    that now it has access to the `history` prop. We'll cover more on that as we move
    on, but let's finish this logout flow first.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, we can fill out `componentDidMount`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Try logging in again and hitting the logout button. You should be taken directly
    to the login screen. Magic!
  prefs: []
  type: TYPE_NORMAL
- en: Detour - higher order components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the preceding code, we used the `withRouter` function (imported from `react-router-dom`)
    to give our `App` component access to the `history` prop. Let's take a moment
    to talk about how that worked, since it's one of the most powerful React patterns
    you can learn.
  prefs: []
  type: TYPE_NORMAL
- en: '`withRouter` is an example of a **Higher Order Component** (**HOC**). This
    slightly grandiose name is better than my favorite explanation: *Functions That
    Build Functions* (thanks to *Tom Coleman* for that one). Let''s see an example.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say that you had a `Button` component, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, let''s say that we had a situation where we wanted it to have white text
    and a red background:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: As your app evolves, you're finding that you're using this particular styling
    a lot with this button. You need a lot of red buttons, with different text, and
    it's getting tiresome to type out `backgroundColor` every time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Not only that; you also have another component, an alert box, with the same
    styles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, you have two options. You want two new components (`RedAlertBox` and
    `RedButton`), which you can use everywhere. You can define them as illustrated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'And:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: However, there's a simpler, more composable way, and that's to make a Higher
    Order Component.
  prefs: []
  type: TYPE_NORMAL
- en: What we want to achieve is a way to take a component and give it the red-on-white
    styling. That's it. We want to inject those props into any given component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the end result, and then what our HOC will look like. If we
    successfully make a HOC called `makeRed`, we can use it, as follows, to create
    our `RedButton` and `RedAlertBox`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This is much easier, and much more reuseable. We can now reuse `makeRed` to
    convert any component into a nice red background and white text. That's power.
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, so how do we create a `makeRed` function? We want to take a component
    as an argument, and return that component with all its assigned props and the
    correct style prop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the same code, with comments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The most confusing thing will likely be the spread operator of `{...props}`.
    The spread operator is a useful yet confusing ES6 tool. It allows you to take
    an object (here, the `props` object) and apply all its keys and values to a new
    object (the component):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Higher order components are a next-level tool to make your React components
    easier to reuse. We've only scratched their surface here. For more information,
    check out *Understanding Higher Order Components* by *Tom Coleman*, at [https://medium.freecodecamp.org/understanding-higher-order-components-6ce359d761b](https://medium.freecodecamp.org/understanding-higher-order-components-6ce359d761b).
  prefs: []
  type: TYPE_NORMAL
- en: Our third Route
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As discussed at the beginning of this chapter, the Chatastrophe team is set
    on having a user profile view. Let's do the skeleton and basic routing for that.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `src/components`, make a new file called `UserContainer.js`. Inside, do
    the basic component skeleton:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Back in `App.js`, let’s import our new container and add the `Route` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Hold on! The preceding code creates a route at `/users` for our `UserContainer`,
    but we don't have just one user view. We have a user view for every user of our
    application. We need to have a route for User 1 at `chatastrophe.com/users/1`,
    and for User 2 at `chatastrophe.com/users/2`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need some way to pass a variable value to our `path` prop, equal to the
    user `id`. Fortunately, it''s easy to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The best part? Now, in our `UserContainer`, we''ll receive a `props.params.match`
    object, equal to `{ id: 1 }` or whatever the `id` is, which we can then use to
    fetch that user''s messages.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s test that by changing our `h1` in `UserContainer.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, head to `localhost:8080/users/1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00037.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you run into problems with finding `bundle.js` when in a nested route, ensure
    that your output inside your `webpack.config.js` looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Beautiful. Now, there's one last step. Let's add a way for the user to return
    to the main chat screen from the `UserContainer`.
  prefs: []
  type: TYPE_NORMAL
- en: We can do so in a really easy way by taking advantage of the `Header` children
    again; only, in this case, we can add in another React Router component to make
    our lives super easy. It's called `Link`, and it's just like a tag in HTML, but
    is optimized for React Router.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `UserContainer.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '![](../images/00038.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: When you click on the button, you should be taken to the root route of `/`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: That's it! We covered a lot in this chapter in order to get our application's
    routing solution up and running. If anything is confusing, I invite you to take
    a look at the React Router docs at [https://reacttraining.com/react-router/](https://reacttraining.com/react-router/).
    Next, we'll go much, much deeper into React, as we finish up our basic application,
    and then start converting it into a Progressive Web App.
  prefs: []
  type: TYPE_NORMAL
