- en: '*Chapter 9*: Troubleshooting Ansible'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ansible is beautifully simple, yet incredibly powerful. The simplicity of Ansible
    means that its operation is easy to understand and follow. However, even with
    the simplest and most user-friendly of systems, things do go wrong from time to
    time—perhaps as we are learning to write our own code (playbooks, roles, modules,
    or otherwise) and need to debug it, or, more rarely, when we might have found
    a bug in a released version of a collection or `ansible-core`.
  prefs: []
  type: TYPE_NORMAL
- en: Being able to understand and follow the operation of Ansible is critically important
    when debugging unexpected behavior, wherever it may arise. Ansible provides a
    number of options and tools to help you troubleshoot the operation of its core
    components, as well as your own playbook code. We will explore these in detail
    in this chapter, with the goal of empowering you to troubleshoot your own Ansible
    work with confidence.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, in this chapter, we will look at the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Playbook logging and verbosity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variable introspection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging code execution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To follow the examples presented in this chapter, you will need a Linux machine
    running **Ansible 4.3** or a newer version. Almost any flavor of Linux should
    do—for those interested in specifics, all the code presented in this chapter was
    tested on Ubuntu Server 20.04 **Long-Term Support** (**LTS**) unless stated otherwise,
    and on Ansible 4.3\. The example code that accompanies this chapter can be downloaded
    from GitHub at this link: [https://github.com/PacktPublishing/Mastering-Ansible-Fourth-Edition/tree/main/Chapter09](https://github.com/PacktPublishing/Mastering-Ansible-Fourth-Edition/tree/main/Chapter09).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the Code in Action: [https://bit.ly/2Xx46Ym](https://bit.ly/2Xx46Ym)'
  prefs: []
  type: TYPE_NORMAL
- en: Playbook logging and verbosity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Increasing the verbosity of Ansible output can solve many problems. From invalid module arguments
    to incorrect connection commands, increased verbosity can be critical in pinpointing
    the source of an error. Playbook logging and verbosity were briefly discussed
    in [*Chapter 3*](B17462_03_Final_JC_ePub.xhtml#_idTextAnchor061), *Protecting
    Your Secrets with Ansible*, with regard to protecting secret values while executing
    playbooks. This section will cover verbosity and logging in further detail.
  prefs: []
  type: TYPE_NORMAL
- en: Verbosity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When executing playbooks with `ansible-playbook`, the output is displayed on
    **standard output** (**stdout**). With the default level of verbosity, very little
    information is displayed. As a play is executed, `ansible-playbook` will print
    a **play** header with the name of the play. Then, for each task, a **task** header
    is printed with the name of the task. As each host executes the task, the name
    of the host is displayed along with the task state, which can be `ok`, `fatal`,
    or `changed`. No further information about the task is displayed—such as the module being
    executed, the arguments provided to the module, or the return data from the execution.
    While this is fine for well-established playbooks, I tend to want a little more
    information about my plays. In a few of the earlier examples in this book, we
    used higher levels of verbosity, up to a level of two (`-vv`), so that we could
    see the location of the task and return data. There are five total levels of verbosity,
    as outlined here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**None**: The default level'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**One** (`-v`): Where the return data and conditional information is displayed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Two** (`-vv`): For task location and handler notification information'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Three** (`-vvv`): Provides details of the connection attempts and task invocation
    information'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Four** (`-vvvv`): Passes along extra verbosity options to the connection
    plugins (such as passing `-vvv` to the `ssh` commands)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Increasing the verbosity can help pinpoint where errors might be occurring,
    as well as providing extra insight into how Ansible is performing its operations.
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned in [*Chapter 3*](B17462_03_Final_JC_ePub.xhtml#_idTextAnchor061), *Protecting
    Your Secrets with Ansible*, verbosity beyond level one can leak sensitive data
    to standard out and log files, so care should be taken when using increased verbosity
    in a potentially shared environment.
  prefs: []
  type: TYPE_NORMAL
- en: Logging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While the default is for `ansible-playbook` to log to stdout, the amount of
    output may be greater than the buffer of the terminal emulator being used; therefore,
    it may be necessary to save all the output to a file. While various shells provide
    some mechanism to redirect output, a more elegant solution is to direct `ansible-playbook` to
    log to a file. This is accomplished by way of either a `log_path` definition in
    the `ansible.cfg` file or by setting `ANSIBLE_LOG_PATH` as an environment variable.
    The value of either should be the path to a file. If the path does not exist,
    Ansible will attempt to create a file. If the file does exist, Ansible will append
    to the file, allowing consolidation of multiple `ansible-playbook` execution logs.
  prefs: []
  type: TYPE_NORMAL
- en: The use of a log file is not mutually exclusive with logging to stdout. Both
    can happen at the same time, and the verbosity level that's provided has an effect
    on both, simultaneously. Logging is of course helpful, but it doesn't necessarily
    tell us what's going on in our code, and what our variables might contain. We'll
    look at how to perform variable introspection in the next section to help you
    with this very task.
  prefs: []
  type: TYPE_NORMAL
- en: Variable introspection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A common set of problems that are encountered when developing Ansible playbooks is
    the improper use, or invalid assumption, of the value of variables. This is particularly
    common when registering the results of one task in a variable, and later using
    that variable in a task or template. If the desired element of the result is not
    accessed properly, the end result will be unexpected, or perhaps even harmful.
  prefs: []
  type: TYPE_NORMAL
- en: 'To troubleshoot improper variable usage, an inspection of the variable value
    is the key. The easiest way to inspect a variable''s value is with the `ansible.builtin.debug`
    module. The `ansible.builtin.debug` module allows the display of freeform text
    on screen, and as with other tasks, the arguments to the module can take advantage
    of the Jinja2 template syntax as well. Let''s demonstrate this usage by creating
    a sample play that executes a task, registers the result, and then shows the result
    in an `ansible.builtin.debug` statement using Jinja2 syntax to render the variable,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We will run this play with level one verbosity using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Assuming the website we''re testing against is accessible, we''ll see a displayed
    value for `derpops`, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1 – Using level one verbosity to examine registered variable values'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_09_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.1 – Using level one verbosity to examine registered variable values
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ansible.builtin.debug` module has a different option that may be useful
    as well. Instead of printing a freeform string to debug template usage, the module
    can simply print the value of any variable. This is done using the `var` argument
    instead of the `msg` argument. Let''s repeat our example, but this time we''ll
    use the `var` argument, and we''ll access just the `server` subelement of the `derpops` variable,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this modified play with the same level of verbosity as before will
    show just the `server` portion of the `derpops` variable, as demonstrated in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.2 – Using the var parameter of the debug module to inspect variable
    subelements'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_09_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.2 – Using the var parameter of the debug module to inspect variable
    subelements
  prefs: []
  type: TYPE_NORMAL
- en: In our example that used the `msg` argument to `ansible.builtin.debug`, the
    variable needed to be expressed inside curly brackets, but when using `var`, it
    did not. This is because `msg` expects a string, and so Ansible needs to render
    the variable as a string via the template engine. However, `var` expects a single
    unrendered variable.
  prefs: []
  type: TYPE_NORMAL
- en: Variable subelements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another frequent mistake in playbooks is to improperly reference a subelement
    of a complex variable. A complex variable is more than simply a string—it is either
    a list or a hash. Often, the wrong subelement will be referenced, or the element
    will be improperly referenced, expecting a different type.
  prefs: []
  type: TYPE_NORMAL
- en: While lists are fairly easy to work with, hashes present some unique challenges.
    A hash is an unordered key-value set of potentially mixed types, which could also
    be nested. A hash can have one element that is a single string, while another
    element can be a list of strings, and a third element can be another hash with
    further elements inside it. Knowing how to properly access the right subelement
    is critical to success.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s modify our previous play a bit more. This time, we''ll
    allow Ansible to gather facts, and then we''ll show the value of `ansible_python`.
    Here''s the code we''ll need:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Run this code with level one verbosity, and you should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.3 – Inspecting the ansible_python fact subelement using ansible.builtin.debug'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_09_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.3 – Inspecting the ansible_python fact subelement using ansible.builtin.debug
  prefs: []
  type: TYPE_NORMAL
- en: Using `ansible.builtin.debug` to display an entire complex variable is a great
    way to learn all the names of the subelements.
  prefs: []
  type: TYPE_NORMAL
- en: 'This variable has elements that are strings, along with elements that are lists
    of strings. Let''s access the last item in the list of flags, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.4 – Inspecting the ansible_python fact subelement further'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_09_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.4 – Inspecting the ansible_python fact subelement further
  prefs: []
  type: TYPE_NORMAL
- en: Because `ansible_python.version_info` is a list, we can use the **list index
    method** to select a specific item from the list. In this case, `-1` will give
    us the very last item in the list.
  prefs: []
  type: TYPE_NORMAL
- en: Subelements versus the Python object method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A less common but confusing gotcha comes from a quirk of the Jinja2 syntax.
    Complex variables within Ansible playbooks and templates can be referenced in
    two ways. The first style is to reference the base element by the name, followed
    by a bracket, and the subelement within quotes inside the brackets. This is the **standard
    subscript syntax**. For example, to access the `herp` subelement of the `derp`
    variable, we will use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The second style is a convenience method that Jinja2 provides, which is to
    use a period to separate the elements. This is called **dot notation**, and it
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'There is a subtle difference in how these styles work, and it has to do with
    Python objects and object methods. As Jinja2 is, at its heart, a Python utility,
    variables in Jinja2 have access to their native Python methods. A string variable
    has access to Python string methods, a list has access to list methods, and a
    dictionary has access to dictionary methods. When using the first style, Jinja2
    will first search the element for a subelement of the provided name. If no subelements
    are found, Jinja2 will then attempt to access a Python method of the provided
    name. However, the order is reversed when using the second style; first, a Python
    object method is searched for, and if not found, then a subelement is searched
    for. This difference matters when there is a name collision between a subelement
    and a method. Imagine a variable named `derp`, which is a complex variable. This
    variable has a subelement named `keys`. Using each style to access the `keys` element
    will result in different values. Let''s build a playbook to demonstrate this,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'When running this play, we can clearly see the difference between the two styles.
    The first style successfully references the `keys` subelement, while the second
    style references the `keys` method of Python dictionaries, as the following screenshot
    illustrates:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.5 – Demonstrating the difference between standard subscript syntax
    and dot notation when name collision occurs'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_09_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.5 – Demonstrating the difference between standard subscript syntax
    and dot notation when name collision occurs
  prefs: []
  type: TYPE_NORMAL
- en: Generally, it's best to avoid using subelement names that conflict with Python
    object methods. However, if that's not possible, the next best thing to do is
    to be aware of the difference in subelement reference styles and choose the appropriate
    one.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, variables are only one aspect of playbook behavior—sometimes, we
    need to actually get into debugging the code itself, and we'll look at just that
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging code execution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, the logging and inspection of variable data are not enough to troubleshoot
    a problem. When this happens, it can be necessary to interactively debug the playbook,
    or to dig deeper into the internals of Ansible code. There are two main sets of
    Ansible code: code that runs locally on the Ansible host, and module code that
    runs remotely on the target host.'
  prefs: []
  type: TYPE_NORMAL
- en: Playbook debugging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Playbooks can be interactively debugged by using an execution strategy that
    was introduced in Ansible 2.1, **the debug strategy**. If a play uses this strategy
    when an error state is encountered, an interactive debugging session starts. This
    interactive session can be used to display variable data, display task arguments,
    update task arguments, update variables, redo task execution, continue execution,
    or exit the debugger.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s demonstrate this with a play that has a successful task, followed by
    a task with an error, followed by a final successful task. We''ll reuse the playbook
    we''ve been using, but update it a bit, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Upon execution, Ansible will encounter an error in our failing task and present
    the (debug) prompt, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.6 – The Ansible debugger starting during a failed task execution
    (when execution strategy is debug)'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_09_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.6 – The Ansible debugger starting during a failed task execution (when
    execution strategy is debug)
  prefs: []
  type: TYPE_NORMAL
- en: 'From this prompt, we can display the task and the arguments to the task by
    using the `p` command, as the following screenshot shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.7 – Using the p command to inspect details of the failed play task'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_09_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.7 – Using the p command to inspect details of the failed play task
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also change the playbook on the fly to try different arguments or variable
    values. Let''s define the missing key of the `derp` variable, and then retry the
    execution. All of the variables are within the top-level `vars` dictionary. We
    can directly set the variable data using Python syntax and the `task_vars` command,
    and then retry with the `r` command, as illustrated in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.8 – Adding previously undefined variable values and retrying the
    play from the debugger'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_09_08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.8 – Adding previously undefined variable values and retrying the play
    from the debugger
  prefs: []
  type: TYPE_NORMAL
- en: The debug execution strategy is a handy tool for quickly iterating through different
    task arguments and variable combinations to figure out the correct path forward.
    However, because errors result in interactive consoles, the debug strategy is
    inappropriate for automated executions of playbooks, as there is no human on the
    console to manipulate the debugger.
  prefs: []
  type: TYPE_NORMAL
- en: Important Point
  prefs: []
  type: TYPE_NORMAL
- en: Changing data within the debugger will not save the changes to backing files.
    Always remember to update playbook files to reflect discoveries that are made
    during debugging.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging local code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The local Ansible code is the lion's share of the code that comes with Ansible.
    All the playbook, play, role, and task parsing code lives locally. All of the
    task result processing code and transport code lives locally. All of the code,
    except for the assembled module code that is transported to the remote host, lives
    locally.
  prefs: []
  type: TYPE_NORMAL
- en: 'Local Ansible code can still be broken down into three major sections: **inventory**,
    **playbook**, and **executor**. Inventory code deals with parsing inventory data
    from host files, dynamic inventory scripts, or combinations of the two, in directory
    trees. Playbook code is used to parse the playbook **YAML Ain''t Markup Language**
    (**YAML**) code into Python objects within Ansible. Executor code is the core
    **application programming interface** (**API**) and deals with forking processes,
    connecting to hosts, executing modules, handling results, and most other things.
    Learning the general area to start debugging comes with practice, but the general
    areas that are described here are a starting point.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As Ansible is written in Python, the tool for debugging local code execution
    is the `pdb` Python debugger. This tool allows us to insert breakpoints inside
    the Ansible code and interactively walk through the execution of the code, line
    by line. This is very useful for examining the internal state of Ansible as the
    local code executes. Many books and websites cover the usage of `pdb`, and these can
    be found with a simple web search for an introduction to Python `pdb`, so we will
    not repeat them here. If you are looking for a hands-on introduction to using
    `pdb`, there are lots of great examples in the book *Django 1.1 Testing and Debugging*,
    *Karen M. Tracey*, *Packt Publishing*, which will enable you to practice real-world
    debugging techniques with `pdb` in Django (which is written in Python). The official
    Python documentation also offers much in the way of information on using the debugger.
    You can view this here: https://docs.python.org/3/library/pdb.html. The basics
    are to edit the source file to be debugged, insert a new line of code to create
    a breakpoint, and then execute the code. Code execution will stop where the breakpoint
    was created, and a prompt will be provided to explore the code state.'
  prefs: []
  type: TYPE_NORMAL
- en: Of course, Ansible has lots of different components that come together to build
    up its functionality, from inventory handling code to the actual playbook execution
    engine itself. It is possible to add breakpoints and debugging to all of these
    places to help resolve issues you might be facing, though the files you need to
    edit are slightly different in each case. We'll look at the details of the most
    common aspects of the Ansible code you might need to debug in the following subsections
    of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging inventory code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Inventory code deals with finding inventory sources, reading or executing the
    discovered files, parsing the inventory data into inventory objects, and loading
    variable data for the inventory. To debug how Ansible will deal with an inventory,
    a breakpoint must be added inside `inventory/__init__.py` or one of the other
    files within the `inventory/` subdirectory. This directory will be located on
    the local filesystem wherever Ansible has been installed. As most installations
    of Ansible 4.0 will have been performed via `pip` at this time, the exact path
    of your installation will vary greatly, depending on factors such as whether you
    used a virtual environment, whether you installed Ansible in your user directory,
    or whether you used `sudo` to install Ansible system-wide. As an example, on my
    Ubuntu 20.04 test system, this file may be found in the `/usr/local/lib/python3.8/dist-packages/ansible/inventory`
    path. To help you discover where Ansible is installed, simply type `which ansible` from
    the command line. This command will show you where the Ansible executable is installed
    and may indicate a Python virtual environment. For this book, Ansible has been
    installed as root using the operating system Python distribution, with the Ansible
    binaries located in `/usr/local/bin/`.
  prefs: []
  type: TYPE_NORMAL
- en: To discover the path to the Ansible Python code, simply type `python3 -c "import
    ansible; print(ansible)"`. Note that, like me, you might have both Python 2 and
    Python 3 installed—if you are unsure of which version of Python Ansible is running
    under, you will need to execute both the version 2 and 3 binaries in order to
    discover your module locations.
  prefs: []
  type: TYPE_NORMAL
- en: On my system, this shows `<module 'ansible' from '/usr/local/lib/python3.8/dist-packages/ansible/__init__.py'>`,
    from which we can deduce that the inventory subdirectory is located at `/usr/local/lib/python3.8/dist-packages/ansible/inventory/`.
  prefs: []
  type: TYPE_NORMAL
- en: The inventory directory was restructured in later releases of Ansible, and in
    version 4.0, we need to look in `inventory/manager.py`. Note that this file comes
    from the `ansible-core` package and not the `ansible` package that depends upon
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Within this file, there is a class definition for the `Inventory` class. This
    is the inventory object that will be used throughout a playbook run, and it is
    created when `ansible-playbook` parses the options provided to it for an inventory
    source. The `__init__` method of the `Inventory` class does all the inventory
    discovery, parsing, and variable loading. To troubleshoot an issue in those three
    areas, a breakpoint should be added within the `__init__()` method. A good place
    to start would be after all of the class variables are given an initial value,
    and just before any data is processed.
  prefs: []
  type: TYPE_NORMAL
- en: In version 2.11.1 of `ansible-core`, this would be line *167* of `inventory/manager.py`,
    where the `parse_sources` function is called.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can skip down to the `parse_sources` function definition on line *215* to
    insert our breakpoint. To insert a breakpoint, we must first import the `pdb` module
    and then call the `set_trace()` function, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.9 – Adding a pdb breakpoint into the ansible-core inventory manager
    code'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_09_09.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.9 – Adding a pdb breakpoint into the ansible-core inventory manager
    code
  prefs: []
  type: TYPE_NORMAL
- en: 'To start debugging, save the source file and then execute `ansible-playbook` as
    normal. When the breakpoint is reached, the execution will stop and a `pdb` prompt will be
    displayed, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.10 – Ansible reaching a pdb breakpoint as it starts to set up the
    inventory for our play'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_09_10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.10 – Ansible reaching a pdb breakpoint as it starts to set up the inventory
    for our play
  prefs: []
  type: TYPE_NORMAL
- en: 'From here, we can issue any number of debugger commands, such as the `help` command,
    as the following screenshot shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.11 – Demonstrating the help command of the pdb debugger'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_09_11.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.11 – Demonstrating the help command of the pdb debugger
  prefs: []
  type: TYPE_NORMAL
- en: 'The `where` and `list` commands can help us determine where we are in the stack
    and where we are in the code, as illustrated in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.12 – Demonstrating the where and list pdb commands'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_09_12.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.12 – Demonstrating the where and list pdb commands
  prefs: []
  type: TYPE_NORMAL
- en: The `where` command shows us that we're in `inventory/manager.py` in the `parse_sources()`
    method. The next frame up is the same file—the `__init__()` function. Before that
    is a different file, the `playbook.py` file, and the function in that file is
    `run()`. This line calls `ansible.inventory.InventoryManager` to create an inventory
    object. Before that is the original file, `ansible-playbook`, calling `cli.run()`.
  prefs: []
  type: TYPE_NORMAL
- en: The `list` command shows the source code around our current point of execution,
    five lines before and five lines after.
  prefs: []
  type: TYPE_NORMAL
- en: 'From here, we can guide `pdb` through the function line by line with the `next` command,
    and if we choose to, we can trace into other function calls with the `step` command.
    We can also print variable data to inspect values, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.13 – Demonstrating the print command to analyze variable values
    during execution'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_09_13.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.13 – Demonstrating the print command to analyze variable values during
    execution
  prefs: []
  type: TYPE_NORMAL
- en: We can see that the `self._sources` variable has a full path of our `mastery-hosts` inventory
    file, which is the string we gave `ansible-playbook` for our inventory data. We
    can continue to walk through or jump around, or just use the `continue` command
    to run until the next breakpoint or the completion of the code.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging playbook code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Playbook code is responsible for loading, parsing, and executing playbooks.
    The main entry point for playbook handling is found by locating the Ansible path,
    just as we did in the *Debugging inventory code* section, and then locating the `playbook/__init__.py`
    file. Inside this file lives the `PlayBook` class. A good starting point for debugging
    playbook handling is around line *68* (for `ansible-core` 2.11.1), though this
    will vary depending upon the version you have installed. The following screenshot
    shows the adjacent code to help you locate the correct lines for your version:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.14 – Adding the pdb debugger for debugging playbook loading and
    execution'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_09_14.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.14 – Adding the pdb debugger for debugging playbook loading and execution
  prefs: []
  type: TYPE_NORMAL
- en: Putting a breakpoint here will allow us to trace through finding the playbook
    file and parsing it. Specifically, by stepping into the `self._loader.load_from_file()` function
    call, we will be able to follow the parsing in action.
  prefs: []
  type: TYPE_NORMAL
- en: The `PlayBook` class `_load_playbook_data()` function just does the initial
    parsing. Other classes within other directories are used for the execution of
    plays and tasks. A particularly interesting directory is the `executor/` directory,
    which holds files with classes to execute playbooks, plays, and tasks. The `run()` function
    within the `PlaybookExecutor` class that's defined in the `executor/playbook_executor.py`
    file will loop through all of the plays in the playbook and execute the plays,
    which will, in turn, execute the individual tasks. This is the function to walk
    through if facing an issue related to play parsing, play or task callbacks, tags,
    play host selection, serial operation, handler running, or anything in between.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging executor code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Executor code in Ansible is the connector code that binds together inventory
    data, playbooks, plays, tasks, and connection methods. While each of those other
    code bits can be individually debugged, how they interact can be examined within
    executor code.
  prefs: []
  type: TYPE_NORMAL
- en: The executor classes are defined in various files within `executor/` and the
    `PlaybookExecutor` class. This class handles the execution of all of the plays
    and tasks within a given playbook. The `__init__()` class creation function creates
    a series of placeholder attributes as well as setting some default values, while
    the `run()` function is where most of the fun happens.
  prefs: []
  type: TYPE_NORMAL
- en: 'Debugging can often take you from one file to another, jumping around the code
    base. For example, in the `__init__()` function of the `PlaybookExecutor` class,
    there is code to cache whether or not the default **Secure Shell** (**SSH**) executable
    supports `ControlPersist`. You can find that by locating the `executor/playbook_executor.py`
    file within your Ansible installation path (just as we have done in the preceding
    sections) and looking for the line that states `set_default_transport()`. This
    is on line *76* in `ansible-core` 2.11.1, to give you an idea of where to look.
    Once you locate the appropriate place in the code, put a breakpoint here to allow
    you to follow the code, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.15 – Inserting the Python debugger into the Ansible playbook executor
    code'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_09_15.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.15 – Inserting the Python debugger into the Ansible playbook executor
    code
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now run our `objmethod.yml` playbook again to get into a debugging state,
    as illustrated in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.16 – Executing an example playbook to trigger the debugger'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_09_16.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.16 – Executing an example playbook to trigger the debugger
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll need to step into the function to follow the execution. Stepping into
    the function will take us to a different file, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.17 – Stepping into the code to follow the execution'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_09_17.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.17 – Stepping into the code to follow the execution
  prefs: []
  type: TYPE_NORMAL
- en: 'From here, we can use `list` to see the code in our new file, as illustrated
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.18 – Listing the adjacent code to our current position in the debugger'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_09_18.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.18 – Listing the adjacent code to our current position in the debugger
  prefs: []
  type: TYPE_NORMAL
- en: 'Walking a few more lines down, we come to a block of code that will execute
    an `ssh` command and check the output to determine whether `ControlPersist` is
    supported, as illustrated in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.19 – Locating the code to establish whether ControlPersist is supported'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_09_19.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.19 – Locating the code to establish whether ControlPersist is supported
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s walk through the next couple of lines and then print out what the value
    of `err` is. This will show us the result of the `ssh` execution and the whole
    string that Ansible will be searching within, as illustrated in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.20 – Analyzing the SSH connection results using the pdb debugger'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_09_20.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.20 – Analyzing the SSH connection results using the pdb debugger
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, the search string is not within the `err` variable, so the value
    of `has_cp` remains as the default of `True`.
  prefs: []
  type: TYPE_NORMAL
- en: A Quick Note on Forks and Debugging
  prefs: []
  type: TYPE_NORMAL
- en: When Ansible uses multiprocessing for multiple forks, debugging becomes difficult.
    A debugger may be attached to one fork and not another, which will make it very
    difficult to debug the code. Unless specifically debugging the multiprocessing
    code, it's a best practice to stick to a single fork.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging remote code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remote code is code that Ansible transports to a remote host to execute it.
    This is typically module code, or in the case of action plugins, other snippets
    of code. Using the debugging method we discussed in the previous section to debug
    module execution will not work, as Ansible simply copies the code over and then
    executes it. There is no terminal attached to remote code execution, and thus
    there is no way to attach it to a debugging prompt—that is, without editing the
    module code.
  prefs: []
  type: TYPE_NORMAL
- en: To debug module code, we need to edit the module code itself to insert a debugger
    breakpoint. Instead of directly editing the installed module file, create a copy
    of the file in a `library/` directory relative to the playbooks. This copy of
    the module code will be used instead of the installed file, which makes it easy
    to temporarily edit a module without disrupting other users of modules on the
    system.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike other Ansible code, module code cannot be directly debugged with `pdb`
    because the module code is assembled and then transported to a remote host. Thankfully,
    there is a solution in the form of a slightly different debugger named `rpdb`—the
    remote Python debugger. This debugger has the ability to start a listening service
    on a provided port to allow remote connections into the Python process. Connecting
    to the process remotely will allow the code to be debugged line by line, just
    as we did with other Ansible code.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate how this debugger works, we''re first going to need a remote
    host. For this example, we''re using a remote host by the name of `debug.example.com`
    (though feel free to use your own example with the appropriate adjustments to
    hostnames). Next, we need a playbook to execute a module that we''d like to debug.
    The code is illustrated in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: The eagle-eyed among you will have noticed that, for the first time in this
    book, we have not used the **fully qualified class name** (**FQCN**) for the module
    reference. This is because the FQCN tells Ansible to use its own built-in module
    from the location it expects, where we actually want to load the local copy we
    will place in our local `library/` directory. As a result, we must use just the
    short-form name of the module in this one instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will also need a new inventory file to reference our new test host. As I
    don''t have the **Domain Name System** (**DNS**) entry set up for this host, I''m
    using the special `ansible_host` variable in the inventory to tell Ansible which
    **Internet Protocol** (**IP**) address to connect to `debug.example.com` on, as
    illustrated in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: Don't forget to set up SSH authentication between your two hosts—I'm using an
    SSH key so that I don't need to type in a password every time I run `ansible-playbook`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This play simply calls the `ansible.builtin.systemd` module to ensure that
    the `nginx` service is stopped and will not start up on boot. As we stated previously,
    we need to make a copy of the service module and place it in `library/`. The location
    of the service module to copy from will vary based on the way Ansible is installed.
    On my demo system for this book, it is located in `/usr/local/lib/python3.8/dist-packages/ansible/modules/systemd.py`.
    Then, we can edit it to put in our breakpoint. I am inserting this at line *358*
    on my system—this is correct for `ansible-core` 2.11.1 but may change as newer
    versions are released. However, the following screenshot should give you an idea
    of where to insert the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.21 – Inserting the remote Python debugger into Ansible module code'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_09_21.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.21 – Inserting the remote Python debugger into Ansible module code
  prefs: []
  type: TYPE_NORMAL
- en: We'll put the breakpoint just before the `systemctl` variable value gets created.
    First, the `rpdb` module must be imported (meaning that the `rpdb` Python library
    needs to exist on the remote host), and then the breakpoint needs to be created
    with `set_trace()`.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: On Ubuntu Server 20.04 (as with the host that was used in the demo), `rpdb` can
    be installed with `pip` using the following command: `sudo pip3 install rpdb`.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike the regular debugger, this function will open a port and listen for external
    connections. By default, the function will listen for connections to port `4444` on
    the address `127.0.0.1`. However, that address is not exposed over the network,
    so in my example, I've instructed `rpdb` to listen on address `0.0.0.0`, which
    is effectively every address on the host (though as I'm sure you'll understand,
    this has security implications you need to be careful of!).
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: If the host on which you are running `rpdb` has a firewall (for example, `firewalld`
    or `ufw`), you will need to open port `4444` for the example given here to work.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now run this playbook to set up the server that will wait for a client
    connection, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.22 – Running a test playbook for remote module debugging'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_09_22.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.22 – Running a test playbook for remote module debugging
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the server is running, we can connect to it from another terminal.
    Connecting to the running process can be accomplished with the `telnet` program,
    as illustrated in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.23 – Using telnet to connect to a remote Python debugger session
    for module debugging'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_09_23.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.23 – Using telnet to connect to a remote Python debugger session for
    module debugging
  prefs: []
  type: TYPE_NORMAL
- en: 'From this point on, we can debug as normal. The commands we used before still
    exist, such as `list` to show where in the code the current frame is, as illustrated
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.24 – Using the now-familiar Python debugger commands in a remote
    debugging session'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_09_24.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.24 – Using the now-familiar Python debugger commands in a remote debugging
    session
  prefs: []
  type: TYPE_NORMAL
- en: Using the debugger, we can walk through the `systemd` module to track how it
    determines the path to the underlying tool, trace which commands are executed
    on the host, determine how a change is computed, and so on. The entire file can
    be stepped through, including any other external libraries the module may make
    use of, allowing the debugging of other non-module code on the remote host as
    well.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the debugging session allows the module to exit cleanly, the playbook''s
    execution will return to normal. However, if the debugging session is disconnected
    before the module completes, the playbook will produce an error, as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.25 – An example of an error produced when terminating the remote
    debugging session early'
  prefs: []
  type: TYPE_NORMAL
- en: '](Images/B17462_09_25.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.25 – An example of an error produced when terminating the remote debugging
    session early
  prefs: []
  type: TYPE_NORMAL
- en: Because of this side effect, it is best to not exit the debugger early, and
    instead issue a `continue` command when your debugging is finished.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging action plugins
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some modules are actually action plugins. These are tasks that will execute
    some code locally before transporting code to the remote host. Some example action
    plugins include `copy`, `fetch`, `script`, and `template`. The source to these
    plugins can be found in `plugins/action/`. Each plugin will have its own file
    in this directory that can be edited to have breakpoints inserted in order to
    debug the code that's executed, prior to (or in lieu of) sending code to the remote
    host. Debugging these is typically done with `pdb` since most of the code is executed
    locally.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ansible is a piece of software, and software breaks; it's not a matter of if,
    but when. Invalid input, improper assumptions, and unexpected environments are
    all things that can lead to a frustrating situation when tasks and plays are not
    performing as expected. Introspection and debugging are troubleshooting techniques
    that can quickly turn frustration into elation when a root cause is discovered.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we learned about how to get Ansible to log its actions to a
    file, and how to change the verbosity level of Ansible's output. We then learned
    how to inspect variables to ensure their values are in line with your expectations
    before we moved on to debugging Ansible code in detail. Furthermore, we walked
    through the process of inserting breakpoints into core Ansible code and executed
    both local and remote Python debugging sessions using standard Python tools.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to extend the functionality of Ansible
    by writing our own modules, plugins, and inventory sources.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What level of verbosity would you need to launch Ansible with to see details
    such as connection attempts?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) Level 3 or above
  prefs: []
  type: TYPE_NORMAL
- en: b) Level 2 or above
  prefs: []
  type: TYPE_NORMAL
- en: c) Level 1 or above
  prefs: []
  type: TYPE_NORMAL
- en: d) Level 4
  prefs: []
  type: TYPE_NORMAL
- en: Why should you be careful with verbosity levels above level one if you are using
    sensitive data in your playbook?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) Higher verbosity levels don't support the use of vaults.
  prefs: []
  type: TYPE_NORMAL
- en: b) Higher verbosity levels may log sensitive data to the console and/or log
    file.
  prefs: []
  type: TYPE_NORMAL
- en: c) Higher verbosity levels will print SSH passwords.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ansible can be centrally configured to log its output to a file by:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) Using the `ANSIBLE_LOG_PATH` environment variable
  prefs: []
  type: TYPE_NORMAL
- en: b) Using the `log_path` directive in `ansible.cfg`
  prefs: []
  type: TYPE_NORMAL
- en: c) Redirecting the output of each playbook run to a file
  prefs: []
  type: TYPE_NORMAL
- en: d) All of these
  prefs: []
  type: TYPE_NORMAL
- en: 'The name of the module used for variable introspection is:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) `ansible.builtin.analyze`
  prefs: []
  type: TYPE_NORMAL
- en: b) `ansible.builtin.introspect`
  prefs: []
  type: TYPE_NORMAL
- en: c) `ansible.builtin.debug`
  prefs: []
  type: TYPE_NORMAL
- en: d) `ansible.builtin.print`
  prefs: []
  type: TYPE_NORMAL
- en: When referencing subelements in Ansible variables, which syntax is the safest
    to prevent clashes with reserved Python names?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) Dot notation
  prefs: []
  type: TYPE_NORMAL
- en: b) Standard subscript syntax
  prefs: []
  type: TYPE_NORMAL
- en: c) Ansible subelement notation
  prefs: []
  type: TYPE_NORMAL
- en: d) Standard dot notation
  prefs: []
  type: TYPE_NORMAL
- en: 'Unless you need to perform low-level code debugging, you can debug the flow
    of a playbook using:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) The debug strategy
  prefs: []
  type: TYPE_NORMAL
- en: b) Debug execution
  prefs: []
  type: TYPE_NORMAL
- en: c) Debug task planner
  prefs: []
  type: TYPE_NORMAL
- en: d) None of these
  prefs: []
  type: TYPE_NORMAL
- en: 'The name of the Python local debugger as demonstrated in this book is:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) `PyDebug`
  prefs: []
  type: TYPE_NORMAL
- en: b) `python-debug`
  prefs: []
  type: TYPE_NORMAL
- en: c) `pdb`
  prefs: []
  type: TYPE_NORMAL
- en: d) `pdebug`
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also debug the execution of modules on remote hosts:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) Using the Python `rpdb` module.
  prefs: []
  type: TYPE_NORMAL
- en: b) By copying the playbook to the host and using `pdb`.
  prefs: []
  type: TYPE_NORMAL
- en: c) Via a packet tracer such as `tcpdump`.
  prefs: []
  type: TYPE_NORMAL
- en: d) This is not possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unless configured otherwise, the remote Python debugger listens for connections
    on:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) `127.0.0.1:4433`
  prefs: []
  type: TYPE_NORMAL
- en: b) `0.0.0.0:4444`
  prefs: []
  type: TYPE_NORMAL
- en: c) `127.0.0.1:4444`
  prefs: []
  type: TYPE_NORMAL
- en: d) `0.0.0.0:4433`
  prefs: []
  type: TYPE_NORMAL
- en: Why should you not end your remote Python debugging session without letting
    the code run to completion?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) It results in an error in your playbook run.
  prefs: []
  type: TYPE_NORMAL
- en: b) It will result in loss of files.
  prefs: []
  type: TYPE_NORMAL
- en: c) It might corrupt your Ansible installation.
  prefs: []
  type: TYPE_NORMAL
- en: d) It will result in a hung debug session.
  prefs: []
  type: TYPE_NORMAL
