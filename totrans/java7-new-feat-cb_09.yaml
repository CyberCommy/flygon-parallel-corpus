- en: Chapter 9. Database, Security, and System Enhancements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the RowSetFactory class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java 7 database enhancements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the ExtendedSSLSession interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the platform MXBeans for JVM or system process load monitoring
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Redirecting input and output from operating systems processes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Embedding a JNLP file in an HTML page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covers database, security, and system type enhancements that have
    been made to Java 7\. Some of these enhancements are minor and will be addressed
    in this introduction. Others are more significant and are detailed in this chapter's
    recipes. Due to the rather specialized nature of some topics, such as those typified
    by some of the security enhancements, they will be mentioned but not explained
    here.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple enhancements have been made to JDBC in Java 7, which now supports **JDBC
    4.1**. Some of the improvements depend on third party driver support not available
    in early driver versions. When this happens, you may receive an `AbstractMethodException`.
    When testing the database recipes for this chapter, ensure that you are working
    with a driver that supports the JDBC 4.1 functionality. Drivers can be found at
    [http://developers.sun.com/product/jdbc/drivers](http://developers.sun.com/product/jdbc/drivers).
  prefs: []
  type: TYPE_NORMAL
- en: The *Using the RowSetFactory* recipe deals with the use of the `javax.sql.rowset.RowSetFactory`
    interface and the `javax.sql.rowset.RowSetProvider` class, which permits the creation
    of any row sets as supported by a given JDBC driver. There are a number of other
    improvements in database's support included in Java 7\. These are addressed in
    the *Java 7 database enhancements* recipe, and include such issues as determining
    the name of the current schema and providing access to hidden columns. The **Derby**
    database engine will be used for the database examples. If you prefer to use other
    databases and tables, you can do so by adjusting the code for the different databases.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to these database recipes, the try-with-resource statement can be
    used with any object that implements the `java.sql` package's `Connection, ResultSet`,
    or `Statement` interfaces. This language improvement simplifies the process of
    opening and closing resources. The general use of the try-with-resource statement
    is detailed in the *Using the try-with-resource block to improve exception handling
    code* recipe, in [Chapter 1](ch01.html "Chapter 1. Java Language Improvements"),
    *Java Language Improvements*. An example of using this with a `ResultSet-derived`
    class is shown in the *Using the RowSetFactory class* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: The `Statement` interface has been enhanced with two new methods. The first
    method, `closeOnCompletion`, is executed to specify that the `Statement` object
    will be closed when result sets that use the connection are closed. The second
    method, `isCloseOnCompletion`, returns a Boolean value indicating whether the
    statement will be closed when this criteria is met.
  prefs: []
  type: TYPE_NORMAL
- en: 'Network enhancements to Java 7 include the addition of two methods to the `java.net.URLClassLoader`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '`close:` This method will close the current `URLClassLoader`, so that it is
    no longer able to load classes or resources. This addresses a problem found on
    Windows, as detailed at [http://download.oracle.com/javase/7/docs/technotes/guides/net/ClassLoader.html](http://download.oracle.com/javase/7/docs/technotes/guides/net/ClassLoader.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getResourceAsStream:` This method returns an `InputStream` for the resource
    specified by its `String` argument'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assistance is also provided to support stream connections using the **InfiniBand**
    (**IB**). This technology uses **Remote Direct Memory Access** (**RDMA**) to move
    data directly between the memories of different computers. This support is provided
    through the **Sockets Direct Protocol** (**SDP**) network protocol. The specialized
    nature of this technology precludes further discussion.
  prefs: []
  type: TYPE_NORMAL
- en: The *Using the platform MXBeans for JVM or system process load monitoring* recipe,
    examines the improvements made in the support of `MXBeans`. This includes different
    methods for accessing these management type beans.
  prefs: []
  type: TYPE_NORMAL
- en: The `java.lang.ProcessBuilder` class has improved redirect capabilities as introduced
    by the `ProcessBuilder.Redirect` class. This topic is explored in the *Redirecting
    input and output from operating systems processes* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Java 7 has also improved the way applets can be embedded in an HTML page. The
    *Embedding a JNLP file in an HTML page* recipe provides a demonstration of this
    technique.
  prefs: []
  type: TYPE_NORMAL
- en: The **Java Secure Socket Extension** (**JSSE**) is used to secure Internet communications
    using **Secure Sockets Layer** (**SSL**) and **Transport Layer Security** (**TLS**).
    JSSE assists in data encryption, authentication, and maintaining message integrity.
    In Java 7, several enhancements have occurred. The *Using the ExtendedSSLSession
    interface* recipe uses SSL, and is used to illustrate the use of the `ExtendedSSLSession`
    interface and new security features.
  prefs: []
  type: TYPE_NORMAL
- en: Security enhancements include the incorporation of **Elliptic Curve Cryptography**
    (**ECC**) algorithms. This class of encryption algorithms is more resistant to
    brute force attacks. A portable implementation of the algorithm has been provided.
  prefs: []
  type: TYPE_NORMAL
- en: New exception classes have been added or enhanced to enhance security. The new
    `java.security.cert.CertificateRevokedException`, when thrown, means that an **X.509**
    certificate has been revoked. The `java.security.cert.CertPathValidatorException`
    class has been enhanced with the addition of a new constructor that takes a `CertPathValidatorException.Reason`
    object. This object implements the `CertPathValidatorException.BasicReason` enumeration
    that enumerates the reason for the exception. The `CertPathValidatorException`
    class's `getReason` method returns a `CertPathValidatorException.Reason` object.
  prefs: []
  type: TYPE_NORMAL
- en: Java 7 also supports TLS 1.1 and 1.2 specifications and improves upon this support.
    The **Sun JSSE** provider supports TLS 1.1 and TLS 1.2 as defined in RFC 4346
    ([http://tools.ietf.org/html/rfc4346](http://tools.ietf.org/html/rfc4346)) and
    RFC 5246 ([http://tools.ietf.org/html/rfc5246](http://tools.ietf.org/html/rfc5246))
    respectively. These include support to protect against cipher block chaining attacks
    and new cryptographic algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, there are a few other TKS-related enhancements:'
  prefs: []
  type: TYPE_NORMAL
- en: The **SSLv2Hello** protocol has been removed from the list of protocols that
    are enabled by default.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A flaw relating to TLS renegotiation has been fixed in Java 7\. Details regarding
    this flaw can be found at [http://www.oracle.com/technetwork/java/javase/documentation/tlsreadme2-176330.html](http://www.oracle.com/technetwork/java/javase/documentation/tlsreadme2-176330.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: During TLS 1.1/1.2 handshaking, Java 7 has improved the process of version number
    checking.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Weak cryptographic algorithms can be disabled using the `jdk.certpath.disabledAlgorithms`
    property for the **Sun** provider. By default, the MD2 algorithm is disabled.
    This property is specified in the `jre/lib/security/java.security` file. The default
    setting is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: It is also possible to specify not only the algorithm, but restrictions on the
    key size.
  prefs: []
  type: TYPE_NORMAL
- en: 'Algorithm restrictions can also be placed at the TLS level. This is accomplished
    using the `jdk.tls.disabledAlgorithms` security property in the `jre/lib/security/java.security`
    file. An example is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Currently, this property is specific to the **Oracle JSSE** implementation and
    may not be recognized by other implementations.
  prefs: []
  type: TYPE_NORMAL
- en: The **Server Name Indication** (**SNI**) JSSE extension (RFC 4366) enables TLS
    clients to connect to virtual servers, that is, multiple servers with different
    network names that use the same supporting network address. This is enabled to
    `true` by default, but can be set to `false` for systems where the extension is
    not supported.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `jsse.enableSNIExtension` system property is used to control this setting.
    It can be set using the `-D` java command option shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'It is also possible to set this property using the `setProperty` method shown
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note that the property name may change in the future.
  prefs: []
  type: TYPE_NORMAL
- en: Using the RowSetFactory class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Row sets can now be created using the new `javax.sql.rowset` package''s `RowSetFactoryInterface`
    interface and the `RowSetProvider` class. This permits the creation of any type
    of row set supported by JDBC. We will use the Derby database to illustrate the
    process of creating row sets. The `COLLEAGUES` table will be used. A description
    of how to create this table is found at [http://netbeans.org/kb/docs/ide/java-db.html](http://netbeans.org/kb/docs/ide/java-db.html).
    The SQL code to create the table is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create a new row set:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an instance of the `RowSetFactory.`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use one of the several `create` methods to create a `RowSet` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new console application. In the `main` method, add the following code
    sequence. We will create a new `javax.sql.rowset.JdbcRowSet` object and use it
    to display some of the fields in the `COLLEAGUES` table. Start by setting up `String`
    variables to establish connectivity to the database and create a `RowSetFactory`
    object as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Next, add a try block to catch any `SQLExceptions`, and then use the `createJdbcRowSet`
    method to create the row set. Next, display the selected elements of the table.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the application. The output should appear as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**1 - Mike**'
  prefs: []
  type: TYPE_NORMAL
- en: '**2 - James**'
  prefs: []
  type: TYPE_NORMAL
- en: '**3 - Jerilyn**'
  prefs: []
  type: TYPE_NORMAL
- en: '**4 - Jonathan**'
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: String variables were created for the database URL, username, and password.
    The `RowSetFactory` object was created using the static `newFactory` method. Any
    exceptions generated will result in the termination of the application.
  prefs: []
  type: TYPE_NORMAL
- en: In the try-with-resources block, the `createJdbcRowSet` method was used to create
    an instance of the `JdbcRowSet` class. The URL, username, and password were then
    assigned to the row set. The select command retrieved all of the fields from the
    `COLLEAGUES` table. The query was then executed.
  prefs: []
  type: TYPE_NORMAL
- en: Next, a `while` loop was used to display the ID and the first name for each
    row of the row set.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There may be more than one `RowSetFactory` implementation available. The `newFactory`
    method will look for a `RowSetFactory` class in the following order:'
  prefs: []
  type: TYPE_NORMAL
- en: The one specified in the system property, `javax.sql.rowset.RowSetFactory`,
    if defined.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the `ServiceLoader` API.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The platform default instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In addition to the creation of a `JdbcRowSet` row set, other methods are available
    to create different types of row sets as listed in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Row set created |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `createCachedRowSet` | `CachedRowSet` |'
  prefs: []
  type: TYPE_TB
- en: '| `createFilteredRowSet` | `FilteredRowSet` |'
  prefs: []
  type: TYPE_TB
- en: '| `createJdbcRowSet` | `JdbcRowSet` |'
  prefs: []
  type: TYPE_TB
- en: '| `createJoinRowSet` | `JoinRowSet` |'
  prefs: []
  type: TYPE_TB
- en: '| `createWebRowSet` | `WebRowSet` |'
  prefs: []
  type: TYPE_TB
- en: 'A `RowSetFactory` can also be created using the overloaded `newFactory` method
    that takes two arguments, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This approach provides more control to the application, enabling it to specify
    the provider to use. When there are multiple providers found in the class path,
    this can be useful. The first argument specifies the class name of the provider
    and the second argument specifies the class loader to use. Using `null` as the
    second argument specifies that the context class loader is to be used.
  prefs: []
  type: TYPE_NORMAL
- en: Java 7 database enhancements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are numerous small enhancements to the database support provided by Java
    7\. This recipe addresses these enhancements and provides examples where practical.
    Due to the immaturity of many JDBC 4.1 drives, not all of the code examples will
    be completely functional.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Most of the examples start by:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a connection to a Derby database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the connection methods to access needed functionality.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new console application. In the `main` method, add the following code
    sequence. It will establish a connection to the database and determine if auto-generated
    keys will always be returned and what the current schema is:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'When executed, your output should appear similar to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Auto Generated Keys: true**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Schema: SchemaName**'
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Statement` interface's `getGeneratedKeys` method was introduced in Java
    1.4 and returns any auto-generated keys for that statement. The `java.sql.DatabaseMetaData`
    interface's `generatedKeyAlwaysReturned` method returned a Boolean value, indicating
    that auto-generated keys will always be returned.
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to set and get the schema for a connection using the `Connection`
    interface's `setSchema` and `getSchema` methods. The `getSchema` method was executed,
    which returned the schema name.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Three other topics bear further discussion:'
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving pseudo-columns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling the type value of the `OUT` parameter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other database enhancements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retrieving pseudo-columns
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Databases will often use hidden columns to represent a unique key for every
    row of a table. These hidden columns are sometimes called **pseudo-columns**.
    In Java 7, two new methods have been added to address pseudo-columns. The `DatabaseMetaData`
    interface''s `getPseudoColumns` method will retrieve a `ResultSet`. The method
    asks for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Catalog: This needs to match the catalog name used in the database. If no catalog
    is used, then use an empty string. A null value means that the catalog name will
    not be used when searching for the columns.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Schema pattern: This needs to match the schema name used in the database. If
    no schema is used then use an empty string. A null value means that the schema
    name will not be used when searching for the columns.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Table name pattern: This needs to match the table name used in the database'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Column name pattern: This needs to match the column name used in the database'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `ResultSet` returned will have the following organization as shown in the
    following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Column | Type | Meaning |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `TABLE_CAT` | String | The name of the catalog which may be null |'
  prefs: []
  type: TYPE_TB
- en: '| `TABLE_SCHEM` | String | The name of the schema which may be null |'
  prefs: []
  type: TYPE_TB
- en: '| `TABLE_NAME` | String | The name of the table |'
  prefs: []
  type: TYPE_TB
- en: '| `COLUMN_NAME` | String | The name of the column |'
  prefs: []
  type: TYPE_TB
- en: '| `DATA_TYPE` | int | SQL type (`java.sql.Types`) |'
  prefs: []
  type: TYPE_TB
- en: '| `COLUMN_SIZE` | int | The size of the column |'
  prefs: []
  type: TYPE_TB
- en: '| `DECIMAL_DIGITS` | int | The number of fractional digits. A null value means
    there are no fractional digits. |'
  prefs: []
  type: TYPE_TB
- en: '| `NUM_PREC_RADIX` | int | The radix |'
  prefs: []
  type: TYPE_TB
- en: '| `COLUMN_USAGE` | String | Specifies how the column is used as defined by
    the new PsuedoColumnUsage enumeration |'
  prefs: []
  type: TYPE_TB
- en: '| `REMARKS` | String | Comment regarding the column |'
  prefs: []
  type: TYPE_TB
- en: '| `CHAR_OCTET_LENGTH` | int | The maximum number of characters for a char column
    |'
  prefs: []
  type: TYPE_TB
- en: '| `IS_NULLABLE` | String | *YES: Column can contain null**NO: Column cannot
    contain nulls**"": Unknown* |'
  prefs: []
  type: TYPE_TB
- en: 'The hidden columns represent a unique key, which provides a fast way of accessing
    a row. Derby does not support hidden columns. However, the following code sequence
    illustrates how this can be accomplished:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Derby will return an empty `ResultSet` consisting of the columns listed previously.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling the type value of the OUT parameter
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `java.sql.CallableStatement` has two overloaded `getObject` methods that
    return an object, which is given a column name or index. Support is currently
    limited. However, the basic approach is illustrated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The query string contains a call to a stored procedure. This procedure is assumed
    to use an integer value as the first parameter to identify a record in a table.
    The second argument is to be returned and is of the type `Date`.
  prefs: []
  type: TYPE_NORMAL
- en: Once the query is executed, the `getObject` method will return the specified
    column using the data type specified. The method will convert the SQL type to
    the Java data type.
  prefs: []
  type: TYPE_NORMAL
- en: Other database enhancements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `java.sql` package''s `Driver` interface has a new method, which returns
    the parent logger for the driver. This is illustrated with the following code
    sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'However, when executed, the current version of the driver will generate the
    following exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Java.sql.SQLFeatureNotSupportedException: Feature not implemented: getParentLogger**.'
  prefs: []
  type: TYPE_NORMAL
- en: Derby does not use the `java.util.logging` package, so it throws this exception.
    The `javax.sql.CommonDataSource` interface has also added the `getParentLogger`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, when a series of database operations are performed in conjunction
    with an `Executor`, three methods are available to support those operations, which
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`abort:` This method will abort an open connection using the `Executor` passed
    to the method'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setNetworkTimeout:` This method specifies the timeout period in milliseconds
    to wait for the response to a request. It also uses an `Executor` object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getNetworkTimeout:` This method returns the number of milliseconds that the
    connection will wait for database requests'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last two methods are optional and are not supported by Derby.
  prefs: []
  type: TYPE_NORMAL
- en: Using the ExtendedSSLSession interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `javax.net.ssl` package provides a series of classes used to effect secure
    socket communication. Improvements introduced in Java 7 include the addition of
    the `ExtendedSSLSession` interface, which can be used to determine the specific
    local and peer supported signature algorithms that are used. In addition, when
    an `SSLSession` is created, an endpoint identification algorithm can be used to
    ensure that the host computer's address matches that of the certificate. This
    algorithm is accessible through the `SSLParameters` class.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To demonstrate the use of the `ExtendedSSLSession` interface, we will:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an `SSLServerSocket-based EchoServer` application to accept messages
    from a client.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a client application, which uses a `SSLSocket` instance to communicate
    with the server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `EchoServer` application to obtain an instance of the `ExtendedSSLSession`
    interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use a `SimpleConstraints` class to demonstrate the use of algorithm constraints.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start by creating a class called `SimpleConstraints`, which is adapted
    from the **Java PKI Programmer''s Guide** ([http://download.oracle.com/javase/7/docs/technotes/guides/security/certpath/CertPathProgGuide.html](http://download.oracle.com/javase/7/docs/technotes/guides/security/certpath/CertPathProgGuide.html)).
    We will use this to associate algorithm constraints to the application. Add the
    following class to your project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'To create the `EchoServer` application, create a new console application. Add
    the following code to the `main` method. In this initial sequence, we create and
    start up the server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, add the following code sequence to set up algorithm constraints for the
    application. It also returns the name of the end point algorithm:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code to display local supported algorithms:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The following sequence displays peer-supported algorithms:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code to buffer the input stream coming from a client application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Finish the method by adding code to display the input from the client:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'To execute the server, we need to create key store. This is accomplished from
    the command prompt by executing the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Provide a password and other information requested by the program. Next, navigate
    to the echo server''s location and enter the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The **password** above, is the password that you used to create the key store,
    and package, is your EchoServer''s package, if any. When the program executes,
    you get the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Waiting for a client ...**'
  prefs: []
  type: TYPE_NORMAL
- en: 'We now need to create a client console application called `EchoClient`. In
    the `main` method, add the following code where we create a connection to the
    server and then send the input from the keyboard to the server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Copy the key store file to the client application''s directory. In a separate
    command window, execute the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The **password** above, is the password that you used to create the key store,
    and package, is your EchoServer''s package, if any. When the program executes,
    enter the word **cat**, and then press the *Enter* key. In the server command
    window, you should see an end point name, which may be null, a list of local supported
    signature algorithms, and **cat** similar to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**End Point: null**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Local Supported Signature Algorithms**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Algortihm: SHA512withECDSA**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Algortihm: SHA512withRSA**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Algortihm: SHA384withECDSA**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Algortihm: SHA384withRSA**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Algortihm: SHA256withECDSA**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Algortihm: SHA256withRSA**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Algortihm: SHA224withECDSA**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Algortihm: SHA224withRSA**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Algortihm: SHA1withECDSA**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Algortihm: SHA1withRSA**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Algortihm: SHA1withDSA**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Algortihm: MD5withRSA**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Peer Supported Signature Algorithms**'
  prefs: []
  type: TYPE_NORMAL
- en: '**cat**'
  prefs: []
  type: TYPE_NORMAL
- en: As you enter more input lines, they should be reflected in the server command
    window. To terminate the program, enter a *Ctrl* + *C* in the client command window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `SimpleConstraints` class allows only RSA algorithms and then with keys
    that use 2048 bits or more. This was used as an argument to the `setAlgorithmConstraints`
    method. The class implemented the `java.security.AlgorithmConstraints` interface,
    which represents the restrictions of the algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: A `SSLServerSocketFactory` instance was created followed by the creation of
    a `SSLServerSocket`. The `accept` method was executed against the socket, which
    blocks until a client connects to it.
  prefs: []
  type: TYPE_NORMAL
- en: Next, the `SimpleConstraints` was set followed by the use of the `getEndpointIdentificationAlgorithm`
    method, which returned an empty string. For this example, no endpoint identification
    algorithm was used.
  prefs: []
  type: TYPE_NORMAL
- en: The local and peer supported signature algorithms were listed. The remaining
    code was concerned with reading and then displaying the string sent by a client.
  prefs: []
  type: TYPE_NORMAL
- en: The `EchoClient` application is simpler. It created an instance of the `SSLSocket`
    class and then used its `getOutputStream` method to write the user's input to
    the echo server.
  prefs: []
  type: TYPE_NORMAL
- en: Using the platform MXBeans for JVM or system process load monitoring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Java Management Extensions** (**JMX**) is a standard way of adding a management
    interface to an application. A **managed bean** (**MBean**) provides the management
    services for the application and is registered with a `javax.management.MBeanServer`,
    which holds and administers the MBean. A `javax.management.MXBean` is a type of
    MBean, which permits clients to access the bean without the need to access specific
    classes.'
  prefs: []
  type: TYPE_NORMAL
- en: The `java.lang.management` package's `ManagementFactory` class has added several
    new methods to gain access to an MBean. These can then be used to access process
    and load monitoring.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To access an `MXBean:`
  prefs: []
  type: TYPE_NORMAL
- en: Use the `getPlatformMXBean` method with the `MXBean` type needed for the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `MXBean` methods as required.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new console application. Use the `main` method that follows. In this
    application, we will obtain an `MXBean` for the runtime environment and display
    basic information about it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the application. Your output should be similar to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**JVM Name: 5584@name-PC**'
  prefs: []
  type: TYPE_NORMAL
- en: '**JVM Specification Name: Java Virtual Machine Specification**'
  prefs: []
  type: TYPE_NORMAL
- en: '**JVM Specification Version: 1.7**'
  prefs: []
  type: TYPE_NORMAL
- en: '**JVM Implemenation Name: Java HotSpot(TM) 64-Bit Server VM**'
  prefs: []
  type: TYPE_NORMAL
- en: '**JVM Implemenation Vendor: Oracle Corporation**'
  prefs: []
  type: TYPE_NORMAL
- en: '**JVM Implemenation Version: 21.0-b17**'
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We used the `ManagementFactory` class' static `getPlatformMXBean` method with
    an argument of `RuntimeMXBean.class`. This returned an instance of a `RuntimeMXBean`.
    Specific methods of this instance were then applied and their values were displayed.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `ManagementFactory` introduced several new methods in Java 7:'
  prefs: []
  type: TYPE_NORMAL
- en: '`getPlatformMXBean:` This is an overloaded method that returns a `PlatformManagedObject`-derived
    object supporting a particular management interface using a `Class` argument'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getPlatformMXBeans:` This is an overloaded method that returns a `PlatformManagedObject`-derived
    object supporting a particular management interface using an `MBeanServerConnection`
    object and a `Class` argument'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getPlatformManagementInterfaces:` This method returns a set of `Class` objects
    for `PlatformManagedObject`-derived objects on the current Java platform'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition, a new interface was added to the `java.lang.management` package.
    The `PlatformManagedObject` interface serves as the base interface for all `MXBeans`.
  prefs: []
  type: TYPE_NORMAL
- en: Using the getPlatformMXBeans method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `getPlatformMXBeans` method is passed the `MXBean` type and returns a list
    of the platform `MXBeans` that implements the `MXBean` type. In the following
    example, we obtain a list for the `OperatingSystemMXBean`. Several attributes
    of the `MXBean` are then displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'When executed, you should get an output similar to the following. The exact
    output is dependent on the operating system and hardware used to execute the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Operating System Name: Windows 7**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Operating System Architecture: amd64**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Operating System Version: 6.1**'
  prefs: []
  type: TYPE_NORMAL
- en: Obtaining the platform's management interfaces
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `ManagementFactory` class' static `getPlatformManagementInterfaces` method
    returns a set of `Class` objects representing the platform-supported `MXBeans`.
    However, this method generated a `ClassCastException` on both the Windows 7 and
    the Ubuntu platforms when running the JDK 7.01 release. Future versions should
    correct this problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **jconsole** application that is available as part of the JDK, provides
    an alternative technique for determining which `MXBeans` are available. The following
    is the console displaying the attributes for the operating system, specifically
    the `ProcessCpuLoad` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Obtaining the platform''s management interfaces](img/5627_09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Redirecting input and output from operating system's processes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `java.lang.ProcessBuilder` class has several new methods that are useful
    for redirecting the input and output of external processes executed from a Java
    application. The nested `ProcessBuilder.Redirect` class has been introduced to
    provide these additional redirect capabilities. To demonstrate this process, we
    are going to send command-line arguments from a text file to a DOS prompt and
    record the output in another text file.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to control input and output from external processes, you must:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new `ProcessBuilder` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Direct the input and output of the process to the appropriate locations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Execute the process via the `start` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, create a new console application. Create three new file instances to
    represent the three files involved in our process execution: input, output, and
    errors as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the file `ProcessCommands.txt` using the path specified for the file
    and enter the following text:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**cd C:\**'
  prefs: []
  type: TYPE_NORMAL
- en: '**dir**'
  prefs: []
  type: TYPE_NORMAL
- en: '**mkdir "Test Directory"**'
  prefs: []
  type: TYPE_NORMAL
- en: '**dir**'
  prefs: []
  type: TYPE_NORMAL
- en: Make sure that there is a carriage return after the last line.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, create a new instance of a `ProcessBuilder`, passing the string `"cmd`"
    to the constructor to specify the external process that we want to launch, which
    is the operating system command window. Call the `redirectInput, redirectOutput`,
    and `redirectError` methods with no arguments and print out the default locations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we want to call the overloaded form of the previous methods, passing the
    respective file to each one. Once again, call the no argument form of each method
    executed using the `toString` method to verify that the IO sources have been changed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, call the `start` method to execute the process as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the application. You should see output similar to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**PIPE**'
  prefs: []
  type: TYPE_NORMAL
- en: '**PIPE**'
  prefs: []
  type: TYPE_NORMAL
- en: '**PIPE**'
  prefs: []
  type: TYPE_NORMAL
- en: '**redirect to read from file "C:\Projects\ProcessCommands.txt"**'
  prefs: []
  type: TYPE_NORMAL
- en: '**redirect to write to file "C:\Projects\ProcessLog.txt"**'
  prefs: []
  type: TYPE_NORMAL
- en: '**redirect to write to file "C:\Projects\ErrorLog.txt"**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Examine each of the text files. Your output file should have text similar to
    this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Microsoft Windows [Version 6.7601]**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Copyright (c) 2009 Microsoft Corporation. All rights reserved.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**C:\Users\Jenn\Documents\NetBeansProjects\ProcessBuilderExample>cd C:\**'
  prefs: []
  type: TYPE_NORMAL
- en: '**C:\>dir**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Volume in drive C has no label.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Volume Serial Number is 927A-1F77**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Directory of C:\**'
  prefs: []
  type: TYPE_NORMAL
- en: '**03/05/2011 10:56 <DIR> Dell**'
  prefs: []
  type: TYPE_NORMAL
- en: '**11/08/2011 16:04 <DIR> Miscellaneous**'
  prefs: []
  type: TYPE_NORMAL
- en: '**11/08/2011 11:08 <DIR> MOVE**'
  prefs: []
  type: TYPE_NORMAL
- en: '**10/31/2011 10:57 <DIR> MUSIC**'
  prefs: []
  type: TYPE_NORMAL
- en: '**11/08/2011 19:44 <DIR> Projects**'
  prefs: []
  type: TYPE_NORMAL
- en: '**10/27/2011 21:09 <DIR> temp**'
  prefs: []
  type: TYPE_NORMAL
- en: '**10/28/2011 10:46 <DIR> Users**'
  prefs: []
  type: TYPE_NORMAL
- en: '**11/08/2011 17:11 <DIR> Windows**'
  prefs: []
  type: TYPE_NORMAL
- en: '**0 File(s) 0 bytes**'
  prefs: []
  type: TYPE_NORMAL
- en: '**34 Dir(s) 620,819,542,016 bytes free**'
  prefs: []
  type: TYPE_NORMAL
- en: '**C:\>mkdir "Test Directory"**'
  prefs: []
  type: TYPE_NORMAL
- en: '**C:\>dir**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Volume in drive C has no label.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Volume Serial Number is 927A-1F77**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Directory of C:\**'
  prefs: []
  type: TYPE_NORMAL
- en: '**03/05/2011 10:56 <DIR> Dell**'
  prefs: []
  type: TYPE_NORMAL
- en: '**11/08/2011 16:04 <DIR> Miscellaneous**'
  prefs: []
  type: TYPE_NORMAL
- en: '**11/08/2011 11:08 <DIR> MOVE**'
  prefs: []
  type: TYPE_NORMAL
- en: '**10/31/2011 10:57 <DIR> MUSIC**'
  prefs: []
  type: TYPE_NORMAL
- en: '**11/08/2011 19:44 <DIR> Projects**'
  prefs: []
  type: TYPE_NORMAL
- en: '**10/27/2011 21:09 <DIR> temp**'
  prefs: []
  type: TYPE_NORMAL
- en: '**10/28/2011 10:46 <DIR> Test Directory**'
  prefs: []
  type: TYPE_NORMAL
- en: '**10/28/2011 10:46 <DIR> Users**'
  prefs: []
  type: TYPE_NORMAL
- en: '**11/08/2011 17:11 <DIR> Windows**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the program again and examine the contents of your error log. Because
    your test directory had already been created with the first process execution,
    you should now see the following error message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**A subdirectory or file Test Directory already exists.**'
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We created three files to handle the input and output of our process. When we
    created the instance of the `ProcessBuilder` object, we specified the application
    to launch to be the command window. The information required to perform actions
    within the application was stored in our input file.
  prefs: []
  type: TYPE_NORMAL
- en: When we first called the `redirectInput, redirectOutput`, and `redirectError`
    methods, we did not pass any arguments. These methods all return a `ProcessBuilder.Redirect`
    object, which we printed. This object represents the default IO source, which
    in all three cases was `Redirect.PIPE`, one of the `ProcessBuilder.Redirect.Type`
    enumerations. A pipe takes the output of one source and sends it to another.
  prefs: []
  type: TYPE_NORMAL
- en: The second form of the methods that we used involved passing a `java.io.File`
    instance to the `redirectInput, redirectOutput`, and `redirectError` methods.
    These methods return a `ProcessBuilder` object as well, but they also have the
    function of setting the IO source. In our example, we then called the no argument
    form of each method once more to verify that the IO had been redirected.
  prefs: []
  type: TYPE_NORMAL
- en: The first time the program was executed, your error log should have been empty,
    assuming you used valid file paths for each `File` object, and you have write
    permissions on your computer. The second execution was intended to display how
    the capture of errors can be directed to a separate file. If the `redirectError`
    method is not invoked, the errors will inherit the standard location and will
    be displayed in your IDE's output window. See the *There's More..*. section for
    information about inheriting standard IO locations.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that the `start` method must be called after the redirect
    methods. Starting the process before redirecting input or output will cause the
    process to disregard your redirects and the application will execute using the
    standard IO locations.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will examine the use of the `ProcessBuilder.Redirect` class
    and the `inheritIO` method.
  prefs: []
  type: TYPE_NORMAL
- en: Using the ProcessBuilder.Redirect class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `ProcessBuilder.Redirect` class provides another way to specify how the
    IO data is redirected. Using the previous example, add a new line prior to calling
    the `start` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This form of the `redirectError` method allows you to specify that the errors
    should be appended to the error log text file rather than overwritten. If you
    execute the application with this change, you will see two instances of the error
    when the process tries to create the `Test Directory` directory again:'
  prefs: []
  type: TYPE_NORMAL
- en: '**A subdirectory or file Test Directory already exists**.'
  prefs: []
  type: TYPE_NORMAL
- en: '**A subdirectory or file Test Directory already exists**.'
  prefs: []
  type: TYPE_NORMAL
- en: This is an example of using the overloaded form of the `redirectError` method,
    passing a `ProcessBuilder.Redirect` object instead of a file. All three methods,
    `redirectError, redirectInput`, and `redirectOutput`, have this overloaded form.
  prefs: []
  type: TYPE_NORMAL
- en: The `ProcessBuilder.Redirect` class has two special values, namely, `Redirect.PIPE`
    and `Redirect.INHERIT. Redirect.PIPE` is the default way external process IO is
    handled, and simply means that the Java process will be connected to the external
    process via a pipe. The `Redirect.INHERIT` value means that the external process
    will have the same input or output location as the current Java process. You can
    also redirect the input or output of data using the `Redirect.to` and `Redirect.from`
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: Using the inheritIO method to inherit the default IO locations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you execute an external process from a Java application, you can set the
    location of the source and destination data to be the same as that of the current
    Java process. The `ProcessBuilder` class'' `inheritIO` method is a convenient
    way to accomplish this. If you have a `ProcessBuilder` object `pb`, executing
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Then it has the same effect as executing the following three statements together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In both cases, the input, output, and error data will be located in the same
    places as the current Java process' input, output, and error data.
  prefs: []
  type: TYPE_NORMAL
- en: Embedding a JNLP file in an HTML page
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Java 7 provides a new option to speed up the deployment of an applet in a web
    page. Prior to 7, when applets were launched using the **Java Network Launch Protocol**
    (**JNLP**), the JNLP file must first be downloaded from the network before the
    applet can be launched. With the new release, the JNLP file can be embedded directly
    into the HTML code, reducing the amount of time the applet needs to launch. In
    this example, we are going to build a basic applet and launch it using a JNLP-embedded
    HTML page.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To speed up applet launch in Java 7, you must:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Applet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create and encode a JNLP file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the reference to the JNLP file to an HTML page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First create an applet to use in an HTML window. The following is a simple
    applet that can be used for the purposes of this recipe. This applet has two input
    fields, `subtotal` and `taxRate`, and a `calculate` button is used to calculate
    the grand total:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create a JNLP file called `JNLPExample.jnlp`. The following is a sample
    JNLP file to accompany our previous applet. Notice that within the resources tag
    a JAR file is referenced. This JAR file, containing your applet, must be in the
    same location as your JNLP file and the HTML file, which we will create in a moment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'After you have created the JNLP file, it must be encoded. There are several
    resources available online to convert the JNLP file to BASE64, but the one used
    for this example was [http://base64encode.org/](http://base64encode.org/). Use
    the UTF-8 charset. Once you have your encoded data, you will use this in the creation
    of an HTML file. Create an HTML file shown as follows. Notice that the BASE64-encoded
    string highlighted has been shortened for purposes of brevity, but your string
    will be much longer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Also, notice the first script tag. To avoid using a `codebase` attribute, we
    are utilizing another new feature of Java 7 by using a Development Toolkit script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Load your application in a browser window. You may need to enable JavaScript
    depending upon your current browser settings. Your applet should load quickly
    and appear similar to the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![How to do it...](img/5627_09_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Embedding the JNLP file in the HTML page allowed the applet to be loaded immediately,
    rather than having to be downloaded from the server first. The JNLP file had to
    have a relative path in the `href` attribute and the `codebase` should not be
    specified. By leaving the `codebase` attribute blank, it was determined by the
    URL of the applet's web page.
  prefs: []
  type: TYPE_NORMAL
- en: The `resources` tag specified the location of your JAR file and the version
    of Java to use. The path for your JAR file was assumed to be the default working
    directory as was the location of your JNLP file. Also included in your JNLP file
    was a description of your applet, surrounded by the `applet-desc` tag. The name
    of your applet and the name of your main class file was specified in this tag.
  prefs: []
  type: TYPE_NORMAL
- en: The HTML file contained information necessary to load the applet without having
    to download the applet information from a server. We first specified that we are
    going to load the application using a JavaScript call. Then, in our first script
    tag, we added a section to allow us to call the applet without a `codebase`. This
    is advantageous because the application can be loaded and tested in different
    environments without changing the `codebase` attribute. It is, instead, inherited
    from the web page that the application is running from.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two functions of the Deployment Toolkit that can be used to deploy
    Java applets in a web page without a `codebase` attribute: the `launchWebStartApplication`
    and `createWebStartLaunchButtonEx`. We chose to use the `createWebStartLaunchButtonEx`
    for this recipe, but the `launchWebStartApplication` option is also discussed
    as follows. In both instances, the client must have the Java SE 7 release to launch
    the applet, and if they do not, they will be directed to the Java website to download
    the most recent version.'
  prefs: []
  type: TYPE_NORMAL
- en: The `createWebStartLaunchButtonEx` function created a launch button for the
    application. Within the `script` tag, the `jnlpFile` variable specified the name
    of the JNLP file and was relative to the applet's web page. This filename is then
    passed to the `deployJava.createWebStartLaunchButtonEx` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, the `launchWebStartApplication` function could be embedded in
    an HTML link. The function is invoked within an `href` tag, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The second `script` tag within your HTML file contained information about your
    JNLP file. The `jnlp_href` variable stored the name of the JNLP file. The JNLP
    file's encoded form was specified by the `jnlp_embedded` parameter. The BASE64
    encoder encoded binary data for instances where the data needs to be stored and
    transferred across textual mediums, such as e-mail and XML files.
  prefs: []
  type: TYPE_NORMAL
