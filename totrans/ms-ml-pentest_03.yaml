- en: Malware Detection with API Calls and PE Headers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some of the most annoying threats in information security are malicious programs.
    Every day, we hear news about data breaches and cyber attacks with malware. Attackers
    are enhancing their development skills and building new malware that are able
    to bypass company safeguards and AV-products. This chapter will introduce some
    new techniques and solutions for defeating malware, using cutting-edge data science,
    Python libraries, and machine learning algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Malware analysis approaches
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Machine learning aided malware analysis techniques, with practical, real-world
    Python projects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will use the same Python libraries that we already installed.
    We are going to use those libraries during most of the chapters in this book.
    That is why we used the first chapter to teach you how to install all of the required
    libraries.
  prefs: []
  type: TYPE_NORMAL
- en: You will find all of the codes discussed, in addition to some other useful scripts,
    in the repository at [https://github.com/PacktPublishing/Mastering-Machine-Learning-for-Penetration-Testing/tree/master/Chapter03](https://github.com/PacktPublishing/Mastering-Machine-Learning-for-Penetration-Testing/tree/master/Chapter03).
  prefs: []
  type: TYPE_NORMAL
- en: Malware overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Malware are malicious pieces of software that are designed to infiltrate and
    damage information systems without the users'' consent. The term *malware* covers
    a lot of categories. There are many different types of malware:'
  prefs: []
  type: TYPE_NORMAL
- en: Viruses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ransomware
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Worms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Trojans
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Backdoor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spyware
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keyloggers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adware, bots, and rootkits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Malware analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Your job, as a malware analyst, is to discover exactly what happened to a system,
    and to make sure that the machines damaged by malicious software are isolated
    from the organization''s network. In order to perform malware analysis, we need
    to follow specific operations and approaches. When it comes to malware analysis,
    we have to perform three techniques: static malware analysis, dynamic malware
    analysis, and memory malware analysis. We are going to look at them one by one.'
  prefs: []
  type: TYPE_NORMAL
- en: Static malware analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first step in malware analysis is gathering all of the information about
    the malware. Static analysis is the art of collecting all of the available information
    about the malicious binary, using different techniques and utilities. In this
    phase, the analyst examines the malware without really executing it. Some common
    static malware analysis methods are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Online antivirus scanning**: Scanning the suspicious file using an online
    scanner is a good way to check the file, thanks to online environments that give
    you the ability to scan the file using many antivirus products. The most well
    known online scanner is VirusTotal. If you want to scan a file, just visit [https://www.virustotal.com/#/home/upload](https://www.virustotal.com/#/home/upload)
    and upload the file:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/00072.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'To automate the tasks, VirusTotal delivers some useful APIs. Thus, you can
    build your own Python script with a few lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00073.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'To scan `file.exe`, you could use the following code snippet from VirusTotal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: To obtain a key, just create a VirusTotal community account.
  prefs: []
  type: TYPE_NORMAL
- en: '**Hashing**: This is a technique to identify files. Each hashed file has a
    unique hash. The most commonly used hash functions are MD5 and SHA256.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Strings**: These are also great sources of information. Extracting strings
    from the malicious program will give us juicy information about the malware. Some
    strings include URIs, URLs, error messages, and comments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamic malware analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After collecting information about malware, you should run it in an isolated
    and secure environment. Generally, these environments are called **malware analysis
    sandboxes**. Sandboxes are loaded with analysis and monitoring tools to gather
    information about the malware while it is running. Malware analysts can collect
    the following information, and more:'
  prefs: []
  type: TYPE_NORMAL
- en: TCP connections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DNS summaries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Malware behaviors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: System calls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory malware analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Years ago, using the two previous techniques was enough to analyze malware,
    but attackers are now using new, more complicated techniques to avoid detection.
    I bet that you have heard about fileless malware. Memory malware analysis is needed
    to detect the new wave of malware. Memory malware analysis occurs by analyzing
    memory dumps collected from infected machines. In order to perform memory analysis,
    the analyst first needs to acquire memory (dumping memory), and can analyze it
    later by using many utilities and techniques.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the most used frameworks is the volatility framework. If you have installed
    a Kali Linux distribution, you can use volatility directly on your machine without
    installing it. The following screenshot was taken from a Kali Linux built-in volatility
    framework:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00074.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Volatility helps analysts to collect information from memory dumps, including
    the following, and more:'
  prefs: []
  type: TYPE_NORMAL
- en: Bash history
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API hooks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Network information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kernel-loaded modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Evasion techniques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Attackers and malware developers are continuously coming up with new techniques
    and methods to avoid detection. Some of the most common techniques are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Obfuscation**: This is the practice of making the malware more difficult
    to detect or analyze. Dead-code insertion, register reassignment, and crypting
    are three obfuscation techniques.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Binding**: This is the practice of binding a malware with a legitimate file,
    resulting in a single executable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Packing**: A packer, sometimes called a **self-extracting archive**, is a
    software that unpacks itself in memory when the *packed file* is executed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Portable Executable format files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Portable Executable** (**PE**) files are file formats for executables, DDLs,
    and object codes  used in 32-bit and 64-bit versions of Windows. They contain
    many useful pieces of information for malware analysts, including imports, exports,
    time-date stamps, subsystems, sections, and resources. The following is the basic
    structure of a PE file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00075.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Some of the components of a PE file are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**DOS Header**: This starts with the first 64 bytes of every PE file, so DOS
    can validate the executable and can run it in the DOS stub mode.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PE Header**: This contains information, including the location and size of
    the code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PE Sections**: They contain the main contents of the file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To explore the PE header's information, you can use many tools, such as PE EXPLORER,
    PEview, and PEstudio.
  prefs: []
  type: TYPE_NORMAL
- en: Machine learning malware detection using PE headers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To train our machine learning models to find malware datasets, there are a
    lot of publicly available sources for data scientists and malware analysts. For
    example, the following websites give security researchers and machine learning
    enthusiasts the ability to download many different malware samples:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Malware-Traffic-Analysis**: [https://www.malware-traffic-analysis.net/](https://www.malware-traffic-analysis.net/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Kaggle Malware Families**: [https://www.kaggle.com/c/malware-classification](https://www.kaggle.com/c/malware-classification)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**VX Heaven**: [http://83.133.184.251/virensimulation.org/index.html](http://83.133.184.251/virensimulation.org/index.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**VirusTotal**: [https://www.virustotal.com](https://www.virustotal.com)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**VirusShare**: [https://virusshare.com](https://virusshare.com)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To work with PE files, I highly recommend using an amazing Python library called `pefile`.
    `pefile` gives you the ability to inspect headers, analyze sections, and retrieve
    data, in addition to other capabilities, like packer detection and PEiD signature
    generation. You can check out the GitHub project at [https://github.com/erocarrera/pefile](https://github.com/erocarrera/pefile).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also install it with PIP, like we did with the other machine learning
    libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we installed `pefile` successfully:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00076.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s start to build our first malware classifier. For this model, we are
    going to use three different techniques:'
  prefs: []
  type: TYPE_NORMAL
- en: Random forests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gradient-boosting classification
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AdaBoost classification
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you may have noticed from the classification algorithms in this book, we
    are trying to use many different techniques. In some cases, you can use one of
    the previously discussed algorithms, but I am trying to use different techniques
    in every chapter, so that you can acquire a clear understanding of how to use
    each machine learning technique.
  prefs: []
  type: TYPE_NORMAL
- en: 'By now, you are aware that the first step to building a machine learning model
    (after studying the project needs and requirements, of course) is downloading
    a dataset. In this section, we are going to download a malware dataset delivered
    by a security blogger, Prateek Lalwani. The malware dataset contains features
    extracted from the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 41,323 Windows binaries (executables `.exe` and `.dlls`), as legitimate files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 96,724 malware files downloaded from the VirusShare website. So, the dataset
    contains 138,048 lines, in total.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The dataset is divided as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00077.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s start by loading the malware dataset using the `pandas` Python library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00078.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'To make sure that the dataset has loaded properly, let''s print the number
    of important features:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '`The Number of important features is 56` will be the resulting line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00079.gif)'
  prefs: []
  type: TYPE_IMG
- en: To improve the estimators' accuracy scores, we are going to use the `sklearn.feature_selection`
    module. This module is used in feature selection or dimensionality reduction in
    the dataset.
  prefs: []
  type: TYPE_NORMAL
- en: 'To compute the features'' importance, in our case, we are going to use tree-based
    feature selection. Load the `sklearn.feature_selection` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00080.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'So, the algorithms has selected nine important features for us. To print them
    out, use the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The most important features are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00081.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, it is time to train our model with a random forest classifier. Don''t
    forget to split the dataset, like we learned previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00082.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s look at the final result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00083.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'The score seems very promising. This model detected malware with a 99% success
    rate, which is a great result. To obtain more information about the `False positive`
    and `False negative` rates of our malware classifier, import the scikit-learn
    `confusion_matrix` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00084.gif)'
  prefs: []
  type: TYPE_IMG
- en: The `False positive rate` is 0.6%, and the `False negative rate` is 1.4%.
  prefs: []
  type: TYPE_NORMAL
- en: 'To train the model with another classifier, redo the previous steps, but instead
    of choosing the random forest classifier, select a machine learning algorithm.
    For example, I am going to select gradient-boosting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00085.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s check the second score:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00086.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'This has a 98.8% detection rate. The following is the score using the AdaBoost
    classifier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00087.gif)'
  prefs: []
  type: TYPE_IMG
- en: Machine learning malware detection using API calls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Analyzing malware with API calls plays a huge role in malware analysis. Thus,
    APIs can give malware analysts an idea about malware behavior, especially when
    basic, static analysis wasn't successful due to obfuscation techniques (like packers,
    crypters, and protectors). Malware analysts can gain an understanding of how a
    malicious file works by studying API calls. There are many online tools that will
    give you the ability to analyze malware in a secure environment. Those utilities
    and environments are called sandboxes. Malware that is detected is identified
    by a hash function (MD5 or SHA256). Malware analysts use hashing to sign a file.
    For example, the following APIs were taken from the report of an online malware
    scan with [https://www.hybrid-analysis.com](https://www.hybrid-analysis.com).
  prefs: []
  type: TYPE_NORMAL
- en: 'These are some details about  the malware "PE32 executable (GUI) Intel 80386,
    for MS Windows". Its hash is: 4c510779ab6a58a3bdbbe8d5f3ec568fcf33df81b0f1a5bdacabf78a9c62f492'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00088.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'According to the Microsoft website, [https://msdn.microsoft.com/](https://msdn.microsoft.com/),
    `GetProcAddress` retrieves the address of an exported function or variable from
    the specified **dynamic-link library** (**DLL**). So, if you want to learn more
    about the other calls, just go to the Microsoft developer network and search for
    the API call functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00089.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The report includes a full summary of the findings, not only the API calls.
    It includes:'
  prefs: []
  type: TYPE_NORMAL
- en: General information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Malicious indicators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unusual characteristics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Anti-detection/stealthiness
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Anti-reverse engineering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Network-related information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following are pieces of information about the scanned malware. We discussed
    most of the required findings (static analysis artifacts: size, type and so on)
    previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00090.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'For our second malware classifier, we are going to use API calls to build a
    machine learning malware detector. To extract APIs from malware binaries, the
    malware analyst needs to go through well-defined steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Malware unpacking
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assembly program retrieving
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: API call extraction
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Analyzing the API calls, using the official Microsoft website
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can categorize malware behaviors into groups. For example, the University
    of Ballarat categorized API calls into six categories in the article, *Towards
    Understanding Malware Behavior by the Extraction of API Calls*. You can use it
    to analyze your findings:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00091.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'As a demonstration, let''s build an Android malware detection project using
    a support vector machine learning algorithm fed by API calls dataset. This chapter''s
    GitHub folder contains a prepared dataset to build our model:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00092.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Before building the model, we need to import some useful modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00093.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'First, let''s pre-process our CSV file (`Android_Feats.csv`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00094.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'Identify the data and the labels in the file using NumPy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00095.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'By now, the processing phase is done. As seen previously, we need to extract
    the most important features, because computing all of the available features would
    be a heavy task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00096.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, divide the dataset (data and labels) into training and testing sets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00097.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'The feature selection has been successfully completed. To train the model,
    we are going to use the support vector machine classifier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00098.gif)'
  prefs: []
  type: TYPE_IMG
- en: Voila! The accuracy of our new model is 98%, which is a great detection rate.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Malware is one of the most prevalent cyber threats haunting the security of
    modern organizations. Black hat hackers are constantly improving; hence, classic
    detection techniques are obsolete, and AV products are often unable to detect
    advanced persistent threats. That is why machine learning techniques can help
    us to detect malware.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we learned how to build malware classifiers, using many machine
    learning algorithms and open source Python libraries. The next chapter will teach
    us how to build more robust systems to detect malware, using the same algorithm
    used by the human mind. We are going to learn how to use deep learning to detect
    malware  , using the same Python libraries used throughout this book.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You are now able to build a machine learning model. Let's practice, putting
    our new skills to the test. In this chapter's GitHub repository, you will find
    a dataset that contains information about Android malware samples. Now you need
    to build your own model, following these instructions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `Chapter3-Practice` GitHub repository, you will find a dataset that
    contains the feature vectors of more than 11,000 benign and malicious Android
    applications:'
  prefs: []
  type: TYPE_NORMAL
- en: Load the dataset using the `pandas` python library, and this time, add the `low_memory=False`
    parameter. Search for what that parameter does.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Prepare the data that will be used for training.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Split the data with the `test_size=0.33`  parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a set of classifiers that contains `DecisionTreeClassifier()`, `RandomForestClassifier(n_estimators=100)`,
    and `AdaBoostClassifier()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is an `AdaBoostClassifier()`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Train the model using the three classifiers and print out the metrics of every
    classifier.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For more information, check out the following log posts and documents:'
  prefs: []
  type: TYPE_NORMAL
- en: PE Format (Windows): [https://msdn.microsoft.com/en-us/library/windows/desktop/ms680547(v=vs.85).aspx](https://msdn.microsoft.com/en-us/library/windows/desktop/ms680547(v=vs.85).aspx)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Malware Analysis: An Introduction*:[https://www.sans.org/reading-room/whitepapers/malicious/malware-analysis-introduction-2103](https://www.sans.org/reading-room/whitepapers/malicious/malware-analysis-introduction-2103)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: VirusTotal documentation: [https://www.virustotal.com/en/documentation/](https://www.virustotal.com/en/documentation/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
