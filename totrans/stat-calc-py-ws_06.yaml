- en: 6\. Matrices and Markov Chains with Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we intend to foray into matrices and their applications using
    Python. We will look at different matrix manipulation techniques that will help
    us use them efficiently to build useful tools in real-world applications.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will understand matrices and be able to perform
    operations on them. You will implement one of the applications of matrices, known
    as Markov chains, using transition matrices and then use Markov chains and the
    Markov property to solve real-world problems.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A matrix is a rectangular array of numbers or expressions arranged in rows
    and columns and considered as a single entity. As we are considering a matrix
    as a single object, if we perform an operation on it, it will apply to each of
    the elements within it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1: A simple m × n matrix with m rows and n columns'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_06_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.1: A simple m × n matrix with m rows and n columns'
  prefs: []
  type: TYPE_NORMAL
- en: A simple linear single-dimension array rarely suffices for the physical world
    we live in, and almost all attributes related to space and time require more than
    one dimension. Compactness is one of the main reasons for the use of matrices.
    A matrix is compact when it is closed and bounded or simply has its points within
    a fixed distance of one another. Primarily for these two reasons, matrices find
    applications in practically every field, including fundamental mathematical concepts,
    ranging from graph theory, linear transformations, and probability theory, to
    different branches of physics, such as quantum mechanics and electromagnetism.
  prefs: []
  type: TYPE_NORMAL
- en: The Markov chain model and its variations are one such application, tying concepts
    of matrices, limits, and probability together to produce results in real-world
    problems where uncertainty is predominant. In a mathematical space, whenever there
    is uncertainty, decisions are based on probability; this forms the basis of Markov
    chains. These use a specific type of matrix, called a transition matrix, to build
    state diagrams. A Markov chain is effectively a memoryless process that is primarily
    based on the current state to decide the outcome of the next state. We find their
    application in some very important use cases, including page-rank algorithms,
    autocomplete applications, and text generators. We will be studying these concepts
    in more detail later in the chapter, and for that, we need to first understand
    matrices.
  prefs: []
  type: TYPE_NORMAL
- en: Matrix Operations on a Single Matrix
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will study the different ways of manipulating matrices and
    how to implement them in Python. Understanding how a matrix works broadly means
    understanding the fundamentals of how 2D or multidimensional arrays work. Once
    we have a good understanding of the basics of 2D matrices, those interested can
    delve into advanced studies of matrices, which includes special types of matrices
    such as sparse matrices, vector spaces, eigenvalues, and eigenvectors, which can
    involve more than two dimensions.
  prefs: []
  type: TYPE_NORMAL
- en: Matrices in Python can be implemented using either lists or arrays. Nested lists
    in Python work perfectly fine, but Python has a powerful package that makes matrix
    implementation much easier called NumPy. SciPy is another package that helps in
    matrix manipulation, but it is usually more suitable for larger matrix computations.
    We will be using both of these modules throughout this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Basic Operations on a Matrix
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is assumed at this point that you have the Python and its default libraries
    installed for running a basic Python program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have the package in place, let''s define our first matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This matrix is the same as the following matrix, `z`, which is simply better
    represented and, as a good practice, is advisable whenever possible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that in the preceding code, we have printed the type of the variable `z`.
    Can you guess the output? The output should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `ndarray` is the standard array format used by NumPy. The array object is
    homogenous, multidimensional, and has a data type object that is associated with
    it internally depending on its assignment.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s take an element in matrix `z`, which we defined previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We find that the elements of the given matrix are of the `int64` type, that
    is, the 64-bit integer type. Other data types include `np.float32`, `np.complex`,
    `np.bool`, `np.object`, `np.string_`, and `np.unicode_`.
  prefs: []
  type: TYPE_NORMAL
- en: For now, it is enough to know that pretty much every data structure that we
    build uses Python version 3.8 and NumPy version 1.17\. As of the date of publication,
    NumPy has a special class called a `matrix` class that does pretty much the same
    things that `ndarray` does. The only difference is that the `matrix` class maintains
    its 2D nature and has some operators built in, such as `*` for multiplication
    and `**` for power. Although the `matrix` class might come in handy and can be
    explored, the official NumPy documentation advises using a regular `ndarray` instead
    of `np.matrix` as it may be removed in the future. So, it is good to note here
    that the term `ndarray` in this context can be considered synonymous with the
    term `matrix` and will be used interchangeably in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Let's continue working with `ndarray`. Assuming we have a single matrix, we
    will see some of the simple operations that we can do with it. We can use the
    same matrix, `z`, that we defined previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s print the sum of the elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This is pretty straightforward. Let's now look at some other things that we
    can do.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s find the maximum, minimum, mean, and standard deviation of the `z` matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: There are a number of other operations that can be performed on an `ndarray`,
    including common mathematical functions such as sin, cos, log, and square root,
    and statistical functions, such as finding correlation coefficients and the cumulative
    sum, some of which we will be using shortly.
  prefs: []
  type: TYPE_NORMAL
- en: Inspecting a Matrix
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, we will deal with some useful functions that can help us learn more about
    any array that we are working with. Let''s continue to use the same matrix/`ndarray`,
    `z`, that we have been using so far:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s print the information of a matrix:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, to ascertain the shape of the matrix, write the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'To check whether the matrix is a 2D or 3D matrix, write the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'To print the data type of the matrix, use the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'To print the length of the matrix, use the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the `info` function already displays the values of the other
    two functions we have called, namely, shape and type. Nevertheless, these functions
    serve a limited purpose, and that is all that is required sometimes. The multidimensional
    `ndarray`, as we know, is an array of arrays, and the `len` function of the NumPy
    array will always be the length of the first dimension. If `z` is a 2D matrix,
    then `len(z)` will be the number of rows in `z`.
  prefs: []
  type: TYPE_NORMAL
- en: In the following exercise, we will create a matrix. We can pretty much create
    a matrix with a nested list, but this problem will elaborate on how matrices are
    packaged and utilized in the real world.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 6.01: Calculating the Time Taken for Sunlight to Reach Earth Each
    Day'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we will calculate the time it takes for sunlight to reach
    the Earth each day of the year.
  prefs: []
  type: TYPE_NORMAL
- en: As we know, the Earth revolves around the Sun in an elliptical orbit. As such,
    the distance between the Earth and the Sun changes, which will change the amount
    of time it takes for light to reach the Earth. There are three main equations
    that we can use to deal with this.
  prefs: []
  type: TYPE_NORMAL
- en: 'The mathematical formula to calculate time is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2: Formula to calculate time'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_06_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.2: Formula to calculate time'
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to calculate the distance, *r*, between the Earth and the Sun:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.3: Formula to calculate distance'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_06_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.3: Formula to calculate distance'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding equation, the value of *a* is 149,600,000 km, which is the
    semi-major axis distance, *e* is 0.0167, which is the eccentricity of Earth's
    orbit, and *θ* is the angle from perihelion.
  prefs: []
  type: TYPE_NORMAL
- en: 'The dependent variable *θ* that will be required in the preceding equation
    is calculated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.4: Formula for calculating the dependent variable'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_06_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.4: Formula for calculating the dependent variable'
  prefs: []
  type: TYPE_NORMAL
- en: Note here that *n* is the number of days from the perihelion that occurs on
    January 3rd. To keep things simple, we will take this to be the beginning of the
    year.
  prefs: []
  type: TYPE_NORMAL
- en: Do not get bogged down by these equations as they are nothing but simple mathematical
    multiplications of constants and can be easily solved by a nifty Python library
    called `math`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now get started with the exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, import the `math` and `numpy` libraries:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We will be using these libraries later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, define the two constants and use capitalization, which is the standard
    Python practice for naming these constants:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '`A` here is the semi-major axis distance between the Earth and the Sun.'
  prefs: []
  type: TYPE_NORMAL
- en: '`E` is known as the eccentricity of the Earth.'
  prefs: []
  type: TYPE_NORMAL
- en: '`l` is a list that we have initialized for storing the values later.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s jump into the main part of the code. For each of the `365` days, calculate
    `theta`, as it is different for each day of the year. Then, calculate the distance
    of the Earth from the Sun, and finally append that distance to a list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Note the use of the `math.pi` and `math.cos` functions from the `math` library
    that we imported previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'Calculate the time required in seconds, assuming the speed of light to be a
    constant value of 299,792 km/s:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Here, we first harness the power of NumPy arrays by using the `divide` function,
    which applies the values to all members of the list without having to use a loop.
    We store its values in `t`, which is type-casted automatically into a NumPy array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we do two things here. First, we use another useful Python function
    called `zip()`, which binds the respective elements of two lists together, and
    then we use the `np.asarray()` function, which converts the list of tuples into
    a NumPy array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the program to see the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We now have in systematic tabular format the values of distance between the
    Earth and the Sun and the time taken for light to reach the Earth. We can go on
    adding other parameters to our matrix, and that is the flexibility that comes
    with using matrices and NumPy arrays.
  prefs: []
  type: TYPE_NORMAL
- en: Please note here that these values are by no means accurate, and we have made
    a few safe assumptions for simplicity, but it is nevertheless a good illustration
    of how matrices can be utilized for practically anything. Also, note that the
    values reflected here are in scientific notation format used in Python and can
    easily be converted to float or any other type as required. The values on the
    left are in km, and the ones on the right are in the form 507.346... seconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'Append the results as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'A section of the output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/3irS3Bk.](https://packt.live/3irS3Bk
    )
  prefs: []
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/3abV9pe](https://packt.live/3abV9pe).
  prefs: []
  type: TYPE_NORMAL
- en: Operations and Multiplication in Matrices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we understand how to perform simple operations, let's perform a number
    of operations, such as resize, reshape, and transpose, over a matrix that results
    in the formation of a new matrix.
  prefs: []
  type: TYPE_NORMAL
- en: 'When indices of rows and columns in a matrix are exchanged, flipping them along
    the diagonal, this is known as the transpose of a matrix. Let''s now examine how
    to transpose a matrix. This can be done in three different ways, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run this code, the output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In method 3, we assign the value of the transpose matrix to a new variable that
    will hold the value.
  prefs: []
  type: TYPE_NORMAL
- en: The functions that we will now see are among the most widely used while you
    are performing matrix manipulation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first function we will be dealing with is flattening. The process of converting
    a matrix into a single row is known as the **flattening of a matrix**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now have a look at the various comparison operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, all the values inside a matrix are compared to a base value (in
    this case, `3`) and Boolean results are displayed against the corresponding indices
    in a matrix. The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'To check whether the value of `z` is less than `3`, use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '`reshape` is a function used to change the dimensions of a matrix according
    to the values passed for row and column inside the function. To reshape the matrix,
    use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'This produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'To resize the matrix, use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'This produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Note here how, when we use the `resize` function, the values are iteratively
    repeated until the size is met, even though all values from the original matrix
    may not be added. Also, note that the `reshape` function is often used instead
    of the `ravel` function to flatten the matrix.
  prefs: []
  type: TYPE_NORMAL
- en: Axes in a Matrix
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This relatively simple topic is easy to understand and equally easy to misunderstand
    and, hence, we need to deal with it independently. For arrays in Python, axes
    are defined for any matrix or array that has more than one dimension. When dealing
    with complex data science and data manipulation problems, oftentimes, we will
    need to deal with more than two dimensions, which is difficult to visualize and
    can be confusing. To simplify this, the dimensions in matrices are represented
    by axes.
  prefs: []
  type: TYPE_NORMAL
- en: Simply speaking, a 2D matrix will have two axes, horizontal and vertical, but
    in this case, they will be represented or named numerically. The first axis, called
    *axis 0*, runs vertically downward across rows, and the second, called *axis 1*,
    runs horizontally across columns.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same set of functions that we used earlier can be used to run along a single
    axis, which, in the case of large datasets, reduces the overhead of calculations.
    Let''s deal with some examples. For clarity, we will be creating a slightly larger
    matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'This produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: What happened here is that the maximum value is calculated along *each* of the
    axes. In the first array that is returned, the comparison is between `1` and `8`,
    `5` and `3`, `9` and `7`, and `4` and `6`, as those are the only two elements
    along axis 0\. Similarly, in the case of axis 1, the comparison is between the
    four elements along the subarrays and the maximum element is returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take another example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Can you guess the result? Let''s have a look at the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now look at one last, more complex, example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'This produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'What we have done is firstly use a concatenation function that accepts two
    arrays. The two arrays taken are simply the first and second elements of the array
    `z`, which are `[8 3 7 6]` and `[1 5 9 4]`, respectively. Since the two arrays
    each have a single dimension, we have taken them along axis 0\. If we had entered
    axis 1 here, NumPy would throw `AxisError`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'This produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Exercise 6.02: Matrix Search'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we will be searching for a given input value in a matrix that
    is sorted in ascending order, both row- and column-wise. This will help us understand
    the general rules of traversal inside a matrix, especially if we are not using
    a NumPy array.
  prefs: []
  type: TYPE_NORMAL
- en: To give a spoiler, we will be implementing a binary search over a matrix. Even
    if you have not dealt with a binary search before, this will be easy enough to
    follow.
  prefs: []
  type: TYPE_NORMAL
- en: 'The aim is to return a `True` or `False` value, depending on whether the value
    is present inside the matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s define the input matrix that we are going to search:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s define and write a function, `matrixsearch()`, that will take this
    matrix as an input along with the value we have to search. We will first be covering
    the edge cases, which, in this instance, means where a matrix is empty or the
    target value is non-zero:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will be defining four variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Please note here how `row` and `column` variables are initialized. In any matrix,
    this is exactly how they will be initialized, and it is worth understanding. The
    `start` and `end` variables are initialized as the first and last values in a
    matrix as the matrix is already sorted and can be treated as a single list, from
    starting to the diagonally opposite end.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now comes the actual logic of the program that we will be breaking down into
    a couple of steps to aid understanding. While looping from start to end, first
    we find the midpoint of the matrix (treating the matrix as a list):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we define a variable named `pointer`, which is initialized by the value
    of this middle value that we have found:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Please note that `/` is used for division, and `%` is used as a modulus here.
    Hence, in the first iteration, their values will be (1,1), respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we go to the heart of the binary search, where we increment or decrement
    our pointer by comparison with the value that we have. If we find the value, we
    return `True`, or else we keep looping until we can find or return `False` at
    the end if we cannot find anything:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: In this exercise, we implemented a binary search over a matrix using NumPy and,
    as per the values of the matrix, our code has returned `True`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/3eVd0Ch.](https://packt.live/3eVd0Ch
    )
  prefs: []
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/2ZusZkj.](https://packt.live/2ZusZkj
    )
  prefs: []
  type: TYPE_NORMAL
- en: Multiple Matrices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far, we have learned how to perform operations and manipulations when we
    have a single matrix. Next, we will be dealing with multiple matrices. The combination
    of matrices with Python is most commonly used today in data science as it requires
    the storage and processing of large arrays. Let''s start with a simple example.
    We will take two matrices, `z` and `x`, and multiply the values as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run the preceding code, you''ll see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The output shows that intuitively, the respective elements of the two matrices
    multiply to give a product value. This is simply the element-wise multiplication
    or, as it is known in mathematics, the Hadamard product.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now change matrix `x` slightly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: What we get here is `ValueError`, due to the property of arrays in NumPy known
    as broadcasting.
  prefs: []
  type: TYPE_NORMAL
- en: Broadcasting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is important to understand the concept of broadcasting so that we know what
    is allowed and not allowed while using arrays for matrix operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'In simple terms, broadcasting is the NumPy way of handling two arrays that
    have different shapes. As a general rule, the array that is smaller among the
    two will be broadcasted across the larger array in a certain way to make them
    compatible. The general rules for broadcasting as per the official documentation
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: It starts with trailing dimensions working their way forward.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The two dimensions of comparison are equal when one of them is 1, or when they
    both are equal.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can also refer to the official documentation at [https://docs.scipy.org/doc/numpy/user/basics.broadcasting.html](https://docs.scipy.org/doc/numpy/user/basics.broadcasting.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'So, as we saw in the earlier examples, when multiplied by matrices of equal
    dimensions and by a scalar variable, multiplication works perfectly. On the other
    hand, if the dimensions of the two matrices are different, `ValueError` will be
    thrown as NumPy was not efficiently able to broadcast the values of a smaller
    matrix across the larger matrix. This broadcasting is primarily done internally
    to make the arrays faster and more memory efficient. It provides a way to vectorize
    the array to implement the looping in C instead of Python, which effectively makes
    it faster. An important thing to remember here is in the case of a pair of NumPy
    arrays, the operations are done on an element-by-element basis. To help overcome
    the problem with the dimensions, the two main methods employed are `reshape` and
    `newaxis`. Before we wrap this up, let''s look at one more variation to the concept
    of broadcasting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Any guesses what the output will look like? Let''s have a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Since the array `z` here is not a regular square-shaped array, NumPy internally
    does not interpret it as a matrix, treating it as a regular row of objects and
    performing element-by-element multiplication on it. So, `z[0]` is multiplied by
    `x[0]`, and `z[1]` is multiplied by `x[1]` to produce objects that happen to be
    a list in this case.
  prefs: []
  type: TYPE_NORMAL
- en: Operations on Multiple Matrices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will now be performing operations between two or more matrices and see the
    functions that will help us to achieve that. We will be covering how to write
    an inverse of a matrix, logical operators, dot products, eigenvalues and eigenvectors,
    outer products, and the determinates of a matrix.
  prefs: []
  type: TYPE_NORMAL
- en: It should be noted that there are plenty of other things you can do with matrices,
    and the official NumPy documentation is a really good resource for referencing
    information according to the requirements of the user. Most of the topics that
    we are going to cover are part of the linear algebra package of the NumPy library.
    There are far wider applications in physics and mathematics that are beyond the
    scope of this chapter for each of the topics we are going to cover, but it should
    suffice to know that they all play a very important role in understanding matrices.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: For more information about the NumPy library, refer to [https://docs.scipy.org/doc/numpy/reference/](https://docs.scipy.org/doc/numpy/reference/).
  prefs: []
  type: TYPE_NORMAL
- en: Identity Matrix
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Identity matrices have ones along the diagonal, and zeros everywhere else.
    We will be creating identity matrices using the `linalg` function of NumPy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: The eye Function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An `eye` function is similar to an identity matrix, except for one difference,
    which is that you can offset the value of the matrix. This means that it will
    create an identity matrix starting from the kth row, as you can see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Inverse of a Matrix
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Inverse or multiplicative inverse is the matrix that produces an identity matrix
    when you multiply it by the original matrix. The inverse of a matrix is most commonly
    used when applied in 3D geometry and graphics:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'This produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: We have two outputs here. The first one is what is called the inverse of the
    matrix, and the second one is where we have multiplied the inverse by the original
    matrix using the `dot` function to produce the identity matrix. The values displayed
    are floats and should not be a point of concern.
  prefs: []
  type: TYPE_NORMAL
- en: Logical Operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will be creating two lists here, containing binary `True` (1) or `False`
    (0) values. We will see the output of using the `AND` operation on them by using
    the built-in `logical_and()` function of NumPy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Pretty straightforward. You can similarly use 1s and 0s instead of `True` and
    `False` and it still gives the results. In fact, as long as it is not 0, it is
    considered to be `True`. Let''s see an example with 1s and 0s:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'This output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: The same thing can be done for other logical functions using the `logical_or`,
    `logical_not`, and `logical_xor` functions.
  prefs: []
  type: TYPE_NORMAL
- en: Outer Function or Vector Product
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`np.outer` is the function that is used to produce a vector or the cross product
    of two matrices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'This produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: So far, we have learned all the different ways in which we can use matrices.
    By no means can the list of methods we use be considered restrictive, and it is
    always a good practice to explore the libraries in detail as and when a certain
    manipulation needs to be done. It is also worth mentioning again that there are
    several specific types of matrices that have a limited use case depending on the
    requirements of the field in which the work is done.
  prefs: []
  type: TYPE_NORMAL
- en: Solving Linear Equations Using Matrices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Linear equations are the foundational blocks of algebra, and anyone who has
    studied basic elementary mathematics knows how they work. Let's cover them briefly,
    and we can then see how easily they can be solved using matrices in Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'Linear equations are typically in the form:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.5: Formula for calculating linear equations'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_06_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.5: Formula for calculating linear equations'
  prefs: []
  type: TYPE_NORMAL
- en: Here, *a*1, *a*2,.., *a*n are the coefficients, and *x*1, *x*2,.. *x*n are variables.
  prefs: []
  type: TYPE_NORMAL
- en: These linear equations with two variables can be represented in a two-dimensional
    space graph where *x* is the horizontal dimension and *y* is the vertical dimension.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a quick example of a linear equation with two variables. Suppose
    the equation is *y = 2x + 6*. This representation is known as the **slope-intercept**
    form and has the format *y = mx + c*, where *m* is the slope and *c* is the *y*
    intercept of the equation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, *m=2* and *c=6*, and the line can be drawn on a graph by plotting different
    values of *x* and *y*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.6: Representation of y = 2x + 6 in a 2D space'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_06_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.6: Representation of y = 2x + 6 in a 2D space'
  prefs: []
  type: TYPE_NORMAL
- en: Without getting into much detail, we can imagine that there may be another line
    in the plane that will either be parallel to the line or will intersect this line.
    The linear equations intend to find the intersecting point of these lines and,
    based on the value of the intersecting common point, find the values of the variables
    *x* and *y*. As the number of dimensions increase, it becomes difficult to visualize,
    but fundamentally, the concept remains the same. Matrices greatly simplify the
    process of solving these equations. There are typically two matrices, one that
    contains the coefficient of *x* and *y*, and the other containing the variables
    *x* and *y*. Their dot product yields the resultant matrix, which is the constant
    or the *y* intercept mentioned previously. It is fairly easy to understand once
    we look at a quick exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 6.03: Use of Matrices in Performing Linear Equations'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will now solve a linear equation problem using matrices.
  prefs: []
  type: TYPE_NORMAL
- en: John is out of town for three days and in a mood to spend until he exhausts
    his resources. He has three denominations of currency with him. On the first day,
    John spends $435 on the latest electronic tablet that he likes, on which he spends
    `37` of type *a* denomination, `20` of type *b*, and `12` of type *c*. On the
    second day, he goes skydiving and spends `15`, `32`, and `4` of denominations
    *a*, *b*, and *c*, respectively, a total of $178\. On the third day, with whatever
    amount he is left with, he decides to go to the theatre, which costs $70, and
    he shells out `5`, `40`, and `2` of the *a*, *b*, and *c* denominations, respectively.
    Can you tell what the values of the respective denominations are?
  prefs: []
  type: TYPE_NORMAL
- en: Looking at the problem, we can tell that there are three equations and three
    unknown variables that we need to calculate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s put the values we know for three days in a matrix using NumPy arrays:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'We now have the matrix that we need to work with. There are a few ways to solve
    this. In essence, this is what we need to do:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Ax = b*'
  prefs: []
  type: TYPE_NORMAL
- en: Where *A* is the matrix whose values we know, *x* is the matrix with unknown
    variables, and *b* is the resultant matrix.
  prefs: []
  type: TYPE_NORMAL
- en: 'The resultant *b* matrix will be as follows. These are the amounts that John
    spent on the three given days:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'There are a couple of ways to solve this problem in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Method 1**: Finding *x* by doing x = A-1b:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first calculate the inverse of matrix A with the help of the function
    we learned earlier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: We will be using a dot product of the matrix and not pure multiplication, as
    these are not scalar variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: It is not necessary here to understand this matrix as it is just an intermediary
    step.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we take the dot product of the two matrices to produce a matrix, `X`,
    which is our output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '**Method 2**: Using in-built methods in the `linalg` package:'
  prefs: []
  type: TYPE_NORMAL
- en: This same thing can be done even more easily with the help of another NumPy
    function called `solve()`. Let's name the output variable here as `y`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'This produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: And in a single line, we were able to solve the linear equation in Python. We
    can extrapolate and comprehend how similar equations with a large number of unknown
    variables can be easily solved using Python.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, we can see that the output after using both methods 1 and 2 is the same,
    which is $10, 25 cents, and $5, which are the respective denominations that we
    were trying to establish.
  prefs: []
  type: TYPE_NORMAL
- en: What if we were receiving the information about John's expenses iteratively
    instead of in one go?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first add the information that we received about John''s expenses:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, let''s also add the information received relating to John''s other two
    expenses:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'We can easily bind these arrays together to form a matrix using the `concat()`
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'This produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: This was the same input that we used for the preceding program.
  prefs: []
  type: TYPE_NORMAL
- en: Again, if we have a lot more of these, we might apply loops to form a larger
    matrix, which we can then use to solve the problem.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/3eStF9N.](https://packt.live/3eStF9N
    )
  prefs: []
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/38rZ6Fl.](https://packt.live/38rZ6Fl
    )
  prefs: []
  type: TYPE_NORMAL
- en: Transition Matrix and Markov Chains
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we will be looking at one of the applications of matrices, which is a field
    of study all by itself. Markov chains make use of transition matrices, probability,
    and limits to solve real-world problems. The real world is rarely as perfect as
    the mathematical models we create to solve them. A car may want to travel from
    point A to B, but distance and speed prove insufficient parameters in reality.
    A cat crossing the street may completely alter all the calculations that were
    made to calculate the time traveled by the car. A stock market may seem to be
    following a predictable pattern for a few days, but overnight, an event occurs
    that completely crashes it. That event may be some global event, a political statement,
    or the release of company reports. Of course, our development in mathematical
    and computational models has still not reached the place where we can predict
    the outcome of each of these events, but we can try and determine the probability
    of some event happening more than others. Taking one of the previous examples,
    if the company reports are to be released on a particular date, then we can expect
    that a particular stock will be affected, and we can model this according to market
    analysis done on the company.
  prefs: []
  type: TYPE_NORMAL
- en: Markov chains are one such model, in which the variable depending on the Markov
    property takes into account only the *current state* to predict the outcome of
    the next state. So, in essence, Markov chains are a memoryless process. They make
    use of transition state diagrams and transition matrices for their representations,
    which are used to map the probability of a certain event occurring given the current
    event. When we call it a memoryless process, it is easy to confuse it with something
    that has no relation to past events, but that is not actually the case. Things
    are much easier to understand when we take an example to illustrate how they work.
    Before we jump into using Markov chains, let's first take a deeper look at how
    transition states and matrices work and why exactly they are used.
  prefs: []
  type: TYPE_NORMAL
- en: Fundamentals of Markov Chains
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To keep things simple, let's break the concepts down into pieces and learn about
    them iteratively from the information that we have before we can put them together
    to understand the concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Stochastic versus Deterministic Models
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When we are trying to solve real-world problems, we often encounter situations
    that are beyond our control and that are hard to formulate. Models are designed
    to emulate the way a given system functions. While we can factor in most of the
    elements of the system in our model, many aspects cannot be *determined* and are
    then emulated based on their likelihood of happening. This is where probability
    comes into the picture. We try and find the probability of a particular event
    happening given a set of circumstances. There are two main types of models that
    we use, deterministic and stochastic. Deterministic models are those that have
    a set of parameter values and functions and can form a predictable mathematical
    equation and will provide a predictable output. Stochastic models are inclusive
    of randomness, and even though they have initial values and equations, they provide
    quantitative values of outcomes possible with some probability. In stochastic
    models, there will not be a fixed answer, but the likelihood of some event happening
    more than others. Linear programming is a good example of deterministic models,
    while weather prediction is a stochastic model.
  prefs: []
  type: TYPE_NORMAL
- en: Transition State Diagrams
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Broadly, these form the basis for object-oriented programming, where you can
    describe all possible states that object can have based on given events and conditions.
    The *state* is that of the object at a given moment in time when a certain previous
    condition is met. Let''s illustrate this with an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.7: State transition diagram for a fan'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_06_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.7: State transition diagram for a fan'
  prefs: []
  type: TYPE_NORMAL
- en: This is the state transition diagram for the regulator of a table fan, which
    usually changes state every time we turn it clockwise until it turns back to the
    `Off` position.
  prefs: []
  type: TYPE_NORMAL
- en: Here, the state of the table fan is changing in terms of the speed, while the
    action is that of twisting. In this case, it is based on events, while in some
    other cases it will be based on a condition being met.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take an example in text generation using the Markov chain that is in
    line with what we are going to implement. We will recall the first two lines of
    a nursery rhyme:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Humpty Dumpty sat on a wall,*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Humpty Dumpty had a great fall.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s prepare a frequency table of all the words present in the sentence:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.8: Frequency table of words in the rhyme'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_06_08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.8: Frequency table of words in the rhyme'
  prefs: []
  type: TYPE_NORMAL
- en: 'Tokens are the number of words present, while keys are unique words. Hence,
    the values will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Tokens = 12*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Keys = 9*'
  prefs: []
  type: TYPE_NORMAL
- en: 'We may not even require everything we learn here, but it will be important
    once you decide to implement more complicated problems. Every transition diagram
    has a start and end state, and so we will add these two states here as keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.9: Frequency table of start and end states'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_06_09.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.9: Frequency table of start and end states'
  prefs: []
  type: TYPE_NORMAL
- en: 'We then prepare a state chart to show the transition from one state to the
    next. In this case, it requires showing which word will follow the current word.
    So, we will be forming pairs as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.10: Word pairs'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_06_10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.10: Word pairs'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we condense this according to keys instead of tokens, we will see that there
    is more than one transition for some keywords, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.11: More than one transition for some keywords'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_06_11.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.11: More than one transition for some keywords'
  prefs: []
  type: TYPE_NORMAL
- en: This is done not only to reduce the state transitions, but also to add meaning
    to what we are doing, which we will see shortly. The whole purpose of this is
    to determine words that can pair with other words. We are now ready to draw our
    state transition diagram.
  prefs: []
  type: TYPE_NORMAL
- en: 'We add all the unique keys as states, and show which states these words can
    transition to:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.12: State transition diagram'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_06_12.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.12: State transition diagram'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we look at the preceding diagram, we can follow any word to complete the
    rhyme from the set of conditions given. What remains is the probability of the
    keywords occurring after the given word. For that, look at the following diagram,
    and we can see in a fairly straightforward manner how the probability is divided
    between keywords according to their frequency. Note that Humpty is always followed
    by Dumpty, and so will have a probability of `1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.13: State transition diagram with probability'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_06_13.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.13: State transition diagram with probability'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have discussed the state transition diagrams, we will move on to
    drawing transition matrices.
  prefs: []
  type: TYPE_NORMAL
- en: Transition Matrices
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the Markov process, we need to show the probability of state transitions
    in mathematical format for which transition matrices are used. The rows and columns
    are simply the states of the transition diagram. Each value in the transition
    matrix shows the probability of transition from one state to another. As you can
    imagine, many of the values in such matrices will be 0\. For the problem discussed
    earlier, the transition matrix will have 9 states and lots of 0s. We will take
    a simpler example of a transition diagram and find its corresponding matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.14: State diagram with states 1, 2, and 3'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_06_14.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.14: State diagram with states 1, 2, and 3'
  prefs: []
  type: TYPE_NORMAL
- en: When we look at this diagram, we see the three transition states. Note that
    we have not included the start and end states explicitly here, but they can be
    necessary in certain cases. The outward arrows represent the transition from one
    state to the next. Once we have the diagram, it is easy to draw the matrix. Write
    rows and columns equal to the states of the diagram. In this case, it will be
    3\. Then, the 0th row will show the transition for the 1st state, the 1st row
    will show the second state, and so on. To generalize, each row in the matrix represents
    the transition probabilities of one state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first look at the matrix, and we can then discuss a couple more things:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.15: Transition matrix'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_06_15.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.15: Transition matrix'
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the property of rows, we can observe one more thing. The sum
    of all probabilities in a given row will always be equal to 1\. In the first row
    here, the sum will be *1/5 + 2/5 + 2/5 = 5/5 = 1*. This is because these states
    are exhaustive.
  prefs: []
  type: TYPE_NORMAL
- en: If there is no transition between two given states, the value of the states
    in that matrix will be 0\. We can verify this by comparing the number of values
    present in the matrix with the number of state transitions we can see in the diagram.
    In this case, they are both equal to 7.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 6.04: Finding the Probability of State Transitions'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Given an array containing four states, `A`, `B`, `C`, and `D`, that are randomly
    generated, let's find the probability of transition between these four states.
    We will be finding the probability of each state transition and form a transition
    matrix from it.
  prefs: []
  type: TYPE_NORMAL
- en: Let's generate a transition matrix in Python from a given array of inputs. We
    will extrapolate the same concept in the future while creating Markov chains.
  prefs: []
  type: TYPE_NORMAL
- en: 'Generate an array of random states out of the characters `A`, `B`, `C`, and
    `D` using the `random` package in Python. We will then define how many elements
    we want by creating a constant, `LEN_STR`, which, in this case, we will set to
    `50`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'This produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The use of another constant, `LEN_TOKENS`, which we created from the length
    of the string, will indicate the number of states that will be present in the
    problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will be finding the relative values of letters and converting them
    into integers, primarily because integers are easier for calculations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'This produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: We have used cardinal values here for convenience, but we could have also done
    this by using a dictionary or some other method. If you are not aware, the `ord()`
    function here returns the ASCII value of characters in the string. For example,
    the ASCII values for `A` and `D` are `65` and `68`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, find the difference between these ASCII values and put them in a list,
    `ti`. We could have also updated the token list in situ, but we are keeping them
    separate simply for clarity:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'This produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: We have now initialized a matrix of zeros depending on the size of the `LEN_TOKENS`
    constant we generated earlier and used that to build a zero matrix.
  prefs: []
  type: TYPE_NORMAL
- en: In the second part, we are creating tuples of pairs, as we did in the earlier
    problem, and updating the frequency of the transition matrix according to the
    number of transitions between two states. The output of this is the last line
    in the preceding code.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: We are iteratively choosing to update the value of matrix *m* in each step instead
    of creating new matrices.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now be generating the probability, which is merely the relative frequency
    in a given row. As in the first row, the transition from A to A is 8, and the
    total transitions from A to any state are 20\. So, in this case, the probability
    will be *8/20 = 0.4*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: The code goes like that for every row and, if the `sum` function is greater
    than `0`, we find the probability. Note here that the `float` function is used
    to avoid type conversion to `int` in some versions of Python. Also, note the use
    of `state[:]`, which creates a shallow copy and thereby prevents conflicts of
    type conversions internally.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s print the `state` object by adding the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: Here, we iterate through the rows in a matrix and print out the values, and
    this is our transition matrix.
  prefs: []
  type: TYPE_NORMAL
- en: 'This produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: Thus, we are able to construct a transition matrix for describing state transitions,
    which shows us the probability of transition from one state to the next. Hence,
    the likelihood of `A` finding `A` as the next letter is `0.4`, `A` going to `B`
    will be `0.15`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/31Ejr9c.](https://packt.live/31Ejr9c
    )
  prefs: []
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/3imNsAb.](https://packt.live/3imNsAb
    )
  prefs: []
  type: TYPE_NORMAL
- en: Markov Chains and Markov Property
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Transition states and matrices essentially cover the majority of Markov chains.
    Additionally, there are a few more things worth understanding. As mentioned earlier,
    the Markov property applies when variables are dependent on just the current state
    for their next state. The probabilistic model formed may determine the likelihood
    of the outcome from the current state, but the past state is seen as independent
    and will not affect the result. Take a coin toss; we may create a chart of probabilities
    of heads or tails, but that will not determine the outcome.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Markov property should essentially meet two criteria:'
  prefs: []
  type: TYPE_NORMAL
- en: It should only be dependent on the current state.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It should be specific for a discrete time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Without getting too confused, the time considered in models is either discrete
    or continuous. The flipping of a coin can be considered a discrete-time event
    because it has a definite outcome, such as heads or tails. On the other hand,
    weather patterns or stock markets are continuous-time events; weather, for example,
    is variable throughout the day and does not have a start and end time to measure
    when it changes. To deal with such continuous events, we require techniques such
    as binning to make them discrete. Binning, in simple terms, means grouping data
    in fixed amounts based on quantity or time. As a Markov chain is memoryless, it
    essentially becomes a discrete-time and state-space process.
  prefs: []
  type: TYPE_NORMAL
- en: There are special matrices that are built for specific purposes. For example,
    sparse matrices are extensively used in data science as they are memory- and computationally-efficient.
    We did not deal too much with the manipulation of elements within the matrix as
    that is essentially like dealing with a list of lists, but it is worthwhile spending
    some time on this in the future.
  prefs: []
  type: TYPE_NORMAL
- en: Other than Markov chains, there are a few more models for random processes.
    These include autoregressive models, Poisson models, Gaussian models, moving-average
    models, and so on. Each deals with the aspect of randomness differently, and there
    are supporting libraries in Python for almost all of them. Even within Markov
    chains, there are complicated topics involving multidimensional matrices or second-order
    matrices, Hidden Markov models, MCMC or Markov chain Monte Carlo methods, and
    so on. You have to make your own choice of how deep you want to go down the rabbit
    hole.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 6.01: Building a Text Predictor Using a Markov Chain'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The aim of this activity is to build our very own text predictor based on what
    we have learned. We will take the transcripts of a speech from a famous leader
    and build a text predictor based on the content of the speech using a Markov chain
    model and state transitions. Perform these steps to achieve the goal:'
  prefs: []
  type: TYPE_NORMAL
- en: First, find a suitable, sufficiently large transcript of a speech given by a
    famous person, such as a scientist or a political or spiritual leader of your
    choice. To get you started, a sample text with the filename `churchill.txt` is
    added to the GitHub repository at [https://packt.live/38rZy6v](https://packt.live/38rZy6v).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generate a list that describes state transition by showing a correlation between
    a given word and the words that follow it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Sort through the list you have made and make a hash table by grouping the words
    that follow a given word in different positions. For example, these follow-up
    words will group to form *John: [cannot, completely, thought, …]*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*John cannot…, John completely…, and John thought ..,*'
  prefs: []
  type: TYPE_NORMAL
- en: Use a random word generator to generate and assign a value to the first word.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, create a random generator that will create a sentence based on the
    transition states that we have declared.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hints
  prefs: []
  type: TYPE_NORMAL
- en: This activity requires a few Python methods that you should be familiar with.
  prefs: []
  type: TYPE_NORMAL
- en: To get you started, you can read in the transcript from a text file using `open('churchill.txt').read()`,
    and then split it into a list of words using `split()`.
  prefs: []
  type: TYPE_NORMAL
- en: You can then iterate through the list and append the elements to a new list,
    which will store the keyword and the word following it.
  prefs: []
  type: TYPE_NORMAL
- en: Then, use a dictionary to form a key-value pair for each tuple in your new list.
  prefs: []
  type: TYPE_NORMAL
- en: A random word corpus can be generated using the `np.random()` function.
  prefs: []
  type: TYPE_NORMAL
- en: The sentence formation comes from joining together the elements of the list
    that we generated.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution to this activity can be found on page 677.
  prefs: []
  type: TYPE_NORMAL
- en: 'This way, we have made our own text predictor. Such a text predictor can be
    considered a foundational step in terms of the vast and fast-growing field of
    text generators. It is far from perfect; there are several reasons for this, some
    of which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The text sample that we have chosen is usually many times larger than the one
    we have chosen. Our text contains about 22,000 words while, in practice, millions
    of words are fed as data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a lot better moderation in terms of the stop words, punctuation, and
    beginning/ending of sentence formations using the proper rules of NLP that is
    not applied here.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have used a simple random generator to select our words, while actual models
    use probability and statistical models to generate significantly more accurate
    outputs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Having said that, we have completed our first text predictor, and more complicated
    text predictors are fundamentally based on the way we have described them.
  prefs: []
  type: TYPE_NORMAL
- en: Though by no means can this be considered smooth, we have still written our
    first text predictor with just a few lines of code, and that is a great start.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we were able to cover the topic of matrices, which is fundamental
    to a number of topics, both in mathematics and in using Python. Data science today
    is primarily based on the efficient use of matrices. We studied their application
    in the form of Markov chains and, although an important topic, there is no dearth
    of topics to explore that come under the umbrella of applications using matrices.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will delve into the world of statistics. We will use a more formal
    and systematic approach in first understanding the building blocks of statistics,
    then understanding the role of probability and variables, and finally tying these
    concepts together to implement statistical modeling.
  prefs: []
  type: TYPE_NORMAL
- en: YKA34
  prefs: []
  type: TYPE_NORMAL
- en: LHL39
  prefs: []
  type: TYPE_NORMAL
