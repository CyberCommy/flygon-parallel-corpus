- en: Performance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Performance is considered a primary criterion when it comes to RESTful web services
    in an application. This chapter will focus mainly on how we can improve the performance
    in our application and reduce the response time. Though performance optimization
    techniques can be applied in different layers of web applications, we will talk
    about the RESTful (web) layer. The remaining performance optimization techniques
    will be discussed in [Chapter 11](c3ef97e3-fbad-4b9e-b7f8-91c6d3d6c6f0.xhtml),
    *Scaling*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be discussed in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: HTTP compression
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTTP caching and HTTP cache control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cache implementation in the REST API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using HTTP If-Modified-Since headers and ETags
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTTP compression
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to get content quickly from a REST service, data can be compressed
    and sent over protocols such as HTTP. While compressing data, we will have to
    follow some encoding format, so the same format will be applied on the receiver
    side.
  prefs: []
  type: TYPE_NORMAL
- en: Content negotiation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While requesting a resource in the server, the client will have many options
    to receive the content in various representations. For example, DOC/PDF is the
    data type representation. Turkish or English is the language representation, where
    the server can send the resource in a particular language. There must be some
    agreement between the server and the client about which format the resource will
    be accessed in, such as language, data type, and so on. The process is called
    **content negotiation**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we will talk about two different content negotiation mechanisms: server-driven
    and agent-driven mechanisms. Before moving on to these mechanisms, we will talk
    about Accept-Encoding and Content-Encoding, as they are important.'
  prefs: []
  type: TYPE_NORMAL
- en: Accept-Encoding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The client will tell the server about which compression algorithm(s) it can
    receive. The most common types of encoding are `gzip` and `deflate`. While requesting
    the server, the client will share encoding types in the request headers. Accept-Encoding
    will be used for such purposes. Simply put, the client will say, "I will accept
    only the mentioned compression formats" to the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will see sample `Accept-Encoding` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding header, the client says that it can accept only `gzip` or `deflate`
    in the response.
  prefs: []
  type: TYPE_NORMAL
- en: 'Other possible options are mentioned as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We can see the `compress` value followed by `q=0.5`, which means the quality
    rating is only `0.5` when compared to the `gzip` rating of `q=1.0`, which is very
    high. In this case, the client is recommending the server that it can get `gzip`
    over `compress`. However, if `gzip` is not possible, `compress` is fine for the
    client.
  prefs: []
  type: TYPE_NORMAL
- en: If the server doesn't support the compression algorithm that the client requested,
    the server should send an error response with the `406 (Not Acceptable)` status
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Content-Encoding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Content-Encoding is an entity header that is used to compress the data type
    to be sent to the client from the server. The Content-Encoding value tells the
    client which encodings were used in the entity-body. It will tell the client how
    to decode the data to retrieve the value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at the single and multiple encoding options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding configuration, single and multiple options are provided on
    Content-Encoding. Here, the server tells the client that it can offer `gzip` and
    `compress` algorithm-based encoding. If the multiple encoding is mentioned by
    the server, those encodings will be applied in the mentioned order.
  prefs: []
  type: TYPE_NORMAL
- en: Compressing data as much as possible is highly recommended.
  prefs: []
  type: TYPE_NORMAL
- en: Changing Content-Encoding on-the-fly is not recommended. As it will collapse
    future requests (such as `PUT` on `GET`), changing Content-Encoding on the fly
    is not a good idea at all.
  prefs: []
  type: TYPE_NORMAL
- en: Server-driven content negotiation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Server-driven content negotiation is performed by server-side algorithms to
    decide on the best representation that the server has to send to the client. It's
    also called proactive content negotiation. In server-driven negotiation, the client
    (user-agent) will give options of various representations with quality ratings.
    Algorithms in the server will have to decide which representation would work best
    for client-provided criteria.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the client requests a resource by sharing the media type criterion,
    with ratings such as which media type would be better for the client. The server
    will do the rest of the work and supply the best representation of the resource
    that suits the client's needs.
  prefs: []
  type: TYPE_NORMAL
- en: Agent-driven content negotiation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Agent-driven content negotiation is performed by algorithms on the client side.
    When the client requests a particular resource, the server will tell the client
    about various representations of the resource, with metadata such as content type,
    quality, and so on. Then the client side algorithms will decide which will be
    the best and request it from the server again. This is also called reactive content
    negotiation.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP caching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When the client requests the same resource representation many times, it will
    be a waste of time to provide it from the server side and it will be time-consuming
    in web applications. Instead of talking to the server, if the the resource is
    reused it will definitely improve the web application performance.
  prefs: []
  type: TYPE_NORMAL
- en: Caching will be considered a primary option for bringing performance to our
    web application. Web caches avoid server contact multiple times and reduce the
    latency; hence, the application will be faster. Caching can be applied on different
    layers of an application. In this chapter, we will only talk about HTTP caching,
    which is considered a middle layer. We will dig more into other forms of caching
    in [Chapter 11](c3ef97e3-fbad-4b9e-b7f8-91c6d3d6c6f0.xhtml), *Scaling*.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP cache control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cache control is a header field that specifies directives for caching operations
    on the web. These directives give the caching authorization, define the duration
    of the caching, and so on. The directives define the behavior, usually intended
    to prevent caching responses.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we will talk about HTTP caching directives: the `public`, `private`,
    `no-cache`, and `only-if-cached` directives.'
  prefs: []
  type: TYPE_NORMAL
- en: Public caching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If the cache control allows public caching, the resource can be cached by multiple
    user cache. We can do this by setting the `public` option in the `Cache-Control`
    header. In public caching, the response may be cached by multiple user cache,
    even the non-cacheable or cacheable, only within a non-share cache:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding setting, `public` indicates that the response can be cached
    by any cache.
  prefs: []
  type: TYPE_NORMAL
- en: Private caching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Unlike public caching, private responses are applicable for a single user cache,
    not for a shared cache. In private caching, intermediates can''t cache the content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The preceding setting indicates that the response is available for a single
    user only, and it should not be accessed by any other caches.
  prefs: []
  type: TYPE_NORMAL
- en: Also, we can specify how long the content should be cached in our heading settings.
    This can be done by the `max-age` directive option.
  prefs: []
  type: TYPE_NORMAL
- en: 'Check the following setting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding setting, we mentioned that the response can be cached in private
    mode (single user only) and the maximum amount of time the resource will be considered
    fresh.
  prefs: []
  type: TYPE_NORMAL
- en: No-cache
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Caching might not be needed for accessing dynamic resources. In such situations,
    we can use a `no-cache` setting in our cache control to avoid client-side caching:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The preceding setting will tell the client to check the server whenever the
    resource is being requested.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, in some situations, we may need to disable the caching mechanism itself.
    This can be done using `no-store` in our setting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The preceding setting will tell the client to avoid resource caching and get
    the resource from the server always.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP/1.0 caches will not follow the no-cache directive, as it was introduced
    in HTTP/1.1
  prefs: []
  type: TYPE_NORMAL
- en: 'Cache control was introduced only in HTTP/1.1\. In HTTP /1.0, only **Pragma:
    no-cache** is used to prevent responses being cached.'
  prefs: []
  type: TYPE_NORMAL
- en: Only-if-cached
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In some scenarios, like poor network connectivity, a client might want to return
    the cached resource and not reload or revalidate with the server. To achieve this,
    the client can include the `only-if-cached` directive in the request. If it is
    received, the client will get the cached entry, or else respond with a `504` (gateway
    timeout) status.
  prefs: []
  type: TYPE_NORMAL
- en: These cache control directives can override the default caching algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have discussed various cache control directives and their explanations.
    The following are sample settings for both cache requests and cache response directives.
  prefs: []
  type: TYPE_NORMAL
- en: 'Request cache control directives (standard `Cache-Control` directives, which
    can be used by the client in an HTTP request) are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Response cache control directives (standard `Cache-Control` directives, which
    can be used by the server in an HTTP response) are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: It is not possible to specify cache directives for a specific cache.
  prefs: []
  type: TYPE_NORMAL
- en: Cache validation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When a cache has a fresh entry that can be used as a response when the client
    requests, it will check with the originating server to see if the cached entry
    is still usable. This process is called **cache validation**. Also, revalidation
    is triggered when the user presses the reload button. If the cached response includes
    the `Cache-Control: must revalidate` header, it will be triggered under normal
    browsing.'
  prefs: []
  type: TYPE_NORMAL
- en: When the resource's time is expired, it will either be validated or fetched
    again. Cache validation will only be triggered when the server provided a strong
    or weak validator.
  prefs: []
  type: TYPE_NORMAL
- en: ETags
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'ETags provide a mechanism for validating cached responses. The ETag response
    header can be used as a strong validator. In this case, the client can neither
    understand the value nor predict what its value will be. When the server issues
    a response, it generates a token that hides the state of the resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'If the `ETag` is part of the response, the client can issue an `If-None-Match`
    in the header of the future request to validate the cached resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The server will compare the requested header with the current state of the resource.
    If the resource state is changed, the server will respond with a new resource.
    Otherwise, the server will return a `304 Not Modified` response.
  prefs: []
  type: TYPE_NORMAL
- en: Last-Modified/If-Modified-Since headers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have seen a strong validator (ETags). Here, we will discuss a weak
    validator that can be used in the header. The `Last-Modified` response header
    can be used as a weak validator. Instead of generating a hash of a resource, a
    timestamp will be used to check the cached responses are valid.
  prefs: []
  type: TYPE_NORMAL
- en: As this validator has a 1-second resolution, it is considered weak compared
    to ETags. If the `Last-Modified` header is present in a response, then the client
    can send an `If-Modified-Since` request header to validate the cached resource.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `If-Modified-Since` header is supplied from the client when requesting
    a resource. To simplify the mechanism in a real example, the client request would
    resemble this: "I have already cached the resource XYZ at 10 A.M.; however, get
    the updated XYZ if it''s changed since 10 A.M. otherwise just return `304`. Then
    I will use the previously cached XYZ."'
  prefs: []
  type: TYPE_NORMAL
- en: Cache implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have seen the theory part in this chapter. Let's try to implement
    the concept in our application. To simplify the cache implementation, we are going
    to use only user management. We will use the `getUser` (single user) REST API
    to apply our caching concept.
  prefs: []
  type: TYPE_NORMAL
- en: The REST resource
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the `getUser` method, we will pass the right `userid` to the path variable,
    assuming the client will pass the `userid` and get the resource. There are many
    caching options available to implement. Here, we will use only the `If-Modified-Since`
    caching mechanism. As this mechanism will pass the `If-Modified-Since` value in
    the header, it will be forwarded to the server, saying that, if the resource is
    changed after the specified time, get the resource fresh, or else return null.
  prefs: []
  type: TYPE_NORMAL
- en: There are many ways we can implement caching. As our goal is to simplify and
    convey the message clearly, we will keep the code simple, instead of adding complexity
    in the code. In order to implement this caching, we might need to add a new variable
    called `updatedDate` in our `User` class. Let's add the variable in our class.
  prefs: []
  type: TYPE_NORMAL
- en: The `updatedDate` variable will be used as a checking variable for `If-Modified-Since`
    caching, as we will rely on user-updated date.
  prefs: []
  type: TYPE_NORMAL
- en: 'The client will ask the server if the user data has changed since the last
    cached time. The server will check against the user `updatedDate` and return null
    if not updated; otherwise, or else it will return fresh data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have just added a new variable, `updatedDate`, and
    added the proper getter and setter methods into it. We might clean up these getter
    and setter methods later by adding the Lombok library. We will apply Lombok in
    upcoming chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, we need to add another constructor to initialize the `updatedDate` variable
    when we get the instance of the class. Let''s add the constructor here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If possible, we can change the `toString` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'After adding all the preceding details mentioned, our class will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will go back to `UserController`, which we introduced in previous chapters,
    and change the `getUser` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we used the `WebRequest` parameter in our existing method.
    The `WebRequest` object will be used for calling the `checkNotModified` method.
    At first, we get the user details by `id` and get the `updatedDate` in milliseconds.
    We check the user updated date against the client header information (we assume
    the client will pass `If-Not-Modified-Since` in the header). If the user-updated
    date is newer than the cached date, we assume the user is updated, so we will
    have to send the new resource.
  prefs: []
  type: TYPE_NORMAL
- en: We might have to import `org.apache.log4j.Logger` since we added the logger
    in `UserController`. Otherwise it will show error while compiling.
  prefs: []
  type: TYPE_NORMAL
- en: If the user is not updated after the cached (by the client) date, it will simply
    return null. Also, we have provided enough loggers to print our desired statements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s test the REST API in SoapUI or the Postman client. When we call the
    API the first time, it will return the data with header information, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e9af7900-24f2-40b0-8ba0-b198978318b2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: SoapUI client
  prefs: []
  type: TYPE_NORMAL
- en: We can see that we are using the `GET` method for this API and the response
    header on the right side.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our preceding screenshot we have used the port `8081`. By default Spring
    Boot works on port `8080`. If you want to change it to `8081`, configure the port
    in `/src/main/resources/``application.properties` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`server.port = 8081`'
  prefs: []
  type: TYPE_NORMAL
- en: If there is not `application.properties` under the mentioned location, you can
    create one.
  prefs: []
  type: TYPE_NORMAL
- en: 'The response (JSON) looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding JSON response, we can see the user details, including `updatedDate`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The response (header) is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding response header, we can see the HTTP result `200` (meaning
    OK) and the `Last-Modified` date.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will add `If-Modified-Since` in the headers and update the latest date
    we got from the previous response. We can check the `If-Modified-Since` parameter
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ebde97a2-d5ee-4698-a91a-cb8a0ea76962.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding configuration, we have added the `If-Modified-Since` parameter
    in the header section and called the same REST API again. The code will check
    whether the resource has been updated since the last cached date. In our case,
    the resource is not updated, so it will simply return `304` in the response. We
    can see the response as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The HTTP `304` (not modified) response simply conveys to the client that there
    is no resource modified, so the client can use the existing cache.
  prefs: []
  type: TYPE_NORMAL
- en: If we update the specified user by calling the update REST API (`http://localhost:8081/user/100`
    using `PUT`) and then call the previous API (`http://localhost:8081/user/100`
    using `GET`), we will get a fresh resource as the user is updated after the client
    cache.
  prefs: []
  type: TYPE_NORMAL
- en: Caching with ETags
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we explored caching based on the updated date. However,
    we may not always need to rely on the updated date when we need to check the updated
    resource. There is another mechanism, called ETag caching, that provides a strong
    validator to check whether the resource is updated or not. ETag caching would
    be the perfect alternative for regular caching by checking the updated date.
  prefs: []
  type: TYPE_NORMAL
- en: In ETag caching, the response header will provide the hashed ID (MD5) for the
    body. If the resource is updated, the header will generate a new hash ID on the
    REST API call. So we don't need to explicitly check the information like we did
    in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring provides a filter called `ShallowEtagHeaderFilter` to support ETag caching.
    Let''s try to add the `ShallowEtagHeaderFilter` in our existing application. We
    will add the code in our main application file (`TicketManagementApplication`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we are adding `ShallowEtagHeaderFilter` as a bean and
    registering by supplying our URL patterns and name. As we will test only the user
    resource at the moment, we will add `/user/*` in our patterns. Finally, our main
    application class will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We can test this ETag mechanism by calling the user API (`http://localhost:8081/user`).
    When we call this API, the server will return the following headers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that `ETag` is added in our header with the hash ID. Now we will
    call the same API with the `If-None-Match` header with the hash value. We will
    see the header in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d644eb31-ffdf-4337-8e47-a057eef15107.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'When we call the same API again with the `If-None-Match` header and the value
    of our previously hashed ID, the server will return a `304` state, which we can
    see as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In this mechanism, the actual response body will not be sent to the client.
    Instead, it will tell the client that the resource is not modified, so the client
    can use the previously cached content. The `304` state conveys that the resource
    is not cached.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned HTTP optimization methods to improve application
    performance. By reducing the interaction between clients and servers and the size
    of the data over HTTP, we will achieve maximum performance in our REST API services.
    We will explore other optimization, caching, and scaling techniques in [Chapter
    11](c3ef97e3-fbad-4b9e-b7f8-91c6d3d6c6f0.xhtml), *Scaling,* as we will be talking
    about more advanced topics relating to web service performance.
  prefs: []
  type: TYPE_NORMAL
