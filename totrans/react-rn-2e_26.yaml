- en: Building a Relay React App
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, you got a ten thousand foot introduction to Relay/GraphQL,
    and learned why you should use the approach for your React application. Now you
    can build your Todo React Native application using Relay. By the end of this chapter,
    you should feel comfortable about how data moves around in a GraphQL centric architecture.
  prefs: []
  type: TYPE_NORMAL
- en: TodoMVC and Relay
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I had originally planned to extend the Neckbeard News app that we worked on
    earlier in this chapter. Instead, I decided that the TodoMVC example for Relay
    ([https://github.com/taion/relay-todomvc](https://github.com/taion/relay-todomvc))
    is a robust yet concise example that I would have trouble beating.
  prefs: []
  type: TYPE_NORMAL
- en: I'm going to walk you through an example React Native implementation of a Todo
    app. The key is that it'll use the same GraphQL backend as the web UI. I think
    this is a win for React developers that want to build both web and native versions
    of their apps; they can share the same schema!
  prefs: []
  type: TYPE_NORMAL
- en: 'I''ve included the web version of the TodoMVC app in the code that ships with
    this book, but I won''t dwell on the details of how it works. If you''ve worked
    on web development in the past 5 years, you''ve probably come across a sample
    Todo app. Here''s what the web version looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/750d45e8-c429-4262-a5e9-b1b9559a072b.png)'
  prefs: []
  type: TYPE_IMG
- en: Even if you haven't used any of the TodoMVC apps before, I would recommend playing
    with this one before trying to implement the native version, which is what you'll
    be doing for the remainder of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The goal of the native version that you're about to implement isn't functional
    parity. In fact, you're shooting for a very minimal subset of todo functionality.
    The aim is to show you that Relay works mostly the same on native platforms as
    it does on web platforms and that the GraphQL backend can be shared between web
    and native apps.
  prefs: []
  type: TYPE_NORMAL
- en: The GraphQL schema
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The schema is the vocabulary used by GraphQL backend server, and the Relay components
    in the frontend. The GraphQL type system enables the schema to describe the data
    that's available, and how to put it all together when a query request comes in.
    This is what makes the whole approach so scalable, the fact that the GraphQL runtime
    figures out how to put data together. All you need to supply are functions that
    tell GraphQL where the data is; for example, in a database or in some remote service
    endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the types used in the GraphQL schema for the TodoMVC
    app, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: There are a lot of things being imported here, so I'll start with the imports.
    I wanted to include all of these imports because I think they're contextually
    relevant for this discussion. First, there's the primitive GraphQL types from
    the the `graphql` library. Next, you have helpers from the `graphql-relay` library
    that simplify defining a GraphQL schema. Lastly, there's imports from your own
    `database` module. This isn't necessarily a database, in fact, in this case, it's
    just mock data. You could replace `database` with `api` for instance, if you needed
    to talk to remote API endpoints, or we could combine the two; it's all GraphQL
    as far as your React components are concerned.
  prefs: []
  type: TYPE_NORMAL
- en: Then, you define some of your own GraphQL types. For example, the `GraphQLTodo`
    type has two fields—`text` and `complete`. One is a Boolean and one is a string.
    The important thing to note about GraphQL fields is the `resolve()` function.
    This is how you tell the GraphQL runtime how to populate these fields when they're
    required. These two fields simply return property values.
  prefs: []
  type: TYPE_NORMAL
- en: Then, there's the `GraphQLUser` type. This field represents the user's entire
    universe within the UI, hence the name. The `todos` field, for example, is how
    you query for todo items from Relay components. It's resolved using the `connectionFromArray()`
    function, which is a shortcut that removes the need for more verbose field definitions.
    Then, there's the `GraphQLRoot` type. This has a single `viewer` field that's
    used as the root of all queries.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s take a closer look at the add todo mutation, as follows. I''m not
    going to go over every mutation that''s used by the web version of this app, in
    the interests of space:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: All mutations have a `mutateAndGetPayload()` method, which is how the mutation
    actually makes a call to some external service to change the data. The returned
    payload can be the changed entity, but it can also include data that's changed
    as a side-effect. This is where the `outputFields` come into play. This is the
    information that's handed back to Relay in the browser so that it has enough information
    to properly update components based on the side effects of the mutation. Don't
    worry, you'll see what this looks like from Relay's perspective shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The mutation type that you''ve created here is used to hold all application
    mutations. Lastly, here''s how the entire schema is put together and exported
    from the module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Don't worry about how this schema is fed into the GraphQL server for now.
  prefs: []
  type: TYPE_NORMAL
- en: Bootstrapping Relay
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At this point, you have the GraphQL backend up and running. Now, you can focus
    on your React components in the frontend. In particular, you''re going to look
    at Relay in a React Native context, which really only has minor differences. For
    example, in web apps, it''s usually `react-router` that bootstraps Relay. In React
    Native, it''s a little different. Let''s look at the `App.js` file that serves
    as the entry point for your native app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s break down what''s happening here, starting with the environment constant:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This is how you communicate with the GraphQL backend, by configuring a network.
    In this example, you're importing `Network` from `relay-local-schema`, which means
    that no network requests are being made. This is really handy for when you're
    getting started—especially building a React Native app.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, there''s the `QueryRenderer` component. This Relay component is used
    to render other components that depend on GraphQL queries. It expects a query
    property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that queries are prefixed by the module that they''re in. In this case,
    `App`. This query uses a GraphQL fragment from another module, `TodoList`, and
    is named `TodoList_viewer`. You can pass variables to the query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, the `render` property is a function that renders your components when
    the GraphQL data is ready:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: If something went wrong, error will contain information about the error. If
    there's no error and no props, it's safe to assume that the GraphQL data is still
    loading.
  prefs: []
  type: TYPE_NORMAL
- en: Adding todo items
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the `TodoInput` component, there''s a text input that allows the user to
    enter new todo items. When they''re done entering the todo, Relay will need to
    send a mutation to the backend GraphQL server. Here''s what the component code
    looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: It doesn't look that different from your typical React Native component. The
    piece that stands out is the mutation—`AddTodoMutation`. This is how you tell
    the GraphQL backend that you want a new `todo` node created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see what the application looks like so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/e3ff8741-63d2-4e06-804a-1bc807755549.png)'
  prefs: []
  type: TYPE_IMG
- en: The textbox for adding new todo items is just above the list of todo items.
    Now, let's look at the `TodoList` component, which is responsible for rendering
    the todo item list.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering todo items
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s the job of the `TodoList` component to render the todo list items. When
    `AddTodoMutation` takes place, the `TodoList` component needs to be able to render
    this new item. Relay takes care of updating the internal data stores where all
    of our GraphQL data lives. Here''s a look at the item list again, with several
    more todos added:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/39f4da0a-c9ea-457a-8eaa-efea4c539730.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here''s the `TodoList` component itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The relevant GraphQL to get the data you need is passed as a second argument
    to `createFragmentContainer()`. This is the declarative data dependency for the
    component. When you you render the `<Todo>` component, you're passing it the `edge.todo`
    data. Now, let's see what the `Todo` component itself looks like.
  prefs: []
  type: TYPE_NORMAL
- en: Completing todo items
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The last piece of this application is rendering each todo item and providing
    the ability to change the status of the todo. Let''s take a look at this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The actual component that's rendered is a switch control and the item text.
    When the user marks the todo as complete, the item text is styled as crossed off.
    The user can also uncheck items. The `ChangeTodoStatusMutation` mutation sends
    the request to the GraphQL backend to change the `todo` state. The GraphQL backend
    then talks to any microservices that are needed to make this happen. Then, it
    responds with the fields that this component depends on.
  prefs: []
  type: TYPE_NORMAL
- en: The important part of this code that I want to point out is the fragments used
    in the Relay container. This container doesn't actually use them directly. Instead,
    they're used by the `todos` query in the `TodoList` component (`Todo.getFrament()`).
    This is useful because it means that you can use the `Todo` component in another
    context, with another query, and its data dependencies will always be satisfied.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you implemented some specific Relay and GraphQL ideas. Starting
    with the GraphQL schema, you learned how to declare the data that's used by the
    application and how these data types resolve to specific data sources, such as
    microservice endpoints. Then, you learned about bootstrapping GraphQL queries
    from Relay in your React Native app. Next, you walked through the specifics of
    adding, changing, and listing todo items. The application itself uses the same
    schema as the web version of the Todo application, which makes things much easier
    when you're developing web and native React applications.
  prefs: []
  type: TYPE_NORMAL
- en: Well, that's a wrap for this book. We've gone over a lot of material together,
    and I hope that you've learned from reading it as much as I have from writing
    it. If there was one theme from this book that you should walk away with, it's
    that React is simply a rendering abstraction. As new rendering targets emerge,
    new React libraries will emerge as well. As developers think of novel ways to
    deal with state at scale, you'll see new techniques and libraries released. My
    hope is that you're now well prepared to work in this rapidly evolving React ecosystem.
  prefs: []
  type: TYPE_NORMAL
