- en: HTTP and WebSocket Communication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we'll be looking at how we can interface with our server-side
    APIs using `HTTP`. We will create an application using our own offline API with
    `HTTP GET`, `POST`, `PUT` , `PATCH`, and `DELETE`. As well as this, we'll be creating
    an in-memory, real-time chat application that takes advantage of WebSockets with
    the `Socket.io` library.
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you will know how to:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a mock database APIs with `json-server`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create HTTP requests with `Axios`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use WebSockets and `Socket.io` for real-time communication across clients
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTTP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start off by creating a new Vue.js project that we can use as a playground
    project. Type the following in your Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'There are many ways to create HTTP requests within JavaScript. We''ll be using
    the `Axios` library to use a simplified promise-based approach within our project.
    Let''s install it by typing the following in our Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We now have the ability to create HTTP requests; we just need an API to point
    `Axios` towards. Let's create a mock API.
  prefs: []
  type: TYPE_NORMAL
- en: Installing JSON server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to create a mock API, we can use the `json-server` library. This allows
    us to get up-and-running globally quickly by just creating a `db.json` file inside
    of our project. It effectively creates a GET, POST, PUT, PATCH, and DELETE API
    and stores the data in a file, appended to our original JSON file.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can install it by running the following in our Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As we've added the `-g` flag, we'll be able to access the `json-server` module
    globally throughout our Terminal.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next thing we need to do is create our `db.json` file inside the root of
    our project. Be as creative as you want with your dataset; we just simply have
    a list of courses that we may or may not be interested in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then run our database by running the following in the Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'If we''ve done everything successfully, we should then be able to access our
    database at `http://localhost:3000`, as seen by the following success message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/77705cdb-4486-431d-b8f9-e929efaa77a4.png)'
  prefs: []
  type: TYPE_IMG
- en: Awesome. We're all set up and now we can get a list of courses.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP GET
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first thing we need to do is import `Axios` into our `App.vue` component.
    We can also set a `ROOT_URL` in this instance as we''ll only be looking for the
    `/courses` endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This then gives us the ability to hook into a lifecycle hook such as `created()`
    and call a method that requests the courses from our API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: What's happening here? We're calling the `getCoursesList` function, which makes
    an HTTP `GET` request to our `http://localhost:3000/courses` endpoint. This then
    either sets the courses array equal to the data (that is, everything inside of
    our `db.json`) or merely logs out an error if there was one.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then display this on screen using the `v-` for directive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Together with a little bit of styling, we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '![](assets/e65701a2-f9fa-424f-a77e-fb392acbbf3b.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's move on to HTTP POST!
  prefs: []
  type: TYPE_NORMAL
- en: HTTP POST
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can add an input box and `button` following the `courseName` `div`, allowing
    the user to input a new course to their learning list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This requires us to add the `courseName` variable to our `data` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then create a similar method named `addCourse` that takes the `courseName`
    as a parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: You may notice that it's quite similar to the previous HTTP call, but this time
    instead of `.get` we're using `.post`, and passing an object with the key and
    value of `name`.
  prefs: []
  type: TYPE_NORMAL
- en: After sending the POST request, we then use `this.courses.push(response.data)`
    to update the client side array as, whilst the server side (our client `db.json`
    file) is updated, the client state is not.
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/5843056b-60f4-42d8-b48e-9106ab582223.png)'
  prefs: []
  type: TYPE_IMG
- en: HTTP PUT
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next thing we'd like to be able to do is change items in our list. Perhaps
    we've made a mistake when submitting the item and we therefore want to edit it.
    Let's add that functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'Firstly, let''s tell Vue to keep track of whenever we''re editing a course.
    A user''s intention to edit will be whenever they click a course name; we can
    then add the editing Boolean to our `data` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Our template can then be changed to reflect this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: What exactly is happening here? Well, we've changed our `courseName` to instead
    only display when we're not editing (that is, we haven't clicked the name of the
    course). Instead, using the `v-else` directive, we're displaying an input box
    and `button` that allows us to save the new `CourseName`.
  prefs: []
  type: TYPE_NORMAL
- en: We're also hiding the add course button at this point to keep things simple.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s what the code looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Here we're using the `.put` method on our `axios` instance pointed at the endpoint
    of our selected course. As a data parameter we're using the spread operator with
    `{ ...course }` to destructure the course variable to work with our API.
  prefs: []
  type: TYPE_NORMAL
- en: 'After this, we merely log the results to the console. Here''s what it looks
    like when we edit the "Vue.js Design Patterns" string to simply say `Vue.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/bf30fdfc-829c-4a50-ada7-0654d868290d.png)'
  prefs: []
  type: TYPE_IMG
- en: Yay! The last thing we'll be looking at is DELETE and removing items from our
    database.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP DELETE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To delete items from our list, let''s add a `button` so that, when the user
    enters edit mode (by clicking an item), they can remove that specific course:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `removeCourse` function then looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We're calling the `axios.delete` method and then filtering our `courses` list
    for every course but the one we've deleted. This then updates our client state
    and makes it consistent with the database.
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/69091533-e283-418f-8b4d-46d41fc6048f.png)'
  prefs: []
  type: TYPE_IMG
- en: In this section of the chapter, we've created ourselves a simple "courses I
    want to study" list based on our REST API. It could have certainly been abstracted
    to multiple components, but as this wasn't the core focus of the application we've
    simply did it all in one.
  prefs: []
  type: TYPE_NORMAL
- en: Coming up next, let's make a real-time chat application with Node and `Socket.io`.
  prefs: []
  type: TYPE_NORMAL
- en: Real-time chat application with Node and Socket.io
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll be creating a real-time chat application using Node and
    `Socket.io`. We'll be writing a small amount of code with Node.js and the Express
    framework, but it's all the same JavaScript that you know and love.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following in your Terminal to create a new project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then create a server folder and initialize a `package.json` for server-specific
    dependencies like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: What is Socket.io?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our previous example, if we wanted to get new data from the server we'd need
    to make another HTTP request, whereas with WebSockets we can simply have a consistent
    event-listener that reacts whenever the event is fired.
  prefs: []
  type: TYPE_NORMAL
- en: To take advantage of this in our chat application, we'll be using `Socket.io`.
    This is a client and server-side library that allows us to work with WebSockets
    quickly and easily. It allows us to define and submit events that we can listen
    to and subsequently perform actions.
  prefs: []
  type: TYPE_NORMAL
- en: Server setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can then create a new HTTP server using Express and listen for application
    connections with `Socket.io` by adding the following to `server.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'If we then run `node server.js` from within our Terminal inside the `server`
    folder, we should see the message Listening on port: 3000. This means that once
    we implement `Socket.io` inside of our client application we''ll be able to monitor
    whenever somebody connects to the application.'
  prefs: []
  type: TYPE_NORMAL
- en: Client connections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To capture a client connection, we need to install the `Socket.io` into our
    Vue application. We'll also be using another dependency named `vue-socket.io`,
    which provides us with a smoother implementation within our Vue applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following in your Terminal, ensuring you''re in the root directory
    (that is, not in the `server` folder):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Setting up Vue and Socket.io
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s head on over to our `main.js` file so we can register `Socket.io` and
    the `Vue-Socket.io` plugin. You may remember how to do this from previous chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code block, we're importing the necessary dependencies and
    creating a reference to our Socket.io server, which is currently running on port
    `3000`. We're then adding the Vue plugin by using `Vue.use`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we''ve done everything correctly, our client and server should be talking
    to each other. We should get the following inside of our Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/3c4ef978-1ba1-461b-acdd-7ca0f26ea14c.png)'
  prefs: []
  type: TYPE_IMG
- en: Determining connection status
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we've added the Vue-Socket.io plugin, we have access to a sockets object
    inside of our Vue instance. This allows us to listen to particular events as well
    as determine whether the user is connected or disconnected from the WebSocket.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside of `App.vue`, let''s display a message on screen if we''re connected/disconnected
    from the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: There shouldn't be much new here other than the sockets object. Whenever we're
    connected to the socket, we can run any code we want inside of the `connect()`
    hook, and the same goes for `disconnect()`. We're simply flipping a Boolean to
    display a different message on screen with the `v-if` and `v-else` directive(s).
  prefs: []
  type: TYPE_NORMAL
- en: 'Initially, we get Connected to the server as our server is running. If we stop
    the server with *CTRL* + *C* in our Terminal window, our heading will change to
    reflect the fact that we no longer have a WebSocket connection. Here''s the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/60c8c31c-5543-4391-80a3-23c99418f74c.png)'
  prefs: []
  type: TYPE_IMG
- en: Creating a connection status bar
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s have some fun with this concept. We can make a components folder and
    subsequently a new component named `ConnectionStatus.vue`. Inside of this file
    we can create a status bar that is shown to the user whenever they''re online
    or offline:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Whilst we only have one screen inside of our current application, we may want
    to use this component across multiple components, so we can register it globally
    inside of `main.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then edit our `App.vue` template to use this component and pass the
    current connection state as a prop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s our result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/4663d9db-06e7-4894-a7ce-f5f279ecd755.png)'
  prefs: []
  type: TYPE_IMG
- en: Next, we can make a navigation bar component to make our UI more complete.
  prefs: []
  type: TYPE_NORMAL
- en: Navigation bar
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The navigation bar component won't have many uses other than to simply display
    the name of our application. You could change this to include other functionality
    such as log in/out, adding new chat channels, or any other chat-specific user
    actions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s make a new component named `Navbar.vue` in the `components` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: You may notice that the `v-once` directive was added on this `div`. This is
    the first time we've looked at it, but as this component is entirely static we
    can tell Vue to not listen for any changes and only render it once.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then have to remove any default padding or margin inside of the HTML body.
    Create a file named `styles.css` inside of the root directory that contains these
    attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then add this to our `index.html` file like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Next, we'll need to register this component globally. Try and do this by yourself
    inside `main.js` if you feel you can.
  prefs: []
  type: TYPE_NORMAL
- en: 'This requires us to import `Navbar` and register it like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then add this to our `App.vue` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Next up, let's create our `MessageList` component to hold a list of messages.
  prefs: []
  type: TYPE_NORMAL
- en: Message list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can display a list of messages on screen by creating a new component with
    a prop that accepts an array of messages. Create a new component inside the components
    folder named `MessageList.vue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This component is fairly simple; all it does is iterate over our `messages`
    array using the `v-for` directive. We pass the messages array into this component
    using the appropriate prop.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of registering this component globally, let''s register it specifically
    inside of our `App.vue` component. Whilst we''re here, we can also add some dummy
    data to the `messages` array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then add the `message-list` component to our template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re passing the messages in as a prop based on the messages array found
    inside of our data object. We can also add the following styles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Doing so will center our message box on the screen and constrain the `width`
    for demonstration purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re making progress! Here''s our message box:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/6f9659ba-e0cf-4719-9d60-66c855f8e40d.png)'
  prefs: []
  type: TYPE_IMG
- en: What next? Well, we still need the ability to add messages to our list. Let's
    work on that next.
  prefs: []
  type: TYPE_NORMAL
- en: Adding messages to the list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create a new component inside of the components folder named `MessageForm.vue`.
    This will serve to input messages into the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can start off with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This essentially allows us to capture user input for both the selected `username`
    and `message`. We can then use this information to send data to our `Socket.io`
    server within the `sendMessage` function.
  prefs: []
  type: TYPE_NORMAL
- en: By adding `@submit.prevent` to our form rather than `@submit`, we're ensuring
    that we override the default behavior of the submitted form; this is necessary
    or else our page would otherwise reload.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go and register our form inside of `App.vue`, even though we haven''t
    hooked up any actions yet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then add this to our template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s what our application looks like now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/92c939a6-e392-4e4b-b07f-2183edd45d5c.png)'
  prefs: []
  type: TYPE_IMG
- en: Server-side events with Socket.io
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to send a new message, we can listen for an event named `chatMessage`
    within our `server.js` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be done inside of our original connection event, ensuring that we
    listen for events on a socket-by-socket basis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: If we then send the `chatMessage` event from our client, it should subsequently
    log out this message inside of our Terminal. Let's try it out!
  prefs: []
  type: TYPE_NORMAL
- en: Because we've made a change to our `server.js` file, we'll need to restart the
    Node instance. Hit *CTRL* + *C* within the Terminal window that is running `server.js`
    and run node `server.js` again.
  prefs: []
  type: TYPE_NORMAL
- en: Nodemon
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Alternatively, you may want to use a module called `nodemon` to automatically
    do this whenever any changes are made.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following inside of your Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Great! Let''s go back to our `MessageForm` component and create the `sendMessage`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '![](assets/b7ba289b-f5fc-401e-babe-33f9f49a203a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'At this point hitting Send doesn''t add the message to an array yet, but it
    does give us the sent message inside of our Terminal! Let''s take a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ec545d8a-9493-4d3a-ab16-e55ec33fbe42.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As it turns out, we don''t have to write much more code to take advantage of
    our WebSockets. Let''s head back over to the `App.vue` component and add a function
    to our sockets object called `chatMessage`. Notice how this is identical to the
    event name, meaning that every time this event is fired we can run a particular
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Our client-side code is now hooked up and listening to the `chatMessage` event.
    The problem is that our server-side code isn''t currently sending anything to
    the client! Let''s fix this by emitting an event from within the socket:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: We're keeping the messages in memory with an array named messages. We're also
    then emitting those messages downstream whenever a client connects to our application
    (all the previous messages will be shown). As well as this, any time there is
    a new message added to the array, we're also sending this to all of the clients
    too.
  prefs: []
  type: TYPE_NORMAL
- en: If we open up two Chrome tabs we should then be able to have a self-directed
    conversation!
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/597f3540-a0de-4b8e-9ea6-0f7ced878124.png)'
  prefs: []
  type: TYPE_IMG
- en: We can then talk to ourselves in the other tab!
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a4adcb16-28ff-4fa1-b43b-b8e88bfe7dd3.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to create HTTP requests with Vue using the `Axios`
    library and `json-server`. This allows us to interact with third-party APIs and
    power up our Vue applications.
  prefs: []
  type: TYPE_NORMAL
- en: We also looked at how to create a larger application using WebSockets and `Socket.io`.
    This allows us to have real-time communication with other clients that are connected
    to our application, allowing for even more possibilities.
  prefs: []
  type: TYPE_NORMAL
- en: We've come a long way! In order to truly take advantage of Vue, we'll need to
    master the router and look at advanced state management concepts. That is all
    coming up in the next chapter(s)!
  prefs: []
  type: TYPE_NORMAL
