- en: Chapter 6. Basics of Classes and Objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will look at the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Using a class to encapsulate data and processing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing classes with lots of processing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing classes with little unique processing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimizing small objects with __slots__
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using more sophisticated collections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extending a collection – a list that does statistics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using properties for lazy attributes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using settable properties to update eager attributes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The point of computing is to process data. Even when building something like
    an interactive game, both the game state and the player's actions are the data;
    the processing computes the next game state and the display update.
  prefs: []
  type: TYPE_NORMAL
- en: Some games can have a relatively complex internal state. When we think of console
    games with multiple players and sophisticated graphics, there are complex, real-time
    state changes.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, when we think of a casino game, such as *Craps* , the game
    state is very simple. There may be no point established, or one of the numbers
    4, 5, 6, 8, 9, or 10 may be the established point. The transitions are relatively
    simple, and are often denoted by moving markers and chips around on the casino
    table. The data includes the current state, player actions, and rolls of the dice.
    The processing is the rules of the game.
  prefs: []
  type: TYPE_NORMAL
- en: A game such as *Blackjack* has a somewhat more complex internal state change
    as each card is accepted. In games where the hands can be split, the state of
    play can become quite complex. The data includes the current game state, the player's
    commands, and the cards drawn from the deck. Processing is defined by the rules
    of the game as modified by any house rules.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of *craps* , the player may place bets. Interestingly, the player's
    input has no effect on the game state. The internal state of the game object is
    determined entirely by the next throw of the dice. This leads to a class design
    that's relatively easy to visualize.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will create classes that implement a number of statistical
    formulae. The math can be a little daunting at first. Almost everything will be
    based on the summation of a sequence of values, often shown as ∑ *x* . In many
    cases, this can be implemented using Python's `sum()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Using a class to encapsulate data and processing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The essential idea of computing is to process data. This is exemplified when
    we write functions that process data. We looked at this in [Chapter 3](text00039.html#page
    "Chapter 3. Function Definitions") , *Function Definitions* .
  prefs: []
  type: TYPE_NORMAL
- en: Often, we'd like to have a number of closely related functions that work with
    a common data structure. This concept is the heart of object-oriented programming.
    A class definition will contain a number of methods that all control the internal
    state of an object.
  prefs: []
  type: TYPE_NORMAL
- en: The unifying concept behind a class definition is often captured as a summary
    of the responsibilities allocated to the class. How can we do this effectively?
    What's a good way to design a class?
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's look at a simple, stateful object—a pair of dice. The context for this
    is an application that simulates the casino game of *Craps* . The goal is to use
    a simulation of results to help invent a better playing strategy. This will save
    us from losing real money while we try to beat the house edge.
  prefs: []
  type: TYPE_NORMAL
- en: There's an important distinction between the class definition and an instance
    of the class, called an **object** . We call this idea **object-oriented programming**
    as a whole. Our focus is on writing class definitions. Our overall application
    will create instances of the classes. The behavior that emerges from the collaboration
    of the instances is the overall goal of the design process.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the design effort is on class definitions. Because of this, the name
    object-oriented programming can be misleading.
  prefs: []
  type: TYPE_NORMAL
- en: The idea of **emergent behavior** is an essential ingredient in object-oriented
    programming. We don't specify every behavior of a program. Instead, we decompose
    the program into objects, and define the object's state and behavior via the object's
    classes. The programming decomposes into class definitions based on their responsibilities
    and collaborations.
  prefs: []
  type: TYPE_NORMAL
- en: An object should be viewed as a thing—a noun. The behaviors of the class should
    be viewed as verbs. This gives us a hint as to how we can proceed to design classes
    that work effectively.
  prefs: []
  type: TYPE_NORMAL
- en: Object-oriented design is often easiest to understand when it relates to tangible
    real-world things. It's often easier to write software to simulate a playing card
    than to create software that implements an **Abstract Data Type** .
  prefs: []
  type: TYPE_NORMAL
- en: For this example, we'll simulate the rolling of dice. For some games, such as
    the casino game of *Craps* , two dice are used. We'll define a class that models
    the pair of dice. To be sure that the example is tangible, we'll model the pair
    of dice in the context of simulating a casino game.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Write down simple sentences that describe what an instance of the class does.
    We can call these the problem statements. It''s essential to focus on short sentences,
    and emphasize the nouns and verbs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The game of *Craps* has two standard dice.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each die has six faces, with point values from one to six.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dice are rolled by a player.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The total of the dice changes the state of the *craps* game. Those rules are
    separate from the dice, however.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the two dice match, the number was rolled the hard way. If the two dice do
    not match, the number was easy. Some bets depend on this hard-easy distinction.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identify all of the nouns in the sentences. Nouns may identify different classes
    of objects. These are **collaborators** . Examples include player and game. Nouns
    may also identify attributes of objects in questions. Examples include face and
    point value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Identify all the verbs in the sentences. Verbs are generally methods of the
    class in question. Examples include rolled and match. Sometimes, they are methods
    of other classes. One example is change the state, which applies to *Craps* .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Identify any adjectives. Adjectives are words or phrases that clarify a noun.
    In many cases, some adjectives will clearly be properties of an object. In other
    cases, the adjectives will describe relationships among objects. In our example,
    a phrase such as *the total of the dice* is an example of a prepositional phrase
    taking the role of an adjective. The *the total of* phrase modifies the noun *the
    dice* . The total is a property of the pair of dice.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Start writing the class with the `class` statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Initialize the object''s attributes in the `__init__` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We'll model the internal state of the dice with the `self.faces` attribute.
    The `self` variable is required to be sure that we're referencing an attribute
    of a given instance of a class. The object is identified by the value of the instance
    variable, `self` .
  prefs: []
  type: TYPE_NORMAL
- en: We could also put some other properties here. The alternative is to implement
    the properties as separate methods. The details of this design decision are the
    subject of the *Using properties for lazy attributes* recipe later on in this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Define the object''s methods based on the various verbs. In our case, we have
    several methods that must be defined:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here''s how we can implement dice are rolled by a player:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We've updated the internal state of the dice by setting the `self.faces` attribute.
    Again, the `self` variable is essential for identifying the object to be updated.
  prefs: []
  type: TYPE_NORMAL
- en: Note that this method mutates the internal state of the object. We've elected
    to not return a value. This makes our approach somewhat like the approach of Python's
    built-in collection classes. Any method that mutates the object does not return
    a value.
  prefs: []
  type: TYPE_NORMAL
- en: This method helps implement the total of the dice changes the state of the *craps*
    game. The game is a separate object, but this method provides a total that fits
    the sentence.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: These two methods help answer the hardways and easyways questions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: It's rare in a casino game to have a rule that has a simple logical inverse.
    It's more common to have a rare third alternative that has a remarkably bad payoff
    rule. In this case, we could have defined `easyway` as return `not self.hardway()`
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example of using the class:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll seed the random number generator with a fixed value so that we
    can get a fixed sequence of results. This is a way of creating a unit test for
    this class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll create a `Dice` object, `d1` . We can then set its state with the `roll()`
    method. We''ll then look at the `total()` method to see what was rolled. We''ll
    examine the state by looking at the faces attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll create a second `Dice` object, `d2` . We can then set its state with
    the `roll()` method. We''ll look at the result of the `total()` method, as well
    as the `hardway()` method. We''ll examine the state by looking at the `faces`
    attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the two objects are independent instances of the `Dice` class, a change
    to `d2` has no effect on `d1` :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The core idea here is to use ordinary rules of grammar—nouns, verbs, and adjectives—as
    a way to identify basic features of a class. Nouns represent things. A good descriptive
    sentence should focus on tangible, real-world things more than ideas or abstractions.
  prefs: []
  type: TYPE_NORMAL
- en: In our example, dice are real things. We try to avoid using abstract terms such
    as randomizers or event generators. It's easier to describe the tangible features
    of real things, and then locate an abstract implementation that offers some of
    the tangible features.
  prefs: []
  type: TYPE_NORMAL
- en: The idea of rolling the dice is an example physical action that we can model
    with a method definition. Clearly, this action changes the state of the object.
    In rare cases—one time in 36—the next state will happen to match the previous
    state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Adjectives often hold the potential for confusion. The following are descriptions
    of the most common ways in which adjectives operate:'
  prefs: []
  type: TYPE_NORMAL
- en: Some adjectives, such as first, last, least, most, next, previous, and so on,
    will have a simple interpretation. These can have a lazy implementation as a method,
    or an eager implementation as an attribute value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some adjectives are a more complex phrase, such as *the total of the dice* .
    This is an adjective phrase built from a noun (total) and a preposition (of).
    This, too, can be seen as a method or an attribute.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some adjectives involve nouns that appear elsewhere in our software. We might
    have a phrase such as *the state of the Craps game* , where *state of* modifies
    another object, the *Craps* game. This is clearly only tangentially related to
    the dice themselves. This may reflect a relationship between dice and game.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We might add a sentence to the problem statement such as *the dice are part
    of the game* . This can help clarify the presence of a relationship between game
    and dice. Prepositional phrases, such as *are part of* , can always be reversed
    to create the statement from the other object''s point of view: for example, *The
    game contains dice* . This can help clarify the relationships among objects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In Python, the attributes of an object are by default dynamic. We don't specify
    a fixed list of attributes. We can initialize some (or all) of the attributes
    in the `__init__()` method of a class definition. Since attributes aren't static,
    we have considerable flexibility in our design.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Capturing the essential internal state and methods that cause state change
    is the first step in good class design. We can summarize some helpful design principles
    using the acronym **S.O.L.I.D** .:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Single Responsibility Principle** : A class should have one clearly defined
    responsibility.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Open/Closed Principle** : A class should be open to extension-generally via
    inheritance, but closed to modification. We should design our classes so that
    we don''t need to tweak the code to add or change features.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Liskov Substitution Principle** : We need to design inheritance so that a
    subclass can be used in place of the superclass.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Interface Segregation Principle** : When writing a problem statement, we
    want to be sure that collaborating classes have as few dependencies as possible.
    In many cases, this principle will lead us to decompose large problems into many
    small class definitions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dependency Inversion Principle** : It''s less than ideal for a class to depend
    directly on other classes. It''s better if a class depends on an abstraction,
    and a concrete implementation class is substituted for the abstract class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The goal is to create classes that have the proper behavior and also adhere
    to the design principles.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See the *Using properties for lazy attributes* recipe, where we'll look at the
    choice between an eager attribute and a lazy property
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In [Chapter 7](text00079.html#page "Chapter 7. More Advanced Class Design")
    , *More Advanced Class Design* , we'll look in more depth at class design techniques
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See [Chapter 11](text00120.html#page "Chapter 11. Testing") , *Testing* , for
    recipes on how to write appropriate unit tests for the class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing classes with lots of processing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most of the time, an object will contain all of the data that defines its internal
    state. However, this isn't always true. There are cases where a class doesn't
    really need to hold the data, but instead can hold the processing.
  prefs: []
  type: TYPE_NORMAL
- en: Some prime examples of this design are statistical processing algorithms, which
    are often outside the data being analyzed. The data might be in a `list` or `Counter`
    object. The processing might be a separate class.
  prefs: []
  type: TYPE_NORMAL
- en: In Python, of course, this kind of processing is often implemented using functions.
    See [Chapter 3](text00039.html#page "Chapter 3. Function Definitions") , *Function
    Definitions* for more information on this. In some languages, all code must take
    the form of a class, leading to some extra complexity.
  prefs: []
  type: TYPE_NORMAL
- en: How can we design a class that makes use of Python's array of sophisticated
    built-in collections?
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [Chapter 4](text00048.html#page "Chapter 4. Built-in Data Structures – list,
    set, dict") , *Built-in Data Structures – list, set, dict* , specifically the
    *Using set methods and operators* recipe, we looked at a statistical process called
    the **Coupon Collector's Test** . The concept is that each time we perform some
    process, we save a coupon that describes some aspect or parameter for the process.
    The question is, how many times do I have to perform the process before I collect
    a complete set of coupons?
  prefs: []
  type: TYPE_NORMAL
- en: If we have customers assigned to different demographic groups based on their
    purchasing habits, we might ask how many online sales we have to make before we've
    seen someone from each of the groups. If the groups are all about the same size,
    it's trivial to predict the average number of customers we encounter before we
    get a complete set of coupons. If the groups are different sizes, it's a little
    more complex to compute the expected time before collecting a full set of coupons.
  prefs: []
  type: TYPE_NORMAL
- en: Let's say we've collected data using a `Counter` object. For more information
    on the various collections, see [Chapter 4](text00048.html#page "Chapter 4. Built-in
    Data Structures – list, set, dict") , *Built-in Data Structures – list, set, dict*
    , specifically the *Using set methods and operators* and *Avoiding mutable default
    values for function parameters* recipes. In this case, the customers fall into
    eight categories with approximately equal numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The data looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The key is the number of visits needed to get a full set of coupons. The value
    is the number of times that it took the given number of visits. In the preceding
    line of code `15` visits were required seven different times. `17` visits were
    required five times. This has a long tail. At one point, there were `45` individual
    visits before a full set of eight coupons was collected.
  prefs: []
  type: TYPE_NORMAL
- en: 'We want to compute some statistics on this `Counter` . We have two overall
    strategies for doing this:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Extend** : We can extend the `Counter` class definition to add statistical
    processing. The complexity of this varies with the kind of processing that we
    want to introduce. We''ll cover this in detail in the *Extending a collection
    – a list that does statistics* recipe, as well as [Chapter 7](text00079.html#page
    "Chapter 7. More Advanced Class Design") , *More Advanced Class Design* .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Wrap** : We can wrap the `Counter` object in another class that provides
    just the features we need. When we do this, though, we''ll often have to expose
    some additional methods that are an important part of Python, but which don''t
    matter much for our application. We''ll look at this in [Chapter 7](text00079.html#page
    "Chapter 7. More Advanced Class Design") , *More Advanced Class Design* .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's a variation on wrapping where we use a statistical computation object
    to wrap an object from a built-in collection. This often leads to an elegant solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have two ways to design the processing. These two design alternatives apply
    to both overall architectural choices:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Eager** : This means that we''ll compute the statistics as soon as possible.
    The values can then be attributes of the class. While this can improve performance,
    it also means that any change to the data collection will invalidate the eagerly
    computed values. We have to examine the overall context to see if this can happen.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lazy** : This means we won''t compute anything until it''s required via a
    method function or property. We''ll look at this in the *Using properties for
    lazy attributes* recipe.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The essential math for both designs is the same. The only question is when the
    computation is done.
  prefs: []
  type: TYPE_NORMAL
- en: 'We compute the mean using a sum of the expected values. The expected value
    is the frequency of a value multiplied by the value. The mean, *μ* , is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](Image00013.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here, *k* is the key from the `Counter` , *C* , and *f[k]* is the frequency
    value for the given key from the `Counter` .
  prefs: []
  type: TYPE_NORMAL
- en: 'The standard deviation, *σ* , depends on the mean, *μ* . This also involves
    computing a sum of values, each of which is weighted by frequency. The following
    is the formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](Image00014.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here, *k* is the key from the `Counter` , *C* , and *f[k]* is the frequency
    value for the given key from the `Counter` . The total number of items in the
    `Counter` is ![Getting ready](Image00015.jpg)  . This is the sum of the frequencies.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Define the class with a descriptive name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Write the `__init__` method to include the object to which this object will
    be connected:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We've defined a method function that takes a `Counter` object as an argument
    value. This `Counter` object is saved as part of the `Counter_Statistics` instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Initialize any other local variables that might be useful. Since we''re going
    to calculate values eagerly, the most eager possible time is when the object is
    created. We''ll write references to some yet to be defined functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We've eagerly computed the mean and standard deviation from the `Counter` object,
    and saved them in two instance variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Define the required methods for the various values. Here''s the calculation
    of the mean:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s how we can calculate the standard deviation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Note that this calculation requires that the mean is computed first and the
    `self.mean` instance variable has been created.
  prefs: []
  type: TYPE_NORMAL
- en: Also, this uses `math.sqrt()` . Be sure to add the needed `import math` statement
    in the Python file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how we can create some sample data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We've imported functions such as `expected()` , `arrival1()` , and `coupon_collector()`
    from the `ch04_r06` module. We've also imported the `Counter` collection from
    the standard library `collections` module.
  prefs: []
  type: TYPE_NORMAL
- en: We defined a function, `raw_data()` , that will generate a number of customer
    visits. By default, it will be 1,000 visits. The domain will be eight different
    classes of customers; each class will have an equal number of members. We'll use
    the `coupon_collector()` function to step through the data, emitting the number
    of visits required to collect a full set of eight coupons.
  prefs: []
  type: TYPE_NORMAL
- en: This data is then used to assemble a `Counter` object. This will have the number
    of customers required to get a full set of coupons. Each number of customers will
    also have a frequency showing how often that number of visits occurred.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how we can analyze the `Counter` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: First, we imported the `random` module so that we could pick a known seed value.
    This makes it easier to test and demonstrate an application because the random
    numbers are consistent. We also imported the `CounterStatistics` class from the
    `ch06_r02` module.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have all of the items defined, we can force the `seed` to a known value,
    and generate the coupon collector test results. The `raw_data()` function will
    emit a `Counter` object, which we called data.
  prefs: []
  type: TYPE_NORMAL
- en: We'll use the `Counter` object to create an instance of the `CounterStatistics`
    class. We'll assign this to the `stats` variable. Creating this instance will
    also compute some summary statistics. These values are available as the `stats.mean`
    attribute and the `stats.stddev` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: For a set of eight coupons, the theoretical average is `21.7` visits to collect
    all coupons. It looks like the results from `raw_data()` show behavior that matches
    the expectation of random visits. This is sometimes called the **null hypothesis**
    —the data is random.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This class encapsulates two complex algorithms, but doesn't include any data
    that changes state. This kind of class doesn't need to retain a lot of data. Instead,
    the design performs all of the computations as soon as possible.
  prefs: []
  type: TYPE_NORMAL
- en: We wrote a high-level specification for the processing and placed it in the
    `__init__()` method. Then we wrote methods to implement the processing steps that
    were specified. We can set as many attributes as are needed, making this a very
    flexible approach.
  prefs: []
  type: TYPE_NORMAL
- en: The advantage of this design is that the attribute values can be used repeatedly.
    The cost of computation is paid once; each time an attribute value is used, no
    further calculating is required.
  prefs: []
  type: TYPE_NORMAL
- en: The disadvantage of this design is that a change to the underlying `Counter`
    object makes the `CounterStatistics` object obsolete. Generally, we use this kind
    of design when the `Counter` isn't going to change. The example creates a single,
    static `Counter` , which is used to create `CounterStatistics` .
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If we need to have stateful objects, we can add update methods that can change
    the `Counter` object. For example, we can introduce a method to add another value
    by delegating the work to the associated `Counter` . This switches the design
    pattern from a simple connection between computation and collection to a proper
    wrapper around the collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'The method might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: First, we've updated the state of the `Counter` . Then, we recomputed all of
    the derived values. This kind of processing might create tremendous computation
    overheads. There needs to be a compelling reason to recompute the mean and standard
    deviation after every value is changed.
  prefs: []
  type: TYPE_NORMAL
- en: There are considerably more efficient solutions. For example, if we save two
    intermediate sums and an intermediate count, we can update the sums and counts
    by computing the mean and standard deviation efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this, we might have an `__init__()` method that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We've written this method to work either with a `Counter` or without a `Counter`
    . If no data is provided, it will start with an empty collection, and zero values
    for the various sums. When the count is zero, the mean and standard deviation
    have no meaningful value, so `None` is provided.
  prefs: []
  type: TYPE_NORMAL
- en: If a `Counter` is provided, then a `count` , `sum` , and sum of squares are
    computed. These can be incrementally adjusted easily, quickly recomputing the
    `mean` and standard deviation.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a single new value is added, the following method will incrementally recompute
    the various derived values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Updating the `Counter` object, the `count` , the `sum` , and the sum of squares
    is clearly necessary to be sure that the `count` , `sum` , and sum of squares
    values match the `self.raw_counter` collection at all times. Since we know the
    `count` must be at least `1` , the mean is easy to compute. The standard deviation
    requires at least two values, and is computed from the `sum` and sum of squares.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the formula for this variation on standard deviation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![There''s more...](Image00016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This involves computing two sums. One sum involves frequency times the value
    squared. The other sum involves the frequency and the value, with the overall
    sum being squared. We've used *C* to represent the total number of values; this
    is the sum of the frequencies.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the *Extending a collection – a list that does statistics* recipe, we'll
    look at a different design approach where these functions are used to extend a
    class definition.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll look at different approach in the *Using properties for lazy attributes*
    recipe. This alternative recipe will use properties and compute the attributes
    as needed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the *Designing classes with little unique processing* recipe we'll look at
    a class with no real processing. It acts as a polar opposite of this class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing classes with little unique processing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In some cases, an object is a container of rather complex data, but doesn't
    really do very much processing on that data. Indeed, in many cases, a class can
    be designed that depends only on built-in Python features and doesn't require
    any unique method functions.
  prefs: []
  type: TYPE_NORMAL
- en: In many cases, Python's built-in container classes can cover almost all of the
    various use cases for us. The small problem is that the syntax for a dictionary
    or a list isn't quite so elegant as the syntax for attributes of an object.
  prefs: []
  type: TYPE_NORMAL
- en: How can we create a class that allows us to use `object.attribute` syntax instead
    of `object['attribute']` ?
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are really only two cases for any kind of class design:'
  prefs: []
  type: TYPE_NORMAL
- en: Is it stateless? Does it embody a number of attributes, but never changes?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is it stateful? Will there be state changes for the various attributes?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A stateful design is slightly more general. We can always use a stateful implementation
    and avoid making any changes to the object to support stateless objects. However,
    there are some significant storage and performance advantages of using truly stateless
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll use two kinds of class to illustrate both kinds of design:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Stateless** : We''ll define a class to describe simple playing cards that
    have a rank and a suit. Since a card''s rank and suit don''t change, we''ll create
    a small stateless class for this.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stateful** : We''ll define a class to describe a player''s current state
    in a game of *Blackjack* where there is a dealer''s hand, the player''s hand(s),
    plus an optional insurance bet. There are a number of aspects of play that grow
    during each hand.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ll look at stateless objects and then stateful objects. For stateful objects
    that have no methods, we have two more choices: We can use a new class or we can
    leverage an existing class. These choices lead to three small recipes.'
  prefs: []
  type: TYPE_NORMAL
- en: Stateless objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We''ll base stateless objects on `collections.namedtuple` .:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the class name, which will be used twice:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the attributes of the object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s how we can use this class definition to create `Card` objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve created a new class, named `Card` , which has two attribute names: `rank`
    and `suit` . After defining the class, we can create an instance of the class.
    We built a single card object, `eight_hearts` , with a rank of eight and a suit
    of ♡.'
  prefs: []
  type: TYPE_NORMAL
- en: We can refer to attributes of this object with their name or their position
    within the tuple. When we use `eight_hearts.rank` or `eight_hearts[0]` , we'll
    see the rank attribute because it's defined first in the sequence of attribute
    names.
  prefs: []
  type: TYPE_NORMAL
- en: 'This kind of class definition is relatively rare. It has a fixed, defined set
    of attributes. Generally, Python class definitions have dynamic attributes. Also,
    the object is immutable. Here''s an example of attempting to change the instance
    attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We attempted to change the `suit` attribute of the object. This raised an `AttributeError`
    exception.
  prefs: []
  type: TYPE_NORMAL
- en: Stateful objects with a new class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Define the new class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve written an empty class definition. An instance of this class is created
    easily with something like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then add attributes to the object with statements such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: While this can work out well, it's often helpful to add a few more features
    to a class definition. Generally, we'll add methods, including the `__init__()`
    method, to initialize the instance variables of the object.
  prefs: []
  type: TYPE_NORMAL
- en: Stateful objects using an existing class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Rather than defining an empty class, we can also use modules in the standard
    library. We can use the `argparse` module or the `types` module for this:'
  prefs: []
  type: TYPE_NORMAL
- en: Import the module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `argparse` module includes the class `Namespace` , which can be used instead
    of an empty class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also use the `SimpleNamespace` from the types module. It looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the class as a reference to the `SimpleNamespace` or `Namespace` :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Any of these techniques will define a class that can have an indefinite number
    of attributes. However, the `SimpleNamespace` has a more flexible constructor
    than defining our own class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: We've created a new class named `Player` . We don't provide a list of attributes,
    since they're dynamic.
  prefs: []
  type: TYPE_NORMAL
- en: When we constructed the `player_1` object, we provided a list of attributes
    that we'd like to create as part of that object. After creating the object, we
    can then make state changes to it; we set the `player_1.bet` value, updated the
    `player_1.stake` , and also updated the `player_1.hand` .
  prefs: []
  type: TYPE_NORMAL
- en: When we display the object, all of the attributes are shown. Typically, they're
    provided in alphabetical order, making it slightly easier to write unit test examples.
  prefs: []
  type: TYPE_NORMAL
- en: When we use a `namedtuple()` function, we're creating a class object. We provide
    a class name as a string, as well as attribute names that will parallel the positional
    values for a tuple. The resulting object needs to be assigned to a variable, and
    it's best practice to make sure that the class name provided as an argument to
    the `nametuple()` function and the variable name are the same.
  prefs: []
  type: TYPE_NORMAL
- en: The class object created by `namedtuple()` is the same kind of class object
    that would be created by the `class` statement. Indeed, if you want to see the
    source, you can use `print(Card._source)` to see exactly what was used to create
    the class.
  prefs: []
  type: TYPE_NORMAL
- en: A `namedtuple` class is essentially a tuple with the added feature of named
    attributes. Like all other tuple objects, it's immutable—once built, it cannot
    be changed.
  prefs: []
  type: TYPE_NORMAL
- en: When we use the `SimpleNamespace` , we're using a very simple class definition
    that has (almost) no methods. Because attributes are generally dynamic, this class
    allows us to `set` , `get` , and `delete` attributes freely.
  prefs: []
  type: TYPE_NORMAL
- en: Classes that are not subclasses of `tuple` or that use `__slots__` (a topic
    we'll look at in the *Optimizing small objects with __slots__* recipe) are very
    flexible. There are also some very advanced techniques for altering the way attributes
    behave. These rely on deeper knowledge of how Python's special method names work.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In many cases, we''ll decompose our application processing into two broad categories
    of class definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Data – collections and items** : We''ll use built-in collection classes,
    collections from the standard library, and perhaps even items based on `namedtuple()`
    , or `SimpleNamespace` , or other class definitions that seem to focus on generic
    collections of data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Processing** : We''ll define classes in a way similar to the example shown
    in the *Designing classes with lots of processing* recipe. These processing classes
    generally depend on data objects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The idea of cleanly separating the data from the processing fits with several
    of the S.O.L.I.D. design principles. In particular, it aligns our classes with
    the Single Responsibility Principle, the Open/Closed Principle, and the Interface
    Segregation Principle. We can create classes with the kind of narrow focus that
    makes change (via subclass extension) relatively simple.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the *Designing classes with lots of processing* recipe we'll look at a class
    that is entirely processing and almost no data. It acts as the polar opposite
    of this class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimizing small objects with __slots__
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The general case for an object allows a dynamic collection of attributes, each
    of which has a dynamic value. There's a special case for an immutable object that's
    based on the `tuple` class. We looked at both of these in the *Designing classes
    with little unique processing* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: There's a middle ground—an object with a fixed number of attributes, but the
    values of the attributes can be changed. By changing the class from an unlimited
    collection of attributes to a fixed set of attributes, it turns out that we can
    also save memory and processing time.
  prefs: []
  type: TYPE_NORMAL
- en: How can we create optimized classes with a fixed set of attributes?
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s look at the idea of a hand of playing cards in the casino game of *Blackjack*
    . There are two parts to a hand:'
  prefs: []
  type: TYPE_NORMAL
- en: The cards
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The bet
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both have dynamic values. But there are only these two things. It's common to
    get more cards. It's also possible to raise the bet via a double down play.
  prefs: []
  type: TYPE_NORMAL
- en: The idea of a split will create additional hands. Each split hand is a separate
    object, with a distinct collection of cards and a unique bet.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ll leverage the `__slots__` special name when creating the class:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define the class with a descriptive name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the list of attribute names:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This identifies the only two attributes that are allowed for instances of this
    class. Any attempt to add another attribute will raise an `AttributeError` exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add an initialization method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Generally, each hand starts as a bet. The dealer then deals two initial cards
    to the hand. Under some circumstances, though, we might want to rebuild a `Hand`
    object from a sequence of `Card` instances.We've used a feature of the `or` operator.
    If the left side operand is not a false-like value (that is, `None` ,) then that's
    the value of an `or` expression. If the left side operand is false-like, then
    the right side operand is evaluated. For more information on why this is necessary,
    see the *Designing functions with optional parameters* recipe in [Chapter 3](text00039.html#page
    "Chapter 3. Function Definitions") , *Function Definitions* .
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a method to update the collection. We''ve called it `deal` because it''s
    used to deal a new card to the `Hand` :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a `__repr__()` method so that it can be printed easily:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s how we can use this class to build a hand of cards. We''ll need the
    definition of the `Card` class based on the example in the *Designing classes
    with little unique processing* recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We've imported the `Card` and `Hand` class definitions. We built an instance
    of a `Hand` , `h1` , with a bet of twice the table minimum. We then added two
    cards to the hand via the `deal()` method of the `Hand` class. This shows how
    the `h1.hand` value can be mutated.
  prefs: []
  type: TYPE_NORMAL
- en: This example also displays the instance of `h1` to show the bet and the sequence
    of cards. The `__repr__()` method produces output that's in Python syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also replace the `h1.bet` value when the player doubles down (yes, this
    is a crazy thing to do when showing 12):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: When we displayed the `Hand` object, `h1` , it showed that the `bet` attribute
    was changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s what happens when we try to create a new attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: We attempted to create an attribute named `some_other_attribute` on the `Hand`
    object, `h1` . This raised an `AttributeError` exception. Using `__slots__` means
    that new attributes cannot be added to the object.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we create a class definition, the behavior is defined in part by the object
    class and the `type()` function. Implicitly, a class is assigned a special `__new__()`
    method that handles the internal house-keeping required to create a new object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python has three essential paths:'
  prefs: []
  type: TYPE_NORMAL
- en: The default behavior, which builds a `__dict__` attribute in each object. Because
    the object's attributes are kept in a dictionary, we can add, change, and delete
    attributes freely. This flexibility requires the use of a relatively large amount
    of memory for the dictionary object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `__slots__` behavior, which avoids the `__dict__` attribute. Because the
    object has only the attributes named in the `__slots__` sequence, we can't add
    or delete attributes. We can change the values of only the defined attributes.
    This lack of flexibility means that less memory is used for each object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The subclass of `tuple` behavior. These are immutable objects. The easiest way
    to create these is with `namedtuple()` . Once built, they cannot be changed. When
    measuring memory use, these are the thriftiest of all classes of objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `__slots__` optimization is used infrequently in Python. The default class
    behavior provides the most flexibility and makes altering a class easy. In some
    cases, however, a large application might be constrained by the amount of memory
    used, and switching just one class to `__slots__` can have a dramatic improvement
    in performance.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It's possible to tailor the way the `__new__()` method works to replace the
    default `__dict__` attribute with a different kind of dictionary. This is a rather
    advanced technique because it exposes some more of the inner workings of classes
    and objects.
  prefs: []
  type: TYPE_NORMAL
- en: Python relies on a metaclass to create instances of a class. The default metaclass
    is the `type` class. The idea is that the metaclass provides a few pieces of functionality
    that are used to create the object. Once the empty object has been created, then
    the class `__init__()` method will initialize the empty object.
  prefs: []
  type: TYPE_NORMAL
- en: Generally, a metaclass will provide a definition of `__new__()` , and perhaps
    `__prepare__()` , if there's a need to customize the namespace object. There's
    a widely used example in the Python Language Reference document that tweaks the
    namespace used to create a class.
  prefs: []
  type: TYPE_NORMAL
- en: For more details, see [https://docs.python.org/3/reference/datamodel.html#metaclass-example](https://docs.python.org/3/reference/datamodel.html#metaclass-example)
    .
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The more common cases of an immutable object or a completely flexible object
    are covered in the *Designing classes with little unique processing* recipe.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using more sophisticated collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python has a wide variety of built-in collections. In [Chapter 4](text00048.html#page
    "Chapter 4. Built-in Data Structures – list, set, dict") , *Built-in Data Structures
    – list, set, dict* , we looked at them closely. In the *Choosing a data structure*
    recipe we provided a kind of decision tree to help locate the appropriate data
    structure from the available choices.
  prefs: []
  type: TYPE_NORMAL
- en: When we fold in the standard library, we have more choices, and more decisions
    to make. How can we choose the right data structure for our problem?
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we put data into a collection, we'll need to consider how we'll gather
    the data, and what we'll do with the collection once we have it. The big question
    is always how we'll identify a particular item within the collection. We'll look
    at a few key questions that we need to answer to help select a proper collection
    for our needs.
  prefs: []
  type: TYPE_NORMAL
- en: Here's the overview of the alternative collections. They're in three modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `collections` module contains a number of variations on the built-in collections.
    These include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`deque` : A double-ended queue. It''s a mutable sequence with optimizations
    for pushing and popping from each end. Note that the class name starts with a
    lower-case letter; this is atypical for Python.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`defaultdict` : A mapping that can provide a default value for a missing key.
    Note that the class name starts with a lower-case letter; this is atypical for
    Python.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Counter` : A mapping that is designed to count occurrences of a key. This
    is sometimes called a multiset or a bag.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OrderedDict` : A mapping that retains the order in which keys where created.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ChainMap` : A mapping that combines several dictionaries into a single mapping.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `heapq` module includes a priority queue implementation. This is a specialized
    sequence that maintains items in a sorted order.
  prefs: []
  type: TYPE_NORMAL
- en: The `bisect` module includes methods for searching a sorted list. This creates
    some overlap between the dictionary features and the list features.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are a number of questions we need to answer to decide if we need a library
    data collection instead of one of the built-in collections:'
  prefs: []
  type: TYPE_NORMAL
- en: Is the structure a buffer between the producer and the consumer? Does some part
    of the algorithm produce data items and another part consume the data items?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A common naive approach is for the producer to accumulate items in a list,
    and then the consumer processes the items from the list. This approach will tend
    to build a large intermediate data structure. A change in focus can interleave
    production and consumption, reducing the amount of memory used:'
  prefs: []
  type: TYPE_NORMAL
- en: A queue is used for **First-In-First-Out** ( **FIFO** ) processing. Items are
    inserted at one end and consumed from the other end. We can use `list.append()`
    and `list.pop(0)` to simulate this, though `collections.deque` will be more efficient;
    we can use `deque.append()` and `deque.popleft()` .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A stack is used for **Last-In-First-Out** ( **LIFO** ) processing. Items are
    inserted and consumed from the same end. We can use `list.append()` and `list.pop()`
    to simulate this, though `collections.deque` will be more efficient; we can use
    `deque.append()` and `deque.pop()` .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A priority queue (or heap queue) keeps the queue sorted in some order, distinct
    from the arrival order. This is often used for optimizing work, including graph
    search algorithms. We can simulate this by using `list.append()` , `list.sort(key=lambda
    x:x.priority)` , and `list.pop(-1)` . Since this involves a sort after each insert,
    it's terribly inefficient. Using the `heapq` module is considerably more efficient.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do we want to deal with missing keys from a dictionary?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Raise an exception. This is the way the built-in `dict` class works.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a default item. This is how a `defaultdict` works. We must provide a
    function that returns the default value. Common examples include `defaultdict(int)`
    and `defaultdict(float)` to use a default value of zero. We can also use `defauldict(list)`
    and `defauldict(set)` to create dictionary-of-list or dictionary-of-set structures.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In some cases, we''ll need to to provide a different literal value as the default:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This uses a lambda object to define a very small function that has no name and
    always returns the string `N/A` . This will create a default item of `N/A` for
    missing keys.
  prefs: []
  type: TYPE_NORMAL
- en: The `defaultdict(int)` used to count items is so common that the `Counter` class
    does exactly this.
  prefs: []
  type: TYPE_NORMAL
- en: How do we want to handle the order of keys in a dictionary?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Order doesn't matter; we always set and get items by key. This is the behavior
    of a built-in `dict` class. Key ordering depends on hash randomization, and is,
    therefore, unpredictable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We want to preserve the insert order as well as rapidly find items using their
    key. The `OrderedDict` class provides this unique combination of features. It
    has the same interface as the built-in `dict` class, but preserves the insert
    order of the keys.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We want the keys sorted into their proper order. While a sorted list does this,
    the lookup time for a given key is quite slow. We can use the bisect module to
    provide rapid access to items within a sorted list. This requires a three step
    algorithm:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build the list, perhaps via `append()` or `extend()` .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sort the list. `list.sort()` is all we need for this.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do retrievals from the sorted list, using the `bisect` module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How will we build the dictionary?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have a simple algorithm to create items. In this case, a built-in dict may
    be sufficient.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have multiple dictionaries that will need to be merged. This can happen when
    reading configuration files. We might have an individual configuration, a system-wide
    configuration, and a default application configuration that all need to be merged.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: How can we combine these?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The resulting `config` object will do a sequential search through the various
    dictionaries. It will look in the user, system, and application dictionaries for
    a given key.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two principle resource constraints on data processing:'
  prefs: []
  type: TYPE_NORMAL
- en: Storage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All of our programming must respect these constraints. In most cases, the two
    are in opposition: anything we do to reduce storage use tends to increase processing
    time, and anything we do to reduce processing time increases storage use.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The time aspect is formalized via a complexity metric. There''s considerable
    analysis of the complexity of an algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Operations that are described as *O* (1) happen in constant time. In this case,
    the complexity doesn''t change with the volume of data. For some collections,
    the actual overall long-term average is nearly  ***O*** (1) with minor exceptions.
    List `append` operations are an example: they''re all about the same complexity.
    Once in a while, though, a behind the scenes memory management operation will
    add some time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operations that are described as  *O* (n) happen in linear time. The cost grows
    as the volume of data grows. Finding an item in a list has this complexity. Finding
    an item in a dictionary is closer to  *O* (1) because it's (nearly) the same low
    complexity, no matter how large the dictionary is.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operations that are  ***O*** ( *n* log *n* ) grow more quickly than the volume
    of data. The `bisect` module includes search algorithms that have this complexity.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are even worse cases: some algorithms have a complexity of *O(n² )* or
    even *O(n!)* . We''d like to avoid these through clever design and smarter data
    structures.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The various data structures reflect unique time and storage trade-offs.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As a concrete and extreme example, let''s look at searching a web log file
    for a particular sequence of events. We have two overall design strategies:'
  prefs: []
  type: TYPE_NORMAL
- en: Read all of the events into a list structure with something like `file.read().splitlines()`
    . We can then use a `for` statement to iterate through the list looking for the
    combination of events. While the initial read may take some time, the search will
    be very fast because the log is all in memory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Read each event from a log file. If the event is part of the pattern, save just
    this event. We might use a `defaultdict` with the IP address as the key and a
    list of events as the value. This will take longer to read the logs, but the resulting
    structure in memory will be much smaller.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first algorithm, read everything into memory, is often wildly impractical.
    On a large web server, the logs might involve hundreds of gigabytes, or perhaps
    even terabytes, of data. This won't fit into any computer's memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second approach has a number of alternative implementations:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Single process** : The general approach to most of the Python recipes here
    assumes that we''re creating an application that runs as a single process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Multiple processes** : We might expand the row-by-row search into a multi-processing
    application using the `multiprocessing` or `concurrent` package. We will create
    a collection of worker processes, each of which can process a subset of the available
    data and return the results to a consumer that combines the results. On a modern
    multiprocessor, multi-core computer, this can be a very effective use of resources.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Multiple hosts** : The extreme case requires multiple servers, each of which
    handles a subset of the data. This requires more elaborate coordination among
    the hosts to share result sets. Generally, a framework such as Hadoop is required
    for this kind of processing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll often decompose a large search into map and reduce processing. The map
    phase applies some processing or filtering to every item in the collection. The
    reduce phase combines map results into summary or aggregate objects. In many cases,
    there is a complex hierarchy of **MapReduce** operations applied to the results
    of previous MapReduce operations.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See the *Choosing a data structure* recipe in [Chapter 4](text00048.html#page
    "Chapter 4. Built-in Data Structures – list, set, dict") , *Built-in Data Structures
    – list, set, dict* , for a foundational set of decisions for selecting data structures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extending a collection – a list that does statistics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the *Designing classes with lots of processing* recipe we looked at a way
    to distinguish between a complex algorithm and a collection. We showed how to
    encapsulate the algorithm and the data into separate classes.
  prefs: []
  type: TYPE_NORMAL
- en: The alternative design strategy is to extend the collection to incorporate a
    useful algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: How can we extend Python's built-in collections?
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll create a sophisticated list that can compute the sums and averages of
    the items in the list. This will require that our application only puts numbers
    in the list; otherwise, there will be `ValueError` exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Pick a name for the list that also does simple statistics. Define the class
    as an extension to the built-in `list` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: This shows the syntax for defining an extension to a built-in class. If we provide
    a body that consists only of the `pass` statement, then the new `StatsList` class
    can be used anywhere the `list` class is used.
  prefs: []
  type: TYPE_NORMAL
- en: When we write this, the `list` class is called the superclass of `StatsList`
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'Define the additional processing as new methods. The `self` variable will be
    an object that has inherited all of the attributes and methods from the superclass.
    Here''s a `sum()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: We've used a generator expression to make it perfectly clear that the `sum()`
    function is applied to every item in the list. Using a generator expression allows
    us to do calculations or introduce filters very easily.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s another method that we often apply to a list. This counts items:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: This will count the items in the list. Rather than use the `len()` function,
    we opted to use a generator expression in case we want to add filtering features
    in the future.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the `mean` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are some additional methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The `sum2()` method computes the sum of the squares of values in the list. This
    is used to compute variance. The variance is then used to compute the standard
    deviation of the values in the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `StatsList` object inherits all the features of a `list` object. It is
    extended by the methods that we added. Here''s an example of using this collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve created two `StatsList` objects from a literal list of objects. We used
    the `extend()` method to combine the two objects. Here''s the resulting object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s how we can use the additional methods which we defined on this object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve displayed the results of the `mean()` and `variance()` methods. Of course,
    all the features of the built-in `list` class are all present in our extension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: We used the built-in `sort()` method and used the index feature to extract an
    item from the list. Because there are an odd number of values, this is the median
    value. Note that this mutates the `list` object, changing the order of the items.
    This isn't the best possible implementation for this algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the essential features of class definition is the concept of inheritance.
    When we create a superclass-subclass relationship, the subclass inherits all of
    the features of the superclass. This is sometimes called the generalization-specialization
    relationship. The superclass is a more generalized class; the subclass is more
    specialized because it adds or modifies features.
  prefs: []
  type: TYPE_NORMAL
- en: All of the built-in classes can be extended to add features. In this example,
    we added some statistical processing which created a subclass that's a specialized
    kind of list.
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s an important tension between the two design strategies:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Extending** : In this case, we extended a class to add features. The features
    are deeply entrenched with this single data structure, and we can''t easily use
    them for a different kind of sequence.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Wrapping** : In designing classes with lots of processing, we kept the processing
    separate from the collection. This leads to some more complexity in juggling two
    objects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's difficult to suggest that one of these is inherently superior to the other.
    In many cases, we'll find that wrapping may have an advantage because it seems
    to be a better fit the S.O.L.I.D. design principles. However, there will always
    be cases where it's clearly appropriate to extend a built-in collection.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The idea of generalization can lead to superclasses that are abstractions. An
    abstract class is incomplete, and requires a subclass to extend it and provide
    missing implementation details. We can't make an instance of an abstract class
    because it would be missing features that make it useful.
  prefs: []
  type: TYPE_NORMAL
- en: As we noted in the *Choosing a data structure* recipe in [Chapter 4](text00048.html#page
    "Chapter 4. Built-in Data Structures – list, set, dict") , *Built-in Data Structures
    – list, set, dict* , there are abstract superclasses for all of the built-in collections.
    Rather than start from a concrete class, we can also start our design from an
    abstract base class.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could, for example, start a class definition like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to finish this class, we''ll need to provide an implementation for
    a number of special methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`__getitem__()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__setitem__()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__delitem__()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__iter__()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__len__()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of these methods is missing from the abstract class; they have no concrete
    implementation in the `Mapping` class. Once we've provided workable implementations
    for each method, we can then make instances of the new subclass.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the *Designing classes with lots of processing* recipe we took a different
    approach. In that recipe, we left the complex algorithms in a separate class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using properties for lazy attributes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the *Designing classes with lots of processing* recipe we defined a class
    that eagerly computed a number of attributes of the data in a collection. The
    idea there was to compute the values as soon as possible, so that the attributes
    would have no further computational cost.
  prefs: []
  type: TYPE_NORMAL
- en: We described this as **eager** processing, since the work was done as soon as
    possible. The other approach is **lazy** processing, where the work is done as
    late as possible.
  prefs: []
  type: TYPE_NORMAL
- en: What if we have values that are used rarely, and are very expensive to compute?
    What can we do to minimize the up-front computation, and only compute values when
    they are truly needed?
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's say we've collected data using a `Counter` object. For more information
    on the various collections, see [Chapter 4](text00048.html#page "Chapter 4. Built-in
    Data Structures – list, set, dict") , *Built-in Data Structures – list, set, dict*
    , specifically the *Using set methods and operators* and *Avoiding mutable default
    values for function parameters* recipes. In this case, the customers fall into
    eight categories with approximately equal numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The data looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: In this collection, each key is the number of visits needed to get a full set
    of coupons. The values are the numbers of times that the visits occurred. In the
    preceding data that we saw, there were seven occasions where `15` visits were
    needed to get a full set of coupons. We can see from the sample data that there
    were five occasions where `17` visits were needed. This has a long tail. At only
    one point, there were `45` individual visits before a full set of eight coupons
    was collected.
  prefs: []
  type: TYPE_NORMAL
- en: 'We want to compute some statistics on this `Counter` . We have two overall
    strategies for doing this:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Extend** : We covered this in detail in the *Extending a collection – a list
    that does statistics* recipe, and we will cover this in [Chapter 7](text00079.html#page
    "Chapter 7. More Advanced Class Design") , *More Advanced Class Design* .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Wrap** : We can wrap the `Counter` object in another class that provides
    just the features we need. We''ll look at this in [Chapter 7](text00079.html#page
    "Chapter 7. More Advanced Class Design") , *More Advanced Class Design* .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A common variation on wrapping uses a statistical computation object with a
    separate data collection object. This variation on wrapping often leads to an
    elegant solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'No matter which class architecture we choose, we have two ways to design the
    processing:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Eager** : This means that we''ll compute the statistics as soon as possible.
    This was the approach followed in the *Designing classes with lots of processing*
    recipe.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lazy** : This means we won''t compute anything until it''s required via a
    method function or property. In the *Extending a collection - a list that does
    statistics* recipe, we added methods to a collection class. These additional methods
    are examples of lazy calculation. The statistical values are computed only when
    required.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The essential math for both designs is the same. The only question is when the
    computation is done.
  prefs: []
  type: TYPE_NORMAL
- en: 'The mean, *μ* , is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready...](Image00013.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here, *k* is the key from the `Counter` , *C* , and *f[k]* is the frequency
    value for the given key from the `Counter` .
  prefs: []
  type: TYPE_NORMAL
- en: 'The standard deviation, *σ* , depends on the mean, *μ* . The formula is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready...](Image00014.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here, *k* is the key from the `Counter` , *C* , and *f[k]* is the frequency
    value for the given key from the `Counter` . The total number of items in the
    counter is ![Getting ready...](Image00015.jpg)  .
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Define the class with a descriptive name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Write the initialization method to include the object to which this object
    will be connected:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: We've defined a method function that takes a `Counter` object as an argument
    value. This `counter` object is saved as part of the `Counter_Statistics` instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Define some useful helper methods. Each of these is decorated with `@property`
    to make it behave like a simple attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the required methods for the various values. Here''s the calculation
    of the mean. This too is decorated with `@property` . The other methods can be
    referenced as if they are attributes, even though they are proper method functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s how we can calculate the standard deviation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Note that we've been using `math.sqrt()` . Be sure to add the required `import
    math` statement in the Python file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how we can create some sample data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: We've imported functions such as `expected()` , `arrival1()` , and `coupon_collector()`
    from the `ch04_r06` module. We've imported the `Counter` collection from the standard
    library `collections` module.
  prefs: []
  type: TYPE_NORMAL
- en: We defined a function, `raw_data()` , that will generate a number of customer
    visits. By default, it will be 1,000 visits. The domain will be eight different
    classes of customers; each class will have an equal number of members. We'll use
    the `coupon_collector()` function to step through the data, emitting the number
    of visits required to collect a full set of eight coupons.
  prefs: []
  type: TYPE_NORMAL
- en: This data is then used to assemble a `Counter` object. This will have the number
    of customers required to get a full set of coupons. Each number of customers will
    also have a frequency showing how often that number of visits occurred.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how we can analyze the `Counter` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: First, we imported the `random` module so that we could pick a known `seed`
    value. This makes it easier to test and demonstrate an application because the
    random numbers are consistent. We also imported the `LazyCounterStatistics` class
    from the `ch06_r07` module.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have all of the items defined, we can force the seed to a known value,
    and generate the coupon collector test results. The `raw_data()` function will
    emit a `Counter` object, which we called `data` .
  prefs: []
  type: TYPE_NORMAL
- en: We'll use the `Counter` object to create an instance of the `LazyCounterStatistics`
    class. We'll assign this to the `stats` variable. When we print the value for
    the `stats.mean` property and the `stats.stddev` property, the methods are invoked
    to do the appropriate calculations of the various values.
  prefs: []
  type: TYPE_NORMAL
- en: For a set of eight coupons, the theoretical average is 21.7 visits to collect
    all coupons. It looks like the results from `raw_data()` show behavior that matches
    the expectation of random visits. This is sometimes called the null hypothesis—the
    data is random.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the data really was random. We've validated our approach. We can
    now use this software on real-world data with some confidence that it behaves
    correctly.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The idea of lazy calculation works out well when the value is used rarely. In
    this example, the count is computed twice as part of computing the variance and
    standard deviation.
  prefs: []
  type: TYPE_NORMAL
- en: This shows that being naive about a lazy design may not be optimal in some cases.
    This is an easy problem to fix, in general. We can always create additional local
    variables to save intermediate results.
  prefs: []
  type: TYPE_NORMAL
- en: To make this class look like the class that performs eager calculations, we
    used the `@property` decorator. This makes a method function appear to be an attribute.
    This can only work for method functions that have no argument values.
  prefs: []
  type: TYPE_NORMAL
- en: In all cases, an attribute that's computed eagerly can be replaced by a lazy
    property. The principle reason for creating eager attribute variables is to optimize
    computation costs. In the case where a value is used rarely, a lazy property can
    avoid an expensive calculation.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are some situations in which we can further optimize a property to limit
    the amount of recomputation that's done. This requires a careful analysis of the
    use cases in order to understand the pattern of updates to the underlying data.
  prefs: []
  type: TYPE_NORMAL
- en: In the situation where a collection is loaded with data and an analysis is performed,
    we can cache results to save computing them a second time.
  prefs: []
  type: TYPE_NORMAL
- en: 'We might do something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: This technique uses an attribute to save a copy of the count calculation. This
    value can be computed once and returned as often as needed with no cost for recalculation.
  prefs: []
  type: TYPE_NORMAL
- en: This optimization is only helpful if the state of the `raw_counter` object never
    changes. In an application that updates the underlying `Counter` , this cached
    value would become out of date. That kind of application would need to recreate
    the `LazyCounterStatistics` every time the `Counter` was updated.
  prefs: []
  type: TYPE_NORMAL
- en: See also...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the *Designing classes with lots of processing* recipe, we defined a class
    that eagerly computed a number of attributes. This represents a different strategy
    for managing the cost of the computation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using settable properties to update eager attributes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In several of the previous recipes, we've looked at the important distinction
    between eager and lazy computation. See the *Designing classes with lots of processing*
    recipe for an example of eagerly computing a result and setting object attributes.
    See the *Using properties for lazy attributes* recipe for a way to use properties
    to lazily compute a result.
  prefs: []
  type: TYPE_NORMAL
- en: When an object is stateful, then attribute values must be changed throughout
    the object's life. It's common to use methods to eagerly compute attribute changes,
    but this isn't really necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have the following choices for stateful objects:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Set attribute values via methods:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compute results eagerly, putting results in attributes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compute results lazily, using properties that have syntax that looks like a
    simple attribute
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Set values via attributes:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If results are computed lazily via properties, then the new state can be reflected
    in these calculations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What can we do if we want to use attribute-like syntax for setting a value,
    but we also want to perform eager calculations?
  prefs: []
  type: TYPE_NORMAL
- en: 'This gives us another variation: we can use a property setter to have attribute-like
    syntax. This method can also perform eager calculations of the results.'
  prefs: []
  type: TYPE_NORMAL
- en: For example, we'll use a fairly complex looking object that has several attributes
    that are derived from other attributes. How can we eagerly compute values from
    attribute changes?
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Consider a class that represents a leg of a voyage. It has three principle features—rate,
    time, and distance. Looking at this in general, it's possible to eagerly compute
    any one value from a change in the other two.
  prefs: []
  type: TYPE_NORMAL
- en: We can add features to make this quite a bit more complex. For example, if the
    distance is computed from latitude and longitude, the general approach has to
    be modified somewhat. If we're using specific points instead of a more flexible
    distance, then a distance calculation may involve something like rate, time, starting
    point, and bearing. This involves two interlocked calculations. We won't go quite
    so far in this example; we'll stick to a simpler rate-time-distance calculation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since two attributes must be set to compute the third, the object will have
    a fairly complex set of internal states:'
  prefs: []
  type: TYPE_NORMAL
- en: 'No attributes have been set: everything is unknown.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'One item has been set: nothing can be computed yet.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Two distinct items have been set: now the third can be computed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After this, it''s ideal to support additional attribute changes. The essential
    rule is to compute appropriate new values based on the most recent two distinct
    changes:'
  prefs: []
  type: TYPE_NORMAL
- en: If rate, *r* , and time, *t* , are the last two things that were changed, compute
    the distance, *d* . Use *d = r * t* .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If rate, *r* , and distance, *d* , are the last two things that were changed,
    compute the time, *t* . Use *t = d/r* .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If time, *t* , and distance, *d* , are the last two things that were changed,
    compute the rate, *r* . Use *r = d/t* .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We''d like the object to behave like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: This has the distinct advantage of offering a very simple interface to the `leg`
    object. An application merely sets any two attributes and the calculation is performed
    eagerly to provide a value for the remaining attribute.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ll break this into two parts. First, the general overview of defining settable
    properties, then the details of how to track state changes:'
  prefs: []
  type: TYPE_NORMAL
- en: Define a class with a meaningful name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Provide hidden attributes. These will be exposed as properties:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'For each gettable property, provide a method to compute the property value.
    In many cases, these will parallel the hidden attributes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'For each settable property, provide a method to set the property value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: The setter method has a special property decorator based on the getter method
    name. In this example, the `@property` decorator on the `rate()` method also creates
    a `rate.setter` decorator that can be used to define the setter method for this
    attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the method names for the getter and setter are identical. The `@property`
    and `@rate.setter` decorations distinguish the two methods from each other.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we've saved the value into the hidden attribute, `self._rate`
    . Then, the `_calculate()` method is used to eagerly calculate all of the hidden
    attributes, if possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be repeated for all other properties. In our case, the code for time
    and distance are similar:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The details of tracking the state change rely on a feature of the `collections.deque`
    class. The rule for calculation can be implemented as a two-element bounded queue
    of distinct changes. As each distinct field is changed, we can enqueue the field
    name. The two distinct names in the queue are the last two fields changed; the
    third can be determined from this by set subtraction:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the `deque` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Initialize the queue in the `__init__()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Enqueue each distinct change. Determine what''s missing from the queue, and
    compute this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: If the latest change is not already in the queue, it's appended. Since the queue
    has a bounded size, the oldest item, the one least recently changed, is silently
    popped to keep the queue size fixed.
  prefs: []
  type: TYPE_NORMAL
- en: The difference between the set of available properties, and the set of properties
    recently changed is a single property name. This is the name least recently set;
    the value for this can be computed from the other two that were set more recently.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This works because Python implements a property with a kind of class called
    a **Descriptor** . A descriptor class can have methods for getting a value, setting
    a value, and deleting a value. Depending on the context, one of these methods
    is used implicitly:'
  prefs: []
  type: TYPE_NORMAL
- en: When a descriptor object is used in an expression, the `__get__` method is used
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a descriptor is on the left side of an assignment statement, the `__set__`
    method is used
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a descriptor appears in a `del` statement, the `__delete__` method is used
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `@property` decorator does three things:'
  prefs: []
  type: TYPE_NORMAL
- en: Modifies the following method to be wrapped up in a descriptor object. The method
    that follows is modified to be the descriptor's `__get__` method. It will compute
    values when used in an expression.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adds a `method.setter` decorator. This decorator will modify the method that
    follows to be the descriptor's `__set__` method. When the name is used on the
    left side of an assignment statement, the given method is executed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adds a `method.deleter` decorator. This decorator will modify the method that
    follows to be the descriptor's `__delete__` method. When the name is used in a
    `del` statement, the given method is executed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This allows the building of an attribute name that can be used to provide values,
    set values, and even delete values.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a few more refinements we could make to this class. We'll look at
    two more advanced techniques for initialization and calculation.
  prefs: []
  type: TYPE_NORMAL
- en: Initialization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can provide a way to properly initialize an instance with some values. This
    change makes it possible to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: The example shows how this helps in planning a voyage by a sailboat. If the
    distance to cover is `38.2` nautical miles, and the goal is to finish in `7` hours,
    the boat must reach a speed of `5.46` knots. To shave a half hour off the trip
    requires a speed of `5.88` knots.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this to work, the `__init__()` method needs to be changed. The internal
    `dequeue` object must be built right away. As each attribute is set, the internal
    `_calculate()` method must be used to track the setting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: The `dequeue` function is created first. As each individual field value is set,
    the change is logged in the queue of changed attributes. If two fields are set,
    the third will be computed.
  prefs: []
  type: TYPE_NORMAL
- en: If all three fields are set, then the last two changes—time and distance, in
    this case—will compute a value for `rate` . This will overwrite the provided value.
  prefs: []
  type: TYPE_NORMAL
- en: Calculation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Currently, the various calculations are buried inside an `if` statement. This
    makes changes difficult because a subclass would be forced to supply the entire
    method rather than simply supplying a calculation change.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can remove the `if` statement using an introspection technique. The overall
    design would be better with explicit calculation methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'The following version of `_calculate()` makes use of these methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: When the value of compute is a singleton set, using the `pop()` method extracts
    that one value from the set. Prepending `calc_` to this string gives the name
    of a method that will compute the desired value.
  prefs: []
  type: TYPE_NORMAL
- en: The `getattr()` function does a lookup to find the requested method of the object,
    `self` . This is then evaluated as a bound function. It can update attributes
    with the desired result.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring the calculations into separate methods makes the class more open
    to extension. We can now create a subclass that includes revised calculations,
    but preserves the overall features of the class.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For more information on working with sets, see the *Using set methods and operators*
    recipe in [Chapter 4](text00048.html#page "Chapter 4. Built-in Data Structures
    – list, set, dict") , *Built-in Data Structures – list, set, dict* .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `dequeue` , effectively, is a list that's highly optimized for append and
    pop operations. See the *Deleting from a list – deleting, removing, popping, and
    filtering* recipe in [Chapter 4](text00048.html#page "Chapter 4. Built-in Data
    Structures – list, set, dict") , *Built-in Data Structures – list, set, dict*
    .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
