- en: Chapter 5. Developers' Treasure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this very chapter, we will kick start by building a web server using Python.
    We will then see how to process all our images automatically using ImageMagick.
    Then, we will look at the git flow branching model and how it will help you. Furthermore,
    we will see how meld command line can help merge our git conflicts. We will then
    focus on the working of ngrok tool and see how it saves the day by proxying requests
    coming from the internet to our laptop. We will also explore the versatile query
    capabilities of jq, the Swiss army knife of JSON! Towards the end, we will explore
    ways in which one can manage and kill Linux processes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Shrinking spells and other ImageMagick
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the work of git flow branching models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using ngrok to secure tunnels to localhost
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting yourself acquainted with jq
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The spot webserver
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have prepared a basic demo `html` file that contains a button, a `div`,
    a `jquery` function (for helping us do some `ajax` calls), and a script that will
    try to load static content from our server and put the content inside the `div`
    tag. The script is trying to load a simple text file on the disk, `/file`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The spot webserver](img/image_05_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If we open this file inside our browser, we can see the page content:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The spot webserver](img/image_05_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Clicking on the button generates a `javascript` error. It is telling us that
    we want to do a cross-origin request, which is not allowed by default by the browser.
    This is to prevent cross-site scripting attacks. What we need to do in order to
    test our `javascript` code is to serve this file in an HTTP server.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to start an HTTP server in the same folder as the file, we type the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '![The spot webserver](img/image_05_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This is a basic Python module that opens port `8000` on localhost, serving
    only static content (so, no, you can''t use it for `php`). Let''s open the address
    in the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the **Click me!** button. We see that our file content was loaded
    in the `div` beneath the button, which means the browser is no longer blocking
    us, because we are issuing requests to the same host using the same protocol.
    Looking at the output from our Python server, we can see all the requests that
    the browser has made to the server. We can see it''s requesting by default a `favicon.ico`
    file that doesn''t exist and it''s giving back a `404` status code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The spot webserver](img/image_05_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can find the files used in this project on the GitHub project page.
  prefs: []
  type: TYPE_NORMAL
- en: Also, if we stop the server and go one level up and fire it up again, we can
    use it as a `webdav` server, with the possibility of navigating through the files
    in the current directory. We could, for example, give access to a folder on our
    local machine to a remote user and allow them to access it through a page in the
    browser, eliminating the need to install a file server.
  prefs: []
  type: TYPE_NORMAL
- en: Shrinking spells and other ImageMagick
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn how to process images from the command line.
    We will start with the most complex and widely used image command line interface
    processing toolkit called **ImageMagick**. To install it, run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '![Shrinking spells and other ImageMagick](img/image_05_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, we have already installed it.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's find some images to process. Let's use the default Ubuntu backgrounds
    that can be found in `/usr/share/backgrounds`. Let's copy the backgrounds to another
    location so that we don't alter our default ones.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll take a look at the first image in our list: we can see from `ls` that
    it is a JPEG image of 1.6 MB. To open it and see how it looks, let''s use the
    **eog** (**eye of gnome**) image viewer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Shrinking spells and other ImageMagick](img/vlcsnap-00001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The first and most important part of knowing how to process an image is knowing
    what that image actually is. To find this out, ImageMagick comes with a tool called
    **identify**. In its simplest form, you have to feed it an image name and it will
    output information like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We can see that the file is a JPEG image of 1.6 MB and most importantly, its
    size is 3,840x2,400 pixels.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we look at the `warty-final-ubuntu.png` we see that the output format is
    similar: the size and resolution are higher and the image format is PNG. Let''s
    see what it looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '![Shrinking spells and other ImageMagick](img/image_05_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'PNG images usually take more space than JPEG images. If you don''t have transparency,
    it is recommended to use `.jpg`. In order to convert from one type to the other,
    we use the `imagemagick` `convert` command with two parameters: input filename
    and output filename:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '![Shrinking spells and other ImageMagick](img/image_05_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The format of the output image will be deduced by `convert` from the filename
    extension. As you can see, the output is a JPEG image with the same resolution,
    but with a much smaller size than the PNG version: 180 KB compared to 2.6 MB.
    If we open the image, we can''t see any noticeable differences. This is a big
    thing when it comes to web development, because if we were to use this picture
    on a web page, it would load as much as 15 times faster than the PNG version.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to crop a region of the image, we can do that with `convert`. For
    example, if we want to cut a 500x500 piece of the image, starting at coordinates
    100,100, we would use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '![Shrinking spells and other ImageMagick](img/image_05_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As we can see, the output image is at the resolution we requested, but it has
    a much lower size of only 2.5 KB. Visually analyzing the two images we can see
    that the cropped one is a section of the big picture. Normally you wouldn't want
    to guess pixels in the command line, but would use an image processing software,
    such as GIMP, to do the work for you, so that you can visually select and crop
    portions of the images. However, when developing software applications, it is
    often the case that you have to programmatically crop images, in which case this
    comes in handy.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `convert` command is also good at creating images. If we want to create
    an image from a text string, we could use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '![Shrinking spells and other ImageMagick](img/image_05_009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This will create a JPEG image with a height of 80 pixels, containing the text
    specified, in this case the string `123`. We can see the output, it is a 3.4 KB
    image and, if we look at it visually, we see the text `123`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Shrinking spells and other ImageMagick](img/image_05_010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This can also come in handy in different scenarios where you need to programmatically
    generate readable images, such as using CAPTCHA software or generating default
    profile images with the user's initials.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s look at some image shrinking tools outside of `imagemagick`. The
    first one is a `png` shrinking tool called `pngquant`. We will install it by typing
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '![Shrinking spells and other ImageMagick](img/image_05_011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s try to shrink the large PNG image that we were looking at earlier. If
    the image contains transparency and it is necessary to keep it in the PNG format,
    we would just call `pngquant` with the following image name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '![Shrinking spells and other ImageMagick](img/image_05_012.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'By default, it outputs a file with the same name and an added `fs8` extension.
    We can see that the difference in size is also noticeable (it''s smaller by 1
    MB, which is almost half the original size). If we visually compare the images,
    we won''t be able to spot any differences:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Shrinking spells and other ImageMagick](img/image_05_013.jpg)![Shrinking
    spells and other ImageMagick](img/image_05_014.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Alright, now let's try and do the same thing for JPEG images.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this, we''ll install the equivalent of `pngquant,` which is `jpegoptim`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '![Shrinking spells and other ImageMagick](img/image_05_015.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We will call it the same way and we''re just going to give it a command-line
    argument, which is the file to shrink. Let''s pick some random images to try and
    see if we can reduce their size:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Shrinking spells and other ImageMagick](img/image_05_016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see from the output, it is saying **Skipped**. That means the image
    had already been shrunk (the guys at Ubuntu probably used the same tool before
    submitting the image). If we try it again on the JPEG produced by `imagemagick`,
    you can see that it is also skipped: `imagemagick` already uses the minimum necessary
    format.'
  prefs: []
  type: TYPE_NORMAL
- en: The image processing tools come in especially handy when it comes to web development,
    where lots of images need to be used and their size needs to be as small as possible.
    Command-line tools are really useful because they can be used to automate tasks.
    Image shrinking is usually added to build tasks, where production versions of
    websites are prepared. The `imagemagick` toolkit comes with a lot more tools than
    the ones we have seen today, so feel free to explore other handy commands from
    the toolkit. Also, when it comes to graphically processing the images, there are
    some great open source tools like GIMP and Inkscape that can really help you get
    your job done, and also save you a lot of money.
  prefs: []
  type: TYPE_NORMAL
- en: Go with the Git flow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Git** is by far the most popular version control system out there. In this
    chapter, we will be looking at a plugin for Git, called **GitFlow**, which proposes
    a branching model for software projects. This branching model doesn''t offer much
    help when it comes to small projects, but it''s a great benefit to medium sized
    and large projects. We will be looking at a variation of the `git-flow` plugin,
    called `gitflow-avh`, which adds extra functionality, such as **Git hooks**, [https://github.com/petervanderdoes/gitflow-avh](https://github.com/petervanderdoes/gitflow-avh).'
  prefs: []
  type: TYPE_NORMAL
- en: To install it, we'll follow the instructions on the GitHub page. We are on Ubuntu,
    so we will follow the installation instructions for Linux.
  prefs: []
  type: TYPE_NORMAL
- en: We can see that it can be directly installed with the `apt` command, but apt
    doesn't usually contain the latest version of the software, so today we will do
    a manual installation. We want to pick the stable version, and use the one line
    command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once this is done, let''s create a dummy project. We''ll create an empty directory
    and initialize it as a Git repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '![Go with the Git flow](img/image_05_017.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Basic Git usage is not part of this course, and we are assuming that you understand
    the basics.
  prefs: []
  type: TYPE_NORMAL
- en: 'All right. A good way to get started with `git-flow` is to read the excellent
    cheatsheet created by Daniel Kummer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://danielkummer.github.io/git-flow-cheatsheet/](http://danielkummer.github.io/git-flow-cheatsheet/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'This provides the basic tips and tricks to get you started quickly with `git-flow`.
    So the first thing the cheatsheet suggests is to run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '![Go with the Git flow](img/image_05_018.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To configure it, we need to answer a bunch of questions about what names the
    branches should have in each flow and what the version tag prefix and hooks directory
    are. Let''s just leave the defaults. Now, let''s run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '![Go with the Git flow](img/image_05_019.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We can see that we are now on the `develop` branch, so no more developing on
    the `master` branch. This helps us have a stable master, while not so stable features
    are kept on the `develop` branch.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we go back to the cheatsheet, we can look at the first item, which is a
    feature branch. Feature branches are useful when developing a specific part of
    functionality or doing refactoring, but you don''t want to break the existing
    functionality on the develop branch. To create a feature branch, just run the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '![Go with the Git flow](img/image_05_020.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is not the most intuitive description of the feature, but it's good for
    demonstration purposes. `GitFlow` will also show us a summary of actions once
    the feature branch has finished. This has created a new branch called `feature/feature1`,
    based on the develop branch and has switched us to that branch. We can also see
    this from our handy `zsh` prompt.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s open up a file, edit, and save it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '![Go with the Git flow](img/image_05_021.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This command will tell us that we have an uncommitted file. Let's go ahead and
    commit it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now `git commit` is using the `nano` editor for editing the commit message.
    Since we prefer `vim`, let''s go ahead and change the default editor to `vim`.
    All we need to do is add this line in our `zshrc` and reload it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Now when we do a `git commit` Vim opens up, shows us a summary of the commit,
    and closes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s assume that we''ve finished adding a new feature. It''s time to
    merge the feature branch back to develop with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '![Go with the Git flow](img/image_05_022.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Again, to get a summary of actions:'
  prefs: []
  type: TYPE_NORMAL
- en: The feature branch was merged back to develop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The feature branch has been deleted
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The current branch was switched back to develop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we do an `ls`, we see the file from our branch present on the develop branch.
    Looking at the cheatsheet we see a graphical representation of this process.
  prefs: []
  type: TYPE_NORMAL
- en: Next up is starting a release. Release branches are good for stopping the incoming
    features and bug fixes from the develop branch, testing the current version, submitting
    bug fixes on it, and releasing it to the general public.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we can see, the syntax is similar, the process is similar, the develop is
    branched to a release branch, but when it comes to finishing the branch, the features
    are also merged to the master branch, and a tag is cut from this branch. Time
    to see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '![Go with the Git flow](img/image_05_023.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This switches us over to our `release/1.0.0` branch. Let's add a `releasenotes.txt`
    file to show what has changed in this release. Added more bugs…Hopefully not!
  prefs: []
  type: TYPE_NORMAL
- en: Let's commit the file.
  prefs: []
  type: TYPE_NORMAL
- en: This is usually the case when you start to run your integration and stress testing,
    to see if all is well and to check that there are no bugs.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the testing is finished, we go ahead and finish our release branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '![Go with the Git flow](img/image_05_024.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'It will prompt us for a series of release messages: we will leave all the defaults.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Checking out the summary, we can see that:'
  prefs: []
  type: TYPE_NORMAL
- en: The release branch was merged into master
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A tag was cut from master with the release version
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The tag has also been merged into develop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The release branch has been deleted
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And we are back on the develop branch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, we run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '![Go with the Git flow](img/image_05_025.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We see that the only two available branches are master and develop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '![Go with the Git flow](img/image_05_026.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This tells us that there is a 1.0.0 tag cut. We can see that the branch now
    contains two files from the merge of the feature and release branch; and if we
    also switch to the master branch, we can see that, at this point, master is an
    exact replica of develop:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Go with the Git flow](img/image_05_027.jpg)'
  prefs: []
  type: TYPE_IMG
- en: GitFlow also comes with an enhanced hooks functionality. If we read the documentation,
    we can see all the possible hooks in the `hooks` folder. Let's add a `git` hook
    that will be executed before every hotfix branch. For this we just open the template,
    copy the content, and paste it to a file with the name `pre-flow-hotfix-start`
    in our `.git/hooks` directory.
  prefs: []
  type: TYPE_NORMAL
- en: GitFlow has more workflows than the ones presented. We won't go through all
    of them, but you can find additional information by visiting the cheatsheet page
    or by reading the instructions on the GitHub page.
  prefs: []
  type: TYPE_NORMAL
- en: Let's just simply `echo` a message with the version and origin.
  prefs: []
  type: TYPE_NORMAL
- en: If we look at the `hotfix` flow, we can see that they are created from the master
    branch and merged back to master and develop, with a tag on master.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see if it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '![Go with the Git flow](img/image_05_028.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Apparently not. Something went wrong, our script was not executed and we need
    to delete our branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '![Go with the Git flow](img/image_05_029.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Analyzing the `git hooks` directory, we see that our hook does not have execution
    permissions. After adding execution permissions, and running the `git hook` command
    again, we can see our message on the top of the hotfix output. Let''s finish this
    hotfix with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '![Go with the Git flow](img/image_05_030.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the commands are quite straightforward. There is also an `oh-my-zsh`
    plugin that you can activate to have command line completion.
  prefs: []
  type: TYPE_NORMAL
- en: As we said earlier, this is a plugin suitable for teams of developers working
    on multiple features, fixing bugs, and releasing hotfixes all at the same time.
    GitFlow is simple to learn, and helps teams have a correct workflow where they
    can easily prepare patches for production code, without worrying about the extra
    functionalities developed on the master branch.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can tweak the `config` as you like: some people prefer to place the `hooks`
    folder in a different place so that it is committed on the `git repo` and they
    don''t have to worry about copying the files over; others continue to develop
    on the master branch and use a separate branch such as customer for the production
    code.'
  prefs: []
  type: TYPE_NORMAL
- en: Merging Git conflicts with ease
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now let's look at another improvement that we can bring to `git`. Most tasks
    are easy to execute from the command line, but some tasks, such as merging, require
    a specialist's eye for understanding the different format.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s open the `feature` file from our previous chapter, edit it, add a new
    line, and save it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '![Merging Git conflicts with ease](img/image_05_031.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `git diff` command will show us colored text explaining the differences
    between the `git` file and the modified file, but some people find this format
    hard to understand:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Merging Git conflicts with ease](img/image_05_032.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Luckily, we can tell `git` to use external tools when it comes to merge and
    one external tool that we can use is called **Meld**. Let''s install it using
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '![Merging Git conflicts with ease](img/image_05_033.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'After this, we can run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '![Merging Git conflicts with ease](img/image_05_034.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'It will ask us if we want to launch Meld as an external program for viewing
    the file. It''s also giving us a list of tools that it can use for displaying
    the difference. Hit `y` to open Meld:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Merging Git conflicts with ease](img/image_05_035.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now we can easily see the two files side by side and the differences between
    them. We can see that `1` has been changed to `2` and a new line has been added.
    Based on this output we can easily decide if we want to add it or not. Let's commit
    the file as it is.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will look at merge conflicts. Let''s manually create a branch called
    **test** and **edit** the same file, commit it, and then switch back to the develop
    branch. Let''s update the same file, commit it, and then try to merge the `test`
    branch: and, of course, there is a merge conflict.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For resolving the conflict, we will be using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '![Merging Git conflicts with ease](img/image_05_036.jpg)![Merging Git conflicts
    with ease](img/image_05_037.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Again, it offers to open Meld. In Meld we can see the three files:'
  prefs: []
  type: TYPE_NORMAL
- en: On the left is the file from our current branch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the right is the file from the remote branch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the middle is the resulting file that will be created
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s say that we decide the correct version for the feature is `4` and that
    we also want to add `of text`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '![Merging Git conflicts with ease](img/image_05_038.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can see the predefined commit message. Don''t forget to remove the temporary
    file that was created at the merge:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Merging Git conflicts with ease](img/image_05_039.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In general, most modern IDEs offer plugins for working with `git`, including
    merging and `diffs`. We recommend that you get more acquainted with the command-line
    tools, because then you don't need to learn a new `git` plugin when switching
    from one IDE to another.
  prefs: []
  type: TYPE_NORMAL
- en: The `git` command works the same way across Linux, Mac, and Windows. It is a
    tool that developers use a lot and being fluent in it will boost your productivity.
  prefs: []
  type: TYPE_NORMAL
- en: From localhost to instant DNS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Often, especially when working with other people or when developing integrations
    with online services, we have to make our computer accessible from the Internet.
    This information could be obtained from our trusty router, but wouldn't it be
    easier if we just had a tool that makes our computer port publicly accessible?
  prefs: []
  type: TYPE_NORMAL
- en: Luckily for us there is such a tool!
  prefs: []
  type: TYPE_NORMAL
- en: Meet `ngrok`, the versatile one line command that makes you forget about router
    configuration and continuous redeploys. `Ngrok` is a simple tool that exposes
    a port from our computer to a unique domain name publicly available on the Internet.
  prefs: []
  type: TYPE_NORMAL
- en: How does it do it?
  prefs: []
  type: TYPE_NORMAL
- en: Well, let's see it in action!
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to the website, click on the **Download** button, and choose your destiny.
    In our case, our destiny is the Linux package in 64-bit. Next, go to the terminal,
    unzip the file, and copy its contents to the `bin` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '`cd` downloads'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unzip ngrok.zip`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mv ngrok ~/bin`![From localhost to instant DNS](img/image_05_040.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now do a rehash and type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '![From localhost to instant DNS](img/image_05_041.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can see that port forwarding for ports 80 and 443 is running on our local
    80 port, at a custom `ngrok` subdomain name. We can also see the region of the
    server, which by default is located in the US. If we are in a different region
    we can set this with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ngrok` server is located in Europe. In order to test our `ngrok` server,
    let''s use our trusty Python server to show a simple HTML page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '![From localhost to instant DNS](img/image_05_042.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Then restart `ngrok` with the HTTP traffic forwarded from port `8000`, the
    default Python web server port:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '![From localhost to instant DNS](img/image_05_043.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Click on the link provided by `ngrok`, and we will see our web page accessible
    to the Internet.
  prefs: []
  type: TYPE_NORMAL
- en: That's it. No configuration, no account, no headaches. Just a simple one line
    command that we can run from anywhere. The subdomain provided by `ngrok` is a
    generated one and will change every time we restart `ngrok`. We have the option
    of using our custom domain name like Linux [https://ngrok.com/](https://ngrok.com/),
    but only after acquiring a paid account.
  prefs: []
  type: TYPE_NORMAL
- en: The `ngrok` also has a web interface at `http://127.0.0.1:4040` where we can
    see statistics and logs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Power comes from ease of use and `ngrok` provides us with that power:'
  prefs: []
  type: TYPE_NORMAL
- en: '![From localhost to instant DNS](img/image_05_044.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here are some specific scenarios for using this powerful tool:'
  prefs: []
  type: TYPE_NORMAL
- en: When testing integrations with online services that require a callback `url`,
    such as oAuth login and online payments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When developing mobile applications that connect to a local service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we want to expose an `ssh` port
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we want to give our clients access to a webpage on our laptop, to show
    them some code, maybe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JSON jamming in the new age
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nowadays, JSON is everywhere, in web `apis`, in configuration files, even in
    logs. JSON is the default format used to structure data. Because it is used so
    much, there will be times when we will need to process JSON from the command line.
    Could you imagine doing this with `grep`, `sed,` or other conventional tools?
    That would be quite a challenge.
  prefs: []
  type: TYPE_NORMAL
- en: Luckily for us, there is a simple Command-line tool called `jq` that we can
    use to query JSON files. It comes with its own language syntax, as we will see
    in just a few minutes.
  prefs: []
  type: TYPE_NORMAL
- en: 'First let''s install `jq` with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '![JSON jamming in the new age](img/image_05_045.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now let''s use an example file, a dummy access log in JSON format: `access.log`,
    which we can also find in the course GitHub repository.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with some simple queries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '![JSON jamming in the new age](img/image_05_046.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We will print the JSON objects back to the screen, in a pretty format:'
  prefs: []
  type: TYPE_NORMAL
- en: '![JSON jamming in the new age](img/image_05_047.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If we want to grab the `request` method from each request, run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '![JSON jamming in the new age](img/image_05_048.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This will print the request method from each `json` object. Notice the double
    quotes around each method:'
  prefs: []
  type: TYPE_NORMAL
- en: '![JSON jamming in the new age](img/image_05_049.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If we want to use the output as input to other scripts we probably don''t want
    the double quotes and that is where the `-r` (raw output) comes in handy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '![JSON jamming in the new age](img/image_05_050.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `jq` is often used for big data queries at a much smaller scale:'
  prefs: []
  type: TYPE_NORMAL
- en: '![JSON jamming in the new age](img/image_05_051.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Say, for example, if we want to calculate a statistic of request methods on
    the log file, we could run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '![JSON jamming in the new age](img/image_05_052.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now we can see a count of `get`, `put`, `post,` and `delete` requests. If we
    want the same type of calculation for another field, say `apikey`, we can run
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '![JSON jamming in the new age](img/image_05_053.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Since that the syntax for accessing nested fields is to just use the dot as
    a delimiter between them. Also notice that we are using single quotes instead
    of double quotes to mark our query as a string. As you probably know, the difference
    between single and double quotes in shell scripting is that double-quoted strings
    will try to expand variables, while single quoted strings will be treated as a
    fixed string.
  prefs: []
  type: TYPE_NORMAL
- en: 'To query for the request bodies, we will be using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '![JSON jamming in the new age](img/image_05_054.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As we can see from the output, even empty request bodies are logged and will
    be printed by `jq`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![JSON jamming in the new age](img/image_05_055.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To skip printing empty bodies, we can use jq''s query language to select all
    documents without an empty body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '![JSON jamming in the new age](img/image_05_056.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If we want to refine our search even more and only print the first element
    in the `dataIds` object of the request body, use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '![JSON jamming in the new age](img/image_05_057.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can even perform arithmetic operations with the returned value, such as
    incrementing it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '![JSON jamming in the new age](img/image_05_058.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'There are many more examples and use cases for `jq`: just go to the official
    `jq` page and visit the tutorial there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://stedolan.github.io/jq/tutorial/](https://stedolan.github.io/jq/tutorial/)'
  prefs: []
  type: TYPE_NORMAL
- en: '![JSON jamming in the new age](img/image_05_059.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'There we can see an example of consuming a rest API that returns `json` and
    pipes it to `jq`. To print a `json` with the commit messages from a `github` repository,
    run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: As we said, there are many more examples in the documentation, and many more
    use cases. `jq` is a pretty powerful tool, and a must when interacting with `json`
    from the command line.
  prefs: []
  type: TYPE_NORMAL
- en: No more mister nice guy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The kernel and command line in Linux are stable and powerful. Their reliability
    has been proven throughout the years, with modern legends about Linux servers
    running for multiple years in a row without restarting. However, graphical interfaces
    are not the same, and they sometimes fail or become unresponsive. This can become
    annoying and it's always good to have a quick way of killing unresponsive windows.
    Prepare to meet `xkill`.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s replicate an unresponsive window. Go to the terminal and start
    `gedit`: and then hit *Ctrl* + *z*. This will send `gedit` to the background,
    while the window is still visible. Trying to click inside the window a couple
    of times will tell Ubuntu that there is no process handling this window anymore
    and Ubuntu will make it gray:'
  prefs: []
  type: TYPE_NORMAL
- en: '![No more mister nice guy](img/image_05_060.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Hit *Ctrl* + *z*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![No more mister nice guy](img/image_05_061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This will send `gedit` to the background, while the window is still visible.
    Trying to click inside the window a couple of times will tell Ubuntu that there
    is no process handling this window anymore and Ubuntu will make it grey:'
  prefs: []
  type: TYPE_NORMAL
- en: '![No more mister nice guy](img/image_05_062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To avoid the process of grepping for the `pid` of the window and then killing
    that process we use a little trick. Go to the terminal and run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '![No more mister nice guy](img/image_05_063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now we see that the mouse pointer has changed to an `x`.
  prefs: []
  type: TYPE_NORMAL
- en: Be careful not to click on anything. Hit *Alt* + *Tab* to bring back the `gedit`
    window, and then click it. The `xkill` command will find and kill the process
    of the window we just clicked on.
  prefs: []
  type: TYPE_NORMAL
- en: This trick can be used on any type of window; it's like shooting your windows!
  prefs: []
  type: TYPE_NORMAL
- en: OK, but what happens if the whole system becomes unresponsive and you can't
    type anything in the command line? That might happen, especially on older systems.
    You can hit the **on/off** button on your laptop or server, but in some circumstances,
    this is not possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'What we are going to show you now is an old trick kept secret by Linux gurus
    for a very long time; nobody really talks about it because it''s so powerful that
    it can do damage in the hands of the wrong people. Please make sure you save all
    your work and close all programs before trying the fatal keyboard shortcut that
    will force a restart of your Linux system. Hold down *Alt* + *PrtScrn* and at
    the same time type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: If you've tried it, it means that your computer restarted and you had to come
    back to this course and continue where you left off.
  prefs: []
  type: TYPE_NORMAL
- en: Practice this command with great caution and please don't use it to restart
    your computer on a regular basis. Use it only when the **graphical user interface**
    (**GUI**) is not responding.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another trick: if the GUI is not responding and you have unsaved work, you
    can recover some of it from the command line, by accessing one of Linux''s virtual
    terminals. Ubuntu starts, by default, seven virtual terminals and the graphical
    user interface starts on terminal 7\. To access any of the seven terminals use
    *Ctrl* + *Alt* + *F1* to *F7*. A prompt will appear asking you to log in and,
    after logging in, you can run some commands to close processes and save work before
    exiting. To get back to the user interface, hit *Ctrl* + *Alt* + *F1*.'
  prefs: []
  type: TYPE_NORMAL
