- en: Device Development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Android Studio provides some very powerful layout tools, enabling us to quickly
    and easily experiment with and develop user interfaces. However, perhaps the biggest
    challenge any Android developer faces is the bewildering number of form factors
    their applications could run on.
  prefs: []
  type: TYPE_NORMAL
- en: We saw in previous chapters how classes, for example the constraint layout and
    libraries such as the percent library, help us design uniform and consistent layouts.
    However, these techniques only provide general solutions, and we will all have
    stumbled across apps that do not really seem to have been designed with our device
    in mind. With a little knowledge and effort, these design faults can easily be
    avoided.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn to:'
  prefs: []
  type: TYPE_NORMAL
- en: Create alternative layout files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extract string resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manage screen rotation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configure resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create wearable UIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build shape-aware layouts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Read sensor data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use virtual sensors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apply Studio's templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a debug filter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitor devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Before looking into how to develop our UIs so that they look great on all our
    users'' devices, we need to explore the most significant layout situation we will
    encounter: the rotation of a screen between portrait and landscape mode.'
  prefs: []
  type: TYPE_NORMAL
- en: Screen orientation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A large percentage of Android apps designed for phones and tablets are designed
    to work in both landscape and portrait mode and generally switch between these
    automatically. Many activities, such as videos, are best viewed in landscape mode,
    while lists are usually easier to scan in portrait; however, and there are some
    activities, and even entire apps, where the orientation is fixed.
  prefs: []
  type: TYPE_NORMAL
- en: There are some layouts that look equally good, whichever way they are viewed,
    but this is not often the case; most of the time, we will want to design one for
    each orientation. Android Studio simplifies and speeds up this process by saving
    us the task of developing an alternative layout from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a simple layout like the one here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b68e6b36-0318-4852-8875-94af4d3edc75.png)'
  prefs: []
  type: TYPE_IMG
- en: A portrait layout
  prefs: []
  type: TYPE_NORMAL
- en: 'A landscape variant can be created with a single click from the Layout Variant
    tool at the top of the design editor, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/19fba689-187b-4295-83ce-8e0026bb9d00.png)'
  prefs: []
  type: TYPE_IMG
- en: The Layout Variant tool.
  prefs: []
  type: TYPE_NORMAL
- en: If you recreate this exercise or create an equivalent of your own, you will
    soon see that a layout like this does not look good when just rotated, and you
    will have to reposition the views to best suit this aspect ratio. If you try this
    with a constraint layout, you will of discovered one of its few weaknesses, and
    the resultant layout can be quite a mess.
  prefs: []
  type: TYPE_NORMAL
- en: Just how you recreate these layouts is down to your own artistic and design
    skills, but what is worth noting is the manner in which Android Studio stores
    and presents these files as this can be a little confusing, particularly if you
    are migrating from Eclipse, which manages this differently.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you open the project you just created in the Project Explorer, under Android
    you will find the landscape variant as `activity_main.xml (land)`, apparently
    inside the `activity_main.xml` directory. Studio presents it like this because
    it is convenient to have all our layouts in one place, but this is not how they
    are stored. Switching the Project Explorer to the Project view will display the
    actual file structure, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e32b1477-579f-4676-921e-8ac8adb9b3ce.png)'
  prefs: []
  type: TYPE_IMG
- en: Project structure.
  prefs: []
  type: TYPE_NORMAL
- en: This structure can also be determined from the navigation bar at the top of
    the IDE.
  prefs: []
  type: TYPE_NORMAL
- en: If you create layout variants like this, moving views into a more pleasing configuration,
    and give both versions the same ID, these will automatically animate between their
    two states when a user rotates their device. We will later see how to construct
    our own custom animations, but more often than not, the default animations are
    the best choice as they help promote a uniform user experience.
  prefs: []
  type: TYPE_NORMAL
- en: If you recreated the example above, you may have noticed a rather neat trick
    that the IDE performs to speed up the process of providing text resources.
  prefs: []
  type: TYPE_NORMAL
- en: You will already know that the use of hard-coded strings is strongly deprecated.
    Like many programming paradigms, Android development is designed so that data
    and code are created and worked on separately. Hard-coded strings also make translations
    nearly impossible.
  prefs: []
  type: TYPE_NORMAL
- en: We saw previously how the quick-fix function allows us to automatically implement
    methods. Here, we can use it to create string resources without ever even having
    to open the `strings.xml` file.
  prefs: []
  type: TYPE_NORMAL
- en: Simply enter a hard-coded string in your layout file and follow the quick-fix
    prompt to extract it as a string resource.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b830abda-83eb-49a7-a67e-f1bcad19159f.png)'
  prefs: []
  type: TYPE_IMG
- en: String resource extraction.
  prefs: []
  type: TYPE_NORMAL
- en: The Layout Editor provides two ready made variants, landscape and extra large,
    but we can create variants of our own to suit any form factor we choose.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have started to add some dynamic elements such as screen rotation,
    the Layout Editor is not enough and we need to run our apps on a device or emulator.
  prefs: []
  type: TYPE_NORMAL
- en: Virtual devices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For a long time, **Android Virtual Devices** (**AVDs**) had the reputation of
    being buggy and horrendously slow. The introduction of hardware acceleration has
    made a big difference, but a powerful computer is still advised, especially if
    you want to run more than one at a time, which is very often the case.
  prefs: []
  type: TYPE_NORMAL
- en: The biggest change to Android emulation is not hardware acceleration, but rather
    the appearance of alternative emulators. As we shall see shortly, some of these
    offer distinct advantages over the native emulator, but AVDs should not be written
    off. Despite the drawbacks, Android emulators are the only emulators that run
    on all Android versions, including the most recent, developer-only, versions.
    Not only this, but Android emulators are the most customizable and any possible
    hardware or software configuration can be recreated with a little effort.
  prefs: []
  type: TYPE_NORMAL
- en: Early on in the development process, it is important to be able to test out
    our ideas quickly and using one or two real-world devices is probably the best
    choice for this level of testing; however, sooner or later we are going to need
    to make sure that our layouts look great on all possible devices.
  prefs: []
  type: TYPE_NORMAL
- en: Layout and image qualification
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two issues that we need to consider here: screen density and aspect
    ratio. If you have done any Android development before, you will be aware of DPI
    and screen size groupings. These designated folders provide handy shortcuts to
    suit the enormous variety of available form factors, but we will all have experienced
    apps with layouts that don''t quite work on our devices. This is something that
    is entirely avoidable, and although countering it will take some effort on our
    part, it will result in avoiding those poor ratings that can so damage a revenue
    stream.'
  prefs: []
  type: TYPE_NORMAL
- en: It is very tempting to create an app that will work on as many form factors
    as possible, and Android Studio will occasionally encourage you to think that
    way. In reality we have to think about when and where devices are used. If we
    are waiting for a bus, then we probably want a game that is easily switched on
    and off and where tasks can be completed quickly. And although there are exceptions,
    these are not the same games that people choose to play on large screens for long
    periods. Picking the right platform is essential, and although it may sound counter-intuitive,
    it is often wiser to exclude a platform than just assume it may earn a little
    more revenue.
  prefs: []
  type: TYPE_NORMAL
- en: Bearing this in mind, we will consider an app designed only for phones and tablets;
    however as well as looking at familiar features such as screen size and density,
    we will see how we can provide customized resources for many other configuration
    issues.
  prefs: []
  type: TYPE_NORMAL
- en: The two most commonly used resource designations are screen size and density.
    Android provides the following four size designations.
  prefs: []
  type: TYPE_NORMAL
- en: '`layout-small`: from two to four inches, 320 x 420dp or larger'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`layout-normal`: from three to five inches, 320 x 480dp or larger'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`layout-large`: from four to seven inches, 480 x 640dp or larger'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`layout-xlarge`: from seven to 10 inches, 720 x 960dp or larger'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are developing for Android 3.0 (API level 11) or below, devices at the
    lower end of this scale will often be categorized incorrectly. The only solution
    to this is to configure for individual devices or avoid developing for such devices
    at all.
  prefs: []
  type: TYPE_NORMAL
- en: Generally speaking, we will need to produce a layout for each of the above sizes.
  prefs: []
  type: TYPE_NORMAL
- en: The use of **density-independent pixels** (**dp** or **dip**) means that we
    do not need to design a new layout for each density setting, but we do have to
    provide a separate drawable for each density class, which are as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '`drawable-ldpi` ~ 120dpi'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`drawable-mdpi` ~160dpi'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`drawable-hdpi` ~240dpi'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`drawable-xhdpi` ~320dpi'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`drawable-xxhdpi` ~480dpi'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`drawable-xxxhdpi` ~640dpi'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The dpi values in the preceding list inform us of the relative size in pixels
    that our resources need to be. For example bitmaps in the `drawable-xhdpi` directory
    need to be twice the size of their equivalent in the `drawable-mdpi` folder.
  prefs: []
  type: TYPE_NORMAL
- en: It is not really possible to create exactly the same output on every device,
    and this is not even desirable. People buy high-end devices because they want
    stunning imagery and fine detail, and we should endeavor to provide this level
    of quality. On the other hand many people buy small and less expensive devices
    for reasons of convenience and budget and we should reflect these choices in our
    designs. Rather than try to reproduce exactly the same experience on all devices,
    we should think about the reasons why people choose their devices and what it
    is they want from them.
  prefs: []
  type: TYPE_NORMAL
- en: The following short exercise demonstrates how these differences manifest themselves
    across different screen configurations. This will give readers the opportunity
    to see how to best exploit the user's choice of device, using their own artistic
    and design acumen.
  prefs: []
  type: TYPE_NORMAL
- en: Select any high-resolution image, ideally a photograph.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using whatever tools you choose, create a copy that has half the width and height
    of the original.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open a new Android Studio project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the Project Explorer, create two new folders inside the res directory,
    called `drawable-mdpi` and `drawable-hdpi`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place the prepared images in these folders.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build a simple layout with an image view and some text.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create two virtual devices, one with `mdpi` density and one `hdpi`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, run the app on each device to observe the differences.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c32e343f-ac39-4a5b-a430-c4cbe157edba.png)'
  prefs: []
  type: TYPE_IMG
- en: Devices with mdpi and hdpi densities.
  prefs: []
  type: TYPE_NORMAL
- en: These are not actually the only density qualifiers we can use. Apps designed
    for televisions often use the `tvdpi` qualifier. This has a value between `mdpi`
    and `hdpi`. There are also the `nodpi` qualifier, which is used when we want exact
    pixel mapping, and `anydpi`, which is used when all artwork is vector drawables.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a lot of other qualifiers and a full list can be found at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[developer.android.com/guide/topics/resources/providing-resources.html](http://developer.android.com/guide/topics/resources/providing-resources.html)'
  prefs: []
  type: TYPE_NORMAL
- en: It is worth taking a look at some of the more useful ones now.
  prefs: []
  type: TYPE_NORMAL
- en: Scale and platform
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Generalized qualifiers such as those discussed earlier are very useful, suit
    most purposes, and save us a lot of time. However, there are times when we want
    more exact information about the device our app is running on.
  prefs: []
  type: TYPE_NORMAL
- en: One of the most important features we want to have information about is screen
    size. We have already encountered qualifiers such as small, normal, and large,
    but we can also configure for more precise dimensions. The simplest of these is
    the available width and available height. For example, layouts in `res/layout/w720dp`
    will only inflate when there is a minimum of 720dp available and height and `res/layout/h1024dp`
    will inflate when the screen height is equal to or greater than 1024dp.
  prefs: []
  type: TYPE_NORMAL
- en: Another very handy feature to configure resources for is the platform version
    number. This operates on the API level. So one would use a qualifier of `v16` for
    resources to be used when running on Android Jelly Bean devices.
  prefs: []
  type: TYPE_NORMAL
- en: Being able to select and prepare resources for such a wide range of hardware
    means we can provide lavish resources for those devices that are capable of displaying
    them and simpler resources for devices that have reduced capacity. Whether we
    are developing for budget phones or high-end tablets we still need some way to
    test our apps. We have already seen how flexible AVDs can be, but it is well worth
    taking a quick look at some of the alternatives.
  prefs: []
  type: TYPE_NORMAL
- en: Alternative emulators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the very best alternative emulators is probably Genymotion. This unfortunately
    is not free and is not as up-to-date as the native AVDs but it is fast and supports
    drag-and-drop file installation and mobile network functionality. It can be found
    at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.genymotion.com](http://www.genymotion.com)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another fast and easy to use emulator is Manymo. This is is a browser-based
    emulator and its primary purpose is to test web apps, but it works perfectly well
    for mobile apps. It too is not free but it does have a wide selection of ready-made
    form factors. It can be found at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.manymo.com](http://www.manymo.com)'
  prefs: []
  type: TYPE_NORMAL
- en: 'In a very similar vein there is Appetize, which is located at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[appetize.io](http://appetize.io)'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a growing number of such emulators but those mentioned above are
    probably the most functional from a development perspective. The following list
    directs the reader to some of the others:'
  prefs: []
  type: TYPE_NORMAL
- en: '[www.andyroid.net](http://www.andyroid.net)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[www.bluestacks.com/app-player.html](http://www.bluestacks.com/app-player.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[www.droid4x.com](http://www.droid4x.com)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[drive.google.com/file/d/0B728YkPxkCL8Wlh5dGdiVXdIS0k/edit](http://drive.google.com/file/d/0B728YkPxkCL8Wlh5dGdiVXdIS0k/edit)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is one scenario where none of these alternatives are suitable and we are
    forced to use the AVD manager and that is when we want to develop for wearables,
    such as smart watches, which is what we will look at next.
  prefs: []
  type: TYPE_NORMAL
- en: Android Wear
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Wearable devices have become very popular of late and Android Wear is fully
    incorporated into the Android SDK. The setting up of a Wear project is slightly
    more involved than other projects as wearable devices really act as a companion
    device with the apps themselves running from a mobile device.
  prefs: []
  type: TYPE_NORMAL
- en: Despite this minor level of complication, developing for wearables can be a
    lot of fun, not least because they often offer us access to some cool sensors,
    such as the heart rate monitor.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to a wearable AVD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It may well be that you have access to a wearable device, but here we will
    be using emulators in the following exercise. This is because these devices come
    in two flavors: square and round.'
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to pairing one of these emulators with a phone or tablet, this
    can be done with either a real device or with another emulator, with a real device
    being preferable as this puts less strain on the computer. These two approaches
    are slightly different. The following exercise assumes you are pairing a wearable
    emulator with a real device, with an explanation of how to pair with an emulated
    mobile device at the end.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before doing anything else, open the SDK Manager and check that you have downloaded
    Android Wear System Images:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b4f5a271-696e-46cb-91f8-93235d4ccf00.png)'
  prefs: []
  type: TYPE_IMG
- en: Open the AVD Manager and create two AVDs, one round and one square.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install the Android Wear app from the Play store on your handset and connect
    it to the computer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Locate and open the directory containing the `adb.exe` file. This can be found
    in `\AppData\Local\Android\Sdk\platform-tools\`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Issue the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Launch the companion app on your handset and follow the on-screen instructions
    to pair the devices.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will need to execute the port forwarding command each time you reconnect
    the handset.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are going to pair the wearable with a virtual handset, the process is
    very similar, the only difference being the manner in which the companion app
    is installed. Follow the steps to achieve this:'
  prefs: []
  type: TYPE_NORMAL
- en: Start or create an AVD that targets Google APIs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Download `com.google.android.wearable.app-2.apk`. There are many places online
    where the file can be found, such as www.file-upload.net/download.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Put the file in your platform-tools folder and install it with:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Start the wearable AVD and enter `adb devices` at the command prompt (or Terminal
    if you are on a Mac) to check that both devices are visible.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `adb telnet localhost 5554`, where `5554` is the phone emulator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally enter `adb redir add tcp:5601:5601`. You can now use the wear app on
    the emulated phone in the same way as the previous exercise to pair the devices.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Although it is added for us automatically, it is still important to understand
    that Android Wear apps require a support library. This can be seen by examining
    the module level in the `build.gradle` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: With our devices now paired, we can begin to actually develop and design our
    wearable app.
  prefs: []
  type: TYPE_NORMAL
- en: Wearable layouts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most interesting challenge when it comes to Android Wear UI development,
     is the two different shapes these smart watches come in. There are two ways we
    can approach this.
  prefs: []
  type: TYPE_NORMAL
- en: One is similar to the way we have managed things previously and involves designing
    a layout for each form factor whilst the other technique uses a method that produces
    a layout that will work for either shape.
  prefs: []
  type: TYPE_NORMAL
- en: On top of these techniques the wearable support library comes equipped with
    some very handy widgets suited to curved and round layouts and lists.
  prefs: []
  type: TYPE_NORMAL
- en: One of the most useful and instructive features of Android Studio is the project
    templates that are offered when a project is first set up. There is a good selection
    of these and they provide good starting points to most projects, in particular
    Wear apps.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a15c089f-644e-4bfa-bdd4-5cc873a653a6.png)'
  prefs: []
  type: TYPE_IMG
- en: Wear templates
  prefs: []
  type: TYPE_NORMAL
- en: Starting a project this way can be helpful and revealing and even the blank
    activity template sets up both XML and Java files, creating a very creditable
    starting point.
  prefs: []
  type: TYPE_NORMAL
- en: If you start a project from Blank Wear Activity, the first thing you will notice
    is that, where we previously had only one module (called app by default), we now
    have two modules, one called mobile that replaces app and another named wear.
    Both these modules have the same structures as those we have encountered before,
    containing a manifest, resource directory and Java activities.
  prefs: []
  type: TYPE_NORMAL
- en: The WatchViewStub class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The blank Wear activity template applies the first technique we discussed earlier
    for managing different device shapes. This takes the form of the `WatchViewStub`
    class, which can be found in the `wear/src/main/res/layout` folder.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As can be seen in the preceding example, the main activity directs the system
    to one or other of the two shaped layouts, which the template also provides.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, this is not the way we have selected the correct layout previously
    and that is because `WatchViewStub` operates differently and requires a specialized
    listener that inflates our layouts once `WatchViewStub` has detected the watch
    face type. This code too is provided by the template in the main activity Java
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: It is tempting to think that `WatchViewStub` is all we need to design our wearable
    layouts. It allows us to design for both faces independently, which is precisely
    what we want to do. However, Wear layouts are generally very simple and indeed
    complex designs are strongly discouraged. Thus with a simple design of little
    more than an image and a button, it is simply a matter of convenience to have
    a `shape-aware` class that distributes its contents according to the shape of
    the device it finds itself being inflated on. This is how the `BoxInsetLayout`
    class works.
  prefs: []
  type: TYPE_NORMAL
- en: Shape - aware layouts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `BoxInsetLayout` class is part of the Wear UI library and allows us to design
    just one layout that will optimize itself for both square and round watch faces.
    It does this by inflating the largest possible square within any round frame.
    This is a simple solution but what the BoxInsetLayout also does very nicely is
    ensure that any background image we choose always fills all available space. As
    we shall see in a moment, if you position components horizontally across the screen,
    the `BoxInsetLayout` class automatically distributes them to cause a best fit.
  prefs: []
  type: TYPE_NORMAL
- en: One of the very first things you will want to do, when developing for these
    unusual form factors when working in Android Studio, is take advantage of the
    powerful preview system provided by the Layout Editor. This provides previews
    of each type of wearable device as well as any AVDs you may have created. This
    saves a great deal of time when testing a layout as we can view this directly
    from the IDE without having to launch an AVD.
  prefs: []
  type: TYPE_NORMAL
- en: The preview tool can be accessed from the `View | Tool Windows` menu; or, if
    the layout Text editor is open; it can be found, by default, in the right hand
    margin.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike `WatchViewStubs`, the `BoxInsetLayout` class is not provided by any of
    the templates and must be coded manually. Follow the short steps below to construct
    a dynamic Wear UI using the `BoxInsetLayout` class .
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the following `BoxInsetLayout` as the root container of the main XML
    activity in the wear module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Place this `FrameLayout` inside the `BoxInsetLayout` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside `FrameLayout` include these widgets (or those of your own choosing):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, run the demonstration on both a round and a square emulator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b138abb9-7ed0-4478-8ea6-7473de6a2740.png)'
  prefs: []
  type: TYPE_IMG
- en: The BoxInsetLayout
  prefs: []
  type: TYPE_NORMAL
- en: The `BoxInsetLayout` class is wonderfully easy to use. Not only does it save
    us time, it also keeps the memory footprint of our app down, as even the simplest
    layout has some cost. It may seem that it is somewhat wasteful of space in the
    round view, but Wear UIs should be bare and stripped down and empty space is not
    something to be avoided; a well designed wearable UI should  be quickly grasped
    by the user.
  prefs: []
  type: TYPE_NORMAL
- en: One of the most frequently used features of Android Wear is the heart rate monitor
    and, as we are working with wearables, now would be a good time to look at how
    we access sensor data.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing sensors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Devices worn on the wrist are ideal for fitness apps and the inclusion of a
    heart rate monitor in many models makes them perfect for such tasks. The way that
    the SDK manages all sensors is almost identical, so seeing how one works applies
    to the others.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following exercise demonstrates how to read the heart rate sensor on a
    wearable device:'
  prefs: []
  type: TYPE_NORMAL
- en: Open an Android Wear project with both mobile and wear modules.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a layout of your choosing, ensuring you include a `TextView` to display
    the output.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the `Manifest` file in the wear module and add the following permission:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the `MainActivity.java` file in the wear module and add the following
    fields:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Have the `Activity` implement a sensor event listener, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Implement the methods required by this.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Edit the `onCreate()` method as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the `onResume()` method to register the listener when the activity starts
    or restarts:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the `onPause()` method to ensure the listener is switched off when
    not required:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, edit the `onSensorChanged()` callback, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/60de7bbe-5ab2-4429-b973-f89155262741.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As mentioned earlier, all sensors can be accessed in the same fashion, although
    of course the values they output differ according to their purpose. Full documentation
    of this can be found at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[developer.android.com/reference/android/hardware/Sensor.html](http://developer.android.com/reference/android/hardware/Sensor.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Now, of course, the reader will be thinking this exercise is pointless without
    an actual device with an actual sensor. Fortunately, there is more than one way
    to make up for this lack of hardware in an emulator.
  prefs: []
  type: TYPE_NORMAL
- en: Sensor emulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have not used the Android emulators for some time or are new to them,
    you may well have missed the extended controls that each AVD has. These can be
    accessed from the bottom of the emulator's toolbar.
  prefs: []
  type: TYPE_NORMAL
- en: 'These extended controls offer a host of useful functions such as the ability
    to easily set mock locations and alternative input methods. Of interest to us
    here are virtual sensors. These allow us to simulate a variety of sensors and
    input values directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e797a1c2-3b12-4f31-91ad-515b15a08f87.png)'
  prefs: []
  type: TYPE_IMG
- en: Virtual sensors
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several other routes to running sensors on emulated devices. Most
    of these depend on connecting real devices and using their hardware. These SDK
    controller sensors can be download from the Play store. There are also some great
    sensor simulators on GitHub, my personal favorite being:'
  prefs: []
  type: TYPE_NORMAL
- en: '[github.com/openintents/sensorsimulator](http://github.com/openintents/sensorsimulator)'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we are beginning to develop more than just static layouts, we can start
    to take advantage of some of Studio's more powerful monitoring tools.
  prefs: []
  type: TYPE_NORMAL
- en: Device monitoring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Very often, simply running an app on a device or emulator is enough to tell
    us if what we have designed works and what, if anything, we need to change. However
    it is always great to see what is going on under the hood, and Android Studio
    has some fantastic tools when it comes to the live monitoring of an app's behavior.
  prefs: []
  type: TYPE_NORMAL
- en: We will cover debugging in detail in the next module, but it is never too soon
    to play with the **Android Debug Bridge** (**ADB**) and Android Studio's Device
    Monitor tool is one of the most significant benefits of choosing the IDE over
    the alternatives.
  prefs: []
  type: TYPE_NORMAL
- en: This section also offers a good opportunity to take a closer look at project
    templates, another fantastic feature of Android Studio.
  prefs: []
  type: TYPE_NORMAL
- en: Project templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Android Studio comes packed with many useful project templates. These are designed
    for a series of typical project types, such as full screen apps or Google Maps
    projects. Templates are partially completed projects with code, layouts, and resources
    that can be used as a starting point for our own creations. The growing presence
    of material design has made the `Navigation Drawer Activity` template one of the
    most used templates and the one we will use to examine the Device Monitor tool.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Navigation Drawer Activity` template is interesting and useful in several
    ways. Firstly, note that there are four layout files including the `activity_main.xml`
    file that we are familiar with. Examining this code, you will note the following
    node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The purpose of this node is simple to understand and the `app_bar_main.xml`
    file that it refers to contains the coordinator layout and other views that we
    covered earlier in the book. The use of the `<include>` tag is by no means necessary
    but it is very useful if we ever want to reuse that code in another activity,
    and of course it produces far cleaner looking code.
  prefs: []
  type: TYPE_NORMAL
- en: Another point of interest in this template is the use of vector graphics in
    the drawable directory. We will be looking at these in detail in the next chapter
    but for now it is enough to know that they provide a fantastic way to manage the
    problem of having to provide separate imagery for each screen density grouping
    as they will scale to any screen.
  prefs: []
  type: TYPE_NORMAL
- en: Before we take a look at how we can monitor an app's behavior, take a quick
    look at the main activity Java code. This shows very nicely how the various features
    are, and should be, coded. It is unlikely the example features will match those
    we want, but they can be replaced and edited very easily to suit our purposes,
    and an entire application can be built from this starting point.
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring and profiling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One tool that all developers want is the ability to monitor an application during
    runtime. Watching the live impact user actions have on hardware components such
    as memory and processors is a fantastic way to identify possible bottlenecks and
    other problems. Android Studio has a sophisticated set of profiling tools, which
    will be examined thoroughly in the next module. However, the Android Profiler
    is useful for UI develeopment as well as coding and certainly worth looking at
    briefly here.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Android Profiler can be opened from the View | Tool Windows menu, the tools
    gutter, or by pressing *Alt* + *6*. It appears at the bottom of the IDE by default,
    but this can be customized using the Settings icon to suit individual preferences:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0a8ad435-927c-4150-b9e8-fb2d72c87053.png)'
  prefs: []
  type: TYPE_IMG
- en: The Android Profiler
  prefs: []
  type: TYPE_NORMAL
- en: An advanced profiling option is available via the Run configuration dialog;
    this will be covered in the next module. For now there is another simple debugging/monitoring
    tool that can be very handy for UI design and development.
  prefs: []
  type: TYPE_NORMAL
- en: The visual feedback provided by the profiler provides a lot of useful information,
    but this information is fleeting and, although advanced profiling allows us to
    record very detailed examination, often all we need is to confirm that a particular
    event took place, or the order in which certain events took place.
  prefs: []
  type: TYPE_NORMAL
- en: For this, we can use another tool window, the logcat, and when all we need is
    to get some basic textual feedback on how and what our app is doing we can create
    a logcat filter for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the logcat tool window via the View | Tool Windows menu or from the margin.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select Edit Filter Configuration from the filter drop-down, on the right.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Complete the dialog, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f67419bf-c7de-48fa-a070-2a55df527520.png)'
  prefs: []
  type: TYPE_IMG
- en: Creating a logcat filter
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following field to your `main` activity:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Include the following import:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, add the highlighted line in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Running the app with logcat open and tapping the FAB, will produce the following
    output.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Although this example is simple, the power of this technique is obvious and
    this form of debugging is the fastest and simplest way to check simple UI behavior,
    program flow, and the activity life cycle state.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter has covered a lot of ground; we have taken the work done on Android
    layouts in an earlier chapter and begun to explore how these can be taken from
    static graphics to more dynamic structures. We have seen how Android provides
    classes and libraries that make developing for different screens easier than with
    other IDEs and how the emulator can be used to produce all possible form factors,
    including the most recent platforms.
  prefs: []
  type: TYPE_NORMAL
- en: There is only one more chapter in this module on layout and design before we
    move onto coding; in it we will cover how the numerous resources available to
    us are managed and how Android Studio assists us in this.
  prefs: []
  type: TYPE_NORMAL
