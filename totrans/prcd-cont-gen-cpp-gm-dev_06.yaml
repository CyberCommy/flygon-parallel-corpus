- en: Chapter 6. Procedurally Generating Art
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A game's art is one of its defining features. It's usually what first attracts
    us, and it is one of the driving forces behind keeping us hooked; great aesthetics
    go a long way. Given that, we want to ensure that this is an area that is as rich,
    diverse, and immersive as possible.
  prefs: []
  type: TYPE_NORMAL
- en: However, art is financially expensive and time-consuming to produce. Not only
    that, it's also expensive at the hardware level! Game textures can hit 4K in size,
    and creating a thousand 4K textures and storing them on traditional game media
    is no easy task. Thankfully, a wide range of procedural generation techniques
    can be employed when creating art to help combat some of these issues.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: How procedural generation is used with art
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The benefits and drawbacks of procedurally generated art
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using SFML sprite modifiers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Saving modified sprites
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Programmatically creating sprites
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How procedural generation is used with art
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Game art is a great candidate for procedural generation. It's expensive to create
    manually, both in terms of developer investment and on a hardware level, and is
    open to be manipulated programmatically. However, like everything, it has a range
    of benefits and drawbacks. So, let's take a look at them before we get started.
  prefs: []
  type: TYPE_NORMAL
- en: Using sprite effects and modifiers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Perhaps the simplest way in which procedural generation can be used with game
    art is through the manipulation of existing sprites and models using built-in
    functions. For example, most game engines and frameworks will offer some functionality
    to edit graphics, such as the color, alpha, and scale modifiers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Combining these functions with **Random Number Generator** (**RNG**) is an
    easy and quick way to start producing randomized game art. For example, **Simple
    and Fast Multimedia Library** (**SFML**) offers the functionality to change both
    the color and size of a sprite. Even if we just use these functions, we can generate
    a wide range of different textures during runtime. This is shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using sprite effects and modifiers](img/B04920_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Combining multiple textures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A step up from the simple modification of existing textures is the combining
    of multiple textures to create new ones. Throw in some RNG, and you can create
    a large number of sprites with very little effort. We'll use this technique in
    this chapter to give our enemies random armor!
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start with a base enemy sprite, randomly choose some armor, and draw
    it on top of the original image to create a random sprite! More on that later,
    but for now, here''s what it will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Combining multiple textures](img/B04920_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Creating textures from scratch
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most complex way of creating procedural textures is by using algorithms
    to create them from scratch. Algorithms such as Perlin noise can be used to create
    a natural looking texture base which can then be used to create a wide range of
    procedural textures using techniques such as image multiplication.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, a base Perlin noise texture, a white noise texture, and a flat
    color can be combined to create a procedural texture, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating textures from scratch](img/B04920_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: With this approach, changes in the algorithm that generates the first two textures
    will result in a different final texture. This technique can be employed to create
    endless unique textures for a game without creating storage problems.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This type of procedural image creation is beyond the scope of the book. If you
    wish to delve into this further, read up on texture synthesis and algorithms such
    as Perlin noise.
  prefs: []
  type: TYPE_NORMAL
- en: Creating complex animations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The growth of computing power has also given rise to procedural animation. Traditionally,
    an animated game asset, such as a character, would be animated in a 3D animation
    package by an animator. This animation routine would then be loaded during runtime
    by the game engine and applied to a given model to make it move.
  prefs: []
  type: TYPE_NORMAL
- en: As computers are now able to perform more calculations that ever, procedural
    animation is becoming more popular. Ragdoll bodies are used in lots of game now,
    which is a great example of procedural animation. Instead of a set animation routine
    being played, information about the body, such as its weight, velocity, and rigidity,
    is used to calculate what position the body should be in to create realistic and
    dynamic movement.
  prefs: []
  type: TYPE_NORMAL
- en: The benefits of procedurally generated art
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The procedural generation of game art brings with it a range of benefits to
    us as developers and the people who play our games. From its versatility, to being
    cost-effective and a time-saver, let's take a look at a few of these benefits.
  prefs: []
  type: TYPE_NORMAL
- en: Versatility
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The main benefit of procedurally generating game art is **versatility**. Game
    art is expensive to produce, and as a result imposes limits on what can feasibly
    be created for a given project. It would be nice to have an artist create thousands
    of textures for our games, but it's not feasible. Instead, we can create a handful
    resources, employ procedural techniques to turn these resources into thousands
    of individual possible textures, and bring variety and diversity to games.
  prefs: []
  type: TYPE_NORMAL
- en: Cheap to produce
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Expanding on the previous point, since we do not have to pay artists to manually
    create all of these textures, procedural generation saves us both time and money.
    In the example that we're going to work on in this chapter, we're going to provide
    our enemies with random armor. There will be three types of armor, each with three
    tiers, and the combination of which armor the enemy has will also be random. The
    number of possible combinations there is huge, and having an artist create them
    manually would be costly.
  prefs: []
  type: TYPE_NORMAL
- en: It requires little storage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Continuing with the example of giving our enemies armor, even if we could get
    an artist to produce all the sprites manually, how are they going to be stored?
    While this is less of an issue for online games, as there's usually no imposed
    limit on the game and download size, games that ship on traditional media, such
    as a disk, have to use the space wisely. Textures are an expensive resource in
    this regard. Therefore, creating a handful of resources and programmatically creating
    a texture from them alleviates these issues.
  prefs: []
  type: TYPE_NORMAL
- en: The drawbacks of procedurally generated art
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the good comes the bad, and procedurally generated art is no exception.
    Though it is flexible and saves space, it does come with a few drawbacks.
  prefs: []
  type: TYPE_NORMAL
- en: Lack of control
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the first drawbacks is application agnostic, and is a drawback of procedural
    generation as a whole; the loss of control that comes with it. If you're generating
    art procedurally you lose the touch that a skilled artist can give it. The content
    can lack character and feel very rigid due to being the result of a deterministic
    process, not a creative one. A good procedural algorithm can mitigate this to
    a certain extent, but it's hard to generate content that feels and looks as natural
    as a talented artist would make it.
  prefs: []
  type: TYPE_NORMAL
- en: Repeatability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another potential problem with procedurally generating art is that things may
    appear very repeated and unnatural. Content will be produced through an algorithm,
    and variation in the output is a result of the variance in the terms used. Given
    that, each algorithm has a spectrum of content that can be produced. If the operating
    range of the algorithm is too small, textures will be repeated and may feel unnatural
    and reused, despite procedural generation being used to mitigate that very thing!
    It's all in the quality of the algorithm and how it's used.
  prefs: []
  type: TYPE_NORMAL
- en: Performance heavy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Procedurally creating art usually involves lots of reading and copying textures,
    which are generally expensive operations, especially if you're working with high-resolution
    textures. Using the enemy armor example as a use case, if we were to create the
    sprites manually, we would just have to load the texture, which is a single operation.
    If we create a sprite procedurally, we have to load each component, edit them,
    and re-render them to create a new texture.
  prefs: []
  type: TYPE_NORMAL
- en: Using SFML sprite modifiers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we've identified a number of strengths and weaknesses of procedurally
    generating art, get started! The first naïve approach that we'll look at is simply
    using `sprite` modifiers such as `color` and `alpha` to alter the existing sprites.
    With this method we'll be using the built-in sprite modifiers that SFML offers.
    Most engines and frameworks will have functions that are similar to these, and
    if not, you can just make them yourself!
  prefs: []
  type: TYPE_NORMAL
- en: How colors work in SFML
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start with the simplest way of procedurally generating a sprite, generating
    a unique color for it during runtime. A color in SFML is simply a set of four
    `uint8` values, with one for each color channel and one for an alpha:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Every `sf::Sprite` in SFML has a `sf::Color` member variable. This color value
    is multiplied with the color values of the pixels in the texture to arrive at
    the final color. The following image demonstrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How colors work in SFML](img/B04920_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding image, we can see the original image on the far left. Also,
    we can see the resulting images when the sprite has various colors set.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For the best results, it's best to start with a monochromatic gray base texture
    so that the color modulation arrives at the correct color.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `sf::Color` type also has an *alpha* value, which is used to determine
    the opacity of the object. The lower the alpha channel, the more transparent the
    object. With this value, you can change how opaque an object is, as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How colors work in SFML](img/B04920_06_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: With this understanding of how SFML deals with color, let's put it into action
    by generating a random sprite for the slime character, setting both its color
    and alpha pragmatically.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To learn more about how SFML deals with color, read the SFML documentation that
    is found at [http://www.sfml-dev.org/learn.php](http://www.sfml-dev.org/learn.php).
    For more in-depth information, head to the OpenGL documentation, in the the graphics
    API SFML uses.
  prefs: []
  type: TYPE_NORMAL
- en: Creating sprites of a random color
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In SFML, sprite objects have a member function called `setColor()`. This function
    takes an `sf::Color` object and sets it as the value to be multiplied with the
    sprite's texture when drawn. We know that `sf::Color` is essentially just four
    `uint8` values, with each having a range of 0 to 255\. Given that, to generate
    a random color, we can either generate random values for these color channels,
    or randomly select one of the built-in pre-defined colors of SFML.
  prefs: []
  type: TYPE_NORMAL
- en: The slime enemy is a great candidate for this, as it will look great in many
    colors and the base sprite is a dull gray color. Multiplying a color with this
    sprite will work well. When we set the slime sprite, we'll give it a random color
    using both methods. Let's start with selecting a pre-defined color.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting a preset color at random
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'SFML comes with the following pre-defined colors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: These are defined in `Color.hpp` and cover the most popular colors. The first
    problem is that we need some way of selecting one at random. To do this, we can
    create an enumerator of matching color values, generate a random index, and then
    use that to match the enumerator value with the matching predefined color. This
    will become clearer as we look at the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start by adding the following enumerator definition to the `Util.h`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: For each of the predefined colors, we've added a corresponding value to the
    `enum`, ensuring that it ends with `COUNT`. With this defined, we just need to
    calculate a number between 0 and `COLOR::COUNT` and then use it in a `switch`
    statement. It's a method that we've used a few times now so we should be familiar
    with it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Jumping to the constructor of the slime enemy, we''ll start by generating a
    random index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will simply switch the `colorIndex` value and set the corresponding
    color:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This should be continued for each value of the enumerator that we defined.
    Now, you will see that every slime enemy that is spawned into the game has a different
    predefined color:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Selecting a preset color at random](img/B04920_06_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Generating a color at random
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The second option, which gives us much more control, is to generate our own
    colors at random. This method gives us a much wider range of possibilities, as
    well as provides us access to the alpha channel; however, we lose some control.
    When selecting from predefined colors, we know that we'll always end up with a
    pleasant-looking color, which is something that we can't guarantee when generating
    our own values for each channel. Regardless of this, let's look at how we'll do
    it.
  prefs: []
  type: TYPE_NORMAL
- en: We know that `sf:color` has four channels (r, g, b, and a), and each value lies
    between 0 and 255\. To generate a random color, we need to generate values for
    the r, g, and b channels; a is for the alpha channel, and it will allow us to
    alter the opacity of the sprite.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, we''ll define the variables and generate a random value for the r,
    g, and b channels, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'For the alpha channel, we want to be a bit more precise with the number generation.
    An alpha value of 0 would be way too low; we''d barely see the sprite. For this
    reason, we''ll generate a number in the range of 100 to 255, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have these values, we need to create an `sf::color` object, passing
    the `r`, `g`, `b`, and `a` values in the `color` constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The final step is to make a call to `sf::sprite::setColor()`, passing the new
    color. The complete code is as follows and should reside in the constructor of
    the slime enemy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we run the game, we should get three very different colored slimes,
    each with a varying degree of opacity, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Generating a color at random](img/B04920_06_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Creating sprites of a random size
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The final sprite modifier that we'll play with is scale. Using the `sf::Sprite::setScale()`
    function, we can set both the horizontal and vertical scale of the sprite. The
    default scale is 1, so if we scale using a value of 2, the sprite will be twice
    as big. Likewise, if we set a scale of 0.5, it will be half as big. Given this,
    we need to generate floats that are just either side of 1\. A range of 0.5 to
    1.5 should give us enough variance in size!
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we need to generate a float, but the `std::rand()` function will only generate
    an integer value. Don''t worry! There is a simple trick that we can use to get
    a float out of it! We simply need to generate a number between 5 and 15 and then
    divide it by ten to get the float value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that the random scale value is generated, we now just need to call me `sf::sprite::setScale()`
    function and use the `scale` variable as the scaling value. The complete code
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'On running the game, you will now see that the slime enemies have different
    colors and they vary in size too:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating sprites of a random size](img/B04920_06_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Saving modified sprites
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our game we're going to be generating new sprites each time the game is run.
    We want each run to be unique, so once we've generated a sprite and used it we
    can let it go. However sometimes, you might want to keep hold of a sprite. For
    example, you might want to create a randomized NPC and keep the same character
    throughout the entire game.
  prefs: []
  type: TYPE_NORMAL
- en: The two data types that we've used to create images so far are `sf::Sprite`
    and `sf::Texture`. These classes let us interact with images through a set of
    predefined member functions. It's great for standard drawing and simple image
    manipulation, but we don't get access to the raw image information. This is where
    `sf::Image` comes into play!
  prefs: []
  type: TYPE_NORMAL
- en: Passing a texture into an image
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Sf::Image` is a class that is used to load, manipulate, and save images. Unlike
    the other data types, `sf::Image` provides us with the raw image data, allowing
    us to interact with every pixel in the image. We''ll use more of this functionality
    later, but for now, we''re interested in the `sf::Image::saveToFile` function.'
  prefs: []
  type: TYPE_NORMAL
- en: With this function, we can save an image in a file; we just need to our the
    texture into that image. Luckily, there's a function to do just that! The `sf::Texture`
    class has a function named `copyToImage` that copies the raw image data from a
    texture into an image. So, we should be able to copy the texture to an image and
    save it, right? Well, let's try it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Slime::Slime`, let''s add the following debug code after we''ve modified
    the sprite:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If you take a look at the file that we created and compare it to the original
    image, you will see something odd:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Passing a texture into an image](img/B04920_06_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The modifications that we make to the sprite do not edit the texture. Instead,
    modifications are made every time we draw the object. When we output the texture
    like this, we simply output the same sprite that we put in! To save the changes
    that were made through sprite modifications, we need to utilize the `sf::RenderTexture`
    class as well.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing to a RenderTexture class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since sprite modifications aren't applied to the texture, we need to somehow
    capture the sprite once it has been rendered. Again, SFML comes to the rescue
    with its `sf::RenderTexture` class. This class allows us to render into a texture
    as opposed to the screen, solving the issue of modifications not been applied
    to the texture.
  prefs: []
  type: TYPE_NORMAL
- en: To start, we need to create an `sf::RenderTexture` object. For this, we need
    to know the size of the area that we'll be drawing to, and there's something that
    we need to keep in mind here. We're making changes to the size of the object.
    So, if we just get the size of the texture, it will either be too big or too small.
    Instead, we need to get the size of the texture and multiply it by the same scale
    value that we apply to the sprite.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s get some code written to make things clearer. We''ll start by creating
    the `sf::RenderTarget` object, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we will get the size of the texture and multiply it by the same
    scale that we modified the sprite by.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we will draw the object to the render view, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Saving an image to a file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: From this point onwards, the code is the same as our first attempt, but with
    a slight modification. Because the sprite is animated, we change both its origin
    and the `textureRect` properties to cut it into subsections in order to animate
    the character. This needs reverting in order to see the entire texture. Also,
    when we call `sf::Texture::copyToImage`, the sprite gets flipped vertically. Before
    we save the file, we need to flip it back.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the complete code example that is used to save the modified slime texture:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Don't forget to delete this code when you're done as it is expensive to save
    files and it messes up the animation!
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if you run the game and take a look at the file, you will see the modifications
    that we made:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Saving an image to a file](img/B04920_06_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Creating enemy sprites procedurally
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Having the ability to render to `sf::RenderTexture` and store the results opens
    up a world of possibilities. One of these is combining multiple sprites to create
    new, more versatile ones. We can draw to an `sf::RenderTexture` class multiple
    times, and the sprites will overlap. This is an incredibly useful technique that
    can be used to generate a vast amount of sprite variations without all the work.
    This is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating enemy sprites procedurally](img/B04920_06_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Using this approach, we'll create random armor for our enemies. We'll have three
    pieces of armor; head, torso, and legs. For each of these, we'll also have three
    variations; bronze, silver, and gold. This alone gives us a large number of possible
    combinations. Then, let's consider that we need this for each character, of which
    we have two, and each character has eight sprites. That's an enormous number of
    textures. It's totally out of the question to create all of them manually.
  prefs: []
  type: TYPE_NORMAL
- en: Breaking sprites into components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The armor sprites that we will create are going to be laid right on top of the
    default enemy animations. The most important thing to consider here is that their
    sizes and position will line up when drawn on top of one another.
  prefs: []
  type: TYPE_NORMAL
- en: 'When creating an `sf::RenderTexture` class, we define a size. Everything drawn
    to it will then be positioned relative to the top left corner of this area. If
    our sprites have different sizes, when we start drawing, they will be misaligned.
    The following examples have had their backgrounds darkened so that we can see
    this. In the first example, the sprites have been cropped, and we can see that
    this makes them misaligned when laid over one another:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Breaking sprites into components](img/B04920_06_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the second example, the sprites are of the same size and are both positioned
    relative to the sprite over which they will be drawn. As a result, they will line
    up nicely:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Breaking sprites into components](img/B04920_06_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We're going to create armor for each enemy, so for each enemy animation, we
    need to create a matching armor sprite. This has already been done to save time,
    and you'll notice that there's only gray versions of these sprites. To save yet
    more time, we'll change the colors using the sprite modifiers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example of an armor overlay sprite on the skeleton walking sprite
    strip:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Breaking sprites into components](img/B04920_06_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The draw setup
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we write any code regarding generating armor, we need change the way
    the `Humanoid` class handles its textures. Since the textures that we'll create
    are unique to each instance of the class and will only be used once, there's no
    use filling the **Texture** manager with them. Instead, we'll create an array
    of our own textures and override the default draw behavior to use the new ones!
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start by defining an array of textures in `Humanoid.h`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Now, in the `Humanoid` constructor, we need to fill this array with the default
    enemy textures. This is because we're going to override the default draw behavior
    to use the array of modified sprites over the default ones. A modified sprite
    is only created when armor is generated. Therefore, we need to ensure that we
    have the default sprites to fall back to. We will fill up the array with default
    sprites and then override them if we generate armor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to `Humanoid::Humanoid`. Then, our prep work is done
    and we can get started:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Randomly selecting sprite components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have three possible pieces of armor that our enemies can have; head, torso,
    and legs, and we want our enemies to have a mix of these types. So, let's give
    each of them a 1 in 5 chance of been spawned on the enemy. This means that enemies
    with more gear are less likely to spawn, which is just what we want; a fully kitted
    out skeleton should be a rare spawn!
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Don't forget about the balance of game mechanics. When creating procedural systems,
    it's easy to focus on the tech and let the balance take a backseat. Always keep
    this in mind when designing your systems. You can visit [http://www.paranoidproductions.com/](http://www.paranoidproductions.com/),
    which contains lots of great information on this subject.
  prefs: []
  type: TYPE_NORMAL
- en: Let's get started by creating a function for all this behavior to go in. The
    armor is designed to fit over both the goblin and the skeleton sprites. Therefore,
    we can place it in the `Humanoid` class and generate armor for both variants!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s declare the `Humanoid::GenerateArmor` function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The first thing that we need to do is create the `sf::RenderTexture` objects
    that we''ll draw to. We''re going to use two textures for each sprite: one for
    the armor and one for the final image. We''ll draw the armor first and then draw
    that over the default enemy sprites to create the final textures.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s give the new function a body and set up the objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now add the code to choose which pieces of armor our enemy will have.
    We said we''d give each item a 20 percent chance of spawning. Hence, we need to
    generate a number from 0 to 4 (inclusive). There''s a 20 percent chance that the
    result of this will be 0\. Therefore, we can use this to determine whether that
    item of armor should spawn:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Now that we randomly choose the pieces of armor, if any, that our enemy will
    have, we can turn our attention to creating different armor tiers by editing the
    sprites. There is a lot of code that is required to achieve this. So from this
    point onwards, we'll focus only on the helmet option.
  prefs: []
  type: TYPE_NORMAL
- en: Loading the default armor textures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To begin, we need to load the default armor textures. Each enemy has eight
    possible animation states, meaning we will need to load all the eight helmet counterparts.
    We''ll do this in a way that is similar to how we load the default sprites in
    the constructor, creating an array of textures and using the enumerator of animation
    states as the index, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: With the default sprites loaded, we can now choose which armor tier they belong
    to, and therefore, what color we need to apply to them.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing the armor tier
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There will be three tiers of armor for each type, namely gold, silver, and bronze.
    So, we need to decide which tier to use. We could take a naive approach and generate
    a number from 0 and 2, but that's not ideal. Each tier would have the same chance
    of spawning, which is 33 percent.
  prefs: []
  type: TYPE_NORMAL
- en: Let's be a bit cannier with how we select the armor tier, making silver rarer
    than bronze, and gold rarer still. To do this, we'll still use the `std::rand()`
    function, but we'll be smarter in how we use the result. First, we need to decide
    the possibilities of each spawning. Let's say that we want 50 percent of it to
    be bronze, 35 percent of it to be silver, and 15 percent of it to be gold.
  prefs: []
  type: TYPE_NORMAL
- en: 'These percentages seem good and are nice to work with as they total 100\. To
    replicate their chances, we need to generate a number from 1 to 100, and we can
    use it to get the desired percentages:'
  prefs: []
  type: TYPE_NORMAL
- en: There is a 50 percent chance that we will generate a number between 1 and 50
    as it represents half of the total possible range (50/100)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a 35 percent chance that we'll generate a number in the range of 51
    to 85, as this range includes 35 values out of the possible 100 (35/100)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, there is a 15 percent chance that we'll generate a number in the range
    of 86 to 100, as this range includes 15 values out of the possible 100 (15/100)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s add the following code to our function, continuing from the previous
    code to load the default textures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We used `std::rand() % 100 + 1`, and not `std::rand() % 100`. While they both
    technically do the same thing, the first generates a number from 1 to 100, while
    the later generates a number from 0 to 99\. The first makes it simpler for us
    to work with.
  prefs: []
  type: TYPE_NORMAL
- en: We create a simple `if` statement that defines each of the ranges that we identified
    earlier. However, by the time we come to the `if` statement of gold, there is
    no need as we've already defined the other ranges. Therefore, we now know that
    anything that's left falls in the range of 86 to 100\. We can therefore simply
    use an `else` statement, saving us an evaluation.
  prefs: []
  type: TYPE_NORMAL
- en: At this stage we've randomly selected a helmet, loaded the default sprites,
    and chosen a tier.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering the armor textures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next step is to edit the armor textures and overly them on the default enemy
    textures. Currently, we only have a gray sprite for each armor type. We need to
    use the sprite modification skills that we learned earlier in the chapter to create
    the bronze and gold versions. We can keep the gray as silver!
  prefs: []
  type: TYPE_NORMAL
- en: 'The pipeline required to do this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Load the default helmet texture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Edit the color using the `tierColor` variable that we set earlier
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Draw the modified armor texture in the `armorTextures` array
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We need to do this for every animation that the enemy has. So, we will encapsulate
    `armorTextures` array within a `for` loop, iterating over each value of the `ANIMATION_STATE`
    enumerator, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `armorTextures` array now contains all the helmet sprites, and their color
    has been set to a random tier value. We now need to do the exact same thing for
    the torso and legs, drawing the same `armorTextures` array again so that we can
    build up the armor texture. This is left as an exercise for you at the end of
    the chapter. For now, let's look at how to put this together to create the final
    texture.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering the final textures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that the armor textures are created, we will need to render them on top
    of the default enemy textures to create the final images. We created copies of
    all the default textures in the constructor, so all that we need to do is draw
    our newly created armor textures on top them and save that as the final texture.
    One thing to remember is that the `sf::Texture::copyToImage` function flips an
    image vertically. Hence, right before we save the final version, we need to flip
    it back.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add this final bit of code. This code needs to go after all the armor
    has been generated, so will be the final block of code in the `Humanoid::GenerateArmor`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'With this function now complete, all that''s left is to make a call to it at
    the end of our constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Overriding the default draw behavior
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The animation code for our objects lies in the base class `Object`. When the
    texture needs to be updated, it goes to the `m_textureIDs` variable and fetches
    the correct texture from the `TextureManager` class. Since we have created our
    own textures and stored them in the new `m_textures` array, we need to override
    this default behavior to provide our own textures.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start with we need to override the update function by adding the following
    declaration to `Humanoid.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We still need to call the parent''s implementation, as that''s where the animation
    logic lies. However, as soon as that''s done, we need to jump in and provide our
    own texture before it''s drawn. Luckily, that''s very easy to do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Debugging and testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we run the game, let's add a little bit of debug code to see our work
    in action. Previously, we covered how to save textures to image files. So, let's
    use that here to save all the procedural sprites that we will create.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s update the loop that creates the final textures using the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'All that this code does is save the textures to the resource folder if a piece
    of armor is generated. If you run the game a few times, remember that there is
    only a 20 percent chance that each skeleton will call this code, and head to the
    `resources` folder, you will see the following sprites:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Debugging and testing](img/B04920_06_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: These are the procedural sprites! In my case, it's a skeleton with a random
    piece of armor of a random tier that we didn't have to draw. We drew the constituent
    parts, did some programmatic editing, and put them together programmatically!
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, after all that, it''s time to test the code. If all is well, when you
    run the game, you should see some skeletons and goblins with helmets! Remember
    that each enemy only has a 20 percent change of having a helmet. You may have
    to run the game a few times to see it if you get unlucky:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Debugging and testing](img/B04920_06_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Before moving forward, you can remove the debug code that we just added to save
    sprites. This was purely for debugging purposes. One of the exercises at the end
    of this chapter is to complete the code and add the same behavior for the torso
    and leg armor options, but feel free to take this further. Experiment!
  prefs: []
  type: TYPE_NORMAL
- en: Editing the game tiles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The final system that we're going to look at is going to lay the groundwork
    for something that is coming later in the book. We're going to create a system
    to make each floor of the dungeon a unique environment, implementing what we know
    about sprite modification on the game tiles.
  prefs: []
  type: TYPE_NORMAL
- en: The goal of the game is to progress through as many floors as you can, getting
    the highest possible score. In [Chapter 9](ch09.html "Chapter 9. Procedural Dungeon
    Generation"), *Procedural Dungeon Generation*, we're going to look at how to generate
    dungeons procedurally, and after every five floors, we'll change the theme. Let's
    create the function that we will use later in the book to accomplish this.
  prefs: []
  type: TYPE_NORMAL
- en: The best way to solve this is to add a function to the `Level` object that sets
    the color of all the tile sprites. This will be a public function as we'll be
    calling it from the main game class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by defining the `sf::color` function in the `Level` header, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The definition for this function is very simple. It simply iterates over all
    the sprites in the grid, setting their color to the parameter that was passed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: With this in place, we're actually done. That's all there is to it! We'll use
    this function later in this chapter, but let's just test it while we're here.
    We initialize the `Level` object in `Game.cpp`, so once we've loaded the textures,
    we can call the `Level::SetColor` function and set the theme of the level.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s update the `Game::Initialize` function with the following test code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'With this, we can see what the levels will look like once we implement the
    function properly later.. Let''s run the game and see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Editing the game tiles](img/B04920_06_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `Level` tiles now have an ambient color applied to all the sprites that
    make up the environment, allowing us to create a unique look and feel for our
    levels. Like I previously mentioned, we'll use this system later when we generate
    random levels programmatically. For now, we can remove the debug code and sit
    tight knowing that the system is ready for use!
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To help you test your knowledge of this chapter''s content, here are a few
    exercises that you should work through. They are not imperative to the rest of
    the book, but working through them will help you to assess your strengths and
    weaknesses in the material covered:'
  prefs: []
  type: TYPE_NORMAL
- en: Give the goblin enemy a slightly random color and scale every time one is spawned.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finish the code to generate armor procedurally for the humanoid by completing
    the condition for the torso and leg armor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Try to generate armor in a more succinct manner. We're using two textures; maybe
    there's a way to use only one. See if you can improve the function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to generate game art procedurally. We took a
    naïve approach to start, simply using RNG with built-in sprite modifiers, and
    moved on to algorithmically generating our own images. Generating procedural art
    is a vast topic, and you could write a book on the subject. Hopefully, this chapter
    has introduced you to the topic nicely.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we're going to look at art's cousin, audio. With our art
    now procedurally generated we'll use similar techniques to create variance in
    sounds. We'll also use SFML's audio functions to create specialized 3D sound and
    thus bring more depth to the levels.
  prefs: []
  type: TYPE_NORMAL
