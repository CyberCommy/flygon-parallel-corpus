- en: Chapter 7. Procedurally Modifying Audio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that our game art has received procedural treatment, let's turn our attention
    to its neighbor, sound. Great sound is imperative for a good game. Think about
    how iconic the sound of Super Mario's jump is, or the sound of chomping ghosts
    in Packman! A great soundtrack and accompanying game sounds help players immerse
    themselves in the worlds that we create as game developers. It's an area that
    needs to be done correctly, and there needs to be enough diversity here so that
    your players don't get sick of hearing the same sound effects over and over again.
  prefs: []
  type: TYPE_NORMAL
- en: We could manually create lots of variants of sound effects, but that's not the
    procedural way! Instead, we'll alter sounds randomly at runtime to create a slightly
    different sound each time it's played. Then, we'll utilize SFML's audio functions
    to create spatialized 3D sounds, thus adding more depth and immersion to the game.
  prefs: []
  type: TYPE_NORMAL
- en: Procedurally generating audio from scratch is a very complex task. Our work
    in this area will be somewhat brief, and really limited to procedurally modifying
    existing sounds as opposed to their outright creation. Still, this will serve
    as a good introduction to taking a procedural approach toward audio.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: SFML audio
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The difference between `sf::sound` and `sf::music`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Altering existing sound effects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating spatialized 3D sound
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An introduction to SFML audio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'SFML has its own module dedicated to audio, which provides a number of useful
    functions that we can use to modify sounds. There are two main sound types in
    SFML: `sf::Sound` and `sf::Music`. We''ll cover the difference between these two
    types in detail shortly. It also provides a number of functions to edit the properties
    of sounds, such as pitch and volume. We''ll use these to give our sound effects
    some variance.'
  prefs: []
  type: TYPE_NORMAL
- en: sf::Sound versus sf::Music
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we start working with audio, we need to look at the difference between
    `sf::Sound` and `sf::Music`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Sf::Sound` is intended for shorter sound clips such as picking up an object
    or footsteps. The sound is loaded in its entirety into the memory, and it is ready
    to be played with no latency.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Sf::Music` is intended for longer, bigger sound files and is not loaded into
    the memory; it is streamed as it is used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This might seem like a slight difference, but it's very important to use the
    correct type. For example, if we were to load a game's music into an `sf::Sound`
    object, the game would use a lot of memory!
  prefs: []
  type: TYPE_NORMAL
- en: sf::SoundBuffer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When creating a sprite in SFML, we create an `sf::Sprite` object, which contains
    information such as the scale and position. The texture itself is stored in an
    `sf::Texture` object to which the sprite object holds a reference. The `sf::Sound`
    class works in the same way, with an `sf::SoundBuffer` object holding the actual
    sound and `sf::Sound` simply holding a reference to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows how a sound is loaded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `sf::SoundBuffer` object must remain active for the same amount of time
    as the `sf::Sound` object does. If `sf::SoundBuffer` goes out of scope before
    the `sf::Sound` object that holds a reference to it, we will get an error, as
    it will try to play a sound that no longer exists.
  prefs: []
  type: TYPE_NORMAL
- en: Also, since we only hold a reference to the sound buffer, it can be used in
    multiple sound objects. To play a sound, we just make a call to `sf::Sound::play`,
    and this runs the sound in a separate thread.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting a random main track
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Currently, the game has no sounds or music. We have been running the game frequently
    throughout the course of the book, and hearing the same track over and over can
    get very tedious. So, we've waited until now to put it in. It's a very simple
    process to add sounds. So, we'll cover this process in its entirety.
  prefs: []
  type: TYPE_NORMAL
- en: To start, we'll add a main music track that will underpin the game. However,
    instead of having a fixed track, we will add multiple possibilities and randomly
    choose one during startup.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by defining all the possibilities in an enumerator in the usual
    way. Add the following code to `Util.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As the `enum` shows, we're going to have four possible tracks. These are already
    included in the `/resources/music/` folder. So, all that we have to do is select
    one track at random and load it at the start of the game. Since we want this music
    to start straightaway, we will insert the code that accomplishes this in our `Game`
    classes constructor.
  prefs: []
  type: TYPE_NORMAL
- en: We've selected a random value from an enumerator a few times now, so it should
    be familiar. We'll generate a number between 1 and `MUSIC_TRACK_COUNT` (inclusive),
    however, instead of casting it to the enumerator type as we normally do, we're
    going to leave it as an integer. The reason behind this will soon become apparent.
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, let''s add the following code to `Game::Game`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the reason why we didn''t cast to the `enum` type is because we can be
    clever when it comes to how we load sounds. We have four music tracks to choose
    from, and they have the following names:'
  prefs: []
  type: TYPE_NORMAL
- en: '`msc_main_track_1.wav`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`msc_main_track_2.wav`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`msc_main_track_3.wav`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`msc_main_track_4.wav`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Note that the only thing that''s different in their names is their number.
    We''ve already generated a number between 1 to 4\. So, instead of creating a `switch`
    statement, we can simply use this index to load the correct track, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when we call `m_music.play()`, the sound will be streamed. Let''s finish
    by calling this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: If we run the game now, we will hear one of the four randomly selected tracks
    playing!
  prefs: []
  type: TYPE_NORMAL
- en: Adding sound effects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have the game's main music, let's add some sounds effects to the
    mix! We've covered `sf::Sound,sf::SoundBuffer`, and how to play sounds, so we're
    ready to jump right in.
  prefs: []
  type: TYPE_NORMAL
- en: We're going to have a few sound effects in our game. One for the death of an
    enemy, one for us being hit, one for each pickup, and one for the sound of torches
    that we'll be playing with later.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start by defining the `sf::Sound` variables for each sound in `Game.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s initialize these sounds in `Game::Initialize`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'With the sounds initialized, we just call `sf::Sound::play` to play the sound
    when we need it. We handle item pickups in the `Game::UpdateItems` function. Therefore,
    we''ll put this code there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This code covers just the gold and gem pickups. The same thing needs to be done
    for all the other pickups and cases where we need to play sounds, such as when
    an enemy dies and a player takes damage.
  prefs: []
  type: TYPE_NORMAL
- en: Editing sound effects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With the sound effects added, we can now alter them to create variety. SFML
    offers a number of ways in which we can manipulate sounds, which includes the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: Pitch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Volume
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Position
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We''ll start with the simplest: the pitch. Then, we''ll cover both the volume
    and position by creating spatialized sounds. These values will be set randomly
    each time we play a sound effect. Before we get into it, let''s create a function
    to encapsulate the modification and playing of sounds. This will save us from
    having repeated code throughout the class.'
  prefs: []
  type: TYPE_NORMAL
- en: Playing a sound function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Collisions with enemies and items are processed in the main game class. So,
    it''s here that we will place the function to play sound effects. Add the following
    function declaration to `Game.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This function takes two parameters: we take the sound that we want to play
    as a reference, to avoid an expensive copy, and we also include a parameter for
    the position where we want to play the sound. Note that we''ve given the position
    parameter a default value of `{ 0.f, 0.f }`. Therefore, it can be ignored should
    we wish to do so. We''ll cover exactly what this parameter does when we create
    spatialized sounds.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s give this class a basic body for now to simply play the sound passed
    via the parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note that if the game was any bigger and we had a large range of many sounds,
    it would be worthwhile to encapsulate the behavior to play sounds in the same
    class in which we manage them. This would ensure that all the interactions with
    sounds happened through a common class and would keep our code organized.
  prefs: []
  type: TYPE_NORMAL
- en: The audio listener
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SFML comes with a static listener class. This class acts as the ear in the level
    and as such, there is only one listener in a scene. Since this is a static class,
    we never instantiate it, and we interact with it through its static functions
    such as `sf::Listener::setPosition`.
  prefs: []
  type: TYPE_NORMAL
- en: 'By "ear in the level", I mean that all the sounds in the level are heard at
    this location. This is how we create 3D sounds. For example, if the source of
    a sound was to the right of the listener, it would be heard more in the right
    speaker. Take a look at the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The audio listener](img/B04920_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this diagram the blue circle represents the position of the audio listener,
    and the red circle represents the position of the sound. You can see that since
    the source of the sound is to the right of the listener, we can use this to determine
    that the sound should be heard more from the right speaker as compared to the
    left one. This is how spatialized sound is created, and we'll look at this in
    detail later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: For occasions where we don't want sound to be spatialized, SFML gives us the
    `sf::Sound::setRelativeToListener` function. This is a self-explanatory function;
    the position of the sound is relative to that of the listener as opposed to being
    absolute within the scene. We set this to `true` and give the sound a position
    of `{0.f, 0.f, 0.f}`, positioning it right on top of the listener.
  prefs: []
  type: TYPE_NORMAL
- en: With regards to the previous diagram, this means that the blue audio listener
    will be placed directly at the top of the red sound source, which means that it
    is not spatialized. This is the behavior that we want for the pickup sounds. For
    each sound, we need to make a call to this function, passing `true` as the parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s update the code to change this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Sounds that originate from the same location as the player require this. For
    example, an item is only picked up once the enemy occupies the same space. You
    will never pick up an item from a distance so the sound will never be spatialized.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a fluctuation in a pitch
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Pitch is the perceived frequency at which a sound is heard. SFML offers a way
    to increase or decrease the pitch of a sound, and it achieves this by increasing/decreasing
    its playback speed respectively. Play it back faster, and it'll sound higher.
    The default value of this is 1, so generating a number that's lesser or greater
    than 1 will give us a fluctuation in pitch.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll add this behavior to our new `Game::PlaySound` function. To start, we''ll
    generate a number between 0.95 and 1.05, set the pitch, and play the sound, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, whenever we want a sound to have this fluctuation in pitch, we need to
    play it through this function as opposed to directly playing it. This applies
    to all the pickup sounds. So, let''s implement this change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: If we now play the game and pick up some items, we can hear that the pickup
    sound is slightly different each time, bringing some variance to the sound effects.
    If you want the sounds that are played when a key is picked up, an enemy dies,
    and a player is hit, to have their pitch fluctuated too, ensure that they are
    also played via this function as opposed to them being directly played.
  prefs: []
  type: TYPE_NORMAL
- en: 3D sound – spatialization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now let's look at ways to create some 3D audio to bring depth to a game scene.
    When we walk past a torch, we want to hear it move past us, and we want to be
    able to hear our enemies coming at us from a direction. Spatialization allows
    us to do this, and SFML has great features to help us achieve that.
  prefs: []
  type: TYPE_NORMAL
- en: The audio listener
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We've already defined what the audio listener is and how it is used to create
    spatialized audio. As the first step toward achieving this, we need to set the
    position of the listener after each update, ensuring that all the sounds in the
    level are heard from the player's perspective.
  prefs: []
  type: TYPE_NORMAL
- en: At the start of each game's update, we recalculate the player's position. Right
    after this we can update the position of the listener class to this new location.
    Remember that `sf::Listener` is a static class and we don't instantiate it. All
    that we need to do is make a static call to `sf::Listener::setPosition`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s append this to the `Game::Update` function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Moving forward, we can now be sure that the listener is in the correct position
    in order for us to create a 3D sound.
  prefs: []
  type: TYPE_NORMAL
- en: The minimum distance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The minimum distance is the closest the player can be to the source of a sound
    before it''s heard at full volume. Imagine it as a circle surrounding the sound
    source. The radius of this circle is `MinDistance`, as shown in the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The minimum distance](img/B04920_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In our case, the minimum distance of the sounds will not change throughout the
    course of the game, which means that we can set their values once in the `Game::Initialize`
    function when we load the sounds. The value that we use here is a matter of preference,
    but I found a minimum distance of `80.f` works well. Let's get these values set.
  prefs: []
  type: TYPE_NORMAL
- en: 'Make the following modifications to the `Game::Initialize` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Attenuation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Attenuation basically means "to lessen" or "to make something smaller". In the
    context of audio, it's the rate at which the sound gets quieter as we move away
    from the source. This comes into effect when we are outside the minimum distance
    and is used to calculate the volume of the sound.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following diagram, the gradient represents the volume of the sound.
    The image to the left shows a high attenuation and the sound drops off very fast,
    while the image to the right shows a low attenuation and the sound drops off more
    smoothly:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Attenuation](img/B04920_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now, let's give our two sounds an attenuation value like we did with the minimum
    distance. Again, the value used here is up to you, but I found out that an attenuation
    value of `5.f`, which is just slightly above the default, created a nice fadeout.
  prefs: []
  type: TYPE_NORMAL
- en: 'Make the following modifications to the `Game::Initialize` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: If we run the game now, we will see that as we approach the torches, they get
    louder, and as we walk away, they get quieter. However, they aren't 3D. For that,
    we need to update the source of the sound!
  prefs: []
  type: TYPE_NORMAL
- en: The position of the sound
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The position of the sound is simply its position in the scene. It's this position,
    and the position of the listener, that are used to create the 3D effect and determine
    which speaker the sound should play out of.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To use spatialization your sounds need to be **Mono** (have a single channel).
    The ones provided with this project are, but if you're adding your own, you need
    to keep this in mind! Sounds with more than one channel already explicitly decide
    how to use the speakers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the attenuation and minimum distance set, we can now set the
    correct position of the sound so that we can hear the 3D effects. We have two
    sounds in the game that are going to be 3D: the sound of the torches and the sound
    of enemies when they are killed. As we have multiple torches in the level we have
    a bit of work to do here. We''ll start with the simpler one of the two: the sound
    of the enemies when they''re killed.'
  prefs: []
  type: TYPE_NORMAL
- en: Fixed positions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First, we need to update the `Game::PlaySound` function. Currently, it only
    generates a random pitch, but we need it to set the position too. You may remember
    that we made the position parameter optional by giving it a default value of `{0.f,
    0.f }`. When we pass a position and override the default, it means that we want
    to utilize a 3D sound. When we leave it blank, it means that we don't want to
    do so and the sound will be relative to the listener. Therefore, `{0.f, 0.f, 0.f}`
    is just what we need.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s hook up the position parameter in `Game::PlaySound` and use it to set
    the position of the sound, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The position of the sound operates in three dimensions, but since we''re working
    with 2D sounds we can leave the *Z* value as `0.f`. Now, when we identify that
    an enemy has been killed, we simply make a call to this function and pass the
    correct sound and location of the enemy, as that''s where the sound is coming
    from, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: It's time to run the game again and listen to our handiwork. As we kill the
    enemies, we can hear that the further away they are, the fainter the sound is.
    Also, if we kill an enemy to the right, we here it coming from that direction!
    To wrap up our work with sound, let's apply the same technique to the torches
    to really give the level some depth when it comes to its audio.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The clarity of the 3D sound will depend on your setup. For example, while headphones
    will allow you to easily hear sounds that are created in different directions,
    laptop speakers might not be so clear.
  prefs: []
  type: TYPE_NORMAL
- en: Moving positions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The last area that we'll add a 3D sound to is the torches in the level. As we
    walk around the level, it would be great to hear torches faintly in the distance,
    or near us in our headphones as we walk past them. However, there's a slight problem.
    We know that the spatialization of sound is achieved when the sound and the listener
    are away from one another. But what if we have a sound that needs to come from
    multiple locations? We could have a sound for each torch, but that's a waste.
    Instead, we'll calculate which torch is closet to the player and use that as the
    source.
  prefs: []
  type: TYPE_NORMAL
- en: As part of our main update function, we need to look at all the torches and
    determine which one is the nearest to the player. As the player walks around the
    level, the source will switch, giving us the impression that each torch is giving
    off its own sound, while we have only a single source in reality.
  prefs: []
  type: TYPE_NORMAL
- en: 'We already have a function to find the distance between two objects, namely
    `Game::DistanceBetweenPoints`. Given this, we can iterate over all the torches
    and use this function to get the distance to the player. Let''s update the `Game::Update`
    function to include this calculation, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, for each torch in the level, we calculate how far away it is
    from the player. If it's closer than the last one that we checked, we mark it
    as the closest. When this code is finished, we end up with the nearest torch stored
    in the shared pointer named `nearestTorch`.
  prefs: []
  type: TYPE_NORMAL
- en: With the closest torch identified, we can use its position as the position of
    the fire's sound. Now, for the rest of the sounds, we've been using the new `Game::PlaySound`
    function, but that's not suitable here. Our fire sound is already looping, we
    don't need to restart it. We just need to set its position, so we'll do it directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s update that code once more:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Let's run the project for the last time! We should now hear a random music track,
    some of our sound effects will be played with a fluctuating pitch, and the sounds
    of the torches and the enemies dying will be spatialized.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To help you test your understanding of this chapter''s content, here are a
    few exercises that you should work on. They are not imperative to the rest of
    the book, but working on them will help you assess your strengths and weaknesses
    in the material covered:'
  prefs: []
  type: TYPE_NORMAL
- en: Add more tracks to the list of main tracks.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a sound that is spatialized for the door when it opens in the `level`. When
    a player collects the key for the `level`, hearing the door sliding open in the
    background will help them find it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add some atmospheric sound effects to the `level`; the sound effects should
    be spatialized and must play at random intervals. We have not covered anything
    like that so far so it should be a challenge.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we used SFML's built-in audio modifiers to make alterations
    to our sound effects. We also utilized the modifiers to create spatialized 3D
    sounds, bringing more depth to our game scene.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we're going to use everything that we learned so far to
    create complex procedural behavior and mechanics in the form of pathfinding and
    unique level goals. We'll give our enemies the intelligence to traverse levels
    and chase the player, and we'll create a unique level goal with unique rewards
    for the player.
  prefs: []
  type: TYPE_NORMAL
