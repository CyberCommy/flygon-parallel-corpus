- en: Learning Game AI - Building a Bot to Play
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: –A game developer aims to create a game that is challenging and fun. Despite
    many attempts, many programmers have failed to do this. The main reason for the
    failure of games, is that human players love to be challenged by an artificial
    player in the gameplay. The result of the creation of such artificial players
    is generally referred to as a **non-player character** (**NPC**), or an artificial
    player. While the creation of such a player is fun (only for the programmer),
    it doesn't add any value to the game until and unless we inject some intelligence
    into that artificial player. The process of creating such NPCs and making them
    interact with human players with some degree of awareness and intelligence (closely
    comparable to human intelligence) is called **a****rtificial intelligence** (**AI**).
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will create an *intelligent system*, which will be able
    to compete with a human player. The system will be smart enough to make moves
    similar to the moves of the human player. The system will be able to check collisions
    on its own, check the different possible moves, and make the one that is the most
    beneficial. Which move is beneficial will be highly dependent upon the target.
    The target of the artificial player will be defined explicitly by the programmer,
    and will be based on that target—a computer player will be able to make a smart
    move. For example, in the Snake AI game, the target of the computer player is
    to make a move that will lead them closer to the snake food, and in **first-person
    shooter** (**FPS**) games, the target of an artificial player is to approach the
    human player and to start to fire at the human player.
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you will have learned how to create an artificial
    system by defining machine states—ways to define what an artificial player will
    do in any instance. Similarly, we will take the example of Snake AI in order to
    illustrate how intelligence can be added to a computer player. We will create
    different entities for the game characters: the player, the computer, and the
    frog (snake food), and explore the power of object-oriented and modular programming.
    In this chapter, you will mostly find stuff that we have already covered and learn
    how to use it efficiently in order to make productive games.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding AI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Starting Snake AI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a computer player
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding intelligence to a computer player
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building the game and frog entities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building the surface renderer and handler
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Possible modifications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following list of requirements must be acquired in order to work through
    this chapter effectively:'
  prefs: []
  type: TYPE_NORMAL
- en: The Pygame editor (IDLE)—version 3.5+ is recommended
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The PyCharm IDE (refer to [Chapter 1](0ef9574b-5690-454e-971f-85748021018d.xhtml),
    *Getting to Know Python – Setting Up Python and the Editor*, for the installation
    procedure)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assets (snake and frog `.png` files)—available at the GitHub link: [https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter16](https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter16)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Check out the following video to see the code in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://bit.ly/2n79HSP](http://bit.ly/2n79HSP)'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding AI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the advent of numerous algorithms and models, today's game developers make
    use of them in order to create artificial characters, and then make them compete
    with human players. Playing a game passively, and competing with oneself, is not
    fun in real-world games anymore, thus, programmers intentionally set several difficulties
    and states, so that games are more challenging and fun. Among the several methods
    that programmers use, one of the best, and most popular, is making a computer
    compete with human beings. Sounds fun and complicated? The question that begs
    is how is it possible to create such algorithms, which will be able to compete
    with intelligent human beings. The answer is simple. We, as programmers, will
    define several smart moves, which will allow the computer to perform in a similar
    way to how we humans would respond to such situations.
  prefs: []
  type: TYPE_NORMAL
- en: While playing games, human beings are smart enough to protect their game characters
    from obstacles and defeat. Thus, in this chapter, our main aim is to provide such
    skills for NPCs. We will use the previously made Snake game ([Chapter 11](bab93016-a6cf-41d8-89e6-1dddfc357e2e.xhtml),
    *Outdo Turtle – Snake Game UI with Pygame*), refine it a little bit, and add a
    computer player to it, which will have some degree of awareness about where the
    food (things that the snake eats) is, and where obstacles are. Speaking literally,
    we are going to define different moves for our computer character, so that it
    will have a life of its own.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, recall [Chapter 4](22e1090d-87f1-4dd8-9f82-ff25cd4862e2.xhtml), *Data
    Structures and Functions*. In that chapter, we created a simple tic-tac-toe game,
    and embedded a simple *intelligent* algorithm in it. In that tic-tac-toe game,
    we were able to make a human player compete with the computer. We started by defining
    the models, handled the user events, and then finally added different moves in
    order for the computer to play on its own. We also tested the game, and the computer
    was able to beat the player in some instances. Thus, the basic concepts of AI
    were already learned by us back in [Chapter 4](22e1090d-87f1-4dd8-9f82-ff25cd4862e2.xhtml),
    *Data Structures and Functions*. Nevertheless, in this chapter, we are going to
    dig deeper down into the world of AI, and uncover other cool things about *intelligent
    algorithms*, which can be added into our previously made Snake game.
  prefs: []
  type: TYPE_NORMAL
- en: To know how an AI algorithm works, we have to have a fair amount of knowledge
    of state machine charts. A state machine chart (originating generally from the
    *theory of computation*) defines what an NPC must do in different instances. We
    will learn about state machine charts, or animation charts, in the next topic.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing states
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The number of states are different for each game, and is highly dependent upon
    the complexity of the game. For instance, in a game such as an FPS, the NPCs,
    or enemies, must have different states: seeking the human player randomly, spawning
    a number of enemies randomly within player positions, shooting the human player,
    and many more. The relation between each of these states is defined by the state
    machine diagram. This diagram (not necessarily pictorial) represents the change
    from one state to another. For example, at what point should the enemy fire at
    the human player? At what distance should a random number of enemies be spawned?'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram represents different states, and when such states must
    be changed from one to another:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/8dc4199a-500c-48da-ab7b-e1879473d42a.png)'
  prefs: []
  type: TYPE_IMG
- en: While observing the preceding diagram, you might not find it foreign. We have
    done similar things before, in the case of adding an intelligent computer player
    to the tic-tac-toe game. In the figure, we start with random enemy movement, since
    we don't want each and every enemy to be rendered in the same place. Similarly,
    after enemies are rendered, they are allowed to approach the human player. There
    is no restriction on the movement of enemies. Thus, a simple conditional check
    between the position of the enemy and the human player can be implemented, in
    order to perform vectored movements ([Chapter 10](b6bfaeca-a5ea-4d39-a757-653f2e2be083.xhtml),
    *Upgrading the Snake Game with Turtle*) for the enemies. Similarly, after each
    position change, the position of the enemies is checked against the human player's
    position, and if they are near to each other, then the enemies can begin to fire
    toward the human player.
  prefs: []
  type: TYPE_NORMAL
- en: 'Between every state, there is a check on the steps, which make sure that the
    computer player is intelligent enough to compete with the human player. We can
    observe the following pseudo code, which represents the preceding machine states:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding pseudo code, each state defines the code, which must be executed
    in order to perform check operations such as `player_movement`, `hits_boundary`,
    and `change_movements`. Furthermore, in the case of approaching the human player,
    the pseudo code looks something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The preceding pseudo code is not the actual code, but it provides us with a
    blueprint about what we can expect AI to do for us. In the next topic, we will
    see how we can use our knowledge of pseudo code, and state machines, to create
    different entities for implementing AI in our snake game.
  prefs: []
  type: TYPE_NORMAL
- en: Starting snake AI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As discussed in the case of FPS, similar machine states can be used in the
    case of snake AI. The two important states that need to be considered for our
    computer player in the Snake AI game are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: What movements are valid for the computer player?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are the crucial stages at which changes from one state to another occur?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With regard to the preceding points, the first one indicates that whenever the
    computer player approaches the boundary line or wall, the movements of the computer
    player must be changed (making sure it remains within the boundary line), so that
    the computer player can compete with the human player. Secondly, we have to define
    a target for the computer snake player. In the case of FPS, as stated before,
    the main target for the computer enemy, is to find a human player and perform
    a *shooting* operation, but, in snake AI, the computer player has to approach
    the food in the game. The real competition in snake AI, between, the human and
    the computer player, is who can eat the food faster.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we are aware of the actions that must be defined for the NPC (computer
    player), we can define the entities for the game. Similar to what we did in [Chapter
    11](bab93016-a6cf-41d8-89e6-1dddfc357e2e.xhtml), *Outdo Turtle – Snake Game UI
    with Pygame*, our Snake AI has three major entities, and they are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class** `Player`: It represents the human player, and all actions are related
    to the human—event handling, rendering, and movements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Class** `Computer`: It represents the computer player (a form of AI). It
    performs actions such as updating the position and updating the target.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Class** `Frog`: It represents the food for the game. The aim of the competition
    between the human and the computer is approach to the frog as fast as possible.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Besides these three major game entities, there are two remaining game entities
    that define the peripheral tasks, and they are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class** `Collision`: It represents the class that will have a method in order
    to check whether any entity (the player or the computer) has collided with the
    boundary, or not.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Class** `App`: It represents the class that will render the display screen
    and check whether any entity has eaten the frog or not.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, with the help of these entity blueprints, we can start to code. We will
    start by adding a `Player` class, along with the method that can render the player
    and handle its movement. Open your PyCharm editor, create a new project folder
    with a new Python file in it, and add the following code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, every module will be familiar to you, except `operator`.
    When writing programs (especially when checking for collisions between the game
    entity and the boundary wall), it is extremely helpful to use mathematical functions
    in order to perform operations, rather than using mathematical operators directly.
    For instance, if you want to check `if value >= 2`, we can easily do the same
    operations by using the functions that are defined inside the `operator` module.
    In this case, we can call the `ge` method, which represents *greater than equal
    to*: `if ge(value, 2)`. Similar to the `ge` method, we can call different methods
    such as these:'
  prefs: []
  type: TYPE_NORMAL
- en: '`gt(a, b)`: to check whether a > b—returns `True` if a > b; otherwise, `False`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lt(a, b)`**:** to check whether a < b—returns `True` if a < b; otherwise,
    `False`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`le(a, b)`: to check whether a <= b—returns `True` if a <= b; otherwise, `False`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`eq(a, b)`: to check whether a == b—returns `True` if a == b; otherwise, `False`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that you have imported the necessary modules, let''s get to the fun stuff,
    by creating the `Player` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we started defining class attributes: (`x`, `y`) represents
    the initial snake position, `size` represents the step size of the snake block,
    `direction` (value ranges from 0 to 4) represents the current direction in which
    the snake is moving, and `length` is the original length of the snake. The value
    of the attribute named `direction` will range from 0 to 3, where 0 represents
    that the snake is moving *right*, 1 represents that the snake is moving *left*,
    and similarly, 2 and 3 are for the *up* and *down* directions, respectively.'
  prefs: []
  type: TYPE_NORMAL
- en: The next two class attributes are `MaxMoveAllow` and `update`. These two attributes
    will be used in the function named `updateMove` (shown in the following code),
    and they make sure that the player is not allowed to make a movement of the snake
    more than twice. It may well be case that the player might enter more than two
    arrow keys at once, but if all the effects or arrow keys are reflected at once,
    the snake will move incongruously. To omit this, we have defined the `maxMoveAllowed`
    variable, in order to ensure that, at most, two arrow key presses are handled
    at once.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, we have defined the constructor inside the class, which performs
    the initialization of the class attributes. It is not limited to that—after rendering
    the snake player in a random position (done by the `for` loop), we have written
    a statement that ensures that there are no collisions at the beginning of the
    game (the highlighted part). The code implies that the position between each block
    of the snake and the other blocks must be three units apart. If you change the
    value of `self.x[0] = 2*44 to self.x[0] = 1 *44`, then a collision will happen
    between the snake head and its. Thus, to ensure that there is no collision at
    the beginning (before the players start to play), we have to provide a specific
    positional gap between the blocks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s use the `MaxMoveAllow` and `updateMove` attributes to create the
    `update` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code will not be foreign to you. You have seen such logic many
    times before (in [Chapter 6](7f11f831-b5e7-4605-a9bd-25bfb5e3098e.xhtml), *Object-Oriented
    Programming*, and in [Chapter 11](bab93016-a6cf-41d8-89e6-1dddfc357e2e.xhtml), *Outdo
    Turtle – Snake Game UI with Pygame*, while handling the snake position). To recapitulate,
    the preceding line of code changes the current position of the human player to
    a new one, based on which arrow key is pressed. You can see in the code that we
    have not handled any arrow keys (we will do this in the `App` class afterward),
    but we have created an attribute named `direction`, which can track which key
    has been pressed. If `direction` is equal to `0`, it means that the right arrow
    key has been pressed, thus, we increase the *x*-position with the block size.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, if `direction` is `1`, we change the *x* positional value, by decrementing
    it with a block size of `44`, which means that the snake will move toward the
    negative *x*-axis. (This information is not new; a detailed discussion can be
    found in [Chapter 9](8b0bc40b-fdbc-43c6-b043-1c6d8680600d.xhtml), *Data Model
    Implementation.*)
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, in order to make sure that each `direction` attribute is associated with
    a value ranging from 0 to 3; we will create functions for each of them, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Observing the preceding code, you might have noticed the importance of the
    `direction` attribute. Each movement has an associated value that can be used
    when handling user events with the `pygame` module (we will discuss this later
    in the chapter). But, for now, just have a look at the `draw` function, which
    takes the arguments of `surface` and `image` of the snake (human player), and
    blits them accordingly. You might have a question such as: instead of using the
    `direction` attribute to handle user events, why don''t we use a traditional approach
    (which we have been doing since [Chapter 8](44d5dc31-eee7-41f7-8f28-755fb5794439.xhtml),
    *Turtle Class – Drawing on the Screen*)? The question is valid, and obviously
    you can do it in that way, too, but there are major drawbacks to implementing
    such code in the case of Snake AI. Since Snake AI has two main players or game
    entities (the human being and the computer), each of them must have movements
    that are independent of one another. Thus, using traditional approaches for handling
    events differently for each entity would be both tedious and lengthy. A better
    option would be to use one attribute to track which key has been pressed, and
    handle it uniquely for each player, which we are going to do, in this case, using
    the `direction` attribute.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we are done with the main human player, we will reach out to the computer
    player. We will start writing code for the `Computers` class, which will handle
    the moves that the computer makes, in the next topic.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a computer player
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Finally, we are in the main part of our chapter—the meaty part—it is easier
    to add the computer snake character into the game. As with the appearance, the
    movement handling technique of the computer must resemble the human player. We
    can reuse the code that was written inside the `Player` class. The only the thing
    that must differ from the `Player` class is the *target*. In the case of the human
    player, the target is not defined, since the target of movement is implemented
    by the player's mind. For example, the human player can play the game effectively
    by controlling its snake movement in the direction of the snake food. If the snake
    food is on the left, then there is no way that the human player will press the
    right arrow key and move the snake in the opposite direction. But, the computer
    is not smart enough to think of the best way to win the game on its own. Thus,
    we have to explicitly specify the target for the computer player. This technique
    of specifying the target for an individual player/system will result in an intelligent
    system, and its application ranges widely—from games to robotics.
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, let''s replicate the code that was written inside the `Player` class
    and add it to the new class, which is named `Computer`. The following code represents
    the creation of the `Computer` class, along with its constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Similar to the `Player` class, it has four attributes, with `direction` specified
    with an initial value of `0`, which means that before the computer actually starts
    to play, the snake will be automatically moving in the right (positive *x*-axis)
    direction. Furthermore, everything that is initialized within the constructor
    is similar to the `Player` class, except the highlighted part of the code. The
    last line of the code has `y[0]`, which started from `4 *44`. Recalling the same
    part of code in the case of the human player, it was `2*44`, which represents
    the column position. Writing this code, we are implying that there must not be
    a collision between the human player snake and the computer player snake at the
    beginning of the game. But, the value of `x[0]` is the same, because we want each
    of the snakes to start within the same row, but not in the same column. By doing
    this, we omit their collision, and each player's snake will be rendered properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, we have to add the `update` method, which will reflect the changes
    in the *x*, *y* position of the computer snake, based on the `direction` attribute.
    Th following code represents the `update` method, which will make sure that the
    snake computer is limited to using a combination of only two arrow key movements
    at one time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code is similar to the `Player` class, so I won''t bother explaining
    it. You can refer to the `update` function of the `Player` class to see how this
    method works. Similar to the `Player` class, we have to add four methods that
    will change value of the `direction` variable accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The code that is written will be able to update the *direction* of the computer
    player, but it is not enough to make a smart move. Let's say, if the snake food
    is on the right-hand side, the code that has been written up till now won't be
    able to track the position of the food, and thus, the computer snake might go
    to the opposite place. Thus, we have to explicitly specify that the computer player
    will move in such a direction, which is close to the position of the snake food.
    We will cover this in the next topic.
  prefs: []
  type: TYPE_NORMAL
- en: Adding intelligence to a computer player
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up till now, two game entities have been defined, and both of them handle the
    players' movements. Unlike the `Player` class, another game entity (the computer
    player) is not going to decide its next move on its own. Thus, we have to explicitly
    enjoin the computer player to make a move that would take the snake closer to
    the snake food. By doing this, there will be immense competition between the computer
    player and the human player. This looks quite complex to implement; however, the
    idea still remains the same, as discussed earlier, along with the machine state
    diagram.
  prefs: []
  type: TYPE_NORMAL
- en: 'Going through the machine state diagram, the AI player must accommodate two
    things:'
  prefs: []
  type: TYPE_NORMAL
- en: Check the position of the snake food, and make a move in order to get closer
    to it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check the current position of the snake, and make sure it that doesn't hit the
    boundary wall.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The first step will be implemented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding line of code, we called different previously made methods,
    such as `moveLeft()`, `moveRight()`, and so on. These methods will cause the snake
    to move as indicated by the `direction` attribute value. The `target()` method
    takes two arguments: `food_x` and `food_y`, which compositely refer to the position
    of the snake food. The operators, `gt` and `lt`, are used to perform comparison
    operations with the snake *x*-head and *y*-head positions. For instance, if the
    snake food is on the negative *x*-axis, then a comparison is made between the
    *x*-position of the snake and the *x*-position of the food (`gt(self.x[0], food_x)`).
    It is obvious that `food_x` is on the negative *x*-axis, which means that the
    snake *x*-position is greater, thus, `moveLeft()` is called. As the signature
    of the method suggests, we are going to make a turn, and move the computer player
    snake toward the negative *x*-axis. Similar comparisons are done for each (*x*,
    *y*) position of the food, and each time a different method is called, so that
    we can lead the computer player toward the snake food.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have added the simple computer player, which is able to pass through
    multiple obstacles, let's add the `Frog` and `Collision` classes in the next topic.
    The `Frog` class is responsible for rendering the frog (the snake food) on the
    screen at random positions, and `Collision` will check whether there is a collision
    between the snakes, and/or between a snake and the boundary wall.
  prefs: []
  type: TYPE_NORMAL
- en: Building the game and frog entities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As previously mentioned, we are going to add two more classes into our code
    in this topic. Each of these classes serve different purposes in our Snake AI.
    The `Game` entity will check whether there is any sort of collision, by checking
    the argument that is passed to their member methods. In the case of the `Game`
    entity, we will define a simple, yet powerful method, named `checkCollision()`,
    which will return a Boolean of either `True` or `False`, based on the collision.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code represents the `Game` class and its member method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The call to the `checkCollision()` method will be done inside the main class
    (which will be defined in a moment). But, the important thing that you will notice
    is that the argument that is passed (the *x* and *y* values), will be the current
    position of the snake, from which this method will be called. Let's say you make
    an instance of the `Game` class, and pass the (`x1`, `y1`, `x2`, and `y2`) positional
    values of the human player. In doing so, you are calling the `checkCollision`
    method for the human players. The conditional statements check whether the positional
    value of a snake is the same as the boundary wall, or not. If yes, it will return
    `True`; otherwise, it will return `False`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next important game entity is `Frog`. This class renders the image of `Frog`
    in a random position, after each time it gets eaten by any player (the human or
    the computer). The following code represents the declaration of the `Frog` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have defined the *x*-position, the *y*-position, and
    the `draw` method in order to render the frog image. The call to this method will
    be made by creating `Frog` from the main class.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next topic, we will wrap up our program by creating and implementing
    one last entity: the main `App` entity. This will be the central director of our
    game.'
  prefs: []
  type: TYPE_NORMAL
- en: Building the surface renderer and handler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To begin, let''s recap what we have done so far. We started to write the code
    by defining two major game entities: `Player` and `Computer`. Both of these entities
    were quite similar in terms of actions and rendering methods, except an extra
    `target()` method was introduced within the `Computer` class, in order to make
    sure that the computer player is smart enough to compete with the human player.
    Similarly, we declared two more entities: `Game` and `Frog`. These two classes
    provide the backend facility for the Snake AI, such as adding collision logic,
    and checking the position for the snake food to be rendered in. We have created
    multiple methods within these different entities, but we have never made instances/objects
    out of them. Such instances can be created from the main single class, which we
    are going to implement now. I am going to call this class the `App` class.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at the following snippet in order to write the code for the `App` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code defines some attributes, such as `Height` and `Width`, for
    the games console. Similarly, it has a constructor, which initializes the different
    class attributes, along with creating the `Player`, `Frog`, and `Computer` instances.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next up, is to load the image from the computer and add it to the Python project
    (refer to [Chapter 11](bab93016-a6cf-41d8-89e6-1dddfc357e2e.xhtml), *Outdo Turtle
    – Snake Game UI with Pygame*, to learn more about the `load` method). The assets
    of the game, such as the snake body and food, are available at this GitHub link:
    [https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter16](https://github.com/PacktPublishing/Learning-Python-by-building-games/tree/master/Chapter16).
    But, you can also create your own, and experiment with it. I have taught you how
    to create a transparent sprite using GIMP and a simple paint application before,
    in [Chapter 11](bab93016-a6cf-41d8-89e6-1dddfc357e2e.xhtml), *Outdo Turtle – Snake
    Game UI with Pygame*. Try to recap those concepts, and it try on your own. For
    now, I am going to load two images into the Python project.'
  prefs: []
  type: TYPE_NORMAL
- en: It is better to use a .png file for sprites, and don't create a filename with
    a numeric value in it. For example, a filename for the snake body that is named
    `snake12.png` is not valid. The filename should be given without numeric values.
    Similarly, make sure that you add those `.png` files within the Python project
    folder. Revisit [Chapter 11](bab93016-a6cf-41d8-89e6-1dddfc357e2e.xhtml), *Outdo
    Turtle – Snake Game UI with Pygame*, to check how an image is loaded with PyCharm
    into the Python project.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code will load two image files into the Python project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding line of code, we created a `surface` object using the `pygame.display`
    module. Then, we loaded two images—`snake.png` and `frog-main.png`—into the Python
    project. The `convert()` method will change the pixel formatting of the rendered
    object, so that it works perfectly on any surface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, if a game has events, and it interacts with the user, then the `on_event`
    method must be implemented:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let''s define the `main` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding function, we called the `target` method to make sure that the
    computer player is able to use the capabilities that have been defined inside
    it. As discussed before, the `target()` method takes the *x*, *y* coordinates
    of the food and the computer makes a decision to move closer to the food. Similarly,
    the `update` method of both the `Player` and `Computer` classes is called.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s define the `renderer()` method. This method will draw the snakes
    and the food onto the game surface. This is done using the `pygame` and `draw`
    modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: If you feel that you do not understand the workings of the `renderer()` method,
    go to [Chapter 11](bab93016-a6cf-41d8-89e6-1dddfc357e2e.xhtml), *Outdo Turtle
    – Snake Game UI with Pygame*. In summary, this method will draw different objects
    (`image_surf` and `Frog_surf`) onto the game screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s create a `handler` method. This method will handle the user
    events. Different methods, such as `moveUp()`, `moveDown()`, `moveLeft()`, and
    `moveRight()` will be called, based upon the arrow keys that are pressed by the
    user. These four methods are created within both the `Player` and `Computer` entities.
    The following code defines the `handler` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The preceding `handler` method has been created so many times before (we saw
    both advanced and easy methods), and this one is the easiest one. We used the
    `pygame` module to listen to incoming key events and handled them accordingly,
    by calling different methods. For example, when the user pressed the down arrow
    key, the `moveDown()` method was called. The last `sleep` method will embed the
    timer, so that there is a difference between two successive key events.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s call this `handler` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s run our game and observe the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/d6ac8fdd-419c-4f70-911f-1a8a03bde72f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As expected, there are several things that must be added to this game, including:
    what happens when the human player and the computer player eat the food, and what
    happens when the snake collides with itself? If you have followed the book throughout,
    properly, this should be a piece of cake for you. We have added this same logic
    multiple times (in [Chapter 7](2d97aa5e-7fdd-459d-9c73-626e29c3a0ed.xhtml), *List
    Comprehension and Properties*; [Chapter 10](b6bfaeca-a5ea-4d39-a757-653f2e2be083.xhtml),
    *Upgrading the Snake Game with Turtle*; and [Chapter 11](bab93016-a6cf-41d8-89e6-1dddfc357e2e.xhtml), *Outdo
    Turtle – Snake Game UI with Pygame*). But apart from that logic, focus on the
    two alike snakes: one must be moving with human player actions, and the other
    independently. The computer snake was aware of the collision with the boundary
    wall and the position of the food. As soon as you run your game, the computer
    player will react instantaneously, and will try to make a smart move, before the
    human does. This is the application of AI in the real-world gaming industry. Although
    you might think that the Snake AI example is simpler, in the real world, AI is
    also all about the machine acting independently, regardless of how complex the
    algorithm is.'
  prefs: []
  type: TYPE_NORMAL
- en: But, there are several tweaks that must be made within the game, which will
    be covered in the next topic—*Possible modifications*.
  prefs: []
  type: TYPE_NORMAL
- en: Game testing and possible modifications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First of all, I suggest that you look back and observe the part where we defined
    the `Game` class. We defined the `checkCollision()` method inside it. This method
    can be used for multiple purposes: firstly, to check whether a player collides
    with the snake food; and secondly, to check whether a player collides with the
    boundary wall, or not. You must have a *gotcha* moment at this time. [Chapter
    7](2d97aa5e-7fdd-459d-9c73-626e29c3a0ed.xhtml), *List Comprehension and Properties*, to
    [Chapter 11](bab93016-a6cf-41d8-89e6-1dddfc357e2e.xhtml), *Outdo Turtle – Snake
    Game UI with Pygame*, was all about using this technique to implement the collision
    principle, which states that, *If the (x, y) position of food objects is same
    with the (x, y) coordinates of any player, there is said to be a collision.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add code that will check whether any player has collided with the food
    or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, let''s use the same function to check whether the human player''s
    snake has hit the boundary wall or not. You might think that you need to check
    this in the case of the computer player too, but that is useless, because the
    `target` method that was defined in the `Computer` class will not let this happen.
    In other words, the computer player will never hit the boundary wall, thus, checking
    whether a collision happened or not is useless. But, in the case of the human
    player, we will check it using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We will end this topic right here, but you can make this game even more appealing
    by adding a g*ame over* screen, which we learned how to create using `pygame` back
    in [Chapter 11](bab93016-a6cf-41d8-89e6-1dddfc357e2e.xhtml), *Outdo Turtle – Snake
    Game UI with Pygame*. Instead of the last `pass` statement, you can create a surface
    and render a font with a label in it, in order to create such a game over screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'But, before wrapping up this chapter, let''s look at the final output of our
    game:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/2c8da6fd-a322-4771-9da9-f4c1773a3e55.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Another thing that you might notice in the game is that the computer player''s
    snake *length* is constant, even if it eats the food. I did this intentionally,
    so that my game screen wouldn''t be polluted too much. But, if you want to increase
    the computer player''s snake length (every time the snake eats the food), you
    can add a statement after the computer player snake eats the frog:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have come to the end of this chapter. We have learned different
    things, as well as revising old ones. The concepts that are associated with AI
    are vast; we have just attempted to touch the surface. You can find other implications
    of AI in the game using Python by heading to this URL: [https://www.pygame.org/tags/ai](https://www.pygame.org/tags/ai).'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored the basic way of implementing AI in our game. Nonetheless,
    the workings of AI depend heavily on rewarding the intelligent system for its
    each and every move. We used a machine state diagram to define the possible states
    for our computer player, and used it to perform different actions for each entity.
    We employed different programming paradigms in this single chapter; in fact, it
    was a recap of everything that we have learned so far, in addition to employing
    smart algorithms for NPCs.
  prefs: []
  type: TYPE_NORMAL
- en: For each defined entity, we made a class, and employed an object-oriented paradigm
    such as the encapsulation and model, based on properties and methods. Furthermore,
    we defined different classes such as `Frog` and `Game` in order to implement the
    logic for collisions. The reason for making separate classes for implementing
    single logic is because these methods should be called by each game entity (`Player`
    and `Computer`) independently. You could infer it as multi-inheritance. The main
    aim of this book was to make the reader understand how a gaming bot can be created
    with Python. Furthermore, to some extent, the aim was to revise all the programming
    paradigms that we have learned throughout the book, in a single chapter.
  prefs: []
  type: TYPE_NORMAL
- en: As the old adage says: *Known is a drop. Unknown is an Ocean*. I hope you are
    still yearning to learn more about Python. I suggest you brush up on your basic
    programming skills and experiment more often, which will surely lead you to your
    dream job of becoming a game developer. The gaming industry is huge, and having
    knowledge of Python will make a difference. Python is a beautiful language, thus,
    you will be incentivized to learn it more deeply, and this book will be the first
    of many steps that you will take in order to become an expert in Python.
  prefs: []
  type: TYPE_NORMAL
