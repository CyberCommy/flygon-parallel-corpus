- en: Creating Sound and Music
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will introduce methods of making sounds and playing music using
    the hardware that comes on the Adafruit Circuit Playground Express. The chapter
    will first introduce the basics of making the board beep at a certain frequency
    of sound and will then move on to more advanced topics, such as playing music
    files using the WAV file format and the board's built-in sound speakers. The techniques
    in this chapter can be used directly in a wide array of MicroPython projects that
    you might make. The options for producing audio output in this chapter range from
    producing simple beeping sounds to playing songs in your embedded projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Making a beeping sound
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling tone, frequency, and duration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Playing a musical note
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Playing a melody
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sounding the alarm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Playing WAV files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting MP3 files to WAV files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Starting and stopping tones
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Adafruit Circuit Playground Express layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following photograph shows the locations of the speaker that is built into
    the board. All of the beeps and sounds covered in this chapter will use this speaker
    for playback:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/7b610559-8dc7-4b1f-ba85-79f8b5c9f34c.png)'
  prefs: []
  type: TYPE_IMG
- en: Courtesy of adafruit.com
  prefs: []
  type: TYPE_NORMAL
- en: Making a beeping sound
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to get the speakers to make a beeping sound
    at a specific sound frequency and for a specific duration of time. Audio output
    is a great way to get someone's attention; you can find it used everywhere from
    ringing phones to doorbells. This recipe will give you the skills that you need
    to add beeps to your embedded projects.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need access to the REPL on the Circuit Playground Express to run the
    code presented in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following lines of code in the REPL. You should hear a beeping sound
    at a frequency of 900 Hz played for 0.2 seconds:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the following code so that a lower frequency beep will be played for
    a longer duration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first line of code imports the Circuit Playground Express library. The
    `cpx` object exposes a method called `play_tone`. This method accepts two arguments:
    frequency and duration. These arguments specify the frequency of the sound in
    Hz, and how long the sound will be played in seconds.'
  prefs: []
  type: TYPE_NORMAL
- en: The duration can be given as a floating point number. This means that a value
    such as `0.2` will correlate to 200 milliseconds. This method call is a blocking
    call. So, calling the method will start playing the audio and it won't return
    anything until the specified time has elapsed.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The technique presented in this chapter is a very straightforward way of generating
    a beeping sound from the speakers on the board. However, under the hood, a lot
    is happening. When you specify the frequency and duration of a sound, it will
    build the sound wave programmatically, and then feed the audio data into the speaker
    to play the sound. The audio data is created by building a sine wave in Python
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code that builds this audio data is part of the Circuit Playground Express
    library, which was imported in this recipe. You can download the code and read
    it to learn how this is done. It''s a great way to understand the mathematics
    of sound waves and how they can be created through software. The following screenshot
    shows what a computer-generated tone playing at 500 Hz looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ea2fd2f8-ab5a-4f62-a3c4-d012bbb0de11.png)'
  prefs: []
  type: TYPE_IMG
- en: You can see clearly from the preceding screenshot that this looks just like
    a sine waveform. The screenshot was taken when we zoomed in to see an individual
    sound cycle. Since the sound is playing at 500 Hz, we would expect one cycle to
    be 1/500 of a second long. Here, we can see that this is where the first wave
    endsâ€”at exactly 0.002 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can find out more information using the following references:'
  prefs: []
  type: TYPE_NORMAL
- en: Documentation on the `play_tone` method can be found at [https://circuitpython.readthedocs.io/projects/circuitplayground/en/latest/api.html#adafruit_circuitplayground.express.Express.play_tone](https://circuitpython.readthedocs.io/projects/circuitplayground/en/latest/api.html#adafruit_circuitplayground.express.Express.play_tone).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More details on the audio spectrum that humans can hear can be found at [https://www.teachmeaudio.com/mixing/techniques/audio-spectrum/](https://www.teachmeaudio.com/mixing/techniques/audio-spectrum/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling tone, frequency, and duration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to play tones with a varying frequency and
    duration. By playing different tones repeatedly with a different duration each
    time, we can learn how to go beyond individual beeps. These steps will eventually
    lead to us playing melodies or varying tones that can make the same sound as an
    alarm.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need access to the REPL on the Circuit Playground Express to run the
    code presented in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following lines of code in the REPL. You should hear five separate
    tones playing for 0.2 seconds each. The sounds will start at a lower pitch and
    gradually get higher and higher. As each tone plays, the frequency of the tone
    will be printed to the output in the REPL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the following code to play three different tones. The tones will increase
    in pitch and will also increase in terms of duration of the playback:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the first block of code, the `for` loop will iterate over the frequency value,
    starting from 500 and raising the value in increments of 100 to end at 900\. This
    range and these steps will be easily audible to the human ear. In each iteration,
    the frequency to be played will be printed out and then played using the `play_tone`
    method. Only the frequency of the sound changes in each iteration; they will all
    play for 200 milliseconds.
  prefs: []
  type: TYPE_NORMAL
- en: In the second block of code, the `for` loop will iterate over a lower sound
    pitch and through fewer tones. For each iteration, the frequency and duration
    of the tone increases. The frequency will be the exact value of the `i` variable,
    while the duration will be the value of `i` in terms of milliseconds. Since the
    `play_tone` method is expecting the value in seconds, we must divide it by 1,000.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The two `for` loops presented in this chapter vary the way tones are played
    over a brief duration of time. In both examples, the tones play within one second
    but they have three or more different tones playing.
  prefs: []
  type: TYPE_NORMAL
- en: This is an excellent starting point to experiment with different variations
    of these loops. Because it only takes a second to play each loop, you can go through
    a fast cycle of experimentation and hear the results instantly. Try and experiment
    by changing the pitch or the pace at which the tones change.
  prefs: []
  type: TYPE_NORMAL
- en: In both loops, the pitch increased with each iteration. Try and experiment with
    a pitch that gets lower with each iteration.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can find out more information using the following references:'
  prefs: []
  type: TYPE_NORMAL
- en: Documentation on the Python range function can be found at [https://docs.python.org/3/library/functions.html#func-range](https://docs.python.org/3/library/functions.html#func-range).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An explanation of pitch and frequency can be found at [https://www.le.ac.uk/se/centres/sci/selfstudy/snd5.htm](https://www.le.ac.uk/se/centres/sci/selfstudy/snd5.htm).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Playing a musical note
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to define a number of global constants, each
    representing a specific musical note. Then, we can play these different musical
    notes by referring to their constants. Musical notes are the building blocks of
    melodies. This will be the first step toward playing a melody. Once we have learned
    how to play a musical note, we can then combine a number of notes in sequence
    to play a melody in future recipes.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need access to the REPL on the Circuit Playground Express to run the
    code presented in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following lines of code in the REPL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: You should hear the `E5` musical note play on the speakers for 0.15 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following code to play the `C5` and `G5` musical notes for 0.15 seconds:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first line of code in this recipe imports the Circuit Playground Express
    library. Then, three global constants are defined and are named after their associated
    musical notes. The **scientific pitch notation** (**SPN**) is used in this recipe.
    This notation works by combining the name of a musical note with the number specifying
    the pitch's octave. In the case of E5, the note will be E and the octave will
    be 5\. Here, each note maps to a specific frequency of sound.
  prefs: []
  type: TYPE_NORMAL
- en: In the first block of code, the `E5` note is played simply by referring to the
    `E5` global constant when calling the `play_tone` method. Setting the duration
    to `0.15` allows each note play for 150 milliseconds, which creates a comfortable
    pace to the music. Reducing or increasing this value can increase or reduce the
    pace that the musical tone will play. The second block of code plays the remaining
    two notes defined at the same speed.
  prefs: []
  type: TYPE_NORMAL
- en: The frequencies used in this chapter follow the standard piano key frequencies.
    This is equivalent to the standard concert pitch and the 12-tone equal temperament.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we used three musical notes to demonstrate the process of defining
    notes and then playing each note back. Of course, there are many more notes that
    can be defined.
  prefs: []
  type: TYPE_NORMAL
- en: A good learning exercise is to find the frequency of other popular notes and
    go through the process of defining them and playing them. Even though three notes
    seems like too few, they are enough to play a recognizable melody. We will see
    in the following recipe how these same three notes can be combined to play a popular
    melody.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can find out more information using the following references:'
  prefs: []
  type: TYPE_NORMAL
- en: An explanation of the octave notation can be found at [http://www.flutopedia.com/octave_notation.html](http://www.flutopedia.com/octave_notation.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Python-based software synthesizer can be found at [https://mdoege.github.io/PySynth/](https://mdoege.github.io/PySynth/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Playing a melody
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to play a melody by playing a sequence of
    musical notes. A single musical note on its own is rather boring. The real fun
    begins when you can combine a sequence of them and time them correctly to play
    a melody.
  prefs: []
  type: TYPE_NORMAL
- en: By following the standard musical notation, it will become possible to take
    popular melodies and specify them in Python in a way that the Circuit Playground
    Express will be able to play them back.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need access to the REPL on the Circuit Playground Express to run the
    code presented in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following lines of code in the REPL. You should hear the `E5` musical
    note play on the speakers for 0.15 seconds:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the following lines of code to play the same note at twice the speed, and
    then at half the speed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the following line of code to play nothing and keep the speaker silent
    for the same period as one note playing at the normal speed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the following lines of code to play the initial part of the *Super Mario
    Bros.* theme song:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The code that follows combines all the code shown in this recipe to make one
    complete program. Add this to the `main.py` file and it will play the start of
    the *Super Mario Bros.* theme song every time you reload the code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The initial lines of code import the necessary libraries and set up the constants
    that are required for the rest of the code in the program. The `MELODY` constant
    has the sequence of notes that make up the song. There are pauses of silence between
    certain notes; these are simply specified with a value of `0` to indicate that
    no notes should be played at this point. The `play_note` function expects to be
    given the frequency of the note to play and, optionally, the duration of time
    to play the note for. If a frequency of `0` is given, it will call the sleep function
    to stay silent; otherwise, it will play the note as a tone.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `for` loop at the end of the program simply loops through each
    note defined in the melody and plays it by calling the `play_note` function. In
    this way, you can define many different melodies and songs, and play different
    songs depending on how the user interacts with the device.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This recipe is written in a generic fashion: you take a popular melody, provide
    the sequence of notes and each note''s associated frequency, and then add the
    melody to your project. The melody in this recipe has each note play for the same
    duration.'
  prefs: []
  type: TYPE_NORMAL
- en: However, there are many melodies that might mix quarter notes and eighth notes.
    These melodies will require a different duration of time to be defined for each
    note. The recipe could be expanded so that we could keep track of each note to
    play and the duration that each note would need to play for.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can find out more information using the following references:'
  prefs: []
  type: TYPE_NORMAL
- en: The playback of the *Super Mario Bros.* theme song on an Arduino device can
    be found at [https://www.princetronics.com/supermariothemesong/](https://www.princetronics.com/supermariothemesong/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A discussion on sound and music with the Circuit Playground can be found at
    [https://learn.adafruit.com/circuit-playground-music](https://learn.adafruit.com/circuit-playground-music).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An example of playing a melody on the Circuit Playground can be found at [https://learn.adafruit.com/circuit-playground-hot-potato/caternuson-playing-a-melody](https://learn.adafruit.com/circuit-playground-hot-potato/caternuson-playing-a-melody).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sounding the alarm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to play low and high frequency sounds to create
    the sound of an alarm. Alarm sounds are very useful for alerting people to get
    their attention. This recipe demonstrates a very simple, but effective, way to
    create an alarm sound, which can then be taken and adapted to the needs of your
    project.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need access to the REPL on the Circuit Playground Express to run the
    code presented in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s perform the following steps for this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following lines of code in the REPL. You should hear a high-pitched
    beeping sound for 0.5 seconds:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the following code to play a low-pitched beeping sound for 0.5 seconds:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the following code to play a siren that goes from a high to a low pitch
    through three cycles, playing for a total of three seconds:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The code that follows combines all the code shown in this recipe to make one
    complete program. Add this to the `main.py` file and it will play the siren alarm
    for three seconds every time you reload the code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The initial lines of code import the necessary libraries and set up the constants
    that are required for the rest of the code in the program. The script then loops
    for a total of three iterations, with each iteration playing sounds for a total
    of one second.
  prefs: []
  type: TYPE_NORMAL
- en: In each iteration, a high-pitched tone will be played for a half a second, followed
    by a low-pitched tone for half a second. In this way, a siren sound effect is
    created, similar to an alarm.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This code can be put into a function that receives an argument count, which
    specifies how many iterations or seconds the alarm is sounded for. Then, for any
    code in your project, you could call the function to make your board play an alarm
    for 10 seconds or 30 seconds. You could also combine this recipe with others in
    the book to make the pixels on the board flash red in the same way that an alarm
    would.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can find out more information using the following references:'
  prefs: []
  type: TYPE_NORMAL
- en: Examples of changing the frequency when calling the `play_tone` method can be
    found at [https://learn.adafruit.com/circuitpython-made-easy-on-circuit-playground-express/play-tone](https://learn.adafruit.com/circuitpython-made-easy-on-circuit-playground-express/play-tone).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A microcontroller project that makes a siren alarm sound can be found at [https://www.instructables.com/id/How-to-Make-a-Siren-Using-Arduino/](https://www.instructables.com/id/How-to-Make-a-Siren-Using-Arduino/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Playing WAV files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to use the speakers to play a WAV file of
    your choice. There is a good amount of storage on the Circuit Playground Express
    to store short audio clips, which can be played back at certain times.
  prefs: []
  type: TYPE_NORMAL
- en: Tones, beeps, alarms, and melodies are great; however, once you can play WAV
    files, then you can play any type of sound.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need access to the REPL on the Circuit Playground Express to run the
    code presented in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Copy the `hello.wav` file to the device in the same folder as the `main.py`
    file. Then, run the following lines of code in the REPL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: You should hear the board say *"**Hello"* as it plays back the audio file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first line of code imports the Circuit Playground Express library. The `cpx`
    object exposes a property method called `play_file`. This method accepts one argument
    in the `.wav` filename, which will be played on the onboard speaker.
  prefs: []
  type: TYPE_NORMAL
- en: The audio file should be in WAV file format; it should have a sample rate of
    22,050 kHz, be 16-bit format, and have a mono channel of audio. This method will
    open the audio file and start the playback on the speaker. It will also keep polling
    the audio device until the playback is finished and will return once the audio
    playback has completed.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Due to hardware constraints on the board, you won't be able to play compressed
    music formats such as MP3\. The file will need to be in a specific uncompressed
    file format, which can be fed directly to the playback hardware that is on the
    board.
  prefs: []
  type: TYPE_NORMAL
- en: A consequence of this is that the uncompressed sound streams will be much larger,
    so only short audio clips will be able to be stored on the device. This still
    opens up a number of possibilities for playing sound effects or other short audio
    clips.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can find out more information using the following references:'
  prefs: []
  type: TYPE_NORMAL
- en: Documentation on the `play_file` method can be found at [https://circuitpython.readthedocs.io/projects/circuitplayground/en/latest/api.html#adafruit_circuitplayground.express.Express.play_file](https://circuitpython.readthedocs.io/projects/circuitplayground/en/latest/api.html#adafruit_circuitplayground.express.Express.play_file).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examples of calling the `play_file` method can be found at [https://learn.adafruit.com/circuitpython-made-easy-on-circuit-playground-express/play-file](https://learn.adafruit.com/circuitpython-made-easy-on-circuit-playground-express/play-file).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting MP3 files to WAV files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to convert an MP3 file to a WAV file, which
    can then be played on the Circuit Playground Express. MP3 files are one of the
    most popular sound file formats around. This recipe is very useful for when you
    have an audio clip that you want to include in your embedded project, but need
    to get it in the right format so that it can play back correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need to download and install the open source audio editing software,
    Audacity. It is available for Windows, macOS, and Linux.
  prefs: []
  type: TYPE_NORMAL
- en: Audacity can be downloaded from the official website at [https://www.audacityteam.org/](https://www.audacityteam.org/).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start the Audacity software and select File | Open. Then, select the MP3 file
    and click on Open.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Details of the audio file should appear in the application, as shown in the
    following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/2e53af75-4de3-4618-ac25-0808b3010fc0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Select Tracks | Resample and the following dialog box should appear:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/ec025055-3467-4fd2-a993-26d6b45e3f27.png)'
  prefs: []
  type: TYPE_IMG
- en: Set the new sample rate to `22050` and then click on OK.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, choose Tracks | Stereo Track to Mono. Instead of the stereo audio streams
    that were visible, there should only be one single mono channel on the screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/a41bf509-b7ef-4be2-afa8-76a4c9ca5926.png)'
  prefs: []
  type: TYPE_IMG
- en: The audio data is now ready to be exported to the WAV format.
  prefs: []
  type: TYPE_NORMAL
- en: Next, choose File | Export Audio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the file format drop-down menu to the value of WAV (Microsoft) signed 16-bit
    PCM.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the Save button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can now copy the WAV file to the board and play it back on the device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Circuit Playground Express board expects an audio file to be in the WAV
    file format and have a sample rate of 22,050 kHz, be in 16-bit format, and have
    a mono channel of audio data. Audacity is a versatile audio editor that can open
    any number of audio formats and perform the necessary changes to convert the audio
    data into the correct format.
  prefs: []
  type: TYPE_NORMAL
- en: The steps taken in this recipe resample the audio data and convert the audio
    channels to a single mono channel. Once that is done, the audio data can be exported
    to the correct WAV format. It is important to note that WAV files are not compressed
    like other audio formats, so they will take up much more space. This, combined
    with the storage constraints on this device, mean that only short audio clips
    should be used so that they can fit on the device.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe focused on the MP3 file format as the input format. However, Audacity
    supports a wide range of input formats, so you are not limited to only that input
    format for conversion. Audacity also has extensive editing capabilities that will
    come in very handy when you want to prepare a short audio clip from a much bigger
    audio stream.
  prefs: []
  type: TYPE_NORMAL
- en: A good example of this is when you have a song that might be five minutes long,
    but you only want a short five-second clip to be loaded on your board. You can
    then use the editing and conversion features of Audacity to achieve the final
    result.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can find out more information using the following references:'
  prefs: []
  type: TYPE_NORMAL
- en: More details on the WAV PCM soundfile format can be found at [http://soundfile.sapp.org/doc/WaveFormat/](http://soundfile.sapp.org/doc/WaveFormat/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A guide to using Audacity for microcontroller audio projects can be found at
    [https://learn.adafruit.com/microcontroller-compatible-audio-file-conversion](https://learn.adafruit.com/microcontroller-compatible-audio-file-conversion).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Starting and stopping tones
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to use the `start_tone` and `stop_tone` calls
    to play tones in the background, and control other components on the board during
    the playback of the sound. The technique used in this recipe will essentially
    allow you to do more than one thing at an item when you play sounds.
  prefs: []
  type: TYPE_NORMAL
- en: One example of when you might want to implement this in a project is when you
    want to play an alarm sound and flash the lights at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need access to the REPL on the Circuit Playground Express to run the
    code presented in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following lines of code in the REPL. You should hear a high-pitched
    beeping sound for 0.5 seconds:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the following code to play a beeping sound in the background while 10 pixels
    turn red at 0.1-second intervals. The beeping will then stop at the end of the
    animation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the following block of code to perform a similar operation, but with a
    lower pitch. Here, the pixel animation will turn off each pixel one by one, ending
    the tone at the end of the animation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The code that follows combines all the code shown in this recipe to make one
    complete program. Add this to the `main.py` file and it will play a siren alarm
    and animate the pixels on and off with the siren:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The initial lines of code import the necessary libraries and set up the constants
    that are required for the rest of the code in the program. The brightness of the
    pixels is also set to a more comfortable level. The script then starts playing
    the high-pitched beeping tone in the background. It does so while looping through
    the 10 pixels and turning each one red, with a 0.1-second delay between each loop.
  prefs: []
  type: TYPE_NORMAL
- en: Once the animation is complete, the tone playback is stopped and a lower tone
    is played. The pixels are once again looped through; however, this time, they
    are shut off one by one. Finally, once the loop ends, the tone playback is stopped.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Even though using `start_tone` and `stop_tone` requires more lines of code than
    simply calling `play_tone`, they allow you to do things that wouldn't be possible
    with just `play_tone`. For example, you can use your script to perform other tasks
    while audio is playing in the background.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, the light and sound output were changed together. However, you
    could use the same technique to play a tone until someone presses a certain button.
    Alternatively, you could change the tones being played in reaction to different
    buttons being pressed.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can find out more information using the following references:'
  prefs: []
  type: TYPE_NORMAL
- en: Documentation on the `start_tone` method can be found at [https://circuitpython.readthedocs.io/projects/circuitplayground/en/latest/api.html#adafruit_circuitplayground.express.Express.start_tone](https://circuitpython.readthedocs.io/projects/circuitplayground/en/latest/api.html#adafruit_circuitplayground.express.Express.start_tone).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documentation on the `stop_tone` method can be found at [https://circuitpython.readthedocs.io/projects/circuitplayground/en/latest/api.html#adafruit_circuitplayground.express.Express.stop_tone](https://circuitpython.readthedocs.io/projects/circuitplayground/en/latest/api.html#adafruit_circuitplayground.express.Express.stop_tone).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
