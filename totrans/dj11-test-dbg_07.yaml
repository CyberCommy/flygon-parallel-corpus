- en: 'Chapter 7. When the Wheels Fall Off: Understanding a Django Debug Page'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just about the last thing you want when your code is running in production is
    for it to encounter an error so severe that the only message that can be returned
    to the client is "We're sorry, the server has encountered an error, please try
    again later." During development, however, these server error situations are among
    the best of the bad outcomes. They generally indicate an exception has been raised,
    and when that happens there is a wealth of information available to figure out
    what has gone wrong. When `DEBUG` is on, this information is returned, in the
    form of a Django debug page, as the response to the request that caused the error.
    In this chapter, we will learn how to understand and make use of the information
    provided by a Django debug page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, in this chapter we will:'
  prefs: []
  type: TYPE_NORMAL
- en: Continue development of the example survey application, making some typical
    mistakes along the way
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See how these mistakes manifest themselves in the form of Django debug pages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn what information is provided on these debug pages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For each mistake, dig into the information available on the resulting debug
    page to see how it can be used to understand the error and determine how to fix
    it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Starting the Survey voting implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 4](ch04.html "Chapter 4. Getting Fancier: Django Unit Test Extensions"),
    *Getting Fancier: Django Unit Test Extensions*, we began developing code to serve
    pages for the `survey` application. We implemented the home page view. This view
    generates a page that lists both active and recently closed surveys and provides
    links, as appropriate, to either take an active survey or display results from
    a closed survey. Both of these kinds of links route to the same view function,
    `survey_detail`, which further routes the request based on the state of the `Survey`
    for which details have been requested:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We did not then, however, write the code to actually display an active `Survey`
    or display results from a `Survey`. Rather we created placeholder views and templates
    that simply state what the pages are eventually intended to show. For example,
    the `display_active_survey` function was left simply as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The template it references, `active_survey.html`, contains:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We will now pick up where we left off here and start replacing this placeholder
    view and template with real code that handles displaying an active `Survey`.
  prefs: []
  type: TYPE_NORMAL
- en: What's involved in doing this? First, when a request comes in to display an
    active survey, we want to return a page that displays the list of questions in
    the `Survey`, each with their associated possible answers. Furthermore, we want
    to present these in a manner so that the user can participate in the `Survey`,
    and submit their chosen answers for the questions. Thus, we will need to present
    the question and answer data in an HTML form, and also have code on the server
    that handles receiving, validating, recording, and responding to posted `Survey`
    responses.
  prefs: []
  type: TYPE_NORMAL
- en: All of that is a lot to tackle at once. What is the smallest piece we can implement
    first that will allow us to start experimenting and verifying that we are moving
    in the right direction? We'll start with the display of a form that allows users
    to see a single question and choose from among its associated answers. First,
    though, let's get our development database set up with some reasonable test data
    to work with.
  prefs: []
  type: TYPE_NORMAL
- en: Creating test data for voting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As it''s been a while since we were working with these models, we may no longer
    have any active surveys. Let''s start with a clean slate by running `manage.py
    reset survey`. Then, ensure the development server is running and use the admin
    application to create a new `Survey`, `Question`, and `Answers`. This is the `Survey`
    that will be used in the upcoming examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating test data for voting](img/7566_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `Answers` defined for the one `Question` in this `Survey` are:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating test data for voting](img/7566_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: That's enough to get started with. We can come back later and add more data
    as necessary. Now, we will move on to developing the form used to display a `Question`
    and choose one of its answers.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a question form for voting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Django `forms` package provides a convenient framework for creating, displaying,
    validating, and processing HTML form data. Within the forms package, the `ModelForm`
    class is often useful for automatically building forms that represent models.
    We might initially think that using a `ModelForm` would come in handy for our
    task here, but a `ModelForm` would not provide what we need. Recall that the `survey`
    application `Question` model contains these fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Further, the `Answer` model is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: A `ModelForm` contains HTML input fields for each field defined in the model.
    Thus, a `ModelForm` for the `Question` model would consist of a text input allowing
    the user to change the content of the `question` field, and a selection box allowing
    the user to select which `Survey` instance this `Question` is associated with.
    That's not at all what we want. Nor is a `ModelForm` built from the `Answer` model
    what we are looking for.
  prefs: []
  type: TYPE_NORMAL
- en: Rather, we want a form that will display the text of the `question` field (but
    not allow the user to change that text), along with all of the `Answer` instances
    associated with the `Question` instance, in a manner that allows the user to select
    exactly one of the listed answers. That sounds like an HTML radio input group
    where the individual radio button values are defined by the set of `Answers` associated
    with the `Question` instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create a custom form to represent this, using the basic form field and
    widget classes provided by Django. Let''s create a new file, `survey/forms.py`,
    and put in it an initial attempt at implementing the form that will be used to
    display a `Question` and its associated answers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This form is named `QuestionVoteForm` and has only one field, `answer`, which
    is a `ModelChoiceField`. This type of field allows selection from a set of choices
    defined by a `QuerySet`, specified by its `queryset` attribute. Since the correct
    set of answers for this field will depend on the specific `Question` instance
    for which the form is built, we omit specifying a `queryset` on the field declaration
    and set it later, in the `__init__` routine. We do, however, specify in the field
    declaration that we want to use a `RadioSelect` widget for display, instead of
    the default `Select` widget (which presents the choices in an HTML select drop-down
    box).
  prefs: []
  type: TYPE_NORMAL
- en: Following the declaration for the single `answer` field, the form defines an
    override for the `__init__` method. This `__init__` requires that a `question`
    argument be passed in when creating an instance of the form. After first calling
    the `__init__` superclass with whatever other arguments may have been provided,
    the passed `question` is used to set the `queryset` attribute for the `answer`
    field to be the set of answers that are associated with this `Question` instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to see if this form displays as intended, we need to create one of
    these forms in the `display_active_survey` function and pass it to the template
    for display. For now, we do not want to worry about displaying a list of questions;
    we''ll just pick one to pass to the template. So, we can change `display_active_survey`
    to be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now this function creates an instance of a `QuestionVoteForm` for the first
    question in the set of questions for the specified survey, and passes that form
    along to the template for rendering as the context variable `qvf`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to modify the template to display the passed form. To do this,
    change the `active_survey.html` template to be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Here we have added the necessary HTML elements to surround the Django form and
    make it a valid HTML form. We've used the form `as_p` method for display, just
    because it is easy. Long-term, we will likely replace that with custom output,
    but displaying the form in an HTML paragraph element will do for the present.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we are hopefully at a point where we can test and see whether our `QuestionVoteForm`
    displays what we want it to. We will try that next.
  prefs: []
  type: TYPE_NORMAL
- en: 'Debug page #1: TypeError at /'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to see how the `QuestionVoteForm` is looking so far, we can first
    go to the survey home page and from there we should be able to click on the link
    for the one active survey we have, and see how the question and answer choices
    are displayed. How well does that work? Not so well. With the code changes we
    have made, we can no longer even display the home page. Instead, attempting to
    access it produces a debug page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Debug page #1: TypeError at /](img/7566_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Yikes, that looks bad. Before we dig into the details of what the page is showing,
    let's try to understand what has happened here. We added a new form, and we changed
    the view used to display active surveys so that it creates one of the newly-defined
    forms. We also changed the template used by that view. But we did not change the
    home page view at all. So how could it now be broken?
  prefs: []
  type: TYPE_NORMAL
- en: The answer is that the home page view itself is not broken, but something else
    is. That broken something else is preventing the home page view from even being
    called. Note that in order to call the home page view, the module that contains
    it (`survey.views`) must be imported without error. Thus, `survey.views` itself
    and anything it references when it is imported must be error-free. Even if nothing
    in the home page view, or even all of `survey.views`, is broken, an error may
    be raised on an attempt to call the home page view if an error has been introduced
    into any module imported as a result of importing `survey.views`.
  prefs: []
  type: TYPE_NORMAL
- en: The point is that changes made in one place may cause initially surprising breakage
    in what seems to be an entirely unrelated area. In fact, the other area is not
    entirely unrelated, but is somehow (usually via a chain of imports) connected
    to the area where the change was made. It is important in cases like this to focus
    attention on the right place in order to find and fix the error.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, for example, staring blankly at the home page view code, because
    that is the code we were attempting to run, and trying to figure out what is wrong
    with it, would be fruitless. That is not where the problem is. Rather, we need
    to put aside any preconceived ideas we have about what code might have been running
    at the time of the error, and use the debug information presented to figure out
    what code was actually running. It can also be instructive to figure out why one
    bit of code ends up running when we were trying to run something else entirely,
    although it is not always necessary to do that in order to fix the problem at
    hand.
  prefs: []
  type: TYPE_NORMAL
- en: Elements of the debug page
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now let's turn our attention to the debug page we've encountered. There is quite
    a lot of information on it, split into four parts (only the first and beginning
    of the second are visible in the screenshot). In this section, we focus on what
    information, in general, is included in each part of the debug page, noting the
    values we see on this page simply as examples. Later in the chapter, we will see
    how the specific information presented on this debug page can be used to fix the
    error we have made.
  prefs: []
  type: TYPE_NORMAL
- en: Basic error information
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The very top part of the debug page contains basic error information. Both the
    page title and the first line of the page body state the type of exception encountered,
    and the URL path contained in the request that triggered the exception. In our
    case, the type of exception is a **TypeError**, and the URL path is **/**. So,
    we see **TypeError at /** as the first line on the page.
  prefs: []
  type: TYPE_NORMAL
- en: The second line contains the exception value. This is usually a specific description
    of what caused the error. In this case, we see **__init__() takes at least 2 non-keyword
    arguments (1 given)**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following the exception value is a list of nine items:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Request Method**: The HTTP method specified in the request. In this case,
    it is **GET**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Request URL**: The full URL of the request. In this case it is **http://localhost:8000/**.
    The path part of this is a repeat of the path reported on the first line.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Exception Type**: This is a repeat of the exception type included on the
    first line.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Exception Value**: This is a repeat of the exception value included on the
    second line.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Exception Location**: The line of code where the exception occurred. In this
    case, it is **/dj_projects/marketr/survey/forms.py in QuestionVoteForm, line 3**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Python Executable**: The Python executable running at the time of the error.
    In this case, it is **/usr/bin/python**. This information is usually only interesting
    if you are doing something like testing with different Python versions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Python Version**: This identifies the version of Python that is running.
    Again, this will often be uninteresting unless you are testing with different
    Python versions. However, it can be a very useful bit of information when looking
    at problems reported by other people, if there is any suspicion that the problem
    may be dependent on the Python version.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Python Path**: The full Python path in effect. This is most often useful
    when the exception type relates to an error importing something. It can also come
    in handy when multiple versions of an add-on package have been installed in different
    places. This, plus an incorrect path specification, can cause an unexpected version
    to be used, which might lead to an error. Having the full Python path in use available
    helps in tracking down what is going on in this type of situation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Server time**: This shows the date, time, and time zone at the server when
    the exception occurred. This can be useful for any views that return time-dependent
    results.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The exception type, exception value, and exception location are the first things
    to look at when presented with a debug page. These three items reveal what went
    wrong, why, and where it happened. Often, that is all you will need to know in
    order to fix the problem. Sometimes though, this basic information alone is not
    enough to understand and fix the error. In such situations, it may be helpful
    to know how the code got to where it ultimately ran into trouble. For that, the
    next part of the debug page is useful.
  prefs: []
  type: TYPE_NORMAL
- en: Traceback
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The traceback portion of the debug page shows how the thread of control got
    to where it encountered the error. At the top, it starts with the outermost level
    of the code that was running to process the request, showing where it called the
    next level down, then where the next call was made, ultimately ending at the bottom
    with the line of code that caused the exception. Thus, it is often the very bottom
    of the traceback (not visible in the screenshot) that is most interesting, though
    at times the path taken by the code to get there is the key to understanding and
    fixing what went wrong.
  prefs: []
  type: TYPE_NORMAL
- en: 'For each call level shown in the traceback, there are three pieces of information
    displayed: first the line of code is identified, then it is shown, and then there
    is a line with a triangle and the text **Local vars**.'
  prefs: []
  type: TYPE_NORMAL
- en: For example, the first bit of information for the top level in the traceback
    on this debug page identifies the line of code as **/usr/lib/python2.5/site-packages/django/core/handlers/base.py
    in get_response**. This shows the file containing the code and the name of the
    function (or method or class) within that file where the code was executing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next is a line with a darker background that shows: **83\. request.path_info)**.
    That looks a little odd. The number on the left is the line number within the
    file, and on the right are the contents of that line. In this case the call statement
    spans multiple lines, and we''re seeing only the last line of the call, which
    is not very informative. All we can tell is that **request.path_info** is being
    passed as the last argument to something. It might be nice to see the other lines
    of code around this line, which would make it clearer what was being called. In
    fact we can do that, just by clicking on the line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Traceback](img/7566_07_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Aha! Now, we can see that something named **resolver.resolve** was being called
    and passed **request.path_info**. Clearly the code at this level is starting with
    the requested path and trying to determine what code should be called to handle
    the current request.
  prefs: []
  type: TYPE_NORMAL
- en: Clicking again anywhere within the displayed code will toggle the display of
    the surrounding code context back to the hidden state, so that only one line is
    displayed. Often, it's not necessary to see the surrounding code in the traceback,
    which is why it is hidden initially. But when it is helpful to see more, it is
    convenient that more context is just a click away.
  prefs: []
  type: TYPE_NORMAL
- en: 'Local variables are contained in the third block of information displayed for
    each level of the traceback. These too are initially hidden, since they can take
    up quite a lot of space and clutter the page if they are displayed, making it
    hard to see at a glance what the flow of control was. Clicking on any **Local
    vars** line expands the block to show the list of local variables at that level
    and the value for each. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Traceback](img/7566_07_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We do not need to fully understand the Django code running here in order to
    guess based on the names and values for the variables shown, that the code is
    trying to look up the view that handles displaying the home page. Clicking again
    on the **Local vars** line toggles the block back to being hidden.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one final very useful feature of the traceback section of the debug
    page. Right next to the **Traceback** heading is a link: **Switch to copy-and-paste
    view**. Clicking that link changes the traceback display into one that can be
    usefully copied and pasted elsewhere. For example on this page, clicking that
    link produces a text box that contains:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this block of information contains both the basic traceback
    plus some other useful information pulled from other sections on the debug page.
    It is far less complete than what is available on the full debug page, but it
    is often enough to get help from others when solving a problem. If you find you
    cannot solve a problem yourself and want to ask others for help, it is this information
    that you want to provide to others, not a screenshot of the debug page.
  prefs: []
  type: TYPE_NORMAL
- en: 'In fact, the cut-and-paste view itself has a button at the bottom: **Share
    this traceback on a public Web site**. If you press that button, the cut-and-paste
    version of the traceback information will be posted to the [dpaste.com](http://dpaste.com)
    site, and you will be taken to that site where you can either record the assigned
    URL for reference or delete the entry.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Clearly this button will only work if your computer is connected to the Internet
    and can reach [dpaste.com](http://dpaste.com). If you try it and don''t have connectivity
    to that site, you''ll get an error reported by your browser that it is unable
    to connect to [dpaste.com](http://dpaste.com). Pressing the back button will return
    you to the debug page. [Chapter 10](ch10.html "Chapter 10. When All Else Fails:
    Getting Outside Help"), *When All Else Fails: Getting Outside Help*, will go into
    more detail on techniques for getting additional help with intractable problems.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When clicked, the **Switch to copy-and-paste view** link is automatically replaced
    by another link: **Switch back to interactive view**. Thus, it is easy to toggle
    between the two forms of the traceback information.'
  prefs: []
  type: TYPE_NORMAL
- en: Request information
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Following the traceback information section on the debug page is detailed request
    information. Often you will not need to look at this section at all, but when
    an error is triggered by some odd characteristic of the request being processed,
    this section can be invaluable. It is split into five subsections, each described
    below.
  prefs: []
  type: TYPE_NORMAL
- en: GET
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This section contains a list of all the keys and their values in the `request.GET`
    dictionary. Alternatively, if the request had no GET data, the string **No GET
    data** is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: POST
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This section contains a list of all the keys and their values in the `request.POST`
    dictionary. Alternatively, if the request had no POST data, the string **No POST
    data** is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: FILES
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This section contains a list of all the keys and their values in the `request.FILES`
    dictionary. Note that the displayed information here is just the file name uploaded,
    not the actual file data (which could be quite large). Alternatively, if no file
    data was uploaded with the request, the string **No FILES data** is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: COOKIES
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This section contains any cookies sent by the browser with the request. For
    example, if the `contrib.sessions` application is listed in `INSTALLED_APPS`,
    you will see the `sessionid` cookie that it uses listed here. Alternatively, if
    the browser did not include any cookies with the request, the string **No cookies
    data** is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: META
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This section contains a list of all the keys and their values in the `request.META`
    dictionary. This dictionary contains all of the HTTP request headers, in addition
    to other variables that have nothing to do with HTTP.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if you look at the contents of this section as reported when you
    are running the development server, you will see it lists all of the environment
    variables that were exported in the environment of the command prompt where the
    development server is running. That is because this dictionary is initially set
    to the value of the Python `os.environ` dictionary, and then additional values
    are added. Thus, there can be a lot of extraneous information listed here, but
    if you ever need to check up on the value of an HTTP header, for example, you
    can find it in here.
  prefs: []
  type: TYPE_NORMAL
- en: Settings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The final part of the debug page is an exhaustive list of the settings in effect
    at the time of the error. This is another section that you may rarely need to
    look at, but when you do it, is very helpful to have it listed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Two items from this section: the installed applications, and the installed
    middleware, are included in the cut-and-paste version of the debug information
    mentioned earlier, since they are often helpful to know when analyzing problems
    posted by others.'
  prefs: []
  type: TYPE_NORMAL
- en: If you glance through this section of the debug page, you may notice that the
    values of some settings are not actually reported, but rather a string of asterisks
    is listed instead. This is a way of hiding information that should not be casually
    exposed to any users who may see a debug page. The hiding technique is applied
    to any setting that has the string `PASSWORD` or `SECRET` in its name.
  prefs: []
  type: TYPE_NORMAL
- en: Note that this hiding technique is applied only to the values as they are reported
    in the settings section of the debug page. It does not imply that it is safe to
    run with `DEBUG` enabled for a production site. It is still possible to retrieve
    sensitive information from a debug page. For example, this would be the case if
    the value of a password setting is stored in a local variable, as will be typical
    when it is being used to set up a connection to the database or mail server. If
    an exception is raised during the connection attempt, the password value can be
    retrieved from the local variable information in the traceback section of the
    page.
  prefs: []
  type: TYPE_NORMAL
- en: We've now finished with the general description of the information available
    on a debug page. Next, we will see how to use the specific information on the
    page we have encountered in order to track down and fix the error in the code.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding and fixing the TypeError
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What went wrong that led to the debug page we''ve encountered here? In this
    case, the basic error information is enough to identify and fix the problem. We
    have a **TypeError** reported, with an exception value of **__init__() takes at
    least 2 non-keyword arguments (1 given)**. Furthermore, the location of the code
    that caused the error is **/dj_projects/marketr/survey/forms.py in QuestionVoteForm,
    line 3**. Looking at that line we see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We have not specified all of the necessary arguments to create a `ModelChoiceField`.
    If you are new to Python, the specifics of the error message may be a bit confusing,
    as that line of code doesn't reference anything named `__init__` nor does it appear
    to pass any non-keyword arguments, yet the message says one was given. The explanation
    for that is that `__init__` is the method called by Python when an object is created,
    and it, like all object instance methods, automatically receives a reference to
    itself as its first positional argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus the one non-keyword argument that has been supplied is `self`. What is
    missing? Checking the documentation, we find that `queryset` is a required argument
    for a `ModelChoiceField`. We omitted it because the correct value is not known
    at the time the field is declared, but only when an instance of the form containing
    the field is created. We cannot just leave it out though, so we need to specify
    something as the `queryset` value when the field is declared. What should it be?
    As it is going to be reset as soon as any instance of the form is created, `None`
    will probably do. So let''s try changing that line to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Does that work? Yes, if we click the browser reload page button we now get
    the survey home page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding and fixing the TypeError](img/7566_07_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Again, if you are new to Python the fact that the fix worked might seem a bit
    confusing. The error message says that at least two non-keyword arguments are
    needed, but we did not add a non-keyword argument with the fix. The message makes
    it sounds like the only correct fix might be to supply the `queryset` value as
    a non-keyword argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Clearly that's not the case, though, since the alternative fix shown above does
    work. The explanation for this is that the message is not referring to how many
    non-keyword arguments are specified by the caller, but rather how many are specified
    in the declaration of the target method (that is the `__init__` method of `ModelChoiceField`
    in this case). The caller is free to pass arguments using keyword syntax, even
    if they are not listed as keyword arguments in the method declaration, and the
    Python interpreter will match them up correctly. Thus, the first fix works fine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the home page working again, we can get back to seeing whether
    we are able to create and display our new `QuestionVoteForm`. To do that, click
    on the link to the **Television Trends** survey. The result will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding and fixing the TypeError](img/7566_07_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: While it is nice not to get a debug page, that's not quite what we are looking
    for. There are a few problems here.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, the heading for the list of answers is **Answer**, yet we want that
    to be the question text. The value displayed here is the label assigned to the
    `ModelChoiceField`. The default label for any form field is the name of the field,
    capitalized and with a colon following. We did not override that default when
    we declared the `ModelChoiceField` answer, so we see **Answer** displayed. The
    fix is to manually set the `label` attribute for the field. Like the `queryset`
    attribute, the correct value for a particular form instance is only known when
    the form is created, so we do this by adding this line to the form''s `__init__`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Second, the list of answers includes an empty first choice, shown as a list
    of dashes. This default behavior is helpful for select drop-down boxes to ensure
    that the user is forced to choose a valid value. However, it is unnecessary when
    using a radio input group since with radio inputs, we do not need to have any
    of the radio buttons initially selected when the form is displayed. Thus, we don't
    need the empty choice. We can get rid of it by specifying `empty_label=None` in
    our `ModelChoiceField` declaration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Third, all the choices listed are displayed as **Answer object** instead of
    the actual answer text. By default, the value displayed here is whatever is returned
    by the model instance''s `__unicode__` method. Since we have not yet implemented
    a `__unicode__` method for the `Answer` model, we simply get **Answer object**
    displayed. One fix is to implement a `__unicode__` method in `Answer` that returns
    the `answer` field value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Note that if we wanted the `Answer` model's `__unicode__` method to return something
    else, we could accommodate that also. The way to do that would be to subclass
    `ModelChoiceField` and provide an override for the `label_from_instance` method.
    This is the method called to display the value of the choice in the list, and
    the default implementation uses the textual representation of the instance. So,
    we could take that approach if we needed to display something other than the model's
    default textual representation in the choice list, but for our purposes simply
    having the `Answer` model's `__unicode__` method return the answer text will work
    fine.
  prefs: []
  type: TYPE_NORMAL
- en: Fourth, the answer choices are displayed as an unordered list, and that list
    is being displayed with bullets, which is a bit ugly. There are various ways of
    fixing this—by either adding a CSS style specification or by changing the way
    the choice list is rendered. However, the bullets are not a functional problem
    and getting rid of them doesn't further our task of learning about the Django
    debug page, so for now we will let them be.
  prefs: []
  type: TYPE_NORMAL
- en: 'The fixes previously made to the `QuestionVoteForm`, result in code that now
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'With that form, and the implementation of a `__unicode__` method in the `Answer`
    model, reloading our survey detail page produces a result that looks better:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding and fixing the TypeError](img/7566_07_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We've now got a form that displays reasonably well and are ready to move on
    to the next step in implementing survey voting.
  prefs: []
  type: TYPE_NORMAL
- en: Handling multiple Survey questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have the display of a single question form working, what's left to do? First,
    we need to handle the display of however many questions that are associated with
    a survey, instead of just a single question. Second, we need to handle receiving,
    validating, and processing the results. We'll focus on the first task in this
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the data for multiple questions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before writing the code to handle multiple questions, let''s add another question
    to our test survey so that we''ll be able to see the new code work. The upcoming
    examples will display this additional question:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the data for multiple questions](img/7566_07_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Coding support for multiple questions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, change the view to create a list of `QuestionVoteForms` and pass this
    list in the template context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Here we start with an empty list named `qforms`. Then, we loop through all questions
    in the set associated with the passed `survey` and create a form for each question
    that has more than one answer associated with it. (A `Question` that has fewer
    than two answers is probably a set-up error. Since it's best to avoid presenting
    a general user with a question for which they cannot actually choose an answer,
    we opt here to just leave such questions out of the display for an active `Survey`.)
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we added passing a `prefix` argument on the form creation, and set
    the value to the position of the current question in the full set of questions
    for the survey. This gives each form instance a unique `prefix` value. The `prefix`
    value, if present in a form, is used when `id` and `name` attributes are generated
    for the HTML form elements. Specifying a unique `prefix` is necessary to ensure
    that the generated HTML is valid when there are multiple forms of the same type
    on a page, as there will be for the case we are implementing here.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, each `QuestionVoteForm` created is appended to the `qforms` list, and
    at the end of the function the `qforms` list is passed in the context to be rendered
    in the template.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last step, then, is to change the template to support displaying multiple
    questions instead of just one. To do this, we might change the `active_survey.html`
    template like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The only change from the previous version is to replace `{{ qvf.as_p }}`, which
    displays a single form, with a `{% for %}` block that loops through the list of
    forms in the `qforms` context variable. Each form is displayed in turn, again
    still using the `as_p` convenience method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Debug page #2: TemplateSyntaxError at /1/'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'How well does that work? Not so well. If we attempt to reload the page displaying
    the questions for this survey, we will see:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Debug page #2: TemplateSyntaxError at /1/](img/7566_07_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We've made a mistake, and triggered a slightly different debug page. Instead
    of the basic exception information being followed immediately by the traceback
    section, we see a **Template error** section. This section is included for exceptions
    of type `TemplateSyntaxError`, when `TEMPLATE_DEBUG` is `True`. It displays some
    context from the template that caused the exception, and highlights the line identified
    as causing the error. Usually for a `TemplateSyntaxError`, the problem is found
    in the template itself, not the code that is attempting to render the template
    (which will be what is shown in the traceback section), so it is helpful for the
    debug page to prominently display the template contents.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding and fixing the TemplateSyntaxError
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this case, the line identified as causing the error may be somewhat puzzling.
    The `{% endblock content %}` line hasn't changed since the previous, working,
    version of the template; it is certainly not an invalid block tag. Why is the
    template engine now reporting that it is invalid? The answer is that template
    syntax errors, like many syntax errors reported in programming languages, are
    sometimes misleading when they attempt to point out where the error is. The point
    identified as in error is actually where an error was recognized, when in fact
    the error may have occurred somewhat earlier.
  prefs: []
  type: TYPE_NORMAL
- en: This misleading identification often happens when something required is left
    out. The parser continues on processing the input, but eventually reaches something
    not allowed given the current state. At that point, the place where the missing
    bit should have been may be several lines away. That is what has happened here.
    The `{% endblock content %}` is reported as being invalid because it is not allowed,
    given that the template has a still-open `{% for %}` tag.
  prefs: []
  type: TYPE_NORMAL
- en: 'In making the template changes for supporting multiple questions, we added
    a `{% for %}` tag, but neglected to close it. The Django template language is
    not Python, it does not consider indentation significant. Thus, it does not consider
    the `{% for %}` block terminated by a return to the previous indentation level.
    Rather, we must explicitly close the new `{% for %}` block with an `{% endfor
    %}`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we make that change, we can reload the page and see that we do now have
    multiple questions displayed on the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding and fixing the TemplateSyntaxError](img/7566_07_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: With the display of multiple questions working, we can move on to adding the
    code to process submitted responses.
  prefs: []
  type: TYPE_NORMAL
- en: Recording Survey responses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've already got test data we can use to exercise processing survey responses,
    so we do not need to add any data to our development database for the next step.
    Furthermore, nothing needs to be changed in the template to support submitting
    responses. It already includes a submit button in the HTML form, and specifies
    that the form data should be submitted as an HTTP POST when the form is submitted.
    Right now the **Submit** button will work, in that it can be pressed and no error
    will occur, but the only result will be that the page is re-displayed. This is
    because the view code does not attempt to distinguish between a GET and a POST,
    and just treats all requests as though they were GET requests. Thus, it is the
    view code we need to change to add support for handling POST requests as well
    as GET requests.
  prefs: []
  type: TYPE_NORMAL
- en: Coding support for recording Survey responses
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The view code, then, needs to change to check what method is specified in the
    request. The handling of a GET request should stay the same. If the request is
    a POST, however, then the `QuestionVoteForms` should be constructed using the
    submitted POST data. These can then be validated, and if all of the responses
    are valid (meaning, in this case, that the user selected a choice for each question),
    then the votes can be recorded and an appropriate response sent to the user. If
    there are any validation errors, the constructed forms should be re-displayed
    with error messages. An initial implementation of this is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Here we start by setting the local variable `data` to either the `request.POST`
    dictionary, if the request method is `POST`, or `None`. We will use this during
    form construction, and it must be `None` (not an empty dictionary) in order to
    create unbound forms, which are what we need for the initial display when a user
    gets the page.
  prefs: []
  type: TYPE_NORMAL
- en: We then build the list of `qforms` as before. The only difference here is that
    we pass in the `data` argument so that the created forms will be bound to the
    posted data in the case where the request is a POST. Binding the data to the forms
    allows us to later check if the submitted data is valid.
  prefs: []
  type: TYPE_NORMAL
- en: We then have a new block of code to handle the case where the request is a POST.
    We create an empty list to hold the chosen answers and then loop through the forms
    checking if each is valid. If any are not, we immediately break out of the `for`
    loop. This will have the effect of skipping the `else` clause associated with
    the loop (since that is executed only if the list of items in the `for` loop is
    exhausted). Thus, as soon as an invalid form is encountered, this routine will
    skip down to the `return render_to_response` line, which will result in the page
    being re-displayed with error annotations on the invalid forms.
  prefs: []
  type: TYPE_NORMAL
- en: But wait—we break out of the `for` loop as soon as the first invalid form is
    found. If there is more than one invalid form, don't we want to display errors
    on all forms, not just the first? The answer is yes, we do, but we do not need
    to explicitly call `is_valid` in the view in order to accomplish that. When the
    form is rendered in the template, if it is bound and has not yet been validated,
    `is_valid` will be called before its values are rendered. Thus, errors in any
    of the forms will be displayed in the template, regardless of whether `is_valid`
    is explicitly called by the view code.
  prefs: []
  type: TYPE_NORMAL
- en: If all the forms are valid, the `for` loop will exhaust its list, and the `else`
    clause on the `for` loop will run. Here we want to record the votes and return
    an appropriate response to the user. We've done the first, by incrementing the
    vote count for each chosen answer instance. For the second, though, we've implemented
    a development version that builds a response indicating what the current vote
    values are for all of the questions. This is not what we want general users to
    see, but we can use it as a quick verification that the answer recording code
    is doing what we expect.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we now choose **Drama** and **Hardly any: I already watch too much TV!**
    as answers and submit the form, we see:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Coding support for recording Survey responses](img/7566_07_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'That looks good: there''s no debug page and the vote values are correct for
    what was chosen, so the vote recording code is working. We can now replace the
    development version of the generated response with one appropriate for general
    users.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Best practice in responding to a successful POST request is to redirect to
    some other page, so that a user pressing the browser''s reload button does not
    result in the posted data being re-submitted and re-processed. To do this, we
    can change the else block to be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Note the imports have been included here only to show what needs to be imported;
    ordinarily these would be placed at the top of the file rather than nested deep
    within a function like this. Instead of building a response noting all of the
    new answer vote values, this code now sends an HTTP redirect. As always, to avoid
    hard-coding URL configuration anywhere outside of the actual `urls.py` files,
    we have used reverse here to generate the URL path corresponding to a new named
    URL pattern, `survey_thanks`. We pass along the survey's primary key value as
    an argument so that the page generated in response can be tailored to reflect
    the survey that was submitted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before that `reverse` call can work, we need to add a new pattern named `survey_thanks`
    to our `survey/urls.py` file. We might add it like so, so that the full `urlpatterns`
    in `survey/urls.py` is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The added `survey_thanks` pattern is much like the `survey_detail` pattern,
    except the associated URL path has the string `thanks` before the segment containing
    the survey's primary key value.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, we will need to add a `survey_thanks` view function to `survey/views.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This view looks up the specified survey using `get_object_or_404`. If a matching
    survey does not exist, then an `Http404` error will be raised and a page not found
    response will be returned. If the survey is found, then a new template, `survey/thanks.html`
    will be used to render a response. The survey is passed in the context to the
    template allowing a tailored response reflecting the survey that was submitted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Debug page #3: NoReverseMatch at /1/'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before writing the new template, let''s check to see if redirect works, as
    all it needs is the changes to `survey/urls.py` and the view implementation. What
    happens if we submit a response with the new redirect code in `views.py`? Not
    what we might have hoped:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Debug page #3: NoReverseMatch at /1/](img/7566_07_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '`NoReverseMatch` exceptions can be among the most frustrating ones to debug.
    Unlike when forward matching fails, the debug page does not provide a list of
    patterns tried and the order in which matching was attempted. This may sometimes
    lead us to think the proper pattern wasn''t even considered. Rest assured, it
    was. The problem is not that the appropriate pattern wasn''t considered, it was
    that it didn''t match.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding and fixing the NoReverseMatch exception
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'How do you figure out why a pattern expected to match is not matching? Guessing
    what might be wrong and making changes based on those guesses has a chance of
    working, but is also likely to make things worse. A better approach is to be methodical
    and check things one by one, which usually leads to discovery of the source of
    the problem. The following is a sequence of things to check. We''ll go through
    this sequence and consider how it applies to our pattern where `reverse` is unexpectedly
    failing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: First, verify that the name identified in the exception matches the name in
    the URL pattern specification. In this case, the exception cites `survey_thanks`,
    and the URL pattern we expect to match has `name='survey_thanks'` specified, so
    those match.
  prefs: []
  type: TYPE_NORMAL
- en: Note that if the URL pattern omits the `name` argument, and the `patterns` call
    it is an argument to specifies a view `prefix`, then the caller of `reverse` must
    also include the view `prefix` when specifying the name to reverse. In this case,
    for example, if we did not specify a name for the `survey_thanks` view, then a
    successful `reverse` call would need to specify `survey.views.survey_thanks` as
    the name to reverse, since `survey.views` is specified as the `patterns prefix`
    in `survey/urls.py`.
  prefs: []
  type: TYPE_NORMAL
- en: Second, make sure that the number of arguments listed in the exception message
    matches the number of regular expression groups in the URL pattern. In this case,
    there is one argument listed by the exception, `1L`, and one regular expression
    group, `(?P<pk>\d+/)`, so the numbers match.
  prefs: []
  type: TYPE_NORMAL
- en: Third, if the exception shows keyword arguments were specified, verify that
    the regular expression groups are named. Further, verify that the names of the
    groups match the names of the keyword arguments. In this case, keyword arguments
    were not specified on the `reverse` call, so there is nothing to check for this
    step.
  prefs: []
  type: TYPE_NORMAL
- en: Note that it is not necessary to ensure non-named groups are used in the URL
    pattern when positional arguments are shown in the exception, because it is possible
    for positional arguments to be matched to named groups in a URL pattern. Thus,
    there is no problem when, as in our case, the URL pattern uses named groups while
    the `reverse` caller specifies positional arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Fourth, for each argument, verify that the string representation of the actual
    argument value listed in the exception matches the associated regular expression
    group from the URL pattern. Note that the values shown in the exception are the
    results of calling `repr` on the arguments, thus they may not exactly match the
    string representation of the argument. Here, for example, the exception reports
    the argument value as `1L`, signifying a Python long integer value (the value
    is a long integer because that is what MySQL, the database in use for this example,
    always returns for integer values). The `L` suffix is used to make the type in
    the `repr` clear, but it does not appear in the string representation of the value,
    which is simply `1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus for our example, the string representation of the argument shown in the
    exception message is `1`. Does that match the associated regular expression group
    in the URL pattern? Recall that the group is `(?P<pk>\d+/)`. The enclosing parentheses
    identify the fact that it is a group. The `?P<pk>` assigns the group the name
    `pk`. The remainder, `\d+/`, is then the regular expression we are trying to match
    with `1`. These don''t match. The regular expression is specifying one of more
    digits followed by a slash, yet the actual value we have is a single numeric digit,
    without a trailing slash. We made a typo here and included the slash inside the
    group instead of following it. The correct specification for our new `survey_thanks`
    view is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: It is very easy for typos like this to creep into URL pattern specifications,
    as the pattern specifications tend to be long and full of punctuation characters
    with special meaning. Breaking them down into component pieces and verifying that
    each piece is correct will save you a great deal of hassle. If, however, that
    does not work, and you get to a point where all of the bits look right but still
    you get a `NoReverseMatch` exception, it might be time to tackle the problem from
    the other direction.
  prefs: []
  type: TYPE_NORMAL
- en: Start with the simplest part of the overall pattern, and verify that `reverse`
    for that works. You might, for example, get rid of all arguments from the reverse
    call and all groups from the URL pattern specification, and verify that you can
    `reverse` the URL by name. Then add back one argument and its associated pattern
    group in the URL specification, and verify if that works. Continue until you hit
    an error. Then change back to trying the simplest version in addition to just
    the argument that caused the error. If that works, then there is some problem
    with combining that argument with the others in the overall pattern, which is
    a clue, so you can start investigating what might cause that.
  prefs: []
  type: TYPE_NORMAL
- en: This approach is a general debugging technique that can be applied whenever
    you encounter a mysterious problem in a complicated set of code. First, back off
    to something very simple that works. Then add things back, one by one, until things
    fail again. You've now identified one piece that is involved in the failure, and
    you can start investigating whether it is that piece alone that is a problem or
    if it works in isolation but only causes a problem when combined with other pieces.
  prefs: []
  type: TYPE_NORMAL
- en: 'Debug page #4: TemplateDoesNotExist at /thanks/1/'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For now, let''s return to our example. Now that we have fixed the `reverse`
    problem, does the redirect to our survey thanks page work? Not quite. If we again
    attempt to submit our survey results, we see:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Debug page #4: TemplateDoesNotExist at /thanks/1/](img/7566_07_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This one is self-explanatory; in tracking down the `NoReverseMatch` error we
    forgot we still had not gotten around to writing the template for the new view.
    The fix will be easy, but there is something to note about this debug page first:
    the section titled **Template-loader postmortem**. This is another optional section,
    like the **Template error** section included with `TemplateSyntaxError` debug
    pages, that provides additional information helpful for determining the exact
    cause of the error.'
  prefs: []
  type: TYPE_NORMAL
- en: The **Template-loader postmortem** section, specifically, lists all of the template
    loaders that were tried in attempting to locate the template. For each loader,
    it then lists the full file names searched for by that loader, and the outcome.
  prefs: []
  type: TYPE_NORMAL
- en: On this page we can see that the `filesystem` template loader was called first.
    But no files are listed as tried by that loader. The `filesystem` loader is included
    in our `settings.py` file, since it is the first listed in `TEMPLATE_LOADERS`
    in the `settings.py` file generated by `django-admin.py startproject`, and we
    have not changed that setting. It looks in all the directories specified in the
    settings `TEMPLATE_DIRS` value. However, `TEMPLATE_DIRS` is empty by default,
    and we have not changed that setting either, so the `filesystem` loader had no
    place to look in order to try and find `survey/thanks.html`.
  prefs: []
  type: TYPE_NORMAL
- en: The second loader tried was the `app_directories` loader. This is the one we
    have been relying on so far to load the templates for our survey application.
    It loads templates from a `templates` directory under each application directory.
    The debug page shows that it attempted to find the `survey/thanks.html` file first
    under the `admin` application's `templates` directory and then under the `survey`
    application's `templates` directory. The result of searching for the specified
    file is placed in parentheses after the file name; in both cases here we see **File
    does not exist**, which is no surprise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes this message will state **File exists**, which can be a little confusing.
    If the file exists, and the loader could see it exists, why didn''t the loader
    load it? This often occurs when running under a web server such as Apache, and
    the problem is that the web server process does not have the necessary permissions
    to read the file. The fix in that case is to make the file readable by the web
    server process. Dealing with production-time issues such as this will be discussed
    in more detail in [Chapter 11](ch11.html "Chapter 11. When it''s Time to Go Live:
    Moving to Production"), *When it''s Time to Go Live: Moving to Production*.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding and fixing TemplateDoesNotExist
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The fix in our case is simple, and we do not really even need to look closely
    at the error message to know what needs to be done, but note that this section
    gives everything needed in order to track down `TemplateDoesNotExist` errors.
    You will know what loader you are relying on to load the template. If that loader
    is not shown in the **Template-loader postmortem**, then the problem is likely
    an incorrect `TEMPLATE_LOADERS` setting in `settings.py`.
  prefs: []
  type: TYPE_NORMAL
- en: If the loader is listed, but does not list attempting to load the expected file,
    then the next step is to figure out why. This step is loader-dependent, since
    each loader has its own rules for where to look for template files. The `app_directories`
    loader, for example, looks under a `templates` directory for each application
    listed in `INSTALLED_APPS`. Thus ensuring the application is in `INSTALLED_APPS`
    and has a `templates` directory would be two things to check when it is the `app_directories`
    loader that isn't searching for the file as expected.
  prefs: []
  type: TYPE_NORMAL
- en: If the loader is listed and the expected file is listed as attempted, then the
    problem is hinted at by whatever is listed as the status for the file by the loader.
    **File does not exist** is a clear status with an easy fix. If **File does not
    exist** appears unexpectedly, double and triple check the filename. Cutting-and-pasting
    from the debug page into a command prompt and attempting to display the file may
    be useful here, as it may help clarify what is different about the name of the
    file the loader is trying to load compared to the name of the file that actually
    exists. Other status messages, such as **File exists**, may not be as direct but
    still hint at the nature of the problem and point towards a direction to look
    in order to fix the problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our example case, the fix is simple: create the `survey/thanks.html` template
    file we forgot to create earlier. This template returns a basic page with a message
    thanking the user for participating in the survey:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'With this template in place under the `survey/templates` directory, we are
    now able to submit a survey without error. Instead we see:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding and fixing TemplateDoesNotExist](img/7566_07_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Good! Are we now done with displaying a survey and processing results? Not quite.
    We have not yet tested to see what happens if an invalid survey response is submitted.
    We will try that next.
  prefs: []
  type: TYPE_NORMAL
- en: Handling invalid Survey submissions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've already coded the view that handles survey submission to re-display the
    page with errors instead of processing the results, if any errors are found in
    the submitted forms. On the display side, since we are using the `as_p` convenience
    method for displaying the form, it will take care of displaying any errors in
    the forms. So, we should have no code or template changes to make in order to
    see what happens when an invalid survey is submitted.
  prefs: []
  type: TYPE_NORMAL
- en: 'What would make a survey submission invalid? The only likely error case for
    our `QuestionVoteForm` is if no answer is chosen. What happens, then, if we attempt
    to submit a survey with missing answers? If we try it, we see that the result
    is not ideal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Handling invalid Survey submissions](img/7566_07_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There are at least two problems here. First, the placement of the error messages,
    above the survey questions, is confusing. It is hard to know what the first error
    message on the page is referring to, and the second error looks like it is associated
    with the first question. It would be better to move the error messages closer
    to where the selection is actually made, such as between the question and answer
    choice list.
  prefs: []
  type: TYPE_NORMAL
- en: Second, the text of the error message is not very good for this particular form.
    Technically the list of answer choices is a single form field, but to a general
    user the word **field** in reference to a list of choices sounds odd. We will
    correct both of these errors next.
  prefs: []
  type: TYPE_NORMAL
- en: Coding custom error message and placement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Changing the error message is easy, since Django provides a hook for this.
    To override the value of the error message issued when a required field is not
    supplied, we can specify the message we would like as the value for the `required`
    key in an `error_messages` dictionary we pass as an argument in the field declaration.
    Thus, this new definition for the `answer` field in `QuestionVoteForm` will change
    the error message to `Please select an answer below`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Changing the placement of the error message requires changing the template.
    Instead of using the `as_p` convenience method, we will try displaying the label
    for the answer field, errors for the answer field, and then the answer field itself,
    which displays the choices. The `{% for %}` block that displays the survey forms
    in the `survey/active_survey.html` template then becomes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'How does that work? Better than before. If we try submitting invalid forms
    now, we see:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Coding custom error message and placement](img/7566_07_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: While the error message itself is improved, and the placement is better, the
    exact form of the display is not ideal. By default, the errors are shown as an
    HTML unordered list. We could use CSS styling to remove the bullet that is appearing
    (as we will eventually do for the list of choices), but Django also provides an
    easy way to implement custom error display, so we could try that instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'To override the error message display, we can specify an alternate `error_class`
    attribute for `QuestionVoteForm`, and in that class, implement a `__unicode__`
    method that returns the error messages with our desired formatting. An initial
    implementation of this change to `QuestionVoteForm` and the new class might be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The only change to `QuestionVoteForm` is the addition of setting its `error_class`
    attribute to `PlainErrorList` in its `__init__` method. The `PlainErrorList` class
    is based on the `django.form.util.ErrorList` class and simply overrides the `__unicode__`
    method to return the errors as a string with no special HTML formatting. The implementation
    here makes use of the fact that the base `ErrorList` class inherits from `list`,
    so iterating over the instance itself returns the individual errors in turn. These
    are then joined together with spaces in between, and the whole string is returned.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we're only expecting there to ever be one error here, but just in
    case we are wrong in that assumption, it is safest to code for multiple errors
    existing. Although our assumption may never be wrong in this case, it's possible
    we might decide to re-use this custom error class in other situations where the
    single possible error expectation doesn't hold. If we code to our assumption and
    simply return the first error in the list, this may result in confusing error
    displays in some situations where there are multiple errors, since we will have
    prevented reporting all but the first error. If and when we get to that point,
    we may also find that formatting a list of errors with just spaces intervening
    is not a good presentation, but we can deal with that later. First, we'd like
    to simply verify that our customization of the error list display is used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Debug page #5: Another TemplateSyntaxError'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'What happens if we try submitting an invalid survey now that we have our custom
    error class specified? An attempt to submit an invalid survey now returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Debug page #5: Another TemplateSyntaxError](img/7566_07_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Oops, we have made another error. The exception value displayed on the second
    line makes it pretty clear that we've mistyped `self` as `sefl`, and since the
    code changes we just made only affected five lines in total, we don't have far
    to look in order to find the typo. But let's take a closer look at this page,
    since it looks a little different than the other `TemplateSyntaxError` we encountered.
  prefs: []
  type: TYPE_NORMAL
- en: 'What is different about this page compared to the other `TemplateSyntaxError`?
    Actually, there is nothing structurally different; it contains all the same sections
    with the same contents. The notable difference is that the exception value is
    not a single line, but is rather a multi-line message containing an **Original
    Traceback**. What is that? If we take a look at the traceback section of the debug
    page, we see it is rather long, repetitive, and uninformative. The end portion,
    which is usually the most interesting part of a traceback, is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Debug page #5: Another TemplateSyntaxError](img/7566_07_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Every line of code cited in that traceback is Django code, not our application
    code. Yet, we can be pretty sure the problem here was not caused by the Django
    template processing code, but rather by the change we just made to `QuestionVoteForm`.
    What's going on?
  prefs: []
  type: TYPE_NORMAL
- en: What has happened here is that an exception was raised during the rendering
    of a template. Exceptions during rendering are caught and turned into `TemplateSyntaxErrors`.
    The bulk of the stack trace for the exception will likely not be interesting or
    helpful in terms of solving the problem. What will be more informative is the
    stack trace from the original exception, before it was caught and turned into
    a `TemplateSyntaxError`. This stack trace is made available as the **Original
    Traceback** portion of the exception value for the `TemplateSyntaxError` which
    is ultimately raised.
  prefs: []
  type: TYPE_NORMAL
- en: A nice aspect of this behavior is that the significant part of what is likely
    a very long traceback is highlighted at the top of the debug page. An unfortunate
    aspect is that the significant part of the traceback is no longer available in
    the traceback section itself, thus the special features of the traceback section
    of the debug page are not available for it. It is not possible to expand the context
    around the lines identified in the original traceback, nor to see the local variables
    at each level of the original traceback. These limitations will not cause any
    difficulty in solving this particular problem, but can be annoying for more obscure
    errors.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that Python 2.6 introduced a change to the base `Exception` class that
    causes the **Original Traceback** information mentioned here to be omitted in
    the display of the `TemplateSyntaxError` exception value. Thus, if you are using
    Python 2.6 and Django 1.1.1, you will not see the **Original Traceback** included
    on the debug page. This will likely be corrected in newer versions of Django,
    since losing the information in the **Original Traceback** makes it quite hard
    to debug the error. The fix for this problem may also address some of the annoyances
    previously noted, related to `TemplateSyntaxErrors` wrapping other exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: Fixing the second TemplateSyntaxError
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Fixing this second `TemplateSyntaxError` is straightforward: simply correct
    the `sefl` typo on the line noted in the original traceback. When we do that and
    again try to submit an invalid survey, we see in response:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Fixing the second TemplateSyntaxError](img/7566_07_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: That is not a debug page, so that is good. Furthermore, the error messages are
    no longer appearing as HTML unordered lists, which was our goal for this change,
    so that is good. Their exact placement may not quite be exactly what we want,
    and we may want to add some CSS styling so that they stand out more prominently,
    but for now they will do.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have now completed the implementation of survey voting, and the in-depth
    coverage of Django debug pages. In this chapter, we:'
  prefs: []
  type: TYPE_NORMAL
- en: Set out to replace the placeholder view and template for display of an active
    Survey with a real implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Made some typical mistakes during implementation, which led to us being presented
    with five different Django debug pages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On encountering the first debug page, learned about all of the different sections
    of debug pages and what information is included in each
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For each debug page encountered, used the information presented to locate and
    correct the coding error
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next chapter, we will proceed to learn techniques for gathering debug
    information even when the code is not causing a debug page to be displayed.
  prefs: []
  type: TYPE_NORMAL
