- en: Chapter 8. Demonstrating Functional Reactive Programming in JavaScript – A Live
    Example, Part I
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 4](ch04.html "Chapter 4. Demonstrating Nonfunctional Reactive Programming
    – A Live Example"), *Demonstrating Nonfunctional Reactive Programming—A Live Example*,
    we used ReactJS to migrate from the legacy code that has its own structure and
    was written without using ReactJS. In the last chapter, [Chapter 7](ch07.html
    "Chapter 7. Not Reinventing the Wheel – Tools for Functional Reactive Programming"),
    *Not Reinventing the Wheel – Tools for Functional Reactive Programming*, we studied
    a few out of a great many tools that we might use when working with ReactJS. In
    this chapter, we will be covering a sort of central road of what to expect in
    mainstream development with ReactJS. One may add quite a lot of options to the
    basics, but the intent is to give a foundational example of how you can build
    a project with ReactJS.
  prefs: []
  type: TYPE_NORMAL
- en: We've spoken a bit about functional reactive programming. Now we will see it
    live in action with ReactJS. We've also talked about how, conceptually, we have
    a complete teardown and rebuild of the user interface. So you, as a developer,
    have ![Demonstrating Functional Reactive Programming in JavaScript – A Live Example,
    Part I](img/B04108_08_03.jpg) states to manage instead of ![Demonstrating Functional
    Reactive Programming in JavaScript – A Live Example, Part I](img/B04108_08_02.jpg)
    state transitions. Here, we will build a `render()` method that will let you build
    just this, and you can call it whenever you want.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we have the first installment of a partly stubbed green field
    project built for ReactJS, this time working with the very sweet syntactic sugar
    in JSX. The two areas of this book, meaning the earlier one-chapter project and
    this multichapter project, are meant to be complementary. The project in this
    chapter stands alone, but is meant to be expanded.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: An overview of the project and its inspiration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The skeleton of the project, and the basics of the preferred approach in ReactJS.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Starting a first component in ReactJS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a `render()` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Triggering display when you want to render or update the display
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What we will be attempting in this chapter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The example in the next three chapters is intended to represent a slightly
    larger green field project. What we will be working on is a system that you should
    be able to see by visiting [http://demo.pragmatometer.com](http://demo.pragmatometer.com).
    The term "Pragmatometer" is taken from the most dystopian of C. S. Lewis''s novels,
    *That Hideous Strength*, in which the ominous National Institute for Coordinated
    Experiments builds a transcendent or nearly transcendent computer such as one
    might have loosely imagined ENIAC when the novel was published (1945; by comparison,
    ENIAC was created in 1946). Alternatively, you might imagine a steampunk novel''s
    analytical engine doing with a seemingly transcendent deck of punch cards. When
    the discussion turns to the computers, it says:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"I agree with James," said Curry, who had been waiting somewhat impatiently
    to speak. "The N.I.C.E. marks the beginning of a new era—the really scientific
    era. Up to now, everything has been haphazard. This is going to put science itself
    on a scientific basis. There are to be forty interlocking commitees sitting every
    day and they''ve got a wonderful gadget—I was shown the model last time I was
    in town—by which the findings of each committee print themselves off in their
    own little compartment on the Analytical Notice-Board every half hour. Then, that
    report slides itself into the right position where it''s connected up by little
    arrows with all the relevant parts of the other reports. A glance at the Board
    shows you the policy of the whole Institute actually taking shape under your own
    eyes. There''ll be a staff of at least twenty experts in the top of the building
    working this Notice-Board in a room rather like the Tube control rooms. It''s
    a marvellous gadget. The different kinds of business all come out in the Board
    in different coloured lights. It must have cost half a million. They call it a
    Pragmatometer."*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: I am not putting too fine a point on it, but C.S. Lewis apparently predicted
    the Twitter that would not be built until decades after his death.
  prefs: []
  type: TYPE_NORMAL
- en: 'That point aside, we will be making a dashboard that features a simple 2 x
    2 grid of quadrants (the exact size and details are subject to hacking and tinkering),
    each one of which is a pigeonhole that can hold different functions. In terms
    of responsive design, we will correct to a 1 xn line of cells, one above the other.
    The features, as they are arranged on the page, are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Calendar | To-do list |'
  prefs: []
  type: TYPE_TB
- en: '| Scratchpad | Room to grow |'
  prefs: []
  type: TYPE_TB
- en: The **Calendar** has a somewhat experimental user interface; it shines at showing
    entries, perhaps days out, in a way that degrades gracefully to a sparse input
    (so you don't need to click through multiple months to find out when some XYZ
    appointment down the road is available). It might click with you, or it might
    not, but it is interesting.
  prefs: []
  type: TYPE_NORMAL
- en: The **To-do list** implements a to-do list with some slightly nonstandard bells
    and whistles. Instead of one checkbox for an item (strictly speaking, no checkbox
    is needed), there are ten boxes, representing various states, and color-coded
    with custom styling of the label to the right of the checkboxes so that you can
    tell, for instance, what is important, active, or on the back burner.
  prefs: []
  type: TYPE_NORMAL
- en: The **Scratchpad** is a rich text area that can be used for scratching. It capitalizes
    on CKeditor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the **Room to Grow** is a placeholder for you to stick in your own
    two cents. There is something that comes in by default, and you can see it as
    you explore. But please do visit [https://demo.pragmatometer.com](https://demo.pragmatometer.com),
    and see the default option there (*hint, hint!*). There are many places for hacking
    and tinkering besides what is explicitly advertised, but some possibilities include
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Building an API client for several public websites**: Most of the top 20
    websites expose a RESTful API. Twitter would be the most obvious candidate as
    the most authentic to the name of *Pragmatometer*, but news, video, and social
    networking sites can work if they expose either an API that is friendly to client-side
    JavaScript, or something else.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Building an application**: Build your own application for displaying.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Making a playground**: Build your own Pragmatometer or download the source
    online, and keep three-fourths of the screen for the purposes detailed here. Make
    the remaining one-fourth a playground for tinkering.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Incorporating Google (or other) gadgets that others have made**: You can
    also incorporate gadgets that others have made, such as Google.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Keeping the default application**: You can keep the default application,
    if you want.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Saying "*the implementation is the spec*" has a bad reputation, but a spec,
    written or not, can be complemented neatly by sketching the appearance and behavior.
    Perhaps using low-fidelity prototypes, which may draw helpful criticism more quickly
    than something that looks pretty polished but will create an undesired social
    nuance of people being less free in criticisms that have an implicit emotional
    payload of "Will I be hurting others' feelings by criticizing something that looks
    as if someone put a lot of work into it?" And this attitude is not a bad thing.
    In terms of the concern that undergirds politeness, it is naïve to tell people,
    "be as brutal as it takes to speak your mind," and actually expect other people
    to take this completely at face value (or perhaps, you don't like receiving criticism
    any more than anyone else, but you recognize its value in the whole of the software
    development process). You may mean it without any mixed messages, but most of
    us have seen it meant with many mixed messages. And even if you are the sort of
    production who almost salivates at the prospect of some really helpful criticism,
    it does not help matters—or does not help much—to tell people to stop acting like
    polite human beings when you show them something you've created. But here, having
    seen a UI, played with it, and thought how you can duplicate things can be a very
    invigorating way to understand what is intended much more precisely than a legal-contract
    spec.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this interface, there is one account, and the priority is for cross-synchronization
    of updates. Let''s begin assembling some of the basic skeleton. Building everything
    within a single, large, and immediately invoked function expression, we have the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Here, we define a `container` class for the entire project. The `Calendar`,
    `Todo`, `Scratch`, and `YouPick` classes represent applications in the larger
    page; some of them could have various layers of subcomponents as well.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The JSX optional syntactic sugar is meant to be readable to people who can read
    HTML, but contains a greater invitation to contribute your own components than
    HTML or really even XHTML (and possibly even XML). In XML development, you can
    define whatever DTD you want, but the usual rank-and-file XML author won't define
    new tags, possibly even after having done a lot of work with XML (this is something
    like programmers who can use functions or objects but not add either functions
    or objects to a namespace). In JSX, it is routine for authors who write any appreciable
    amount of JSX, by nature, to contribute tags that are reusable.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding code sample has `<div className=`, where the desired HTML is `<div
    class=`. Because JSX compiles JavaScript and is meant to be a syntactic sugar
    only, rather than an independent language in its depths, the decision was made
    to avoid `class` and `for` in the rendered JavaScript. Use `className` to cover
    CSS class names and `htmlFor`. HTML ID attributes may optionally be specified;
    JSX gets along with the HTML IDs it puts in and the HTML IDs that you specify,
    along with some pixie dust. If you need to enter the UTF8 literals outside of
    ASCII, don't give the ASCII encoding of the symbol (`—`); instead, paste the literal
    inside your editor (`—`).
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, there is an XSS protection escape hatch available. The optimal
    intended approach for using the language seems to be to solve the problem so that
    you will mark up what should genuinely be marked up and include an XSS-protected
    display of the user data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternately, if you are willing to trust a third-party library, such as `Showdown`
    ([https://github.com/showdownjs/showdown](https://github.com/showdownjs/showdown)),
    to render HTML without including XSS''s vulnerabilities, you can create a `Showdown`
    converter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that this code is a self-contained example and not part of the main project
    that we have begun in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: This will render as a `DIV` variable containing `<em>Hello</em>, world!`.
  prefs: []
  type: TYPE_NORMAL
- en: This escape hatch, which may or may not serve as a rarely used escape hatch,
    is central enough to be explicitly covered in the documentation. One gets the
    feeling that the mainstream use of JSX, with XSS protection that escapes HTML
    (so that `<em>a</em>` renders in a web page not as `a` but as an `<em>a</em>`
    function displayed in the browser window), has benefits similar to unit testing.
    This is a point worth pausing on for a moment.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing has come somewhat further down to earth; its early center of gravity
    was around what was easiest to unit test—mathematical functions that would return
    an appropriate value if given an appropriate input value. So, we would illustrate
    unit testing with problems implicitly optimized to play to the strengths and needs
    of unit testing, and show a red, green, refactor XP approach to appropriately
    solve a problem such as converting integers to and from Roman numerals (good luck
    if you wanted to test code that deals with a database or user interface). Unit
    testing caught perhaps 30 percent of the total errors, and as a rule, it tended
    to catch the least significant errors, with the least coverage of the bugs that
    were the most difficult to resolve. Now there is a more robust set of features,
    with it being entirely possible and straightforward to make test assertions about
    how a user interface behaves given some mouse clicks and other user interface
    behavior. Also, it is less of a matter of software that is written to serve the
    needs of unit testing than unit testing that properly serves the needs of software.
    It is possible that unit testing hit prime time when it was not yet ready for
    prime time, like responsive design, about which some have said, "I've seen responsive
    design mainly on websites advocating for responsive design." This was true when
    unit testing and responsive design became buzzwords; but since then, they have
    matured, and responsive design is pretty close to being the only game in town.
    Perhaps the largest websites, such as Google, can afford to customize a solution
    for every mobile, tablet, desktop, and watch environment. But for most customers,
    responsive design has fairly effectively displaced its other competitors. It is
    now relatively uncommon for websites to have some URLs for a desktop version and
    a mobile version and perform browser direction and redirection to separate sites,
    which was once fairly mainstream. These approaches have matured since they first
    entered the limelight.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of early unit testing, when you couldn''t really test integration
    or user interface behavior, there was one cardinal payoff to writing code for
    unit testing: code written to be unit testable is usually better code. The same
    principle may speak about writing as much as possible to cut with Facebook''s
    grain, not against it, in using ReactJS.'
  prefs: []
  type: TYPE_NORMAL
- en: Right now, there is no particular premature hype about writing code in an approach
    oriented to play well with the XSS protection surrounding JSX and not, as per
    the deliberately chosen name, dangerously set `innerHTML`, which has been labeled
    an escape hatch. Facebook could, if they wanted, try to go the "tough love" route
    and advise people to structure and organize projects in a way that would fit in
    naturally with XSS protection and JSX. But perhaps they are taking a humbler approach,
    both making it clear how to bypass the XSS protection, and presenting this escape
    hatch as perhaps something to avoid wherever possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'The wisdom would appear to be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: As far as practicable, structure your applications to work appropriately with
    the main anti-XSS approach adopted in ReactJS.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want to do something that requires rendering, for example, HTML tags
    in `innerHTML`, confine it to as small a space as you can and treat it like the
    monads in Haskell used for the IO, necessary and perhaps nonnegotiable, but quarantined
    to as small a space as is practicable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you need to render tags, consider using HTML generated by a tool such as
    `Showdown` for Markdown, which is not necessarily perfect and foolproof but offers
    less surface area for HTML code that contains tags that have been vetted and lessen
    the surface area for bugs in HTML code (possibly, this is a use case for an HTML
    tag cleaner or an HTML-to-markdown converter that stores markdown and renders
    HTML).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Only if you cannot work the default way with XSS protection and can't tag, clean,
    or work from markup, or anything else, should you store and dangerously set `innerHTML`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's move on to the `YouPick` tag included in the Pragmatometer definition.
  prefs: []
  type: TYPE_NORMAL
- en: This project's first complete component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can see what this component implements at [https://CJSHayward.com/missing.html](https://CJSHayward.com/missing.html).
    For our first component, we pick a mostly skeletal implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This skeleton returns empty, "falsy" values, which we will override. What we
    want to do is take two strings, break them down into one-character substrings
    (excluding tags), then display more and more of the first string, and then repeat
    the second string. It makes for a very old joke displayed for the user.
  prefs: []
  type: TYPE_NORMAL
- en: There is a division of labor between properties, meant to be set once and never
    changed and state, meant to allow changing. Note that state, being mutable, should
    be treated privately, so as to avoid the shared mutable state that Facebook declared
    war on. Technically, properties can be changed, but notwithstanding this, properties
    that should be set at the beginning (possibly passed down by a parent component)
    and then frozen. The state is something that can change, although the general
    pattern in relation to Flux is to avoid the shared mutable state. In general,
    this means that stores have getters but not setters; they might receive actions
    from dispatchers, but they are not at the mercy of anyone who has reference to
    the core object.
  prefs: []
  type: TYPE_NORMAL
- en: For this object, the strings are obvious candidates for the default props. Note,
    however, that the timestamp that a component began is not appropriate for the
    props, because `getDefaultProps()` will be evaluated before any instances are
    created, thus enabling a borg variation on the singleton pattern, where there
    are any number of components of this type. Potentially, there are more of them
    added over time, but all of them share a starting timestamp before any of them
    were instantiated.
  prefs: []
  type: TYPE_NORMAL
- en: 'So let''s flesh out the `getDefaultState` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Perhaps the first change to this is to convert the text from HTML to Markdown.
    This is not strictly necessary; this is text that we have written ourselves, and
    we may have more confidence in text that we''ve written—confidence that it will
    not trigger XSS vulnerabilities—than text generated from our Markdown. In the
    world of computer security, a great deal of trouble can be presented by giving
    as little privilege out, stingily, as will let people or things get their work
    done: hence the saying, "Stinginess with privilege is kindness in disguise". Facebook
    has made not so much a stellar decision that shows uniquely good judgment as avoiding
    handing its users a live grenade. It is very, very easy to allow vulnerabilities
    that will run hundreds of megs of hostile JavaScript, with security certification
    assuring the user that this hostile JavaScript is genuinely from your site. For
    more information, please see [http://tinyurl.com/reactjs-xss-protection](http://tinyurl.com/reactjs-xss-protection).
    In this case, only `initial_text`, and not `repeated_text`, needs to be changed,
    as `repeated_text` contains only letters and spaces; thus, it works the same as
    plain text, HTML, or Markdown. Our revised `initial_text` reads like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Before continuing further, let''s create stubs for the other three main components,
    which we will expand later on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We will set the state as the timestamp for this object's creation. At one glance,
    this might seem like something that belongs to properties, and in spirit, it is.
    But we want each component instance to keep its own creation date, and therefore
    start at zero from when it was created. If we or someone else reuse our work and
    create more than one instance of this on a page, each keeping its appropriate
    time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, we change the `getInitialState` method of `YouPick` to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The render() method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Next, we implement the render method. What we do is take the properties, which
    should never be directly mutated and probably should not have any existing value
    changed, and get the two strings from them. We will, token by token, display everything
    in the first string, and repeat the second as many times as the component is displayed.
    We will also create a tokenize function for rendered HTML converted from `Showdown`—this
    breaks its argument to each next tag or the next character—and, in a moment, see
    why we are creating a verbose anonymous function instead of a regular expression
    (in a nutshell, writing readable code in lieu of a regular expression appears
    verbose compared to the terseness available in writing write-only code).
  prefs: []
  type: TYPE_NORMAL
- en: 'The render method consists of more than half the lines of code as we already
    have it. Let''s go through it step by step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: One of the points of breakage in JavaScript surrounds `this`. Among the horror
    stories that many readers may be familiar with is that if you create a constructor
    (the convention is to give a warning label by capitalizing the first letters of
    constructors and non-constructor functions, thus providing a way to cause serious
    misunderstanding by not holding down the *Shift* key) that adds methods and fields
    to an object and you have `x = Foo();` when you actually meant `x = new Foo();`,
    then the `Foo` constructor will trample the global namespace and add or clobber
    variables in it. Douglas Crockford, after originally including the "bad implementation
    of Java" pseudoclassical inheritance in *The Good Parts*, had second thoughts
    and eliminated it from *The Better Parts*, after he made an Adsafe program that
    could maintain security only if the `this` were removed from use. Then he started
    to try out the medicine he was foisting on others, and suddenly found a bunch
    of things he liked when he stopped using this. We can't drop the this and still
    use technologies like ReactJS, but we do have a say about whether we choose to
    drag in this when we don't need to. But ReactJS uses it, and it might be good
    practice to use pseudo-classical approaches based on `this` as much as needed
    to talk with ReactJS, but not (much) more.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we have the patterned hack to deal with `this` not always being available
    for our first line we have:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The `tokenize()` function is a function that breaks HTML mostly into characters
    but keeps tags together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We introduce helper variables to mitigate multiline expressions. The two variables
    following could as well be refactored out, but multiline expressions without them
    are the sort of thing that programmers glance at and then skip down, saying, "I''ll
    read it if I have to." This is a bad thing. These variables hold the original
    (Markdown) strings converted to HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The HTML generated by `Showdown` has proper paragraph formatting. This is a
    good thing, but in this case, it means paragraph tags separating things that should
    belong to the same paragraph. We remove the counterproductive tags in this slightly
    unusual case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We tokenize the HTML generated from our Markdown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This step calculates the number of tokens that are desired at a particular
    point of time, in what has been called continuous time semantics. This means that
    however often or rarely we call the `render()` method, the content will be rendered
    appropriately when it is called, and (apart from choppiness) nothing will change
    if you double the frequency at which the render function is called. The `tokens`
    function is not a list of tokens, but the count of how many tokens should be displayed
    now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We have a workbench as an array to which we keep adding or replacing with more
    tokens to display so as to build up the string that should be displayed. These
    should be one-character or one-tag tokens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'If the number of tokens that should be displayed is at most the number of tokens
    from the initial string, we render that part of the string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'If we need more tokens, we keep looping over the already available tokens from
    the repeated tokens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is roughly how we can render an element containing text that we have calculated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Triggering the actual display for what we have created
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have to manually refresh the display for updates. Because ReactJS is so
    fast, we really can afford to wastefully render the page every millisecond. We
    put the following code at the end, just preceding the end of the immediately invoked
    function expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'For the last major piece of our puzzle, let''s look at an HTML skeleton that
    will house these components for now. The HTML is not especially interesting, but
    is provided with an interest in reducing guesswork:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: And what does it look like!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here, we saw the nuts and bolts used for a simple application, perhaps more
    whimsical than the the `TodoMVC` function. For now, we're just making some basic
    explanations.
  prefs: []
  type: TYPE_NORMAL
- en: Join us in the next chapter for a to-do list that offers ways to mark a task
    as in progress, important, having problems, or other useful points.
  prefs: []
  type: TYPE_NORMAL
