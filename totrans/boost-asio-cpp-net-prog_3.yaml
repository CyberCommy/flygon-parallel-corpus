- en: Chapter 3. Introducing the Boost C++ Libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Many programmers use libraries since this simplifies the programming process.
    Because they do not need to write the function from scratch anymore, using a library
    can save much code development time. In this chapter, we are going to get acquainted
    with Boost C++ libraries. Let us prepare our own compiler and text editor to prove
    the power of Boost libraries. As we do so, we will discuss the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the C++ standard template library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing the Boost libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preparing the Boost C++ libraries in MinGW compiler
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building the Boost libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compiling code that contains Boost C++ libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing the C++ standard template library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The C++ **Standard Template Library** (**STL**) is a generic template-based
    library that offers generic containers, among other things. Instead of dealing
    with dynamic arrays, linked lists, binary trees, or hash tables, programmers can
    easily use an algorithm that is provided by STL.
  prefs: []
  type: TYPE_NORMAL
- en: 'The STL is structured by containers, iterators, and algorithms, and their roles
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Containers**: Their main role is to manage the collection of objects of certain
    kinds, such as arrays of integers or linked lists of strings.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Iterators**: Their main role is to step through the element of the collections.
    The working of an iterator is similar to that of a pointer. We can increment the
    iterator by using the `++` operator and access the value by using the `*` operator.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Algorithms**: Their main role is to process the element of collections. An
    algorithm uses an iterator to step through all elements. After it iterates the
    elements, it processes each element, for example, modifying the element. It can
    also search and sort the element after it finishes iterating all the elements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let us examine the three elements that structure STL by creating the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Name the preceding code `stl.cpp`, and run the following command to compile
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we dissect this code, let us run it to see what happens. This program
    will ask users to enter as many as integer they want, and then it will sort the
    numbers. To stop the input and ask the program to start sorting, the user has
    to input `0`. This means that `0` will not be included in the sorting process.
    Since we do not prevent users from entering non-integer numbers such as 3.14,
    the program will soon stop waiting for the next number after the user enters a
    non-integer number. The code yields the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introducing the C++ standard template library](img/00015.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We have entered six integers: `43`, `7`, `568`, `91`, `2240`, and `56`. The
    last entry is `0` in order to stop the input process. Then the program starts
    to sort the numbers and we get the numbers sorted in sequential order: `7`, `43`,
    `56`, `91`, `568`, and `2240`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let us examine our code to identify the containers, iterators, and algorithms
    that are contained in the STL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The `begin()` and `end()` functions in the preceding code are algorithms in
    STL. They play the role of processing the data in the containers that are used
    to get the first and the last elements in the container. Before that, we can see
    the `push_back()` function, which is used to append an element to the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The preceding `for` block will iterate each element of the integer that is called
    as `collection`. Each time the element is iterated, we can process the element
    separately. In the preceding example, we showed the number to the user. That is
    how the iterators in STL play their role.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We include vector definition to define all `vector` functions and `algorithm`
    definition to invoke the `sort()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the Boost C++ libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Boost C++ libraries is a set of libraries to complement the C++ standard
    libraries. The set contains more than a hundred libraries that we can use to increase
    our productivity in C++ programming. It is also used when our requirements go
    beyond what is available in the STL. It provides source code under Boost Licence,
    which means that it allows us to use, modify, and distribute the libraries for
    free, even for commercial use.
  prefs: []
  type: TYPE_NORMAL
- en: The development of Boost is handled by the Boost community, which consists of
    C++ developers from around the world. The mission of the community is to develop
    high-quality libraries as a complement to STL. Only proven libraries will be added
    to the Boost libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For detailed information about Boost libraries, go to [www.boost.org](http://www.boost.org).
    And if you want to contribute developing libraries to Boost, you can join the
    developer mailing list at [lists.boost.org/mailman/listinfo.cgi/boost](http://lists.boost.org/mailman/listinfo.cgi/boost).
  prefs: []
  type: TYPE_NORMAL
- en: The entire source code of the libraries is available on the official GitHub
    page at [github.com/boostorg](http://github.com/boostorg).
  prefs: []
  type: TYPE_NORMAL
- en: Advantages of Boost libraries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we know, using Boost libraries will increase programmer productivity. Moreover,
    by using Boost libraries, we will get advantages such as these:'
  prefs: []
  type: TYPE_NORMAL
- en: It is open source, so we can inspect the source code and modify it if needed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Its license allows us to develop both open source and close source projects.
    It also allows us to commercialize our software freely.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is well documented and we can find it libraries all explained, along with
    sample code from the official site.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It supports almost any modern operating system, such as Windows and Linux. It
    also supports many popular compilers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is a complement to STL instead of a replacement. It means using Boost libraries
    will ease those programming processes that are not handled by STL yet. In fact,
    many parts of Boost are included in the standard C++ library.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preparing Boost libraries for the MinGW compiler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we go through to program our C++ application by using Boost libraries,
    the libraries need to be configured in order to be recognized by MinGW compiler.
    Here, we are going to prepare our programming environment so that our compiler
    is able use Boost libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Downloading Boost libraries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The best source from which to download Boost is the official download page.
    We can go there by pointing our internet browser to [www.boost.org/users/download](http://www.boost.org/users/download).
    Find the **Download** link in **Current Release** section. At the time of writing,
    the current version of Boost libraries is 1.58.0, but when you read this book,
    the version may have changed. If so, you can still choose the current release
    because the higher version must be compatible with the lower. However, you have
    to adjust as we're going to talk about the setting later. Otherwise, choosing
    the same version will make it easy for you to follow all the instructions in this
    book.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are four file formats to be choose from for download; they are `.zip`,
    `.tar.gz`, `.tar.bz2`, and `.7z`. There is no difference among the four files
    but their file size. The largest file size is of the ZIP format and the lowest
    is that of the 7Z format. Because of the file size, Boost recommends that we download
    the 7Z format. See the following image for comparison:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Downloading Boost libraries](img/00016.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: From the preceding image, we can see the size of ZIP version is 123.1 MB while
    the size of the 7Z version is 65.2 MB. It means that the size of the ZIP version
    is almost twice that of the 7Z version. Therefore, they suggest that you choose
    the 7Z format to reduce download and decompression time. Let us choose `boost_1_58_0.7z`
    to be downloaded and save it to our local storage.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying Boost libraries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After we have got `boost_1_58_0.7z` in our local storage, decompress it using
    the 7ZIP application and save the decompression files to `C:\boost_1_58_0`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The 7ZIP application can be grabbed from [www.7-zip.org/download.html](http://www.7-zip.org/download.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'The directory then should contain file structures as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Deploying Boost libraries](img/00017.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Instead of browsing to the Boost download page and searching for the Boost version
    manually, we can go directly to [sourceforge.net/projects/boost/files/boost/1.58.0](http://sourceforge.net/projects/boost/files/boost/1.58.0).
    It will be useful when the 1.58.0 version is no longer the current release.
  prefs: []
  type: TYPE_NORMAL
- en: Using Boost libraries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Most libraries in Boost are **header-only**; this means that all declarations
    and definitions of functions, including namespaces and macros, are visible to
    the compiler and there is no need to compile them separately. We can now try to
    use Boost with the program to convert the string into `int` value as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the Notepad++ application, type the preceding code, and save it as `lexical.cpp`
    in `C:\CPP`—the directory we had created in [Chapter 1](part0015_split_000.html#page
    "Chapter 1. Simplifying Your Network Programming in C++"), *Simplifying Your Network
    Programming in C++*. Now open the command prompt, point the active directory to
    `C:\CPP`, and then type the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We have a new option here, which is `–I` (the "include" option). This option
    is used along with the full path of the directory to inform the compiler that
    we have another header directory that we want to include to our code. Since we
    store our Boost libraries in `c:\ boost_1_58_0`, we can use `–Ic:\boost_1_58_0`
    as an additional parameter.
  prefs: []
  type: TYPE_NORMAL
- en: In `lexical.cpp`, we apply `boost::lexical_cast` to convert `string` type data
    into `int` type data. The program will ask the user to input two numbers and will
    then automatically find the sum of both numbers. If a user inputs an inappropriate
    number, it will inform them that an error has occurred.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Boost.LexicalCast` library is provided by Boost for casting one data type
    to another (converting numeric types such as `int`, `double`, or `floats` into
    `string` types, and vice versa). Now, let us dissect `lexical.cpp` to for a more
    detailed understanding of what it does:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We include `boost/lexical_cast.hpp` in order to be able to invoke `boost::lexical_cast`
    function since the function is declared in `lexical_cast.hpp`. Also we use `string`
    header to apply `std::string` function as well as `iostream` header to apply `std::cin`,
    `std::cout` and `std::cerr` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Other functions, such as `std::cin` and `std::cout`, have been talked about
    in [Chapter 1](part0015_split_000.html#page "Chapter 1. Simplifying Your Network
    Programming in C++"), *Simplifying Your Network Programming in C++*, and we saw
    what their functions are so we can skip those lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We used the preceding two separate lines to convert the user-provided input
    `string` into the `int` data type. Then, after converting the data type, we summed
    up both of the `int` values.
  prefs: []
  type: TYPE_NORMAL
- en: We can also see the `try-catch` block in the preceding code. It is used to catch
    the error if user inputs an inappropriate number, except 0 to 9.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let us run the application by typing `lexical` at the command prompt. We
    will get output like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using Boost libraries](img/00018.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'I put `10` for first input and `20` for the second input. The result is `30`
    because it just sums up both input. But what will happen if I put in a non-numerical
    value, for instance `Packt`. Here is the output to try that condition:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using Boost libraries](img/00019.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once the application found the error, it will ignore the next statement and
    go directly to the `catch` block. By using the `e.what()` function, the application
    can get the error message and show it to the user. In our example, we obtain `bad
    lexical cast: source type value could not be interpreted` as target as the error
    message because we try to assign the `string` data to `int` type variable.'
  prefs: []
  type: TYPE_NORMAL
- en: Building Boost libraries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we discussed previously, most libraries in Boost are header-only, but not
    all of them. There are some libraries that have to be built separately. They are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Boost.Chrono`: This is used to show the variety of clocks, such as current
    time, the range between two times, or calculating the time passed in the process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Boost.Context`: This is used to create higher-level abstractions, such as
    coroutines and cooperative threads.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Boost.Filesystem`: This is used to deal with files and directories, such as
    obtaining the file path or checking whether a file or directory exists.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Boost.GraphParallel`: This is an extension to the **Boost Graph Library**
    (**BGL**) for parallel and distributed computing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Boost.IOStreams`: This is used to write and read data using stream. For instance,
    it loads the content of a file to memory or writes compressed data in GZIP format.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Boost.Locale`: This is used to localize the application, in other words, translate
    the application interface to user''s language.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Boost.MPI`: This is used to develop a program that executes tasks concurrently.
    **MPI itself stands for Message Passing Interface**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Boost.ProgramOptions`: This is used to parse command-line options. Instead
    of using the `argv` variable in the `main` parameter, it uses double minus (`--`)
    to separate each command-line option.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Boost.Python`: This is used to parse Python language in C++ code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Boost.Regex`: This is used to apply regular expression in our code. But if
    our development supports C++11, we do not depend on the `Boost.Regex` library
    anymore since it is available in the `regex` header file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Boost.Serialization`: This is used to convert objects into a series of bytes
    that can be saved and then restored again into the same object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Boost.Signals`: This is used to create signals. The signal will trigger an
    event to run a function on it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Boost.System`: This is used to define errors. It contains four classes: `system::error_code`,
    `system::error_category`, `system::error_condition`, and `system::system_error`.
    All of these classes are inside the `boost` namespace. It is also supported in
    the C++11 environment, but because many Boost libraries use `Boost.System`, it
    is necessary to keep including `Boost.System`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Boost.Thread`: This is used to apply threading programming. It provides classes
    to synchronize access on multiple-thread data. In C++11 environments, the `Boost.Thread`
    library offers extensions, so we can interrupt thread in `Boost.Thread`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Boost.Timer`: This is used to measure the code performance by using clocks.
    It measures time passed based on usual clock and CPU time, which states how much
    time has been spent to execute the code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Boost.Wave`: This provides a reusable C preprocessor that we can use in our
    C++ code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are also a few libraries that have optional, separately compiled binaries.
    They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Boost.DateTime`: It is used to process time data; for instance, calendar dates
    and time. It has a binary component that is only needed if we use `to_string`,
    `from_string`, or serialization features. It is also needed if we target our application
    in Visual C++ 6.x or Borland.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Boost.Graph`: It is used to create two-dimensional graphics. It has a binary
    component that is only needed if we intend to parse `GraphViz` files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Boost.Math`: It is used to deal with mathematical formulas. It has binary
    components for `cmath` functions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Boost.Random`: It is used to generate random numbers. It has a binary component,
    which is only needed if we want to use `random_device`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Boost.Test`: It is used to write and organize test programs and their runtime
    execution. It can be used in header-only or separately compiled mode, but separate
    compilation is recommended for serious use.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Boost.Exception`: It is used to add data to an exception after it has been
    thrown. It provides non-intrusive implementation of `exception_ptr` for 32-bit
    `_MSC_VER==1310` and `_MSC_VER==1400`, which requires a separately compiled binary.
    This is enabled by `#define BOOST_ENABLE_NON_INTRUSIVE_EXCEPTION_PTR`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let us try to recreate the random number generator program we created in [Chapter
    1](part0015_split_000.html#page "Chapter 1. Simplifying Your Network Programming
    in C++"), *Simplifying Your Network Programming in C++*. But now we will use the
    `Boost.Random` library instead of `std::rand()` from the C++ standard function.
    Let us take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We can compile the preceding source code by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let us run the program. Unfortunately, for the three times that I ran
    the program, I always obtained the same random number as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building Boost libraries](img/00020.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As we can see from this example, we always get number 8\. This is because we
    apply Mersenne Twister, a **Pseudorandom Number Generator** (**PRNG**), which
    uses the default seed as a source of randomness so it will generate the same number
    every time the program is run. And, of course, it is not the program that we expect.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will rework the program once again, just in two lines. First, find
    the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Change it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, find the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Change it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, save the file as `rangen2_boost.cpp` and compile the `rangen2_boost.cpp`
    file by using the command like we compiled `rangen_boost.cpp`. The command will
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Sadly, there will be something wrong and the compiler will show the following
    error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This is because, as we saw earlier, the `Boost.Random` library needs to be compiled
    separately if we want to use the `random_device` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'Boost libraries have a system to compile or build Boost itself, called `Boost.Build`
    library. There are two steps we have to achieve to install the `Boost.Build` library.
    First, run **Bootstrap** by pointing the active directory at the command prompt
    to `C:\boost_1_58_0` and typing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We use our MinGW compiler we had installed in [Chapter 1](part0015_split_000.html#page
    "Chapter 1. Simplifying Your Network Programming in C++"), *Simplifying Your Network
    Programming in C++*, as our toolset in compiling the Boost library. Wait a second
    and then we will get the following output if the process is a success:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In this step, we will find four new files in the Boost library''s root directory.
    They are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`b2.exe`: This is an executable file to build Boost libraries'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bjam.exe`: This is exactly the same as `b2.exe` but it is a legacy version'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bootstrap.log`: This contains logs from the `bootstrap` process'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`project-config.jam`: This contains a setting that will be used in the building
    process when we run `b2.exe`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We also find that this step creates a new directory in `C:\boost_1_58_0\tools\build\src\engine\bin.ntx86`
    , which contains a bunch of `.obj` files associated with Boost libraries that
    needed to be compiled.
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, run the second step by typing the following command at the command
    prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Grab yourself a cup of coffee after running that command because it will take
    about twenty to fifty minutes to finish the process, depending on your system
    specifications. The last output we will get will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This means that the process is complete and we have now built the Boost libraries.
    If we check in our explorer, the `Boost.Build` library adds `C:\boost_1_58_0\stage\lib`,
    which contains a collection of static and dynamic libraries that we can use directly
    in our program.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`bootstrap.bat` and `b2.exe` use `msvc` (Microsoft Visual C++ compiler) as
    the default toolset, and many Windows developers already have `msvc` installed
    on their machines. Since we have installed the GCC compiler, we set the `mingw`
    and `gcc` toolset options in Boost''s build. If you also have `mvsc` installed
    and want to use it in Boost''s build, the toolset options can be omitted.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let us try to compile the `rangen2_boost.cpp` file again, but now with
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We have two new options here, they are `–L` and `–l`. The `-L` option is used
    to define the path that contains the library file if it is not in the active directory.
    The `–l` option is used to define the name of library file but omitting the first
    `lib` word in front of the file name. In this case, the original library file
    name is `libboost_random-mgw49-mt-1_58.a`, and we omit the `lib` phrase and the
    file extension for option `-l`.
  prefs: []
  type: TYPE_NORMAL
- en: The new file called `rangen2_boost.exe` will be created in `C:\CPP`. But before
    we can run the program, we have to ensure that the directory that the program
    installed has contained two library files which the program is dependent on. These
    are `libboost_random-mgw49-mt-1_58.dll` and `libboost_system-mgw49-mt-1_58.dll`,
    and we can get them from the library directory `c:\boost_1_58_0_1\stage\lib`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just to make it easy for us to run that program, run the following `copy` command
    to copy the two library files to `C:\CPP`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: And now the program should run smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: In order to create a network application, we are going to use the `Boost.Asio`
    library. We do not find `Boost.Asio`—the library that we are going to use to create
    a network application—in the non-header-only library. It seems that we do not
    need to build the Boost library since `Boost.Asio` is header-only library. This
    is true, but since `Boost.Asio` depends on `Boost.System` and `Boost.System` needs
    to be built before being used, it is important to build Boost first before we
    can use it to create our network application.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For option `–I` and `–L`, the compiler does not care if we use backslash (\)
    or slash (/) to separate each directory name in the path because the compiler
    can handle both Windows and Unix path styles.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We saw that Boost C++ libraries were developed to complement the standard C++
    library. We have also been able to set up our MinGW compiler in order to compile
    the code that contains Boost libraries and build the binaries of libraries that
    have to be compiled separately. In the next chapter, which talks about the `Boost.Asio`
    library (the library we are going to use to develop network applications), we
    will delve into Boost libraries specifically. Please remember that although we
    can use the `Boost.Asio` library as a header-only library, it would be better
    to build all Boost libraries by using the `Boost.Build` library. It will be easy
    for us to use all libraries without worrying about compiling failure.
  prefs: []
  type: TYPE_NORMAL
