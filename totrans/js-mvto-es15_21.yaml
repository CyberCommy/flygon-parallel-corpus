- en: Chapter 8. Application Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Thus far we have spent a great deal of time examining patterns that are used
    to solve local problems, that is; problems that span only a handful of classes
    and not the whole application. These patterns have been narrow in scope. They
    frequently only relate to two or three classes and might be used but a single
    time in any given application. As you can imagine there are also larger scale
    patterns that are applicable to the application as a whole. You might think of
    "toolbar" as a general pattern that is used in many places in an application.
    What's more, it is a pattern that is used in a great number of applications to
    give them a similar look and feel. Patterns can help guide how the whole application
    is assembled.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter we're going to look at a family of patterns which I've taken
    to calling the MV* family. This family includes MVC, MVVM, MVP, and even PAC.
    Just like their names, the patterns themselves are pretty similar. The chapter
    will cover each of these patterns and show how, or if, we can apply them to JavaScript.
    We'll also pay special attention to how the patterns differ from one another.
    By the end of the chapter you should be able to thrill guests at a cocktail party
    with an explanation of the nuances of MVP versus MVC.
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics covered will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: History of Model View patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Model View Controller
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Model View Presenter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Model View ViewModel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First, some history
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Separating concerns inside an application is a very important idea. We live
    in a complex and ever-changing world. This means that not only is it nearly impossible
    to formulate a computer program which works in exactly the way users want, but
    that what users want is an ever-shifting maze. Couple this with the fact that
    an ideal program for user A is totally different from an ideal program for user
    B and we''re guaranteed to end up in a mess. Our applications need to change as
    frequently as we change our socks: at least once a year.'
  prefs: []
  type: TYPE_NORMAL
- en: Layering an application and maintaining modularity reduces the impact of a change.
    The less each layer knows about the other layers the better. Maintaining simple
    interfaces between the layers reduces the chances that a change to one layer will
    percolate to another layer.
  prefs: []
  type: TYPE_NORMAL
- en: If you've ever taken a close look at a high quality piece of nylon (from a hot
    air balloon, parachute, or expensive jacket) you may have noticed that that the
    fabric seems to form tiny squares. This is because, every few millimeters, a thick
    reinforcing thread is added to the weave to form a crosshatch pattern. If the
    fabric is ripped, then the rip will be stopped or at least slowed by the reinforcement.
    This limits the damage to a small area and prevents it from spreading.
  prefs: []
  type: TYPE_NORMAL
- en: 'Layers and modules in an application are exactly the same: they limit the spread
    of damage from a change.'
  prefs: []
  type: TYPE_NORMAL
- en: In the early chapters of this module, we talked a bit about the seminal language,
    Smalltalk. It was the language which made classes famous. Like many of these patterns,
    the original MV* pattern, **Model View Controller** (**MVC**), was used long before
    it was ever identified. Although difficult to prove it seems that MVC was originally
    suggested in the late 1970s by Trygve Reenskaug, a Norwegian computer scientist,
    during a visit to the legendary Xerox PARC. Through the 1980s the pattern became
    heavily used in Smalltalk applications. However, it was not until 1988 that the
    pattern was more formally documented in an article entitled, *A Cookbook for Using
    the Model-View-Controller User Interface Paradigm* by Glenn E. Krasner and Stephen
    T. Pope.
  prefs: []
  type: TYPE_NORMAL
- en: Model View Controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'MVC is a pattern that is useful for creating rich, interactive user interfaces:
    just the sort of interfaces which are becoming more and more popular on the web.
    The astute amongst you will have already figured out that the pattern is made
    up of three major components: model, view, and controller. You can see how information
    flows between the components in this illustration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Model View Controller](img/00069.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding diagram shows the relationship between the three components in
    MVC.
  prefs: []
  type: TYPE_NORMAL
- en: The model contains the state of the program. In many applications this model
    is contained in some form, in a database. The model may be rehydrated from a persistent
    store such as the database or it can be transient. Ideally the model is the only
    mutable part of the pattern. Neither the view nor the controller has any state
    associated with them.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a simple login screen the model might look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You'll notice that not only do we have fields for the inputs shown to the user
    but also for the state of the login. This would not be apparent to the user but
    it is still part of the application state.
  prefs: []
  type: TYPE_NORMAL
- en: The model is usually modeled as a simple container for information. Typically,
    there are no real functions in the model. It simply contains data fields and may
    also contain validation. In some implementations of the MVC pattern the model
    also contains meta-data about the fields such as validation rules.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Naked Object pattern is a deviation from the typical MVC pattern. It augments
    the model with extensive business information as well as hits about the display
    and editing of data. It even contains methods for persisting the model to storage.
  prefs: []
  type: TYPE_NORMAL
- en: The views in the Naked Object pattern are generated from these models automatically.
    The controller is also automatically generated by examining the model. This centralizes
    the logic for displaying and manipulating application states and saves the developer
    from having to write their own views and controllers. So while the view and controller
    still exist, they are not actual objects but are dynamically created from the
    model.
  prefs: []
  type: TYPE_NORMAL
- en: Several systems have been successfully deployed using this pattern. Some criticism
    has emerged around the ability to generate an attractive user interface from just
    the models as well as how to properly coordinate multiple views.
  prefs: []
  type: TYPE_NORMAL
- en: In a foreword to the PhD thesis, *presenting Naked Objects* by Reenskaug, he
    suggests that the naked objects pattern is actually closer to his original vision
    for MVC than most of the derivations of MVC in the wild.
  prefs: []
  type: TYPE_NORMAL
- en: Updates to the model are communicated to the view whenever the state changes.
    This is typically done through the use of an observer pattern. The model does
    not typically know about either the controller or the view. The first is simply
    the thing telling it to change and the second is only updated through the observer
    pattern so the model doesn't have direct knowledge of it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The view does pretty much what you would expect: communicate the model state
    to a target. I hesitate to suggest that the view must be a visual or graphical
    representation of the model as frequently the view is being communicated to another
    computer and may be in the form of XML, JSON, or some other data format. In most
    cases, especially those related to JavaScript, the view will be a graphical object.
    In a web context this will typically be HTML which is rendered by the browser.
    JavaScript is also gaining popularity on phones and on the desktop, so the view
    could also be a screen on a phone or on the desktop.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The view for the model presented in the preceding paragraph might look like
    the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Model View Controller](img/00070.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In cases, where the observer pattern is not used, then the view may poll the
    model at some interval looking for changes. In this case the view may have to
    keep a representation of the state itself or at least a version number. It is
    important that the view not unilaterally update this state without passing the
    updates to the controller, otherwise the model and the copy in the view will get
    out of sync.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the state of the model is updated by the controller. The controller
    usually contains all the logic and business rules for updating fields on the model.
    A simple controller for our login page might look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The controller knows about the existence of the model and is typically aware
    of the view's existence as well. It coordinates the two of them. A controller
    may be responsible for initializing more than one view. For instance, a single
    controller may provide a list view of all the instances of a model as well as
    a view that simply provides details. In many systems a controller will have create,
    read, update, and delete (CRUD) operations on it that work over a model. The controller
    is responsible for choosing the correct view and for wiring up the communication
    between the model and the view.
  prefs: []
  type: TYPE_NORMAL
- en: 'When there is a need for a change to the application then the location of the
    code should be immediately apparent. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Change | Location |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Elements don''t appear well spaced on the screen, change spacing. | View
    |'
  prefs: []
  type: TYPE_TB
- en: '| No users are able to log in due to a logical error in password validation.
    | Controller |'
  prefs: []
  type: TYPE_TB
- en: '| New field to be added. | All layers |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Presentation-Abstraction-Control** (**PAC**) is another pattern that makes
    use of a triad of components. In this case its goal is to describe a hierarchy
    of encapsulated triples that more closely match how we think of the world. The
    control, similar to an MVC controller, passes interactions up in the hierarchy
    of encapsulated components allowing for information to flow between components.
    The abstraction is similar to a model but may represent only a few fields that
    are important for that specific PAC instead of the entire model. Finally, the
    presentation is effectively the same as a view.'
  prefs: []
  type: TYPE_NORMAL
- en: The hierarchical nature of PAC allows for parallel processing of the components,
    meaning that it can be a powerful tool in today's multiprocessor systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might notice that the last one there requires a change in all layers of
    the application. These multiple locations for responsibility are something that
    the Naked Objects pattern attempts to address by dynamically creating views and
    controllers. The MVC pattern splits code into locations by dividing the code by
    its role in user interaction. This means that a single data field lives in all
    the layers as is shown in this picture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Model View Controller](img/00071.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Some might call this a cross-cutting concern but really it doesn't span a sufficient
    amount of the application to be called such. Data access and logging are cross-cutting
    concerns as they are pervasive and difficult to centralize. This pervasion of
    a field through the different layers is really not a major problem. However, if
    it is bugging you then you might be an ideal candidate for using the Naked Objects
    pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Let's step into building some code to represent a MVC in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: MVC code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's start with a simple scenario for which we can apply MVC. Unfortunately,
    Westeros has very few computers, likely due to the lack of electricity. Thus applying
    application structuring patterns using Westeros as an example is difficult. Sadly
    we'll have to take a step back and talk about an application which controls Westeros.
    Let's assume it to be a web application and implement the entirety of MVC on the
    client side.
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to implement MVC by splitting the model, view and controller
    between client and server. Typically, the controller would sit on the server and
    provide an API which is known by the view. The model serves as a communication
    method both to the view which resides on the web browser and to the data store,
    likely a database of some form. It is also common that the controller be split
    between the server and the client in cases where some additional control is required
    on the client.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example we would like to create a screen that controls the properties
    of a castle. Fortunately, you''re lucky that this is not a book on designing user
    interfaces with HTML as I would certainly fail. We''ll stick to a picture in place
    of the HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '![MVC code](img/00072.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'For the most part, the view simply provides a set of controls and data for
    the end user. In this example the view will need to know how to call the save
    function on the controller. Let''s set that up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: You'll notice that the constructor for this view contains both a reference to
    the document and to the controller. The document contains both HTML and styling,
    provided by CSS. We can get away with not passing in a reference to the document
    but injecting the document in this fashion allows for easier testability. We'll
    look at testability more in a later chapter. It also permits reusing the view
    multiple times on a single page without worrying about the two instances conflicting.
  prefs: []
  type: TYPE_NORMAL
- en: 'The constructor also contains a reference to the model which is used to add
    data to fields on the page as needed. Finally, the constructor also references
    a collection of errors. This allows for validation errors from the controller
    to be passed back to the view to be handled. We have set the validation result
    to be a wrapped collection that looks something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The only functionality here is that the button's `onclick` method is bound to
    calling save on the controller. Instead of passing in a large number of parameters
    to the `saveCastle` function on the controller, we build a lightweight object
    and pass that in. This makes the code more readable, especially in cases where
    some of the parameters are optional. No real work is done in the view and all
    the input goes directly to the controller.
  prefs: []
  type: TYPE_NORMAL
- en: 'The controller contains the real functionality of the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The controller here does a number of things. The first thing is that it has
    a `setView` function which instructs the browser to set the given view as the
    current one. This is likely done through the use of a template. The mechanics
    of how that works are not important to the pattern so I'll leave that up to your
    imagination.
  prefs: []
  type: TYPE_NORMAL
- en: Next, the controller implements a `validate` method. This method checks to make
    sure that the model is valid. Some validation may be performed on the client,
    such as testing the format of a postal code, but other validation requires a server
    trip. If a username must be unique then there is no reasonable way to test that
    on the client without communicating with the server. In some cases, the validation
    functionality may exist on the model rather than in the controller.
  prefs: []
  type: TYPE_NORMAL
- en: Methods for setting up various different views are also found in the controller.
    In this case we have a bit of a workflow with a view for creating a castle then
    views for both success and failure. The failure case just returns the same view
    with a collection of validation errors attached to it. The success case returns
    a whole new view.
  prefs: []
  type: TYPE_NORMAL
- en: The logic to save the model to some sort of persistent storage is also located
    in the controller. Again the implementation of this is less important than to
    see that the logic for communicating with the storage system is located in the
    controller.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final letter in MVC is the model. In this case, it is a very light weight
    one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, all it does is keep track of the variables that make up the
    state of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Concerns are well separated in this pattern allowing for changes to be made
    with relative ease.
  prefs: []
  type: TYPE_NORMAL
- en: Model View Presenter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Model View** **Presenter** (**MVP**) pattern is very similar to MVC. It
    is a fairly well known pattern in the Microsoft world and is generally used to
    structure WPF and Silverlight applications. It can be used in pure JavaScript
    as well. The key difference comes down to how the different parts of the system
    interact and where their responsibility ends.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first difference is that, with the presenter, there is a one to one mapping
    between presenter and view. This means that the logic that existed in the controller
    in the MVC pattern, which selected the correct view to render, doesn''t exist.
    Or rather it exists at a higher level outside the concern of the pattern. The
    selection of the correct presenter may be handled by a routing tool. Such a router
    will examine the parameters and provide the best choice for the presenter. The
    flow of information in the MVP pattern can be seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Model View Presenter](img/00073.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The presenter is aware of both the view and the model but the view is unaware
    of the model and the model unaware of the view. All communication is passed through
    the presenter.
  prefs: []
  type: TYPE_NORMAL
- en: The presenter pattern is often characterized by a great deal of two-way dispatch.
    A click will fire in the presenter and then the presenter will update the model
    with the change and then the view. The preceding diagram suggests that the input
    first passes through the view. In a passive version of the MVP pattern, the view
    has little to no interaction with the messages as they are passed onto the presenter.
    However, there is also a variation called active MVP that allows the view to contain
    some additional logic.
  prefs: []
  type: TYPE_NORMAL
- en: This active version of MVP can be more useful for web situations. It permits
    adding validation and other simple logic to the view. This reduces the number
    of requests that need to pass from the client back to the web server.
  prefs: []
  type: TYPE_NORMAL
- en: Let's update our existing code sample to use MVP instead of MVC.
  prefs: []
  type: TYPE_NORMAL
- en: MVP code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start again with the view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As you can see the constructor for the view no longer takes a reference to the
    model. This is because the view in MVP doesn't have any idea about what model
    is being used. That information is abstracted away by the presenter. The reference
    to presenter remains in the constructor to allow sending messages back to the
    presenter.
  prefs: []
  type: TYPE_NORMAL
- en: Without the model there is an increase in the number of public setter and getter
    methods. These setters allow the presenter to make updates to the state of the
    view. The getters provide an abstraction over how the view stores the state and
    gives the presenter a way to get the information. The `saveCastle` function no
    longer passes any values to the presenter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The presenter''s code looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: You can see that the view is now referenced in a persistent fashion in the presenter.
    The `saveCastle` method calls into the view to get its values. However, the presenter
    does make sure to use the public methods of the view instead of referencing the
    document directly. The `saveCastle` method updates the model. If there are validation
    errors, then it will call back into the view to update the `IsValid` flag. This
    is an example of the double dispatch I mentioned earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the model remains unchanged from before. We've kept the validation
    logic in the presenter. At which level the validation is done, model or presenter,
    matters less than being consistent in where the validation is done through your
    application.
  prefs: []
  type: TYPE_NORMAL
- en: The MVP pattern is again a fairly useful pattern for building user interfaces.
    The larger separation between the view and the model creates a stricter API allowing
    for better adaptation to change. However, this comes at the expense of more code.
    With more code comes more opportunity for bugs.
  prefs: []
  type: TYPE_NORMAL
- en: Model View ViewModel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The final pattern we''ll look at in this chapter is the Model View ViewModel
    pattern, more commonly known as MVVM. By now this sort of pattern should be getting
    quite familiar. Again you can see the flow of information between components in
    this illustration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Model View ViewModel](img/00074.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: You can see here that many of the same constructs have returned but that the
    communication between them is somewhat different.
  prefs: []
  type: TYPE_NORMAL
- en: In this variation, what has previously been the controller and presenter is
    now the view model. Just like with MVC and MVP, the majority of the logic is held
    within the central component, in this case the view model. The model itself is
    actually very simple in MVVM. Typically, it acts as an envelope that just holds
    data. Validation is done within the view model.
  prefs: []
  type: TYPE_NORMAL
- en: Just like with MVP, the view is totally unaware of the existence of the model.
    The difference is that, with MVP, the view was aware that it was talking to some
    intermediate class. It called methods rather than simply setting values. In MVVM
    the view believes that the view model is its view. Instead of calling operations
    like `saveCastle` and passing in data or waiting for data to be requested, the
    view updates fields on the view model as they change. In effect, the fields on
    the view are bound to the view model. The view model may proxy these values through
    to the model or wait until a commit-like operation like save is called to pass
    the data along.
  prefs: []
  type: TYPE_NORMAL
- en: Equally, changes to the view model should be reflected at once in the view.
    A single view may have a number of view models. Each of these view models may
    push updates to the view or have changes pushed to it via the view.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at a really rudimentary implementation of this and then we'll
    discuss how to make it better.
  prefs: []
  type: TYPE_NORMAL
- en: MVVM code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The naïve view implementation is, frankly, a huge mess:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'It is highly repetitive and each property must be proxied back to `ViewModel`.
    I''ve truncated most of this code but it adds up to a good 70 lines. The code
    inside the view model is equally terrible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'One look at this code should send you running for the hills. It is set up in
    a way that will encourage copy and paste programming: a fantastic way to introduce
    errors into a code base. I sure hope there is a better way to transfer changes
    between the model and the view.'
  prefs: []
  type: TYPE_NORMAL
- en: A better way to transfer changes between the model and the view
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It may not have escaped your notice that there are a number of MVVM-style frameworks
    for JavaScript in the wild. Obviously they would not have been readily adopted
    if they followed the approach that we described in the preceding section. Instead
    they follow one of two different approaches.
  prefs: []
  type: TYPE_NORMAL
- en: The first approach is known as dirty checking. In this approach, after every
    interaction with the view model we loop over all of its properties looking for
    changes. When changes are found, the related value in the view is updated with
    the new value. For changes to values in the view change, actions are attached
    to all the controls. These then trigger updates to the view model.
  prefs: []
  type: TYPE_NORMAL
- en: 'This approach can be slow for large models as it is expensive to iterate over
    all the properties of a large model. The number of things which can cause a model
    to change is high and there is no real way to tell if a distant field in a model
    has been changed by changing another without going and validating it. On the upside,
    dirty checking allows you to use plain old JavaScript objects. There is no need
    to write your code any differently than before. The same is not true of the other
    approach: container objects.'
  prefs: []
  type: TYPE_NORMAL
- en: With a container object a special interface is provided to wrap existing objects
    so that changes to the object may be directly observed. Basically this is an application
    of the observer pattern but applied dynamically so the underlying object has no
    idea it is being observed. The spy pattern, perhaps?
  prefs: []
  type: TYPE_NORMAL
- en: 'An example might be helpful here. Let us say that we have the model object
    we''ve been using up until now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, instead of `model.name` being a simple string, we would wrap some function
    around it. In the case of the Knockout library this would look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In the highlighted code, the various properties of the model are being wrapped
    with an observable. This means that they must now be accessed differently:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This approach obviously adds some friction to your code and makes changing frameworks
    quite involved.
  prefs: []
  type: TYPE_NORMAL
- en: Current MVVM frameworks are split on their approach to container objects versus
    dirty checking. AngularJS uses dirty checking while Backbone, Ember, and Knockout
    all make use of container objects. There is currently no clear winner.
  prefs: []
  type: TYPE_NORMAL
- en: Observing view changes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Fortunately, the pervasiveness of MV* patterns on the web and the difficulties
    with observing model changes has not gone unnoticed. You might be expecting me
    to say that this will be solved in ECMAScript-2015 as is my normal approach. Weirdly,
    the solution to all of this, `Object.observe`, is a feature under discussion for
    ECMAScript-2016\. However, at the time of writing, at least one major browser
    already supports it.
  prefs: []
  type: TYPE_NORMAL
- en: 'It can be used like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Having this simple interface to monitor changes to objects removes much of the
    logic provided by large MV* frameworks. It will be easier to roll your own functionality
    for MV* and there may, in fact, be no need to use external frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: Tips and tricks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The different layers of the various MV* patterns need not all be on the browser,
    nor do they all need to be written in JavaScript. Many popular frameworks allow
    for maintaining a model on the server and communicating with it using JSON.
  prefs: []
  type: TYPE_NORMAL
- en: '`Object.observe` may not be available on all browsers yet, but there are polyfills
    that can be used to create a similar interface. The performance is not as good
    as the native implementation, but it is still usable.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Separating concerns to a number of layers ensures that changes to the application
    are isolated like a ripstop. The various MV* patterns allow for separating the
    concerns in a graphical application. The differences between the various patterns
    come down to how the responsibilities are separated and how information is communicated.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter we'll look at a number of patterns and techniques to improve
    the experience of developing and deploying JavaScript to the Web.
  prefs: []
  type: TYPE_NORMAL
