- en: Composing Event-Based Programs Using Reactive Extensions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用反应式扩展来组合基于事件的程序
- en: 'This chapter deals with **Reactive Extensions** (**Rx**). To understand Rx,
    we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涉及**反应式扩展**（**Rx**）。为了理解 Rx，我们将涵盖以下内容：
- en: Installing Rx
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装 Rx
- en: Events versus observables
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件与可观察对象
- en: Using LINQ to perform queries
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 LINQ 执行查询
- en: Using schedulers in Rx
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Rx 中使用调度程序
- en: Debugging lambda expressions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试 lambda 表达式
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Often, during your day-to-day dealings with developing applications in C#, you
    will have to use asynchronous programming. You might also have to deal with many
    data sources. Think of a web service that returns the current exchange rates,
    a Twitter search returning a stream of related data, or even different events
    generated by multiple computers. Rx provides an elegant solution in the form of
    the `IObserver<T>` interface.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在日常处理 C# 应用程序开发中，您经常需要使用异步编程。您可能还需要处理许多数据源。想象一下返回当前汇率的 Web 服务，返回相关数据流的 Twitter
    搜索，甚至多台计算机生成的不同事件。Rx 通过 `IObserver<T>` 接口提供了一个优雅的解决方案。
- en: 'You use the `IObserver<T>` interface to subscribe to the events. Then, the
    `IObservable<T>` interface, which maintains a list of `IObserver<T>` interfaces,
    will notify them of the change of state. In essence, Rx will stick together multiple
    data sources (social media, RSS feeds, UI events, and so on) that generate data.
    Rx, therefore, brings these data sources together in one interface. In fact, Rx
    can be thought of as consisting of three sections:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 您使用 `IObserver<T>` 接口订阅事件。然后，维护 `IObserver<T>` 接口列表的 `IObservable<T>` 接口将通知它们状态的变化。实质上，Rx
    将多个数据源（社交媒体、RSS 订阅、UI 事件等）粘合在一起生成数据。因此，Rx 将这些数据源汇集在一个接口中。事实上，Rx 可以被认为由三个部分组成：
- en: '**Observables**: The interface that brings together and represents all these
    datastreams'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可观察对象**：将所有这些数据流汇集并表示的接口'
- en: '**Language-Integrated Query** (**LINQ**): The ability to use LINQ to query
    these multiple datastreams'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**语言集成查询**（**LINQ**）：使用 LINQ 查询这些多个数据流的能力'
- en: '**Schedulers**: Parameterizing concurrency using schedulers'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调度程序**：使用调度程序参数化并发'
- en: The question on many minds might be why developers should use (or find a use
    for) Rx. Here are a few examples where Rx is really useful.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 许多人心中的疑问可能是为什么开发人员应该使用（或找到使用）Rx。以下是一些 Rx 真正有用的例子。
- en: Creating a search that has an autocomplete function. You don't want the code
    to perform a search for each value you type into the search area. Rx allows you
    to throttle the search.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建具有自动完成功能的搜索。您不希望代码对搜索区域中输入的每个值执行搜索。Rx 允许您对搜索进行节流。
- en: Making the UI of your application more responsive.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使应用程序的用户界面更具响应性。
- en: Being notified when data changes instead of having to poll the data for changes.
    Think of real-time stock prices.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在数据发生变化时得到通知，而不是必须轮询数据以查看变化。想象实时股票价格。
- en: To keep up to date with Rx, you can take a look at the [https://github.com/Reactive-Extensions/Rx.NET](https://github.com/Reactive-Extensions/Rx.NET) 
    GitHub page[.](https://github.com/Reactive-Extensions/Rx.NET)
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解 Rx 的最新信息，您可以查看 [https://github.com/Reactive-Extensions/Rx.NET](https://github.com/Reactive-Extensions/Rx.NET) 
    GitHub 页面[.](https://github.com/Reactive-Extensions/Rx.NET)
- en: Installing Rx
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 Rx
- en: Before we can begin exploring Rx, we need to install it. The easiest way to
    do this is using NuGet.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始探索 Rx 之前，我们需要安装它。最简单的方法是使用 NuGet。
- en: Getting ready
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this chapter on Rx, we will not create a separate class. All the code will
    be written in a console application.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Rx 的这一章中，我们不会创建一个单独的类。所有的代码都将在控制台应用程序中编写。
- en: How to do it...
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Create a console application, and then right-click on your solution and select
    Manage NuGet Packages for Solution... from the context menu.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个控制台应用程序，然后右键单击解决方案，从上下文菜单中选择“管理解决方案的 NuGet 包...”。
- en: 'In the window that is displayed afterwards, type in `System.Reactive` in the
    search textbox and search for the NuGet installer:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在随后显示的窗口中，在搜索文本框中键入 `System.Reactive` 并搜索 NuGet 安装程序：
- en: '![](img/B06434_10_01.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_10_01.png)'
- en: At the time of writing this book, the last stable release was version 3.1.1\.
    If you have more than a single project, select the projects that you want to install
    Rx on. Seeing that we only have a single Console application, just select Rx to
    be installed for the whole project.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在撰写本书时，最新的稳定版本是 3.1.1。如果您有多个项目，请选择要在其上安装 Rx 的项目。鉴于我们只有一个单独的控制台应用程序，只需选择为整个项目安装
    Rx。
- en: The next screen that is displayed is a confirmation dialog box, asking you to
    confirm the changes to the project. It will show a preview of the changes it will
    be making to each project. If you are happy with the changes, click on the OK
    button.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来显示的屏幕是一个确认对话框，询问您确认对项目的更改。它将显示对每个项目将要进行的更改的预览。如果您对更改满意，请单击“确定”按钮。
- en: A license agreement might be presented to you in the last dialog screen, which
    you will need to accept. To continue, click on the I Accept button.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在最后的对话框屏幕上可能会向您呈现许可协议，您需要接受。要继续，请单击“我接受”按钮。
- en: 'After the installation is complete, you will see the references added to the
    Rx under the References node in your project. These are as follows:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装完成后，您将在项目的引用节点下看到 Rx 添加的引用。具体如下：
- en: '`System.Reactive.Core`'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System.Reactive.Core`'
- en: '`System.Reactive.Interfaces`'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System.Reactive.Interfaces`'
- en: '`System.Reactive.Linq`'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System.Reactive.Linq`'
- en: '`System.Reactive.PlatformServices`'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System.Reactive.PlatformServices`'
- en: How it works...
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'NuGet is by far the easiest way to add additional components to your projects.
    As you can see from the added references, `System.Reactive` is the main assembly.
    To gain a better understanding of `System.Reactive`, view the assemblies in Object
    Browser. To do this, double-click on any of the assemblies in the References option
    of your project. This will display the Object Browser:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: NuGet绝对是向项目添加附加组件的最简单方式。从添加的引用中可以看出，`System.Reactive`是主要程序集。要更好地了解`System.Reactive`，请查看对象浏览器中的程序集。要做到这一点，请双击项目的引用选项中的任何程序集。这将显示对象浏览器：
- en: '![](img/B06434_10_02.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_10_02.png)'
- en: '`System.Reactive.Linq` contains all the querying functionality in Rx. You will
    also notice that `System.Reactive.Concurrency` contains all the schedulers.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.Reactive.Linq`包含Rx中的所有查询功能。您还会注意到`System.Reactive.Concurrency`包含所有调度程序。'
- en: Events versus observables
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件与可观察对象
- en: 'Being developers, we should all be quite familiar with events. Most developers
    have been creating events since we started writing code. In fact, if you have
    even dropped a button control on a form and double-clicked the button to create
    the method that handles the click of the button, you have created an event. In
    .NET, we can declare events using the `event` keyword, publish to the event by
    invoking it, and subscribe to that event by adding a handler to the event. We,
    therefore, have the following operations:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发人员，我们应该都对事件非常熟悉。自从我们开始编写代码以来，大多数开发人员一直在创建事件。事实上，如果您在窗体上放置了一个按钮控件并双击按钮以创建处理按钮点击的方法，那么您已经创建了一个事件。在.NET中，我们可以使用`event`关键字声明事件，通过调用它来发布事件，并通过向事件添加处理程序来订阅该事件。因此，我们有以下操作：
- en: Declare
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明
- en: Publish
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布
- en: Subscribe
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订阅
- en: With Rx, we have a similar structure where we declare a datastream, publish
    data to that stream, and subscribe to it.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Rx，我们有一个类似的结构，我们声明一个数据流，将数据发布到该流中，并订阅它。
- en: Getting ready
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: First, we will see how an event works in C#. We will then see the working of
    an event using Rx and, in doing so, highlight the differences.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将看看C#中事件的工作原理。然后，我们将看到使用Rx的事件的工作方式，并在此过程中突出显示差异。
- en: How to do it...
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In your console application, add a new class called `DotNet`. To this class,
    add a property called `AvailableDatatype`:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的控制台应用程序中，添加一个名为`DotNet`的新类。在这个类中，添加一个名为`AvailableDatatype`的属性：
- en: '[PRE0]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the main program class, add a new static action event called `types`. Basically,
    this is just a delegate and will receive some value; in our case, the available
    .NET data types:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主程序类中，添加一个名为`types`的新静态动作事件。基本上，这只是一个委托，将接收一些值；在我们的情况下，是可用的.NET数据类型：
- en: '[PRE1]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Inside `void Main`, create a `List<DotNet>` class called `lstTypes`. Inside
    this list, add several values of type `DotNet` class. Here, we will just add hardcoded
    data of some of the data types in .NET:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`void Main`内，创建一个名为`lstTypes`的`List<DotNet>`类。在这个列表中，添加几个`DotNet`类的值。在这里，我们将只添加一些.NET中的数据类型的硬编码数据：
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Our next task is to subscribe to this event with an event handler that is simply
    outputting the value of *x* to the console window. We then raise the event each
    time we loop through our `lstTypes` list by adding the line `types(lstTypes[i].AvailableDatatype);`:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的下一个任务是订阅此事件，使用一个简单地将*x*的值输出到控制台窗口的事件处理程序。然后，每次我们通过`lstTypes`列表循环时，通过添加`types(lstTypes[i].AvailableDatatype);`来触发事件：
- en: '[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In reality, before raising an event we should always check that the event isn't
    null. Only after this check should we raise the event. For brevity, we have not
    added this check before raising the event.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，在触发事件之前，我们应该始终检查事件是否为null。只有在此检查之后，我们才应该触发事件。为简洁起见，我们在触发事件之前没有添加此检查。
- en: 'When you have added all the code from step 1 to step 4, your console application
    should look like this:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您将步骤1到步骤4的所有代码添加到控制台应用程序中时，它应该看起来像这样：
- en: '[PRE4]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Running your application will set our list with values and then raise the event
    created to output the values of the list to the console window:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用程序将使用值设置我们的列表，然后触发创建的事件以将列表的值输出到控制台窗口：
- en: '![](img/B06434_10_03.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_10_03.png)'
- en: 'Let''s see the working of events using Rx. Add a static `Subject` of `string`.
    You might also need to add the `System.Reactive.Subjects` namespace to your project
    as `Subjects` live in this separate namespace:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看使用Rx的事件的工作方式。添加一个静态的`string`的`Subject`。您可能还需要将`System.Reactive.Subjects`命名空间添加到您的项目中，因为`Subjects`位于这个单独的命名空间中：
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'After the code that created the list of `DotNet`, we used `+=` to wire up an
    event handler. This time round, we will use `Subscribe`. This is the `IObservable`
    portion of the code. After you''ve added this, raise the event using the `OnNext`
    keyword. This is the `IObserver` portion of the code. Therefore, as we loop through
    our list, we will call `OnNext` to pump out the values to the subscribed `IObservable`
    interface:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建`DotNet`列表的代码之后，我们使用`+=`来连接事件处理程序。这一次，我们将使用`Subscribe`。这是代码的`IObservable`部分。添加完这个之后，使用`OnNext`关键字触发事件。这是代码的`IObserver`部分。因此，当我们循环遍历我们的列表时，我们将调用`OnNext`来将值输出到订阅的`IObservable`接口：
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'When you''ve completed adding all the code, your application should look like
    this:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您完成添加所有代码后，您的应用程序应该看起来像这样：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: When you run your application, you will see the same items are output to the
    console window, as it did earlier.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用程序时，您将看到与之前相同的项目输出到控制台窗口。
- en: How it works...
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In Rx, we can declare an event stream with the `Subject` keyword. So, we have
    a source of events that we can publish to using `OnNext`. To see those values
    in the console window, we subscribed to the event stream using `Subscribe`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在Rx中，我们可以使用`Subject`关键字声明事件流。因此，我们有一个事件源，我们可以使用`OnNext`发布到该事件源。为了在控制台窗口中看到这些值，我们使用`Subscribe`订阅了事件流。
- en: Rx allows you to have objects that are just publishers or just subscribers.
    This is because the `IObservable` and `IObserver` interfaces are in fact separate.
    Also, note that in Rx, the observables can be passed as parameters, returned as
    results, and stored in variables, which makes them first class.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B06434_10_04.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
- en: 'Rx also allows you to specify that the event stream is completed or that an
    error occurred. This really sets Rx apart from events in .NET. Also, it is important
    to note that including the `System.Reactive.Linq` namespace in your project allows
    developers to write queries over the `Subject` type because a `Subject` is an
    `IObservable` interface:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B06434_10_05.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
- en: This is another feature that sets Rx apart from the events in .NET.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: Using LINQ to perform queries
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Rx allows developers to use the `IObservable` interface, which represents synchronous
    datastreams, to write queries using LINQ. To recap, Rx can be thought of as consisting
    of three sections:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '**Observables**: The interface that brings together and represents all these
    datastreams'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Language-Integrated Query** (**LINQ**): The ability to use LINQ to query
    these multiple datastreams'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Schedulers**: Parameterizing concurrency using schedulers'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this recipe, we will be looking at the LINQ functionality of Rx in more detail.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As observables are just datastreams, we can use LINQ to query them. In the following
    recipe, we will output text to the screen based on a LINQ query.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Start by adding a new Windows forms project to your solution.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Call the project `winformRx` and click on the OK button:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Toolbox, search for the TextBox control and add it to your form.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, add a label control to your form:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_10_06.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
- en: Right-click on your `winformRx` project and select Manage NuGet Packages...
    from the context menu.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the search textbox, enter `System.Reactive` to search for the NuGet package
    and click on the Install button.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Visual Studio will ask you to review the changes it's about to make to your
    project. Click on the OK button.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Before the installation starts, you might need to accept the license agreement
    by clicking on the I Accept button.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After the installation completes, you should see the newly added references
    to your `winformRx` project if you expand the References for the project:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, right-click on the project and set `winformRx` as your startup project
    by clicking on the Set as StartUp Project from the context menu.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the form load event handler for the form by double-clicking anywhere
    on the Windows form. To this form, add the `Observable` keyword. You will notice
    that the keyword is immediately underlined. This is because you are missing the
    reference to the LINQ assembly of `System.Reactive`.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To add this, press *Ctrl* + *.* (period) to bring up the possible suggestions
    to fix the issue. Select to add the `using System.Reactive.Linq` namespace to
    your project.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Continue adding the following code to your form load event. Basically, you
    are using LINQ and telling the compiler that you want to select the text from
    the event pattern that matches the text changed event of the textbox on the form
    called `textBox1`. After you have done that, add a subscription to the variable
    and tell it to output whatever it finds in the text to the label on the form called
    `label1`:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: When we added the textbox and label to our form, we left the control names as
    default. If, however, you changed the default names, you would need to specify
    those names instead of `textBox1` and `label1` for the controls on the form.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: Click on the run button to run your application. The Windows form will be displayed
    with the textbox and label on it.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Notice that as you type, the text is output to the label on the form:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_10_07.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
- en: 'Let''s jazz things up a bit by adding in a `Where` condition to the LINQ statement.
    We will specify that the `text` string must only select the text when it ends
    with a period. This means that the text will only be displayed in the label after
    each full sentence. As you can see, we aren''t doing anything special here. We
    are merely using standard LINQ to query our datastream and return the results
    to our `searchTerm` variable:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过在LINQ语句中添加`Where`条件来增加一些乐趣。我们将指定`text`字符串只有在以句号结尾时才能选择文本。这意味着文本只会在每个完整句子之后显示在标签上。正如您所看到的，我们在这里并没有做任何特别的事情。我们只是使用标准的LINQ来查询我们的数据流，并将结果返回给我们的`searchTerm`变量：
- en: '[PRE9]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Run your application and start typing in a line of text. You will see that
    nothing is output to the label control as you type, as was evident in the previous
    example before we added in our `Where` condition:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行您的应用程序并开始输入一行文本。您会发现在您输入时标签控件没有输出任何内容，就像在我们添加`Where`条件之前的上一个示例中一样：
- en: '![](img/B06434_10_08.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_10_08.png)'
- en: 'Add a period and start adding a second line of text:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文本后加上一个句号并开始添加第二行文本：
- en: '![](img/B06434_10_09.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_10_09.png)'
- en: 'You will see that only after each period, the text entered is added to the
    label. Our `Where` condition is, therefore, working perfectly:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您会发现只有在每个句号之后，输入的文本才会添加到标签上。因此，我们的`Where`条件完美地发挥作用：
- en: '![](img/B06434_10_10-1.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_10_10-1.png)'
- en: How it works...
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The LINQ aspect of Rx allows developers to construct observables. Here are
    some examples:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Rx的LINQ方面允许开发人员构建可观察序列。以下是一些示例：
- en: '`Observable.Empty<>`: This returns an empty observable sequence'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Observable.Empty<>`: 这将返回一个空的可观察序列'
- en: '`Observable.Return<>`: This returns an observable sequence containing a single
    element'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Observable.Return<>`: 这将返回一个包含单个元素的可观察序列'
- en: '`Observable.Throw<>`: This returns an observable sequence terminating with
    an exception'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Observable.Throw<>`: 这将返回一个以异常终止的可观察序列'
- en: '`Observable.Never<>`: This returns a non-terminating observable sequence that
    is infinite in duration'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Observable.Never<>`: 这将返回一个持续时间无限的非终止可观察序列'
- en: The use of LINQ in Rx allows the developer to manipulate and filter the datastream
    to return exactly what they need.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在Rx中使用LINQ允许开发人员操纵和过滤数据流，以返回他们需要的内容。
- en: Using schedulers in Rx
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Rx中使用调度程序
- en: Sometimes, we need to have an `IObservable` subscription run at a specific time.
    Imagine having to synchronize events across servers in different geographical
    areas and time zones. You might also need to read data from a queue while preserving
    the order in which the events occur. Another example would be to perform some
    kind of I/O task that could take some time to complete. Schedulers come in very
    handy in these situations.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们需要在特定时间运行`IObservable`订阅。想象一下需要在不同地理区域和时区的服务器之间同步事件。您可能还需要从队列中读取数据，同时保留事件发生顺序。另一个例子是执行可能需要一些时间才能完成的某种I/O任务。在这些情况下，调度程序非常有用。
- en: Getting ready
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Additionally, you can consider reading up more on using schedulers on MSDN.
    Take a look at [https://msdn.microsoft.com/en-us/library/hh242963(v=vs.103).aspx.](https://msdn.microsoft.com/en-us/library/hh242963(v=vs.103).aspx)
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您可以考虑在MSDN上阅读更多关于使用调度程序的内容。请查看[https://msdn.microsoft.com/en-us/library/hh242963(v=vs.103).aspx.](https://msdn.microsoft.com/en-us/library/hh242963(v=vs.103).aspx)
- en: How to do it...
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: If you haven't already done so, create a new Windows form application and call
    it `winformRx`. Open the form designer and in Toolbox, search for the TextBox
    control and add it to your form.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您还没有这样做，请创建一个新的Windows表单应用程序并将其命名为`winformRx`。打开表单设计器，在工具箱中搜索TextBox控件并将其添加到您的表单中。
- en: Next, add a label control to your form.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在您的表单中添加一个标签控件。
- en: 'Double-click on your Windows form designer to create the onload event handler.
    Inside this handler, add some code to read the text entered into the textbox and
    only display that text 5 seconds after the user has stopped typing. This is achieved
    using the `Throttle` keyword. Add a subscription to the `searchTerm` variable,
    writing the result of the text input to the label control''s text property:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击您的Windows表单设计器以创建onload事件处理程序。在此处理程序中，添加一些代码来读取输入到文本框中的文本，并在用户停止输入5秒后仅显示该文本。这是使用`Throttle`关键字实现的。向`searchTerm`变量添加一个订阅，将文本输入的结果写入标签控件的文本属性：
- en: '[PRE10]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note that you might need to add `System.Reactive.Linq` in your `using` statements.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您可能需要在您的`using`语句中添加`System.Reactive.Linq`。
- en: 'Run your application and start typing some text into the textbox. Immediately,
    we will receive an exception. It is a cross-thread violation. This occurs when
    there is an attempt to update the UI from a background thread. The `Observable`
    interface is running a timer from `System.Threading`, which isn''t on the same
    thread as the UI. Luckily, there is an easy way to overcome this. Well, it turns
    out that the UI-threading capabilities lie in a different assembly, which we find
    easiest to get via the Package Manager Console:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行您的应用程序并开始在文本框中输入一些文本。立即，我们将收到一个异常。这是一个跨线程违规。当尝试从后台线程更新UI时会发生这种情况。`Observable`接口正在从`System.Threading`运行一个计时器，这与UI不在同一线程上。幸运的是，有一种简单的方法可以克服这个问题。事实证明，UI线程能力位于不同的程序集中，我们最容易通过包管理器控制台获取：
- en: '![](img/B06434_10_11.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_10_11.png)'
- en: Navigate to View | Other Windows | Package Manager Console to access the Package
    Manager Console.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到视图 | 其他窗口 | 包管理器控制台以访问包管理器控制台。
- en: 'Enter the following command:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下命令：
- en: '[PRE11]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This will add the System.Reactive.Windows.Forms.3.1.1 to your `winformRx` project.
    You should, therefore, see the following in the output: Successfully installed
    'System.Reactive.Windows.Forms 3.1.1' to winformRx
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这将向您的`winformRx`项目添加System.Reactive.Windows.Forms.3.1.1。因此，您应该在输出中看到以下内容：成功安装'System.Reactive.Windows.Forms
    3.1.1'到winformRx
- en: Note that you need to ensure that the Default project selection is set to `winformRx`
    in the Package Manager Console. If you don't see this option, resize the Package
    Manager Console screen width ways until the option is displayed. This way you
    can be certain that the package is added to the correct project.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: 'After the installation completes, modify your code in the onload event handler
    and change `searchTerm.Subscribe(trm => label1.Text = trm);`, which does the subscription,
    to look like this:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You will notice that we are using the `ObserveOn` method here. What this basically
    tells the compiler is that the `this` keyword in `new ControlScheduler(this)`
    is actually a reference to our Windows form. Therefore, `ControlScheduler` will
    use the Windows forms timers to create the interval to update our UI. The message
    happens on the correct thread, and we no longer have our cross-thread violation.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: If you have not added the `System.Reactive.Concurrency` namespace to your project,
    Visual Studio will underline the `ControlScheduler` line of code with a squiggly
    line. Pressing *Ctrl* + *.* (period) will allow you to add the missing namespace.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This means that `System.Reactive.Concurrency` contains a scheduler that can
    talk to Windows forms controls so that it can do the scheduling. Run your application
    again and start typing some text into your textbox:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_10_12.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
- en: 'Around 5 seconds after we stop typing, the throttle condition is fulfilled
    and the text is output to our label:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_10_13.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
- en: How it works...
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What we need to keep in mind here from the code we created is that there is
    `ObserveOn` and `Subscribe`. You should not confuse the two. In most cases, when
    dealing with schedulers, you will use `ObserveOn`. The `ObserveOn` method allows
    you to parameterize where the `OnNext`, `OnCompleted`, and `OnError` messages
    run. With `Subscribe`, we parameterize where the actual subscribe and unsubscribe
    code runs.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to remember that Rx uses the threading timers (`System.Threading.Timer`)
    as a default, which is why we encountered the cross-thread violation earlier.
    As you saw though, we used schedulers to parameterize which timer to use. The
    way schedulers do this is by exposing three components. These are as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: The scheduler's ability to perform some action
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The order in which the action or work to be performed is executed
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A clock that allows the scheduler to have a notion of time
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The use of a clock is important because it allows the developer to use timers
    on remote machines; for example (where there might be a time difference between
    you and them), to tell them to perform an action at a particular time.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Debugging lambda expressions
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The ability to debug lambda expressions has been around since Visual Studio
    2015\. This is a fantastic addition to the features of our favorite IDE. It allows
    us to check the results of a lambda expression on the fly and modify the expression
    to test different scenarios.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will create a very basic lambda expression and change it in the Watch window
    to produce a different value.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a console application and add a class called `LambdaExample` to the
    console application. Add a property to this class called `FavThings`:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the console application, create a `List<LambdaExample>` object and add a
    few of your favorite things to this list:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then, create an expression to return only the things starting with the string
    `"Sum"`. Here, we would obviously expect to see `Summer Rain` as a result:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Place a breakpoint on the expression and run your application. When the code
    stops at the breakpoint, you can copy the lambda expression:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_10_14.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
- en: 'Paste the lambda expression `MyFavoriteThings.Where(feature => feature.FavThings.StartsWith("Sum"))` into
    your Watch windows and change the string in the `StartsWith` method from `Sum`
    to `Ice`. You will see that the result has changed and now displays an `Ice-cream` string:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B06434_10_15.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
- en: Note that if you are using Visual Studio 2017 RC, debugging lambda expressions
    will probably not work. You will receive anything from Internal error in the expression
    evaluator to a message stating Expression cannot contain lambda expression.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果您正在使用Visual Studio 2017 RC，调试lambda表达式可能不起作用。您可能会收到从表达式评估器中的内部错误到包含lambda表达式的消息的任何内容。
- en: How it works...
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理是这样的…
- en: In this way, we're able to change and debug a lambda expression easily. This
    is something that was not possible in the previous versions before Visual Studio
    2015\. It is obviously of great importance to know this tip when working with
    these expressions.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们能够轻松地更改和调试lambda表达式。这在Visual Studio 2015之前的旧版本中是不可能的。显然，在处理这些表达式时，了解这个技巧非常重要。
- en: Another point to note is that you can do the same thing from the Immediate window
    in Visual Studio 2017, as well as pinned variables from the lambda expression.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个要注意的重点是，您可以在Visual Studio 2017的Immediate窗口中执行相同的操作，以及从lambda表达式中固定变量。
