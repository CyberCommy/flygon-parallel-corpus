- en: Introduction to Event Stream Programming Using C++
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter will be the last in the series of pre-requisite chapters required
    for programming reactive systems using C++. The reason why we need to go through
    quite a number of concepts is due to the fact that the reactive programming model
    unifies a lot of computing concepts in realizing its robust programming model.
    To start thinking in a reactive way, a programmer has to be familiar with object-oriented
    programming, functional programming, language-level concurrency, lock-free programming,
    the asynchronous programming model, design patterns, scheduling algorithms, data
    flow programming model, declarative-style programming, and even a bit of graph
    theory! We started the book with a peek into the event-driven programming models
    of various GUI systems and ways to structure our code around them. We covered
    the core essence of Modern C++ [Chapter 2](e1c95513-a3a7-40f2-ac25-9f95cbd9a2e6.xhtml),
    *A Tour of Modern C++ and its Key Idioms*. In [Chapter 3](16bbadb9-c545-44b1-8edb-82ab82a83394.xhtml), *Language-Level
    Concurrency and Parallelism in C++*, and [Chapter 4](80c4a483-89c7-45fc-a83f-736a1817126e.xhtml),
    *Asynchronous and Lock-Free Programming in C++*, we covered the language-level
    concurrency supported by the C++ language and lock-free programming, respectively.
    In [Chapter 5](c73fa9f3-6f2b-47f6-946d-155446d3225f.xhtml), *Introduction to Observables*,
    we focused on how to put the reactive programming model into perspective by dealing
    with it in the context of GOF patterns. What is left is event Stream programming.
    Now we will be focusing on the processing of event Streams or event Stream programming.
    In this chapter, we will look at the following:'
  prefs: []
  type: TYPE_NORMAL
- en: What is the Stream programming model?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advantages of the Stream programming model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stream programming using C++ with a public domain library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stream programming using Streamulus
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Event Stream programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is Stream programming model?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we get into the topic of the Stream programming model, we will take a
    step back to look at parallels with the POSIX shell programming model. In a typical
    command line shell program, every command is a program and every program is a
    command. We can pipe the output of one program to another program after achieving
    a computational objective or task. In effect, we can chain a series of commands 
    to achieve bigger computational task. We can see it as a stream of data passing
    through a series of filters or transformations to fetch the output. We can also
    call the preceding process as *command composition*. There are real-life cases
    where huge programs are being replaced by small amount of shell code using *command
    composition* . The same process can be realized in a C++ program, by treating
    the input of a function as a stream, sequence, or list. The data can be passed
    from one function or function object (aka functor)  to another as a standard data
    container.
  prefs: []
  type: TYPE_NORMAL
- en: 'Dr. Donald Knuth, the legendary computer scientist and Stanford University
    Professor was asked to write a program that:'
  prefs: []
  type: TYPE_NORMAL
- en: Reads a text file and determines *n* frequently used words
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prints out a sorted list of words along with their frequencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Knuth''s solution was a ten-page Pascal program! Doug McIlroy realized the
    same with just the following shell script:'
  prefs: []
  type: TYPE_NORMAL
- en: '`tr -cs A-Za-z '' n '' | tr A-Z a-z | sor t | uniq -c | sor t -rn | sed ${1}q`So
    much for the power of command composition.'
  prefs: []
  type: TYPE_NORMAL
- en: Advantages of the Stream programming model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Traditional OOP programs model hierarchies well, and processing hierarchies
    is mostly a difficult process compared to processing a linear collection. In the
    case of the Stream programming model, we can treat the input as a stream of entities
    put into a container and the output as a bag of entities, without modifying the
    input data stream. Using C++ generic programming techniques, we can write container-agnostic
    code to process streams. Some advantages of this model are:'
  prefs: []
  type: TYPE_NORMAL
- en: Stream programming simplifies program logic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Streams can support lazy evaluation and functional style transforms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Streams are better suited for the concurrent programming model (Source Streams
    are immutable)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can compose functions to create higher-order functions to process them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Streams facilitate the declarative programming model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They can aggregate, filter, and transform data from different sources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They decouple data sources and the entities that process them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They improve code readability  (developers can comprehend code faster)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They can exploit data parallelism and task parallelism
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can leverage hundreds of well-defined Stream operators (algorithms) to process
    data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applied Stream programming using the Streams library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will introduce  the topic of Stream programming using the
    *`Streams` *library ,a public domain library written by Jonah Scheinerman. The
    library is hosted at [https://github.com/jscheiny/Streams ](https://github.com/jscheiny/Streams)and 
    the API documentation is available from [http://jscheiny.github.io/Streams/api.html#](http://jscheiny.github.io/Streams/api.html).
    An introduction has been given as following  (taken from the library GitHub page):'
  prefs: []
  type: TYPE_NORMAL
- en: '`Streams` is a C++ library that provides lazy evaluation and functional-style
    transformations on data, to ease the use of C++ standard library containers and
    algorithms. `Streams` supports many common functional operations such as map,
    filter, and reduce, as well as various other useful operations such as various
    set operations (union, intersection, difference), partial sum, and adjacent difference,
    as well as many others.'
  prefs: []
  type: TYPE_NORMAL
- en: We can see that a programmer who is familiar with the **standard template library** (**STL**)
    will clearly be at ease with this library. The STL Containers are treated as 
    Stream data source and  the STL algorithms can be considered  as  transformations 
    on the Stream data source. The library uses functional programming idioms supported
    by Modern C++ and also supports lazy evaluation. The concept of lazy evaluation
    is very significant here, as it is the corner stone of functional programming
    model and Rx programming  model.
  prefs: []
  type: TYPE_NORMAL
- en: Lazy evaluation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In programming languages, there are two prominent  ways to evaluate arguments
    to a function they are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Applicative-order evaluation** (**AO**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Normal-order evaluation** (**NO**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the case of AO, arguments are evaluated in the calling context, before being
    passed to the callee. Most conventional programming languages follow this method.
    In the case of NO, the evaluation of the variables is deferred until the result
    of the computation is warranted in the context of the callee. Some functional
    programming languages, such as Haskell, F#, and ML, follow the NO model. In functional
    programming languages, most of the evaluation of functions is referentially transparent
    (the invocation of the functions does not produce side-effects); we need to evaluate
    the expression only once (for a particular value as argument) and the result can
    be shared, when the evaluation with the same function with the same arguments
    appears once again for execution. This is called **lazy evaluation**. Thus, lazy
    evaluation can be considered a NO  coupled with sharing of the previously computed
    results. The C++ programming language does not provide support for lazy evaluation
    of function parameters by default, but can be emulated using different techniques
    available  such as Variadic Templates and expression templates.
  prefs: []
  type: TYPE_NORMAL
- en: A simple Stream program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To get started with the `Streams` library, let''s write a small program to
    generate a Stream of numbers and compute the square of the first ten numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The previous code snippet generates a list of values (using `MakeStream::counter(1)`
    ) and the generated values will be transformed using the map function (in this
    case, computing the square). When ten elements are assembled (`limit(10)`) in
    the Stream, we call the operator sum on the Stream.
  prefs: []
  type: TYPE_NORMAL
- en: Aggregating values using the Stream paradigm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we understand the basics of Stream programming as envisaged by the
    Stream library, let''s write a piece of code that computes the average of numbers
    stored in a  std::vector container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The previous code snippet creates a Stream out of `std::vector` and applies
    a reduction process using the `std::plus` functor. It is tantamount to aggregating
    the values in the Stream. Finally, we divide the aggregated value with by the
    of elements in `std::vector`.
  prefs: []
  type: TYPE_NORMAL
- en: The STL and the Stream paradigm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Streams` library can work seamlessly with the STL containers. The following
    code snippets will map a function on Streams and resultant data is being transformed
    to a vector container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The previous code snippet converts `std::vector<double>` into a Stream, applies
    the square function, and converts the stuff back to `std:::vector<double>`. After
    that, the vector is iterated to print the content. The `Streams` library documentation
    is very elaborate and contains lot of code samples that you can use to write code
    for production-quality applications. Consult the API documentation, available
    at [http://jscheiny.github.io/Streams/api.html](http://jscheiny.github.io/Streams/api.html).
  prefs: []
  type: TYPE_NORMAL
- en: A word about the Streams library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Streams` library is a well-designed piece of software with an intuitive
    programming model. Any programmer who has worked with a functional programming
    and Streams programming will really be comfortable with it in a matter of hours.
    Those of you who are familiar with STL will also find the library to be very intuitive
    as well. From a programming model perspective, the API can be divided into:'
  prefs: []
  type: TYPE_NORMAL
- en: Core methods (Stream initialization)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generators (Stream creators)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stateful intermediate operators (functional immutable transformations)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stateless intermediate operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Terminal operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The previously mentioned documentation  of the library sheds light on the each
    of the aspects of this wonderful library.
  prefs: []
  type: TYPE_NORMAL
- en: Event Stream programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have got some kind of understanding about the working of  Stream programming
    model. When we process events as Streams, it can be categorized  as Event Stream
    programming. In the programming community, event-driven architecture is being
    projected as a better model for crafting modern programs. A wonderful example
    of software that relies on Event Stream programming is version control systems.
    In a version control system, everything is treated as an event. Typical examples
    include checking out the code, commits, rollbacks, and branching.
  prefs: []
  type: TYPE_NORMAL
- en: Advantages of Event Stream programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Aggregating events as a Stream and processing  them in downstream  systems
    has many advantages compared to the traditional Event programming model. Some
    of the key advantages are:'
  prefs: []
  type: TYPE_NORMAL
- en: Event source and Event sinks are not coupled
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Event sinks can process events without bothering with Event sources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can apply Stream processing operators to process and filter Streams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The transformation and filtering can be done at the aggregation level
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The events can be propagated through a Stream-processing network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Event processing can be parallelized easily (declarative parallelism )
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Streamulus library and its programming model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Streamulus library, from Irit Katiel, is a library that makes the programming
    of event Streams easier with a programming model, which implements **domain-specific
    embedded language** (**DSEL**). To understand the programming model, let''s inspect
    a program that Streams data into a class that aggregates received data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding functor just accumulates the value passed into a static variable.
    For each invocation of the function by the `Streamify` template (`Streamify<print>(s)`
    ), the value accumulated so far will be printed to the console. More on this can
    be understood by going through the listing as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We create a Stream using the `NewInputStream<T>` template method. The function
    expects a parameter that determines whether logs should be printed to the console.
    By giving the second parameter as `false`, we can turn off verbose mode. We need
    to create an instance of the Streamulus engine to orchestrate the data flow. The
    Streamulus engine does a topological sort of the Stream expressions to determine
    the change propagation order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We use the `Streamify<f>` strop (Stream operator) to serialize calls to the
    print functor we just created. We can create our own Stream operators, and usually
    Streamify would suffice for us. Streamfiy creates a single event functor and a
    strop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The previous code snippets emit some values into the Stream. We would be able
    to see the accumulated sum to be printed on the console three times. In the main
    function, we invoke the `hello_Stream` function to trigger all the actions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have learned how the Streamulus systems work with a simple program,
    let''s write a program that clarifies the semantics of the library much better.
    The following program Streams data through a host of single argument functors
    to demonstrate the functioning of the library. We also use Stream expressions
    liberally in the listings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding set of functors is arithmetical in nature. The `twice` functor
    doubles the argument, the `neg` functor flips the sign of the argument, and the
    `half` functor scales the value by 0.5 to halve the value of the argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'How the preceding two function objects work is obvious—the first one (print)
    just outputs the value to the console. `as_string` converts the argument to the
    string using the `std::stringStream` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '`DataFlowGraph()` created `InputStream<T>` to process a double-valued Stream.
    After instantiating the `Streamulus` object (engine), we glued a series of functors
    through a `Streamify<f>` Stream operator. The operation can be considered a kind
    of functional composition with a single argument function. After setting up the
    mechanism, we injected data to the Stream using the `InputStreamPut` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The Streamulus library – a peek into its internals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Streamulus` library basically creates a change propagation graph to ease
    Stream processing. We can treat the node of a graph as computation, and the edges
    as buffers that take the data from one node to another. Almost all data flow systems
    follow the same semantics. The `Streamulus` library helps us to build a graph
    of dependent variables, which help us propagate the changes to child nodes. The
    order in which variables should be updated will be defined by doing a topological
    sort on the graph.
  prefs: []
  type: TYPE_NORMAL
- en: 'A graph is a data structure where a set of dependent entities is represented
    as nodes (or vertices) and their relationship (as edges) between them. In computer
    science, especially when it comes to scheduling and analyzing dependencies, a
    particular version of graph, called directed acyclic graphs, is preferred for
    its unique qualities. A DAG is a directed graph without cycles. We can perform
    an operation called a topological sort to determine the linear order in which
    the entities are dependent. The topological sorting can only be performed on a
    DAG and they are not unique. In the following graph, we can find multiple topological
    orders:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2b411853-e46e-490e-b720-cf0c6e626342.png)'
  prefs: []
  type: TYPE_IMG
- en: The Streamulus Library – a look into expression processing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will take a look at how `Streamulus` processes expressions using a simple
    Stream expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The `- (x+1)` Stream expression will produce the following graph. The term 
    strop stands for Stream operators and each of the nodes is organized as a strop:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bc54a6ad-64ad-4387-be8a-641b1f3cc85c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once the node has been labeled correctly, a topological sort on the graph will
    be done to determine the execution order. The following diagram shows a topological
    sort (you can have multiple topological orders):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e5e60556-9541-400f-8cc2-210cfa39479f.png)'
  prefs: []
  type: TYPE_IMG
- en: The Streamulus engine walks through the graph to find out the order in which
    Stream operators have to be applied on the data propagating through the network.
    The **TO** label stands for **topological order**. After topological sort, a linear
    list of Stream operators ranked by Topological order will be produced. The execution
    engine will execute the code in topological order.
  prefs: []
  type: TYPE_NORMAL
- en: The Streamulus engine performs its magic using the boost proto library. The
    latter manages expression trees for the Streamulus library. To really go through
    the source code of the library, you need to be comfortable with template meta
    programming, especially expression templates. Meta programming is a technique
    where we write code to generate or transform source code. It turned out that the
    C++ template mechanism was Turing complete by Erwin Unruh in the year 1994.
  prefs: []
  type: TYPE_NORMAL
- en: The spreadsheet Library — a change-propagation engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An electronic spreadsheet is often touted as the quintessential example of a
    reactive system. In a spreadsheet, a page is organized as a matrix of cells. When
    there is a  change in  a cell, all dependent cells will be re-computed to reflect
    the change. This happens for every cell. In effect, modelling a spreadsheet is
    easy, if you have a library such as Streamulus. Fortunately, the designer of the
    library itself wrote another library that relies on Streamulus for change propagation.
  prefs: []
  type: TYPE_NORMAL
- en: Spreadsheet is a C++ library that enables spreadsheet-programming, that is,
    setting up variables (cells) where each cell is assigned an expression that can
    contain the values of other cells. Changes are propagated to all dependent cells,
    as in a spreadsheet. Spreadsheet was developed to demonstrate the use of Streamulus.
    Spreadsheet is a header-only library. It uses boost and Streamulus. So put these
    three libraries in your include path. The details of the library can be found
    at [https://github.com/iritkatriel/spreadsheet](https://github.com/iritkatriel/spreadsheet).
  prefs: []
  type: TYPE_NORMAL
- en: 'We will go through a sample program that leverages the `Spreadsheet` library,
    which is included in the project''s GitHub repository (`main.cpp`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous code snippet creates a set of cells, which acts as a container
    for IEEE double-precision floating-point numbers. After we have initialized the
    cell, we will start mutating the values of the cell with the following set of
    expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will mutate the values with the preceding expressions. After each assignment
    through the `Set` method, a computational pass will get triggered through the
    cells. The `Streamulus` library manages the underlying flow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous code snippet prints the value of the cells to the console. Once
    again, we will change the cells'' expressions to trigger a computational flow
    graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The source code of the library can be perused to understand the internal workings
    of the library. A spreadsheet is a wonderful example of how the Streamulus library
    can be leveraged to write robust software.
  prefs: []
  type: TYPE_NORMAL
- en: RaftLib – another Stream-processing library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: RaftLib  is a library that is worth checking out for anyone (developers) who
    are interested in doing parallel programming or Stream-based programming. The
    library is available at [https://github.com/RaftLib/RaftLib](https://github.com/RaftLib/RaftLib)
    . The following description is available from the preceding site
  prefs: []
  type: TYPE_NORMAL
- en: RaftLib is a C++ Library for enabling Stream/data-flow parallel computation.
    Using simple right-shift operators (just like the C++ Streams that you would use
    for string manipulation), you can link parallel compute kernels together. With
    RaftLib, we do away with explicit use of pthreads, std::thread, OpenMP, or any
    other parallel threading library. These are often mis-used, creating non-deterministic
    behavior. RaftLib's model allows lock-free FIFO-like access to the communications
    channels connecting each compute kernel. The full system has many auto-parallelization,
    optimization, and convenience features that enable relatively simple authoring
    of performant applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'We won''t be covering `RaftLib` in detail in this particular book, due to space
    constraints. A wonderful talk by the author of the library (Jonathan Beard) is
    available at [https://www.youtube.com/watch?v=IiQ787fJgmU](https://www.youtube.com/watch?v=IiQ787fJgmU).
    Let''s go through a code snippet that shows the working of this library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As a programmer, you are supposed to define a kernel for custom computation
    and use the `>>` operator to Stream the data. In the preceding code, the `hi`
    class is such a kernel. Consult the `Raftlib` documentation (available at the
    preceding RaftLib URL) and source code examples to learn more about this wonderful
    library.
  prefs: []
  type: TYPE_NORMAL
- en: What do these things have to do with Rx programming?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Basically, the reactive programming model treats events as a Stream of data
    propagating through a change-propagation graph. For this to happen, we need to
    aggregate event elements to a container-based data structure and create a Stream
    out of that. Sometimes, we even apply statistical techniques to sample events,
    if there is plenty of data. The generated Stream can be filtered and transformed
    at the source level using functional transformation, before being notified to
    the observers who are  waiting to get notified. The event source is supposed to
    take a fire-and-forget approach to event-Stream dispatch, to avoid the coupling
    between Event source sinks and the Event sinks . When to dispatch the event data 
    will be determined by scheduling software which runs the functional transformation
    pipeline in an asynchronous manner. So, the key elements of reactive programming
    are:'
  prefs: []
  type: TYPE_NORMAL
- en: Observables (a Stream of data in which others are interested)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Observer (entities which is interested in an Observable and Subscribe for notification)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scheduler (which determines when the Stream should be propagated down the network)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functional Operators (event filtering and transformation)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In a nutshell, the `Scheduler` (part of the Rx Engine) takes an `Observable`
    for filtering and transformation asynchronously before notifying the subscribers,
    as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/410323d7-7640-424d-b00e-07089e08888d.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered the topic of event Stream programming. Treating
    events as Streams has many advantages over the traditional event-processing model.
    We started with the `Streams` library and learned about its programming model.
    We also wrote some programs to familiarize ourselves with the library and its
    semantics. The `Streams` library has excellent documentation and you should consult
    its documentation to learn more about it. After Streams library, we looked at
    the Streamulus library, which provides a DSEL approach to the manipulation of
    event Streams. We wrote a couple of programs and also studied some sample programs
    that come with the `Streamulus` library. We also mentioned the `Raftlib` library,
    an alternative library for the Stream processing . With the coverage of Event
    Stream programming model, We have now finished dealing with the prerequisites
    for understanding reactive programming in general and the RxCpp library in particular.
    In the next chapter, we will start using the RxCpp library to get into the programming
    model of the reactive system design.
  prefs: []
  type: TYPE_NORMAL
