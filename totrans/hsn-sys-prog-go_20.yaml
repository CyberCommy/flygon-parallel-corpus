- en: Using Reflection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is about **reflection**, a tool that allows an application to inspect
    its own code, overcoming some of the limitations imposed by Go static typing and
    its lack of generics. This can be very helpful, for instance, for producing packages
    that are capable of handling any type of input that they receive.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding interfaces and type assertions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning about interaction with basic types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using reflection with complex types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Evaluating the cost of reflection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning the best practices of reflection usage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter requires Go to be installed and your favorite editor to be set
    up. For more information, refer to [Chapter 3](602a92d5-25f7-46b8-83d4-10c6af1c6750.xhtml), *An
    Overview of Go*.
  prefs: []
  type: TYPE_NORMAL
- en: What's reflection?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reflection is a very powerful feature that allows **meta-programming**, the
    capability of an application to examine its own structure. It's very useful to
    analyze the types in an application at runtime, and it is used in many encoding
    packages such as JSON and XML.
  prefs: []
  type: TYPE_NORMAL
- en: Type assertions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We briefly mentioned how type assertions work in [Chapter 3](https://cdp.packtpub.com/hands_on_systems_programming_with_go/wp-admin/post.php?post=38&action=edit#post_26),* An
    Overview of Go*. A type assertion is an operation that allows us to go from interface
    to concrete type and vice versa. It takes the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The first version is unsafe, and it assigns a value to a single variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using assertion as an argument of a function also counts as unsafe. This type
    of operation panics if the assertion is wrong:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: A full example is available here: [https://play.golang.org/p/hNN87SuprGR](https://play.golang.org/p/hNN87SuprGR).
  prefs: []
  type: TYPE_NORMAL
- en: 'The second version uses a Boolean a as second value, and it will show the success
    of the operation. If the assertion is not possible, the first value will always
    be a zero value for the asserted type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: A full example is available here: [https://play.golang.org/p/BIba2ywkNF_j](https://play.golang.org/p/BIba2ywkNF_j).
  prefs: []
  type: TYPE_NORMAL
- en: Interface assertion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Assertion can also be done from one interface to another. Imagine having two
    different interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s define a type that implements one of them and another that implements
    both:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If we define a new variable for the first interface, the assertion to the second
    is going to be successful only if the underlying value has a type that implements
    both; otherwise, it''s going to fail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: A full example is available here: [https://play.golang.org/p/bX2rnw5pRXJ](https://play.golang.org/p/bX2rnw5pRXJ).
  prefs: []
  type: TYPE_NORMAL
- en: 'A use case scenario could be having the `io.Reader` interface, checking out
    whether it is also an `io.Closer` interface, and wrapping it in the `ioutil.NopCloser`
    function (which returns an `io.ReadCloser` interface) if not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: A full example is available here: [https://play.golang.org/p/hUEsDYHFE7i](https://play.golang.org/p/hUEsDYHFE7i).
  prefs: []
  type: TYPE_NORMAL
- en: There is an important aspect to interfaces that we need to underline before
    jumping onto reflection—its representation is always a tuple interface-value where
    the value is a concrete type and cannot be another interface.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding basic mechanics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `reflection` package allows you to extract the type and value from any `interface{}` variable.
    This can be done using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Using `reflection.TypeOf` returns the type of the interface in a `reflection.Type ` variable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `reflection.ValueOf` function returns the value of the interface using the `reflection.Value` variable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Value and Type methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A `reflect.Value` type also carries information of the type that can be retrieved
    with the `Type` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: A full example is available here: [https://play.golang.org/p/tmYuMc4AF1T](https://play.golang.org/p/tmYuMc4AF1T).
  prefs: []
  type: TYPE_NORMAL
- en: Kind
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another important property of `reflect.Type` is `Kind`, which is an enumeration
    of basic types and generic complex types. The main relationship between `reflect.Kind`
    and `reflect.Type` is that the first represents the memory representation of the
    second.
  prefs: []
  type: TYPE_NORMAL
- en: 'For built-in types, `Kind` and `Type` are the same, but for custom types they
    will differ—the `Type` value will be what is expected, but the `Kind` value will
    be one of the built-in ones on which the custom type is defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: A full example is available here: [https://play.golang.org/p/qjiouk88INn](https://play.golang.org/p/qjiouk88INn).
  prefs: []
  type: TYPE_NORMAL
- en: 'For the composite type, it will reflect just the main type and not the underlying
    ones. This means that a pointer to a structure or to an integer is the same kind,
    `reflect.Pointer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: A full example is available here: [https://play.golang.org/p/-uJjZvTuzVf](https://play.golang.org/p/-uJjZvTuzVf).
  prefs: []
  type: TYPE_NORMAL
- en: The same reasoning applies to all the other composite types, such as arrays,
    slices, maps, and channels.
  prefs: []
  type: TYPE_NORMAL
- en: Value to interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the same way that we can get `reflect.Value` from any `interface{}` value, 
    we can execute the reverse operation and obtain `interface{}`from `reflect.Value`.
    This is done using the `Interface` method of the reflected value, and be cast
    to a concrete type if necessary. If the interested method or function accepts
    an empty interface, such as `json.Marshal` or `fmt.Println`, the returned value
    can be passed directly without any casting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: A full example is available here: [https://play.golang.org/p/1942Dhm5sap](https://play.golang.org/p/1942Dhm5sap).
  prefs: []
  type: TYPE_NORMAL
- en: Manipulating values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Transforming values in their reflection and going back to the value is not very
    useful if the values themselves cannot be changed. That's why our next step is seeing
    how to change them using the `reflection` package.
  prefs: []
  type: TYPE_NORMAL
- en: Changing values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is a series of methods of the `reflect.Value` type that allow you to
    change the underlying value:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Set`: Uses another `reflect.Value`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SetBool`: Boolean'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SetBytes`: Byte slice'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SetComplex`: Any complex type'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SetFloat`: Any float type'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SetInt`: Any signed integer type'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SetPointer`: A pointer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SetString`: A string'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SetUint`: Any unsigned integer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In order to set a value, it needs to editable, and this happens in specific
    conditions. To verify this, there is a method, `CanSet`, which returns `true`
    if a value can be changed. If the value cannot be changed and a `Set` method is
    called anyway, the application will panic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: A full example is available here: [https://play.golang.org/p/hKn8qNtn0gN](https://play.golang.org/p/hKn8qNtn0gN).
  prefs: []
  type: TYPE_NORMAL
- en: In order to be changed, a value needs to be addressable. A value is addressable
    if it's possible to modify the actual storage where the object is saved. When
    creating a new value using a basic built-in type, such as `string` , what gets
    passed to the function is `interface{}` , which hosts a copy of the string.
  prefs: []
  type: TYPE_NORMAL
- en: Changing this copy would result in a variation of the copy with no effect on
    the original variable. This would be incredibly confusing, and it would make the
    usage of a sensible tool such as reflection, even harder. That's why, instead
    of this useless behavior, the `reflect` package panics—it's a design choice. This
    explains why the last example panicked.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create `reflect.Value` using the pointer to the value we want to change,
    and access the value using the `Elem` method. This will give us a value that is
    addressable because we copied the pointer instead of the value, so the reflected
    value is still a pointer to the variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: A full example is available here: [https://play.golang.org/p/-X5JsBrlr4Q](https://play.golang.org/p/-X5JsBrlr4Q).
  prefs: []
  type: TYPE_NORMAL
- en: Creating new values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `reflect` package allows us also to create new values using types. There
    are several functions that allow us to create a value:'
  prefs: []
  type: TYPE_NORMAL
- en: '`MakeChan` creates a new channel value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MakeFunc` creates a new function value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MakeMap` and `MakeMapWithSize` creates a new map value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MakeSlice` creates a new slice value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`New` creates a new pointer to the type'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NewAt` creates a new pointer to the type using the selected address'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Zero` creates a zero value of the selected type'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code shows how to create new values in a couple of different
    ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: A full example is available here: [https://play.golang.org/p/wCTILSK1F1C](https://play.golang.org/p/wCTILSK1F1C).
  prefs: []
  type: TYPE_NORMAL
- en: Handling complex types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After seeing how to handle the reflection basics, we will now see how complex
    data types such as structures and maps can also be handled using reflection.
  prefs: []
  type: TYPE_NORMAL
- en: Data structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For changeability, structures work in exactly the same way as the basic types;
    we need to obtain the reflection of the pointer, then access its element in order
    to be able to change the value, because using the structure directly would produce
    a copy of it and it would panic when changing values.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can replace the value of the entire structure using the `Set` method, after
    obtaining the new value''s reflection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: A full example is available here: [https://play.golang.org/p/mjb3gJw5CeA](https://play.golang.org/p/mjb3gJw5CeA).
  prefs: []
  type: TYPE_NORMAL
- en: Changing fields
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Individual fields can also be modified using `Field` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Field` returns a field using its index'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FieldByIndex` returns a nested field using a series of indexes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FieldByName` returns a field using its name'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FieldByNameFunc` returns a field using  `func(string) bool` in the name'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s define a structure to change the values of the fields, using both simple
    and complex types, with at least one unexported field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have the structure, we can try to access the fields in different
    ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: A full example is available here: [https://play.golang.org/p/z5slFkIU5UE](https://play.golang.org/p/z5slFkIU5UE).
  prefs: []
  type: TYPE_NORMAL
- en: When working with `reflect.Value` and structure fields, what you get are other
    values, indistinguishable from the struct. When handling `reflect.Type` instead,
    you obtain a `reflect.StructField` structure, which is another type that carries
    all the information of the field with it.
  prefs: []
  type: TYPE_NORMAL
- en: Using tags
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A structure field carries plenty of information, from the field name and index
    to its tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'A `reflect.StructField` value can be obtained using the `reflect.``Type` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Field`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FieldByName`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FieldByIndex`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'They are the same methods used by `reflect.Value`, but they return different
    types. The `NumField` method returns the total number of fields for the structure,
    allowing us to execute an iteration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: A full example is available here: [https://play.golang.org/p/nkEADg77zFC](https://play.golang.org/p/nkEADg77zFC).
  prefs: []
  type: TYPE_NORMAL
- en: 'Tags are really central to reflection because they can store extra information
    about a field and how other packages behave with it. To add a tag to a field,
    it needs to be inserted after the field name and type in a string, which should
    have a `key:"value"` structure. One field can have multiple tuples in its tag,
    and each pair is separated by a space. Let''s look at a practical example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This structure has two fields, both with tags, and each tag has two pairs.
    The `Get` method returns the value for a specific key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: A full example is available here: [https://play.golang.org/p/P-Te8O1Hyyn](https://play.golang.org/p/P-Te8O1Hyyn).
  prefs: []
  type: TYPE_NORMAL
- en: Maps and slices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can easily use reflection to read and manipulate maps and slices. Since
    they are such important tools for writing applications, let's see how to execute
    an operation using reflection.
  prefs: []
  type: TYPE_NORMAL
- en: Maps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A `map` type allows you to get the type of both value and key, using the `Key`
    and `Elem` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'A full example is available here: [https://play.golang.org/p/j__1jtgy-56](https://play.golang.org/p/j__1jtgy-56).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The values can be accessed in all the ways that a map can be accessed normally:'
  prefs: []
  type: TYPE_NORMAL
- en: By getting a value using a key
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By ranging over keys
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By ranging over values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s see how it works in a practical example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Note that we don't need to pass a pointer to the map to make it addressable,
    because maps are already pointers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each method is pretty straightforward and depends on the type of access you
    need to the map. Setting values is also possible, and should always be possible
    because maps are passed by reference. The following snippet shows a practical
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: A full example is available here: [https://play.golang.org/p/JxK_8VPoWU0](https://play.golang.org/p/JxK_8VPoWU0).
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also possible to use this method to unset a variable, like we do when
    calling the `delete` function using the zero value of `reflect.Value` as a second
    argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: A full example is available here: [https://play.golang.org/p/4bPqfmaKzTC](https://play.golang.org/p/4bPqfmaKzTC).
  prefs: []
  type: TYPE_NORMAL
- en: The output will have one less field as it gets deleted because the length of
    the map decreases after `SetMapIndex`.
  prefs: []
  type: TYPE_NORMAL
- en: Slices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A slice allows you to get its size with the `Len` method and to access its
    elements using the `Index` method. Let''s see that in action in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: A full example is available here: [https://play.golang.org/p/ifq0O6bFIZc.](https://play.golang.org/p/ifq0O6bFIZc)
  prefs: []
  type: TYPE_NORMAL
- en: 'Since it is always possible to get the address of a slice element, it is also
    possible to use `reflect.Value` to change the content of the respective element
    in the slice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: A full example is available here: [https://play.golang.org/p/onuIvWyQ7GY](https://play.golang.org/p/onuIvWyQ7GY).
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also possible to append to a slice using the `reflect` package. If the
    value is obtained from the pointer to the slice, the result of this operation
    can also be used to replace the original slice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: A full example is available here: [https://play.golang.org/p/2hXRg7Ih9wk](https://play.golang.org/p/2hXRg7Ih9wk).
  prefs: []
  type: TYPE_NORMAL
- en: Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Method and function handling with reflection allow you to gather information
    about the signature of a certain entry and also to invoke it.
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing a function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are a few methods of `reflect.Type` in the package that will return information
    about a function. These methods are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`NumIn`: Returns the number of input arguments of the function'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`In`: Returns the selected input argument'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IsVariadic`: Tells you if the last argument of the function is variadic'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NumOut`: Returns the number of output values returned by the function'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Out`: Returns the `Type` value of the select output'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Note that all these methods will panic if the kind of `reflect.Type` is not
    `Func`. We can test these methods by defining a series of functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can use the method from `reflect.Type` to obtain information about them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: A full example is available here: [https://play.golang.org/p/LAjjhw8Et60](https://play.golang.org/p/LAjjhw8Et60).
  prefs: []
  type: TYPE_NORMAL
- en: In order to obtain the name of the functions, we use the `runtime.FuncForPC`
    function, which returns `runtime.Func`  containing methods that will expose runtime
    information about the function—`name`, `file`, and `line`. The function takes `uintptr`
    as an argument, which can be obtained with `reflect.Value` of the function and
    its `Pointer` method.
  prefs: []
  type: TYPE_NORMAL
- en: Invoking a function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While the type of the function shows information about it, in order to call
    a function, we need to use its value.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will pass the function a list of argument values and get back the ones returned
    by the function call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: A full example is available here: [https://play.golang.org/p/jPxO_G7YP2I](https://play.golang.org/p/jPxO_G7YP2I).
  prefs: []
  type: TYPE_NORMAL
- en: Channels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reflection allows us to create channels, send and receive data, and also to
    use `select` statements.
  prefs: []
  type: TYPE_NORMAL
- en: Creating channels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A new channel can be created via the `reflect.MakeChan` function, which requires
    a `reflect.Type` interface value and a size:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: A full example is available here: [https://play.golang.org/p/7_RLtzjuTcz](https://play.golang.org/p/7_RLtzjuTcz).
  prefs: []
  type: TYPE_NORMAL
- en: Sending, receiving, and closing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `reflect.Value` type offers a few methods that have to be used exclusively
    with channels, `Send` and `Recv` for sending and receiving, and `Close` for closing
    channels. Let''s take a look at a sample use case of these functions and methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: A full example is available here: [https://play.golang.org/p/Gp8JJmDbLIL](https://play.golang.org/p/Gp8JJmDbLIL).
  prefs: []
  type: TYPE_NORMAL
- en: Select statement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A `select` statement can be executed with the `reflect.Select` function. Each
    case is represented by a data structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'It contains the direction of the operation and both the channel and the value
    (for send operations). The direction can be either send, receive, or none (for
    default statements):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: A full example is available here: [https://play.golang.org/p/_DgSYRIBkJA](https://play.golang.org/p/_DgSYRIBkJA).
  prefs: []
  type: TYPE_NORMAL
- en: Reflecting on reflection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After talking how about how reflection works in all its aspects, we will now
    focus on its downside, when it is used in the standard library, and when to use
    it in packages.
  prefs: []
  type: TYPE_NORMAL
- en: Performance cost
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reflection allows code to be flexible and handles unknown data types by analyzing
    their memory representation. This is not cost-free and, besides complexity, another
    aspect that reflection influences is performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create a couple of examples to demonstrate how some trivial operations
    are much slower using reflection. We can create a timeout and keep repeating these
    operations in goroutines. Both routines will terminate when the timeout expires,
    and we will compare the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We can compare normal map writing with the same operation done with reflection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also test out how fast the reading is and the settings of a structure
    field, with and without reflection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: There is at least a 50% performance drop when executing operation via reflection,
    compared to the standard, static way of doing things. This drop could be very
    critical when performance is a very important priority in an application, but
    if that's not the case, then the use of reflection could be a reasonable call.
  prefs: []
  type: TYPE_NORMAL
- en: Usage in the standard library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are many different packages in the standard library that use the `reflect`
    package:'
  prefs: []
  type: TYPE_NORMAL
- en: '`archive/tar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`context`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`database/sql`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`encoding/asn1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`encoding/binary`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`encoding/gob`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`encoding/json`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`encoding/xml`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fmt`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`html/template`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`net/http`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`net/rpc`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sort/slice`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`text/template`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can reason about their approach to reflection, taking as an example the
    encoding packages. Each of these packages offers interfaces for encoding and decoding,
    for instance, the `encoding/json` package. We have the following interfaces defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The package first looks if the unknown type implements the interface while decoding
    or encoding, and, if not, it uses reflection. We can think of reflection as a
    last resource that the package uses. Even the `sort` package has a generic `slice`
    method that takes any slice using reflection to set values and a sorting interface
    that avoids using reflection.
  prefs: []
  type: TYPE_NORMAL
- en: There are other packages, such as `text/template` and `html/template`, that
    read runtime text files with instructions on which method or field to access or
    to use. In this case, there is no other way than reflection to accomplish it,
    and there is no interface that can avoid it.
  prefs: []
  type: TYPE_NORMAL
- en: Using reflection in a package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After seeing how reflection works and the kind of complications that it adds
    to code, we can think about using it in a package we are writing. One of the Go
    proverbs, from its creator Rob Pike, comes to the rescue:'
  prefs: []
  type: TYPE_NORMAL
- en: Clear is better than clever. Reflection is never clear.
  prefs: []
  type: TYPE_NORMAL
- en: The power of reflection is huge, but it also comes at the expense of making
    code more complicated and implicit. It should be used only when it's extremely
    necessary, as in the template scenario, and should be avoided in any other case,
    or at least offer an interface to avoid it, as in the encoding packages.
  prefs: []
  type: TYPE_NORMAL
- en: Property files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can try to use reflection to create a package that reads property files.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use reflection to create a package that reads property files:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we should do is define an interface that avoids using reflection:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can define a decoder structure that will feed on an `io.Reader` instance,
    using a line scanner to read the individual properties:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The decoder will also be used by the `Unmarshal` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'We can reduce the number of uses of reflection that we will do by building
    a cache of field names and indices. This will be helpful because the value of
    a field in reflection can only be accessed by an index, and not by a name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is defining the `Decode` method. This will receive a pointer
    to a structure and then proceed to process lines from the scanner and populate
    the structure fields:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The most important part of the work will be done by the private `decodeValue` method.
    The first thing will be verifying that the `Unmarshaller` interface is satisfied,
    and, if it is, using it. Otherwise, the method is going to use reflection to decode
    the value received correctly. For each type, it will use a different `Set` method
    from `reflection.Value`, and it will return an error if it encounters an unknown
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Using the package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To test whether the package behaves as expected, we can create a custom type
    that satisfies the `Unmarshaller` interface. The type implemented transforms the
    string into uppercase when decoding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can use the type as a structure field and we can verify that it gets
    transformed correctly in a `decode` operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we reviewed the Go memory model for interfaces in detail, highlighting
    that an interface always contains a concrete type. We used this information to
    get a better look at type casting and understand what happens when an interface
    gets cast to another.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we introduced the basic mechanics of reflection, starting with type and
    value, which are the two main types of the package. They represent, respectively,
    the type and value of a variable. Value allows you to read a variable content
    and also to write it if the variable is addressable. In order to be addressable,
    a variable needs to be accessed from its address, using a pointer, for instance.
  prefs: []
  type: TYPE_NORMAL
- en: We also saw how complex data types can be handled with reflection, seeing how
    to access structure field value. Data types of structure can be used to get metadata
    about fields, including name and tags, which are heavily used by encoding packages
    and other third-party libraries.
  prefs: []
  type: TYPE_NORMAL
- en: We saw how to create and operate with maps, including adding, setting, and deleting
    values. With slices, we saw how to edit their values and how to execute append
    operations. We also showed how to use a channel to send and receive data, and
    even how to use `select` statements in the same way we do with static-typed programming.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we listed where reflection is used in the standard library, and did
    a quick analysis of its computational cost. We concluded the chapter with some
    tips on how and when to use reflection in a library or in any application you
    are writing.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter is the last one of the book, and it explains how to leverage
    the existing C library in Go using CGO.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What's the memory representation of an interface in Go?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What happens when an interface type is cast to another one?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are `Value`, `Type` , and `Kind` in reflection?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does it mean if a value is addressable?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why are structure field tags important in Go?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What's the general trade-off of reflection?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Could you describe a good approach to using reflection?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
