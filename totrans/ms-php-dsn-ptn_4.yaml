- en: Chapter 4. Structural Design Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Structural design patterns provide different ways to create class structure;
    for example, this can be how we use encapsulation to create bigger objects from
    smaller ones. They exist to ease the design by allowing us to identify simple
    ways to realize these relationships between entities.
  prefs: []
  type: TYPE_NORMAL
- en: In the last chapter, we covered how creational patterns can be used to determine
    how objects should be created; with structural patterns, we can determine the
    structure and relationship between classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'After a brief note on Agile software architecture, in this chapter we will
    cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Decorator pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class Adapter pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Object Adapter pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flyweight pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Composite pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bridge pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Proxy pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Facade pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Agile software architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many organizations are leaning towards adopting an Agile form of project management.
    This bring about new concerns for the role of an architect; indeed, some view
    Agile and architecture to be in conflict. Two of the original signatories to the
    Agile manifesto, Martin Fowler and Robert Cecil Martin, have been vocally opposed
    to this idea. Indeed, Fowler is clear in clarifying the fact that while the Agile
    manifesto is hostile to large upfront design (such as the type you see in Prince2),
    Agile does not reject upfront design itself.
  prefs: []
  type: TYPE_NORMAL
- en: The computer scientist, Allen Holub, has a similar view. Agile focuses on doing
    things that are important for delivering software that is useful to the user,
    ahead of software that is merely useful for the salesman. In order for software
    to be of use in the long term it must be adaptable, extendable, and maintainable.
  prefs: []
  type: TYPE_NORMAL
- en: Fowler also has a vision for an architect within software development teams.
    Citing the fact that irreversible software is likely to give the most headaches
    later, this is where architectural decisions must lie. Above this, he claims that
    the role of an architect should be to seek to make these decisions reversible,
    thus mitigating the issue altogether.
  prefs: []
  type: TYPE_NORMAL
- en: During many large-scale software deployments, the phrase *we are at the point
    of no return* may be used. After the *point of no return*, it becomes unfeasible
    to revert the deployment to its original state. Software has its own *point of
    no return*, when it becomes the fact that software is harder to rewrite then it
    is to simply rebuild. While software may not reach the worst case of this *point
    of no return*, climbing up on the maintainability difficulty poses business difficulties.
  prefs: []
  type: TYPE_NORMAL
- en: Fowler also states that, in many cases, software architects do not even check
    that the software matches its original design. Through pair-programming with an
    architect, and indeed, the architect reviewing the code changes (that is, the
    pull requests), they can gain an understanding in order to provide feedback to
    the developer and also mitigate further technical debt.
  prefs: []
  type: TYPE_NORMAL
- en: In this book you may notice the lack of UML; that's because here I don't see
    UML as necessary. I mean, we are all speaking in PHP, right? You might find UML
    useful in your teams, though.
  prefs: []
  type: TYPE_NORMAL
- en: The process of architecture usually results in a deliverable; we call that deliverable
    an *artifact*. In Agile teams, those artifacts may be developed in an evolutionary
    way, rather than being an upfront product, but nevertheless it is perfectly possible
    to do architecture in an Agile setting.
  prefs: []
  type: TYPE_NORMAL
- en: Indeed, I would argue that architecture makes working in an Agile environment
    far easier. When programming to an interface or an abstract layer it is far easier
    to replace classes; in an Agile environment, requirements may change, meaning
    a class may need to be replaced. Software is only useful insofar as it is useful
    to the end client. Agile can help with this, but in order to be Agile, your code
    must be adaptive. Having great architecture is critical to this end.
  prefs: []
  type: TYPE_NORMAL
- en: When we write code, we should write code defensively. The adversary, however,
    isn't an enemy, it is ourselves. One of the quickest ways to degrade reliable
    code is by editing it to be weak.
  prefs: []
  type: TYPE_NORMAL
- en: Decorator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Decorator is simply what adds additional functionality to an individual class
    without affecting the behavior of other objects from the same class.
  prefs: []
  type: TYPE_NORMAL
- en: The Single Responsibility Principle, simply put by Robert C. Martin (who I introduced
    at the start of this chapter), is that *a class should have only one reason to
    change*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The principle states that every module or class should have a single responsibility
    and that responsibility should be entirely encapsulated by that class. All services
    of the class should align with that responsibility. Martin summarized this by
    defining the responsibility as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"a charge assigned to a unique actor to signify its accountabilities concerning
    a unique business task".*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: By using the Decorator design pattern, we are able to ensure that functionality
    is divided between classes with unique areas of concern, thus adhering to the
    Single Responsibility Principle.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start off by declaring our `Book` interface. This is what we expect
    our Books to be able to produce:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we can declare our `EBook.php` class. This is the class we will be decorating
    with our `PrintBook` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can declare our `PrintBook` class. This is what we''re using to decorate
    the `EBook` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'So now let''s test all this with our `index.php` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Adapter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are two types of Adapter pattern. I have a clear preference for Object
    Adapters over Class Adapters where possible; I will explain this in detail later.
  prefs: []
  type: TYPE_NORMAL
- en: The Adapter pattern allows an existing class to be used with an interface that
    it doesn't match. It is often used to allow existing classes to work with others
    without needing to alter their source code.
  prefs: []
  type: TYPE_NORMAL
- en: This can be quite useful in a polymorphic setting where you are using third-party
    libraries, each with their own interface.
  prefs: []
  type: TYPE_NORMAL
- en: Fundamentally, an Adapter helps two incompatible interfaces work together. Otherwise
    incompatible classes can be made to work together by converting the interface
    of one class into an interface expected by the clients.
  prefs: []
  type: TYPE_NORMAL
- en: Class Adapter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In a Class Adapter, we use inheritance to create an adapter. A class (the adapter)
    can inherit another (the adaptee); using standard inheritance we are able to add
    additional functionality to the adaptee.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s suppose we have an `ATM` class, in our `ATM.php` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create our `ATMWithPhoneTopUp.php` to form our adapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s wrap this all together in an `index.php` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have adapted our initial `ATM` class to yield top-up codes, we
    can now utilize this new top-up functionality. The output of all this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note that if we wanted to adapt to multiple adaptees, this would be difficult
    in PHP.
  prefs: []
  type: TYPE_NORMAL
- en: In PHP, multiple inheritance isn't possible, unless you are working with Traits.
    In this case, we can only adapt one class to match the interface of another.
  prefs: []
  type: TYPE_NORMAL
- en: The other key architectural reason for us not using this approach is that it
    is often good design to prefer composition over inheritance (as described by the
    Composite Reuse Principle).
  prefs: []
  type: TYPE_NORMAL
- en: In order to explore this principle in more detail, we need to take a look at
    Object Adapters.
  prefs: []
  type: TYPE_NORMAL
- en: Object Adapter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Composite Reuse Principle states that classes should achieve polymorphic
    behavior and code reuse by their composition.
  prefs: []
  type: TYPE_NORMAL
- en: By applying this principle, classes should contain instances of other classes
    when they want to implement a particular piece of functionality, as opposed to
    inheriting the functionality from a base or parent class.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this reason, the Gang of Four stated the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"Favor ''object composition'' over ''class inheritance''."*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Why is this principle so vital? Consider our last example, where we used class
    inheritance; in such a case, there is no formal guarantee that our adapter would
    match the interface we want it to. What if the parent class exposed a function
    we didn't want the adapter to? Composition gives us more control.
  prefs: []
  type: TYPE_NORMAL
- en: By using composition over inheritance, we are able to better support the polymorphic
    behavior that is so vital in object-oriented programming.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s suppose we have a class to generate an insurance premium. It provides
    a monthly premium and an annual premium depending on how the customer wants to
    pay their premium. By paying annually, the customer gets a saving equivalent to
    half a month:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s suppose a market comparison tool polymorphically uses classes such as
    the one mentioned earlier to actually go ahead and calculate insurance quotes
    from multiple different vendors; they use this interface to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Accordingly, we can use this interface to build an Object Adapter to ensure
    our `Insurance` class, our premium generator, matches the interface that the market
    comparison tool is expecting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Note how the class actually goes ahead and instantiates its own class for what
    it's trying to adapt.
  prefs: []
  type: TYPE_NORMAL
- en: The adapter then stores this class in a `private` variable. We then use this
    object in the `private` variable to proxy requests.
  prefs: []
  type: TYPE_NORMAL
- en: An Adapter, both a Class Adapter and an Object Adapter, should act as glue code.
    What I mean by that is that adapters shouldn't perform any calculations or computation,
    they merely act as a proxy between incompatible interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: It is standard practice to keep logic out of our glue code and leave the logic
    down to the code that we are adapting. If, in doing this, we come up against the
    Single Responsibility Principle, we need to adapt another class.
  prefs: []
  type: TYPE_NORMAL
- en: As I mentioned earlier, adapting multiple classes isn't really possible in a
    Class Adapter, so you'd either have to wrap such logic in a Trait or we would
    need to use an Object Adapter, such as the one we're discussing here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try out this adapter. We''ll do so by writing the following `index.php`
    file to see if our new class matches the expected interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The key drawback of this method, compared to the Class Adapter method, is that
    we must implement common methods, even if those methods are merely forwarding
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: FlyWeight
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like in real life, not all objects are easy to create, and some can take up
    excessive amounts of memory. The FlyWeight design pattern can help us minimize
    memory usage by sharing as much data as possible with similar objects.
  prefs: []
  type: TYPE_NORMAL
- en: This design pattern has limited use in most PHP applications, but it is still
    worth knowing it for the odd situation where it is incredibly useful.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we have a `Shape` interface with a `draw` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Let's create a `Circle` class that implements this interface. When implementing
    this, we build the ability to set the location of a circle with X and Y co-ordinates.
    We also create the ability to set the circle's radius and draw it (print out this
    information). Note how the color characteristic is set outside the class.
  prefs: []
  type: TYPE_NORMAL
- en: There's a very important reason for this. In our example, the color is state-independent;
    it is an intrinsic part of the circle. The location and size of the circle are,
    however, state-dependent and are therefore extrinsic. The extrinsic state information
    is passed to the FlyWeight object when its functions are needed; the intrinsic
    options, however, are independent of each process of the FlyWeight. This will
    make more sense when we cover how this factory is made.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the important information:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Extrinsic**: State belongs to the external context of the object and is input
    into the object when it''s used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Intrinsic**: State that naturally belongs to the object and therefore should
    be permanent, immutable (internal), or context-free.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With this in mind, let''s put together an implementation of our `Shape` interface.
    Here''s our `Circle` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'With this, we can now build our `ShapeFactory`, which actually implements the
    FlyWeight pattern. An object with the color of our choice is instantiated when
    it''s needed, and is then stored for later use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Let's demonstrate how this works in our `index.php` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order for this to work, we create `100` objects with random colors, in a
    random location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s take a look at the output. You can see we''ve drawn 100 circles,
    but we have only needed to instantiate a handful of circles as we are caching
    objects of the same color for later use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed something here. The way I'm storing the cache of the FlyWeight
    object that we are reusing is by concatenating the *Circle*_ and the color, for
    example *Circle_green*. Obviously, this works in this use case, but there is a
    better way of doing this; in PHP, it is actually possible to get a unique ID for
    a given object. We'll cover this in the next pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Composite
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine an audio system consisting of individual songs and also playlists of
    songs. Yes, playlists consist of songs, but we want both to be treated individually.
    Both are types of music, both can be played.
  prefs: []
  type: TYPE_NORMAL
- en: The Composite design pattern can help here; it allows us to ignore the differences
    between compositions of objects and individual objects. It allows us to treat
    both with identical or nearly-identical code.
  prefs: []
  type: TYPE_NORMAL
- en: Let's put together a little example; a song is our example of a *leaf*, with
    playlists being *composites*. `Music` is our abstraction of playlists and songs;
    therefore, we can call this our *component*. The *client* of all this is our `index.php`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: By not discriminating between leaf-nodes and branches, our code becomes less
    complex and therefore less error prone.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by defining an interface for our `Music`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s put together some implementations, starting with our `Song` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Now we can start to put together our `Playlist` class. In this example, you
    may notice I set the key in the songs array using a function called `spl_object_hash`.
    This function is an absolutely blessing when dealing with arrays of objects.
  prefs: []
  type: TYPE_NORMAL
- en: What this function does is return a unique hash for each object which remains
    consistent so long as the object is not destroyed, regardless of what properties
    of the class are changed. It provides a stable way of addressing arbitrary objects.
    Once the object is destroyed, the hash can then be reused for other objects.
  prefs: []
  type: TYPE_NORMAL
- en: The contents of the object are not hashed by this function; it merely acts to
    show the internal handle and the hander table pointer. This means that if you
    alter the properties of an object, the hash will not change. This said, it does
    not guarantee uniqueness. If an object is destroyed and one of the same class
    is immediately created afterwards you will get the same hash as PHP will reuse
    the same internal handle after the first class has been dereferenced and destroyed.
  prefs: []
  type: TYPE_NORMAL
- en: 'This will be true, as PHP can use the internal handle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'However, this will be false, as PHP must create a new handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s return to our `Playlist` class. Let''s implement our `Music` interface
    with it; so, here''s the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Now let's put this all together in our `index.php` file. What we're doing here
    is creating some song objects, some of which we will assign to a playlist using
    their `addSong` function.
  prefs: []
  type: TYPE_NORMAL
- en: Because playlists are implemented in the same way as songs, we can even use
    the `addSong` function with other playlists (in this case, it may be better for
    us to rename the `addSong` function `addMusic`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we play the parent playlist. This plays the child playlists and in turn
    plays all the songs in those playlists as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run this script, we can see the expected output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Bridge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Bridge pattern can be quite straightforward; it effectively allows us to
    decouple an abstraction from an implementation so the two can vary independently.
  prefs: []
  type: TYPE_NORMAL
- en: When classes vary frequently, bridging an interface and a concrete class allows
    developers to vary their classes with greater ease.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s propose a generic messenger interface that has the ability to send some
    form of message, `Messenger.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'One specific implementation of this interface is an `InstantMessenger` application,
    `InstantMessenger.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, we can do the same with an `SMS` application, `SMS.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now create an interface for the physical device, the transmitter, if
    you will, `Transmitter.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We can decouple a transmitter from the devices that implement its methods by
    using a `Device` class. The `Device` class bridges the `Transmitter` interface
    to the physical device, `Device.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'So let''s put together a concrete class to represent a phone, `Phone.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'And let''s do the same for a `Tablet`. `Tablet.php` is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let''s wrap this all together in an `index.php` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Proxy pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Proxy is a class that is merely an interface to something else. It may be an
    interface to anything; from being a network connection, a file, a large object
    in memory, or any other resource that is too difficult to duplicate.
  prefs: []
  type: TYPE_NORMAL
- en: In our example here, we will simply be creating a simple proxy to forward to
    one of two objects depending on how the proxy is instantiated.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing a simple Proxy class allows the client to access both feeders for
    cats and dogs from one object, depending on whether it's been instantiated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start off by defining an interface for our `AnimalFeeder`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then define two animal feeders for a cat and a dog:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'And here''s our dog `AnimalFeeder`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: With this defined, we can now make our proxy class, a class that essentially
    uses the constructor to decipher what kind of class it needs to instantiate, then
    redirects all function calls to this class. In order to redirect function calls,
    the `__call magic` method is used.
  prefs: []
  type: TYPE_NORMAL
- en: 'This looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: You might have noticed that we have to manually create the class in the constructor
    with the namespace. We do this using the `__NAMESPACE__ magic` constant to find
    the current namespace, then concatenating it onto the specific sub-namespace where
    the classes are. Note that we have to escape the `\` using another `\` in order
    to allow us to specify the namespace without PHP interpreting `\` as an escape
    character.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s build our `index.php` file and utilize the proxy class to build objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: So how can you use this in reality? Suppose you got a record out of the database
    that contained an object that detailed the animal type and name; you could just
    pass this object to the constructor of the Proxy class and use that as a mechanism
    to create your classes.
  prefs: []
  type: TYPE_NORMAL
- en: In practice, this has a great use case when it comes to supporting resource-hungry
    objects that you don't necessarily want to instantiate unless they are really
    required by the client; the same can be true of resource-hungry network connections
    and other types of resource.
  prefs: []
  type: TYPE_NORMAL
- en: Facade
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Facade (also known as *Façade*) design patterns are a curious thing; they essentially
    act as a simple interface to a complex system. A Facade design pattern works providing
    a single class that in itself instantiates other classes and provides a simple
    interface to use those functions.
  prefs: []
  type: TYPE_NORMAL
- en: A warning when using such pattern is that, as classes are instantiated within
    the Facade, you are essentially tightly coupling the classes that it utilizes.
    There are cases where you want this, but there are cases where you do not. Where
    do you do not want this behavior, you are better suited to using dependency injection.
  prefs: []
  type: TYPE_NORMAL
- en: I have found this to be useful when wrapping a set of poor APIs into a single
    unified API. It reduces external dependencies, allowing complexity to be internalized;
    this process can make your code more readable.
  prefs: []
  type: TYPE_NORMAL
- en: I shall demonstrate this pattern in a crude example, but this will effectively
    make the mechanism obvious.
  prefs: []
  type: TYPE_NORMAL
- en: Let me propose three classes for a toy factory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Manufacturer (the factory building the toy) is a simple class that is instantiated
    with the capacity of how many toys to build at a time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Post class (the shipping courier) is a simple function that dispatches the
    toy from the factory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'An `SMS` class informs the client that their toy has been dispatched from the
    factory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is our `ToyFactory` class, which acts as a Facade to link together all
    these classes and allow operations to happen sequentially:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, we can wrap all this together in our `index.php` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we run this code, we see the message from our `SMS` class showing the
    text message was sent:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Facade](graphics/image_04_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In other situations, where the various classes were loosely coupled together,
    we may find it better to use dependency injection. By injecting objects that perform
    various actions into the `ToyFactory` class we can benefit from making testing
    easier by being able to inject fake classes that the `ToyFactory` class can manipulate.
  prefs: []
  type: TYPE_NORMAL
- en: Personally, I am a huge believer in making code as easily testable as possible;
    hence why I don't like this approach.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter extended the design patterns we started to learn in the previous
    chapter by introducing structural design patterns.
  prefs: []
  type: TYPE_NORMAL
- en: 'To this end, we learned some critical patterns to ease the software design
    process; these patterns identify a simple way to realize the relationships between
    different entities:'
  prefs: []
  type: TYPE_NORMAL
- en: We learned about the Decorator, how to wrap classes to add additional behavior
    to them, and critically, we learned how this can help us comply with the Single
    Responsibility Principle.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We learned about Class and Object Adapters, and the difference between them.
    The critical takeaway here is the arguments for why we may choose composition
    over inheritance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We reviewed the FlyWeight design pattern, which can help us perform certain
    processes in a memory-efficient manner.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We learned how the Composite design pattern can help us treat compositions of
    objects the same as individual objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We covered the Bridge design pattern, which lets us decouple our abstraction
    from its implementation, allowing the two to vary independently.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We covered how the Proxy design pattern can function as an interface to another
    class and how we can use this as a forwarding agent.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we learned how the Facade design pattern can be used to provide a simple
    interface to a complex system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next chapter, we will wrap up our design patterns section by talking
    about Behavioral patterns, ready to touch on Architectural patterns.
  prefs: []
  type: TYPE_NORMAL
