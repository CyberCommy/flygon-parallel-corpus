- en: Coding on the Adafruit HalloWing Microcontroller
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will create a joke-telling machine. We will use the Adafruit
    HalloWing M0 Express board that comes with a full color TFT display and capacitive
    touch sensors. Each time you press the touch button, a new joke riddle will be
    presented. You can try and figure out the answer to the riddle and when you are
    ready, touch the button to show the answer to the riddle. Pressing the touch button
    again randomly selects a new riddle and starts another game.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will be a useful source of information and help you build projects
    that let you leverage the power of a full color screen with a good enough resolution
    to present multi-line text and full color graphical images.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be covering the following recipe in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Discovering I2C devices
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading data from the accelerometer using I2C
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detecting board-flipping with the accelerometer
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling screen brightness
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying a bitmap image
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Listing all image files
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a joke-telling machine
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Adafruit HalloWing M0 Express
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Adafruit HalloWing is a microcontroller with a built-in 1.44 inch 128 x
    128 full-color TFT display. The software for displaying images fully supports
    displaying full color bitmap image files. With 8 MB storage on the device, this
    gives you plenty of space to store and display a large number of images. The board
    also comes equipped with a 3-axis accelerometer, light sensor, and 4 capacitive
    touchpads. The following screenshot shows the TFT screen displaying a bitmap image:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/147b6ec4-61e4-4d56-a458-7865333945e9.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
- en: The board can be powered by a portable power source. It supports both rechargeable
    lithium-ion polymer batteries and a USB portable power bank.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Where to buy
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Adafruit HalloWing M0 Express board can be purchased directly from Adafruit
    ([https://www.adafruit.com/product/3900](https://www.adafruit.com/product/3900)).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code files for this chapter can be found in the `Chapter15` folder of this
    book's GitHub repository, at [https://github.com/PacktPublishing/MicroPython-Cookbook](https://github.com/PacktPublishing/MicroPython-Cookbook).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: This chapter uses the Adafruit HalloWing M0 Express board, loaded with the CircuitPython
    firmware. CircuitPython version 4.0.0-rc.1 was used for all the recipes in this
    chapter.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: You may download the firmware image from [https://circuitpython.org/board/hallowing_m0_express/](https://circuitpython.org/board/hallowing_m0_express/).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Many of the recipes in this chapter require a set of bitmap images to be transferred
    to the Adafruit HalloWing device. They can all be downloaded from the `Chapter15`
    folder in this book's GitHub repository. They should be saved in the top-level
    folder, along with your `main.py` file.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Discovering I2C devices
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will show you how to scan for I2C devices connected to the bus using
    the `i2c` object. The I2C protocol supports multiple devices being connected to
    a single I2C connection. One of the first steps in connecting to a device is to
    scan and list all detected devices. This recipe will help you troubleshoot an
    I2C device to confirm that it is connected and can be found in scans. It can also
    help you build Python scripts that can automatically scan and detect multiple
    devices.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need access to the REPL on the Adafruit HalloWing board to run the
    code presented in this recipe.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to learn how to discover I2C devices:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following lines of code in the REPL:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The required libraries will have been imported. Run the following line of code
    to create the `i2c` object that will be used for scanning:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The following lines of code will keep looping until a lock is acquired on the
    I2C bus:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following block of code performs a scan and lists all detected devices:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We can perform the scan again and convert the returned device addresses into
    hex format:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The following code should be put into the `main.py` file:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: When this script is executed, it will print out the addresses of all discovered
    devices.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main function sets up the `i2c` object. The `try_lock` method is then repeatedly
    called until a lock is acquired. This lock is needed to perform a scan on the
    I2C bus. The `scan` method is then called, which returns a list of device addresses.
    Each address is then converted into hex notation and saved as a list of strings
    in the device's variable. Finally, the contents of this variable are output with
    a message, indicating that this is the list of devices that were discovered on
    the bus.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some I2C operation, such as scanning, require a lock. If you try and perform
    a scan without first acquiring a lock, you will get a runtime error indicating
    that this function requires a lock. In the next recipe, we will see that there
    are other operations that don't require a lock. The addresses of I2C are frequently
    referred to using hex notation, and this is the reason why we converted the value
    from an integer into a hex value.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: The Adafruit HalloWing M0 Express board comes with one I2C device—an accelerometer—which
    should have the address `0x18`. Our scans confirm that. If you're not sure of
    the specific address value for your device, you can use the scan method to detect
    these values.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are a few references regarding this recipe:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Documentation on the `scan` method can be found at [https://circuitpython.readthedocs.io/en/3.x/shared-bindings/busio/I2C.html#busio.I2C.scan](https://circuitpython.readthedocs.io/en/3.x/shared-bindings/busio/I2C.html#busio.I2C.scan).
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documentation on a project that uses the accelerometer on the Adafruit HalloWing
    board can be found at [https://learn.adafruit.com/hallowing-magic-9-ball/](https://learn.adafruit.com/hallowing-magic-9-ball/).
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading data from the accelerometer using I2C
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will show you how to connect to the onboard accelerometer using
    the I2C protocol. Once we have an I2C object, we will use the Python `adafruit_lis3dh`
    library to create a `LIS3DH_I2C` object. This object will let us read live sensor
    data from the accelerometer. This recipe will help you whenever you want to create
    a project that uses board's orientation to create an interactive experience. You
    could, for example, create a project that reacts to the board being shaken by
    changing the image that's currently being displayed.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need access to the REPL on the Adafruit HalloWing device to run the
    code presented in this recipe.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to learn how to read data from the accelerometer using I2C:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the following block of code in the REPL:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The required libraries have now been imported, and the accelerometer address
    has been defined in the `ACCEL_ADDRESS` constant. Run the following block of code
    to create an `i2c` object and use that object to create a `LIS3DH_I2C` object:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The following block of code will fetch accelerometer orientation data and display
    its values:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We can also access specific information, such as the *x* axis orientation data,
    using the following block of code:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The following loop is used to print the live accelerometer sensor data every
    0.1 seconds:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The following code should be put into the `main.py` file:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: When this script is executed, it will print sensor data from the accelerometer
    every 0.1 seconds.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `ACCEL_ADDRESS` constant contains the address for the accelerometer on the
    Adafruit HalloWing M0 Express board. Once we've created an `i2c` object, we take
    it and the `ACCEL_ADDRESS` to create a `LIS3DH_I2C` object, which we will save
    in a variable called `accel`. An infinite loop is started that reads the sensor
    data from the accelerometer on each iteration and prints them out. The loop then
    waits for a 0.1 second delay before starting the next iteration.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The name of the accelerometer that's used on the Adafruit HalloWing device is
    called LIS3DH, which is why the Python library that knows how to speak to this
    device is called `adafruit_lis3dh`. This sensor can be used to detect both the
    orientation and acceleration of the board. In the next recipe, we will use this
    orientation data to detect when the board has been flipped over.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are a few references regarding this recipe:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: Documentation on the LIS3DH accelerometer can be found at [https://www.st.com/en/mems-and-sensors/lis3dh.html](https://www.st.com/en/mems-and-sensors/lis3dh.html).
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documentation on the `LIS3DH_I2C` object can be found at [https://circuitpython.readthedocs.io/projects/lis3dh/en/latest/api.html#adafruit_lis3dh.LIS3DH_I2C](https://circuitpython.readthedocs.io/projects/lis3dh/en/latest/api.html#adafruit_lis3dh.LIS3DH_I2C).
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Detecting board-flipping with the accelerometer
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will show you how to create a function that detects when the board
    is flipped over. To achieve this, we will use the orientation data that we fetched
    from the accelerometer. We will focus on the *z* axis data as this will indicate
    whether the board is facing up or facing down. The approach presented in this
    recipe can be useful to you whenever you are creating a project and want to find
    a more creative way of interacting with the project than just pushing buttons.
    This can create a fun level of interaction when someone discovers that all they
    have to do is flip over your board to interact with it.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need access to the REPL on the Adafruit HalloWing device to run the
    code presented in this recipe.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to learn how you can detect board flipping with the accelerometer:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the REPL to run the following lines of code:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The required libraries have been imported and constantly defined. Run the following
    block of code to create the `i2c` and `LIS3DH_I2C` objects:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We can now inspect the *z* axis orientation data:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Flip the board so that its display is face-down and then run the following
    block of code:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The orientation value of the *z* axis will be a positive or negative number,
    depending on whether the board is face-up or face-down. Execute the following
    block of code to calculate this value:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Run the following block of code while you flip the board between face-down
    and face-up:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The following code should be put into the `main.py` file:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: When this script is executed, it will print whether the board is facing up or
    down every 0.1 seconds.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once the `i2c` and `accel` variables are set up, we can then start accessing
    the orientation data from the accelerometer. When the board is facing up, the
    `z` value will be a negative number, and when the board is facing down, the `z`
    value will be a positive number. We can use this piece of information to calculate
    whether the board is facing up or down. An infinite loop is started and the variable
    face has `up` or `down` values saved to it, depending on the board's current orientation.
    This information is then printed while the loop waits for a 0.1 second delay before
    starting the next iteration.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe showed you how you can use one piece of information from the accelerometer
    to detect a change in the physical orientation of the board. Once we've detected
    this change, we can make the script change its output, for example, whenever the
    board's face value changes. The accelerometer is also accurate enough to provide
    the angle the board is pointed at in reference to the *z* axis. We can use this
    information to change the behavior of our application, depending on how far the
    board is tilted in a certain direction.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are a few references regarding this recipe:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Documentation on how accelerometers detect orientation can be found at [https://ieeexplore.ieee.org/document/1241424](https://ieeexplore.ieee.org/document/1241424).
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documentation on the `acceleration` attribute can be found at [https://circuitpython.readthedocs.io/projects/lis3dh/en/latest/api.html#adafruit_lis3dh.LIS3DH.acceleration](https://circuitpython.readthedocs.io/projects/lis3dh/en/latest/api.html#adafruit_lis3dh.LIS3DH.acceleration).
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling screen brightness
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will show you how to control the brightness level on the TFT display
    that comes with the Adafruit HalloWing device. The brightness can be set to the
    maximum level or to lower levels by providing a fractional value between 0 and
    1\. The brightness setting can also be used to turn off the display by setting
    the brightness level to 0\. This recipe can be useful to you in projects where
    you don't want the screen on all the time, and want to turn it on and off. It
    can also be helpful when you want to tweak the brightness levels of the backlight
    to a lower level to reduce power consumption.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need access to the REPL on the Adafruit HalloWing device to run the
    code presented in this recipe.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to learn how to control the Adafruit HalloWing device''s
    screen brightness:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following lines of code in the REPL:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The required libraries have been imported you can run the following block of
    code to set the brightness level to 50%:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The following block of code will turn of the display by setting brightness
    to 0%:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We can now set the brightness to the maximum level with the following block
    of code:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The following function will take the brightness from the lowest level to the
    maximum level over 11 iterations:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Run the following block of code. You should see the display fade up to maximum
    brightness:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The following code should be put into the `main.py` file:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: When this script is executed, it will fade the screen from black to full brightness,
    with a 0.1 second delay between each fade.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main function starts an infinite loop that repeatedly calls the `fade_in`
    function. Each call to the `fade_in` function will start a `for` loop that loops
    over 11 brightness values. The values vary, from the display being off to setting
    the display to its maximum brightness. The brightness level is calculated for
    each iteration and stored in the brightness variable. The value is printed and
    then applied to the brightness attribute on the `DISPLAY` object. A sleep of 0.1
    second is then applied before the next iteration of the fade in the loop is applied.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe demonstrates how easy it is to set the brightness level of the display.
    It also shows you how screen effects such as fading the screen in and out can
    also be implemented in Python. The brightness attribute can be particularly useful
    when you want to turn off the display by switching the backlight of the display
    off. You might create a battery-operated device that can use this technique to
    optimize power consumption.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are a few references regarding this recipe:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: An example of controlling screen brightness can be found at [https://circuitpython.readthedocs.io/en/latest/shared-bindings/displayio/OnDiskBitmap.html](https://circuitpython.readthedocs.io/en/latest/shared-bindings/displayio/OnDiskBitmap.html).
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Details on the TFT display on the Adafruit HalloWing device can be found at
    [https://learn.adafruit.com/adafruit-hallowing?view=all#tft-2-18](https://learn.adafruit.com/adafruit-hallowing?view=all#tft-2-18).
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying a bitmap image
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will show you how to create a function that receives the path to
    a bitmap image, takes this image, and displays it on the HalloWing screen. There
    are many different objects and options available for manipulating the contents
    of the screen. We will have to interact with a number of these different objects,
    even when we just want to show a single image. This recipe gives you an insight
    into what is involved in getting an image rendered on the board's screen. This
    recipe can be helpful if you are using the HalloWing device for projects that
    need to display different images and you want a straightforward way to change
    the currently displayed image.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need access to the REPL on the Adafruit HalloWing device to run the
    code presented in this recipe.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to learn how to display a bitmap image on the HalloWing
    device''s screen:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the following block of code in the REPL:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The necessary objects from the `displayio` module have now been imported. Run
    the following block of code to open a file object as a binary stream:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We will use this file object to create our bitmap object and then prepare the
    `pixel_shader` object:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'These two objects are then used as arguments for creating a `TileGrid` object
    called `sprite`:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The following block of code creates a group object and appends the `sprite`
    to it:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We can use the following block of code to show this group on the display and
    call `wait_for_frame` to make the block of code wait until the display has been
    fully updated. Now, we will close the file object as it is no longer needed:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Run the following block of code to define the `show_image` function and call
    it to show a different image on the display:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The following code should be put into the `main.py` file:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: When this script is executed, it will repeatedly change the image being displayed
    between two different bitmaps.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `show_image` function in this recipe does all the heavy lifting of displaying
    the bitmap on the screen. It receives one argument, which is the path to the bitmap
    file. This file is opened for reading and then used to create an `OnDiskBitmap`
    object called bitmap.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: The `ColorConverter` object is used to create the `pixel_shader` variable. A
    `TileGrid` object is created and requires the bitmap to be displayed, as well
    as the pixel shader that will be used. Both of these arguments are provided and
    the new `TileGrid` object is saved in the sprite variable. The sprite variable
    cannot be given directly to the `DISPLAY` object, so we must create a `Group`
    object and append the sprite to it.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: We can now call the show method on the `DISPLAY` object to show the `group`
    variable. The `wait_for_frame` method is called to make sure that the image is
    fully displayed on the screen before continuing. The main function starts an infinite
    loop that repeatedly calls `show_image` to continuously change the currently displayed
    image.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a lot of different types of objects that need to be employed to display
    a bitmap image on the HalloWing device. Part of the reason for this is that each
    object provides a wide variety of flexibility in terms of how the image is displayed
    on the screen. You can, for example, control the *x* and *y* coordinates of an
    image or use other bitmap objects that don't come from files.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: The display can display images with a resolution of up to 128 x 128, saved in
    the 24-bit pixel BMP file format. You can use the open source GIMP image editor
    to create these images.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: 'When you create a new image in the GIMP application, you should set the correct
    resolution, as shown in the following screenshot:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/71187889-9643-49fd-b1a2-31085a1b88a7.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
- en: 'When you are ready to save the image, use the Export function in the file menu
    and save your image in BMP file format. When you do this, make sure you select
    the correct bits per pixel setting, as shown in the following screenshot:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/9f973955-24eb-4610-8356-4b5f357d9dbf.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
- en: It's important to know that you can also use images of a smaller resolution,
    and that this will be automatically detected and correctly displayed on the screen.
    Smaller images also tend to be displayed on the screen faster.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are a few references regarding this recipe:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: Downloads for the GIMP image editor can be found at [https://www.gimp.org/](https://www.gimp.org/).
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documentation on the `OnDiskBitmap` object can be found at [https://circuitpython.readthedocs.io/en/latest/shared-bindings/displayio/OnDiskBitmap.html](https://circuitpython.readthedocs.io/en/latest/shared-bindings/displayio/OnDiskBitmap.html).
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Listing all image files
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will show you how to list all the image files in a specific directory.
    In the joke-telling machine, we are creating each joke question and response as
    a pair of images. This recipe will allow you to list all your bitmap images on
    the board. We will then extend this functionality to filter the list further and
    have all the bitmap images of the joke questions at hand. This recipe can be useful
    in any project that you create where you want to retrieve a list of images to
    display or audio files or play in your project.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need access to the REPL on the Adafruit HalloWing device to run the
    code presented in this recipe.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to learn how to list image files:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the REPL to run the following lines of code:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We have now retrieved and output a sorted list of all the paths on the board''s
    root directory. We will use the following block of code to list only bitmap image
    files:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We can extend this further and only list joke question image files, as shown
    in the following block of code:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The following block of code will select the first question image and save it
    to a variable:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The following block of code can be used to calculate the name of a joke''s
    response image based on the question image:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We will use the following block of code to confirm that the calculated response
    image exists as a file:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The following code should be put into the `main.py` file:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: When this script is executed, it will list all question images and calculate
    their related response images.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `get_questions` function in this recipe saves a sorted list of filenames
    in the `paths` variable. It then filters the listing to only include the question
    images by checking whether the `question.bmp` string appears in the filename.
    This filtered list is then returned by the function.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: The main function calls the `get_questions` function and saves its results to
    the `questions` variable. Each question is looped through and has its response
    image calculated when we replace the `question.bmp` value with `response.bmp`
    in the filename. Both the question and response filenames are then printed before
    the next iteration of the loop commences.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A number of images will be used to create the joke-telling machine. We could
    have saved the names of the necessary images in the script itself, instead of
    directly listing them in the filesystem. But the approach taken in this recipe
    is better because it avoids us having to hardcode the image list directly in our
    application. This means that we can have 5 jokes or even 50 on the board without
    us having to change our application's code.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: 'Each time we start the joke-telling machine, it will automatically grab the
    latest listing of joke images. The following screenshot shows the joke question
    and the responses that will be used in the next recipe to create the joke-telling
    machine:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ae0c3e94-3e8b-43bf-b075-d12389207c90.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
- en: You can see that the filenames follow a simple naming convention to make it
    easy for you to see each question and response when they're viewed in an image
    viewer. This naming convention also makes it an easy process to calculate the
    related response image for a specific question image.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are a few references regarding this recipe:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: Documentation on the BMP file format can be found at [https://www.fileformat.info/format/bmp/egff.htm](https://www.fileformat.info/format/bmp/egff.htm).
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Details on using bitmap images on the HalloWing device can be found at [https://learn.adafruit.com/hallowing-badge/hallowing-badge-and-image-player](https://learn.adafruit.com/hallowing-badge/hallowing-badge-and-image-player).
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a joke-telling machine
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will show you how to list all the image files in a specific directory.
    In the joke-telling machine we are creating, each joke question and response will
    be provided as a pair of images. This recipe will show us how to list all our
    bitmap images on the board.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: We will then extend this functionality to further filter the list so that we
    have all the bitmap images of the joke questions at hand. This recipe will help
    you if you want to create a project where you want to retrieve a list of images
    or audio files so that you can display or play them in your project.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need access to the REPL on the Adafruit HalloWing device to run the
    code presented in this recipe.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to learn how to create a joke-telling machine:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following lines of code in the REPL:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We have now imported all the necessary modules. The following block of code
    will create a `TouchIn` object:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'In the following block of code, we will check the status of the touchpad:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Touch the pad while executing the following block of code:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The following block of code will define the `wait_for_touch` function, which
    will keep looping until a touch event is detected:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We will use the following block of code to call `wait_for_touch`. After executing
    this function, wait a few moments before touching the pad to confirm that the
    function returns from its `while` loop once it detects the touch event:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The following block of code will save the list of question images in the `questions`
    variable:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We will use the following block of code to randomly select a question from
    the questions list:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The following code should be put into the `main.py` file:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: When this script is executed, it will start the joke-telling machine and let
    you see joke questions and responses on the display each time you press the touchpad.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `main` function creates a `TouchIn` object that's connected to the first
    touchpad connector on the board. The list of question images is retrieved by calling
    the `get_questions()` function and saving the returned list in the `questions`
    variable.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: An infinite event loop is then started, which first selects a random question
    and calculates the associated response image for that question. The question image
    is then displayed on the screen by calling the `show_image` function. The `wait_for_touch`
    function is then called, which loops and checks for a touch event every 100 milliseconds.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: Once a touch event is detected, the function is returned, and then the `show_image`
    function is called to show the response image. The `wait_for_touch` function is
    called again so that the user can see the response before deciding to load another
    question by pressing the touchpad. Once the touchpad is pressed, the current loop
    iteration ends and the process starts again with a new, randomly selected question.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The joke-telling machine is a fun way to use the input and output potential
    of this board. It uses the board's graphical display to show the different joke
    questions and responses, as well as the capacitive touch sensors as input to make
    the application load the next question or show the answer to a loaded question.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: This base recipe can be extended in many ways. Since the board comes with four
    touchpads, you could create a simple menu system where people can choose from
    different categories of jokes. You could even create a project for digital dice
    by having images of the six sides of a die and showing a random side each time
    the touchpad is pressed.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are a few references regarding this recipe:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是关于这个配方的一些参考资料：
- en: Documentation on the `ColorConverter` object can be found at [https://circuitpython.readthedocs.io/en/latest/shared-bindings/displayio/ColorConverter.html](https://circuitpython.readthedocs.io/en/latest/shared-bindings/displayio/ColorConverter.html).
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ColorConverter` 对象的文档可以在 [https://circuitpython.readthedocs.io/en/latest/shared-bindings/displayio/ColorConverter.html](https://circuitpython.readthedocs.io/en/latest/shared-bindings/displayio/ColorConverter.html)
    找到。'
- en: Documentation on the `TileGrid` object can be found at [https://circuitpython.readthedocs.io/en/latest/shared-bindings/displayio/TileGrid.html](https://circuitpython.readthedocs.io/en/latest/shared-bindings/displayio/TileGrid.html).
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TileGrid` 对象的文档可以在 [https://circuitpython.readthedocs.io/en/latest/shared-bindings/displayio/TileGrid.html](https://circuitpython.readthedocs.io/en/latest/shared-bindings/displayio/TileGrid.html)
    找到。'
