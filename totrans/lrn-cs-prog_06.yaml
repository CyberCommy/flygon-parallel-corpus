- en: '*Chapter 6*: Generics'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned about OOP in C#. In this chapter, we will
    explore the concept of generics. Generics allow us to create classes, structures,
    interfaces, methods, and delegates in such a manner that they will work in a type-safe
    environment with different data types. Generics were added as a part of the C#
    2.0 release. It promotes code reusability and extensibility and is one of the
    most powerful features of C#.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will learn about the following concepts in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Generic classes and generic inheritance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generic interfaces and variant generic interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generic structures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generic methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type constraints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have gained the skills necessary to write
    generic types, methods, and variant generic interfaces and to use type constraints.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding generics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Simply put, generics are types parametrized with other types. As we mentioned
    before, we can create a class, structure, interface, method, or delegate that
    accepts one or more data types they use as parameters. These parameters are known
    as **type parameters** and act as *placeholders* for the actual data types that
    are passed during compile time.
  prefs: []
  type: TYPE_NORMAL
- en: For example, we can create a class that models a list, which is a variable-length
    sequence of elements of the same type. Instead of having a different class that
    works with integers, doubles, strings, or any other user-defined types we might
    need, we can create a generic class that has a type parameter specifying the actual
    type of its elements. We will then specify the actual type at compile time when
    we instantiate the class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Advantages of using generics include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Generics provide reusability**: We can create a single version of the code
    and reuse it for different data types.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Generics promote type safety**: While using generics, we do not need to perform
    explicit typecasting. The typecasting is taken care of by the compiler.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`object` type to a reference type is time-consuming. Therefore, by avoiding
    these operations, they help to improve the execution time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generic types and methods can be constrained so that only the types that meet
    requirements can be used as type parameters. Information about the actual types
    is used to instantiate a generic type that can be obtained at runtime using reflection.
  prefs: []
  type: TYPE_NORMAL
- en: The most common use of generics is to create collection or wrapper classes.
    Collections will be the subject of the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Generic types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Both reference types and value types can be generic. We have already seen examples
    of generic types earlier in this book, such as `Nullable<T>` and `List<T>`.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will learn how to create generic classes, structures, and
    interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Generic classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The creation of generic classes is no different than non-generic classes. The
    only thing that differs is a list of type parameters and their use in the class
    as a placeholder for actual types. Let''s look at an example of a generic class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have defined a generic class, `GenericDemo`, that is accepting one
    type parameter, `T`. We have defined a property called `Value` of the `T` type
    and initialized it inside the class constructor. The constructor is accepting
    an argument of the `T` type. The overridden method, `ToString()`, will return
    a string containing the type and value of the property.
  prefs: []
  type: TYPE_NORMAL
- en: 'To instantiate objects of this generic class, we will proceed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we are specifying the data type for the type parameter while
    creating the object of the generic class, `GenericDemo<T>`. Both `obj1` and `obj2`
    are instances of the same generic type, but their type parameter differs: one
    is `int` and the other is `string`. Therefore, they are not type-compatible with
    each other. This means if we try to assign one object to another, it will result
    in a compile-time error.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can get information about the type of these objects and their generic type
    parameters using reflection (which we will look at in [*Chapter 11*](B12346_11_Final_SK_ePub.xhtml#_idTextAnchor200),
    *Reflection and Dynamic Programming*), as shown in the following sample:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Upon execution, we will see the output shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1 – Screenshot of the console showing the reflected content of a
    type'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.1_B12346.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.1 – Screenshot of the console showing the reflected content of a type
  prefs: []
  type: TYPE_NORMAL
- en: 'We can declare more than one type parameter for a generic type. In this case,
    we need to specify all of the type parameters as a comma-separated value inside
    the angle brackets. The following shows an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Here, `Pair<T, U>` is a class that requires two type parameters. We are instantiating
    objects `p1`, `p2`, and `p3` using different combinations of types.
  prefs: []
  type: TYPE_NORMAL
- en: This class is actually very similar to the .NET class `KeyValueType<TKey`, `TValue>`,
    from the `System.Collections.Generic` namespace. In fact, there are many generic
    classes that the framework is providing. You should use existing types when available,
    rather than defining your own.
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance with generic classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A generic class can behave either as a *base class* or a *derived class*. When
    deriving from a generic class, the child class must specify the type parameters
    that are required by the base class. These type parameters can be actual types
    or type parameters from the derived class, which is also a generic class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s understand how the inheritance of generic classes works with the example
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We have defined a generic abstract class, `Shape`, that contains a single and
    abstract property called `Area` that represents the area of a shape. The type
    of this property is also `T`. Consider the class definition here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have defined a class called `Square`, which is inheriting from the
    generic abstract class `Shape`. We are using the `int` type for the type parameter.
    We have defined a property called `Length` for the `Square` class and initialized
    it in the constructor. We are overriding the `Area` property to calculate the
    area of the square. Now, consider another class definition shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Circle` class is also inheriting from the generic abstract class `Shape<T>`.
    The type parameter for the parent class `Shape` is now specified as `double`.
    The `Radius` property is defined to store the radius of the circle. We are again
    overriding the `Area` property to calculate the area of a circle. We can use these
    derived classes as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We are creating instances of `Square` and `Circle` and printing to the console
    the area of each shape. Upon execution, we will see the output shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2 – The areas of the square and circle displayed to the console'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_6.2_B12346.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.2 – The areas of the square and circle displayed to the console
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that although both `Square` and `Circle` derive from
    `Shape<T>`, these types cannot be treated polymorphically. One is `Shape<int>`
    and the other `Shape<double>`. Therefore, instances of `Square` and `Circle` cannot
    be put in a homogeneous container. The only possible solution is to use the `object`
    type to hold references to such instances and then perform type casts.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, `Shape<T>` is a generic type. `Shape<int>` is a type that is
    constructed from `Shape<T>` by replacing the type parameter `T` with `int`. Such
    a type is called a **constructed type**. This is also a *closed constructed type*
    because all of the type parameters have been substituted. Non-generic types are
    all *closed types*. Generic types are *open types*. Constructed generic types
    can be open or closed. An open constructed type is one that has a type parameter
    that has not been substituted. A closed constructed type is any type that is not
    open.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another important thing to remember when creating generic types is that some
    operators, such as arithmetic operators, cannot be used with objects of type parameters.
    Let''s look at the following code to exemplify this case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `Square` type is now a generic type. The type parameter `T` is used for
    the type parameter of the base class as well as the `Length` property. However,
    when computing the area, the use of the `*` operator generates a compiler error.
    That is because the compiler does not know what concrete types will be used for
    `T` and whether they have the `*` operator overloaded. To make sure that, under
    no circumstances, invalid instantiation may occur, the compiler generates an error.
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to ensure that only types matching some pre-defined constraints
    are used at compile time to instantiate generic types or call generic methods.
    These are called *type constraints* and will be discussed later in this chapter
    in the *Type parameter constraints* section.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've seen how to create and use generic classes, let's see how to
    do the same with generic interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Generic interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous examples, the generic class `Shape<T>` does not contain anything
    other than an abstract property. This is not a good candidate for a class and
    it should rather be an interface. Generic interfaces differ from non-generic interfaces
    in the same way as generic classes differ from non-generic classes. The following
    is an example of a generic interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The type parameters are specified in the same manner as they are for classes
    or structures. This interface can be implemented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The implementation of the `Square` and `Circle` classes is only slightly different
    from the one seen in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: Concrete classes, such as `Square` and `Circle` here, can implement closed constructed
    interfaces, such as `IShape<int>` or `IShape<double>`. Generic classes can also
    implement a generic or closed constructed interface if the class parameter list
    supplies all of the type parameters required by the interface. On the other hand,
    generic interfaces can inherit from non-generic interfaces; however, the generic
    class must be contravariant.
  prefs: []
  type: TYPE_NORMAL
- en: The variance of generic interfaces will be discussed in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Variant generic interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is possible to declare type parameters in generic interfaces as *covariant*
    or *contravariant*:'
  prefs: []
  type: TYPE_NORMAL
- en: A *covariant* type parameter is declared with the `out` keyword and allows an
    interface method to have a return type that is more derived than the specified
    type parameter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A *contravariant* type parameter is declared with the `in` keyword and allows
    an interface method to have a parameter that is less derived than the specified
    type parameter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A generic interface that has covariant or contravariant type parameters is called
    a **variant generic interface**. Variance is only supported with reference types.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand how covariance works, let''s look at the `System.IEnumerable<T>`
    generic interface. This is a variant interface because its type parameter is declared
    covariant. The interface is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'A class that implements `IEnumerable<T>` (and other interfaces) is `List<T>`.
    Because `T` is covariant, we can write the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `names` is an `IEnumerable<string>` and `objects` is an `IEnumerable<object>`.
    The former does not derive from the latter, but `string` is derived from `object`,
    and because `T` is covariant, we can assign `names` to `objects`. However, this
    is only possible while using variant interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'Classes that implement variant interfaces are not variant themselves but invariant.
    That means the following example, where we substitute `List<T>` for `IEnumerable<T>`,
    will produce a compiler error because `List<string>` cannot be assigned to `List<object>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'As mentioned earlier, variance is not supported for value types. `IEnumerable<int>`
    cannot be assigned to `IEnumerable<object>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In summary, a covariant type parameter in an interface must:'
  prefs: []
  type: TYPE_NORMAL
- en: Be prefixed with the `out` keyword
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be only used as the return type for methods and not as a type for method parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Not be used as a generic constraint for interface methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Contravariance is the other form of variance that deals with arguments passed
    to interface methods. To understand how it works, let''s consider a situation
    where we want to compare the size of various shapes, defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'These are only slightly different from the types used previously because `IShape`
    is no longer generic to keep the example simple. What we want here is to be able
    to compare shapes. For this purpose, a series of classes are provided as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `ShapeComparer` compares `IShape` objects by their area, `SquareComparer`
    compares squares by their length, and `CircleComparer` compares circles by their
    radius. All of these classes implement the `IComparer<T>` interface from the `System.Collections.Generic`
    namespace. This interface is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This interface has a single method called `Compare()`, which takes two objects
    of the `T` type and returns one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A negative number if the first is smaller than the second
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 0, if they are equal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A positive number if the first is greater than the second
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, the key to its definition is the `in` keyword with the type parameter
    that makes it contravariant. Because of this, it is possible to pass `IShape`
    references where `Square` or `Circle` are expected. That means we can safely pass
    `IComparer<IShape>` where `IComparer<Square>` is required. Let's see a concrete
    example of that.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following class contains a single method that checks whether a `Square`
    object is bigger than another. The `IsBigger()` method also takes a reference
    to an object implementing `IComparer<Square>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We could call this method passing both `SquareComparer` or `ShapeComparer`,
    and the result would be the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Had the `IComparer<T>` interface been invariant, passing `ShapeComparer` would
    result in a compiler error. A compiler error is also issued, with the implementation
    shown here, if we try to pass `CircleComparer` because `Circle` is not a lesser
    derived class than `Square`; it is actually a sibling in the inheritance hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: 'In summary, a contravariant type parameter in an interface:'
  prefs: []
  type: TYPE_NORMAL
- en: Must be prefixed with the `in` keyword
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Must be used only for method parameters and not as a return type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can be used as a generic constraint for interface methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It is possible to define an interface that is both *covariant and contravariant*
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `IMultiVariant<T, U>` interface shown in the preceding snippet is covariant
    with respect to `T` and contravariant with respect to `U`.
  prefs: []
  type: TYPE_NORMAL
- en: Generic structures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Similar to generic classes, we can also create generic structures. The syntax
    for a generic structure is the same as that of a generic class. The `Circle` and
    `Square` types used in the previous example are small and can be defined as structures
    instead of classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: All of the rules that apply to generic classes also apply to generic structures.
    Because value types do not support inheritance, structures cannot derive from
    other generic types but can implement any number of generic or non-generic interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Generic methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C# allows us to create generic methods that accept one or more generic type
    parameters. We can create a generic method inside a generic class as well as a
    non-generic class. Both static and non-static methods can be generic. The rules
    for type inference are the same for all. The type parameters must be declared
    after the method name and just before the parameter list, within angle brackets,
    just like we did for types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s understand how to use generic methods with the help of the example shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The non-generic class `CompareObjects` contains a generic method, `Compare`,
    which is used to compare two objects. This method is accepting two parameters—`input1`
    and `input2`. We are using the `Equals()` method from the `System.Object` base
    class to compare the input parameters. The method will return a Boolean based
    on whether the inputs are equal or not. Consider the code shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We are creating an object of the `CompareObjects` class and invoking the `Compare()`
    method for various data types. In this example, the type argument is explicitly
    specified. However, the compiler is able to infer that from the arguments; therefore,
    it can be skipped, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'If a generic method has a type parameter that is the same as a type parameter
    of the class, structure, or interface where it is defined, the compiler issues
    a warning because the method type parameter hides the type parameter of the outer
    type, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Generic methods, as well as generic types, support type parameter constraints
    to impose restrictions on types. This topic will be discussed in the next section
    of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Type parameter constraints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The type parameters in a generic type or method can be replaced by any valid
    type. However, there are scenarios when we want to restrict the types that can
    be used for a type parameter. Take, for instance, the generic `Shape<T>` class
    or the `IShape<T>` interface we saw earlier.
  prefs: []
  type: TYPE_NORMAL
- en: The type parameter `T` was used for the type of the `Area` property. We would
    expect that to be either an integral type or a floating-point type. But there
    is no restriction and someone could use `bool`, `string`, or any other type. Of
    course, depending on the way the type parameter is used, that could lead to various
    compiler errors. However, it is useful to be able to restrict the types used to
    instantiate generic types or call generic methods.
  prefs: []
  type: TYPE_NORMAL
- en: For this purpose, we can apply constraints to the type parameters. The constraints
    are used to inform the compiler about what kind of capabilities the type parameter
    must have. If we do not specify a constraint, then the type parameter can be replaced
    by any type. Applying a constraint will limit the types that can be used as a
    type parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Constraints are specified using the keyword `where`. C# defines the following
    eight types of constraints on generics:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Chapter_6Table_1_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'A constraint should be specified after the type parameters. We can use more
    than one constraint by separating them with a comma. There are some rules for
    using these constraints:'
  prefs: []
  type: TYPE_NORMAL
- en: The `struct` constraint implies `the new()` constraint and therefore all value
    types must have a public parameterless constructor. These two constraints, `struct`
    and `new()`, cannot be used together.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `unmanaged` constraint implies the `struct` constraint; therefore, these
    two cannot be used together. It also cannot be used with the `new()` constraint.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When using more than one constraint, the `new()` constraint must be mentioned
    last in the list of constraints.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `notnull` constraint is available as of C# 8 and must be used in a nullable
    context, otherwise, the compiler generates a warning. When the constraint is violated,
    the compiler does not generate an error but a warning.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As of C# 7.3, `System.Enum`, `System.Delegate`, and `System.MulticastDelegate`
    can be used as base class constraints.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Type parameters that do not have constraints are called *unbounded*. There
    are several rules for unbounded type parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: You cannot use the`!=` and `==` operators with these types since it is not possible
    to know whether the concrete type overloads them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They can be compared to `null`. For value types, this comparison will always
    yield `false`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They can be converted to and from `System.Object`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They can be converted to and from any interface type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To understand how constraints work, let''s start with the following example
    of a generic structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '`Point<T>` is a structure that represents a point in the two-dimensional space.
    This class is generic because we might want to use integral values for the point
    coordinates or real values (floating-point values). However, we can instantiate
    the class using any types, such as `bool`, `string`, or `Circle`, as shown in
    the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'To restrict the instantiation of `Point<T>` to numerical types (that is integral
    and floating-point types), we can write constraints for the type parameter `T`,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We have used two types of constraints: the `struct` constraint and the interface
    constraint, and they are listed separated by a comma. Unfortunately, there is
    no constraint to define a type as numeric but these constraints are the best combination
    to represent one because all numerical types are value types and they all implement
    the five interfaces listed here. The `bool` type implements the first four but
    not `IFormattable`. Therefore, instantiating `Point<T>` with `bool` or `string`
    will now produce compiler errors.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A type or method can have more than one type parameter and each of them can
    have their own constraints. We can see this in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The `RestrictedDictionary<TKey, TValue>` class is a special dictionary that
    allows only enumeration types for the key type. For this, it uses the base class
    constraint with `System.Enum`. The type of the value must be a reference type
    with a public default constructor. For this, it uses the `class` and `new()` constraints.
    This class has a public generic method called `Make<T>()`.
  prefs: []
  type: TYPE_NORMAL
- en: The type parameter, `T`, must be either `TValue` or a type derived from `TValue`
    and must also have a public default constructor. This method creates a new instance
    of the type, `T`, adds it to the dictionary in a list associated with the specified
    key, and returns a reference to the newly created object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s also consider the following hierarchy of shape classes. Notice that
    for simplicity these are kept to a minimum:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use the `RestrictedDictionary` class as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we are adding several shapes (a circle, ellipsis, rectangle,
    and square) to the restricted dictionary. The key type is `ShapeType` and the
    value type is `Shape`. The `Make()` method takes an argument of the `ShapeType`
    type and returns a reference to a shape object. Each type must be derived from
    `Shape` and have a public default constructor. Otherwise, the code would produce
    an error.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about generics in C#. Generics allow us to create
    parameterized types in C#. Generics enhance code reusability and ensure type safety.
    We explored how to create generic classes and generic structs. We also implemented
    inheritance in a generic class.
  prefs: []
  type: TYPE_NORMAL
- en: We learned how to implement constraints on the type parameters of a generic
    type or method. Constraints allow us to limit the data types that can be used
    as a type parameter. We also learned about creating generic methods and generic
    interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: You can use generics primarily for creating collections and wrappers. In the
    next chapter, we will explore the most important collections available in .NET.
  prefs: []
  type: TYPE_NORMAL
- en: Test what you learned
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are generics and what benefits do they provide?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are type parameters?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you define a generic class? What about generic methods?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can a class be derived from a generic type? What about structures?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a constructed type?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a covariant type parameter of a generic interface?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a contravariant type parameter of a generic interface?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are type parameter constraints and how are they specified?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does the `new()` type parameter constraint do?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What type parameter constraint was introduced in C# 8 and what does it do?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
