- en: Ansible Inventory and Playbook
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have Ansible installed, we can move on to the next milestone. We
    are now going to explore two major features: Ansible inventory, for client host
    organization, and Ansible playbooks, to demonstrate how to write Ansible play
    scripts. These two functionalities combined are the foundation for Ansible''s
    automation and orchestration. This chapter will cover how to use Ansible for quick
    commands or modules. We will also look at how to use its inventory to identify
    and configure hosts'' access and group them either statically or dynamically.
    Finally, we will introduce Ansible playbook and look at its actions, its handler,
    and its variables. We will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Using simple Ansible commands with manually set hosts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up our first Ansible static inventory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up and configuring a group inventory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up and configuring a dynamic inventory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ansible playbook overview and usage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ansible playbook best practices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advanced Ansible playbook features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic Ad hoc commands on Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When automating or orchestrating tasks, Ansible is mainly used with playbooks
    to allow subtasks to be scripted and organized in a handy pipeline. However, Ansible
    also has various ad hoc commands. These allow the execution of a module on a host,
    or group of hosts, no matter how they are identified.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once Ansible is installed, the ad hoc command line can be used directly. It
    can be easily tested, either by using it with the raw module or with some simple
    modules, such as `ping` or `shell`. As a quick example, each Ansible instance
    can ping itself using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/74a77b4d-21f1-4c4c-bd5e-8ba11452699b.png)The `-m` option indicates the
    module name that will be used while the task is running.'
  prefs: []
  type: TYPE_NORMAL
- en: Some could question the Ansible ad hoc commands usefulness. They are actually
    a great way to test your tasks in depth, thereby making it easier to debug step-by-step
    smaller bits of a bigger task and capture the error location or troubleshoot slow
    requests. For beginners, running simple commands may help to master the basic
    operation of the tool by solving simpler tasks and going up a notch until you
    reach more complex tasks—it's better to learn how to walk before you start running.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most common use for Ansible ad hoc commands is to run raw commands. A raw
    command is basically any line of Bash or PowerShell code to be sent to the host
    or hosts as is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Something like the following output will appear after executing the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/d2e5bbab-664b-449e-ad31-69b21f13539b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s try to run a command on a different host. For this, we need the host''s
    IP address or a fully qualified hostname, and a user where we can copy the SSH
    key. This can be done by physically copying the key to the user''s `~/.ssh` folder,
    or it can be done using the `ssh-copyid` command mentioned in [Chapter 2](cb196d17-b8ea-44f5-8114-4a91ae541566.xhtml),
    *Ansible Setup and Configuration*. After that, we run the following raw command
    to get information about the host:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This ad hoc command will produce an output as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/403e9087-8b8a-4c1f-918b-2be8d9ab2b06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Alternatively, we can try and make the host perform an elevated task that requires
    superuser privileges:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This is what the output should look like when executing the preceding command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/e771ea35-e758-41d8-a7ae-52595b1fc952.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If we use this command without the `--become` option, it will fail with a `permission
    denied` error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/bb228bf1-d11b-4c0b-8bbf-00a8f4685143.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This same task can be performed using Ansible modules. To do so, we use the
    `-m` option, followed by the name of the module and its arguments after the `-a`
    option, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Ansible also allows you to run tasks as another user by using the `--become`
    option to elevate the current user to a superuser, then selecting which user to
    use to run the command. It can also be done using the `-e` option and defining
    the variables in its input. The two commands are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This is what the output should look like when executing the preceding playbook:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/0ca3ee88-6294-408f-bfaa-59eb7715d795.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The ad hoc commands can also be used for a quick file transfer to multiple
    machines. We can either use a raw command, relying on `scp` or `rsync`, or we
    can also use the Ansible `copy` module. To be able to perform tasks on multiple
    hosts, we recommend using a quick static inventory. This can be done by adding
    a few lines to the `/etc/ansible/hosts` file or any other location that the Ansible
    configuration file points to. The file should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Grouping the three hosts under the `servers` name allows us to run tasks on
    all three hosts just by calling their group name. This is shown in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Some tasks are so simple that writing a playbook to achieve them is a huge
    waste of time. Also, any Ansible ad hoc command can be made into a playbook—an
    Ansible user could always try some of the commands and verify their parameters,
    before adding them to the playbook pipeline or workflow. This is a great way of
    troubleshooting and applying a quick update or fix on the fly. The following example
    shows how we can restart a replicate of web servers one at a time by setting the
    number of forks to one (with the `-f` option). This applies the restart command
    host by host:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Ansible inventory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ansible host management is simpler by far than all other configuration management
    and orchestration tools. It is basically a simple `.ini` file that contains a
    list of IP addresses, fully qualified hostnames, or short hostnames of the host
    clients. It also sometimes contains extra variables that define some aspects about
    the hosts. Generally, hosts are organized in groups with the name of the group
    put on top between two square brackets, such as `[Group1]`.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a new host is as easy and simple as adding a new line to the host file,
    making sure it is in the right group and that it has the right variables needed
    to manage it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the default Ansible configuration file, the inventory file is located at
    `/etc/ansible/hosts`. It is an `.ini` file with simple text and a basic structure
    composed of sections, properties, and values. Being the default location, however,
    does not make it the best. In many cases, Ansible can be used by non-root users
    who do not have the privileges to edit files located outside their home directory.
    Our recommendation for such an environment is to have all Ansible configuration
    files located in a folder within the home directory of the user. This means that
    these users can alter their configuration to accommodate their needs. Other than
    changing the Ansible configuration file to point to a different inventory location,
    we can also choose an inventory file while executing either an Ansible ad hoc
    command or a playbook by adding the `-i` option, followed by the location of the
    inventory file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Or, we can use the following
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The Ansible inventory does not just serve to arrange alike hosts; it is also
    much more useful when orchestrating tasks. Having several hosts that provide the
    same type of service (such as web servers, database controllers, or Web APIs)
    grouped in one group allows for a smarter and more efficient group control. A
    good host classification means that you can be more precise when applying fixes
    or optimizations to a specific service. Hosts can be part of multiple groups to
    allow them to answer to each task that is sent toward each specific aspect that
    they possess:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two types of inventory in Ansible: static and dynamic. In a small
    to medium environment or infrastructure, a static inventory should do just fine.
    However, when there is a very large number of hosts, the tasks can get complicated
    and errors may start to arise. A dynamic inventory relies on a third-party service, such
    as AWS EC2, Rackspace, and OpenStack, to provide it with its inventory. There
    is always the possibility of scripting your way through and filling your Ansible
    static host inventory files, which can be handy if you know what you are doing.'
  prefs: []
  type: TYPE_NORMAL
- en: When adding hosts with a similar pattern to an Ansible inventory file, we can
    simplify its syntax by changing the different pattern with a counter block, as
    in the following examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the original inventory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the simplified inventory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This inventory syntax is not limited to numbers in specific formats. It can
    also be used for alphabetic enumeration, that is, `[a:z]` or `[A:Z]`, or numbers
    with specific digits, such as `[001:250]`. It can be placed at any location in
    the hostname.
  prefs: []
  type: TYPE_NORMAL
- en: 'First let''s talk about the Ansible static inventory. As its name implies,
    it is a static host organisation in a text file. By default, it is an `.ini` file
    that is very simply structured in lines with values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, it can be a YAML file, structured like a Python script structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Most of our inventory examples will be written in the `.ini` file format. While
    the YAML format looks prettier and neater, it is easier and faster to write in
    .`ini` format.
  prefs: []
  type: TYPE_NORMAL
- en: 'A host inventory should be tolerant to all kinds and shapes of hosts. The Ansible
    inventory can accommodate these differences by introducing host and group variables.
    This is basically a way of defining each host or group with a certain aspect to
    help Ansible with its management. Host variables are very specific to the host
    and can only affect that host. The most commonly defined host variables are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ansible_user`: This value defines which user Ansible will be using to manage
    the host. It has the same function as the `-u` option, which is used in the ad
    hoc command.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ansible_host`: Some hosts may not be located in the DNS server, or we may
    want to give them different names. This variable allows us to point to the IP
    address of the host without checking how we choose to name it in the inventory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ansible_port`: This is also known as `host1:port`. This is used when the hosts
    are accessible via a certain port other than the default.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ansible_connection`: This varies between `ssh`, the default connection; `local`,
    to communicate with the local machine; and `docker`, for running commands directly
    in Docker containers that rely on the local machine''s Docker client. We will
    cover Ansible Docker usage in more detail in [Chapter 8](43750355-ab57-4d16-b464-10d2a47be2ea.xhtml),
    *Ansible Advanced Features*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ansible_become`: This option, when present, forces the host to execute all
    the commands on an elevated privilege (`sudo`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ansible_become_user`: This allows Ansible to run a command as a specific user
    other than the remote access user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ansible_ssh_pass`: This specifies the password to be used to access the host.
    This is not recommended, since the user''s password will be written in plain text.
    The next option is better.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ansible_ssh_private_key_file`: This option specifies the location of the private
    SSH key to be used to access this VM. This is much more secure than writing the
    password in plain text.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is a sample configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Some host variables can be defined under the group flag, especially when the
    hosts share the same admin username or SSH key. The group-specific variables are
    defined in the same way as the host variable, in a very simple text format. Group
    variables, however, have an extra feature: they can be defined in two ways, either
    on the inventory file or on separate files. By default, Ansible looks for them
    in the `/etc/ansible/group_vars/` folder.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Defining group variables in the inventory file should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: When running a task on a single host, or a part of a group that has its variables
    defined, those variables will be applied to the host as if they are host variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Host groups can also be organized into groups using the `:children` suffix
    in `.ini` files and the `children:` entry in the YAML files. This is how it looks
    in an INI format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Any variable applied to the parent group will get flattened to the hosts of
    each sub-group or child group. However, the variable of the sub-group overrides
    the parent variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The method recommended by Ansible is to define the group variables by storing
    them away from the inventory file and in the `group_vars` folder in separate YAML
    or JSON files. We will mainly be using the YAML format for the group variables
    file, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Each file will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Hosts can also have their variables stored in a YAML file. By default, this
    is located in the `/etc/ansible/host_vars/` folder. They share the same structure
    as the group variable files.
  prefs: []
  type: TYPE_NORMAL
- en: Variables defined in the playbook directory override those in the inventory
    directory. We will look closely at the playbook directory in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible also supports importing an inventory from other third-party frameworks,
    such as cloud providers, LDAP servers, or Cobbler. For each of these, there is
    a specific import script that needs to be executed with Ansible after the `-i`
    option for inventory selection. This starts the communication between Ansible
    and the third-party API that returns the inventory list. The execution should
    happen after filling in an `.ini` file with the appropriate parameters of the
    third-party server or API.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible playbook
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now things are starting to get interesting. Using Ansible playbooks, we will
    be able to achieve configuration management, orchestration, provisioning, and
    deployment. Playbook scripting uses the Ansible ad hoc commands in a more organized
    way, similar to the way in which shell scripting arranges shell commands to execute
    a task on a system, but more advanced than that. Ansible playbooks can set up
    and configure complex environments on bare metal, virtually, or on the cloud.
    It can sequence multi-tier machine roll-outs; apply systems, devices, and application
    patches and fixes; gather data from hosts or monitoring services; and act accordingly
    to send immediate actions to servers, network devices, and load balancers. All
    of these tasks can be delegated to other servers.
  prefs: []
  type: TYPE_NORMAL
- en: Playbooks are coded in a YAML data serialization format. This is a human-readable
    formatting, allowing the developer an easier sharing of their code and better
    organization as part of team projects. YAML is a very simple language compared
    to a traditional coding/scripting language.
  prefs: []
  type: TYPE_NORMAL
- en: 'Playbooks cannot do much on their own without their Ansible modules, which
    you can either get from Ansible Galaxy or build yourself. Modules will be explained
    in more detail in the next chapter. A playbook script runs multiple *plays*. Each
    one executes a number of *tasks*, which are composed of a number of modules on
    selected hosts from the Ansible inventory or from an external inventory, if this
    option is selected. These modules apply certain configuration changes, updates,
    or fixes to the selected hosts, depending on the nature of the module. A simple
    playbook running one play with one module to update the package manager cache
    is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we fill it in with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: YAML requires a very strict file structure when writing its files. Well-aligned
    action parameters are very important for the success of the playbook file.
  prefs: []
  type: TYPE_NORMAL
- en: 'We save the file and then run the `ansible-playbook` command as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The following output from the playbook''s execution shows if the playbook''s
    has made a change to the hosts:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c4ff726e-e56a-4bf6-9d3e-52236844a51b.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, a task called gathering facts has been executed within our simple
    playbook. This is a task that runs the module setup, which collects all of the
    useful information about the host or hosts in question.
  prefs: []
  type: TYPE_NORMAL
- en: 'When not needed, disabling the *gathering facts* task can increase the performance
    of your playbooks. This can be done by adding `gather_facts: False` when defining
    a play.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try to break down the structure of a playbook script. First, let''s
    explain the `name` option. This is an optional parameter, but it is highly recommended.
    When a simple and meaningful sentence is written as input to the `name` option,
    it helps provide a useful description of the play for improved user communication.
    It is also helpful when running the playbook, in order to see which plays have
    finished and which are still processing. A playbook output without the use of
    the `name` option looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: When executing the preceding playbook, the output should look as follows:![](assets/ecb764c3-0fe8-48ac-b4e2-5e8d88e91cb6.png)
  prefs: []
  type: TYPE_NORMAL
- en: 'We then have the `hosts` parameter or line. This is used to point to the inventory
    that the play should be run on, either to specify a certain group or host, or
    both of these combined. At the same level within the playbook, we can fill in
    other parameters underneath it. Those parameters can be host or group variables,
    used to enforce the parameters that are configured in their inventory files. These
    variables can be play-specified when we define them underneath the line hosts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'They can also be task-specific when we define them within the task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We then move to the tasks list, which is basically a list module to be executed
    in a series. Similarly to a playbook, each task can be named using the `name:` parameter.
    This is highly recommended for both documentation and to follow upon the status
    of tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'If a task fails, the playbook execution stops with the failure. To bypass this
    when running a non-critical task, we can always add the `ignore_errors: True` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'As you have seen from the two previous examples, each task''s action line can
    be used in two different ways: either broken down or in one line. You can choose
    which to use based on your needs.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, handlers are a major factor in making playbooks independent and automated,
    with less interaction for the user. They have the capacity to recognize changes
    and act accordingly. They are a way of controlling the system''s behaviors and
    running actions that respond to the needs of those behaviors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'When executing the preceding playbook, the output should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/bc82679e-452d-4db7-b266-91465d2f475d.png)Handlers can also be placed
    before the tasks in listen mode to enable action execution whenever they are triggered
    by multiple tasks.'
  prefs: []
  type: TYPE_NORMAL
- en: Advanced Ansible playbook scripting includes conditional and loop statements
    to give the developer various logic and patterns to play within their playbooks.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the `when` parameter is a way of implementing task control with
    conditions. Consider the following example, which only runs application updates
    when it is running on the right family of Linux:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The `when` parameter condition is not limited to values collected from the
    host system but also from the task''s execution status, which can be one of the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: Result has failed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Result has succeeded
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Result has been skipped
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are various other ways to use the playbook conditions. We will look at
    these in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'The loop statement can also be used. For this, we are going to use the `loop` parameter.
    In some cases, when we want to apply an action on multiple entries, we use the
    `vars:` parameter, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This can also be done using the `loop` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: In this chapter, we have only covered the tip of the iceberg of Ansible playbooks.
    There are many more advanced customizations and parameters that we cannot cover
    in this book. Ansible is well-known for its neat and well-maintained documentation,
    so we recommend you have a look at this for more information.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we saw how Ansible can be used to run quick and simple commands.
    We then looked at how Ansible manages its host inventory, which helped us to understand
    its playbook scripting. We discovered how playbooks are structured and how they
    are used to orchestrate tasks. In the next chapter, we will discover Ansible Modules
    and learn how they are important out of all the tasks that are executed within
    a playbook. We will look at both Linux and Windows system modules, some network
    devices, and various visualization and cloud managers.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ansible blog: [https://www.ansible.com/blog](https://www.ansible.com/blog)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ansible documentation: [https://docs.ansible.com/ansible/latest](https://docs.ansible.com/ansible/latest)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vagrant and Ansible lab GitHub repository:  [https://github.com/xanmanning/vagrant-ansible-lab](https://github.com/xanmanning/vagrant-ansible-lab)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
