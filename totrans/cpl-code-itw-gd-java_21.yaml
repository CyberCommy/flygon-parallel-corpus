- en: '*Chapter 17*:'
  prefs: []
  type: TYPE_NORMAL
- en: Functional-Style Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As you probably know, Java is not a purely functional programming language
    like Haskell, but starting with version 8, Java has added some functional-style
    support. The effort of adding this support was a success and functional-style
    code was widely adopted by developers and companies. Functional-style programming
    sustains code that is more understandable, maintainable, and testable. However,
    writing Java code in the functional style requires serious knowledge of lambdas,
    the stream API, `Optional`, functional interfaces, and so on. All these functional
    programming topics can be interview topics as well and, in this chapter, we will
    cover some of the hot questions that are mandatory to know for passing a regular
    Java interview. Our agenda contains the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Java functional-style programming in a nutshell
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Questions and coding challenges
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Java functional-style programming in a nutshell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As usual, this section is meant to highlight and refresh the main concepts of
    our topic and to provide a comprehensive resource for answering the fundamental
    questions that may occur in a technical interview.
  prefs: []
  type: TYPE_NORMAL
- en: Key concepts of functional-style programming
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So, the key concepts of functional programming include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Functions as first-class objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pure functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Higher-order functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's briefly dive into each of these concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Functions as first-class objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Saying that functions are first-class objects means that we can create an *instance*
    of a function as having a variable referencing that function instance. This is
    like referencing a `String`, `List`, or any other object. Moreover, functions
    can be passed as parameters to other functions. However, Java methods are not
    first-class objects. The best we can do is to rely on Java lambda expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Pure functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A *pure* function is a function whose execution has no *side effects* and the
    return value depends only on its input parameters. The following Java method is
    a pure function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If a method uses member variables or mutates the states of a member variable,
    then it is not a *pure* function.
  prefs: []
  type: TYPE_NORMAL
- en: Higher-order functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A higher-order function takes one or more functions as parameters and/or returns
    another function as a result. Java emulates higher-order functions via lambda
    expressions. In other words, in Java, a higher-order function is a method that
    gets one (or more) lambda expressions as arguments and/or returns another lambda
    expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the `Collections.sort()` method, which takes a `Comparator` as
    parameter, is a higher-order function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The first parameter of `Collections.sort()` is a `List` and the second parameter
    is a lambda expression. This lambda expression parameter is what makes `Collections.sort()`
    a higher-order function.
  prefs: []
  type: TYPE_NORMAL
- en: Pure functional programming rules
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, let''s briefly discuss pure functional programming rules. Pure functional
    programming has a set of rules to follow too. These are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: No state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No side effects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Immutable variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Favoring recursion over looping
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's briefly dive into each of these rules.
  prefs: []
  type: TYPE_NORMAL
- en: No state
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By *no state*, we do not mean that functional programming eliminates state.
    Commonly, no state means that there is no external state to the function. In other
    words, a function may work with local variables that contain temporary states
    internally, but it cannot reference any member variables of the class/object it
    belongs to.
  prefs: []
  type: TYPE_NORMAL
- en: No side effects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'By *no side effects*, we should understand that a function cannot change (mutate)
    any state outside of the function (outside of its functional scope). State outside
    of a function includes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The member variables in the class/object that contain that function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The member variables that are passed as parameters to the function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Or the state in external systems (for example, databases or files).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Immutable variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Functional programming encourages and sustains the usage of immutable variables.
    Relying on immutable variables helps us to avoid *side effects* in a much easier
    and more intuitive way.
  prefs: []
  type: TYPE_NORMAL
- en: Favoring recursion over looping
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Since recursion relies on repeated function calls to emulate looping, the code
    becomes more functional. This means that the following iterative approach for
    calculating factorials is not encouraged by functional programming:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Functional programming encourages the following recursive approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We use *tail recursion* to improve the performance penalty caused by the fact
    that, in the preceding example, every function call is saved as a frame in the
    recursion stack. Tail recursion is preferred when there are many recursive calls.
    In tail recursion, the function executes the recursive call as the last thing
    to do, so the compiler doesn''t need to save the function call as a frame in the
    recursion stack. Most compilers will optimize tail recursion, hence avoiding the
    performance penalty:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, looping can be achieved via the Java Stream API, which is functionally
    inspired:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now, it is time to practice some questions and coding challenges.
  prefs: []
  type: TYPE_NORMAL
- en: Questions and coding challenges
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we cover 21 questions and coding challenges that are very popular
    in interviews. Let's begin!
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 1 – Lambda parts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Problem**: Describe the parts of a lambda expression in Java. In addition,
    what characterizes a lambda expression?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: As the following diagram reveals, a lambda has three main parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.1 – Lambda parts'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_17.1_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 17.1 – Lambda parts
  prefs: []
  type: TYPE_NORMAL
- en: 'The parts of a lambda expression are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: On the left of the arrow, there are the parameters of this lambda that are used
    in the lambda body. In this example, these are the parameters of the `FilenameFilter.accept(File
    folder, String fileName)` method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the right of the arrow, there is the lambda body. In this example, the lambda
    body checks whether the folder (`folder`) in which the file (`fileName`) was found
    can be read and whether the name of this file is suffixed with the *.pdf* string.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The arrow that sits between the list of parameters and the body of a lambda
    acts as a separator.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, let''s talk about the characteristics of a lambda expression. So, if
    we write the anonymous class version of the lambda from the preceding diagram,
    then it will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now, if we compare the anonymous version and the lambda expression, then we
    notice that the lambda expression is a concise anonymous function that can be
    passed as a parameter to a method or be held in a variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The four words shown in the following diagram characterize a lambda expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.2 – Lambda characteristics'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_17.2_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 17.2 – Lambda characteristics
  prefs: []
  type: TYPE_NORMAL
- en: As a rule of thumb, keep in mind that lambdas sustain the Behavior Parameterization
    design pattern (a behavior is passed as parameter of a function) and it can be
    used only in the context of a functional interface.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 2 – Functional interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Problem**: What is a functional interface?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: In Java, a functional interface is an interface that contains
    only one abstract method. In other words, a functional interface contains only
    one method that is not implemented. So, a functional interface wraps a function
    as an interface and the function is represented by a single abstract method on
    the interface.'
  prefs: []
  type: TYPE_NORMAL
- en: Optionally, besides this abstract method, a functional interface can have default
    and/or static methods as well. Commonly, a functional interface is annotated with
    `@FunctionalInterface`. This is just an informative annotation type that's used
    to mark a functional interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of a functional interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As a rule of thumb, if an interface has more methods without implementation
    (that is, abstract methods), then it is no longer a functional interface. This
    means that such an interface cannot be implemented by a Java lambda expression.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 3 – Collections versus streams
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Problem**: What are the main differences between collections and streams?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: Collections and streams are quite different. Some of the differences
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`List`, `Set`, and `Map`), streams are meant to apply operations (for example,
    *filtering*, *mapping*, and *matching*) on that data. In other words, streams
    apply complex operations on a view/source represented by data stored on a collection.
    Moreover, any modification/change performed on a stream is not reflected in the
    original collection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data modification**: While we can add/remove elements from a collection,
    we cannot add/remove elements from a stream. Practically, a stream consumes a
    view/source, performs operations on it, and returns a result without modifying
    the view/source.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Iteration**: While a stream consumes a view/source, it automatically and
    internally performs the iteration of that view/source. The iteration takes place
    depending on the chosen operations that should be applied to the view/source.
    On the other hand, collections must be iterated externally.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Traversal**: While collections can be traversed multiple times, streams can
    be traversed only once. So, by default, Java streams cannot be reused. Attempting
    to traverse a stream twice will lead to an error reading *Stream has already been
    operated on or closed*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Construction**: Collections are eagerly constructed (all the elements are
    present right from the beginning). On the other hand, streams are lazily constructed
    (the so-called *intermediate* operations are not evaluated until a *terminal*
    operation is invoked).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coding challenge 4 – The map() function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`map()` function do and why would you use it?'
  prefs: []
  type: TYPE_NORMAL
- en: '`map()` function is an intermediate operation named *mapping* and available
    via the `Stream` API. It is used to transform a type of object to other type by
    simply applying the given function. So, `map()` traverses the given stream and
    transforms each element in a new version of it by applying the given function
    and accumulating the results in a new `Stream`. The given `Stream` is not modified.
    For example, transforming a `List<String>` into a `List<Integer>` via `Stream#map()`
    can be done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Challenge yourself to practice more examples. Try to apply `map()` to transform
    an array into another array.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 5 – The flatMap() function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`flatMap()` function do and why would you use it?'
  prefs: []
  type: TYPE_NORMAL
- en: '`flatMap()` function is an intermediate operation named *flattening* and is
    available via the `Stream` API. This function is an extension of `map()`, meaning
    that apart from transforming the given object into another type of object, it
    can also flatten it. For example, having a `List<List<Object>>`, we can turn it
    into a `List<Object>` via `Stream#flatMap()` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The next coding challenge is related to this one, so consider this as well.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 6 – map() versus flatMap()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`map()` and `flatMap()` functions?'
  prefs: []
  type: TYPE_NORMAL
- en: '`flatMap()` function is capable of flattening the given object as well. In
    other words, `flatMap()` can also flatten a `Stream` object.'
  prefs: []
  type: TYPE_NORMAL
- en: Why does this matter? Well, `map()` knows how to wrap a sequence of elements
    in a `Stream`, right? This means that `map()` can produce streams such as `Stream<String[]>`,
    `Stream<List<String>>`, `Stream<Set<String>>`, or even `Stream<Stream<R>>`. But
    the problem is that these kinds of streams cannot be manipulated successfully
    (that is, as we expected) by stream operations such as `sum()`, `distinct()`,
    and `filter()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s consider the following `List`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We try to obtain the distinct names of melons from this list. If wrapping an
    array into a stream can be done via `Arrays.stream()`, for a collection, we have
    `Collection.stream()`. Therefore, the first attempt may look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'But this will not work because `map()` will return `Stream<Stream<String>>`.
    The solution is provided by `flatMap()`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows: `Gac`, `Cantaloupe`, `Hemi`, `Apollo`.'
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, if you find trouble understanding these functional programming methods,
    then I strongly recommend you to read my other book, *Java Coding Problems*, available
    from Packt ([https://www.packtpub.com/programming/java-coding-problems](https://www.packtpub.com/programming/java-coding-problems)).
    That book contains two comprehensive chapters about Java functional-style programming
    that provide detailed explanations, diagrams, and applications useful for deep
    diving into this topic.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 7 – The filter() function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`filter()` function do and why would you use it?'
  prefs: []
  type: TYPE_NORMAL
- en: '`filter()` function is an intermediate operation named *filtering* available
    via the `Stream` API. It is used to filter the elements of a `Stream` that satisfy
    a certain condition. The condition is specified via the `java.util.function.Predicate`
    function. This predicate function is nothing but a function that takes as a parameter
    an `Object` and returns a `boolean`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assume that we have the following `List` of integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Streaming this list and extracting only non-zero elements can be accomplished
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting list will contain the following elements: `1`, `2`, `-4`, `2`,
    `-1`, `14`, `-1`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that, for several common operations, the Java `Stream` API already provides
    out-of-the-box intermediate operations. For example, there is no need to use `filter()`
    and define a `Predicate` for operations such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`distinct()`: Removes duplicates from the stream'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`skip(n)`: Discards the first `n` elements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`limit(s)`: Truncates the stream to be no longer than `s` in length'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sorted()`: Sorts the stream according to the natural order'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sorted(Comparator<? super T> comparator)`: Sorts the stream according to the
    given `Comparator`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All these functions are built into the `Stream` API.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 8 – Intermediate versus terminal operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Problem**: What is the main difference between intermediate and terminal
    operations?'
  prefs: []
  type: TYPE_NORMAL
- en: '`Stream`, while the terminal operations produce a result other than `Stream`
    (for example, a collection or a scalar value). In other words, intermediate operations
    allow us to chain/call multiple operations in a type of query named a *pipeline*.'
  prefs: []
  type: TYPE_NORMAL
- en: Intermediate operations are not executed until a terminal operation is invoked.
    This means that intermediate operations are lazy. Mainly, they are executed at
    the moment when a result of some given processing is actually needed. A terminal
    operation triggers the traversal of the `Stream` and the pipeline is executed.
  prefs: []
  type: TYPE_NORMAL
- en: Among the intermediate operations, we have `map()`, `flatMap()`, `filter()`,
    `limit()`, and `skip()`. Among the terminal operations, we have `sum()`, `min()`,
    `max()`, `count()`, and `collect()`.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 9 – The peek() function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`peek()` function do and why would you use it?'
  prefs: []
  type: TYPE_NORMAL
- en: '`peek()` function is an intermediate operation named *peeking* available via
    the `Stream` API. It allows us to see through a `Stream` pipeline. Mainly, `peek()`should
    execute a certain *non-interfering* action on the current element and forward
    the element to the next operation in the pipeline. Typically, this action consists
    of printing a meaningful message on the console. In other words, `peek()` is a
    good choice for debugging issues related to streams and lambda expression processing.
    For example, imagine that we had the following list of addresses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: It is important to mention that, even if `peek()` can be used to mutate state
    (to modify the data source of the stream), it stands for *look, but don't touch*.
    Mutating state via `peek()` can become a real problem in case of parallel stream
    pipelines because the mutating action may be called at whatever time and in whatever
    thread the element is made available by the upstream operation. So, if the action
    modifies the shared state, it is responsible for providing the required synchronization.
  prefs: []
  type: TYPE_NORMAL
- en: As a rule of thumb, think twice before using `peek()` to mutate the state. Also,
    be aware that this practice is a point of contention among developers and can
    be categorized as bad practice or even anti-pattern umbrellas.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 10 – Lazy streams
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Problem**: What does it mean to say that a stream is lazy?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: Saying that a stream is lazy means that a stream defines a pipeline
    of intermediate operations that are executed only when the pipeline encounters
    a terminal operation. This question is related to *Coding challenge 8* of this
    chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 11 – Functional interfaces versus regular interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Problem**: What is the main difference between a functional interface and
    a regular interface?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: The main difference between a functional interface and a regular
    interface consists of the fact that a regular interface can contain any number
    of abstract methods, while a functional interface can have only one abstract method.'
  prefs: []
  type: TYPE_NORMAL
- en: You can consult *Coding challenge 2* of this book for a deeper understanding.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 12 – Supplier versus Consumer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Supplier` and `Consumer`?'
  prefs: []
  type: TYPE_NORMAL
- en: '`Supplier` and `Consumer` are two built-in functional interfaces. `Supplier`
    acts as a factory method or as the `new` keyword. In other words, `Supplier` defines
    a method named `get()` that doesn''t take arguments and returns an object of type
    `T`. So, a `Supplier` is useful to *supply* some value.'
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, `Consumer` defines a method named `void accept(T t)`. This
    method accepts a single argument and returns `void`. The `Consumer` interface
    *consumes* the given value and applies some operations to it. Unlike other functional
    interfaces, `Consumer` may cause *side effects*. For example, `Consumer` can be
    used as a setter method.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 13 – Predicates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Predicate`?'
  prefs: []
  type: TYPE_NORMAL
- en: '`Predicate` is a built-in functional interface that contains an abstract method
    whose signature is `boolean test(T object)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `test()` method tests a condition and returns `true` if that condition is
    met, otherwise it returns `false`. A common usage of a `Predicate` is in conjunction
    with the `Stream<T> filter(Predicate<? super T> predicate)` method for filtering
    unwanted elements of a stream.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 14 – findFirst() versus findAny()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`findFirst()` and `findAny()`?'
  prefs: []
  type: TYPE_NORMAL
- en: '`findFirst()` method returns the first element from the stream and is especially
    useful in obtaining the first element from a sequence. It returns the first element
    from the stream as long as the stream has a defined order. If there is no encounter
    order, then `findFirst()` returns any element from the stream.'
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, the `findAny()` method returns any element from the stream.
    In other words, it returns an arbitrary (non-deterministic) element from the stream.The
    `findAny()` method ignores the encountered order, and, in a non-parallel operation,
    it will most likely return the first element, but there is no guarantee of this.
    In order to maximize performance, the result cannot be reliably determined in
    parallel operations.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that, depending on the stream's source and the intermediate operations,
    streams may or may not have a defined encounter order.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 15 – Converting arrays to streams
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Problem**: How would you convert an array to a stream?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: Converting an array of objects into a stream can be done in at
    least three ways, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first is via `Arrays#stream()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Second, we can use `Stream#of()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The last technique is via `List#stream()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Converting an array of primitives (for example, integers) into a stream can
    be done in at least two ways, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Firstly, via `Arrays#stream()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Secondly, by using `IntStream#of()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Of course, for longs, you can use `LongStream`, and for doubles, you can use
    `DoubleStream`.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 16 – Parallel streams
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Problem**: What is a parallel stream?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: A parallel stream is a stream that can parallelize the execution
    using multiple threads. For example, you may need to filter a stream of 10 million
    integers to find the integers smaller than a certain value. Instead of using a
    single thread to traverse the stream sequentially, you can employ a parallel stream.
    This means that multiple threads will concurrently search for those integers in
    different parts of the stream and then combine the result.'
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 17 – The method reference
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Problem**: What is a method reference?'
  prefs: []
  type: TYPE_NORMAL
- en: '`::`, and the name of the method is provided after it. We have the following
    references:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A method reference to a static method: *Class*::*staticMethod* (for example,
    `Math::max` is equivalent to `Math.max(`*x*`,` *y*`)`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A method reference to a constructor: *Class*::*new* (for example, `AtomicInteger::new`
    is equivalent to `new AtomicInteger(`*x*`)`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A method reference to an instance method from instance: *object*::*instanceMethod*
    (`System.out::println` equivalent to `System.out.println(`*foo*`)`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A method reference to an instance method from class type: *Class*::*instanceMethod*
    (`String::length` equivalent to `str.length()`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coding challenge 18 – The default method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Problem**: What is a default method?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: Default methods were added to Java 8 mainly to provide support
    for interfaces so that they can evolve beyond an abstract contract (that is, containing
    only abstract methods). This facility is very useful for people who write libraries
    and want to evolve APIs in a compatible way. Via default methods, an interface
    can be enriched without disrupting existing implementations.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A default method is implemented directly in the interface and is recognized
    by the `default` keyword. For example, the following interface defines an abstract
    method called `area()` and a default method called `perimeter()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Since `Polygon` has a single abstract method, it is a functional interface as
    well. So, it can be annotated with `@FunctionalInterface`.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 19 – Iterator versus Spliterator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Iterator` and `Spliterator`?'
  prefs: []
  type: TYPE_NORMAL
- en: '`Iterator` was created for the `Collection` API, while `Spliterator` was created
    for the `Stream` API.'
  prefs: []
  type: TYPE_NORMAL
- en: By analyzing their names, we notice that *Spliterator* = *Splittable Iterator*.
    Hence, a `Spliterator` can split a given source and it can iterate it, too. Splitting
    is needed for parallel processing. In other words, an `Iterator` can sequentially
    iterate the elements in `Collection`, while a `Spliterator` can iterate the elements
    of a stream in parallel or sequential order.
  prefs: []
  type: TYPE_NORMAL
- en: An `Iterator` can traverse the elements of a collection only via `hasNext()`/`next()`
    because it doesn't have a size. On the other hand, a `Spliterator` can provide
    the size of the collection either by approximating it via `estimateSize()` or
    exactly via `getExactSizeIfKnown()`.
  prefs: []
  type: TYPE_NORMAL
- en: A `Spliterator` can use several flags for internally disabling unnecessary operations
    (for example, `CONCURRENT`, `DISTINCT`, and `IMMUTABLE`). An `Iterator` doesn't
    have such flags.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you can create a `Spliterator` around an `Iterator` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In the book *Java Coding Problems* ([https://www.amazon.com/gp/product/B07Y9BPV4W/](https://www.amazon.com/gp/product/B07Y9BPV4W/)),
    you can find more details on this topic, including a complete guide for writing
    a custom `Spliterator`.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 20 – Optional
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Optional` class?'
  prefs: []
  type: TYPE_NORMAL
- en: '`Optional` class was introduced in Java 8 with the main purpose of mitigating/avoiding
    `NullPointerException`. The Java language architect Brian Goetz''s definition
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Optional is intended to provide a limited mechanism for library method return
    types where there needed to be a clear way to represent no result, and using null
    for such was overwhelmingly likely to cause errors.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'In a nutshell, you can think of `Optional` as a single value container that
    contains either a value or is empty. For example, an empty `Optional` looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'And a non-empty `Optional` looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In *Java Coding Problems* ([https://www.amazon.com/gp/product/B07Y9BPV4W/](https://www.amazon.com/gp/product/B07Y9BPV4W/)),
    you can find a complete chapter dedicated to best practices for using `Optional`.
    This is a must-read chapter for any Java developer.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 21 – String::valueOf
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`String::valueOf` mean?'
  prefs: []
  type: TYPE_NORMAL
- en: '`String::valueOf` is a method reference to the `valueOf` static method of the
    `String` class. Consider reading *Coding challenge 17* as well for more information
    on this.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we've covered several hot topics regarding functional-style
    programming in Java. While this topic is quite extensive, with many books dedicated
    to it, the questions covered here should be enough to pass a regular Java interview
    that covers the main features of the Java 8 language.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss scaling-related questions.
  prefs: []
  type: TYPE_NORMAL
