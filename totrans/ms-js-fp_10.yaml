- en: Ensuring Purity - Immutability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 4](943d8f5d-2e39-409a-a1aa-26c1a5b36a6d.xhtml), *Behaving Properly
    - Pure Functions*, when we considered pure functions and their advantages, we
    saw that side-effects such as modifying a received argument or a global variable
    were frequent causes for impurity. Now, after several chapters dealing with many
    aspects and tools of FP, let''s get to the concept of *immutability*: how to work
    with objects in such a way that accidentally modifying them will become harder
    or, even better, impossible.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We cannot force developers to work in a safe, guarded way, but if we find some
    way to make data structures immutable (meaning that they cannot be directly changed,
    except through some interface that never allows modifying the original data, but
    produces new objects instead) then we''ll have an enforceable solution. In this
    chapter, we will see two distinct approaches to working with such immutable objects
    and data structures:'
  prefs: []
  type: TYPE_NORMAL
- en: Basic JS ways, such as freezing objects, plus cloning to create new ones instead
    of modifying existing objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Persistent data structures, with methods that allow updating them without changing
    the original and without the need to clone everything either, for higher performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A warning: the code in this chapter isn''t production-ready; I wanted to focus
    on the main points and not on all the myriad details having to do with properties,
    getters, setters, prototypes, and more, that you should take into account for
    a full, bulletproof, solution. For actual development, I''d very much recommend
    going with a third-party library, but only after checking that it really applies
    to your situation. We''ll be recommending several such libraries, but of course
    there are many more that you could use.'
  prefs: []
  type: TYPE_NORMAL
- en: The straightforward JS way
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the biggest causes of side-effects was the possibility of a function
    modifying either global objects or its arguments themselves. All non-primitive
    objects are passed as references, so when/if you modify them, the original objects
    will be changed. If we want to stop this (without just depending on the goodwill
    and clean coding of our developers) we may want to consider some straightforward
    JS techniques to disallow those side-effects.
  prefs: []
  type: TYPE_NORMAL
- en: Mutator functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A common source of unexpected problems comes from the fact that several JS methods
    actually modify the underlying object. In this case, by merely using them, you
    will be causing a side-effect, which you may even not recognize. Arrays are the
    basic source of problems and the list of troublesome methods is not short. (See
    [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array#Mutator_methods](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array#Mutator_methods)
    for more on each method.)
  prefs: []
  type: TYPE_NORMAL
- en: '`.copyWithin()` lets you copy elements within the array'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.fill()` fills an array with a given value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.push()` and `.pop()` let you add or delete elements at the end of an array'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.shift()` and `.unshift()` work the same way, but at the beginning of the
    array'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.splice()` lets you add or delete elements anywhere within the array'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.reverse()` and `.sort()` modify the array in place, reversing its elements
    or ordering them'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For some of these operations, you might generate a copy of the array and then
    work with that. In the *Argument mutation* section of [Chapter 4](943d8f5d-2e39-409a-a1aa-26c1a5b36a6d.xhtml),
    *Behaving Properly - Pure Functions*, we did just that with the spread operator;
    we could have used `.slice()` as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Setter methods are also mutators and will logically produce side-effects because
    they can do just about anything. If this is the case, you'll have to go for some
    of the other solutions described later.
  prefs: []
  type: TYPE_NORMAL
- en: Constants
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If the mutations do not happen because of using some JS methods, then we might
    want to attempt using `const` definitions, but that just won't work. In JS, a
    const definition means only that the *reference* to the object or array cannot
    change (so you cannot assign a different object to it) but you can still modify
    the properties of the object itself.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: So, if you decide to use `const` everywhere, you will be safe only against direct
    assignments to objects and arrays. More modest side-effects, such as changing
    an attribute or an array element, will still be possible, so this is not a solution.
  prefs: []
  type: TYPE_NORMAL
- en: What can work is using *freezing* to provide un-modifiable structures and *cloning*
    to produce modified new ones. These are probably not the best way to go about
    forbidding objects to be changed but can be used as a makeshift solution. Let's
    go with both of them in some detail.
  prefs: []
  type: TYPE_NORMAL
- en: Freezing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we want to avoid the possibility of a programmer accidentally or willingly
    modifying an object, freezing it is a valid solution. After an object has been
    frozen, any attempts at modifying it will silently fail.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Don''t confuse freezing with sealing: `Object.seal()`, applied to an object,
    prohibits adding or deleting properties to it, so the structure of the object
    is immutable, but the attributes themselves can be changed. `Object.freeze()`
    includes not only sealing properties but also making them unchangeable. See [https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/seal](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/seal)
    and [https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze)
    for more on this.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is only one problem with this solution: freezing an object is a *shallow*
    operation, that freezes the attributes themselves similarly to what a `const`
    declaration does. If any of the attributes are objects or arrays themselves, with
    further objects or arrays as properties, and so on, they can still be modified.
    We will only be considering data here; you may also want to freeze, say, functions,
    but for most use cases it''s data you want to protect.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This is only partially successful, as we can see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to achieve real immutability for our object, we need to write a
    routine that will freeze all the levels of an object. Fortunately, it''s easy
    to achieve that by applying recursion. Mainly, the idea is to first freeze the
    object itself and then recursively freeze each of its properties. We must take
    care we only freeze the object''s own properties; we shouldn''t mess with the
    prototype of the object, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Note that, in the same way as `Object.freeze()` works, `deepFreeze()` also freezes
    the object *in place*. I wanted to keep the original semantics of the operation,
    so the returned object will always be the original one. If we wanted to work in
    a purer fashion, we should first make a copy of the original object (we'll be
    seeing how to do this in the next section) and then freeze that.
  prefs: []
  type: TYPE_NORMAL
- en: 'There remains a small possible problem, but with a very bad result: what would
    happen if an object included, somewhere down there, a reference to itself? We
    can avoid that if we skip freezing already frozen objects: backward circular references
    would then be ignored since objects they refer to would be already frozen. So,
    the logic we wrote took care of that problem and there''s nothing more to be done!'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we apply `deepFreeze()` to an object, we can safely pass it to any function,
    knowing that there simply is no way in which it can be modified. You can also
    use this property to test whether a function modifies its arguments: deep freeze
    them, call the function, and if the function depends on modifying its arguments,
    it will not work, because the changes will be silently ignored. But, then, how
    can we return a result from a function, if it involves a received object? This
    can be solved in many ways, and a simple one uses cloning, as we''ll see.'
  prefs: []
  type: TYPE_NORMAL
- en: Check the *Questions* section at the end of this chapter, for another way of
    freezing an object by means of proxies.
  prefs: []
  type: TYPE_NORMAL
- en: Cloning and mutating
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If mutating an object isn't allowed, then you must create a new object. For
    example, if you use Redux, a reducer is a function that receives the current state
    and an action (essentially, an object with new data) and produces the new state.
    Modifying the current state is totally forbidden and we could avoid this error
    by always working with frozen objects, as we saw in the previous section. Then,
    in order to fulfill the reducer requirements, we will have to be able to clone
    the original state, plus mutate it accordingly to the received action, and that
    resulting object will then become the new state.
  prefs: []
  type: TYPE_NORMAL
- en: You may want to revisit the *More general looping* section of [Chapter 5](3cf24154-32aa-4bcd-bfbe-e9de8fe35096.xhtml),
    *Programming Declaratively - A Better Style*, where we wrote a basic `objCopy()`
    function that provides a different approach from the one shown here.
  prefs: []
  type: TYPE_NORMAL
- en: 'To round things off, we should also freeze the returned object, as we did with
    the original state. But let''s start at the beginning: how do we clone an object?
    Of course, you can always do it by hand, but that''s not something you''d really
    want to consider when working with large, complex objects.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now, going for more automatic solutions, there are a couple of straightforward
    ways of copying arrays or objects in JS, but they have the same *shallowness*
    problem.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If an object or array includes objects (which may themselves include objects,
    and so on) we get the same problem as with freezing: objects are copied by reference,
    which means that a change in the new object will also imply changing the old object.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: There is a simple solution, based on JSON. If we `stringify()` the original
    object and then `parse()` the result, we'll get a new object but its totally separate
    from the old one.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This works with both arrays and objects, but there''s a problem, anyway. If
    any of the properties of the object have a constructor, it won''t get invoked:
    the result will always be composed of plain JS objects. We can see this very simply
    with a `Date()`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We could do a recursive solution, as with deep freezing, and the logic is quite
    similar. Whenever we find a property that is really an object, we invoke the appropriate
    constructor.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This solves the problem we found with dates or, in fact, with any object! If
    we run the code above, but using `deepCopy()` instead of `jsonCopy()`, we'll get
    `object object` as output, as it should be. If we check types and constructors,
    everything will match. Furthermore, the data changing experiment will also work
    fine now.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we know how to copy an object, we can work in this way:'
  prefs: []
  type: TYPE_NORMAL
- en: Receive a (frozen) object as an argument.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make a copy of it, which won't be frozen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Take values from that copy, to use in your code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify the copy at will.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Freeze it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return it as the result of the function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All of this is viable, though a bit cumbersome. So, let's add a couple of functions
    that will help bring everything together.
  prefs: []
  type: TYPE_NORMAL
- en: Getters and setters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Doing all the work we listed at the end of the previous section, every time
    you want to update a field, would probably become troublesome, and prone to errors.
    Let's add a pair of functions to be able to get values from a frozen object, but
    unfreezing them so they become usable by you, and to allow modifying any property
    of the object, creating a new copy of it, so the original won't be actually modified.
  prefs: []
  type: TYPE_NORMAL
- en: Getting a property
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Back in the *Getting a property from an object* section in [Chapter 6](9f36fbcb-da30-4a75-9b47-01cd3427633e.xhtml),
    *Producing Functions - Higher-Order Functions*, we wrote a simple `getField()`
    function that could handle getting a single attribute out of an object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We could get a deep attribute out of an object by composing a series of applications
    of `getField()`calls, but that would be rather cumbersome. Rather, let's have
    a function that will receive a *path* -an array of field names- and will return
    the corresponding part of the object, or will be undefined if the path doesn't
    exist. Using recursion is quite appropriate and simplifies coding!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Once an object has been frozen, you cannot *defrost* it, so we must resort
    to making a new copy of it; `deepCopy()` is quite appropriate for that. Let''s
    try out our new function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We can also check that returned objects are not frozen.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Setting a property by path
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we wrote this, we can code a similar `setByPath()` function that will
    take a path, a value, and an object, and update an object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We are using recursion here to get into the object, creating new attributes
    if needed, until we have traveled the full length of the path. One important detail,
    when creating attributes, is whether we need an array or an object. We can determine
    that by checking the next element in the path: if it''s a number, then we need
    an array; otherwise, an object will do. When we get to the end of the path, we
    simply assign the new given value.'
  prefs: []
  type: TYPE_NORMAL
- en: If you like this way of doing things, you should check out the *seamless-immutable*
    library, which works exactly in this fashion. The *seamless* part of the name
    alludes to the fact that you still work with normal objects, albeit frozen!, so
    you can use `.map()`, `.reduce()`, and so on. Read more about it at [https://github.com/rtfeldman/seamless-immutable](https://github.com/rtfeldman/seamless-immutable).
  prefs: []
  type: TYPE_NORMAL
- en: We can then write a function that will be able to take a frozen object and update
    an attribute within it, returning a new, also frozen, object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We can check out how it works: let''s run several updates on the `myObj3` object
    we have been using.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Given this pair of functions, we have finally gotten ourselves a way to keep
    immutability:'
  prefs: []
  type: TYPE_NORMAL
- en: Objects must be frozen from the beginning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting data from objects is done with `getByPath()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting data is done with `updateObject()`, which internally uses ``setByPath()``
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you want to see another way of using setters and getters to accomplish functional
    access and updates to objects, check out lenses, provided by libraries such as
    Ramda. Lenses can be seen as a functional way of not only getting and setting
    variables, but also running functions over them, in a composable way: a *something*
    that lets you focus on a specific part of a data structure, access it, and possibly
    also change it or apply functions to it. Check out more starting at [http://ramdajs.com/docs/#lens.](http://ramdajs.com/docs/#lens.)'
  prefs: []
  type: TYPE_NORMAL
- en: Persistent data structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If every time you want to change something in a data structure, you just go
    and change it, your code will be full of side-effects. On the other hand, copying
    complete structures every time is a waste of time and space. There's a middle
    way, with persistent data structures, which, if handled correctly, let you apply
    changes while creating new structures, in an efficient way.
  prefs: []
  type: TYPE_NORMAL
- en: Working with lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s consider a simple procedure: suppose you have a list, and you want to
    add a new element to it. How would you do it? We can assume each node is a `NodeList`
    object.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'A possible list would be as follows, where a `list` variable would point to
    the first element. See figure 10.1:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/6de96866-8506-4eae-9ad7-54d464e40287.jpg)Figure 10.1\. The initial
    list. (Can you tell what is missing in this list, and where?)'
  prefs: []
  type: TYPE_IMG
- en: 'If you wanted to add D between B and F (this is something musicians will understand:
    we have here the *Circle of Thirds*, but D is missing) the simplest solution would
    be to just add a new node and change an existing one, to get the following result.
    See figure 10.2:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ba086145-a541-4238-9230-c876d1014ef7.jpg)Figure 10.2\. The list
    has now a new element: we had to modify an existing one to do the addition.'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, working in this way is obviously non-functional and it''s clear we
    are modifying data. There is a different way of working, by creating a persistent
    data structure, in which all alterations (insertions, deletions, and modifications)
    are done separately, being careful not to modify existing data. On the other hand,
    if some parts of the structure can be reused, this is done to gain in performance.
    Doing a persistent update would return a new list, with some nodes that are duplicates
    of some previous ones, but with no changes whatsoever to the original list. See
    figure 10.3:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/aeff7170-298f-418b-8481-93d246c2778d.jpg)Figure 10.3\. The dotted
    elements show the newly returned list: some elements had to be duplicated to avoid
    modifying the original structure. Old list refers to the original structure and
    new list to the result of the insertion.'
  prefs: []
  type: TYPE_NORMAL
- en: Of course, we will also deal with updates or deletions. Starting again with
    the list as in Figure 10.4, if we wanted to update its fourth element, the solution
    would imply creating a new subset of the list, up to and including the fourth
    element, while keeping the rest unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ecbdcf64-6a9b-4bd1-9b30-169c7d25f790.jpg)Figure 10.4\. Our list,
    with a changed element.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Removing an element would also be similar. Let''s do away with the third element,
    F, in the original list. See figure 10.5:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/1a66ce0d-d5f3-435f-b687-4ee1e7a8c798.jpg)Figure 10.5\. The original
    list, after removing the 3^(rd) element in a persistent way.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Working with lists or other structures can always be solved to provide data
    persistence. But, let''s now focus on what will probably be the most important
    kind of work for us: dealing with simple JS objects. After all, all data structures
    are JS objects, so if we can work with any objects, we can work with other structures.'
  prefs: []
  type: TYPE_NORMAL
- en: Updating objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This kind of method can also be applied to more common requirements, such as
    modifying an object. This is a very good idea for, say, Redux users: a reducer
    can be programmed that will receive the old state as a parameter and produce an
    updated version with the minimum needed changes, without altering the original
    state in any way.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine you had an object as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'If you wanted to modify `myObj.d.f`, and wanted to do it in a persistent way,
    you would create a new object, which would have several attributes in common with
    the previous object, but would define new ones for the modified ones. See figure
    10.6:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c62a4319-a79b-45fa-9e71-35bdcf5666ac.jpg)Figure 10.6\. A persistent
    way of editing an object, by creating a new one with some shared attributes, and
    some new ones.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you had wanted to do this by hand, you would have had to write, in a very
    cumbersome way, something like the following. Most attributes are taken from the
    original object, but `d` and `d.f` are new:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We already saw similar code earlier in this chapter, when we decided to work
    on a cloning function, but let's now go for a different type of solution. In fact,
    this kind of update can be automated.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The logic is recursive, but not too complex. First, we figure out, at the current
    level, what kind of object we need: either an array or an object. Then, we copy
    all attributes from the original object to the new one, except the property we
    are changing. Finally, we set that property to the given value (if we have finished
    with the path of property names), or we use recursion to go deeper with the copy.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note the order of the arguments: first the path, then the value, and finally
    the object. We are applying the concept of putting the most *stable* parameters
    first and the most variable last. If you curry this function, you can apply the
    same path to several different values and objects, and if you fix the path and
    the value, you can still use the function with different objects.'
  prefs: []
  type: TYPE_NORMAL
- en: We can give this logic a try. Let's start with a nonsensical object, but with
    several levels and even an array of objects, for variety.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We can test changing `myObj.d.f` to a new value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The logs at the bottom verify that the algorithm is working correctly: `myObj2.d`
    is a new object, but `myObj2.d.g` is re-using the value from `myObj`.'
  prefs: []
  type: TYPE_NORMAL
- en: Further updating the array in the second object lets us test also how the logic
    works in those cases.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We can compare the elements in the `myObj.d.j` array with the ones in the newly
    created object, and you can see that the array is a new one, but two of the elements
    (the ones that weren't updated) are still the same objects as in `myObj`.
  prefs: []
  type: TYPE_NORMAL
- en: This obviously isn't enough to get by. Our logic can update an existing field,
    or even add it if it wasn't there, but you'd also require the possibility of eliminating
    some attribute. Libraries usually provide many more functions, but let's at least
    work on the deletion of an attribute, to see other important structures change
    in an object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The logic is similar to that of `setIn()`. The difference is that we do not
    always copy all attributes from the original object to the new one: we only do
    that while we haven''t yet arrived at the end of the array of path properties.
    Continuing the series of tests after the updates, we get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: With this pair of functions, we can manage to work with persistent objects,
    doing changes, additions, and deletions, in an efficient way that won't create
    new objects needlessly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Probably the best-known library for working with immutable objects is the appropriately
    named *immutable.js*, at [https://facebook.github.io/immutable-js/](https://facebook.github.io/immutable-js/).
    The only weak point about it is its notoriously obscure documentation. However,
    there''s an easy solution for that: check out *The Missing Immutable.js Manual
    With All The Examples You’ll Ever Need* at [http://untangled.io/the-missing-immutable-js-manual/](http://untangled.io/the-missing-immutable-js-manual/)
    and you won''t have any trouble!'
  prefs: []
  type: TYPE_NORMAL
- en: A final caveat
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Working with persistent data structures requires some cloning, but how would
    you implement a persistent array? If you think about this, you'll realize that,
    in that case, there would be no way out apart from cloning the whole array after
    each operation. This would mean that an operation such as updating an element
    in an array, which took a basically constant time, would now take a length of
    time proportional to the size of the array.
  prefs: []
  type: TYPE_NORMAL
- en: In algorithm complexity terms, we would say that updates went from being an
    O(1) operation to an O(n) one. Similarly, access to an element may become an O(log
    n) operation, and similar slow-downs might be observed for other operations, such
    as mapping, reducing, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: How do we avoid this? There's no easy solution. For example, you may find that
    an array is internally represented as a binary search tree (or even more complex
    data structures) and the persistence library provides the needed interface so
    you'll be still able to use it as an array, not noticing the internal difference.
  prefs: []
  type: TYPE_NORMAL
- en: When using this kind of libraries, the advantages of having immutable updates
    without cloning may be offset in part by some operations that may become slower.
    If this becomes a bottleneck in your application, you might even have to go so
    far as changing the way you implement immutability or even work out some way of
    changing your basic data structures to avoid the time loss, or at least minimize
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 10.1\. **Freezing by proxying**. In the *Chaining and Fluent Interfaces*section
    of [Chapter 8](8e0f575a-87f7-4601-b47c-6872aaacb954.xhtml), *Connecting Functions
    - Pipelining and Composition*, we used a proxy for getting operations in order
    to provide for automatic chaining. By using a proxy for *setting* and *deleting*
    operations, you may do your own *freezing* (if, instead of setting an object's
    property, you'd rather throw an exception). Implement a `freezeByProxy(obj)` function
    that will apply this idea to forbid all kinds of updates (adding, modifying, or
    deleting properties) for an object. Remember to work recursively, in case an object
    has other objects as properties!
  prefs: []
  type: TYPE_NORMAL
- en: '10.2\. **Inserting into a list, persistently**. In the *Working with lists*
    section, we described how an algorithm could add a new node to a list, but in
    a persistent way, by creating a new list as we earlier described. Implement an
    `insertAfter(list, newKey, oldKey)` function that will create a new list, but
    adding a new node with key `newKey` just after the node with key `oldKey`. You
    may assume the nodes of the list were created by the following logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we have seen two different approaches (actually used by commonly
    available immutability libraries) to avoiding side-effects by working with immutable
    objects and data structures: one was based on using JavaScript''s *object freezing*
    plus some special logic for cloning and the other applied the concept of persistent
    data structures, with methods that allowed all kinds of updates without either
    changing the original or requiring full cloning.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In Chapter 11, *Implementing Design Patterns - The Functional Way*, we will
    focus on a question often asked by object-oriented programmers: how are design
    patterns used in FP? Are they required, available, or usable? Are they still practiced
    but with a new focus on functions rather than on objects? We''ll answer these
    questions with several examples showing where and how they are equivalent or they
    differ from the usual OOP practices.'
  prefs: []
  type: TYPE_NORMAL
