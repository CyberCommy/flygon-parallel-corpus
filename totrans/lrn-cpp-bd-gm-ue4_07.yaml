- en: Dynamic Memory Allocation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we talked about class definitions and how to devise
    your own custom class. We discussed how, by devising your own custom classes,
    you can construct variables that represent entities within your game or program.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will talk about dynamic memory allocation and how to create
    space in memory for groups of objects. Let''s take a look at the topics covered
    in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Constructors and destructors revisited
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamic memory allocation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regular arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: C++ style dynamic size arrays (new[] and delete[])
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamic C-style arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vectors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constructors and destructors revisited
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Assume that we have a simplified version of `class Player`, as before, with
    only a constructor and a destructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We talked earlier about the *scope* of a variable in C++; to recap, the scope
    of a variable is the section of the program where that variable can be used. The
    scope of a variable is generally inside the block in which it was declared. A
    block is just any section of code contained between `{` and `}`. Here is a sample
    program that illustrates variable scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/089f6225-04df-4f5c-993d-fcb0765a7f5a.png)'
  prefs: []
  type: TYPE_IMG
- en: In this sample program, the x variable has scope through all of main(). The
    y variable's scope is only inside the if block.
  prefs: []
  type: TYPE_NORMAL
- en: 'We mentioned previously that, in general, variables are destroyed when they
    go out of scope. Let''s test this idea out with instances of `class Player`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this program is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The destructor for the `Player` object is called at the end of the player object's
    scope. Since the scope of a variable is the block within which it is defined in
    the three lines of code, the `Player` object would be destroyed immediately at
    the end of `main()`, when it goes out of scope.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic memory allocation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, let's try allocating a `Player` object dynamically. What does that mean?
  prefs: []
  type: TYPE_NORMAL
- en: 'We use the `new` keyword to allocate it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this program is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The player does not die! How do we kill the player? We must explicitly call
    `delete` on the `player` pointer.
  prefs: []
  type: TYPE_NORMAL
- en: The delete keyword
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `delete` operator invokes the destructor on the object being deleted, as
    shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the program is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: So, only normal (or automatic, also called non-pointer type) variable types
    get destroyed at the end of the block in which they were declared. Pointer types
    (variables declared with `*` and `new`) are not automatically destroyed, even
    when they go out of scope.
  prefs: []
  type: TYPE_NORMAL
- en: What is the use of this? Dynamic allocation lets you control when an object
    is created and destroyed. This will come in handy later.
  prefs: []
  type: TYPE_NORMAL
- en: Memory leaks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, dynamically allocated objects created with `new` are not automatically deleted,
    unless you explicitly call `delete` on them. There is a risk here! It is called
    a *memory leak*. Memory leaks happen when an object allocated with `new` is not
    ever deleted. What can happen is that, if a lot of objects in your program are
    allocated with `new` and then you stop using them, your computer will eventually
    run out of memory due to memory leakage.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a ridiculous sample program to illustrate the problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This program, if left to run long enough, will eventually gobble the computer''s
    memory, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f33d9c48-4e20-4276-9e66-97d6a9c19fe3.png)'
  prefs: []
  type: TYPE_IMG
- en: 2 GB of RAM used for Player objects.
  prefs: []
  type: TYPE_NORMAL
- en: Note that no one ever intends to write a program with this type of problem in
    it! Memory leak problems happen accidentally. You must take care of your memory
    allocation and `delete` objects that are no longer in use.
  prefs: []
  type: TYPE_NORMAL
- en: Regular arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An array in C++ can be declared as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The way this looks in memory is something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/110fedec-6e9f-4833-82f1-e9bd06c15964.png)'
  prefs: []
  type: TYPE_IMG
- en: 'That is, inside the `array` variable are five slots or elements. Inside each
    of the slots is a regular `int` variable. You can also declare an array by passing
    in values, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: You can also pass in `int` variables to use the values stored there.
  prefs: []
  type: TYPE_NORMAL
- en: The array syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So, how do you access one of the `int` values in the array? To access the individual
    elements of an array, we use square brackets, as shown in the following line of
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s very similar to the syntax for creating an array in the first place.
    The preceding line of code would change the element at slot `0` of the array to
    a `10`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/da693da7-325f-4d27-b8eb-1f38a9f0786f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In general, to get to a particular slot of an array, you will write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Keep in mind that array slots are always indexed starting from `0` (some languages
    may start from `1`, but that's unusual and could get confusing). To get into the
    first slot of the array, use `array[0]`. The second slot of the array is `array[1]`
    (not `array[2]`). The final slot of the preceding array is `array[4]` (not `array[5]`).
    The `array[5]` data type is out of bounds of the array! (There is no slot with
    index 5 in the preceding diagram. The highest index is 4.)
  prefs: []
  type: TYPE_NORMAL
- en: Don't go out of the bounds of the array! It might work sometimes, but other
    times your program will crash with a **memory access violation** (accessing memory
    that doesn't belong to your program). In general, accessing memory that does not
    belong to your program will will cause your app to crash, and if it doesn't do
    so immediately, there will be a hidden bug in your program that will only cause
    problems once in a while. You must always be careful when indexing an array.
  prefs: []
  type: TYPE_NORMAL
- en: Arrays are built into C++, that is, you don't need to include anything special
    to have immediate use of arrays. You can have arrays of any type of data that
    you want, for example, arrays of `int`, `double`, `string`, and even your own
    custom object types (`Player`).
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create an array of five strings and put some names inside it(made up or random—it
    doesn't matter).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an array of doubles called `temps` with three elements and store the
    temperature for the last three days in it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following is a sample program with an array of five strings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is just the array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: C++ style dynamic size arrays (new[] and delete[])
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It probably occurred to you that we won't always know the size of an array at
    the start of a program. We would need to allocate the array's size dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: However, if you've tried it, you might have noticed that this doesn't work!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try and use the `cin` command to take in an array size from the user.
    Let''s ask the user how big he wants his array and try to create one of that size
    for him:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We get an error. The problem is that the compiler wants to allocate the size
    of the array. However, unless the variable size is marked `const`, the compiler
    will not be sure of its value at compile time. The C++ compiler cannot size the
    array at compile time, so it generates a compile time error.
  prefs: []
  type: TYPE_NORMAL
- en: 'To fix this, we have to allocate the array dynamically (on the "heap"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'So, the lessons here are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: To allocate an array of some type (for example, `int`) dynamically, you must
    use new `int[numberOfElementsInArray]`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arrays allocated with `new[]` must be deleted later with `delete[]`, otherwise,
    you'll get a memory leak (that's `delete[]` with square brackets; not regular
    delete)!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamic C-style arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: C-style arrays are a legacy topic, but they are still worth discussing, since
    even though they are old, you might still see them used sometimes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The way we declare a C-style array is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The differences are highlighted here.
  prefs: []
  type: TYPE_NORMAL
- en: 'A C-style array is created using the `malloc()` function. The word malloc stands
    for memory allocate. This function requires you to pass in the size of the array
    in bytes to create, and not just the number of elements you want in the array.
    For this reason, we multiply the number of elements requested (`size`) by `sizeof`
    of the type inside the array. The sizes in bytes of a few typical C++ types are
    listed in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| C++ primitive type | `sizeof` (size in bytes) |'
  prefs: []
  type: TYPE_TB
- en: '| `int` | `4` |'
  prefs: []
  type: TYPE_TB
- en: '| `float` | `4` |'
  prefs: []
  type: TYPE_TB
- en: '| `double` | `8` |'
  prefs: []
  type: TYPE_TB
- en: '| `long long` | `8` |'
  prefs: []
  type: TYPE_TB
- en: Memory allocated with the `malloc()` function must later be released using `free()`.
  prefs: []
  type: TYPE_NORMAL
- en: Vectors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There's one other way of creating what are essentially arrays, and this one
    is the easiest to use and is preferred by many programmers—using a vector. Imagine
    that, in any of the previous examples, you were adding new items into an array
    and suddenly ran out of space while the program was running. What would you do?
    You could create a whole new array and copy everything over, but as you might
    guess, that's a lot of extra work and processing. So, what if you had a type of
    array that handled cases like that for you behind the scenes, without you even
    asking?
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what vectors do. A vector is a member of the Standard Template Library
    (we will get to templates in a couple of chapters, so just be patient), and as
    in other examples that have come up, you can set the type inside angled brackets
    (`<>`). You create a vector like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This basically says you are creating a vector of strings, called names. To
    add new items to a vector, you can use the `push_back()` function, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This will add the item you pass in to the end of the vector. You can call `push_back()`
    as many times as you want, and whenever the vector runs out of space, it will
    automatically increase its size without you having to do anything! So, you can
    keep adding as many items as you want (within reason, since you could run out
    of memory eventually), without worrying about how the memory is managed.
  prefs: []
  type: TYPE_NORMAL
- en: Vectors also add other useful functions, such as `size()`, which tells you how
    many items a vector contains (in a standard array, you have to keep track of this
    yourself).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have created a vector, you can treat it just like an array to access
    it with standard `[]` syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter introduced you to C and C++ style arrays and vectors. In most UE4
    code, you will use the UE4 editor built-in collection classes (`TArray<T>`), which
    are similar to vectors. However, you need familiarity with basic C and C++ style
    arrays to be a very good C++ programmer.
  prefs: []
  type: TYPE_NORMAL
- en: We've now covered enough basic C++ to move on to UE4 next, with actors and pawns.
  prefs: []
  type: TYPE_NORMAL
