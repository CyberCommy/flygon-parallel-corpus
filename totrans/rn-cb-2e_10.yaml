- en: App Workflow and Third-Party Plugins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter works a bit differently, so we will first look into it before
    we go ahead and cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: React Native development tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Planning your app and choosing your workflow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using NativeBase for cross-platform UI components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using glamorous-native for styling UI components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using react-native-spinkit for adding animated loading indicators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using react-native-side-menu for adding side navigation menus
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using react-native-modalbox for adding modals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How this chapter works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we'll be taking a closer look at how each method of bootstrapping
    a new React Native app works, and how we can integrate third-party packages that
    may or may not be Expo friendly. In previous chapters, the focus has been entirely
    on building functional pieces of a React Native app. In this chapter, many of
    these recipes will therefore also serve a secondary purpose of illustrating how
    different packages can be implemented using different workflows.
  prefs: []
  type: TYPE_NORMAL
- en: 'In most of the recipes in this chapter, we will begin with a pure React Native
    project initialized with the React Native CLI command, which is done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: When creating a new React Native app, you'll need to choose the right tooling
    for initializing your app. Generally speaking, the tools you use for bootstrapping
    and developing your React Native app will either focus on streamlining the development
    process and purposefully obfuscating native code from you for the sake of ease
    and mental overhead, or keep your development process flexible by providing access
    to all native code and allowing the use of more third-party plugins.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two methods for initializing and developing your app: Expo and the
    React Native CLI. Until recently, there was a distinct third method, using **Create
    React Native App** (**CRNA**). CRNA has since been merged with the Expo project,
    and only continues to exist as a separate entity to provide backwards compatibility.'
  prefs: []
  type: TYPE_NORMAL
- en: Expo falls into the first category of tools, providing a more robust and developer-friendly
    development workflow at the cost of some flexibility. Apps bootstrapped with Expo
    also have access to a multitude of useful features provided by the Expo SDK, such
    as  `BarcodeScanner`, `MapView`, `ImagePicker`, and so many more.
  prefs: []
  type: TYPE_NORMAL
- en: 'Initialize an app with the React Native CLI, via the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This provides flexibility at the cost of ease of development.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: It is said to be a pure React Native app, since none of the native code is hidden
    away from the developer.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a rule of thumb, a pure React Native app will be required if using third-party
    packages whose setup requires running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'So what do you do when you are halfway through building an app with Expo, only
    to find out that a package integral to your app''s requirements is not supported
    by an Expo development workflow? Luckily, Expo has a method for turning an Expo
    project into a pure React Native app, just as if it had been created with the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: When a project is ejected, all of the Native code is unpacked into `ios` and
    `android` folders, and the `App.js` file is split into `App.js` and `index.js`,
    exposing the code that mounts the root React Native component.
  prefs: []
  type: TYPE_NORMAL
- en: But what if your Expo app depends on features provided by the Expo SDK? After
    all, much of the value of developing with Expo comes from the excellent features
    the SDK provides, including `AuthSession`, `Permissions`, `WebBrowser`, and others.
  prefs: []
  type: TYPE_NORMAL
- en: That’s where ExpoKit comes into play. When you choose to eject from a project,
    you’re given the option of including ExpoKit as part of the ejected project. Including
    ExpoKit will ensure that all of the Expo dependencies being used in your app will
    continue to work, and also give you the ability to continue using all the features
    of the Expo SDK, even after the app has been ejected.
  prefs: []
  type: TYPE_NORMAL
- en: For a deeper understanding of the eject processes, you can read the Expo documentation
    at [https://docs.expo.io/versions/latest/expokit/eject](https://docs.expo.io/versions/latest/expokit/eject).
  prefs: []
  type: TYPE_NORMAL
- en: React Native development tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As with any development tools, there is going to be a trade-off between flexibility
    and ease of use. I encourage you start by using Expo for your React Native development
    workflow, unless you’re sure you’ll need access to the native code.
  prefs: []
  type: TYPE_NORMAL
- en: Expo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This was taken from the [expo.io](http://expo.io) site:'
  prefs: []
  type: TYPE_NORMAL
- en: '"Expo is a free and open source toolchain built around React Native to help
    you build native iOS and Android projects using JavaScript and React."'
  prefs: []
  type: TYPE_NORMAL
- en: 'Expo is becoming an ecosystem of its own, and is made up of five interconnected
    tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Expo CLI**: The command-line interface for Expo.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We''ve been using the Expo CLI to create, build, and serve apps. A list of
    all the commands supported by the CLI can be found in the official documentation
    at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[  https://docs.expo.io/versions/latest/workflow/expo-cli](https://docs.expo.io/versions/latest/workflow/expo-cli)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Expo developer tools**: This is a browser-based tool that automatically runs
    whenever an Expo app is started from the Terminal via the `expo start` command.
    It provides active logs for your in-development app, and quick access to running
    the app locally and sharing the app with other developers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Expo Client**: An app for Android and iOS. This app allows you to run your
    React Native project within the Expo app on the device, without the need for installing
    it. This allows developers to hot reload on a real device, or share development
    code with anyone else without the need for installing it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Expo Snack**: Hosted at [https://snack.expo.io](https://snack.expo.io/),
    this web app allows you to work on a React Native app in the browser, with a live
    preview of the code you’re working on. If you''ve ever used CodePen or JSFiddle,
    Snack is the same concept applied to React Native applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Expo SDK**: This is the SDK that houses a wonderful collection of JavaScript
    APIs that provide Native functionality not found in the base React Native package,
    including working with the device''s accelerometer, camera, notifications, geolocation,
    and many others. This SDK comes baked in with every new project created with Expo.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These tools together make up the Expo workflow. With the Expo CLI, you can create
    and build new applications with Expo SDK support baked in. The CLI also provides
    a simple way to serve your in-development app by automatically pushing your code
    to Amazon S3 and generating a URL for the project. From there, the CLI generates
    a QR code linked to the hosted code. Open the Expo Client app on your iPhone or
    Android device, scan the QR code, and BOOM there’s your app, equipped with hot
    reload! And since the app is hosted on Amazon S3, you can even share the in-development
    app with other developers in real time.
  prefs: []
  type: TYPE_NORMAL
- en: React Native CLI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The original bootstrapping method for creating a new React Native app using
    the command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This is provided by the React Native CLI. You'll likely only be using this method
    of bootstrapping a new app if you're sure you'll need access to the native layer
    of the app.
  prefs: []
  type: TYPE_NORMAL
- en: In the React Native community, an app created with this method is said to be
    a pure React Native app, since all of the development and Native code files are
    exposed to the developer. While this provides the most freedom, it also forces
    the developer to maintain the native code. If you’re a JavaScript developer that’s
    jumped onto the React Native bandwagon because you intend on writing native applications
    solely with JavaScript, having to maintain the native code in a React Native project
    is probably the biggest disadvantage of this method.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, you'll have access to more third-party plugins when working
    on an app that's been bootstrapped this process.
  prefs: []
  type: TYPE_NORMAL
- en: Get direct access to the native portion of the code base. You'll also be able
    to sidestep a few of the limitations in Expo currently, particularly the inability
    to use background audio or background GPS services.
  prefs: []
  type: TYPE_NORMAL
- en: CocoaPods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once you begin working with apps that have components that use native code,
    you're going to be using CocoaPods in your development as well. CocoaPods is a
    dependency manager for Swift and Objective-C Cocoa projects. It works nearly the
    same as npm, but manages open source dependencies for native iOS code instead
    of JavaScript code.
  prefs: []
  type: TYPE_NORMAL
- en: 'We won''t be using CocoaPods much in this book, but React Native makes use
    of CocoaPods for some of its iOS integration, so having a basic understanding
    of the manager can be helpful. Just as the `package.json` file houses all of the
    packages for a JavaScript project managed with npm, CocoaPods uses a `Podfile`
    for listing a project''s iOS dependencies. Likewise, these dependencies can be
    installed using the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Ruby is required for CocoaPods to run. Run the command at the command line
    to verify Ruby is already installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If not, it can be installed with Homebrew with the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Once Ruby has been installed, CocoaPods can be installed via the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: If you encounter any issues while installing, you can read the official CocoaPods
    *Getting Started* guide at [https://guides.cocoapods.org/using/getting-started.html](https://guides.cocoapods.org/using/getting-started.html).
  prefs: []
  type: TYPE_NORMAL
- en: Planning your app and choosing your workflow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When trying to choose which development workflow best fits your app''s needs,
    here are a few things you should consider:'
  prefs: []
  type: TYPE_NORMAL
- en: Will I need access to the native portion of the code base?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Will I need any third-party packages in my app that are not supported by Expo,
    that is require running the command react-native link?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Will my app need to play audio while it is not in the foreground?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Will my app need location services while it is not in the foreground?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Am I comfortable working, at least nominally, in Xcode and Android Studio?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In my experience, Expo usually serves as the best starting place. It provides
    a lot of benefits to the development process, and gives you an escape hatch in
    the eject process if your app grows beyond the original requirements. I would
    recommend only starting development with the React Native CLI if you're sure your
    app needs something that cannot be provided by an Expo app, or if you're sure
    you will need to work on the native code.
  prefs: []
  type: TYPE_NORMAL
- en: I also recommend browsing the Native Directory hosted at [http://native.directory](http://native.directory).
    This site has a very large catalog of the third-party packages available for React
    Native development. Each package listed on the site has an estimated stability,
    popularity, and links to documentation. Arguably the best feature of the Native
    Directory, however, is the ability to filter packages by what kind of device/development
    they support, including iOS, Android, Expo, and web. This will help you narrow
    down your package choices and better indicate which workflow should be adopted
    for a given app.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll begin with the React Native CLI setup of our app, which will create a
    new pure React Native app, giving us access to all of the Native code, but also
    requiring that Xcode and Android Studio are installed.
  prefs: []
  type: TYPE_NORMAL
- en: You may recall from [Chapter 1](2cdfc766-d9d3-4f8f-ba71-521e82b8fed5.xhtml),  *Setting
    Up Your Environment*, that some of these steps have already been covered in detail.
    There is no need to reinstall anything listed here that was described there as
    well.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll install all the dependencies needed for working with a pure React
    Native app, starting with the Homebrew ([https://brew.sh/](https://brew.sh/))
    package manager for macOS. As stated on the project''s home page, Homebrew can
    be easily installed from the Terminal via the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Once Homebrew is installed, it can be used to install the dependencies needed
    for React Native development: Node.js and `nodemon`. If you''re a JavaScript developer,
    you''ve likely already got Node.js installed. You can check it''s installed via
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This command will list the version of Node.js that''s installed, if any. Note
    that you will need Node.js version 8 or higher for React Native development. If
    Node.js is not already installed, you can install it with Hombrew via the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need the `nodemon` package, which React Native uses behind the scenes
    to enable things like live reload during development. Install `nodemon` with Homebrew
    via the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll also of course need the React Native CLI for running the commands that
    bootstrap the React Native app. This can be installed globally with `npm` via
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'With the CLI installed, all it takes to create a new pure React Native app
    is the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This will create a new project in a new `name-of-project` directory. This project
    has all Native code exposed, and requires Xcode for running the iOS app and Android
    Studio for running the Android app. Luckily, installing Xcode for supporting iOS
    React Native development is a simple process. The first step is to download Xcode
    from the App Store and install it. The second step is to install the Xcode command-line
    tools. To do this, open Xcode, choose Preferences... from the Xcode menu, open
    the Locations panel, and install the most recent version from the Command Line
    Tools dropdown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/d954acd0-be2c-4e74-aebc-e06fa08acb92.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Unfortunately, setting up Android Studio for supporting Android React Native
    development is not as cut and dry, and requires some very specific steps for installing
    it. Since this process is particularly involved, and since there is some likelihood
    that the process will have changed by the time you read this chapter, I recommend
    referring to the official documentation for in-depth, up-to-date instructions
    on installing all Android development dependencies. These instructions are hosted
    at the following URL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[  https://facebook.github.io/react-native/docs/getting-started.html#java-development-kit](https://facebook.github.io/react-native/docs/getting-started.html#java-development-kit)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that all dependencies have been installed, we''re able to run our pure
    React Native project via the command line. The iOS app can be executed via the
    following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'And the Andriod app can be started with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Be sure you are already running the Android emulator before trying to open
    your Android app. These commands should start up your app on the associated emulator
    for the correct platform, install the new app, and run the app within the emulator.
    If you have any trouble with either of these commands not behaving as expected,
    you might be able to find an answer in the React Native troubleshooting docs,
    hosted here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://facebook.github.io/react-native/docs/troubleshooting.html#content](https://facebook.github.io/react-native/docs/troubleshooting.html#content)'
  prefs: []
  type: TYPE_NORMAL
- en: Expo CLI setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Expo CLI can be installed using the Terminal with `npm` via the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The Expo CLI can be used to do all the great things the Expo GUI client can
    do. For all the commands that can be run with the CLI, check out the docs here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.expo.io/versions/latest/workflow/expo-cli](https://docs.expo.io/versions/latest/workflow/expo-cli)'
  prefs: []
  type: TYPE_NORMAL
- en: Using NativeBase for cross-platform UI components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Similar to Bootstrap on the web, NativeBase is a collection of React Native
    components for improving the efficiency of React Native app development. The components
    cover a wide range of use cases for building out UI in Native applications, including ActionSheets, Badges, Cards,
    Drawers, and grid layouts.
  prefs: []
  type: TYPE_NORMAL
- en: 'NativeBase is a library that supports both pure React Native applications (those
    created with the React Native CLI via `react-native init`) and Expo powered applications.
    Instructions for installing NativeBase into one type of project or another is
    outlined in the *Getting Started* section of the NativeBase documentation, hosted
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/GeekyAnts/NativeBase#4-getting-started](https://github.com/GeekyAnts/NativeBase#4-getting-started)'
  prefs: []
  type: TYPE_NORMAL
- en: Since this is the case, we'll take this opportunity to outline both scenarios
    in the *Getting ready* section of this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whichever method of bootstrapping you use for this recipe, we'll be keeping
    the *How to do it...* section of the recipe as consistent as possible. One difference
    that we'll need to take into account is the project naming convention of each
    app creation method. Pure React Native applications are named in Pascal case (MyCoolApp)
    and Expo applications are named in kebab case (my-cool-app). If you're creating
    a pure React Native app, you can use the app name `NativeBase`, and if you're
    using Expo you can name it `native-base`.
  prefs: []
  type: TYPE_NORMAL
- en: Using a pure React Native app (React Native CLI)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Assuming you''ve followed the introduction to this chapter, you should already
    have the React Native CLI installed globally. If not, go ahead and do so now with
    `npm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'To create a new pure React app with the CLI, we''ll use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates a new pure React Native app in a folder called `NativeBase` in
    the current directory. The next step is to install the required peer dependencies.
    Let''s `cd` into the new `NativeBase` directory and install the `native-base`
    package using `npm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can use `yarn`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we will install the Native dependencies with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'If we open up the project in an IDE and look at the folder structure of this
    pure React Native app, we''ll see a few slight differences from the Expo applications
    we''ve become accustomed to at this point. First, the repository has an `ios`
    and an `android` folder, each containing Native code for the respective platform.
    There''s also an `index.js` file at the root of the project that is not included
    in an app bootstrapped with Expo. In an app made with Expo, this file would be
    obscured away, just like the `ios` and `android` folders, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This simply serves as the bootstrapping process of your React Native app at
    runtime. `AppRegistry` is imported from the `react-native` packages, the main
    `App` component is imported from the `App.js` file at the root of the directory,
    and the `AppRegistry` method `registerComponent` is called with two parameters:
    the name of our app (`NativeBase`), and an anonymous function that returns the `App`
    component. For more information on `AppRegistry`, you can find the documentation
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://facebook.github.io/react-native/docs/appregistry.html](https://facebook.github.io/react-native/docs/appregistry.html)'
  prefs: []
  type: TYPE_NORMAL
- en: One other minor difference is the existence of two sets of development instructions
    in the `App.js` boilerplate code, displaying the appropriate dev instructions
    through the use of the `Platform` component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember to stop and think whenever you see a third-party React Native package
    whose installation instructions include running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: It is usually safe to assume it is not compatible with an Expo app unless explicitly
    stated otherwise. In the case of NativeBase, we have an option to use either setup,
    so let's cover getting started with our other option next, bootstrapping with
    Expo.
  prefs: []
  type: TYPE_NORMAL
- en: Using an Expo app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Setting up Native Base in an app created with Expo is as simple as installing
    the required dependencies with `npm` or `yarn`. First, we can create the app using
    the Expo CLI on the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the app is created, we can `cd` into it and install the dependencies for
    NativeBase with `npm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can use `yarn`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'When using NativeBase with Expo, the NativeBase documentation recommends loading
    fonts asynchronously with the `Expo.Font.loadAsync` method in the `componentWillMount`
    method in the `App.js` component. We''ll cover how to do this in the appropriate
    step in the *How to do it...* section of this recipe. You can start up the app from
    the CLI with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll start by adding the imports we''ll be using in the `App` component in
    `App.js`. While this app won''t have much functionality, we will be using a number
    of components from NativeBase to see how they can help improve your workflow,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s declare the `App` class and define a starting `state` object.
    We''ll be adding a FAB section to show how NativeBase lets you easily add fly-out
    menu buttons to your app. We will track whether this menu should be displayed
    or not with the `fabActive` Boolean. We''ll also use the `loading` Boolean later
    in the `render` method, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'You may recall from the *Getting ready* section of the recipe, if you''re developing
    an app with Expo, NativeBase suggests loading the fonts used by NativeBase via
    the `Expo.Font.loadAsync` function. In the `componentWillMount` method, we''ll
    initialize and await the loading of `require` fonts, then set the `loading` property
    on `state` to `false`. The `loading` property will be referenced in the `render`
    method to determine whether the app has finished loading, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Since this app is mostly UI, we're ready to start building the `render` function.
    To make sure fonts are loaded before we use them, we return the App placeholder
    Expo component, `AppLoading`, if the `loading` property of `state` is true, otherwise
    we'll render the App UI. `AppLoading` will instruct the app to continue displaying
    the app's splash screen until the component is removed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you chose to start this recipe with a pure React Native project, you won't
    have access to Expo components. You can simply return an empty `View` instead
    of `AppLoading` in this case.
  prefs: []
  type: TYPE_NORMAL
- en: We'll start with the `Container` component, along with the `Header`, `Body`,
    and `Title` helper components. This will act as the container for the page, displaying
    a header at the top of the page with the title Header Title!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, the app should look similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/0de58427-fa11-43e7-8b9f-33ad9287a412.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the following code, the `Header` will have a few more UI elements from NativeBase.
    The `Spinner` component allows for easily displaying a loading spinner with the
    desired color passed in as a prop. The `Button` component provides buttons with
    more built-in customizability when compared with the vanilla `TouchableOpacity`
    component. Here, we''re using the `block` prop to spread the buttons across their
    container, and an `info` and `success` prop on each to apply their respective
    default blue and green background colors:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding render function also refers to a `renderFab` method we have not
    yet defined. This makes use of the `Icon` and `Fab` components. NativeBase uses
    the same `vector-icons` package as Expo under the hood (defaulting to Ionicon
    fonts if no `type` prop is provided), which was covered in the *Using Font icons*
    recipe in [Chapter 3](4d1b8446-1a41-4729-9bc2-7e525cb1f206.xhtml), *Implementing
    Complex User Interfaces – Part I*, so please refer to that recipe for more information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s round this recipe out with a few styles to align things within the `View`
    and apply colors to our layout, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Looking back at the completed app, there''s now a nice spread of UI that is
    cross-platform and easy to use:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/d5fc973a-9043-4415-a3f9-3c9ad419b6ac.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While the more complicated portion of this recipe was the set-up of the app
    itself, we had a quick review of a few of the components provided by NativeBase
    that might be able to help you develop your next app more efficiently. If you
    prefer to work in a widget-based system similar to what Bootstrap ([https://getbootstrap.com/](https://getbootstrap.com/))
    or Semantic-UI ([https://semantic-ui.com/](https://semantic-ui.com/)) provide
    on the web platform, be sure to give NativeBase a spin. For more information on
    all of the components that NativeBase offers and how to use them, you can find
    the official documentation at [http://docs.nativebase.io/Components.html](http://docs.nativebase.io/Components.html).
  prefs: []
  type: TYPE_NORMAL
- en: Using glamorous-native for styling UI components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As a JavaScript developer, you''re likely familiar with CSS on the web and
    how it''s used to style web pages and web applications. More recently, a technique
    called CSS-in-JS has came along in web development, which uses the power of JavaScript
    to adapt CSS for a more modular, component-based styling approach. One of the
    main benefits of CSS-in-JS tools is their ability to produce styles that are scoped
    to a given element, instead of the default cascading behavior of vanilla JavaScript.
    Scoped CSS allows a developer to apply styles in a more predictable and modular
    way. This in turn increases usability in larger organizations and makes packaging
    and publishing styled components easier. If you''d like to learn more about how
    CSS-in-JS works or where CSS-in-JS comes from conceptually, I''ve written an article
    on the topic on the gitconnected Medium blog called *A Brief History of CSS-in-JS:
    How We Got Here and Where We''re Going*, hosted at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://levelup.gitconnected.com/a-brief-history-of-css-in-js-how-we-got-here-and-where-were-going-ea6261c19f04](https://levelup.gitconnected.com/a-brief-history-of-css-in-js-how-we-got-here-and-where-were-going-ea6261c19f04).'
  prefs: []
  type: TYPE_NORMAL
- en: The `StyleSheet` component that comes packaged with React Native is an implementation
    of CSS-in-JS. One of the most popular implementations of CSS-in-JS on the web
    is `glamorous`, a library created by the venerable Kent C. Dodds. This library
    inspired the excellent React Native styling library `glamorous-native`, which
    we will be using in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll need to create a new app for this recipe. This package does not require
    running the following command during setup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: So, should work just fine with an Expo app. Let's name the recipe `glamorous-app`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will also need to install the glamorous-app package. This can be installed
    with `npm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, we can use `yarn`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start by importing all the dependencies we''ll need in `App.js`, as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Our app will need a containing `View` element to hold all of the other components
    displayed in the app. Instead of styling this element with an object passed to
    the `StyleSheet` component, like we''ve been doing in all previous recipes, we''ll
    use `glamorous` by passing a style object to the `view` method, which returns
    a styled  `View` component that we store in a `const` called `Container` for later
    use,  as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, we''ll add three styled `Text` components using `glamorous.text`.
    By doing this, we have three more styled and explicitly named components ready
    to be used in `render`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll also make a reusable `Button` component with the `glamorous.touchableHighlight`
    method. This method shows how `glamorous` components can also be created with
    multiple style declarations of different types. The second parameter passed to `touchableHighlight`
    in this case is a function that updates the `backgroundColor` style depending
    on the `props` defined on the element, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also create components styled inline, thanks to the special versions
    of React Native components `glamorous` ships with. We will use an `Image` component,
    but instead of importing it from `react-native`, we use the `Image` component
    from the imported `glamorous` package, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we are ready to declare the `App` component. `App` will only need a `render`
    function for rendering all our newly styled components, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s begin building out the render function by adding the `Container` component
    we created in *step 2*. The improvement in code readability is already apparent.
    The `Container` is explicitly named and needs no other attributes or properties
    to declare styles, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s add the `Image` component that we pulled from the imported `glamorous`
    library in *step 5*. Notice how we are able to declare style properties such as `height`, `width`,
    and `borderRadius` as props directly on the component, unlike the vanilla `Image`
    component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we''ll add the `Headline` and `Subheading` components we created in *step
    3*. Just like the `Container` component, these two components read much more clearly
    than one `View` and two `Text` elements ever could:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we''ll add the `Button` component we created in *step 4*, and the
    `ButtonText` component we created in *step 3*. Both buttons have an `onPress`
    method like any `TouchableOpacity` or `TouchableHighlight` component would, but
    the second `Button` also has a `warning` prop, causing it to have a red background
    instead of blue:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: All of our `glamorous` components have been added to the `render` method. If
    you run the app, you should be greeted by a fully styled UI.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/acf7555d-906d-4fc6-be06-c266bedcdddb.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *step 2* and *step 3*, we created styled `View` and `Text` components by
    using the corresponding `glamorous` method and passing in an object containing
    all the styles that should be applied to that particular component.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 4*, we created a reusable `Button` styled component by applying the
    same method used for creating the `View` and `Text` components in previous steps.
    The way styles are declared in this component is different, however, and shows
    off the versatility `glamorous-native` has when processing styles. You can pass
    any number of style collections as parameters to a `glamorous` component constructor
    and they will all be applied. This includes dynamic styles, which usually take
    the form of using props defined on the component to apply different styles. In
    *step 10*, we used our `Button` element. If the prop `warning` is present, as
    it is on the first `Button` in `render`, the `backgroundColor` will be `red`.
    Otherwise, it will be `blue`. This provides a very nice system for applying simple
    and reusable theming across multiple types of components.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 5*, we pulled the `Image` component from the `glamorous` library to
    use in place of the React Native `Image` component. This special version of the
    component behaves the same as its React Native counterpart, along with the benefit
    of being able to apply styles directly to the element itself. In *step 8*, where
    we used that component, we were able to apply `height`, `width`, and `borderRadius`
    styles without ever having to use the `style` prop.
  prefs: []
  type: TYPE_NORMAL
- en: Using react-native-spinkit for adding animated loading indicators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: No matter what kind of app you are building, there's a very good chance your
    app will need to wait on data of one kind or another, whether it be loading assets
    or waiting on a response from an AJAX request. When this situation arises, you'll
    probably also want a way for your app to indicate to the user that some required
    piece of data is still loading. One easy-to-use solution to this problem is using
    `react-native-spinkit`. This package provides 15 (four of which are iOS-only)
    professional looking, easy-to-use loading indicators for displaying while data
    is loading in your app.
  prefs: []
  type: TYPE_NORMAL
- en: 'This package requires the following command to be run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: So, it is probably safe to assume that it will not work with an Expo app (unless
    that app is subsequently ejected). This will provide us with another recipe that
    depends on a pure React Native workflow.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we''ve established that this recipe will be built in pure React Native,
    we can begin by initializing a new app from the command line named `SpinKitApp` as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'This command will begin the scaffolding process. Once it has completed, `cd`
    into the new `SpinKitApp` directory and add `react-native spinkit` with `npm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Or use `yarn`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'With the library installed, we must link it before it can be used with the
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, the app is bootstrapped and the dependencies have been installed.
    The app can then be run in the iOS or Android simulators via this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, use this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: When launching a pure React Native project in the iOS simulator, if you wish
    to specify a device, you can pass the `simulator` argument set to a string value
    for the desired device. For example, `react-native run-ios --simulator="iPhone
    X"` will launch the app in a simulated iPhone X.
  prefs: []
  type: TYPE_NORMAL
- en: When launching a pure React Native project in an Android emulator via the command
    line, you must open the Android emulator you intend to use before running this
    command.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll also be making use of the `randomcolor` library again in this recipe.
    Install it with `npm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Or use `yarn`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll start by adding the dependencies to the `App.js` file in the root of
    the project, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re going to be setting up the app in this recipe to cycle through all of
    the loading spinner types provided by `react-native-spinkit`. To do this, let''s
    create an array with strings for each possible type of spinner. Since the last
    four types are not fully supported in Android, they will all appear as the same
    `Plane` spinner on Android, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can begin building the `App` component. We will need a `state` object
    with four properties: an `isVisible` property to track whether the spinner should
    be displayed, a `type` property for holding the current spinner type, a `typeIndex`
    for keeping our place in the `types` array, and a color. We''ll initialize color
    to a random hex code by simply calling `randomColor()`, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll need a function for changing the properties of the `Spinner` component,
    which we will define later in the `render` method. This function simply increases
    the `typeIndex` by one, or sets it back to `0` if the end of the array has been
    reached, then updates `state` accordingly, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The `render` method will be made up of the `Spinner` component, wrapped in
    a `TouchableOpacity` component for changing the type and color of `Spinner`. We
    will also add a `Text` component for displaying the current `Spinner` type, as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let''s add a few styles to the center content and increase the font
    size of the `Text` element via the `text` class, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: With the recipe complete, we should see a loader that changes on press. Thanks
    to `react-native-spinkit`, this is all it takes to add slick loading indicators
    to our React Native applications!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/f21b3fc5-4779-4778-923e-f4d33138cfe2.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In *step 5*, we defined the app''s `render` method, where we made use of the `Spinner`
    component. The `Spinner` component has four optional props:'
  prefs: []
  type: TYPE_NORMAL
- en: '`isVisible`: A Boolean that determines whether the component should be displayed.
    Default: `true`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`color`: A hex code to determine the spinner''s color. Default: `#000000`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`size`: Determines what size the spinner should be, in pixels. Default: `37`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`type`: A string that determines the type of spinner to use. Default: `Plane`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since the `isVisible` prop on the `Spinner` component is set to the value of `isVisible`
    on the `state` object, we can simply toggle this property to `true` whenever a
    long running process begins (such as waiting on the response from an AJAX request),
    and set it back to `false` when the operation completes.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Even though the app we've created in this recipe is fairly simple, it has illustrated
    both how `react-native-spinkit` can be implemented, and how using third-party
    packages that require the `react-native link` command works in practice. There
    are all kinds of third-party packages available to use in your next React Native
    app, thanks to the hard work of countless open source contributors. Being equipped
    to utilize any third-party package that suits your app's needs, no matter what
    requirements those package have, will be a vital tool in planning and developing
    React Native projects.
  prefs: []
  type: TYPE_NORMAL
- en: Using react-native-side-menu for adding side navigation menus
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Side menus are a common UX pattern for displaying options, controls, app settings,
    navigation, and other secondary information in mobile applications. The `react-native-side-menu`
    third-party package provides an excellent, straightforward way to implement side
    menus in a React Native app. In this recipe, we will be building an app that has
    a side menu housing buttons that change the background.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Setting up the `react-native-side-menu` package does not require the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: So feel free to create this app with Expo or as a pure React Native app. We
    need to create a new app for this recipe, and for project naming purposes we'll
    assume this app is being built with Expo and name it `side-menu-app`. If you're
    using pure React Native, you can name it `SideMenuApp`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will also need to install `react-native-side-menu` into our project with `npm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, use `yarn`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start this recipe by adding all the imports we''ll need in the `App.js`
    file in the root of the project. One of these imports is a `Menu` component, which
    we''ll create in a later step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s define the `App` class and the initial `state`. `state` only needs
    two properties in this app: an `isOpen` Boolean to keep track of when the side
    menu should be open, and a `selectedBackgroundColor` property whose value is a
    string representing the currently selected background color, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Our app will need a method for changing the `selectedBackgroundColor` property
    on `state`. This method takes a `color` string as a parameter, and sets that color
    to `selectedBackgroundColor`. It will also set `state.isOpen` to `false` so that
    the side menu closes when a color is selected from the menu, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re ready to define the `render` method `App`. First, let''s set up the `Menu`
    component so it can be used by `SideMenu` in the next step. We still haven''t
    created the  `Menu` component, but we''ll be using an `onColorSelected` property
    to pass along the `changeBackgroundColor` method, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'The rendered UI consists of four pieces. The first is a `View` component, which
    has a `style` property tied to `state.selectedBackgroundColor`. This `View` component holds a
    single `TouchableOpacity` button component, which opens the side menu whenever
    it''s pressed. The `SideMenu` component has a required `menu` prop, which takes
    the component that will act as the side menu itself, and so we''ll pass the `Menu`
    component to this property, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'As the final touch for this component, let''s add basic styles to center the
    layout, and apply colors and font sizes, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s time to create the `Menu` component. Let''s create a `component` folder
    with a `Menu.js` file inside. We''ll start with the component imports. As we''ve
    done in previous recipes, we''ll also use `Dimensions` to store the dimensions
    of the app window in a variable for applying styles, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Menu` component needs only to be a presentational component, since it
    has no state or need for life cycle hooks. The component will receive `onColorSelected` as
    a property, which we''ll make use of in the next step, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'The body of the `Menu` component is simply a list of `TouchableOpacity` buttons
    that, when pressed, call `onColorSelected`, passing in the corresponding color,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s add a few styles to layout the `Menu` component, apply colors, and apply
    font sizes. Note that we''re also using the `window` variable we defined in *step
    7* to set the `height` and `width` of the component equal to that of the screen, as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Our app is complete! When the Open Menu button is pressed, a smoothly animated
    side menu will slide out from the left, displaying a list of colors for the user
    to choose from. When a color is selected from the list, the background color of
    the app changes and the menu slides back to closed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/73ecede4-e54a-465c-af8c-e4e19f2dbe0e.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *step 4*, we created the `render` function for the main `App` component.
    We stored the `Menu` component in a `menu` variable so that it can be legibly
    passed to the `menu` property of `SideMenu`, as we did in *step 5*. We pass the `changeBackgroundColor`
    class method via the `onColorSelected` prop on our `Menu` component so that we
    can use it to properly update `state` in the `App` component.
  prefs: []
  type: TYPE_NORMAL
- en: We then pass the `Menu` component to `SideMenu` as the `menu` prop, which wires
    the two components together. The second props is `isOpen`, which dictates whether
    the side menu should be open. The third prop, `onChange`, takes a callback function
    that's executed every time the menu is opened or closed. The `onChange` callback
    is provided an `isOpen` parameter that we used to update the value of `isOpen`
    on `state` so that it stays in sync.
  prefs: []
  type: TYPE_NORMAL
- en: The containing `View` element has a `style` prop set to an array with both the `container`
    styles defined in *step 6* and an object with the `backgroundColor`  key set to `selectedBackgroundColor`
    on `state`. This will cause the background color of the `View` component to change
    to this value whenever it updates.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 8* and *step 9*, we built out the `render` method of the `Menu` component.
    Each `TouchableOpacity` button is wired to call `onColorSelected`, passing in
    the color associated with the pressed button. This in turn runs `changeBackgroundColor`
    in the parent `App` class, which updates `state.selectedBackgroundColor` on setting `state.isOpen`
    to `false`, causing the background color to change and the side menu to close.
  prefs: []
  type: TYPE_NORMAL
- en: Using react-native-modalbox for adding modals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another common piece of many mobile UIs is the modal. Modals are the perfect
    solution for isolating data in a meaningful way, alerting a user of updated info,
    displaying a required action that blocks other user interactions (like a login
    screen), and so much more.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be making use of the third-party package `react-native-modalbox`. This
    package provides an easy-to-understand and versatile API for creating modals,
    with options including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`position`: Top, bottom, center'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`entry`: Direction modal enters from—top or bottom?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`backdropColor`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`backdropOpacity`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For all of the available options, refer to the documentation at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/maxs15/react-native-modalbox](https://github.com/maxs15/react-native-modalbox)'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will need a new app for this recipe. The `react-native-modalbox` package
    is Expo friendly, so we can create this app with Expo. We'll name this app `modal-app`.
    If using a pure React Native project, a name such as `ModalApp` will work, to
    match naming conventions.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will also need the third-party package. It can be installed with `npm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, use `yarn`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start by opening the `App.js` file in the root of the project and add
    the imports, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will define and export the `App` component, as well as the initial
    `state` object, as follows. For this app, we''ll only need an `isOpen` Boolean
    for keeping track of whether one of our modals should be opened or closed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s skip ahead to building out the `render` method next. The template is
    made up of two `TouchableOpacity` button components that when pressed, open their
    respective modal. We''ll be defining those two modals in the following steps.
    These buttons will call two methods for rendering each `Modal`  of the two modal
    components, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we''re ready to define the `renderModal1` method. The `Modal` component
    needs a `ref` prop to be assigned a string, which will be used to refer to the
    `Modal` when we want to open or close it, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s add the `openModal1` method next. This is the method that is called
    by `onPress` on the first `TouchableOpacity` component we added in the `render`
    method in *step 3*. By passing the `modal1` string to the `ref` prop on the `Modal`
    component we defined in *step 4*, we''re able to access the modal as `this.refs.modal1`.
    Calling the `open` method on this ref opens the modal. More on this in the *How
    it works... *section at the end of this recipe. Add the `openModal1` method as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Modal` we defined in *step 4* also has `onClosed` and `onOpened` props,
    which each take a callback that''s executed when the modal is closed or opened,
    respectively. Let''s define the callbacks for these props next. In this recipe,
    we''ll just be firing a `console.log` as a proof of concept, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re ready to define the second modal. This `Modal` component''s `ref` prop
    will be set to the string `modal2`, and we''ll add two other optional props we
    didn''t use on the other modal. The first is `position`, which can be set to `top`, `bottom`,
    or `center` (default). The `isOpen` prop provides a secondary way of opening and
    closing a modal via a Boolean. The content of the modal has a `TouchableOpacity`
    with an OK button that, when pressed, will set the `isOpen` Boolean on the `state`
    object to `false`, closing the modal, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we''re using the `state` Boolean `isOpen` to manipulate the state of
    the modal, the `openModal2` method will illustrate an alternative method for opening
    and closing the modal. By setting `isOpen` on `state` to `true`, the second modal
    will open, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'You might have also noticed that the second modal, defined in *step 7*, has
    a different `onClosed` callback. If the user presses the OK button, the `isOpen`
    value on `state` will be successfully updated to `false`, but if they dismiss
    the modal by touching the backdrop, it will not. Adding the `onCloseModal2` method
    guarantees that the `isOpen` value of the `state` is properly kept in sync no
    matter how the user dismisses the modal, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'The last step in this recipe is applying styles. We''ll have a `modal` class
    for shared modal styles, `modal1` and `modal2` classes for styles unique to each
    modal, and classes for applying colors, padding, and margin to buttons and text,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'This recipe is complete, and we now have an app with two basic modals, displayed
    on button press, and living in harmony in the same component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/14001108-37b7-461a-9205-f5b17bf10e78.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *step 4*, we defined the first `Modal` component. We defined the `onClosed`
    and `onOpened` props, passing the `onClose` and `onOpen` class methods to these
    props. Whenever this `Modal` component is opened, `this.onOpen` will fire, and `this.onClose`
    will execute when the `Modal` is closed. While we didn't do anything exciting
    with these methods in this recipe, these hooks could serve as the perfect opportunity
    for logging user actions related to the modal. Or if the modal houses a form,
    `onOpen` could be used to pre-populate some form inputs with data, and `onClose`
    could save the form data to the `state` object for use as the modal is closed.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *step 5*, we defined the method that the first `TouchableOpacity` button
    component executes when pressed: `openModal1`. In this method, we made use of
    the `Modal` component''s ref. Refs are a core feature of React itself, and provide
    a place on the component instance for storing DOM nodes and/or React elements
    that are created in the component''s render method. Just as React (and React Native)
    components have both state and props (`this.state`, and `this.props` in a class
    component), they can also have refs (which live on `this.ref`). For more on how
    refs in React work, check the documentation at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://reactjs.org/docs/refs-and-the-dom.html](https://reactjs.org/docs/refs-and-the-dom.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Since we set the `ref` prop on the first `Modal` to the string `modal1`, we're
    able to access this same component in the `openModal1` method with the reference `this.ref.modal1`.
    Since `Modal` has an `open` and a `close` method, calling `this.ref.modal1.open()`
    opens the `Modal` with a `ref` of `modal1`.
  prefs: []
  type: TYPE_NORMAL
- en: This is not the only way to open and close a `Modal` component, as illustrated
    with the second modal we defined in *step 7*. Since this component has an `isOpen`
    prop, the modal can be opened or closed by changing the Boolean value being passed
    to the prop. By setting `isOpen` to be the `isOpen` value of the state, we can
    use the OK button in this modal to close the modal from within, by setting `isOpen`
    to false on `state`. In *step 8*, we defined the `openModal2` method, which also
    illustrates opening the second modal by changing the value of `isOpen` on `state`.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 9*, we defined a separate `isClosed` callback for keeping the `isOpen`
    value of `state` in sync in case the user dismisses the modal by pressing the
    backdrop instead of the modal's OK button. An alternative strategy would have
    been to disable the user's ability to dismiss the modal via pressing the backdrop,
    by adding the `backdropPressToClose` property to the `Modal` component and setting
    it to `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a number of other optional props provided by the `react-native-modalbox`
    package that can make modal creation easier. We used `position` in this recipe
    to declare that the second modal be placed at the bottom of the screen, and you
    can view all other available props for `Modal` in the documentation at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/maxs15/react-native-modalbox](https://github.com/maxs15/react-native-modalbox)'
  prefs: []
  type: TYPE_NORMAL
- en: The `react-native-modalbox` library supports multiple modals in a single component;
    however, attempting to use the `isOpen` prop on more than one of these modals
    will cause all of those modals to open at once, which is unlikely to be the desired
    behavior.
  prefs: []
  type: TYPE_NORMAL
