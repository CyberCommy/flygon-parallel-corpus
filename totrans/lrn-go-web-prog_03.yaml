- en: Chapter 3. Connecting to Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we explored how to take URLs and translate them to
    different pages in our web application. In doing so, we built URLs that were dynamic
    and resulted in dynamic responses from our (very simple) `net/http` handlers.
  prefs: []
  type: TYPE_NORMAL
- en: By implementing an extended mux router from the Gorilla toolkit, we expanded
    the capabilities of the built-in router by allowing regular expressions, which
    gives our application a lot more flexibility.
  prefs: []
  type: TYPE_NORMAL
- en: This is something that's endemic to some of the most popular web servers. For
    example, both Apache and Nginx provide methods to utilize regular expressions
    in routes and staying at par with common solutions should be our minimal baseline
    for functionality.
  prefs: []
  type: TYPE_NORMAL
- en: But this is just an admittedly important stepping stone to build a robust web
    application with a lot of varied functionality. To go any further, we need to
    look at bringing in data.
  prefs: []
  type: TYPE_NORMAL
- en: Our examples in the previous chapter relied on hardcoded content grabbed from
    static files—this is obviously archaic and doesn't scale. Anyone who has worked
    in the pre-CGI early days of the Web could regale you with tales of site updates
    requiring total retooling of static files or explain the anachronism that was
    Server-Side Includes.
  prefs: []
  type: TYPE_NORMAL
- en: But luckily, the Web became largely dynamic in the late 1990s and databases
    began to rule the world. While APIs, microservices and NoSQL have in some places
    replaced that architecture, it still remains the bread and butter of the way the
    Web works today.
  prefs: []
  type: TYPE_NORMAL
- en: So without further ado, let's get some dynamic data.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to a database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using GUID for prettier URLs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling 404s
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting to a database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When it comes to accessing databases, Go's SQL interface provides a very simple
    and reliable way to connect to various database servers that have drivers.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, most of the big names are covered—MySQL, Postgres, SQLite, MSSQL,
    and quite a few more have well-maintained drivers that utilize the `database/sql`
    interface provided by Go.
  prefs: []
  type: TYPE_NORMAL
- en: The best thing about the way Go handles this through a standardized SQL interface
    is that you won't have to learn custom Go libraries to interact with your database.
    This doesn't preclude needing to know the nuances of the database's SQL implementation
    or other functionality, but it does eliminate one potential area of confusion.
  prefs: []
  type: TYPE_NORMAL
- en: Before you go too much farther, you'll want to make sure that you have a library
    and a driver for your database of choice installed via `go get` command.
  prefs: []
  type: TYPE_NORMAL
- en: The Go project maintains a Wiki of all of the current SQLDrivers and is a good
    starting reference point when looking for an adapter at [https://github.com/golang/go/wiki/SQLDrivers](https://github.com/golang/go/wiki/SQLDrivers)
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Note: We''re using MySQL and Postgres for various examples in this book, but
    use the solution that works best for you. Installing MySQL and Postgres is fairly
    basic on any Nix, Windows, or OS X machine.'
  prefs: []
  type: TYPE_NORMAL
- en: MySQL can be downloaded from [https://www.mysql.com/](https://www.mysql.com/)
    and although there are a few drivers listed by Google, we recommend the Go-MySQL-Driver.
    Though you won't go wrong with the recommended alternatives from the Go project,
    the Go-MySQL-Driver is very clean and well-tested. You can get it at [https://github.com/go-sql-driver/mysql/](https://github.com/go-sql-driver/mysql/)For
    Postgres, grab a binary or package manager command from [http://www.postgresql.org/](http://www.postgresql.org/).
    The Postgres driver of choice here is `pq`, which can be installed via `go get`
    at [github.com/lib/pq](http://github.com/lib/pq)
  prefs: []
  type: TYPE_NORMAL
- en: Creating a MySQL database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can choose to design any application you wish, but for these examples we'll
    look at a very simple blog concept.
  prefs: []
  type: TYPE_NORMAL
- en: Our goal here is to have as few blog entries in our database as possible, to
    be able to call those directly from our database by GUID and display an error
    if the particular requested blog entry does not exist.
  prefs: []
  type: TYPE_NORMAL
- en: To do this, we'll create a MySQL database that contains our pages. These will
    have an internal, automatically incrementing numeric ID, a textual globally unique
    identifier, or GUID, and some metadata around the blog entry itself.
  prefs: []
  type: TYPE_NORMAL
- en: To start simply, we'll create a title `page_title`, body text `page_content`
    and a Unix timestamp `page_date`. You can feel free to use one of MySQL's built-in
    date fields; using an integer field to store a timestamp is just a matter of preference
    and can allow for some more elaborate comparisons in your queries.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the SQL in your MySQL console (or GUI application) to create
    the database `cms` and the requisite table `pages`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As mentioned, you can execute this query through any number of interfaces. To
    connect to MySQL, select your database and try these queries, you can follow the
    command line documentation at [http://dev.mysql.com/doc/refman/5.7/en/connecting.html](http://dev.mysql.com/doc/refman/5.7/en/connecting.html).
  prefs: []
  type: TYPE_NORMAL
- en: Note the `UNIQUE KEY` on `page_guid`. This is pretty important, as if we happen
    to allow duplicate GUIDs, well, we have a problem. The idea of a globally unique
    key is that it cannot exist elsewhere, and since we'll rely on it for URL resolution,
    we want to make sure that there's only one entry per GUID.
  prefs: []
  type: TYPE_NORMAL
- en: As you can probably tell, this is a very basic content type of blog database.
    We have an auto-incrementing ID value, a title, a date and the page's content,
    and not a whole lot else going on.
  prefs: []
  type: TYPE_NORMAL
- en: While it's not a lot, it's enough to demonstrate dynamic pages in Go utilizing
    a database interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just to make sure there''s some data in the `pages` table, add the following
    query to fill this in a bit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This will give us something to start with.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our structure and some dummy data, let's take a look at how
    we can connect to MySQL, retrieve the data, and serve it dynamically based on
    URL requests and Gorilla's mux patterns.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started, let''s create a shell of what we''ll need to connect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We're importing the MySQL driver package for what's known as *side effects*.
    By this, it's generally meant that the package is complementary to another and
    provides various interfaces that do not need to be referenced specifically.
  prefs: []
  type: TYPE_NORMAL
- en: You can note this through the underscore `_` syntax that precedes the packages
    import. You're likely already familiar with this as a quick-and-dirty way to ignore
    the instantiation of a returned value from a method. For example `x, _ := something()`allows
    you to ignore the second returned value.
  prefs: []
  type: TYPE_NORMAL
- en: It's also often used when a developer plans to use a library, but hasn't yet.
    By prepending the package this way, it allows the import declaration to stay without
    causing a compiler error. While this is frowned upon, the use of the underscore—or
    blank identifier—in the preceding method, for side effects, is fairly common and
    often acceptable.
  prefs: []
  type: TYPE_NORMAL
- en: 'As always, though, this all depends on how and why you''re using the identifier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Make sure to replace these values with whatever happens to be relevant to your
    installation, of course:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'By keeping our database connection reference as a global variable, we can avoid
    a lot of duplicate code. For the sake of clarity, we''ll define it fairly high
    up in the code. There''s nothing preventing you from making this a constant instead,
    but we''ve left it mutable for any necessary future flexibility, such as adding
    multiple databases to a single application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This `struct`, of course, matches our database schema rather closely, with
    `Title`, `Content` and `Date` representing the non-ID values in our table. As
    we''ll see a bit later in this chapter (and more in the next), describing our
    data in a nicely-designed struct helps parlay the templating functions of Go.
    And on that note, make sure your struct fields are exportable or public by keeping
    them propercased. Any lowercased fields will not be exportable and therefore not
    available to templates. We will talk more on that later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As we mentioned earlier, this is largely scaffolding. All we want to do here
    is ensure that we're able to connect to our database. If you get an error, check
    your connection and the log entry output after `Couldn't connect`.
  prefs: []
  type: TYPE_NORMAL
- en: If, hopefully, you were able to connect with this script, we can move on to
    creating a generic route and outputting the relevant data from that particular
    request's GUID from our database.
  prefs: []
  type: TYPE_NORMAL
- en: To do this we need to reimplement Gorilla, create a single route, and then implement
    a handler that generates some very simple output that matches what we have in
    the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the modifications and additions we''ll need to make to
    allow this to happen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The big change here is that we''re bringing Gorilla and `net/http` back into
    the project. We''ll obviously need these to serve pages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We've added a `PORT` constant, which refers to our HTTP server port.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that if your host is `localhost`/`127.0.0.1`, it''s not necessary to specify
    a `DBPort`, but we''ve kept this line in the constants section. We don''t use
    the host here in our MySQL connection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '`ServePage` is the function that takes an `id` from `mux.Vars` and queries
    our database for the blog entry ID. There''s some nuance in the way we make a
    query that is worth noting; the simplest way to eliminate SQL injection vulnerabilities
    is to use prepared statements, such as `Query`, `QueryRow`, or `Prepare`. Utilizing
    any of these and including a variadic of variables to be injected into the prepared
    statement removes the inherent risk of constructing a query by hand.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Scan` method then takes the results of a query and translates them to
    a struct; you''ll want to make sure the struct matches the order and number of
    requested fields in the query. In this case, we''re mapping `page_title`, `page_content`
    and `page_date` to a `Page` struct''s `Title`, `Content` and `Date`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Note our regular expression here: it''s just numeric, with one or more digits
    comprising what will be the `id` variable accessible from our handler.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember that we talked about using the built-in GUID? We''ll get to that in
    a moment, but for now let''s look at the output of `local` `host:8080/page/1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a MySQL database](img/B04294_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding example, we can see the blog entry that we had in our database.
    This is good, but obviously lacking in quite a few ways.
  prefs: []
  type: TYPE_NORMAL
- en: Using GUID for prettier URLs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Earlier in this chapter we talked about using the GUID to act as the URL identifier
    for all requests. Instead, we started by yielding to the numeric, thus automatically
    incrementing column in the table. That was for the sake of simplicity, but switching
    this to the alphanumeric GUID is trivial.
  prefs: []
  type: TYPE_NORMAL
- en: All we'll need to do is to switch our regular expression and change our resulting
    SQL query in our `ServePage` handler.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we only change our regular expression, our last URL''s page will still work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The page will of course still pass through to our handler. To remove any ambiguity,
    let''s assign a `guid` variable to the route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we change our resulting call and SQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'After doing this, accessing our page by the `/pages/hello-world` URL will result
    in the same page content we got by accessing it through `/pages/1`. The only real
    advantage is cosmetic, it creates a prettier URL that is more human-readable and
    potentially more useful for search engines:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using GUID for prettier URLs](img/B04294_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Handling 404s
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A very obvious problem with our preceding code is that it does not handle a
    scenario wherein an invalid ID (or GUID) is requested.
  prefs: []
  type: TYPE_NORMAL
- en: 'As it is, a request to, say, `/page/999` will just result in a blank page for
    the user and in the background a **Couldn''t get page!** message, as shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Handling 404s](img/B04294_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Resolving this is pretty simple by passing proper errors. Now, in the previous
    chapter we explored custom `404` pages and you can certainly implement one of
    those here, but the easiest way is to just return an HTTP status code when a post
    cannot be found and allow the browser to handle the presentation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our preceding code, we have an error handler that doesn''t do much except
    return the issue to our log file. Let''s make that more specific:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see the output in the following screenshot. Again, it would be trivial
    to replace this with a custom `404` page, but for now we want to make sure we''re
    addressing the invalid requests by validating them against our database:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Handling 404s](img/B04294_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Providing good error messages helps improve usability for both developers and
    other users. In addition, it can be beneficial for SEO, so it makes sense to use
    HTTP status codes as defined in HTTP standards.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we've taken the leap from simply showing content to showing
    content that's maintained in a sustainable and maintainable way using a database.
    While this allows us to display dynamic data easily, it's just a core step toward
    a fully-functional application.
  prefs: []
  type: TYPE_NORMAL
- en: We've looked at creating a database and then retrieving the data from it to
    inject into route while keeping our query parameters sanitized to prevent SQL
    injections.
  prefs: []
  type: TYPE_NORMAL
- en: We also accounted for potential bad requests with invalid GUIDs, by returning
    *404 Not Found* statuses for any requested GUID that does not exist in our database.
    We also looked at requesting data by ID as well as the alphanumeric GUID.
  prefs: []
  type: TYPE_NORMAL
- en: This is just the start of our application, though.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 4](ch04.html "Chapter 4. Using Templates"), *Using Templates*, we'll
    take the data that we've grabbed from MySQL (and Postgres) and apply some of Go's
    template language to them to give us more frontend flexibility.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of that chapter, we will have an application that allows for creation
    and deletion of pages directly from our application.
  prefs: []
  type: TYPE_NORMAL
