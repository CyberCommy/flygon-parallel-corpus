- en: Scaling Our REST API Using Microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building a REST API is easy in terms of concepts. But scaling them to accept
    huge traffic is a challenge. Till now, we looked into the details of creating
    REST API structures and sample REST APIs. In this chapter, we are going to explore
    the Go Kit, a wonderful, idiomatic Go package for building microservices. This
    is the microservices age, where startups are turning into enterprises in no time. 
    The microservice architecture allows companies to quickly iterate in parallel.
    We will start by defining microservices and then move on to Go Kit by creating
    REST-style microservices.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The difference between monolith and microservices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The need for microservices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing Go Kit, a microservice toolkit in Go
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a REST API with Go Kit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding logging to the API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding instrumentation to the API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting the code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can get the code samples for this chapter at the GitHub repository link [https://github.com/narenaryan/gorestful/tree/master/chapter9](https://github.com/narenaryan/gorestful/tree/master/chapter9).
    In the previous chapter, we discussed Go API clients. Here, we come back to the
    REST API with microservice architecture.
  prefs: []
  type: TYPE_NORMAL
- en: What are microservices?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are microservices? This is the question the enterprise world is asking
    the computing world. Because of the bigger teams, the companies are ready to embrace
    microservices for breaking down tasks. Microservice architecture replaces the
    traditional monolith with granular services that talk to each other with some
    kind of agreement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Microservices bring the following benefits to the plate:'
  prefs: []
  type: TYPE_NORMAL
- en: If the team is big, people can work on chunks of applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adaptability is easy for the new developers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adopting best practices, such as **Continuous Integration** (**CI**) and **Continuous
    Delivery** (**CD**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easily replaceable software with loosely coupled architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In a monolith application (traditional application), a single huge server serves
    the incoming requests by multiplexing the computing power. It is good because
    we have everything, such as an application server, database, and other things,
    in a single place. It also has disadvantages. When a piece of software breaks,
    everything breaks. Also, developers need to set up an entire application to develop
    a small piece.
  prefs: []
  type: TYPE_NORMAL
- en: 'The disadvantage list of a monolithic application could be:'
  prefs: []
  type: TYPE_NORMAL
- en: Tightly coupled architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Single point of failure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Velocity of adding new features and components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fragmentation of work is limited to teams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Continuous deployment is very tough because an entire application needs to be
    pushed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Looking at the monolith application, the entire stack is treated as a single
    entity. If the database fails, the app fails. If a bug in the code crashes the
    software application, the entire connectivity with clients goes down. This actually
    led to the emergence of microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Let us take a scenario. A company run by Bob uses the traditional **Service
    Oriented Architecture** (**SOA**), where developers work around the clock to add
    new features. If there is a release, people need to test the code overall for
    every small component. The project moves from development to testing when all
    changes are done. Another company on the next street, run by Alice, uses the microservices
    architecture. All software developers in Alice's company work on individual services,
    that get tested by a continuous build pipeline that notifies things pretty quickly.
    The developers talk with each other's REST/RPC APIs to add new features. They
    can easily shift their stack from one technology to another, as compared to Bob's
    developers. This example shows that Alice's company's flexibility and velocity
    is greater than Bob's.
  prefs: []
  type: TYPE_NORMAL
- en: Microservices also create a platform that allows us to use containers (docker,
    and so on). In microservices, orchestration and service discovery are very important
    to track the loosely coupled elements. A tool such as Kubernetes is used to manage
    the docker containers. Generally, it is a good practice to have a docker container
    for a microservice. Service discovery is the automatic detection of an IP address and
    other details on the fly. This removes the potential threat of hardcoding the
    stuff that is needed for microservices to consult each other.
  prefs: []
  type: TYPE_NORMAL
- en: Monolith versus microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Industry experts suggest starting a software application as a monolith and
    then breaking it down into microservices in the long run. This actually helps
    us focus on the application delivery, instead of studying the microservices patterns.
    Once the product is stabilized, then developers should find a way to loosely couple
    functionalities. Take a look at the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a7355ea1-d2ba-4a9d-b60b-b49dac855c81.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This diagram depicts the structure of monolith and microservice architectures.
    A monolith has everything wrapped in the form of an onion. It is called a tightly
    coupled system. In contrast, microservices are individual, easy to replace and
    modify. Each microservice can talk to each other through various transport mechanisms,
    such as HTTP and RPC. The format could be either JSON or Protocol Buffers.
  prefs: []
  type: TYPE_NORMAL
- en: Go Kit, a package for building microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the enterprise world, people know about Netflix's Eureka and Spring Boot
    from the Java community. In Go, a package that tries to reach that level of implementation
    is obviously **Go kit**. It is a toolkit for building microservices.
  prefs: []
  type: TYPE_NORMAL
- en: 'It has a Go style of adding services, which makes us feel good. It comes with
    a procedure for adding the microservices. In the upcoming sections, we will see
    how to create a microservice with the steps defined by Go Kit. It mainly consists
    of many layers. There are three layers where request and response flow in Go Kit:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Transport layer**: This takes care of transferring data from one service
    to another'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Endpoint layer**: This takes care of building endpoints for the given services'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Service layer**: This is the actual business logic for the API handlers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Install Go Kit using this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us lay down the plan for our first microservice. We all know the encryption
    of messages. A message string can be encrypted using a key that outputs a gibberish
    message that can be passed over the wire. The recipient decrypts the message and
    gets back the original string. This process is called encryption in cryptography.
    We will try to implement this as part of our microservice illustration:'
  prefs: []
  type: TYPE_NORMAL
- en: First, develop logic for encryption
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, integrate it with Go Kit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go comes with packages for encrypting messages. We need to import encrypting
    algorithms from those packages and use them. As part of the first step, we will
    write a project that uses an **Advanced Encryption Standard** (**AES**).
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a directory called `encryptString` in your `GOPATH/src/user` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let us add one more in the new directory, called utils. Add two files, `main.go`in
    the project directory and `utils.go` in the new directory called `utils`. The
    directory structure looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let us add the logic of encryption in our `utils.go` file. We create two
    functions, one for encrypting and another for decrypting the messages, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The AES algorithm takes the initialization vector. Let us define that first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let us implement the logic for encryption and decryption:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `EncryptString` function, we are creating a new cipher block using a
    key. Then we are passing that block to a cipher block encryptor function. That
    encryptor takes the block and initialization vector. Then we generate ciphertext
    (an encrypted message) by doing a `XORKeyStream` on the cipher block. It fills
    the ciphertext. Then we need to do a Base64 encoding to generate the protected
    string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the `DecryptString` function, decode Base64 encoding and create a cipher
    block with the key. Pass this cipher block with the initialization vector to `NewCFBEncrypter`.Next,
    use `XORKeyStream`to load content from cipher text to plain text. Basically, it
    is a process of swapping the encrypted and decrypted messages in `XORKeyStream`.
    This finishes the `utils.go` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let us edit the `main.go` file to leverage the preceding `utils` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are importing the encrypting/decrypting functions from the `utils`
    package and using them to show an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run this program, we see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: It shows how we can use the AES algorithm to encrypt a message and get it back
    using the same secret key. This algorithm is also called the **Rijndael** (pronounced
    rain-dahl) algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Building a REST microservice with Go Kit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With this knowledge, we are ready to build our first microservice that provides
    the API for encryption/decryption. We use Go Kit and our encryption `utils` to
    write that microservice. As we discussed in the previous section, a Go-Kit microservice
    should be built in a step-wise manner. To create a service, we need to design
    a few things upfront. They are:'
  prefs: []
  type: TYPE_NORMAL
- en: Service implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Endpoints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Request/response models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transport
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Sit tight. This terminology seems alien for now. We will be quite comfortable
    with it soon. Let us create a directory with the following directory structure.
    Every Go Kit project can be in this project structure. Let us call our project `encryptService.` Create
    these files in the same tree structure in the `encryptService` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We will go through each and every file and see how things should be built.
    First, in Go Kit, create the interface that tells all functions our microservice
    performs. In this case, those functions are `Encrypt` and `Decrypt`. `Encrypt`
    takes the key and converts the text to a cipher message. `Decrypt` converts the
    cipher message back to the text using the key. Take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The service needs to implement these functions to satisfy the interface. Next,
    create models for your services. Models specify what data a service can receive
    and produce back. Create a `models.go` file in the `helpers` directory of the
    project:'
  prefs: []
  type: TYPE_NORMAL
- en: '`encryptService/helpers/models.go`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we have two service functions, there are four functions mapped to the
    request and response. The next step is to create a struct that implements the
    preceding defined interface, `EncryptService`. So, create that logic in an implementations
    file in the following path:'
  prefs: []
  type: TYPE_NORMAL
- en: '`encryptService/helpers/implementations.go`'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let us import all necessary packages. Also, give the package name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This is leveraging the same AES encryption we saw in the previous example. In
    this file, we are creating a struct called `EncyptionServiceInstance`that has
    two methods, `Encrypt` and `Decrypt`.So it satisfies the preceding interface.
    Now, how can we link these actual service implementations with service requests
    and responses? We need to define endpoints for that. So, add the following endpoints
    to link service requests with service business logic.
  prefs: []
  type: TYPE_NORMAL
- en: We are using the `Capitalized` function and variable names because in Go, any
    function or variable that is Capital is exported from that package name. In `main.go`,
    to use all these functions, we need to export them first. Giving capital names
    makes them visible to the main program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create `endpoints.go` in the `helpers` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are clubbing the previous interface definition code with the endpoints
    definition code. Endpoints take a service as the argument and return a function.
    This function, in turn, takes a request and returns a response. These things are
    the same as what we defined in our `models.go`file. We check the errors, then
    return back the struct for a response.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, things fit nicely. In the previous REST API examples we worked on, we
    always tried to unmarshal the JSON string into the Go structs. For a response,
    we converted the struct back into the JSON string by marshaling. Here, we unmarshal
    and marshal request and response, respectively. For that, we write one more file
    for encoding/decoding logic. Let us call that file `jsonutils.go` and add it in the `helpers`
    directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '`EncodeResponse`is common for marshaling the response of `EncyptService` and
    `DecryptService`,but while decoding JSON into structs we need two different methods.
    We defined them as `DecodeEncryptRequest` and `DecodeDecryptRequest`.These functions
    use Go''s internal JSON package to marshal and unmarshal data.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we have all helper files that have the constructs needed to create a microservice.
    Let us design the `main` function that import the existing things and wire microservice
    to a server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We are importing Go Kit''s transport/http as `httptransport` to create handlers.
    A handler attaches the endpoints, JSON decoder, and JSON encoder. Then, using
    Go''s net/http, we are handling the HTTP requests for the given URL endpoint.`httptransport.NewServer`takes
    a few arguments: an endpoint, the JSON decoder, and the JSON encoder. Where is
    the logic for the service execution? It lies in the endpoint. An endpoint takes
    the request model and spits out the response model. Now, let us run this project
    within the `encryptService` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We can make curl `POST` requests to check the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We provided the key and message to the microservice. It returned the cipher
    message back. It means the service encrypted the text. Make one more request to
    decrypt the message by passing the same key along with the cipher message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'It returns us the exact message we passed initially. Hurray! We wrote our first
    microservice for encrypting/decrypting messages. Apart from handling normal HTTP
    requests, Go Kit provides many other useful constructs, such as middleware for:'
  prefs: []
  type: TYPE_NORMAL
- en: Transport logging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application logging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application instrumentation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Service discovery
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the upcoming sections, we discuss a few important constructs from the preceding
    list.
  prefs: []
  type: TYPE_NORMAL
- en: Adding logging to your microservice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, let us learn how to add transport-level logging and application-level
    logging to our Go Kit microservices. We use the above example but modify it a
    little bit. Let us call our new project `encryptServiceWithLogging`. In the GitHub
    project of this book, you will find this directory. We visited the concepts of
    middleware many times in this book. For revision, a middleware is a function that
    tampers the request/response before/after it reaches the respective request handlers.
    Go Kit allows us to create logging middleware, which we attach to our service.
    That middleware will have the logging logic. In this example, we try to log to
    the Stderr (console). Add one new file called `middleware.go` to the `helpers`
    directory, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to create a struct that has a logger and our service instance. Then,
    define a few methods on that whose names are similar to the service methods (in
    this case, they are `encrypt` and `decrypt`). The **Logger **is the Go Kit''s
    logger that has a `Log` function. This `Log` function takes a few arguments. It
    takes a pair of arguments. The first and second are one set. The third and fourth
    are another set. Refer to the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to maintain the order in which the log should print. After logging
    our request details, we make sure to allow the request to go to the next middleware/handler
    using this function. `Next`is of the type `EncryptService`, which is our actual
    implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'For the encryption function, middleware logs a request for encryption and passes
    it to the implementation of the service. In order to hook this created middleware
    into our service, modify `main.go` to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We imported the log from Go Kit as `kitlog`.We created a new logger using `NewLogfmtLogger(os.Stderr)`.
    This attaches the logging to the console. Now, pass this logger and service to
    the `LoggingMiddleware`. It returns the service that can be passed to the HTTP
    server. Now, let us run the program from `encryptServiceWithLogging` and see what
    output logs on the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'It starts our microservice. Now, fire client requests from the `CURL` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'That logs the following messages on the server console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This is to log the messages per application/service. System-level logging is
    also available and can be approached from the Go Kit's documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Adding instrumentation to your microservice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For any microservice, along with logging, instrumentation is vital. The `metrics` package
    of Go Kit records statistics about your service’s runtime behavior: counting the
    number of jobs processed, recording the duration of requests after they have finished,
    and so on. This is also a middleware that tampers the HTTP requests and collects
    metrics. To define a middleware, simply add one more struct, similar to the logging
    middleware. Metrics are useless unless we monitor. **Prometheus** is a metrics
    monitoring tool that can collect latency, number of requests for a given service,
    and so on. Prometheus scrapes the data from the metrics that Go Kit generates.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can download the latest stable version of Prometheus from this site. Before
    using Prometheus, make sure you install these packages, that are needed by the
    Go Kit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Once these are installed, try to copy the last discussed logging service project
    into a directory called `encryptServiceWithInstrumentation`. The directory is
    exactly the same, except we add one more file called `instrumentation.go` to the
    `helpers` directory and modify our `main.go` to import the instrumentation middleware.
    The project structure looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Instrumentation can measure the number of requests per service and the latency
    in terms of parameters such as `Counter` and `Histogram`, respectively. We try
    to create a middleware that has these two measurements (requests count, latency)
    and implements the functions for the given services. In those middleware functions,
    we try to call the Prometheus client API to increment the number of requests,
    log the latency, and so on. The core Prometheus client library tries to increment
    a request count in this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '`NewCounter`creates a new counter struct that expects counter options. These
    options are the name of the operation and other details. Then, we need to call
    the `With` function on the struct with the method, method name, and error code.This
    particular signature is demanded by Prometheus to generate the counter metric.
    Finally, we are incrementing the counter with the `Add(1)`function call.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The newly added file `instrumentation.go` implementation looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This is exactly the same as the logging middleware code. We created a struct
    with a few fields. We attached the functions for both the encrypt and decrypt
    services. Inside the middleware function, we are looking for two metrics; one
    is count and the second one is latency. When a request is passed through this
    middleware:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This line increments the counter. Now see the other line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This line observes the latency by calculating the difference between the request
    arrival time and final time (since the defer keyword is used, this will be executed
    after the request and response cycle is completed). In simple words, the preceding
    middleware logs the request count and latency to the metrics provided by the Prometheus
    client. Now let us modify our `main.go` file to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We are importing the kit Prometheus package for initializing the metrics template,
    and the client Prometheus package for providing the option structs. We are creating
    `requestCount` and `requestLatency`metrics-type structs and passing them to our `InstrumentingMiddleware`,
    which is imported from `helpers`.  If you see this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'It is how we create a template that matches with the `RequestCount`in the `InstrumentingMiddleware`struct
    in `helpers.go`. The options that we pass will be appended to a single string
    while generating the metrics:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a uniquely identifiable service instrumentation that tells us, *This
    is a request count operation for my microservice called Encryption*. There is
    one more interesting line we added to the server part of the code in `main.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'This actually creates an endpoint that can generate a page with collected metrics.
    This page can be scraped (parsed) by Prometheus to store, plot, and display metrics.
    If we run the program and make 5 HTTP requests to the encrypt service and 10 HTTP
    requests to the decrypt service, the metrics page logs the count of requests and
    their latencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Make 5 CURL requests to the encrypt service in a loop from another bash shell
    (in Linux):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Make 10 CURL requests in a loop for the decrypt service (the output is hidden
    for brevity):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, visit the URL `http://localhost:8080/metrics` and you will see a page
    that the Prometheus Go client is generating for us. The content of the page will
    have this information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, there are two types of metrics:'
  prefs: []
  type: TYPE_NORMAL
- en: '`encryption_myservice_request_count`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`encryption_myservice_request_latency_microseconds`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you see the number of requests to the `encrypt` method and `decrypt` method,
    they match with the CURL requests we made.
  prefs: []
  type: TYPE_NORMAL
- en: The `encryption_myservice` metrics type has count and latencymetrics for both
    the encrypt and decrypt microservices. The method parameter tells from which microservice
    the metrics are drawn.
  prefs: []
  type: TYPE_NORMAL
- en: These kinds of metrics give us key insights, such as which microservice is being
    used heavily and how the latency trends are over time, and so on. But in order
    to see the data in action, you need to install the Prometheus server and write
    a configuration file for Prometheus to scrape metrics from your Go Kit service.
    For more information about creating targets (hosts generating metrics pages) in
    Prometheus, visit [https://prometheus.io/docs/operating/configuration/](https://prometheus.io/docs/operating/configuration/).
  prefs: []
  type: TYPE_NORMAL
- en: We can also pass data from Prometheus to Grafana, a graphing and monitoring
    tool for nice real-time charts of metrics. Go Kit provides many other features,
    such as service discovery. Scaling microservices is only possible if the system
    is loosely coupled, monitored, and optimized.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we started with the definition of microservices. The main difference
    between a monolith application and a microservice is the way tightly coupled architecture
    is broken into loosely coupled architecture. Microservices talk to each other
    using either REST-based JSON or RPC-based protocol buffers. Using microservices,
    we can break business logic into multiple chunks. Each service does one job pretty
    well. This approach comes with a disadvantage. Monitoring and managing microservices
    is painful. Go provides a wonderful toolkit called Go Kit. It is a microservices
    framework using which we can generate boilerplate code for microservices.
  prefs: []
  type: TYPE_NORMAL
- en: We need to define a few things in Go Kit. We need to create implementations,
    endpoints, and models for a Go-Kit service. Endpoints take requests and return
    responses. Implementations have the actual business logic of services. Models
    are a nice way to decode and encode request and response objects. Go Kit provides
    various middleware for performing vital tasks such as logging, instrumentation
    (metrics), and service discovery.
  prefs: []
  type: TYPE_NORMAL
- en: The small organizations can start with a monolith, but in bigger organizations
    with huge teams, microservices suit better. In the next chapter, we can see how
    to deploy our Go services using Nginx. A service needs to be deployed for it to
    be exposed to the outside world.
  prefs: []
  type: TYPE_NORMAL
