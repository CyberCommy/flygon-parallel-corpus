- en: Chapter 4. Writing Your First Microservice in Node.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have been learning about how to build robust microservices-oriented software,
    and now it is time to put all the concepts to practice. In this chapter, we are
    going to build a microservices-oriented e-commerce using Seneca and some other
    frameworks that are going to allow us to write a software that will benefit from
    the particularities of the microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Micromerce – the big picture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It covers the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Writing microservices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sizing microservices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating Seneca with Express
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing data using Seneca
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we are going to write a full (nearly) simplistic e-commerce
    solution based on microservices. Full means full from the conceptual point of
    view, but for obvious reasons, it won't be full (as production ready) as it could
    take us a few books to handle all the possible flows.
  prefs: []
  type: TYPE_NORMAL
- en: We won't go deep in to the UI, as it is not related to the subject of this book.
    What we will do instead is a microservice that will aggregate all the other microservices,
    creating a frontend API to be consumed by a **Single-Page Application** (**SPA**),
    built with any of the modern JavaScript frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to develop the following four microservices:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Product Manager**: This microservice will be responsible for adding, editing,
    and removing products from our database, as well as serving products to the customers.
    This microservice will be partially public for a potential admin site to add/remove
    products.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Order Manager**: This microservice will be responsible for managing the order
    and billing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Emailer**: This microservice will be responsible for delivering e-mails to
    the customers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**UI**: This microservice will expose the feature from the other microservices
    to a potential SPA, but we will only build the JSON interface.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building the four preceding microservices, we will develop the concepts discussed
    in the previous chapters so that, by the end of this chapter, we will be able
    to identify the most common pitfalls going forward. Keep in mind that the objective
    of this book is not converting you into a microservices or Node.js expert, but
    to give you the tools required to learn by yourself, as well as make you aware
    of the best design principles and the most common pitfalls.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the deployment diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Micromerce – the big picture](img/B04889_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This diagram shows how our company (the yellow square) hides some of our microservices
    from the real world and exposes some others to different networks, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**UI** will be exposed to the Internet. Everybody will be able to hit this
    endpoint.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Product Management** will manage the products in our e-commerce. It will
    have the following two interfaces:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Seneca endpoint from where the UI will extract data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A JSON API from where the office of our company will be able to create, update,
    and delete products
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Emailer** will be our communication channel with our customers. We will use
    this microservice to explain the good points of Seneca, and we will also give
    an example of the eventual consistency and system degradation when a microservice
    fails.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Order Manager**: This microservice will let us handle the orders for our
    customers. With this microservice, we will discuss how to handle the fact that
    the data is local to each microservice, instead of being global to the system.
    You can''t just go to the database to recover the product name or price, it needs
    to be recovered from other microservice.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, there is no user or staff management, but with these four microservices,
    we will be able to develop the core concepts of microservices architectures. Seneca
    comes with a very powerful data and transport plugin system that makes it easy
    to use Seneca with different data storages and transport systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'For all our microservices, we are going to use MongoDB as the storage. Seneca
    comes with an out-of-the-box in-memory database plugin that allows you to start
    coding straightaway, but the storage is transient: it does not persist the data
    between calls.'
  prefs: []
  type: TYPE_NORMAL
- en: Product Manager – the two-faced core
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Product Manager is the core of our system. I know what you are thinking: microservices
    should be small (micro) and distributed (no central point), but you need to set
    the conceptual centre somewhere, otherwise you will end up with a fragmented system
    and traceability problems (we will talk about it later).'
  prefs: []
  type: TYPE_NORMAL
- en: Building a dual API with Seneca is fairly easy, as it comes with a quite straightforward
    integration with Express. Express is going to be used to expose some capabilities
    of the UI such as editing products, adding products, deleting products, and so
    on. It is a very convenient framework, easy to learn, and it integrates well with
    Seneca. It is also a de-facto standard on Node.js for web apps, so it makes it
    easy to find information about the possible problems.
  prefs: []
  type: TYPE_NORMAL
- en: It is going to also have a private part exposed through Seneca TCP (the default
    plugin in Seneca) so that our internal network of microservices (specifically,
    the UI) will be able to access the list of products in our catalogue.
  prefs: []
  type: TYPE_NORMAL
- en: Product Manager is going to be small and cohesioned (it will only manage products),
    as well as scalable, but it will hold all the knowledge required to deal with
    products in our e-commerce.
  prefs: []
  type: TYPE_NORMAL
- en: 'First thing we need to do is to define our Product Manager microservice, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: This is going to have a function to retrieve all the products in the database.
    This is probably a bad idea in a production system (as it probably would require
    pagination), but it works for our example.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This should have one function that fetches all the products for a given category.
    It is similar to the previous one, it would need pagination in a production-ready
    system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This should have a function to retrieve products by identifier (`id`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This should have one function that allows us to add products to the database
    (in this case MongoDB). This function will use the Seneca data abstraction to
    decouple our microservice from the storage: we will be able to (in theory) switch
    Mongo to a different database without too much hassle (in theory again).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This should have one function to remove products. Again, using Seneca data abstraction.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This should have one function to edit products.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Our product will be a data structure having four fields: **name**, **category**,
    **description**, and **price**. As you can see, it is a bit simplistic, but it
    will help us to understand the complicated world of microservices.'
  prefs: []
  type: TYPE_NORMAL
- en: Our Product Management microservice is going to use MongoDB ([https://www.mongodb.org/](https://www.mongodb.org/)).
    Mongo is a document-oriented schema-less database that allows an enormous flexibility
    to store data such as products (that, at the end of the day, are documents). It
    is also a good choice for Node.js as it stores JSON objects, which is a standard,
    created for JavaScript (**JSON** stands for **JavaScript Object Notation**), so
    that looks like the perfect pairing.
  prefs: []
  type: TYPE_NORMAL
- en: There is a lot of useful information on the MongoDB website if you want to learn
    more about it.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start coding our functions.
  prefs: []
  type: TYPE_NORMAL
- en: Fetching products
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To fetch products, we go to the database and dump the full list of products
    straight to the interface. In this case, we won't create any pagination mechanism,
    but in general, paginating data is a good practice to avoid database (or applications,
    but mainly database) performance problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We already have a pattern in Seneca that returns all the data in our database.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `products.list$()` function will receive the following two parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: The query criteria
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A function that receives an error and result object (remember the error-first
    callback approach)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Seneca uses the `$` symbol to identify the key functions such as `list$`, `save$`,
    and so on. Regarding the naming of the properties of your objects, as long as
    you use alphanumeric identifiers, your naming will be collision free.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are passing the `done` function from the `seneca.add()` method to the `list$`
    method. This works as Seneca follows the callback with error-first approach. In
    other words, we are creating a shortcut for the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Fetching by category
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Fetching by category is very similar to fetching the full list of products.
    The only difference is that now the Seneca action will take a parameter to filter
    the products by category.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: One of the first questions that most advanced developers will now have in their
    mind is that *isn't this a perfect scenario for an injection attack?* Well, Seneca
    is smart enough to prevent it, so we don't need to worry about it any more than
    avoid concatenating strings with user input.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the only significant difference is the parameter passed called
    `category`, which gets delegated into Seneca data abstraction layer that will
    generate the appropriate query, depending on the storage we use. This is extremely
    powerful when talking about microservices. If you remember, in the previous chapters,
    we always talked about coupling as if it was the root of all evils, and now we
    can assure it is, and Seneca handles it in a very elegant way. In this case, the
    framework provides a contract that the different storage plugins have to satisfy
    in order to work. In the preceding example, `list$` is part of this contract.
    If you use the Seneca storage wisely, switching your microservice over to a new
    database engine (have you ever been tempted to move a part of your data over MongoDB?)
    is a matter of configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Fetching by ID
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Fetching a product by ID is one of the most necessary methods, and it is also
    a tricky one. Not tricky from the coding point of view, as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The tricky part is how `id` is generated. The generation of `id` is one of
    the contact points with the database. Mongo creates a hash to represent a synthetic
    ID; whereas, MySQL usually creates an integer that auto-increments to uniquely
    identify each record. Given that, if we want to switch MongoDB to MySQL in one
    of our apps, the first problem that we need to solve is how to map a hash that
    looks something similar to the following into an ordinal number:'
  prefs: []
  type: TYPE_NORMAL
- en: '`e777d434a849760a1303b7f9f989e33a`'
  prefs: []
  type: TYPE_NORMAL
- en: In 99% of the cases, this is fine, but we need to be careful, especially when
    storing IDs as, if you recall from the previous chapters, the data should be local
    to each microservice, which could imply that changing the data type of the ID
    of one entity, requires changing the referenced ID in all the other databases.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a product
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Adding a product is trivial. We just need to create the data and save it in
    the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In this method, we are using a helper from Seneca, `products.data$(false)`.
    This helper will allow us to retrieve the data of the entity without all the metadata
    about namespace (zone), entity name, and base name that we are not interested
    in when the data is returned to the calling method.
  prefs: []
  type: TYPE_NORMAL
- en: Removing a product
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The removal of a product is usually done by `id`: We target the specific data
    that we want to remove by the primary key and then remove it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we don't return anything aside from an error if something goes
    wrong, so the endpoint that calls this action can assume that a non-errored response
    is a success.
  prefs: []
  type: TYPE_NORMAL
- en: Editing a product
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We need to provide an action to edit products. The code for doing that is as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Here is an interesting scenario. Before editing a product, we need to fetch
    it by ID, and we have already done that. So, what we are doing here is relying
    on the already existing action to retrieve a product by ID, copying the data across,
    and saving it.
  prefs: []
  type: TYPE_NORMAL
- en: This is a nice way for code reuse introduced by Seneca, where you can delegate
    a call from one action to another and work in the wrapper action with the result.
  prefs: []
  type: TYPE_NORMAL
- en: Wiring everything up
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we agreed earlier, the product manager is going to have two faces: one that
    will be exposed to other microservices using the Seneca transport over TCP and
    a second one exposed through Express (a Node.js library to create web apps) in
    the REST way.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s wire everything together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s explain the code:'
  prefs: []
  type: TYPE_NORMAL
- en: We have created a Seneca plugin. This plugin can be reused across different
    microservices. This plugin contains all the definitions of methods needed by our
    microservice that we have previously described.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding code describes the following two sections:'
  prefs: []
  type: TYPE_NORMAL
- en: The first few lines connect to Mongo. In this case, we are specifying that Mongo
    is a local database. We are doing that through the use of a plugin called mongo-store—[https://github.com/rjrodger/seneca-mongo-store](https://github.com/rjrodger/seneca-mongo-store),
    written by Richard Rodger, the author of Seneca.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second part is new to us. It might sound familiar if you have used JQuery
    before, but basically what the `seneca.ready()` callback is doing is taking care
    of the fact that Seneca might not have connected to Mongo before the calls start
    flowing into its API. The `seneca.ready()` callback is where the code for integrating
    Express with Seneca lives.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is the `package.json` configuration of our app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Here we control all the libraries needed for our microservice to run, as well
    as the configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating with Express – how to create a REST API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Integrating with Express is quite straightforward. Let''s take a look at the
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This code snippet, as we''ve seen in the preceding section, provides the following
    three REST endpoints:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/products/fetch`'
  prefs: []
  type: TYPE_NORMAL
- en: '`/products/edit`'
  prefs: []
  type: TYPE_NORMAL
- en: '`/products/delete`'
  prefs: []
  type: TYPE_NORMAL
- en: Let's explain how.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, what we do is tell Seneca to execute the `role:web` action, indicating
    the configuration. This configuration specifies to use a `/products` prefix for
    all the URLs, and it pins the action with a matching `{area: "product", action:
    "*"}` pattern. This is also new for us, but it is a nice way to specify to Seneca
    that whatever action it executes in the URL, it will have implicit `area: "product"`
    of the handler. This means that `/products/fetch` endpoint will correspond to
    the `{area: ''products'', action: ''fetch''}` pattern. This could be a bit difficult,
    but once you get used to it, it is actually really powerful. It does not force
    `use` to fully couple our actions with our URLs by conventions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the configuration, the attribute map specifies the HTTP actions that can
    be executed over an endpoint: fetch will allow `GET`, edit will allow `PUT`, and
    delete will only allow `DELETE`. This way, we can control the semantics of the
    application.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Everything else is probably familiar to you. Create an Express app and specify
    using the following two plugins:'
  prefs: []
  type: TYPE_NORMAL
- en: The JSON body parser
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Seneca web plugin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is all. Now, if we add a new action to our Seneca list of actions in order
    to expose it through the API, the only thing that needs to be done is to modify
    the map attribute to allow HTTP methods.
  prefs: []
  type: TYPE_NORMAL
- en: Although we have built a very simplistic microservice, it captures a big portion
    of the common patterns that you find when creating a **CRUD** (**Create Read Update
    Delete**) application. We have also created a small REST API out of a Seneca application
    with little to no effort. All we need to do now is configure the infrastructure
    (MongoDB) and we are ready to deploy our microservice.
  prefs: []
  type: TYPE_NORMAL
- en: The e-mailer – a common problem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: E-mailing is something that every company needs to do. We need to communicate
    with our customers in order to send notifications, bills, or registration e-mails.
  prefs: []
  type: TYPE_NORMAL
- en: In the companies where I've worked before, e-mailing always presented a problem
    such as e-mails not being delivered, or being delivered twice, with the wrong
    content to the wrong customer, and so on. It looks terrifying that something as
    simple as sending an e-mail could be this complicated to manage.
  prefs: []
  type: TYPE_NORMAL
- en: 'In general, e-mail communication is the first candidate to write a microservice.
    Think about it:'
  prefs: []
  type: TYPE_NORMAL
- en: E-mail does one thing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: E-mail does it well
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: E-mail keeps its own data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is also a good example of how the *Conway's law* kicks into our systems without
    being noticed. We design our systems modeling the existing communication in our
    company as we are constrained by it.
  prefs: []
  type: TYPE_NORMAL
- en: How to send e-mails
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Back to the basics. How do we send e-mails? I am not talking about which network
    protocol we use for sending the e-mail or what are the minimum acceptable headers?
  prefs: []
  type: TYPE_NORMAL
- en: 'I am talking about what we need to send an e-mail from the business point of
    view:'
  prefs: []
  type: TYPE_NORMAL
- en: A title
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The content
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A destination address
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'That is everything. We could have gone far, talking about acknowledgements,
    secure e-mail, BCCs, and so on. However, we are following the lean methodology:
    start with the minimum viable product and build up from it until you achieve the
    desired result.'
  prefs: []
  type: TYPE_NORMAL
- en: I can't remember a project where the e-mail sending wasn't a controversial part.
    The product chosen to deliver e-mails ends up tightly coupled to the system and
    it is really hard to replace it seamlessly. However, microservices are here to
    rescue us.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As I mentioned before, although it sounds easy, sending corporate e-mails could
    end up being a mess. Therefore, the first thing we need to clear is our minimum
    requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: How do we render the e-mail?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does rendering the email belongs to the bound context of the email manipulation?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do we create another microservice to render e-mails?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do we use a third party to manage the e-mails?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do we store the already sent e-mails for auditing purposes?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For this microservice, we are going to use Mandrill. Mandrill is a company that
    allows us to send corporate e-mails, track the already sent e-mails, and create
    e-mail templates that can be edited online.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our microservice is going to look as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We have two patterns: one that makes use of templates and the other that sends
    the content contained in the request.'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, everything that we have defined here is information related
    to e-mailing. There is no bleeding from the Mandrill terminology into what the
    other microservices see in our e-mail sending. The only compromise that we are
    making is the templating. We are delegating the template rendering to the e-mail
    sender, but it is not a big deal, as even if we walk away from Mandrill, we will
    need to render the content somehow.
  prefs: []
  type: TYPE_NORMAL
- en: We will come back to the code later.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Mandrill
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Mandrill is fairly easy to use and shouldn't be a problem to set up. However,
    we are going to use the test mode so that we can assure that the e-mails are not
    going to be delivered and we can access the API for all our needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we need to do is create an account on Mandrill. Just register
    with your e-mail at [https://mandrillapp.com](https://mandrillapp.com), and you
    should be able to access to it, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up Mandrill](img/B04889_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now we have created an account that we need to enter into the test mode. In
    order to do it, just click on your e-mail at the top-right corner and select the
    **Turn on the test mode** option from the menu. The Mandrill menu on the left
    will turn orange now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to create an API key. This key is the login information to be
    used by the Mandrill API. Just click on **Settings** and **SMTP & API Info** and
    add a new key (don''t forget the checkbox to mark the key as test key). It should
    look like the following screenshot now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up Mandrill](img/B04889_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The key is everything you need for now. Let''s test the API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'With these few lines, we have managed to test that Mandrill is up and running
    and we have a valid key. The output of this program should be something very similar
    to the following JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up Mandrill](img/B04889_04_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Hands on – integrating Mandrill in your microservice
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Everything is ready now. We have a working key and our interface. The only
    thing left is to create the code. We are going to use a small part of the Mandrill
    API, but if you want to make use of other features, you can find a better description
    here: [https://mandrillapp.com/api/docs/](https://mandrillapp.com/api/docs/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This first method sends messages without using a template. We just get the HTML
    content (and a few other parameters) from our application and deliver it through
    Mandrill.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, we only have two contact points with the outer world: the parameters
    passed in and the return of our actions. Both of them have a clear contract that
    has nothing to do with Mandrill, but what about the data?'
  prefs: []
  type: TYPE_NORMAL
- en: At the error, we are returning `e.name`, assuming that it is a code. At some
    point, someone will end up branching the flow depending on this **error code**.
    Here, we have something called data coupling; our software components don't depend
    on the contract, but they do depend on the content sent across.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the question is: how do we fix it? *We can''t*. At least not in an easy
    way. We need to assume that our microservice is not perfect, it has a flaw. If
    we switch provider for e-mailing, we are going to need to revisit the calling
    code to check potential couplings.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the world of software, in every single project that I''ve worked on before,
    there was always a big push trying to make the code as generic as possible, trying
    to guess the future, which usually could be as bad as assuming that your microservice
    won''t be perfect. There is something that always attracted my attention: we put
    a large amount of effort in to perfection, but we pretty much ignore the fact
    that we are going to fail and we do can nothing about it. Software fails often
    and we need to be prepared for that.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Later, we will see a pattern to factor human nature into the microservices:
    **the circuit breaker**.'
  prefs: []
  type: TYPE_NORMAL
- en: Don't be surprised if Mandrill rejects the e-mails due to the *unsigned* reason.
    This is due to the fact that they couldn't validate the domain from where we are
    sending the e-mail (in this case, a dummy domain that does not exist). If we want
    Mandrill to actually process the e-mails (even though we are in test mode), we
    just need to verify our domain by adding some configuration to it.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'More information can be found in the Mandrill documentation here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://mandrillapp.com/api/docs/](https://mandrillapp.com/api/docs/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The second method to send e-mails is send an e-mail from a template. In this
    case, Mandrill provides a flexible API:'
  prefs: []
  type: TYPE_NORMAL
- en: It provides per-recipient variables in case we send the e-mail to a list of
    customers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has global variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It allows content replacement (we can replace a full section)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For convenience, we are going to just use global variables as we are limited
    on space in this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now we can create our templates in Mandrill (and let someone else to manage
    them) and we are able to use them to send e-mails. Again, we are specializing.
    Our system specializes in sending e-mails and you leave the creation of the e-mails
    to someone else (maybe someone from the marketing team who knows how to talk to
    customers).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s analyze this microservice:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Data is stored locally**: Not really (it is stored in Mandrill), but from
    the design point of view, it is'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Our microservice is well cohesioned**: It sends only e-mails; it does one
    thing, and does it well'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The size of the microservice is correct**: It can be understood in a few
    minutes, it does not have unnecessary abstractions and can be rewritten fairly
    easily'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we talked about the SOLID design principles earlier, we always skipped
    L, which stands for **Liskov Substitution**. Basically, this means that the software
    has to be semantically correct. For example, if we write an object-oriented program
    that handles one abstract class, the program has to be able to handle all the
    subclasses.
  prefs: []
  type: TYPE_NORMAL
- en: Coming back to Node.js, if our service is able to handle sending a plain e-mail,
    it should be easy to extend and add capabilities without modifying the existing
    ones.
  prefs: []
  type: TYPE_NORMAL
- en: Think about it from the day-to-day production operations point of view; if a
    new feature is added to your system, the last thing you want to do is retest the
    existing functionalities or even worse, deliver the feature to production, introducing
    a bug that no one was aware of.
  prefs: []
  type: TYPE_NORMAL
- en: Let's create a use case. We want to send the same e-mail to two recipients.
    Although Mandrill API allows the calling code to do it, we haven't factored in
    a potential CC.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, we are going to add a new action in Seneca that allows us to do
    it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We have instructed Seneca to take the calls that include `cc` in the list of
    parameters and send them using a Mandrill CC in the send API. If we want to use
    it, the following signature of the calling code will change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The signature will change to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: If you remember correctly, the pattern matching tries to match the most concrete
    input so that if an action matches with more parameters than another one, the
    call will be directed to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is where Seneca shines: We can call it **polymorphism of actions**, as
    we can define different versions of the same action with different parameters
    that end up doing slightly different things and enabling us to reutilize the code
    if we are 100% sure that this is the right thing to do (remember, microservices
    enforce the share-nothing approach: repeating the code might not be as bad as
    coupling two actions).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the `package.json` for the e-mailer microservice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The fallback strategy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you design a system, usually we think about replaceability of the existing
    components; for example, when using a persistence technology in Java, we tend
    to lean towards standards (**JPA**) so that we can replace the underlying implementation
    without too much effort.
  prefs: []
  type: TYPE_NORMAL
- en: Microservices take the same approach, but they isolate the problem instead of
    working towards an easy replaceability. If you read the preceding code, inside
    the Seneca actions, we have done nothing to hide the fact that we are using Mandrill
    to send the e-mails.
  prefs: []
  type: TYPE_NORMAL
- en: As I mentioned before, e-mailing is something that, although seems simple, always
    ends up giving problems.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine that we want to replace Mandrill for a plain SMTP server such as Gmail.
    We don't need to do anything special, we just change the implementation and roll
    out the new version of our microservice.
  prefs: []
  type: TYPE_NORMAL
- en: 'The process is as simple as applying the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: For the outer world, our simplest version of the e-mail sender is now using
    SMTP through Gmail to deliver our e-mails.
  prefs: []
  type: TYPE_NORMAL
- en: As we will see later in the book, delivering a new version of the same interface
    in a microservice network is fairly easy; as long as we respect the interface,
    the implementation should be irrelevant.
  prefs: []
  type: TYPE_NORMAL
- en: We could even roll out one server with this new version and send some traffic
    to it in order to validate our implementation without affecting all the customers
    (in other words, contain the failure).
  prefs: []
  type: TYPE_NORMAL
- en: We have seen how to write an e-mail sender in this section. We have worked through
    a few examples on how our microservice can be adapted quickly for new requirements
    as soon as the business requires new capabilities or we decide that our vendor
    is not good enough to cope with our technical requirements.
  prefs: []
  type: TYPE_NORMAL
- en: The order manager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The order manager is a microservice that processes the orders that the customer
    places through the UI. As you probably remember, we are not going to create a
    sophisticated single-page application with a modern visual framework, as it is
    out of the scope of this book, but we are going to provide the JSON interface
    in order to be able to build the front end later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Order manager introduces an interesting problem: this microservice needs access
    to the information about products, such as name, price, availability, and so on.
    However, it is stored in the product manager microservice, so how do we do that?'
  prefs: []
  type: TYPE_NORMAL
- en: Well, the answer for this question might look simple, but requires a bit of
    thinking.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the microservice – how to gather non-local data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our microservice will need to do the following three things:'
  prefs: []
  type: TYPE_NORMAL
- en: Recover orders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create orders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Delete existing orders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When recovering an order, the option is going to be simple. Recover the order
    by the primary key. We could extend it to recover orders by different criteria,
    such as price, date, and so on, but we are going to keep it simple as we want
    to focus on microservices.
  prefs: []
  type: TYPE_NORMAL
- en: 'When deleting existing orders, the option is also clear: use the ID to delete
    orders. Again, we could choose a more advanced deletion criteria, but we want
    to keep it simple.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem arises when we are trying to create orders. Creating an order in
    our small microservice architecture means sending an e-mail to the customer, specifying
    that we are processing their order, along with the details of the order, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Number of products
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Price per product
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Total price
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Order ID (in case the customer needs to troubleshoot problems with the order)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do we recover the product details?
  prefs: []
  type: TYPE_NORMAL
- en: 'If you see our diagram shown in the *Micromerce – the big picture* section
    of this chapter, order manager will only be called from the UI, which will be
    responsible to recover the product name, its price, and so on. We could adopt
    the following two strategies here:'
  prefs: []
  type: TYPE_NORMAL
- en: Order manager calls product manager and gets the details
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: UI calls product manager and delegates the data to the order manager
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Both options are totally valid, but in this case, we are going for the second:
    UI will gather the information needed to generate an order and it will only call
    the order manager when all the data required is available.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now to answer the question: why?'
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple reason: failure tolerance. Let''s take a look at the following sequence
    diagram of the two options:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Defining the microservice – how to gather non-local data](img/B04889_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The diagram for the second option is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Defining the microservice – how to gather non-local data](img/B04889_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the first view, there is a big difference: the depth of the call; whereas
    in the first example, we have two levels of depth (UI calls the order manager,
    which calls the product manager). In the second example, we have only one level
    of depth. There are a few immediate effects in our architecture, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: When something goes wrong, if we only have one level of depth, we don't need
    to check in too many places.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are more resilient. If something goes wrong, it is the UI of the microservice
    that notices it, returning the appropriate HTTP code, in this case, without having
    to translate the errors that occurred a few levels above the client-facing microservice.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is easier to deploy and test. Not much easier, but we don't need to juggle
    around, we can see straight away if the product manager is reached from the UI,
    instead of having to go through the order manager.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The fact that we are using this architecture instead of the two-level depth
    does not mean that it isn''t appropriate for another situation: the network topology
    is something that you need to plan ahead if you are creating a microservices-oriented
    architecture, as it is one of the hardest aspects to change.'
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, if we want to be extremely flexible, we can use a messaging queue
    with publisher/subscriber technology where our microservices can subscribe to
    different types of messages and emit others to be consumed by a different service,
    but it could complicate the infrastructure that we need to put in place to avoid
    single point of failures.
  prefs: []
  type: TYPE_NORMAL
- en: The order manager – the code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s take a look at the code for the order manager:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, there is nothing complicated about the code. The only interesting
    point is the missing code from the create action.
  prefs: []
  type: TYPE_NORMAL
- en: Calling remote services
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Until now, we have assumed that all our microservices run in the same machine,
    but that is far from ideal. In the real world, microservices are distributed and
    we need to use some sort of transport protocol to carry the message from one service
    to another.
  prefs: []
  type: TYPE_NORMAL
- en: Seneca, as well as nearForm, the company behind Seneca, has sorted this problem
    for us and the open source community around it.
  prefs: []
  type: TYPE_NORMAL
- en: As a modular system, Seneca has embedded the concept of plugin. By default,
    Seneca comes with a bundled plugin to use TCP as the protocol, but it is not hard
    to create a new transport plugin.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'While writing this book, I created one by myself: [https://github.com/dgonzalez/seneca-nservicebus-transport/](https://github.com/dgonzalez/seneca-nservicebus-transport/)'
  prefs: []
  type: TYPE_NORMAL
- en: With this plugin, we could route the Seneca messages through NServiceBus (a
    .NET-based Enterprise Bus), changing the configuration of our client and server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how to configure Seneca to point to a different machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: By default, Seneca will use the default plugin for transport, which as we've
    seen in [Chapter 2](ch02.html "Chapter 2. Microservices in Node.js – Seneca and
    PM2 Alternatives"), *Microservices in Node.js – Seneca and PM2 Alternatives*,
    is `tcp`, and we have specified it to point to the `192.168.0.2` host on the `8080`
    port.
  prefs: []
  type: TYPE_NORMAL
- en: As simple as that, from now on, when we execute an act command on `senecaEmailer`,
    the transport will send the message across to the e-mailer and receives the response.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see the rest of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we are receiving a list of products with all the data needed
    and passing them to the e-mailer to render the e-mail.
  prefs: []
  type: TYPE_NORMAL
- en: If we change the host where the e-mailer lives, the only change that we need
    to do here is the configuration of the `senecaEmailer` variable.
  prefs: []
  type: TYPE_NORMAL
- en: Even if we change the nature of the channel (we could potentially even write
    a plugin to send the data over Twitter, for example), the plugin should look after
    the particularities of it and be transparent for the application.
  prefs: []
  type: TYPE_NORMAL
- en: Resilience over perfection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the example from the preceding section, we built a microservice that calls
    another microservice in order to resolve the call that it receives. However, the
    following points need to be kept in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: What happens if the e-mailer is down?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What happens if the configuration is wrong and the e-mailer is not working on
    the correct port?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We could be throwing *what ifs* for few pages.
  prefs: []
  type: TYPE_NORMAL
- en: Humans are imperfect and so are the things that they build, and software is
    not an exception. Humans are also bad at recognizing the potential problems in
    logical flows, and software tends to be a complex system.
  prefs: []
  type: TYPE_NORMAL
- en: 'In other languages, playing with exceptions is almost something normal, but
    in JavaScript, exceptions are a big deal:'
  prefs: []
  type: TYPE_NORMAL
- en: If an exception bubbles out in a web app in Java, it kills the current stack
    of calls and Tomcat (or the container that you use) returns an error to the client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If an exception bubbles out in a Node.js app, the application is killed as we
    only have one thread executing the app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, pretty much every single callback in Node.js has a first parameter
    that is an error.
  prefs: []
  type: TYPE_NORMAL
- en: When talking about microservices, this error is especially important. You want
    to be resilient. The fact that an e-mail has failed sending does not mean that
    the order cannot be processed, but the e-mail could be manually sent later by
    someone reprocessing the data. This is what we call eventual consistency; we factor
    into our system the fact that at some point our system is going to crash.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, if there is a problem sending the e-mail, but we could store
    the order in the database, the calling code, in this case the UI, should have
    enough information to decide whether the customer gets a fatal message or just
    a warning:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Your order is ready to be processed, however it might take us two days to
    send you the e-mail with the order details. Thanks for your patience*.'
  prefs: []
  type: TYPE_NORMAL
- en: Usually, the fact that our application will keep working even if we cannot complete
    a request, it is usually more business than technical decision. This is an important
    detail, as when building microservices, *Conway's law* is pushing us, the technical
    people, to model the existing business process and partial success maps perfectly
    to the human nature. If you can't complete a task, create a reminder in Evernote
    (or a similar tool) and come back to it once the blocker is resolved.
  prefs: []
  type: TYPE_NORMAL
- en: 'This reads much better than the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Something happened about something, but we can''t tell you more* (which is
    what my mind reads sometimes when I get a general failure in some websites).'
  prefs: []
  type: TYPE_NORMAL
- en: 'We call this way of handling errors system degradation: it might not be 100%
    functional, but it will still work even though its few features are not available,
    instead of a general failure.'
  prefs: []
  type: TYPE_NORMAL
- en: If you think for a second, how many times a web service call has rolled back
    a full transaction in your big corporate system only because it couldn't reach
    a third-party service that might not even be important?
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we built a microservice that uses another microservice to
    resolve a request from a customer: order manager uses e-mailer to complete the
    request. We have also talked about resilience and how important it is in our architecture
    in order to provide the best service.'
  prefs: []
  type: TYPE_NORMAL
- en: The UI – API aggregation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Until now, we have built independent microservices. They had a specific purpose
    and dealt with one specific part of our system: e-mail sending, product management,
    and order processing, but now we are building a microservice whose only purpose
    is to facilitate the communication between microservices.'
  prefs: []
  type: TYPE_NORMAL
- en: Now we are going to build a microservice that interacts with others and is the
    front-facing façade to the customer.
  prefs: []
  type: TYPE_NORMAL
- en: When I was planning the contents of this chapter, a service like this one wasn't
    in it. However, after thinking about it, this chapter wouldn't have been the same
    without showing a few concepts around API aggregation that are fairly easy to
    show in a frontend microservice.
  prefs: []
  type: TYPE_NORMAL
- en: Need for frontend microservice
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Think about scalability. When dealing with HTTP traffic, there is a pyramid
    of traffic. There are more hits in the frontend than in the backend. Usually,
    in order to reach the backend, the frontend needs to process the following few
    requests from the frontend:'
  prefs: []
  type: TYPE_NORMAL
- en: Read a form
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validate it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manage the PRG pattern ([https://en.wikipedia.org/wiki/Post/Redirect/Get](https://en.wikipedia.org/wiki/Post/Redirect/Get))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, there is a lot of logic that needs to be processed by the frontend,
    so that it is not hard to see capacity problems if the software is busy. If we
    are using a microservice, and we are using it in the right way, scaling up or
    down should be an automatic process that can be triggered with a couple of clicks
    (or commands).
  prefs: []
  type: TYPE_NORMAL
- en: The code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Until now, we have pretty much always tested the code in a single server. This
    is fine for testing, but when we are building microservices, we want them to be
    distributed. Therefore, in order to achieve it, we need to indicate to Seneca
    how to reach the services:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: What we have done is create three Seneca instances. They are like communication
    pipes between servers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s explain the code:'
  prefs: []
  type: TYPE_NORMAL
- en: Seneca, by default, uses the transport plugin TCP. It means that Seneca will
    be listening to the `/act` URL on the server. As an example, when we create `senecaEmailer`,
    the URL where Seneca will be pointing to is `http://192.168.0.2:8080/act`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can actually verify it with curl. If we execute the following command line,
    replacing `<valid Seneca pattern>` by a valid Seneca command, we should get a
    response from the server in the JSON format, which would be the second parameter
    in the `done` function for the action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Seneca's default transport plugin is TCP. If we don't specify any other, Seneca
    will use it to reach other servers and listen to calls.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see an easy example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run this program, we can see the following output from the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The code](img/B04889_04_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'It means that Seneca is listening to the port `3000`. Let''s test it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This should print something very similar to the following code in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The code](img/B04889_04_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding code is the TCP/IP dialog between our terminal and Seneca server
    with the result of the response in the last line.
  prefs: []
  type: TYPE_NORMAL
- en: So, what we achieved earlier on having three different instances of Seneca is
    configuring our network of microservices; Seneca will transport the messages across
    the network for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following flow diagram describes how a single API can hide multiple Seneca
    servers in the backend with different microservices (different Seneca instances,
    basically):'
  prefs: []
  type: TYPE_NORMAL
- en: '![The code](img/B04889_04_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s take a look at the skeleton of the microservice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We have actually left the functionality that calls other microservices for
    later discussion. Now we are going to focus on how the code is articulated:'
  prefs: []
  type: TYPE_NORMAL
- en: We are creating a new plugin. The plugin is called `api` (the name of the function
    for wrapping the plugin is `api`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The plugin has to perform the following three actions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: List all the products
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get a product by ID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create an order
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These three actions will call to two different microservices: Product Manager
    and Order Manager. We will come back to this topic later.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Seneca can be seamlessly integrated with Express in order to provide web capabilities
    to Seneca microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Until here, everything is well known, but what about the initialization function
    of the plugin?
  prefs: []
  type: TYPE_NORMAL
- en: 'At first look, it looks like dark magic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s explain it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Seneca will call the `init: <plugin-name>` action in order to initialize the
    plugin.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Through the `prefix` argument, we are listening to URLs under the `/api` path.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are instructing Seneca to map the URLs to action by pinning a base common
    argument. In this case, all our `seneca.add(..)` contains an argument called `area`
    with the `ui` value. We are also asking Seneca to route calls that contain the
    `action` argument (no matter the value, that is why we use the `*`) so that it
    would ignore calls that don't specify the `action` argument.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The following argument (`map`) specifies the methods allowed in the matching.
  prefs: []
  type: TYPE_NORMAL
- en: How is the argument matching done?
  prefs: []
  type: TYPE_NORMAL
- en: The `area` argument is implicit as we have pinned it with the `ui` value.
  prefs: []
  type: TYPE_NORMAL
- en: The `action` argument needs to be present.
  prefs: []
  type: TYPE_NORMAL
- en: The URL must start with `/api` as we specified a prefix.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, with this information, `/api/products` will correspond to the `{area: "ui",
    action: "products"}` action. In the same way, `/api/createorder` will correspond
    to the `{area: "ui", action:"createorder"}` action.'
  prefs: []
  type: TYPE_NORMAL
- en: The `Productbyid` argument is a bit special.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Seneca `pin` keyword is used to assume that the calling code has a pair
    of argument-value so that it makes the code easier to understand, but be careful,
    implicit values can have bad effects to the readability.
  prefs: []
  type: TYPE_NORMAL
- en: Now, although it is not simple, this looks much easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go back to the Seneca actions that are going to provide the functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Warning! In the services written in this chapter, there is no data validation
    performed in order to make the concepts around the design of microservices clear.
    You should always validate the incoming data from untrusted systems (such as customers
    input).
  prefs: []
  type: TYPE_NORMAL
- en: We are actually using everything that we've discussed in the previous chapters,
    but we are taking a step forward in the Seneca semantics.
  prefs: []
  type: TYPE_NORMAL
- en: We have created an API with a very limited set of functionalities, but through
    them, we are aggregating the functionality of different microservices into one.
  prefs: []
  type: TYPE_NORMAL
- en: A detail to take into account is the amount of nested calls in the create order
    action (the last one). In this case, we are creating orders out of only a product
    to simplify the code, but if we are nesting too many calls for non-blocking actions
    waiting for the response in a callback, we will end up having a pyramid of code
    that makes your program difficult to read.
  prefs: []
  type: TYPE_NORMAL
- en: The solution for it would be to refactor how the data is fetched and/or reorganize
    the anonymous functions, avoiding inlining.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another solution is the usage of promises libraries such as Q or Bluebird ([http://bluebirdjs.com/](http://bluebirdjs.com/))
    that allow us to chain the flow of the methods through promises:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In this way, instead of building a sea of callbacks, we are nicely chaining
    the calls to the methods and adding error handlers to avoid the exceptions from
    bubbling up.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we are using the UI as a central point of communication for
    all the microservices, except for the mailer, and we have a really good reason
    for it.
  prefs: []
  type: TYPE_NORMAL
- en: Service degradation – when the failure is not a disaster
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Microservices are great, and we have demonstrated that by writing a small system
    in a few hundred lines of code that is fairly easy to understand.
  prefs: []
  type: TYPE_NORMAL
- en: 'They are also great as they allow us to react in the event of a failure:'
  prefs: []
  type: TYPE_NORMAL
- en: What happens if the e-mailer microservice stops working?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What happens if the order processor stops working?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can we recover from the situation?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What does the customer see?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These questions, on a monolithic system, are nonsense. The e-mailer probably
    would be a part of the application. The failure on sending an e-mail implies a
    general error, unless it is specifically handled. Same with the order processor.
  prefs: []
  type: TYPE_NORMAL
- en: However, what about our microservices-oriented architecture?
  prefs: []
  type: TYPE_NORMAL
- en: The fact that the e-mailer has failed to deliver a few e-mails does not prevent
    the orders from being processed, even though the customers aren't getting the
    e-mails. This is what we call performance or service degradation; the system might
    be slower, but some functionalities will still work.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Service degradation is the ability of a system to lose a feature without suffering
    a general failure.
  prefs: []
  type: TYPE_NORMAL
- en: What about the order manager? Well...we can still make the products-related
    calls work, but we won't be able to process any order…which might still be a good
    thing.
  prefs: []
  type: TYPE_NORMAL
- en: The fact that the order manager is responsible for sending the e-mail instead
    of the UI microservice is not coincidental; we only want to send the e-mail with
    the acknowledgement of a sale on the success event, and we don't want to send
    the success e-mail in any other case.
  prefs: []
  type: TYPE_NORMAL
- en: Circuit breakers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous section, we talked about system degradation in the event of
    a failure, but everybody who has worked in IT for a number of years knows that
    a system does not fail suddenly in most cases of failures.
  prefs: []
  type: TYPE_NORMAL
- en: The most common event is a timeout; the server is busy for a period of time,
    which makes the request to fail, giving our customers a terrible user experience.
  prefs: []
  type: TYPE_NORMAL
- en: How can we solve this particular problem?
  prefs: []
  type: TYPE_NORMAL
- en: 'We can solve this problem with a circuit breaker, as shown in the following
    image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Circuit breakers](img/B04889_04_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A circuit breaker is a mechanism to prevent requests from reaching an unstable
    server that could cause our application to misbehave.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see in the preceding schema, the circuit breaker has the following
    three statuses:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Closed**: The circuit is closed; the requests reach their destination.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Open**: The circuit is open; the requests don''t get past the circuit breaker
    and the client gets an error. The system will retry the communication after a
    time period.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**HalfOpen**: The circuit tests the service again, and if there is no error
    reaching it, the requests can flow again and the circuit breaker is **Closed**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With this simple mechanism, we can prevent the errors to cascade through our
    system, avoiding catastrophic failures.
  prefs: []
  type: TYPE_NORMAL
- en: Ideally, the circuit breaker should be asynchronous. This means that even if
    there are no requests, every few seconds/milliseconds, the system should be trying
    to re-establish the connection to the faulty service in order to continue the
    normal operation.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Failure is a common denominator in the human nature: better be prepared for
    it.'
  prefs: []
  type: TYPE_NORMAL
- en: Circuit breakers are also an ideal place to alert the support engineers. Depending
    on the nature of our system, the fact that a given service cannot be reached could
    mean a serious issue. Can you imagine a bank that is unable to reach the SMS service
    to send two-factor authentication codes? No matter how hard we try, it will always
    happen at some point. So, be prepared for it.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is a very inspiring article from Martin Fowler (one of the big names in
    microservices) about circuit breakers at [http://martinfowler.com/bliki/CircuitBreaker.html](http://martinfowler.com/bliki/CircuitBreaker.html).
  prefs: []
  type: TYPE_NORMAL
- en: Seneca – a simple puzzle that makes our lives easier
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Seneca** is great. It enables the developers to take a simple and small idea
    and translate it into a piece of code with a connection point that does not make
    any assumption, just facts. An action has a clear input and provides you the interface
    to give an answer for it through a callback.'
  prefs: []
  type: TYPE_NORMAL
- en: How many times have you found your team struggling with the class structure
    of an application just to reuse code in *a nice way*?
  prefs: []
  type: TYPE_NORMAL
- en: Seneca focuses on **simplicity**. The fact that we are not modeling objects,
    but just parts of systems using small portions of code that are extremely cohesive
    and idempotent to objects makes our life much easier.
  prefs: []
  type: TYPE_NORMAL
- en: Another way how Seneca makes our life easy is through the **plugability**.
  prefs: []
  type: TYPE_NORMAL
- en: If you review the code that we have been writing in this book, the first thing
    that will be spotted is how convenient the plugins are.
  prefs: []
  type: TYPE_NORMAL
- en: They provide the right level of encapsulation for a bunch of actions (Does it
    look similar to a class?) that are somehow related to each other.
  prefs: []
  type: TYPE_NORMAL
- en: I always try not to over-engineer solutions. It is really easy to fall into
    premature abstraction, preparing the code for a future that we don't know whether
    it it is going to happen in the majority of the cases.
  prefs: []
  type: TYPE_NORMAL
- en: We don't realize how long we spend maintaining features that have been overdesigned
    and need to be tested every time someone changes the code around them.
  prefs: []
  type: TYPE_NORMAL
- en: Seneca avoids (or at least discourages) this type of designs. Think about Seneca
    actions as a small piece of paper (like a post-it), where you need to write what
    happened last week. You need to be smart about what to fit in there, and possibly,
    split it into another post-it if the content gets to dense.
  prefs: []
  type: TYPE_NORMAL
- en: Another point where Seneca is good is in configurability. As we have seen before,
    Seneca comes with a number of integrations for data storage and transport.
  prefs: []
  type: TYPE_NORMAL
- en: 'An important side of Seneca is the transport protocol. As we know by now, the
    default transport is carried over TCP, but can we use a message queue to do it?
    The structure is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Seneca – a simple puzzle that makes our lives easier](img/B04889_04_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Yes, we can. It is already done and maintained.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following URL is a plugin for Seneca that allows it to send messages over
    RabbitMQ instead of HTTP:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/senecajs/seneca-rabbitmq-transport](https://github.com/senecajs/seneca-rabbitmq-transport)'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you look into the code of the plugin (it looks really complex, but it is
    not), you can spot where the magic happens in few seconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Seneca is using Seneca actions to delegate the transport of the message. Although
    it looks a bit recursive, it is brilliant!
  prefs: []
  type: TYPE_NORMAL
- en: Once you understand how Seneca and the transport protocol chosen work, you are
    immediately qualified to write a transport plugin for Seneca.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When I started learning about Seneca in order to write this book, I also wrote
    a transport plugin to use NServiceBus ([http://particular.net/](http://particular.net/)).
  prefs: []
  type: TYPE_NORMAL
- en: NServiceBus is an interesting idea, it allows you to connect a number of storages
    and AMPQ-compliant systems and use them as clients. For example, we could be writing
    messages in a SQL Server table and consuming them from a queue once they get routed
    through NServiceBus, having immediate auditing capabilities on the history of
    the messages.
  prefs: []
  type: TYPE_NORMAL
- en: With such flexibility, we could potentially write a plugin that uses pretty
    much anything as a transport protocol.
  prefs: []
  type: TYPE_NORMAL
- en: Seneca and promises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All our code from the previous chapters is relying on callbacks. Callbacks are
    good as far as your code does not nest them on more than three levels.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there is an even better way of managing the asynchronous nature of
    JavaScript: **promises**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is an example of the JQuery fragment using promises.
  prefs: []
  type: TYPE_NORMAL
- en: 'A promise, by its definition is:'
  prefs: []
  type: TYPE_NORMAL
- en: '*A declaration or assurance that one will do something or that a particular
    thing will happen.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'That is exactly it. If you see the preceding code, `$.when`, returns a promise.
    We don''t know how long the effect function will take, but we can guarantee that
    once it is ready, the function inside of `done` will be executed. It looks very
    similar to callbacks, but take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Don''t try to execute it, it is just a hypothetical example, but what we are
    doing in there is chain promises; and that makes the code vertical instead of
    ending up in a pyramid-shaped program, which is a lot harder to read, as shown
    in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Seneca and promises](img/B04889_04_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Seneca, by default, is not a promise-oriented framework, but (there is always
    a but) using Bluebird, one of the most famous promises libraries in JavaScript,
    we can *promisify* Seneca, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two important details in the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates a promisified version of the `act` function and its use, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'An important detail in this last fragment; instead of receiving a callback
    with the following two parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: An error
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The results
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We are chaining the following two methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Then**: This is executed when the promise is resolved'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Catch**: This is executed if there is an error while resolving the promise'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This type of constructions allows us to write the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'This code is handling something that we have never talked about before: the
    gate executor timeouts. It happens when Seneca cannot reach the destination in
    some situations, and it can be easily handled with a promise as shown earlier.
    The `then` part would never be executed as the function will only be called when
    there is an error.'
  prefs: []
  type: TYPE_NORMAL
- en: There are a few well-consolidated options in the market now for promises in
    JavaScript. Nowadays, my preferred choice would be Bluebird ([https://github.com/petkaantonov/bluebird](https://github.com/petkaantonov/bluebird))
    because of its simplicity. Q is another option used by AngularJS (one of the most
    popular **SPA** frameworks), but for day-to-day use, it looks more complicated
    than Bluebird.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Debugging a Node.js application is very similar to debugging any other application.
    IDEs like **WebStorm** or **IntelliJ** provide a traditional debugger where you
    can install breakpoints and stop the execution whenever the application hits the
    given line.
  prefs: []
  type: TYPE_NORMAL
- en: This is perfect if you buy a license for one of the IDEs, but there is a free
    alternative that will have a very similiar result for the users of Google Chrome,
    **node-inspector**.
  prefs: []
  type: TYPE_NORMAL
- en: Node-inspector is an npm package that pretty much enables the Chrome debugger
    to debug Node.js applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we need to install node-inspector:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'This should add a command to our system called `node-inspector`. If we execute
    it, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Debugging](img/B04889_04_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: That means our debug server has started.
  prefs: []
  type: TYPE_NORMAL
- en: Now we need to run a node application with a special flag to indicate that it
    needs to be debugged.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s take a simple Seneca act as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in order to run it on the debug mode, execute the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The way to access the debugger is through the URL `http://127.0.0.1:8080/?port=5858`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Debugging](img/B04889_04_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'I am sure this image is very familiar to every developer in the world: it is
    the Chrome debugger showing our code. As you can see in the first line, the one
    highlighted in blue, the application stopped in the first instruction so that
    we can place the breakpoints by clicking the line numbers, as shown in the following
    image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Debugging](img/B04889_04_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see in the preceding image, we have installed a breakpoint in line
    **9**. Now we can use the control panel to navigate through the code and values
    of our variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Debugging](img/B04889_04_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The controls on the top speak for themselves if you ever debugged an application:'
  prefs: []
  type: TYPE_NORMAL
- en: The first button is called play and it allows the application to run to the
    next breakpoint
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Step over executes the next line in the current file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Step into goes into the next line, getting deeper in the call stack so that
    we can see the call hierarchy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Step out is the reverse of step into
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disable breakpoints will prevent the program from stopping at the breakpoints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pause on exceptions, as its name indicates, will cause the program to stop on
    exceptions (it is very useful when trying to catch errors)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we click on play, we can see how the script will stop in line **9** in the
    following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Debugging](img/B04889_04_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As a good debugger, it will let us inspect the value of our variables by hovering
    the cursor over the variable name.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter has been pretty intense. We have gone through a lot of content
    that helped us in building a small microservices ecosystem that, when orchestrated
    together, would fairly work well. We have been a bit simplistic some times, but
    the idea of the book is to indicate the power of the microservices-oriented software.
    At this stage, I would recommend the reader to start performing some testing around
    Seneca.
  prefs: []
  type: TYPE_NORMAL
- en: The documentation on the website is quite helpful, and there are a lot of examples
    to follow.
  prefs: []
  type: TYPE_NORMAL
- en: There are a few plugins for storage and transport, as well as other type of
    plugins (such as user authentication), that would allow you to experiment with
    different features of Seneca.
  prefs: []
  type: TYPE_NORMAL
- en: We will be talking more about some of them in the following chapters.
  prefs: []
  type: TYPE_NORMAL
