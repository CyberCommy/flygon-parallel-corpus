- en: Chapter 5. Dependency Injection in Angular 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we'll explain how to take advantage of the **dependency injection**
    (**DI**) mechanism of the framework with all its various features.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will explore the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Configuring and creating injectors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instantiating objects using injectors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Injecting dependencies into our directives and components. This way, we will
    be able to reuse the business logic defined within the services and wire it up
    with the UI logic.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Annotating the ES5 code we will write in order to get the exact same result
    we get when we are using the TypeScript syntax.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why do I need Dependency Injection?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s suppose that we have a `Car` class that depends on the `Engine` and
    `Transmission` classes. How can we implement this system? Let''s take a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we created the dependencies of the `Car` class inside of its
    constructor. Although it looks simple, it is far from being flexible. Each time
    we create an instance of the `Car` class, instances of the same `Engine` and `Transmission`
    classes will be created. This may be problematic because of the following reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Car` class gets less testable because we can't test it independently from
    its `engine` and `transmission` dependencies.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We couple the `Car` class with the logic used for the instantiation of its dependencies.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependency Injection in Angular 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another way we can approach this is by taking advantage of the DI pattern.
    We''re already familiar with it from AngularJS 1.x. Let''s demonstrate how we
    can refactor the preceding code using DI in the context of Angular 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: All we did in the preceding snippet was add the `@Injectable` class decorator
    on top of the definition of the `Car` class and provide type annotations for the
    parameters of its constructor.
  prefs: []
  type: TYPE_NORMAL
- en: Benefits of DI in Angular 2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is one more step left, which we''ll take a look at in the next section.
    But let''s see what the benefits of the mentioned approach are:'
  prefs: []
  type: TYPE_NORMAL
- en: We can easily pass different versions of the dependencies of the `Car` class
    for a testing environment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We're not coupled with the logic around the dependencies' instantiation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Car` class is only responsible for implementing its own domain-specific
    logic instead of being coupled with additional functionalities, such as the management
    of its dependencies. Our code also got more declarative and easier to read.
  prefs: []
  type: TYPE_NORMAL
- en: Now, after we've realized some of the benefits of the DI, let's take a look
    at the missing pieces in order to make this code work!
  prefs: []
  type: TYPE_NORMAL
- en: Configuring an injector
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The primitive used for the instantiation of the individual dependencies in our
    Angular 2 applications via the DI mechanism of the framework is called the **injector**.
    The injector contains a set of **providers** that encapsulate the logic for the
    instantiation of registered dependencies associated with **tokens**. We can think
    of tokens as identifiers of the different providers registered within the injector.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following snippet, which is located at `ch5/ts/injector-basics/injector.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You can run the file using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: If you haven't installed `ts-node` yet, take a look at [Chapter 3](part0027_split_000.html#PNV61-a118c4c18dd64e8ab73e171b466b6582
    "Chapter 3. TypeScript Crash Course"), *TypeScript Crash Course*, which explains
    how you can proceed in order to have it up and running on your computer.
  prefs: []
  type: TYPE_NORMAL
- en: We import `Injector`, `Injectable`, `Inject`, `OpaqueToken`, and `provide`.
  prefs: []
  type: TYPE_NORMAL
- en: Injector represents the **container** used for the instantiation of the different
    dependencies. Using the rules declared with the `provide` function and the metadata
    generated by the TypeScript compiler, it knows how to create them.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding snippet, we initially defined the `BUFFER_SIZE` constant and
    set it to the `new OpaqueToken('buffer-size')` value. We can think of the value
    of `BUFFER_SIZE` as a unique value that cannot be duplicated in the application
    (`OpaqueToken` is an alternative of the `Symbol` class from ES2015, since at the
    time of writing this, it is not supported by TypeScript).
  prefs: []
  type: TYPE_NORMAL
- en: 'We defined two classes: `Buffer` and `Socket`. The `Buffer` class has a constructor
    that accepts only a single dependency called `size`, which is of the type `Number`.
    In order to add additional metadata for the process of dependency resolution,
    we use the `@Inject` parameter decorator. This decorator accepts an identifier
    (also known as **token**) of the dependency we want to inject. Usually, it is
    the type of the dependency (that is, a reference of a class), but in some cases,
    it can be a different type of a value. For example, in our case, we used the instance
    of the `OpaqueToken` class.'
  prefs: []
  type: TYPE_NORMAL
- en: Dependency resolution with generated metadata
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now let's take a look at the `Socket` class. We decorate it with the `@Injectable`
    decorator. This decorator is supposed to be used by any class that accepts dependencies
    that should be injected via the dependency injection mechanism of Angular 2.
  prefs: []
  type: TYPE_NORMAL
- en: The `@Injectable` decorator forces the TypeScript compiler to generate additional
    metadata for the types of dependencies that a given class accepts. This means
    that if we omit the `@Injectable` decorator, Angular's DI mechanism will not be
    aware of the tokens associated with the dependencies it needs to resolve.
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript doesn't generate any metadata if no decorator is used on top of a
    class mostly for performance concerns. Imagine if such metadata was generated
    for each individual class that accepts dependencies—in this case, the output would
    be bloated with additional type metadata that would be unused.
  prefs: []
  type: TYPE_NORMAL
- en: 'An alternative to using `@Injectable` is to explicitly declare the types of
    dependencies using the `@Inject` decorator. Take a look at the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This means that the preceding code has equivalent semantics to the code that
    uses `@Injectable`, as mentioned earlier. The only difference is that Angular
    2 will get the type of dependency (that is, the token associated with it) explicitly
    (directly from the metadata added by the `@Injector` decorator) compared to the
    case where `@Injectable` is used, when it will look at the metadata generated
    by the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: Instantiating an injector
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let''s create an instance of an injector in order to use it for the instantiation
    of registered tokens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We create an instance of the `Injector` using its static method called `resolveAndCreate`.
    This is a factory method that accepts an array of providers as argument and returns
    a new `Injector`.
  prefs: []
  type: TYPE_NORMAL
- en: '`resolve` means that the providers will go through a resolution process, which
    includes some internal processing (flattening multiple nested arrays and converting
    individual providers into an array). Later, the injector can instantiate any of
    the dependencies for which we have registered providers based on the rules the
    providers encapsulate.'
  prefs: []
  type: TYPE_NORMAL
- en: In our case, we used the `provide` method in order to explicitly tell the Angular
    2 DI mechanism to use the value `42` when the `BUFFER_SIZE` token is required.
    The other two providers are implicit. Angular 2 will instantiate them by invoking
    the provided class with the `new` operator once all of their dependencies are
    resolved.
  prefs: []
  type: TYPE_NORMAL
- en: 'We request the `BUFFER_SIZE` value in the constructor of the `Buffer` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we used the `@Inject` parameter decorator. It hints
    the DI mechanism that the first argument of the constructor of the `Buffer` class
    should be instantiated with the provider associated with the `BUFFER_SIZE` token
    passed to the injector.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing forward references
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Angular 2 introduced the concept of **forward references**. It is required
    due to the following reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: ES2015 classes are not hoisted.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allow resolution of the dependencies that are declared after the declaration
    of the dependent providers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, we're going to explain the problem that forward references
    solve and the way we can take advantage of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s suppose that we have defined the `Buffer` and `Socket` classes
    in the opposite order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have the exact same dependencies as in the ones in the previous example,
    but in this case, the `Socket` class definition precedes the definition of the
    `Buffer` class. Note that the value of the `Buffer` identifier will equal `undefined`
    until the JavaScript virtual machine evaluates the declaration of the `Buffer`
    class. However, the metadata for the types of dependencies that `Socket` accepts
    will be generated and placed right after the `Socket` class definition. This means
    that along with the interpretation of the generated JavaScript, the value of the
    `Buffer` token will equal `undefined`—that is, as a type of dependency (or in
    the context of the DI mechanism of Angular 2, its token), the framework will get
    an invalid value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the preceding snippet will result in a runtime error of the following
    form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The best way to resolve this issue is by swapping the definitions with their
    proper order. Another way we can proceed is to take advantage of a solution that
    Angular 2 provides: a forward reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The preceding snippet demonstrates how we can take advantage of forward references.
    All we need to do is use the `@Inject` parameter decorator and pass the result
    of the invocation of the `forwardRef` function to it. The `forwardRef` function
    is a higher-order function that accepts a single argument—another function that
    is responsible for returning the token associated with the dependency (or more
    precisely associated with its provider) that needs to be injected. This way, the
    framework provides a way to defer the process of resolving the types (tokens)
    of dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: The token of the dependency will be resolved the first time `Socket` needs to
    be instantiated, unlike the default behavior in which the token is required at
    the time of the declaration of the given class.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring providers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let''s take a look at an example similar to the one used earlier but with
    a different configuration of the injector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In this case, inside of the provider, we explicitly declared that we want the
    `Buffer` class to be used for the construction of the dependency with a token
    equal to the reference of the `Buffer` class. We do the exact same thing for the
    dependency associated with the `Socket` token; but this time, we provide the `Socket`
    class instead. This is how Angular 2 will proceed when we omit the call of the
    `provide` function and pass only a reference to a class instead.
  prefs: []
  type: TYPE_NORMAL
- en: Explicitly declaring the class used for the instantiation of the same class
    may seem quite worthless, and given the examples we looked at so far, this'll
    be completely correct. In some cases, however, we might want to provide a different
    class for the instantiation of a dependency associated with given class token.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, let''s suppose we have the `Http` service that is used in a service
    called `UserService`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The `UserService` service uses `Http` for communication with a RESTful service.
    We can instantiate `UserService` using `injector.get(UserService)`. This way,
    the constructor of `UserService` invoked by the injector''s `get` method will
    accept an instance of the `Http` service as an argument. However, if we want to
    test `UserService`, we don''t really need to make HTTP calls to the RESTful service.
    In case of unit testing, we can provide a dummy implementation that will only
    fake these HTTP calls. In order to inject an instance of a different class to
    the `UserService` service, we can change the configuration of the injector to
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Now, when we instantiate `UserService`, it's constructor will receive a reference
    to an instance of the `DummyHttp` service. This code is available at `ch5/ts/configuring-providers/dummy-http.ts`.
  prefs: []
  type: TYPE_NORMAL
- en: Using existing providers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Another way to proceed is using the `useExisting` property of the provider''s
    configuration object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding snippet, we registered three tokens: `DummyService`, `UserService`,
    and `Http`. We declared that we want to bind the `Http` token to the existing
    token, `DummyService`. This means that when the `Http` service is requested, the
    injector will find the provider for the token used as the value of the `useExisting`
    property and instantiate it or get the value associated with it. We can think
    of `useExisting` as creating an alias of the given token:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The preceding snippet will create an alias of the `Http` token to the `DummyHttp`
    token. This means that once the `Http` token is requested, the call will be forwarded
    to the provider associated with the `DummyHttp` token, which will be resolved
    to the value `dummyHttp`.
  prefs: []
  type: TYPE_NORMAL
- en: Defining factories for instantiating services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, let's suppose we want to create a complex object, for example, one that
    represents a **Transport Layer Security** (**TLS**) connection. A few of the properties
    of such an object are a socket, a set of crypto protocols, and a certificate.
    In the context of this problem, the features of the DI mechanism of Angular 2
    we have so far looked at might seem a bit limited.
  prefs: []
  type: TYPE_NORMAL
- en: For example, we might need to configure some of the properties of the `TLSConnection`
    class without coupling the process of its instantiation with all the configuration
    details (choose appropriate crypto algorithms, open the TCP socket over which
    we will establish the secure connection, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, we can take advantage of the `useFactory` property of the provider''s
    configuration object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code seems a bit complex at first, but let''s take a look at
    it step by step. We can start with the parts we''re already familiar with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Initially, we registered a number of providers: `Buffer`, `Socket`, `Certificate`,
    and `Crypto`. Just like in the preceding example, we also registered the `BUFFER_SIZE`
    token and associated it with the value `42`. This means that we can already create
    objects of the `Buffer`, `Socket`, `Certificate`, and `Crypto` types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We can create and configure an instance of the `TLSConnection` object in the
    following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we register a provider that has the `TLSConnection` token as a dependency,
    we will prevent the dependency injection mechanism of Angular from taking care
    of the dependency resolution process. In order to handle this problem, we can
    use the `useFactory` property of the provider''s configuration object. This way,
    we can specify a function in which we can manually create the instance of the
    object associated with the provider''s token. We can use the `useFactory` property
    together with the `deps` property in order to specify the dependencies to be passed
    to the factory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, we defined the factory function used for the instantiation
    of `TLSConnection`. As dependencies, we declared `Socket`, `Certificate`, and
    `Crypto`. These dependencies are resolved by the DI mechanism of Angular 2 and
    injected to the factory function. You can take a look at the entire implementation
    and play with it at `ch5/ts/configuring-providers/factory.ts`.
  prefs: []
  type: TYPE_NORMAL
- en: Child injectors and visibility
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we're going to take a look at how we can build a hierarchy
    of injectors. This is a completely new concept introduced by Angular 2\. Each
    injector can have zero or one parent injectors and each parent injector can have
    zero or more children, respectively. In contrast to AngularJS 1.x, where all the
    registered providers are stored in a flat structure in Angular 2, they are stored
    in a tree. The flat structure is more limited; for instance, it doesn't support
    the namespacing of tokens; that is, we cannot declare different providers for
    the same token, which might be required in some cases. So far, we looked at an
    example of injector that doesn't have any children or a parent. Now let's build
    a hierarchy of injectors!
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to gain a better understanding of this hierarchical structure of injectors,
    let''s take a look at the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Child injectors and visibility](../images/00022.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, we see a tree where each node is an injector and each of these injectors
    keeps a reference to its parent. Injector **House** has three child injectors:
    **Bathroom**, **Kitchen**, and **Garage**.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Garage** has two children: **Car** and **Storage**. We can think of these
    injectors as containers with registered providers inside of them.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's suppose we want to get the value of the provider associated with the token
    **Tire**. If we use the injector **Car**, this means that Angular 2's DI mechanism
    will try to find the provider associated with this token in **Car** and all of
    its parents, **Garage** and **House**, until it finds it.
  prefs: []
  type: TYPE_NORMAL
- en: Building a hierarchy of injectors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to gain a better understanding of the previous paragraph, let''s take
    a look at this simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The imports are omitted, since they are not essential to explain the preceding
    snippet. We have two services, `Http` and `UserService`, where `UserService` depends
    on the `Http` service.
  prefs: []
  type: TYPE_NORMAL
- en: Initially, we created an injector using the `resolveAndCreate` static method
    of the `Injector` class. We passed an implicit provider to this injector, which
    will later be resolved to a provider with an `Http` token. Using `resolveAndCreateChild`,
    we resolved the passed providers and instantiated an injector, which points to
    `parentInjector` (so we get the same relation as the one between **Garage** and
    **House** on the diagram above).
  prefs: []
  type: TYPE_NORMAL
- en: Now, using `childInjector.get(UserService)`, we are able to get the value associated
    with the `UserService` token. Similarly, using `childInjector.get(Http)` and `parentInjector.get(Http)`,
    we get the same value associated with the `Http` token. This means that `childInjector`
    asks its parent for the value associated with the requested token.
  prefs: []
  type: TYPE_NORMAL
- en: However, if we try to use `parentInjector.get(UserService)`, we won't be able
    to get the value associated with the token, since in this injector, we don't have
    a registered provider with this token.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring dependencies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we're familiar with the injectors' hierarchy, let's see how we can
    get the dependencies from the appropriate injectors in it.
  prefs: []
  type: TYPE_NORMAL
- en: Using the @Self decorator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now let''s suppose we have the following configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We can instantiate the `UserService` token using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In `UserService`, we can declare that we want to get the `Channel` dependency
    from the current injector (that is, `childInjector`) using the `@Self` decorator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Although this is going to be the default behavior during the instantiation
    of the `UserService`, using `@Self`, we can be more explicit. Let''s suppose we
    change the configuration of `childInjector` to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: If we keep the `@Self` decorator in the `UserService` constructor and try to
    instantiate `UserService` using `childInjector`, we will get a runtime error because
    of the missing provider for `Channel`.
  prefs: []
  type: TYPE_NORMAL
- en: Skipping the self injector
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In some cases, especially while injecting the dependencies of UI components,
    we may want to use the provider registered in the parent injector instead of the
    one registered in the current injector. We can achieve this behavior by taking
    advantage of the `@SkipSelf` decorator. For instance, let''s suppose we have the
    following definition of the class `Context`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Each instance of the `Context` class has a parent. Now let''s build a hierarchy
    of two injectors, which will allow us to create a context with a parent context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Since the root context doesn't have a parent, we will set the value of its provider
    to be `new Context(null)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to instantiate the child context, we can use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: For the instantiation of the child, `Context` will be used by the provider registered
    within the `childInjector`. However, as a dependency it accepts an object which
    is an instance of the `Context` class. Such classes exist in the same injector,
    which means that Angular will try to instantiate it, but it has a dependency of
    the `Context` type. This process will lead to an infinite loop that will cause
    a runtime error.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to prevent it from happening, we can change the definition of `Context`
    in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The only change that we introduced is the addition of the parameter decorator
    `@SkipSelf`.
  prefs: []
  type: TYPE_NORMAL
- en: Having optional dependencies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Angular 2 introduces the `@Optional` decorator, which allows us to deal with
    dependencies that don't have a registered provider associated with them. Suppose
    a dependency of a provider is not available in any of the target injectors responsible
    for its instantiation. If we use the `@Optional` decorator, during the instantiation
    of the dependent provider for value of the missing dependency will be passed `null`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we defined an abstract class called `SortingAlgorithm` and a class
    called `Collection`, which accepts an instance of a concrete class as a dependency
    that extends `SortingAlgorithm`. Inside of the `Collection` constructor, we set
    the `sort` instance property to the passed dependency of the `SortingAlgorithm`
    type or a default sorting algorithm implementation.
  prefs: []
  type: TYPE_NORMAL
- en: We didn't define any providers for the `SortingAlgorithm` token in the injector
    we configured. So, if we want to get an instance of the `Collection` class using
    `injector.get(Collection)`, we'll get a runtime error. This means that if we want
    to get an instance of the `Collection` class using the DI mechanism of the framework,
    we must register a provider for the `SortingAlgorithm` token, although we can
    fall back to the default sorting algorithm's implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Angular 2 provides a solution to this problem with the `@Optional` decorator.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how we can approach the problem using the `@Optional` decorator provided
    by the framework:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, we declared the `sort` dependency as optional, which
    means that if Angular 2 doesn't find any provider for its token, it will pass
    the `null` value.
  prefs: []
  type: TYPE_NORMAL
- en: Using multiproviders
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Multiproviders are another new concept brought to the Angular 2 DI mechanism.
    They allow us to associate multiple providers with the same token. This can be
    quite useful if we're developing a third-party library that comes with some default
    implementations of different services, but you want to allow the users to extend
    it with custom ones. They are also exclusively used to declare multiple validations
    over a single control in the Angular 2 form module. We will explain this module
    in [Chapter 6](part0062_split_000.html#1R42S1-a118c4c18dd64e8ab73e171b466b6582
    "Chapter 6. Working with the Angular 2 Router and Forms"), *Working with the Angular
    2 Router and Forms*, and [Chapter 7](part0069_split_000.html#21PMQ2-a118c4c18dd64e8ab73e171b466b6582
    "Chapter 7. Explaining Pipes and Communicating with RESTful Services"), *Explaining
    Pipes and Communicating with RESTful Services*.
  prefs: []
  type: TYPE_NORMAL
- en: Another sample of an applicable use case of multiproviders is what Angular 2
    uses for event management in their WebWorkers implementation. They create multiproviders
    for event management plugins. Each of the providers returns a different strategy,
    which supports a different set of events (touch events, keyboard events, and so
    on). Once a given event occurs, they can choose the appropriate plugin that handles
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at an example that illustrates the typical usage of multiproviders:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, we declared a constant called `VALIDATOR` with a new
    instance of `OpaqueToken`. We also created an injector where we registered three
    providers—two of them are used as value functions that, based on different criteria,
    validate instances of the class `Employee`. These functions are of the type `EmployeeValidator`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to declare that we want the injector to pass all the registered validators
    to the constructor of the class `Employee`, we need to use the following constructor
    definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we declared a class `Employee` that accepts a single
    dependency—an array of `EmployeeValidators`. In the method `validate`, we applied
    the individual validators over the current class instance and filtered the results
    in order to get only the ones that have returned an error message.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the constructor argument `validators` is of the `EmployeeValidator[]`
    type. Since we can't use the type "array of objects" as a token for a provider,
    because it is not a valid type reference, we need to use the `@Inject` parameter
    decorator.
  prefs: []
  type: TYPE_NORMAL
- en: Using DI with components and directives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [Chapter 4](part0040_split_000.html#164MG1-a118c4c18dd64e8ab73e171b466b6582
    "Chapter 4. Getting Started with Angular 2 Components and Directives"), *Getting
    Started with Angular 2 Components and Directives*, when we developed our first
    Angular 2 directive, we saw how we can take advantage of the DI mechanism to inject
    services into our UI-related components (that is, directives and components).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a quick look at what we did earlier, but from a DI perspective:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Most of the code from the earlier implementation is omitted because it is not
    directly related to our current focus.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the constructor of `Tooltip` accepts two dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: An instance of the `ElementRef` class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An instance of the `Overlay` class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The types of dependencies are the tokens associated with their providers, and
    the corresponding values from the providers are going to be injected with the
    DI mechanism of Angular 2.
  prefs: []
  type: TYPE_NORMAL
- en: Although the declaration of the dependencies of the `Tooltip` class looks exactly
    the same as what we did in the previous sections, there's neither any explicit
    configuration nor any instantiation of an injector.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the element injectors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Under the hood, Angular will create injectors for all the directives and components,
    and add a default set of providers to it. This is the so-called **element injector**
    and is something the framework takes care of itself. The injectors associated
    with the components are called **host injectors**. One of the providers in each
    directive and component injector is associated with the `ElementRef` token; it
    will return a reference to the host element of the directive. But where is the
    provider for the `Overlay` class declared? Let''s take a look at the implementation
    of the top-level component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: We configured the element injector for the `App` component by declaring the
    `providers` property inside of the `@Component` decorator. At this point, the
    registered providers are going to be visible by the directive or the component
    associated with the corresponding element injector and the component's entire
    component subtree, unless it is overridden somewhere in the hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring providers for the element injectors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Having the declaration of all the providers in the same place might be quite
    inconvenient. For example, imagine we're developing a large-scale application
    that has hundreds of components depending on thousands of services. In this case,
    configuring all the providers in the root component is not a practical solution.
    There will be name collisions when two or more providers are associated to the
    same token. The configuration will be huge and it will be hard to trace where
    the different tokens need to be injected.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we mentioned, Angular 2''s `@Directive` (and respectively `@Component`)
    decorator allows us to introduce directive-specific providers using the `providers`
    property. Here is how we can approach this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example overrides the provider for the `Overlay` token in the
    `Tooltip` directive's declaration. This way, Angular will inject an instance of
    `OverlayMock` instead of `Overlay` during the instantiation of the tooltip.
  prefs: []
  type: TYPE_NORMAL
- en: 'A better way to override the provider is using the `bootstrap` function. We
    can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding `bootstrap` call, we provided a different top-level component
    and provider for the `Overlay` service that will return an instance of the `OverlayMock`
    class. This way, we can test the `Tooltip` directive ignoring the implementation
    of `Overlay`.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring DI with components
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since components are generally directives with views, everything we've seen
    so far regarding how the DI mechanism works with directives is valid for components
    as well. However, because of the extra features that the components provide, we're
    allowed to have further control over their providers.
  prefs: []
  type: TYPE_NORMAL
- en: As we said, the injector associated with each component will be marked as a
    **host** injector. There's a parameter decorator called `@Host`, which allows
    us to retrieve a given dependency from any injector until it reaches the closest
    host injector. This means that by using the `@Host` decorator in a directive,
    we can declare that we want to retrieve the given dependency from the current
    injector or any parent injector until we reach the injector of the closest parent
    component.
  prefs: []
  type: TYPE_NORMAL
- en: The `viewProviders` property added to the `@Component` decorator is in charge
    of achieving even more control.
  prefs: []
  type: TYPE_NORMAL
- en: viewProviders versus providers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s take a look at an example of a component called `MarkdownPanel`. This
    component will be used in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The content of each section of the panel will be translated from the markdown
    to the HTML. We can delegate this functionality to a service called `Markdown`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The `Markdown` service wraps the markdown module in order to make it injectable
    through the DI mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's implement `MarkdownPanel`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following snippet, we can find all the important details from the component''s
    implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We used the `markdown-panel` selector and set the `viewProviders` property.
    In this case, there''s only a single view provider: the one for the `Markdown`
    service. By setting this property, we declared that all the providers declared
    in it will be accessible from the component itself and all of its **view children**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s suppose we have a component called `MarkdownButton` and we want
    to add it to our template in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Markdown` service will not be accessible by the `MarkdownButton` used
    below the `panel-content` element; however, it''ll be accessible if we use the
    button in the component''s template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: If we need the provider to be visible in all the content and view children,
    all we should do is change the property name of the `viewProviders` property to
    `providers`.
  prefs: []
  type: TYPE_NORMAL
- en: You can find this example in the file in the examples directory at `ch5/ts/directives/app.ts`.
  prefs: []
  type: TYPE_NORMAL
- en: Using Angular's DI with ES5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are already proficient in using the dependency injection of Angular 2 with
    TypeScript! As we know, we are not limited to TypeScript for the development of
    Angular 2 applications; we can also use ES5, ES2015, and ES2016 (as well as Dart,
    but that is out of the scope of this book).
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, we declared the dependencies of the different classes in their constructor
    using standard TypeScript type annotations. All such classes are supposed to be
    decorated with the `@Injectable` decorator. Unfortunately, some of the other languages
    supported by Angular 2 miss a few of these features. In the following table, we
    can see that ES5 doesn''t support type annotations, classes, and decorators:'
  prefs: []
  type: TYPE_NORMAL
- en: '|   | ES5 | ES2015 | ES2016 |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Classes | No | Yes | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| Decorators | No | No | Yes (no parameter decorators) |'
  prefs: []
  type: TYPE_TB
- en: '| Type annotations | No | No | No |'
  prefs: []
  type: TYPE_TB
- en: In this case, how we can take advantage of the DI mechanism in these languages?
    Angular 2 provides an internal JavaScript **Domain Specific Language** (**DSL**),
    which allows us to take advantage of the entire functionality of the framework
    using ES5.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s translate the `MarkdownPanel` example we took a look at in the
    previous section from TypeScript to ES5\. First, let''s start with the `Markdown`
    service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: We defined a variable called `Markdown` and set its value to the returned result
    from the invocation of `ng.core.Class`. This construct allows us to emulate ES2015
    classes using ES5\. The argument of the `ng.core.Class` method is an object literal,
    which must have the definition of a `constructor` function. As a result, `ng.core.Class`
    will return a JavaScript constructor function with the body of `constructor` from
    the object literal. All the other methods defined within the boundaries of the
    passed parameter will be added to the function's prototype.
  prefs: []
  type: TYPE_NORMAL
- en: 'One problem is solved: we can now emulate classes in ES5; there are two more
    problems left!'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s take a look at how we can define the `MarkdownPanel` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: From [Chapter 4](part0040_split_000.html#164MG1-a118c4c18dd64e8ab73e171b466b6582
    "Chapter 4. Getting Started with Angular 2 Components and Directives"), *Getting
    Started with Angular 2 Components and Directives*, we are already familiar with
    the ES5 syntax used to define components. Now, let's take a look at the constructor
    function of `MarkdownPanel` in order to make sure how we can declare the dependencies
    of our components and even classes in general.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the preceding snippet, we can note that the value of the constructor is
    not a function this time, but an array instead. This might seem familiar to you
    from AngularJS 1.x, where we are able to declare the dependencies of the given
    service by listing their names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Although the syntax in Angular 2 is similar, it brings a lot of improvements.
    For instance, we're no longer limited to using strings for the dependencies' tokens.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s suppose we want to make the `Markdown` service an optional dependency.
    In this case, we can approach this by passing an array of decorators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'This way, by nesting arrays, we can apply a sequence of decorators: `[[ng.core.Optional()`,
    `ng.core.Self()`, `Markdown]`, `...]`. In this example, the `@Optional` and `@Self`
    decorators will add the associated metadata to the class in the specified order.'
  prefs: []
  type: TYPE_NORMAL
- en: Although using ES5 makes our build simpler and allows us to skip the intermediate
    step of transpilation, which can be tempting, Google's recommendation is to take
    advantage of static typing using TypeScript. This way, we have a much clearer
    syntax, which carries better semantics with less typing and provides us with great
    tooling.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered the DI mechanism of Angular 2\. We briefly discussed
    the positives of using dependency injection in our projects by introducing it
    in the context of the framework. The second step in our journey was how to instantiate
    and configure injectors; we also explained the injectors' hierarchy and the visibility
    of the registered providers. In order to enforce a better separation of concerns,
    we mentioned how we can inject services carrying the business logic of our application
    in our directives and components. The last point we took a look at was how we
    can use the DI mechanism with the ES5 syntax.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll introduce the new routing mechanism of the framework.
    We'll explain how we can configure the component-based router and add multiple
    views to our application. Another important topic we are going to cover is the
    new form module. By building a simple application, we will demonstrate how we
    can create and manage forms.
  prefs: []
  type: TYPE_NORMAL
