- en: Chapter 12. Testing and Debugging
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As you write JavaScript applications, you will soon realize that having a sound
    testing strategy is indispensable. In fact, not writing enough tests is almost
    always a bad idea. It is essential to cover all nontrivial functionality of your
    code to make sure of the following points:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Existing code behaves as per the specifications
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any new code does not break the behavior defined by the specifications
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both these points are very important. Many engineers consider only the first
    point as the sole reason to cover your code with enough tests. The most obvious
    advantage of test coverage is to really make sure that the code being pushed to
    production system is mostly error free. Writing test cases to smartly cover maximum
    functional areas of the code, generally gives good indication around the overall
    quality of the code. There should be no arguments or compromises around this point.
    Although, it is unfortunate that many production systems are still bereft of adequate
    code coverage. It is very important to build an engineering culture where developers
    think about writing tests as much as they think about writing code.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: The second point is even more important. Legacy systems are usually very difficult
    to manage. When you are working on code, either written by someone else or written
    by a large distributed team, it is fairly easy to introduce bugs and break things.
    Even the best engineers make mistakes. When you are working on a large code base
    you are unfamiliar with, if there is no sound test coverage to help you, you will
    introduce bugs. As you won't have the confidence in the changes you are making,
    because there are no test cases to confirm your changes, your code releases will
    be shaky, slow, and obviously full of hidden bugs.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: You will refrain from refactoring or optimizing your code, because you won't
    be really sure what changes to the code base would potentially break something
    (again, because there are no test case to confirm your changes); all this is a
    vicious circle. It's like a civil engineer saying-although I have constructed
    this bridge, I have no confidence on the quality of the construction. It may collapse
    immediately or never. Although this may sound like an exaggeration, I have seen
    a lot of high impact production code being pushed with no test coverage. This
    is risky and should be avoided. When you are writing enough test cases to cover
    majority of your functional code, when you make change to those pieces, you will
    immediately realize if there is a problem with this new change. If your changes
    make the test case fail, you will realize the problem. If your refactor breaks
    the test scenario, you will realize the problem; all of this happens much before
    the code is pushed to production.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: In recent years, ideas like test-driven development and self-testing code are
    gaining prominence, especially in agile methodology. These are fundamentally sound
    ideas and will help you write robust code - the code you are confident of. We
    will discuss all these ideas in this chapter. We will understand how to write
    good test cases in modern JavaScript. We will also look at several tools and methods
    to debug your code. JavaScript was traditionally a bit difficult to test and debug,
    primarily due to lack of tools, but modern tools make both of these easy and natural.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we talk about test cases, we mostly mean unit tests. It is incorrect to
    assume that the unit we want to test is always a function. The unit, or unit of
    work, is a logical unit that constitutes single behavior. This unit should be
    able to be invoked via a public interface and should be testable independently.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, a unit test can perform the following functions:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: It tests a single logical function
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can run without a specific order of execution
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It takes care of its own dependencies and mock data
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It always returns the same result for the same input
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It should be self-explanatory, maintainable, and readable
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Martin Fowler advocates the *Test Pyramid* ([http://martinfowler.com/bliki/TestPyramid.html](http://martinfowler.com/bliki/TestPyramid.html))
    strategy to make sure we have a high number of unit tests to ensure maximum code
    coverage. There are two important testing strategies that we will discuss in this
    chapter.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Test Driven Development
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Test driven development** (**TDD**) has gained a lot of prominence in the
    last few years. The concept was first proposed as part of the extreme programming
    methodology. The idea is to have short repetitive development cycles where the
    focus is on writing the test cases first. The cycle looks like the following:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Add a test case as per the specifications for the specific unit of code.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run existing suite of test cases to see if the new test case you wrote fails;
    it should, because there is no code for that unit yet. This step ensures that
    the current test harness works well.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write the code that mainly serves to confirm to the test case. This code is
    not optimized, refactored, or even entirely correct. However, this is fine at
    this moment.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rerun tests and see if all the test cases pass. After this step, you are confident
    that the new code is not breaking anything.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Refactor code to make sure you are optimizing the unit and handling all corner
    cases
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: These steps are repeated for any new code you add. This is an elegant strategy
    that works really well for agile methodology. TDD will be successful only if the
    testable units of code are small and confirms only to the test case.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Behavior Driven Development
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A very common problem while trying to follow TDD is vocabulary and the definition
    of correctness. BDD tries to introduce a ubiquitous language while writing the
    test cases when you are following TDD. This language makes sure that both the
    business and the engineering are talking about the same thing.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: We will use Jasmine as the primary BDD framework and explore various testing
    strategies.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can install Jasmine by downloading the standalone package from [https://github.com/jasmine/jasmine/releases/download/v2.3.4/jasmine-standalone-2.3.4.zip](https://github.com/jasmine/jasmine/releases/download/v2.3.4/jasmine-standalone-2.3.4.zip).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: 'When you unzip this package, you will see the following directory structure:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '![Behavior Driven Development](graphics/image_12_001.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
- en: 'The `lib` directory contains the JavaScript files that you need in your project
    to start writing Jasmine test cases. If you open `SpecRunner.html`, you will find
    the following JavaScript files included in it:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first three are Jasmine's own framework files. The next section includes
    the source files we want to test and the actual test specifications.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s experiment with Jasmine via a very ordinary example. Create a `bigfatjavascriptcode.js`
    file and place it in the `src/` directory. The function we will test is as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This is a simple function that does one single thing. It receives a string and
    returns a capitalized string. We will test various scenarios around this function.
    This is the unit of code, which we discussed earlier.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, create the test specifications. Create one JavaScript file, `test.spec.js`,
    and place it in the `spec/` directory. You will need to add the following two
    lines into your `SpecRunner.html`: The file should contain the following:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The order of this inclusion does not matter. When we run `SpecRunner.html`,
    you will see something like the following image:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '![Behavior Driven Development](graphics/image_12_002.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
- en: 'This is the Jasmine report that shows details about the number of tests that
    were executed and the count of failures and successes. Now, let''s make the test
    case fail. We want to test a case where an `undefined` variable is passed to the
    function. Let''s add one more test case, as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, when you run `SpecRunner`, you will see the following result:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '![Behavior Driven Development](graphics/image_12_003.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, the failure is displayed for this test case in a detailed error
    stack. Now, we will go about fixing this. In your original JS code, handle undefined
    as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'With this change, your test case will pass, and you will see the following
    result in the Jasmine report:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '![Behavior Driven Development](graphics/image_12_004.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
- en: This is very similar to what a test-driven development would look like. You
    write test cases and then fill the necessary code to confirm to the specifications
    and rerun the test suite. Let's understand the structure of the Jasmine tests.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: 'Our test specification looks like the following piece of code:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `describe("TestStringUtilities"` is what a test suite is. The name of the
    test suite should describe the unit-of-code we are testing; this can be a function
    or a group of related functionality. Inside the specs, you will call the global
    Jasmine function,`it`, to which you will pass the title of the spec and the function
    that validates the condition of the testcase This function is the actual test
    case. You can catch one or more assertions or the general expectations using the
    `expect` function. When all expectations are `true`, your spec is passed. You
    can write any valid JavaScript code inside `describe` and `it` functions. The
    values you verify as part of the expectations are matched using a matcher. In
    our example, `toEqual` is the matcher that matches two values for equality. Jasmine
    contains a rich set of matches to suit most of the common use cases. Some common
    matchers supported by Jasmine are as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '`toBe`: This matcher checks if two objects being compared are equal. This is
    same as the `===` comparison. For example, check out the following code snippet:'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`not`: You can negate a matcher with a not prefix. For example, `expect(1).not.toEqual(2);`
    will negate the match made by `toEqual()`.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`toContain`: This checks if an element is part of an array. It is not an exact
    object match as `toBe`. For example, take a look at the following lines of code:'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`toBeDefined` and `toBeUndefined`: These two matches are handy to check whether
    a variable is `undefined` or not.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`toBeNull`: This checks if a variable''s value is `null`.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`toBeGreaterThan` and `toBeLessThan`: These matcher performs numeric comparison
    (works on strings too). For example, consider the following piece of code:'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'An interesting feature of Jasmine is the spies. When you are writing a large
    system, it is not possible to make sure that all systems are always available
    and correct. At the same time, you don''t want your unit tests to fail due to
    a dependency that may be broken or unavailable. To simulate a situation where
    all dependencies are available for a unit of code we want to test, we will mock
    this dependency to always give the response we expect. Mocking is an important
    aspect of testing, and most testing frameworks provide support for mocking. Jasmine
    allows mocking using a feature called a **Spy**. Jasmine spies essentially stubs
    the functions we may not have ready at the time of writing the test case, but
    as part of the functionality, we will need to track that we are executing those
    dependencies and not ignoring them. Consider the following example:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this example, while we are writing this test case, we either don't have the
    real implementation of the dependency, `configurator.submitPOSTRequest()`, or
    someone is fixing this particular dependency; in any case, we don't have it available.
    For our test to work, we will need to mock it. Jasmine spies allow us to replace
    a function with its mock and allows us to track its execution.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we will need to ensure that we called the dependency. When the
    actual dependency is ready, we will revisit this test case to make sure it fits
    the specifications; however, at this time, all we need to ensure that the dependency
    is called. Jasmine function `tohaveBeenCalled()` lets us track the execution of
    a function that may be a mock. We can use `toHaveBeenCalledWith()`, which allows
    us to determine if the stub function was called with correct parameters. There
    are several other interesting scenarios you can create using Jasmine spies. The
    scope of this chapter won't permit us to cover them all, but I would encourage
    you to discover those areas on your own.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: Mocha, Chai and Sinon
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Though Jasmine is the most prominent JavaScript testing framework, mocha and
    chai are gaining prominence in the `Node.js` environment:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: Mocha is the testing framework used to describe and run test cases
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chai is the assertion library supported by Mocha
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sinon comes in handy while creating mocks and stubs for your tests
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We won't discuss these frameworks in this book; however, experience on Jasmine
    will be handy if you want to experiment with these frameworks.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript debugging
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are not a completely new programmer, I am sure you must have spent some
    amount of time debugging your or someone else's code. Debugging is almost like
    an art form. Every language has different methods and challenges around the debugging.
    JavaScript is traditionally a difficult language to debug. I have spent days and
    nights in misery, trying to debug badly written JavaScript code using `alert()`
    functions. Fortunately, modern browsers, such as Mozilla, Firefox, and Google
    Chrome, have excellent **Developer Tools** to help debug JavaScript in the browser.
    There are IDEs like IntelliJ IDEA and WebStorm with great debugging support for
    JavaScript and Node.js. In this chapter, we will focus primarily on Google Chrome's
    built-in developer tool. Firefox also supports Firebug extension and has excellent
    built-in developer tools, but as they behave more or less the same as Google Chrome's
    **Developer Tools**, we will discuss common debugging approaches that work in
    both of these tools.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: Before we talk about the specific debugging techniques, let's understand the
    type of errors we would be interested in while we try to debug our code.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: Syntax errors
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When your code has something that does not confirm to the JavaScript language
    grammar, the interpreter rejects that piece of code. These are easy to catch if
    your IDE is helping you with syntax checking. Most modern IDEs help with these
    errors. Earlier, we discussed the usefulness of tools, such as JSLint and JSHint,
    around catching syntax issues with your code. They analyze the code and flag errors
    in the syntax. The JSHint output can be very illuminating. For example, the following
    output shows up so many things we can change in the code. The following code snippet
    is from one of my existing projects:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Using strict
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We briefly discussed the strict mode in earlier chapters. When you enable strict
    mode, JavaScript stops being accepting of syntactical errors in your code. Rather
    than silently failing, strict mode makes these failure throw errors instead. It
    also helps you convert mistakes into actual errors. There are two ways of enforcing
    strict mode. If you want the strict mode for the entire script, you can just add
    the `use strict` statement (with the quotes) as the first line of your JavaScript
    program. If you want a specific function to confirm to strict mode, you can add
    the directive as the first line of a function. For example, take a look at the
    following code snippet:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Runtime exceptions
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'These errors appear when you execute the code, try to refer to an `undefined`
    variable, or try to process a `null`. When a runtime exception occurs, any code
    after that particular line, which caused the exception, does not get executed.
    It is essential to correctly handle such exceptional scenarios in the code. While
    exception handling can help prevent crashes, they also aid in debugging. You can
    wrap the code that may encounter a runtime exception into a `try{ }` block. When
    any code inside this block generates a runtime exception, a corresponding handler
    captures it. The handler is defined by a `catch(exception){}` block. Let''s clarify
    this using the following example:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In this example, the `var a = doesnotexist` line tries to assign an `undefined`
    variable, `doesnotexist`, to another variable `a`. This causes a runtime exception.
    When we wrap this problematic code into `try{}catch(){}` block or when the exception
    occurs (or is thrown), the execution stops in the `try{}` block and goes directly
    to the `catch() {}` handler. The catch handler is responsible for handling the
    exceptional scenario. In this case, we are displaying the error message on the
    console for debugging purposes. You can explicitly throw an exception to trigger
    an unhandled scenario in the code. Consider the following example:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In this example, we are handling valid states of a gear shift: `R`, `N`, and
    `D`; however, when we receive an invalid state, we are explicitly throwing an
    exception clearly stating the reason. When we call the function which we think
    may throw an exception, we will wrap the code in the `try{}` block and attach
    a `catch(){}` handler with it. When the exception is caught by the `catch()` block,
    we will handle the exceptional condition appropriately.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: Console.log and asserts
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Displaying the state of execution on console can be very useful while debugging.
    Although, modern developer tools allow you to put breakpoints and halt execution
    to inspect a particular value during runtime. You can quickly detect small issues
    by logging some variable state on the console.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: With these concepts with us, let's see how we can use Chrome **Developer Tools**
    to debug JavaScript code.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: Chrome Developer Tools
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can start Chrome **Developer Tools** by clicking **menu** | **More tools**
    | **Developer Tools**. Take a look at the following screenshot:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '![Chrome Developer Tools](graphics/image_12_005.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
- en: 'Chrome developer tool opens up on the lower pane of your browser and has a
    bunch of very useful sections. Consider the following screenshot:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '![Chrome Developer Tools](graphics/image_12_006.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
- en: The **Elements** panel helps you inspect and monitor the DOM tree and associated
    style sheet for each of these components.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: The **Network** panel is useful to understand network activity. For example,
    you can monitor the resources being downloaded over the network in real time.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: 'The most important pane for us is the **Sources** pane. This pane is where
    the JavaScript and the debugger are displayed. Let''s create a sample HTML with
    the following content:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Save this HTML file and open it in Google Chrome. Open **Developer Tools**
    in the browser, and you will see the following screen:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '![Chrome Developer Tools](graphics/image_12_007.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
- en: This is the view of the **Sources** panel. You can see the HTML and embedded
    JavaScript source in this panel. You can see the **Console** window as well, and
    you can see that the file is executed and the output is displayed on console.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: 'On the right side, you will see the debugger window, as shown in the following
    screenshot:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '![Chrome Developer Tools](graphics/image_12_008.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
- en: 'In the **Sources** panel, click on the line numbers **8** and **15** to add
    a breakpoint. The breakpoints allow you to stop execution of the script at the
    specified point. Consider the following screenshot:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '![Chrome Developer Tools](graphics/5239_12.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
- en: 'In the debug pane, you can see all existing breakpoints. Take a look at the
    following screenshot:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '![Chrome Developer Tools](graphics/image_12_010.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![Chrome开发者工具](graphics/image_12_010.jpg)'
- en: 'Now, when you rerun the same page, you will see that the execution stops at
    the debug point. Consider the following screenshot:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当您重新运行同一个页面时，您会看到执行停在调试点。请看下面的截图：
- en: '![Chrome Developer Tools](graphics/image_12_011.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![Chrome开发者工具](graphics/image_12_011.jpg)'
- en: 'This window now has all the action. You can see that the execution is paused
    on line **15**. In the debug window, you can see which breakpoint is being triggered.
    You can also see the **Call Stack** and resume execution in several ways. The
    debug command window has a bunch of actions. Take a look at the following screenshot:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这个窗口现在有了所有的操作。您可以看到执行已经暂停在第15行。在调试窗口中，您可以看到触发了哪个断点。您还可以看到**调用堆栈**并以多种方式恢复执行。调试命令窗口有很多操作。看一下下面的截图：
- en: '![Chrome Developer Tools](graphics/image_12_012.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![Chrome开发者工具](graphics/image_12_012.jpg)'
- en: 'You can resume execution, which will execute until the next breakpoint, by
    clicking on the following button:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过点击以下按钮恢复执行，直到下一个断点：
- en: '![Chrome Developer Tools](graphics/image_12_013.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![Chrome开发者工具](graphics/image_12_013.jpg)'
- en: 'When you do that, the execution continues until the next breakpoint is encountered.
    In our case, we will halt at line **8**. Consider the following screenshot:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当您这样做时，执行会继续，直到遇到下一个断点。在我们的情况下，我们将在第8行停下来。请看下面的截图：
- en: '![Chrome Developer Tools](graphics/image_12_014.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![Chrome开发者工具](graphics/image_12_014.jpg)'
- en: You can observe that the **Call Stack** window shows how we arrived at line
    **8**. The **Scope** panel shows the **Local** scope where you can see the variables
    in the scope when the breakpoint was arrived at. You can also Step-Into or Step-over
    the next function.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以观察到**调用堆栈**窗口显示了我们是如何到达第8行的。**作用域**面板显示了**局部**作用域，在断点到达时您可以看到作用域中的变量。您还可以步进或跳过下一个函数。
- en: There are other very useful mechanisms to debug and profile your code using
    Chrome **Developer Tools**. I would suggest you to experiment with the tool and
    make it a part of your regular development flow.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Chrome开发者工具还有其他非常有用的机制来调试和分析您的代码。我建议您尝试使用这个工具，并将其作为您常规开发流程的一部分。
- en: Summary
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Both testing and debugging phases are essential to developing robust JavaScript
    code. TDD and BDD are approaches closely associated with the agile methodology
    and is widely embraced by the JavaScript developer community. In this chapter,
    we reviewed best practices around TDD and the usage of Jasmine as the testing
    framework. Additionally, we saw various methods of debugging JavaScript using
    Chrome **Developer Tools**.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 测试和调试阶段对于开发健壮的JavaScript代码至关重要。TDD和BDD是与敏捷方法学密切相关的方法，被JavaScript开发者社区广泛接受。在本章中，我们回顾了围绕TDD的最佳实践以及Jasmine作为测试框架的使用。此外，我们还看到了使用Chrome开发者工具调试JavaScript的各种方法。
- en: In the next chapter, we will explore the new and exciting world of ES6, DOM
    Manipulation and cross-browser strategies.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探索ES6、DOM操作和跨浏览器策略的新颖世界。
