- en: Chapter 2. Understanding the Networking Concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we start coding a network application, it is better for us to understand
    how a network works. In this chapter, we will dig up network concepts with their
    contents. The topics that we''ll cover in this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Distinguishing between the OSI model and the TCP/IP model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring IP addresses in both IPv4 and IPv6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Troubleshooting TCP/IP problems using various tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An introduction to networking systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Network architecture is structured with layers and protocols. Each **layer**
    in the architecture has its own role, while its main purpose is to offer a certain
    service to the higher layer and communicate with the adjoining layers. However,
    a **protocol** is a collection of rules and conventions that are used by all the
    communicating parties to standardize the communication process. For instance,
    when the layer *n* in a device communicates with another layer *n* in another
    device, for the communication to take place, they have to use the same protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two popular network architectures that are used nowadays: the **Open
    Systems Interconnection** (**OSI**) and **TCP/IP** reference models. We will dig
    deeper to understand each reference model with its advantages and disadvantages
    so that we can decide which model should be used in our network application.'
  prefs: []
  type: TYPE_NORMAL
- en: The OSI reference model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The OSI model is used to connect to the open systems—these are the systems that
    are open and communicate with other systems. By using this model, we do not depend
    on an operating system anymore, so we are allowed to communicate with any operating
    system on any computer. This model contains seven layers, where each layer has
    a specific function and defines the way data is handled on certain different layers.
    The seven layers that are contained in this model are the **Physical layer**,
    **Data Link layer**, **Network layer**, **Transport layer**, **Session layer**,
    **Presentation layer**, and the **Application layer**.
  prefs: []
  type: TYPE_NORMAL
- en: The Physical layer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is the first layer in the OSI model and contains a definition of the network's
    physical specification, including the physical media (cables and connectors) and
    basic devices (repeaters and hubs). The layer is responsible for the input raw
    bits transmission data stream into zeros and for the ones that are on the communication
    channel. It then places the data onto the physical media. It is concerned with
    data transmission integrity and makes sure that the bits that are sent from one
    device are exactly the same as the data that is received by the other device.
  prefs: []
  type: TYPE_NORMAL
- en: The Data Link layer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The main role of the Data Link layer is to provide a link for raw data transmission.
    Before the data is transmitted, it is broken up into data frames, and the Data
    Link layer transmits them consecutively. The receiver will send back an *acknowledge
    frame* for each frame that has been sent if the service is reliable.
  prefs: []
  type: TYPE_NORMAL
- en: 'This layer consists of two sublayers: **Logical Link Control** (**LLC**) and
    **Media Access Control** (**MAC**). The LLC sublayer is responsible for transmission
    error checking and deals with frame transmission, while the MAC sublayer defines
    how to retrieve data from the physical media or store data in the physical media.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also find the MAC address, also called as the **physical address**,
    in this layer. The MAC address is used to identify every device that connects
    to the network because it is unique for each device. Using Command Prompt, we
    can obtain the address by typing the following command in the console window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We will get the console output, as follows, after ignoring all other information
    except **Windows IP Configuration** and **Wireless LAN adapter Wi-Fi**. We can
    find the MAC address in the **Physical Address** section, which is **80-19-34-CB-BF-FB**
    for my own environment. You will get a different result since the MAC address
    is unique for every device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The MAC address contains twelve hexadecimal characters, where two digits are
    paired with each other. The first six digits represent the **organizationally
    unique identifier** and the remaining digits represent the **manufacturer serial
    number**. If you are really curious to know what this number means, you can go
    to [www.macvendorlookup.com](http://www.macvendorlookup.com) and fill the text
    box with our MAC address to know more about it. In my own system, I got Intel
    Corporate as the vendor company name, which is the same as the brand of my installed
    network card.
  prefs: []
  type: TYPE_NORMAL
- en: The Network layer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Network layer is responsible for defining the best way to route the packets
    from a source to the destination device. It will generate routing tables using
    **Internet Protocol** (**IP**) as the routing protocol, and the IP address is
    used to make sure that the data gets its route to the required destination. There
    are two versions of IP nowadays: **IPv4** and **IPv6**. In IPv4, we use 32-bit
    addresses to address the protocol and we use 128-bit addresses in IPv6\. You are
    going to learn more about Internet Protocol, IPv4, and IPv6 in the next topic.'
  prefs: []
  type: TYPE_NORMAL
- en: The Transport layer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Transport layer is responsible for transferring data from a source to destination.
    It will split up the data into smaller parts, or in this case **segments**, and
    then will join all the segments to restore the data to its initial form in the
    destination.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two main protocols that work in this layer: the **Transmission Control
    Protocol** (**TCP**) and the **User Datagram Protocol** (**UDP**). TCP supplies
    the delivery of data by establishing a session. The data will not be transmitted
    until a session is established. TCP is also known as the **connection-oriented
    protocol**, which means that the session has to be established before transmitting
    the data. UDP is a method of delivering data with the best efforts, but does not
    give a guaranteed delivery because it does not establish a session. Therefore,
    UDP is also known as the **connection-less protocol**. In-depth explanation about
    TCP and UDP can be found in the next topic.'
  prefs: []
  type: TYPE_NORMAL
- en: The Session layer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Session layer is responsible for the establishment, maintenance, and termination
    of the session. We can analogize the session like a connection between two devices
    on the network. For example, if we want to send a file from a computer to another,
    this layer will establish the connection first before the file can be sent. This
    layer will then make sure that the connection is still up until the file is sent
    completely. Finally, this layer will terminate the connection if it is no longer
    needed. The connection we talk about is the session.
  prefs: []
  type: TYPE_NORMAL
- en: This layer also makes sure that the data from a different application is not
    interchanged. For example, if we run the Internet browser, chat application, and
    download manager at the same time, this layer will be responsible for establishing
    the session for every single application and ensure that they remain separated
    from other applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three communication methods that are used by this layer: the **simplex**,
    **half-duplex**, or **full-duplex** method. In the simplex method, data can only
    be transferred by one party, so the other cannot transfer any data. This method
    is no longer common in use, since we need applications that can interact with
    each other. In the half-duplex method, any data can be transferred to all the
    involved devices, but only one device can transfer the data in the time, after
    it completes the sending process. Then, the others can also send and transfer
    data. The full-duplex method can transfer data to all the devices at the same
    time. To send and receive data, this method uses different paths.'
  prefs: []
  type: TYPE_NORMAL
- en: The Presentation layer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Presentation layer role is used to determine the data that has been sent,
    to translate the data into the appropriate format, and then to present it. For
    example, we send an MP3 file over the network and the file is split up into several
    segments. Then, using the header information on the segment, this layer will construct
    the file by translating the segments.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, this layer is responsible for data compression and decompression because
    all the data transmitted over the Internet is compressed to save the bandwidth.
    This layer is also responsible for data encryption and decryption in order to
    secure communication between two devices.
  prefs: []
  type: TYPE_NORMAL
- en: The Application layer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Application layer deals with the computer application that is used by a
    user. Only the application that connects to a network will connect to this layer.
    This layer contains several protocols that are needed by a user, which are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The Domain Name System** (**DNS**): This protocol is the one that finds the
    hostname of an IP address. With this system, we do not need to memorize every
    IP address any longer, just the hostname. We can easily remember a word in the
    hostname instead of a bunch of numbers in the IP address.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The Hypertext Transfer Protocol** (**HTTP**): This protocol is the one that
    transmits data over the Internet on web pages. We also have the HTTPS format that
    is used to send encrypted data for security issues.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The File Transfer Protocol** (**FTP**): This protocol is the one that is
    used to transfer files from or to an FTP server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The Trivial FTP** (**TFTP**): This protocol is similar to FTP, which is used
    to send smaller files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The Dynamic Host Configuration Protocol** (**DHCP**): This protocol is a
    method that is used to assign the TCP/IP configuration dynamically.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The Post Office Protocol** (**POP3**): This protocol is an electronic mail
    protocol used to get back e-mails from POP3 servers. The server is usually hosted
    by an **Internet Service Provider** (**ISP**).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The Simple Mail Transfer Protocol** (**SMTP**): This protocol is in contrast
    with POP3 and is used to send electronic mails.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The Internet Message Access Protocol** (**IMAP**): This protocol is used
    to receive e-mail messages. With this protocol, users can save their e-mail messages
    on their folder on a local computer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The Simple Network Management Protocol** (**SNMP**): This protocol is used
    to manage network devices (routers and switches) and detect problems to report
    them before they become significant.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The Server Message Block** (**SMB**): This protocol is an FTP that is used
    on Microsoft networks primarily for file and printer sharing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This layer also decides whether enough network resources are available for network
    access. For instance, if you want to surf the Internet using an Internet browser,
    the Application layer decides whether access to the Internet is available using
    HTTP.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see the following figure to see which all protocols are included in
    the OSI layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Application layer](img/00011.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can divide all the seven layers into two section layers: the **Upper Layer**
    and **Lower Layer**. The upper layer is responsible for interacting with the user
    and is less concerned about the low-level details, whereas the lower layer is
    responsible for transferring data over the network, such as formatting and encoding.'
  prefs: []
  type: TYPE_NORMAL
- en: The format of data traveling is different for each layer. There are bits for
    the Physical layer, frame for the Data Link layer, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The TCP/IP reference model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The TCP/IP model was created before the OSI model. This model works in a similar
    way to the OSI model, except that it just contains four layers. Each layer on
    the TCP/IP model corresponds to the layers of the OSI model. The TCP/IP Application
    layer maps the 5, 6, and 7 layers of the OSI model. The TCP/IP Transport layer
    maps the layer 4 of the OSI model. The TCP/IP Internet layer maps the layer 3
    of the OSI model. The TCP/IP Link layer maps the layers 1 and 2 of the OSI model.
    Let''s see the following figure for further details:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The TCP/IP reference model](img/00012.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'These are the main roles of each layer in the TCP/IP model:'
  prefs: []
  type: TYPE_NORMAL
- en: The Link layer is responsible for determining the protocols and physical devices
    that are used in the data transmission process.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Internet layer is responsible for determining the best routing for the data
    transmission process by addressing the packet.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Transport layer is responsible for establishing the communication between
    the two devices and sending the packet.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Application layer is responsible for providing services to applications
    that run on a computer. Because of the absence of the session and presentation
    layers, applications have to be included in any required session and presentation
    functions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are the protocols and devices that are involved in the TCP/IP model:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Layer | Protocol | Device |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Application | HTTP, HTTPS, SMTP, POP3, and DNS | Proxy Server and Firewall
    |'
  prefs: []
  type: TYPE_TB
- en: '| Transport | TCP and UDP | - |'
  prefs: []
  type: TYPE_TB
- en: '| Internet | IP and ICMP | Router |'
  prefs: []
  type: TYPE_TB
- en: '| Link | Ethernet, Token Ring, and Frame Relay | Hub, Modem, and Repeater |'
  prefs: []
  type: TYPE_TB
- en: Understanding TCP and UDP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we discussed earlier in this chapter in the *Transport layer* section, TCP
    and UDP are the main protocols that are used to transfer data across a network.
    The delivery mechanisms that they have are different from each other. TCP has
    acknowledgments, sequence numbers, and flow control in transferring data process
    to provide a guaranteed delivery, whereas UDP does not provide a guaranteed delivery
    but provides a delivery with best efforts.
  prefs: []
  type: TYPE_NORMAL
- en: Transmission Control Protocol
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'TCP performs a three-way handshaking process before the protocol establishes
    the session. This is done in order to provide a guaranteed delivery. Refer to
    the following figure to understand the three-way handshaking process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Transmission Control Protocol](img/00013.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: From the preceding image, imagine that Carol's device wants to transfer data
    to Bryan's device and that they need to perform a three-way handshaking process.
    First, Carol's device sends a packet to Bryan's device with the **synchronize**
    (**SYN**) flag enabled. Once Bryan's device receives the packet, it replies with
    sending another packet that has both the SYN and **acknowledge** (**ACK**) flags
    enabled. Lastly, Carol's device completes the handshaking process by sending a
    third packet with the ACK flag enabled. Now, both devices have an established
    session and an assurance that the other device is working. The data transmission
    is then ready to take place after the session is established.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the security area, we know the term "SYN-Flood", which is a denial-of-service
    attack, where an attacker sends a succession of SYN requests to a target's system
    in an attempt to consume enough server resources to make the system unresponsive
    to legitimate traffic. The attacker just sends SYN without sending the expected
    ACK, causing the server to send the SYN-ACK to a falsified IP address—which will
    not send an ACK because it "knows" that it never sent the SYN.
  prefs: []
  type: TYPE_NORMAL
- en: TCP also splits up the data into smaller segments and uses sequence numbers
    to track these segments. Each separated segment is assigned different sequence
    numbers, such as 1 to 20\. The destination device then receives each segment and
    uses the sequence numbers to reassemble the file based on the order of the sequence.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, consider that Carol wants to download a JPEG image file from Bryan's
    device. After establishing the session in a three-way handshaking process, the
    two devices determine how big the single segment is and how many segments need
    to be sent between acknowledgments. The total number of segments that can be sent
    at a time is known as the TCP **sliding window**. The data in the segment is not
    valid anymore if a single bit is broken or lost in transmission. TCP uses **Cyclical
    Redundancy** **Check** (**CRC**) to identify the broken or lost data by verifying
    that the data is intact in each segment. If there is any corrupt or missing segment
    in transmission, Carol's device will send a **negative acknowledge** (**NACK**)
    packet and then will request the corrupt or missing segment; otherwise, Carol's
    device will send an ACK packet and request the next segment.
  prefs: []
  type: TYPE_NORMAL
- en: User Datagram Protocol
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: UDP does not perform any handshaking process before sending data. It just sends
    the data directly to the destination device; however, it puts in its best effort
    to forward the messages. Imagine that we are waiting to receive a message from
    our friend. We call his/her phone to receive our message. If our call is not answered,
    we can send the e-mail or text message to inform our friend. If our friend does
    not reply to our e-mail or text messages, we can send regular e-mails. However,
    all techniques that we talked about do not give any assurance that our message
    was received. But still, we make our best efforts to forward the message until
    this works. This our best effort in analogy of sending e-mails is similar with
    best-effort term for UDP. It will give its best effort to ensure that the data
    is received by the receiver, even though there is no assurance that the data was
    received.
  prefs: []
  type: TYPE_NORMAL
- en: So, why is UDP used even though it is not reliable? Sometimes we need a communication
    which has fast speed data transfer even though has a little bit data corruption.
    For instance, streaming audio, streaming video, and **Voice over IP** (**VoIP**)
    use UDP to make sure that they have fast speed data transfer. Although the UDP
    must have had lost packets, we are still able to get all the messages clearly.
  prefs: []
  type: TYPE_NORMAL
- en: However, although UDP does not check the connection before transmitting data,
    it actually uses a checksum to validate the data. The checksum can check whether
    the received data is altered or not by comparing the checksum value.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding ports
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In computer networking, a **port** is an endpoint to send or receive data. A
    port is recognized by its **port number**, which contains a 16-bit number. The
    logical port number is used by both TCP and UDP to trace the contents of a packet
    and helps TCP/IP obtain the packet of the application or service that will process
    the data when it is received by the device.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a total of `65536` TCP ports and `65536` UDP ports. We can divide
    the TCP ports into three port ranges, which are:'
  prefs: []
  type: TYPE_NORMAL
- en: Well-known ports from `0` to `1023` are ports that have been registered by the
    **Internet** **Assigned Numbers Authority** (**IANA**) to associate with specific
    protocols or applications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Registered ports from `1024` to `49151` are ports that have been registered
    by IANA for a specific protocol, but unused ports in this range can be assigned
    by computer applications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamic ports from `49152` to `65535` are unregistered ports and can be assigned
    for any purpose.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To get more details about all the ports in TCP and UDP, we can go to [en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers](http://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers).
    Also, to know about all the assigned ports that have been registered by IANA,
    go to [www.iana.org/assignments/port-numbers](http://www.iana.org/assignments/port-numbers).
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand the port concept, consider that we have an e-mail client installed
    in our computer, such as Thunderbird or Microsoft Outlook. Now, we want to send
    an e-mail to the Gmail server and then grab all the incoming e-mails from the
    server to save them on our local computer. The steps to send an e-mail are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Our computer assigns a random unused port number, such as `48127`, to send the
    e-mail to the Gmail SMTP server to the port `25`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the e-mail arrives at the SMTP server, it recognizes that the data has
    come from the port `25` and then forwards the data to the SMTP, which handles
    the service.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the e-mail is received, the server sends the acknowledgement to the port
    `48127` in our computer to inform the computer that the e-mail has been received.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After our computer completely receives the acknowledgement from the port `48127`,
    it sends an e-mail to the e-mail client, and the e-mail client then moves the
    e-mail from Outbox to the Sent folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Similar to the steps for sending an e-mail, to receive an e-mail, we have to
    deal with a port. The steps for which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Our computer assigns a random unused port number, such as `48128`, to send a
    request to the Gmail POP3 server to the port `110`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the e-mail arrives at the POP3 server, it recognizes that the data has
    come from the port `110` and then forwards the data to POP3, which handles the
    service.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The POP3 server then sends an e-mail to our computer on the port `48128`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After our computer receives the e-mail from the port `48128`, it sends the e-mail
    to our e-mail client and then moves it to the Inbox folder. It also automatically
    saves the mail to the local computer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Exploring the Internet Protocol
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: IP is a primary communication protocol that is used to deliver a datagram across
    networks. The datagram itself is a transfer unit associated with a packet-switched
    network. The role of IP is to deliver packets from the host to the host based
    on the IP address, which is stated in the packet's header. There are two versions
    of IP that are commonly used nowadays, which are IPv4 and IPv6.
  prefs: []
  type: TYPE_NORMAL
- en: Internet Protocol Version 4 – IPv4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: IPv4 has become the standard IP address since 1980s and is used to obtain TCP/IP
    traffic from a computer to another over the network. An IP address is unique for
    every device connected over the Internet, and all devices can communicate with
    each other over the Internet as long as they have a valid IP address.
  prefs: []
  type: TYPE_NORMAL
- en: A valid IP address is constructed by four decimal numbers that are separated
    by three dots. The address only contains a decimal number from `0` to `255`. We
    can say that `10.161.4.25` is a valid IP address since it contains four decimal
    numbers between `0` to `255` and is separated by three dots, while `192.2.256.4`
    is an invalid IP address because it contains decimal numbers greater than `255`.
  prefs: []
  type: TYPE_NORMAL
- en: The decimal numbers actually convert the result from 8 binary digits. So, for
    the maximum 8-bit number, we will have 1111 1111 or 255 in decimal. This is why
    the range of a decimal number in an IP address is from 0 (0000 0000) to 255 (1111
    1111).
  prefs: []
  type: TYPE_NORMAL
- en: 'To know our IP address configuration, we can use the `ipconfig /all` command
    again in our Command Prompt window. Then, it will display the output as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The output will show the IP address in the IPv4 address and the IPv6 address.
    We can also see that in my device, `10.1.6.1` is used as a default gateway of
    the system. The `Default Gateway` parameter is a point on the computer network
    that is used to provide a path for the unmatched IP address or subnets.
  prefs: []
  type: TYPE_NORMAL
- en: 'An IP address must contain these two components: a **network ID** to identify
    the subnetwork or subnet where the computer is located and a **host ID** to identify
    the computer within that subnet. Every network ID indicates a group of hosts on
    a subnet of a network. Devices that have the same network IDs must have unique
    host IDs. If two or more devices have the same host ID and the same network ID
    (the IP address is the same for all four decimal numbers), there will be an IP
    address conflict.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For local networks, the **subnet mask** is used to identify the portion of
    a network ID and a host ID in the IP address. The following are a few common subnet
    masks:'
  prefs: []
  type: TYPE_NORMAL
- en: '`255.0.0.0`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`255.255.0.0`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`255.255.255.0`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Imagine that we have the IP address `190.23.4.51` and the subnet mask `255.255.0.0`.
    Now, we can find the network ID using the Boolean `AND` logic for each bit of
    the IP address corresponding to the subnet mask. The following table will convert
    the IP address and subnet mask into a binary digit and then use the Boolean `AND`
    logic to find out the network ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '|   | 1st Octet | 2nd Octet | 3rd Octet | 4th Octet |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 190.23.4.51 | 1011 1110 | 0001 0111 | 0000 0100 | 0011 0011 |'
  prefs: []
  type: TYPE_TB
- en: '| 255.255.0.0 | 1111 1111 | 1111 1111 | 0000 0000 | 0000 0000 |'
  prefs: []
  type: TYPE_TB
- en: '| **Network ID:** | 1011 1110 | 0001 0111 | 0000 0000 | 0000 0000 |'
  prefs: []
  type: TYPE_TB
- en: From the preceding table, we can obtain the network ID, which is `190.23.0.0`.
  prefs: []
  type: TYPE_NORMAL
- en: The adjacent maximum number has to be applied in a subnet mask. This means that
    if the first zero is decided to be used, the remaining numbers have to be zero.
    So, a subnet mask of `255.0.255.0` is invalid. A subnet mask is also not allowed
    to begin with zero. This means that a subnet mask of `0.255.0.0` is invalid as
    well.
  prefs: []
  type: TYPE_NORMAL
- en: 'IPv4 can be classified into three primary address classes: Class A, Class B,
    and Class C. The class of the address is defined by the first number in the IP
    address and the subnet mask is predefined for each class. Here are the three ranges
    for each class:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Class | The first number | Range of the IP address | Subnet mask |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Class A | 1 to 126 | 1.0.0.0 to 126.255.255.254 | 255.0.0.0 |'
  prefs: []
  type: TYPE_TB
- en: '| Class B | 128 to 191 | 128.0.0.0 to 191.255.255.254 | 255.255.0.0 |'
  prefs: []
  type: TYPE_TB
- en: '| Class C | 192 to 223 | 192.0.0.0 to 223.255.255.254 | 255.255.255.0 |'
  prefs: []
  type: TYPE_TB
- en: 'Our computer is able to determine the class of the IP address by just looking
    at the first two bits after converting the first decimal number in the IP address.
    For instance, in Class A with the range 1 to 126, the binary digit is between
    0000 0001 to 0111 1110\. The first two bits might be 0 and 0 or 0 and 1\. Class
    B with the range from 128 to 191 has the range in binary digits from 1000 0000
    to 1011 1111\. This means that the highest first bit is always 1 and the second
    is always 0\. Class C with the range from 192 to 223 has the range in binary digits
    from 1100 0000 to 1101 1111\. The bits will be all 1 for the first two bits. Refer
    to the following table to conclude how a computer determines the class of an IP
    address by just checking the first two bits of the IP address (here, X is ignored
    and can be any hexadecimal character):'
  prefs: []
  type: TYPE_NORMAL
- en: '| Class | First number in binary digits |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Class A | 00XXXXXX01XXXXXX |'
  prefs: []
  type: TYPE_TB
- en: '| Class B | 10XXXXXX |'
  prefs: []
  type: TYPE_TB
- en: '| Class C | 11XXXXXX |'
  prefs: []
  type: TYPE_TB
- en: 'By classifying the IP address, we can also determine the subnet mask by just
    looking at the IP address because each class has a different subnet mask, shown
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Class | Range | Subnet Mask |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Class A addresses | 0 -126 | 255.0.0.0 |'
  prefs: []
  type: TYPE_TB
- en: '| Class B addresses | 128 to 191 | 255.255.0.0 |'
  prefs: []
  type: TYPE_TB
- en: '| Class C addresses | 192 to 223 | 255.255.255.0 |'
  prefs: []
  type: TYPE_TB
- en: 'By knowing the subnet mask, we can easily know the network ID. Suppose that
    we have these three IP addresses:'
  prefs: []
  type: TYPE_NORMAL
- en: '`174.12.1.8`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`192.168.1.15`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`10.70.4.13`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, we can determine the network ID as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| The IP address | Class | Subnet mask | The Network ID |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 174.12.1.8 | Class B | 255.255.0.0 | 174.12.0.0 |'
  prefs: []
  type: TYPE_TB
- en: '| 192.168.1.15 | Class C | 255.255.255.0 | 192.168.1.0 |'
  prefs: []
  type: TYPE_TB
- en: '| 10.70.4.13 | Class A | 255.0.0.0 | 10.0.0.0 |'
  prefs: []
  type: TYPE_TB
- en: 'A subnet mask is also able to reference with an indicator known as **Classless
    Inter-Domain Routing** (**CIDR**), which is defined based on the number of bits.
    For instance, the subnet mask `255.0.0.0` uses 8 bits (a bit with the value of
    `0` is considered as unused bits), so it is referenced as /8\. Similarly, the
    subnet mask 255.255.0.0 uses 16 bits and can be referenced as /16, and the subnet
    mask 255.255.255.0 uses 24 bits and can be referenced as /24\. These are the CIDR
    notations for our previous IP address sample:'
  prefs: []
  type: TYPE_NORMAL
- en: '| IP address | Subnet mask | CIDR notation |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 174.12.1.8 | 255.255.0.0 | 174.12.1.8 /16 |'
  prefs: []
  type: TYPE_TB
- en: '| 192.168.1.15 | 255.255.255.0 | 192.168.1.15 /24 |'
  prefs: []
  type: TYPE_TB
- en: '| 10.70.4.13 | 255.0.0.0 | 10.70.4.13 /8 |'
  prefs: []
  type: TYPE_TB
- en: Internet Protocol Version 6 – IPv6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: IPv6 contains 128 bits and is launched to improve IPv4, which only consists
    32 bits. With 32 bits in IPv4, it can address 4,294,967,296 addresses. The number
    was very high at the beginning, but now it has become insufficient because there
    are many devices that need an IP address. IPv6 is created to solve the problem
    because it can address more than 340,000,000,000,000,000,000,000,000,000,000,000,000,
    or about *3.4028e+38*, which is more than enough—at least for now.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: IPv5 had been developed so that it consisted of 64 bits, but it was never adopted
    because it was believed that the Internet would run out of IP addresses quickly
    if it was used.
  prefs: []
  type: TYPE_NORMAL
- en: The prominent difference between the IPv4 address and IPv6 address is that instead
    of displaying the IP address in decimal numbers, IPv6 expresses the address in
    hexadecimal characters. We can determine whether it is IPv4 or IPv6 at first sight
    by just looking at this format number. We can call the `ipconfig /all` command
    to know our IPv6 address and see it in the Ethernet Adapter Network. I have `fe80::f14e:d5e6:aa0a:5855%3`,
    but yours must be different. The address itself is `fe80::f14e:d5e6:aa0a:5855`,
    and the last `%3` variable is a zone index that is used to identify the network
    interface card. The number `fe80` in the first IPv6 address is stated as a link-local
    address, which is an IP address that is automatically assigned on the network
    because it is not automatically configured by DHCP or has not been manually configured
    yet.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we know, IPv6 is actually a set of 128 bits and converts its bits into a
    hexadecimal character in order to simplify its notation. Consider that we have
    a set of binary digits that form IPv6, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of memorizing all these digits, it is easier if we convert it into
    the IPv6 address format. First, we convert each four digits group into a hexadecimal
    character and we will get these hexadecimal characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Second, we separate each set of four characters with a colon, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Third, we can throw out the leading zero in each four digit collection, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Fourth, we collapse the consecutive zero groups into an empty group, shown
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now it is easier for us to memorize this IPv6 address.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An empty group, which is indicated by two colons (`::`), means inserting as
    many as zeros as needed to form this address into 128 bits. IPv6 address is not
    allowed to have more than one empty group since it will be confusing for us to
    determine how many zeros there are in each empty group.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, with IPv4, which classifies the IP address by looking at the first
    number (the first two bit actually), the type of IPv6 can also be identified by
    looking at its **prefix**. This is how we write all the addresses that have a
    network ID `2001:04fe` that begins with a 32-bit prefix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This means that the first 32 bits of all addresses are 0010 0000 0000 0001 000
    0100 1111 1110\. However, to ease the reading of this address, we use a hexadecimal
    character instead.
  prefs: []
  type: TYPE_NORMAL
- en: Using TCP/IP tools for troubleshooting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some of the following commands can be used to track any TCP/IP errors. The commands
    can be used to examine whether or not any router is down or any connection is
    established. It will then help us a lot to decide on the proper solution.
  prefs: []
  type: TYPE_NORMAL
- en: The ipconfig command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We used the `ipconfig` command earlier to identify the MAC address and the IP
    address. In addition to this, we can use this command to check the TCP/IP configuration.
    We can also use this command as explained in the upcoming sections.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying the full configuration information
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To display the configuration information completely, we can call the following
    command on the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: All the configuration information about the network adapter will be displayed
    for us, such as the network interface card, wireless card, and Ethernet adapter,
    like we have already tried in *The Data Link layer* section in this chapter when
    we looked for MAC Address.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying DNS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following command will display the content of the DNS Resolver Cache using
    the following option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'By calling the preceding command, we will be provided with the information
    about DNS in our local system, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The meaning of each field in the output of displaying DNS is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Record Name**: This is the name of the DNS that is to be associated with
    the IP address.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Record Type**: This is the type of the record and is represented as a number.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Time To Live**: This is the cache expired time in seconds.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data Length**: This is the size of the memory to store the text of a record
    value in byte.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Section**: If the value is `Answer`, this means that it replies the actual
    query, but if the value is `Additional`, this means that it contains information
    that will be needed to find the actual answer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A (Host) Record**: This is the place where the actual value is stored.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flushing DNS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following command is used to remove the resolved DNS server item but not
    the item in a cache. Type the following command in the command prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Once it successfully flushes the DNS Resolver Cache, we will be showed this
    message in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: If we call the `ipconfig /displaydns` command again, the resolved DNS server
    has been removed and remaining are the item in the cache.
  prefs: []
  type: TYPE_NORMAL
- en: Renewing the IP address
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are two commands that can be used to renew an IP address, which are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command will renew the lease process of IPv4 from a DHCP server,
    while the following command will renew the lease process of IPv6:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Releasing the IP address
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Use the following two commands to release the lease process of IPv4 and IPv6
    respectively, which is obtained from the DHCP server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: These commands only affect the DHCP-assigned (automatically assigned) IP address.
  prefs: []
  type: TYPE_NORMAL
- en: The ping command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `ping` command is used to examine the connectivity with other computers.
    It uses **Internet Control Message Protocol** (**ICMP**) to send a message to
    target computers. We can use the IP address and hostname to ping the target. Suppose
    we have a device whose hostname is `HOST1`, to ping itself, we can use the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we will get the following output in our console window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'If we get the IPv6 address and we want to display it in the IPv4 address instead,
    we can use the `-4` option to force the use of an IPv4 address, as shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we will get the output, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'However, what if we are displayed the IPv4 address and we need to get inside
    the IPv6 address instead? We can use the `-6` option to force the use of an IPv6
    address, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'From the `ping` command, there are two points that occur. First, the computer
    named `HOST1` is resolved to the IP address `10.1.6.165`. If the hostname resolution
    does not work, we will get an error like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Second, this command sends four packets to `HOST1` and receives four packets.
    This reply expresses that the computer named `HOST1` is working properly and is
    able to respond to the command request. If `HOST1` does not work or is disabled
    to respond to the request, we will see an output as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'There is some error information that we may encounter when we send the `ping`
    command, some of which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Destination Host Unreachable**: This indicates that there is a problem with
    the routing. This might be because of the misconfiguration of the default gateway
    in the local computer or remote computer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**TTL Expired in Transit**: This indicates that the ping process has passed
    through the number of routers that is greater than the TTL (Time To Live) value.
    Every time the ping passes through a router, the TTL value will be decremented.
    If the total number of router that a ping has to pass through is more than the
    TTL value, this error message will be displayed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Another option that we can use in the ping command is `–t`. With this option,
    instead of sending four packets, the `ping` command will continue to send packets
    until the user stops the same by pressing *Ctrl* + *C*. This is usually used when
    we wait for the disconnect status to turn to the connected status. We can send
    the command to the console, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The tracert command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When we have more than one router, we can use the `tracert` command to trace
    the path that is taken by the packets. The `tracert` command is similar to the
    `ping` command, except that `tracert` has the information about the router between
    the source device and the destination device. Here is the command that I used
    to trace the communication track from my device to [google.com](http://google.com):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'I got this output in my console window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, there are 14 rows, and each row represents a **hop** (a circumstance
    in which the `ping` command passes the router). If we divide one row by a column,
    for instance the fourth row, we will get the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Hop # | RTT1 | RTT2 | RTT3 | Name/IP address |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | 293 ms | 76 ms | 84 ms | 73.171.94.61.in-addr.arpa [61.94.171.73] |'
  prefs: []
  type: TYPE_TB
- en: 'The explanation of each row is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The Hop number**: This is the first column and is just the number of hops
    along the route.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**RTT columns**: This is the **Round Trip Time** (**RTT**) for our packet to
    reach that destination and return to our computer. The RRT is bifurcated into
    three columns because the `tracecert` command sends three separate signal packets.
    This is to display the consistency, or a lack of it thereof, in the route.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The domain/IP column**: This is the IP address of the router. The domain
    name will also be informed if it is available.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The pathping command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `pathping` command is used to verify the routed path. It examines the route
    of two devices just like the `tracert` command does, and then checks the connectivity
    in each router like the `ping` command does. The `pathping` command sends 100
    request commands to each router and expects to get 100 replies back. For every
    request that is not replied, the `pathping` command will count it as 1 percent
    data loss. So if, for instance, there are ten requests that do not reply back,
    there will be 10 percent data loss. The smaller the percentage of data loss, the
    better connection we have.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will try to send the `pathping` command to [google.com](http://google.com)
    with the help of the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'By doing this, we will get the output as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In the 10th and 11th rows, we get 100 percent packet loss because 100 of the
    packets sent to the network were lost. However, this is not likely because the
    data does not arrive at the destination router as ICMP is blocked by the routers.
    With this command, we can identify in which specific router we will encounter
    the large percentage of data loss, especially in a large network with many routers
    connected.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also change the number of requests to be sent to the router using the
    `–q` option. We just need to state the new number of requests after the option,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This will send ten requests to the router instead of 100 requests and will be
    faster.
  prefs: []
  type: TYPE_NORMAL
- en: The netstat command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `netstat` (stands for **network statistics**) command is used to view the
    TCP/IP statistics by displaying all the information about the TCP/IP connection
    in the current device. It will show information about connections, ports, and
    applications that are involved in the network. We can use this command by typing
    it in the console window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'After this, we will get something as shown in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that there are four columns in the `netstat` command''s output.
    The explanation of each column is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Proto**: This displays the name of the protocol, which is TCP or UDP.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Local Address**: This displays the IP address of the local computer along
    with the port number being used. If the server is listening on all interfaces,
    the asterisk symbol (`*`) will be shown as the hostname. If the port has not been
    established yet, the port number will be shown as an asterisk as well.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Foreign Address**: This displays the IP address and port number of the remote
    computer to which the socket is connected. If the port has not been established
    yet, the port number will be shown as an asterisk (`*`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**State**: This indicates the state of a TCP connection. The possible states
    that we will get are as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SYN_SEND**: This indicates active open systems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SYN_RECEIVED**: This indicates that the server just received SYN from the
    client.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ESTABLISHED**: This indicates that the client received the server''s SYN
    and that the session is established.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**LISTEN**: This indicates that the server is ready to accept the connection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**FIN_WAIT_1**: This indicates active close systems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**TIMED_WAIT**: This indicates that the client enters this state after active
    close.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CLOSE_WAIT**: This indicates passive close, which means that the server just
    received its first FIN from a client.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**FIN_WAIT_2**: This indicates that the client just received an acknowledgment
    of its first FIN from the server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**LAST_ACK**: This indicates that the server is in this state when it sends
    its own FIN.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CLOSED**: This indicates that the server received ACK from the client and
    that the connection is now closed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more details and information about these states, you can go to [tools.ietf.org/html/rfc793](http://tools.ietf.org/html/rfc793)
    and refer to [Chapter 3](part0025_split_000.html#page "Chapter 3. Introducing
    the Boost C++ Libraries"), *Functional Specification*.
  prefs: []
  type: TYPE_NORMAL
- en: The telnet command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `telnet` (stands for **Terminal Network**) command is used to access remote
    computers over the TCP/IP network. In Windows, there are two Telnet features,
    which are the Telnet Server and Telnet Client. The former is used to configure
    Windows in order to listen for incoming connections and allow others to use it.
    Whereas, the latter is used to connect through Telnet with any server.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, Telnet is not installed on the Windows system because of the security
    risks. It is more secure to keep Telnet disabled since an attacker can check the
    opening port on the system using Telnet. However, no one can stop us from installing
    it in our system. We can by do so by performing these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the **Run** window by pressing *Windows* + *R*, type `%SYSTEMROOT%\System32\OptionalFeatures.exe`
    in the text box, and then press the **OK** button. The **Windows Features** window
    will open then.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check **Telnet Client** and **Telnet Server** options, and then press the **OK**
    button to confirm the change. The checked option will look like the following
    screenshot:![The telnet command](img/00014.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Telnet should be installed by now on our computer. Open the Command Prompt
    window and run the following command to start Telnet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'After pressing *Enter*, you will be showed the following output with the blinking
    cursor at the end:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Now, Telnet is ready to receive our command. To test it, we can run various
    commands in it. The complete list of the commands that are available in telnet
    can be found at [windows.microsoft.com/en-us/windows/telnet-commands](http://windows.microsoft.com/en-us/windows/telnet-commands).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we came to know the main role of each layer in both the OSI
    and TCP/IP models when we talked about network architecture. We explored the Internet
    Protocol and were able to distinguish the difference between IPv4 and IPv6\. We
    were also able to determine the subnet mask and classify the IP address. Moreover,
    we were able to detect whether an error occurs using various TCP/IP tools.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to talk about the Boost C++ library, which
    is the library that will make us more productive in the C++ programming. Now,
    let's prepare our programming tool and go to the next chapter.
  prefs: []
  type: TYPE_NORMAL
