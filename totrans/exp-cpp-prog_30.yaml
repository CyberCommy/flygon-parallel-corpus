- en: Filesystem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a path normalizer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting canonical file paths from relative paths
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Listing all files in directories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a grep-like text search tool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing an automatic file renamer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a disk usage counter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calculating statistics about file types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a tool that reduces folder size by substituting duplicates with
    symlinks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Working with filesystem paths is always tedious if we don't have a library that
    helps us because there are many conditions that we need to handle.
  prefs: []
  type: TYPE_NORMAL
- en: Some paths are *absolute*, some are *relative*, and maybe they are not even
    straightforward because they also contain `.` (current directory) and `..` (parent
    directory) indirections. Then, at the same time, different operating systems use
    the slash `/` to separate directories (Linux, MacOS, and different UNIX derivatives),
    or the backslash (Windows). And of course there are different types of files.
  prefs: []
  type: TYPE_NORMAL
- en: Since every other program that handles filesystem-related things needs such
    functionality, it is great to have the new filesystem library in the C++17 STL.
    The best thing about it is that it works the same way for different operating
    systems, so we don't have to write different code for versions of our programs
    that support different operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will first see how the `path` class works, because it is
    most central to anything else in this library. Then, we will see how powerful
    but yet simple to use `directory_iterator` and `recursive_directory_iterator`
    classes are, while we do useful things with files. In the end, we will use some
    small and simple example tools that do some real-life tasks related to the filesystem.
    From this point, it will be easy to build more complex tools.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a path normalizer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We start this chapter with a very simple example around the `std::filesystem::path`
    class and a helper function that intelligently normalizes filesystem paths.
  prefs: []
  type: TYPE_NORMAL
- en: The result of this recipe is a little application that takes any filesystem
    path and returns us the same path in normalized form. Normalized means that we
    get an absolute path that contains no `.` or `..` path indirections.
  prefs: []
  type: TYPE_NORMAL
- en: While implementing that, we will also see what details we need to pay attention
    to when working with this basic part of the filesystem library.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will implement a program that just accepts a filesystem
    path as a command-line argument and then prints it in normalized form.
  prefs: []
  type: TYPE_NORMAL
- en: Includes come first, and then we declare that we use namespace `std` and `filesystem`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the main function, we check whether the user provided a command-line argument.
    If that is not the case, we error out and print how to use the program. If a path
    was provided, we instantiate a `filesystem::path` object from it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Since we can instantiate `path` objects from any string, we cannot be sure if
    the path really exists on the filesystem of the computer. In order to do that,
    we can use the `filesystem::exists` function. If it doesn't, we simply error out
    again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Okay, at this point, we are pretty sure that the user provided some *existing*
    path knowing that we can ask for a normalized version of it, which we then print.
    `filesystem::canonical` returns us another `path` object. We could print it directly,
    but the `path` type overload of the `<<` operator surrounds paths with quotation
    marks. In order to avoid that, we can print a path through its `.c_str()` or `.string()`
    method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Let's compile the program and play with it. When we execute it in my home directory
    on the relative path `"src"`, it will print the full absolute path.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: When we run the program in my home directory again, but give it a quirky relative
    path description that first enters my `Desktop` folder, then steps out of it again
    using `..`, then enters the `Documents` folder and steps out again in order to
    finally enter the `src` directory, the program prints the *same* path as before!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a starter on `std::filesystem`, this recipe is still fairly short and straightforward.
    We initialized a `path` object from a string that contains a filesystem path description.
    The `std::filesystem::path` class plays a very central role whenever we use the
    filesystem library because most of the functions and classes relate to it.
  prefs: []
  type: TYPE_NORMAL
- en: Using the `filesystem::exists` function, we were able to check if the path really
    exists. Up to that point, we could not be sure about that, because it is indeed
    possible to create `path` objects that do not relate to an existing filesystem
    object. `exists` just accepts a `path` instance and returns `true` if it really
    exists. The function is already able to determine itself if we gave it an absolute
    or a relative path, which makes it very comfortable to use.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we used `filesystem::canonical` on the directory in order to print
    it in normalized form.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '`canonical` accepts a path and as an optional second argument, it accepts another
    path. The second path `base` is prepended to path `p` if `p` is a relative path.
    After doing that, `canonical` tries to remove any `.` and `..` path indirections.'
  prefs: []
  type: TYPE_NORMAL
- en: While printing, we used the `.c_str()` method on the canonicalized path. The
    reason for this is that the overload of `operator<<` for output streams surrounds
    paths with quotation marks, which we may not always want.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`canonical` throws a `filesystem_error` type exception if the path we want
    to canonicalize does not exist. In order to prevent that, we checked our filesystem
    path with `exists`. But was that check really sufficient to avoid getting unhandled
    exceptions? No.'
  prefs: []
  type: TYPE_NORMAL
- en: Both `exists` and `canonical` can throw `bad_alloc` exceptions. If those hit
    us, one could argue that the program is doomed anyway. A far more critical, and
    also much more probable problem would occur if, between us checking if the file
    exists and canonicalizing it, someone else renames or deletes the underlying file!
    In that case, `canonical` would throw a `filesystem_error`, although we checked
    for the file's existence before.
  prefs: []
  type: TYPE_NORMAL
- en: Most filesystem functions have an additional overload that takes the same arguments,
    but also an `std::error_code` reference.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This way we can choose if we surround our filesystem function calls with `try`-`catch`
    constructs or check the errors manually. Note that this only changes the behavior
    of *filesystem-related* errors! With and without the `ec` parameter, more fundamental
    exceptions, for example, `bad_alloc`, can still be thrown if the system runs out
    of memory.
  prefs: []
  type: TYPE_NORMAL
- en: Getting canonical file paths from relative paths
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last recipe, we already canonicalized/normalized paths. The `filesystem::path`
    class is, of course, capable of more things than just holding and checking paths.
    It also helps us in composing paths from strings easily, and also to decompose
    them again.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, `path` does already abstract operating system details away from
    us, but there are also certain instances where we still need to keep such details
    in mind.
  prefs: []
  type: TYPE_NORMAL
- en: We will see how to deal with paths and their composition/decomposition by playing
    around with absolute and relative paths.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will play around with absolute and relative paths in order
    to see the strengths of the `path` class and the helper functions around it.
  prefs: []
  type: TYPE_NORMAL
- en: First, we include all the necessary headers and declare that we use namespace
    `std` and `sfilesystem`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Then, we declare an example path. At this point, it is not important that the
    text file it refers to really exists. There are some functions, however, that
    throw exceptions if the underlying file does not exist.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We will have a look at four different filesystem library functions now. `current_path`
    returns us the path the program is currently executed in, the *working directory*.
    `absolute` accepts a relative path like our path `p` and returns the absolute,
    nonambiguous path in the whole filesystem. `system_complete` does practically
    the same as `absolute` on Linux, MacOS, or UNIX-like operating systems. On Windows,
    we would get the absolute path additionally prepended by the disk volume letter
    (for example, `"C:"`). `canonical` does again the same as `absolute` does, but
    then additionally removes any `"."` (short for *"this directory"*) or `".."` (short
    for *"one directory up"*) indirections. We will play with such indirections in
    the following steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Another nice thing about the `path` class is that it overloads the `/` operator.
    This way we can concatenate folder names and filenames using `/` and compose paths
    from that. Let's try it out and print a composed path.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Let's play with `canonical` and composed paths. By giving `canonical` a relative
    path such as `"foobar.txt"` and a composed absolute path `current_path() / "testdir"`,
    it should return us the existing absolute path. In another call, we give it our
    path `p` (which is `"testdir/foobar.txt"`) and provide it an absolute path that
    is `current_path()`, which directs us into `"testdir"` and up again. This should
    be the same as `current_path()`, because of the indirection. In both calls, `canonical`
    should return us the same absolute path.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We can also test for the equivalence of two paths that are not canonical. `equivalence`
    canonicalizes the paths, which it accepts as arguments and returns `true` if they
    describe the same path after all. For this test, the path must really *exist,*
    otherwise, it throws an exception.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Compiling and running the program yields the following output. `current_path()`
    returns the home folder on my laptop because I executed the application from there.
    Our relative path `p` has been prepended with this directory by `absolute_path`,
    `system_complete`, and `canonical`. We see that `absolute_path` and `system_complete`
    yield exactly the same path on my system because it is a Mac (it would be the
    same on Linux). On a Windows machine, `system_complete` would have prepended `"C:"`,
    or whatever drive the working directory is located in.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We do not handle any exceptions in our short program. If we remove the `foobar.txt`
    file in the `testdir` directory, then the program aborts its execution due to
    an exception. The `canonical` function requires the path to exist. There is also
    a `weakly_canonical` function that does not come with this requirement.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The goal of this recipe is to see how easy it is to compose new paths on the
    fly. This is mainly because the `path` class has a handy overload for the `/`
    operator. In addition to that, the filesystem functions get along well with relative
    and absolute paths, as well as with paths that contain `.` and `..` indirections.
  prefs: []
  type: TYPE_NORMAL
- en: There is quite a jungle of functions that return parts of a `path` instance,
    with or without transformations. We are not going to list all functions there
    are here because a short glance into the C++ reference is the best way to get
    an oversight.
  prefs: []
  type: TYPE_NORMAL
- en: The member functions of the `path` class, however, might be worth a closer look.
    Let's see which part of a path is returned by what member function of `path`.
    The following diagram also shows how Windows paths are slightly different from
    UNIX/Linux paths.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9c9ab3d9-e0c4-41d0-b90c-2de3c0075dd2.png)'
  prefs: []
  type: TYPE_IMG
- en: You can see that the diagram shows what the member functions of `path` return
    for an *absolute* path. For *relative* paths, `root_path`, `root_name`, and `root_directory`
    are empty. `relative_path` then just returns the path if it is relative already.
  prefs: []
  type: TYPE_NORMAL
- en: Listing all files in directories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Of course, every operating system that offers filesystem support also comes
    with some kind of utility that does just *list* all files within a directory in
    the filesystem. The simplest examples are the `ls` command on Linux, MacOS, and
    other UNIX-related operating systems. In DOS and Windows, there is the `dir` command.
    Both list all files in a directory and provide supplemental information such as
    file size, permissions, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Reimplementing such a tool is, however, also a nice standard task to get going
    with directory and file traversal. So, let's just do that!
  prefs: []
  type: TYPE_NORMAL
- en: Our own `ls`/`dir` utility will be able to list all items in a directory by
    name, indicate what kind of items there are, list their access permission flags,
    and display the number of bytes they occupy on the filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will implement a little tool that lists all files in any
    user provided directory. It will not only list the filenames, but also their type,
    size, and access permissions.
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to include some headers and declare that we use the namespaces
    `std` and `filesystem` by default.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: One helper function that we are going to need is `file_info`. It accepts a `directory_entry`
    object reference and extracts the path from it, as well as a `file_status` object
    (using the `status` function), which contains file type and permission information.
    Finally, it also extracts the size of the entry if it is a regular file. For directories
    or other special files, we plainly return a size of `0`. All this information
    is bundled into a tuple.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Another helper function that we will need is `type_char`. A path cannot only
    represent directories and simple text/binary files. Operating systems provide
    a variety of other types that abstract something else, such as hardware device
    interfaces in the form of so-called character/block files. The STL filesystem
    library provides a lot of predicate functions for them. This way we can return
    the letter `'d'` for directories, the letter `'f'` for regular files, and so on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Yet another helper we will need is the `rwx` function. It accepts a `perms`
    variable (which is just an `enum` class type from the filesystem library) and
    returns a string such as `"rwxrwxrwx"` that describes the file's permission settings.
    The first group of `"rwx"` characters describes the ***r**ead, **w**rite, and
    e**x**ecution* permissions for the owner of the file. The next group describes
    the same rights for all users that are part of the *user group* the file belongs
    to. The last character group describes which rights everyone else has for accessing
    the file. A string such as `"rwxrwxrwx"` means that everyone can access the object
    in any way. `"rw-r--r--"` means that only the owner can read and modify the file,
    while anyone else can only read it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We just compose a string from such read/write/execute character values, permission
    bit by permission bit. A lambda expression helps us with the repetitive work of
    checking if the `perms` variable `p` contains a specific owner bit and then returns
    `'-'` or the right character.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Finally, the last helper function accepts an integral file size and converts
    it to a better to read form. We just ignore the period while dividing numbers
    down and floor them to the nearest kilo, mega, or giga boundary.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Now we can finally implement the main function. We begin with checking if the
    user provided a path in the command line. If he didn't, we just take the current
    directory "`.`". Then, we check if the directory exists. If it doesn't, we can't
    possibly list any files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Now, we will fill a `vector` with file information tuples just like our first
    helper function `file_info` returns from `directory_entry` objects. We instantiate
    a `directory_iterator` and give its constructor the `path` object, which we created
    in the last step. While iterating with the directory iterator, we transform the
    `directory_entry` objects to file information tuples and insert them into the
    vector.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Now we have all information saved in the vector items and can simply print it
    using all the helper functions we wrote.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Compiling and running the project with a file path in the offline version of
    the C++ documentation yields the following output. We see that the folder only
    contains directories and plain files because there are only `'d'` and `'f'` entries
    as first characters of all output lines. These files have different access permissions,
    and of course different sizes. Note that the files appear in alphabetical order
    of their names, but we cannot really rely on that because alphabetic ordering
    is not required by the C++17 standard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we iterated over files, and for every file, we checked its status
    and size. While all our per-file operations are fairly straightforward and simple,
    our actual directory traversal looked a bit magic.
  prefs: []
  type: TYPE_NORMAL
- en: In order to traverse our directory, we just instantiated a `directory_iterator`
    and then iterated over it. Traversing a directory is fantastically simple with
    the filesystem library.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'There is not much more to say about this class apart from the following things:'
  prefs: []
  type: TYPE_NORMAL
- en: It visits every element of the directory once
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The order in which the directory elements are iterated is unspecified
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Directory elements `.` and `..` are already filtered out
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'However, it might be noticeable that `directory_iterator` seems to be an *iterator*,
    and an *iterable range* at the same time. Why? In the minimal `for` loop example
    we just had a look at, it was used as an iterable range. In the actual recipe
    code, we used it like an iterator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The truth is, it is just an iterator class type, but the `std::begin` and `std::end`
    functions provide overloads for this type. This way we can call the `begin` and
    `end` function on this kind of iterator and they return us iterators again. That
    might look strange at first sight, but it makes this class more useful.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a grep-like text search tool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most operating systems come equipped with some kind of local search engine.
    Users can fire it up with some keyboard shortcut and then just enter what local
    file they are looking for.
  prefs: []
  type: TYPE_NORMAL
- en: Before such features came up, command-line users already searched through files
    with tools such as `grep` or `awk`. The user can simply type "`grep -r foobar
    .`" and the tool will crawl recursively through the current directory and find
    any file that contains the `"foobar"` string.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will implement exactly such an application. Our little grep
    clone will just accept a pattern from the command line, and then recursively search
    through the directory we are in at the time of the application start. It will
    then print the name of every file that matches our pattern. The pattern matching
    will be applied linewise, so we can also print on which exact line numbers a file
    is matching the pattern.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will implement a little tool that searches for user-provided text patterns
    in files. The tool works similar to the UNIX tool `grep`, but will not be as mature
    and powerful, for the sake of simplicity.
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to include all the necessary headers and declare that we use
    namespace `std` and `filesystem`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We implement a helper function first. It accepts a file path and a regular expression
    object that describes the pattern we are looking for. Then, we instantiate a `vector`
    that shall contain pairs of matching line numbers and their content. And we instantiate
    an input file stream object from which we will read and pattern-match the content,
    line by line.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We traverse the file line by line using the `getline` function. `regex_search`
    returns `true` if the string contains our pattern. If this is the case, then we
    put the line number and the string into the vector. Finally, we return all collected
    matches.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In the main function, we first check whether the user provided a command-line
    argument that we can use as the pattern. If not, we error out.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Next, we construct a regular expression object from the input pattern. If the
    pattern is not a valid regular expression, this would lead to an exception. If
    such an exception occurs, we catch it and error out.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can finally iterate over the filesystem and look for pattern matches.
    We use `recursive_directory_iterator` to iterate over all the files in the working
    directory. It works exactly like `directory_iterator` in the previous recipe,
    but it also descends down into subdirectories. This way we don't have to manage
    recursion. On every entry, we call our helper function `matches`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: For every match (if any) we print the file path, its line number, and the matching
    line's complete content.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Let's prepare a file called `"foobar.txt"`, which contains some test lines we
    can search for.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Compiling and running yields the following output. I launched the app in the
    `/Users/tfc/testdir` folder on my laptop, first with the pattern `"bar"`. Within
    that directory, it found the second line of our `foobar.txt` file and another
    file `"text1.txt"` that is located in `testdir/dir1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Launching the app again, but this time with the pattern `"baz"`, it finds the
    third line of our example text file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Setting up and using a regular expression in order to filter the content of
    files is certainly the main task of this recipe. However, let's concentrate on
    `recursive_directory_iterator` because filtering recursively iterated files was
    just our motivation to use this special iterator class in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Just like `directory_iterator`, `recursive_directory_iterator` iterates over
    elements of a directory. Its specialty is to do this recursively, as its name
    tells. Whenever it hits a filesystem element that is a *directory*, it will yield
    a `directory_entry` instance to this path, but then also descend down into it
    in order to iterate its children, too.
  prefs: []
  type: TYPE_NORMAL
- en: '`recursive_directory_iterator` has some interesting member functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`depth()`: This tells us how many levels the iterator has currently descended
    down into subdirectories.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`recursion_pending()`: This tells us if the iterator is going to descend down
    after the element it currently points to.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`disable_recursion_pending()`: This can be called to keep the iterator from
    descending into the next subdirectory if it is currently pointing to a directory
    into which it would descend. This means that calling this method has no effect
    if we call it *too early*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pop()`: This aborts the current recursion level and goes one level up in the
    directory hierarchy to continue from there.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another thing to know about is the `directory_options` enum class. The constructor
    of `recursive_directory_iterator` does indeed accept a value of this type as a
    second argument. The default value which we have been implicitly using is `directory_options::none`.
    The other values are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`follow_directory_symlink`: This allows the recursive iterator to follow symbolic
    links to directories'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`skip_permission_denied`: This tells the iterator to skip directories that
    would otherwise result in errors because permission to access is denied by the
    filesystem'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These options can be combined with the `|` operator.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing an automatic file renamer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe is motivated by a situation I find myself in pretty often. When
    collecting picture files from holidays, for example, from different friends and
    also different photo devices in one folder, the file endings often look different.
    Some JPEG files have a `.jpg` extension, some have `.jpeg`, and some others even
    have `.JPEG`.
  prefs: []
  type: TYPE_NORMAL
- en: Some people might prefer to homogenize all extensions. It would be useful to
    rename all files with a single command. At the same time, we could remove spaces
    `' '` and substitute them by underscores `'_'`, for example.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe, we will implement such a tool and call it `renamer`. It will
    accept a range of input patterns and their substitutes like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: In that case, renamer will iterate recursively through the current directory
    and search for the patterns `jpeg` and `JPEG` in all filenames. It will substitute
    both with `jpg`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will implement a tool that recursively scans all files within a directory
    and matches their filenames with patterns. All matches are replaced with user
    provided tokens and the affected files are renamed accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to include a few headers and declare that we use namespaces `std`
    and `filesystem`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: We implement a short helper function that accepts an input file path in the
    form of a string and a range of replacement pairs. Each replacement pair consists
    of a pattern and its replacement. While looping through the replacement range,
    we use `regex_replace` to feed it with the input string and let it return the
    transformed string. Afterward, we return the resulting string.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: In the main function, we first validate the command line. We accept command-line
    arguments in *pairs* because we want patterns together with their replacements.
    The first element of `argv` is always the executable name. This means that if
    the user provides at least one pair or more, then `argc` must be *odd* and not
    smaller than `3`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Once we checked that there are pairs of input, we will fill a vector with these.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Now we can iterate over the filesystem. For the sake of simplicity, we just
    define the application's current path as the directory to iterate over.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For every directory entry, we extract its original path to the `opath` variable.
    Then, we take only the filename without the rest of this path and transform it
    according to the list of patterns and replacements we collected before. We take
    a copy of `opath`, call it `rpath`, and replace its filename part with the new
    filename.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: For all files that are affected by our patterns, we print that we rename them.
    In case the resulting filename from replacing the patterns does already exist,
    we can't proceed. Let's just skip such files. We could of course alternatively
    just append some number to the path or something else to resolve the name clash.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Compiling and running the program in an example directory yields the following
    output. I have put some JPEG pictures into the directory but have given them different
    name endings `jpg`, `jpeg`, and `JPEG`. Then, I executed the program with the
    patterns `jpeg` and `JPEG` and chose `jpg` as the replacement for both. The result
    is a folder with homogenous filename extensions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Implementing a disk usage counter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We already implemented a tool that works like `ls` on Linux/MacOS, or `dir`
    on Windows, but just as these tools, it doesn't print the file size for *directories*.
  prefs: []
  type: TYPE_NORMAL
- en: In order to get the size equivalent of a directory, we would have to descend
    down into it and sum up the size of all files that it contains.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will implement a tool that does just that. The tool can be
    run on any folder and will summarize the accumulated size of all directory entries.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will implement an app that iterates over a directory and
    lists the file size of each entry. This is simple for regular files, but if we
    are looking at a directory entry that itself is a directory, then we have to look
    into it and summarize the size of all the files it holds.
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to include all the necessary headers and declare that we use
    namespace `std` and `filesystem`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Then we implement a helper function that accepts a `directory_entry` as an argument
    and returns its size in the filesystem. If it is not a directory, we simply return
    the file size calculated by `file_size`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: If it is a directory, we need to iterate over all its entries and calculate
    their size. We end up calling our own `entry_size` helper function recursively
    if we stumble upon subdirectories again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: For better readability, we use the same `size_string` function as in other recipes
    in this chapter. It just divides large file sizes in to shorter and nicer ones
    to read strings with kilo, mega, or giga suffix.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The first thing we need to do in the main function is to check whether the user
    provided a filesystem path on the command line. If that is not the case, we just
    take the current folder. Before proceeding, we check whether it exists.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can iterate over all directory entries and print their sizes and names.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Compiling and running the program yields the following results. I launched it
    in a folder in the C++ offline reference. As it contains subfolders too, our recursive
    file size summary helper is immediately helpful.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The whole program revolves around using `file_size` on regular files. If the
    program sees a directory, it recursively descends down into it and calls `file_size`
    on all its entries.
  prefs: []
  type: TYPE_NORMAL
- en: The only thing we did to distinguish if we call `file_size` directly or if we
    need the recursion strategy was asking the `is_directory` predicate. This works
    well for directories that only contain regular files and directories.
  prefs: []
  type: TYPE_NORMAL
- en: 'As simple as our example program is, it would crash under the following conditions,
    because of unhandled exceptions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`file_size` only works on regular files and symbolic links. It throws an exception
    in any other case.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although `file_size` works on symbolic links, it *still* throws an exception
    if we call it on a *broken* symbolic link.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In order to make this example recipe program more mature, we need more defensive
    programming against the wrong type of files and handling of exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: Calculating statistics about file types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last recipe, we implemented a tool that lists the size of all members
    of any directory.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will be counting sizes recursively, too, but this time we
    will accumulate the size of each file to their filename *extension*. This way
    we can print the user a table that lists how many files of each file type we have,
    and what the average size of such file types is.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will implement a little tool that recursively iterates over
    a given directory. While doing that, it counts the number and size of all files,
    grouped by their extensions. Finally, it prints which filename extensions exist
    within that directory, how many there are per extension, and their average file
    size.
  prefs: []
  type: TYPE_NORMAL
- en: We need to include necessary headers and we declare that we use namespace `std`
    and `filesystem`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The `size_string` function was already helpful in other recipes. It transforms
    file sizes to human-readable strings.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Then, we implement a helper function that accepts a `path` object as its argument
    and iterates over all files within that path. On its way, it collects all information
    in a map that maps from filename extensions to pairs that contain the total number
    and accumulated size of all files that have the same extension.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: If a directory entry is a directory itself, we skip it. Skipping it at this
    point does not mean that we are not recursively descending into it. `recursive_directory_iterator`
    still does that, but we do not want to look at the directory entries themselves.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Next, we extract the extension part of the directory entry string. If it has
    no extension, we simply skip it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Next, we calculate the size of the file we are looking at. Then, we look up
    the aggregate object in the map for this extension. If there are yet none at this
    point, it is created implicitly. We simply increment the file count and add the
    file size to the size accumulator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Afterward, we return the map.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: In the main function, we take either a user-provided path from the command line
    or the current directory. Of course, we need to check whether it exists because
    it would not make sense to continue otherwise.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: We can immediately iterate over the map that `ext_stats` gives us. Because the
    `accum_size` items in the map contain the sum of all files with the same extension,
    we divide this sum by the total number of such files before printing it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Compiling and running the program yields the following output. I gave it a folder
    from the offline C++ reference as a command-line argument.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Implementing a tool that reduces folder size by substituting duplicates with
    symlinks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a lot of tools that compress data in various ways. The most famous
    examples for file packing algorithms/formats are ZIP and RAR. Such tools try to
    reduce the size of files by reducing internal redundancy.
  prefs: []
  type: TYPE_NORMAL
- en: Before compressing files in archives, a very simple way to reduce disk usage
    is just *deleting* *duplicate* files. In this recipe, we will implement a little
    tool that crawls a directory recursively. While crawling, it will look for files
    that have the same content. If it finds such files, it will remove all duplicates
    but one. All removed files will be substituted with symbolic links that point
    to the now unique file. This saves spaces without any compression, while at the
    same time preserving all data.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will implement a little tool that finds out which files
    in a directory are duplicates of each other. With that knowledge, it will remove
    all but one of all duplicated files, and substitute them with symbolic links,
    which reduces the folder size.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure to have a *backup* of your system's data. We will be playing with
    STL functions that remove files. A simply *misspelled* path in such a program
    can lead to a program that greedily removes too many files in unwanted ways.
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to include the necessary headers and then we declare that we
    use namespace `std` and `filesystem` by default.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: In order to find out which files are duplicates of each other, we will construct
    a hash map that maps from hashes of file content to the path of the first file
    from which that hash was generated. It would be a better idea to use a production
    hash algorithm for files such as MD5 or an SHA variant. In order to keep the recipe
    clean and simple, we just read the whole file into a string and then use the same
    hash function object that `unordered_map` already uses for strings to calculate
    hashes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Then we implement the function that constructs such a hash map and deletes duplicates.
    It iterates recursively through a directory and its subdirectories.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: For every directory entry, it checks whether it is a directory itself. All directory
    items are skipped. For every file, we generate its hash value and try to insert
    it into the hash map. If the hash map already contains the same hash, then this
    means that we already inserted a file with the same hash. This means that we just
    found a duplicate! In case of a clash during insertion, the second value in the
    pair that `try_emplace` returns is `false`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Using the return values from `try_emplace`, we can tell the user that we just
    inserted a file because we have seen its hash for the first time. In case we found
    a duplicate, we tell the user what other file it is a duplicate of and delete
    it. After deletion, we create a symbolic link that replaces the duplicate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: After the filesystem iteration, we return the number of files we deleted and
    replaced with symlinks.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: In the main function, we make sure that the user provided a directory on the
    command line, and that this directory exists.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: The only thing we need to do now is to call `reduce_dupes` on this directory
    and print how many files it deleted.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Compiling and running the program on an example directory that contains some
    duplicate files looks like the following. I used the `du` tool to check the folder
    size before and after launching our program to demonstrate that the approach works.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We used the `create_symlink` function in order to make a filesystem entry point
    to another file in the filesystem. This way we can avoid having duplicate files.
    We could also have set a hard link using `create_hard_link`. Semantically, this
    is similar, but hard links have other technical implications than soft links.
    Different filesystem formats might not support hard links at all, or only a certain
    number of hard links that refer to the same file. Another problem is that hard
    links cannot link from one filesystem to the other.
  prefs: []
  type: TYPE_NORMAL
- en: However, apart from implementation details, there is one *blatant error* source
    when using `create_symlink` or `create_hard_link`. The following lines contain
    a bug. Can you spot it immediately?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Nothing bad happens when executing this program, but the symlink will be *broken*.
    The symlink points to `"some_dir/some_file.txt"`, which is wrong. The problem
    is that it should really either point to `"/absolute/path/some_dir/some_file.txt"`,
    or `"../some_dir/some_file.txt"`. The `create_symlink` call uses a correct absolute
    path if we write it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '`create_symlink` does not check whether the path we are linking to is *correct*.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We already noticed that our hash function is a too simple one. For the sake
    of keeping this recipe simple and without external dependencies, we chose this
    way.
  prefs: []
  type: TYPE_NORMAL
- en: 'What is the problem with our hash function? There are actually two problems:'
  prefs: []
  type: TYPE_NORMAL
- en: We read the whole file into a string. This is disastrous for files that are
    larger than our system memory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The C++ hash function trait `hash<string>` is most probably not designed for
    such hashes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we are looking for a better hash function, we should take one that is fast,
    memory-friendly, and that makes sure that no two really large but different files
    get the same hash. The latter requirement is maybe the most important one. If
    we decide that one file is a duplicate of the other although they do not contain
    the same data, we surely have some *data loss* after deleting it.
  prefs: []
  type: TYPE_NORMAL
- en: Better hash algorithms are, for example, MD5 or one of the SHA variants. In
    order to get access to such functions in our program, we could use the OpenSSL
    cryptography API, for example.
  prefs: []
  type: TYPE_NORMAL
