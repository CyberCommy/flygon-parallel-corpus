- en: Chapter 8. Payloads and Shells
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Extracting data through HTTP requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an HTTP C2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an FTP C2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an Twitter C2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a simple Netcat shell
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will be looking at the creation of reverse shells and payloads
    in Python. Once an upload vulnerability has been identified on a Linux or Mac
    system, Python payloads are in the sweet spot of next steps. They are easy to
    craft or customize to match a specific system, have clear functionality, and best
    of all, almost all Mac and Linux systems come with Python 2.7 by default.
  prefs: []
  type: TYPE_NORMAL
- en: Extracting data through HTTP requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first script we''ll being creating will use a very simple technique to
    extract data from the target server. There are three basic steps: run the commands
    on the target, transfer the output through HTTP requests to the attacker, and
    view the results.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting Ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This recipe requires a web server that is accessible on the attacker''s side
    in order to receive the HTTP request from the target. Luckily, Python has a really
    simple way to start a web server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This will start a HTTP web server on port `8000`, serving up any files in the
    current directory. Any requests it receives are printed out directly to the console,
    making this a really quick way to grab the data and are therefore a nice addition
    to this script.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is the script that will run various commands on the server and transfer
    the output through a web request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After the imports, the first part of the script creates an array of commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This is an example of three standard Linux commands that could give useful information
    back to the attacker. Note that there's an assumption here that the target server
    is running Linux. Use scripts from the previous chapters for reconnaissance, in
    order to determine the target's operating system and replace the commands in this
    array with Windows equivalents, if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we have the main `for` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This part of code executes the command and grabs the output from `subprocess`
    (piping both standard out and standard error into a single `subprocess.PIPE`).
    It then adds the result to the out dictionary. Notice that we use a `try` and
    `except` statement here, as any command that fails to run will cause an exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we have a single HTTP request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This uses `urllib.encode` to transform the dictionary into URL encoded key/value
    pairs. This means that any characters that could affect the URL, for example,
    `&` or `=`, will be converted to their URL encoded equivalent, for example, `%26`
    and `%3D`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that there will be no output on the script side; everything is passed
    over in the HTTP request to the attacker''s web server (the example uses localhost
    on port `8000`). The `GET` request looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/B04044_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Creating an HTTP C2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The issue with brazenly presenting your commands in URLs is that even a half-asleep
    log analyst will spot it. There are multiple methods of hiding requests, but when
    you don't know what the response text is going to look like, you need to provide
    a solid method of disguising the output and returning it to your server.
  prefs: []
  type: TYPE_NORMAL
- en: We will create a script that masks command and control activities as HTTP traffic,
    takes commands from comments on a web page, and returns the output into a guestbook.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Started
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this, you will need a functioning web server with two pages, one to host
    your comments and one to host your retrieval page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your comment page should just have standard content. For this, I''m using the
    Nginx default home page and adding comments to it at the end. A comment should
    be expressed as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The retrieval page can be as simple as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Basically, what this PHP does is take an incoming value in the `POST` request
    named `comment` and places it in a database. It's very rudimentary and does not
    distinguish between multiple incoming commands if you have multiple shells going.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The script we will be using is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The following shows an example of the output produced when using this script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As ever, we import the necessary libraries and get the script going:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'As this script has a built-in self deletion method, we can set it up to run
    forever with the following loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We make a request to check whether there are any comments on our preconfigured
    page. If there are, we put them in a list. We use very basic `regex` to perform
    this check:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The first thing we do is check for an empty comment. This signifies to the
    script that it should delete itself, a very important mechanism for hands-off
    C2 scripts. If you wish the script to delete itself, just leave an empty comment
    on your page. The script deletes itself by looking for its own name and removing
    that name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If the comment isn''t blank, we attempt to pass it to the system with the `subprocess`
    command. It''s important that you use .`split()` on the command to account for
    how `subprocess` handles multi-part commands. We use `.check_output` to return
    whatever output the command gives directly to the variable that we assign:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If the command fails, we set the response value to be `command failed`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We take the `response` variable and assign it to a key that matches our PHP
    script in a dictionary. In this circumstance, the field name is `comment` and
    thus we assign our output to a comment. We base64 the output in order to account
    for any random variables, such as spaces or code that may interfere with our script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the data has been assigned, we send it in a `POST` request to our preconfigured
    server and wait `30` seconds to again check for further instructions in the comments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Creating an FTP C2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This script is a quick and dirty file-theft tool. It runs in a straight line
    up the directories, nabbing everything it comes into contact with. It then exports
    these to an `FTP` directory that it's pointed at. In situations where you can
    drop a file and want to quickly get the contents of the server, this is ideal
    as a starting point.
  prefs: []
  type: TYPE_NORMAL
- en: We will create a script that connects to an FTP, grabs the files in the current
    directory, and exports them to the FTP. It then jumps up into the next directory
    and repeats. When it encounters two directory listings that are the same (that
    is, it has hit the root), it stops.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Started
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this, you will need a functioning FTP server. I'm using `vsftpd`, but you
    may use whatever you please. You'll need to either hard code the credentials into
    the script (not advisable) or send them with the credentials as flags.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The script we will be using is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As ever, we import our libraries and set up our variables. We have set the
    username and password as `sys.argv` to avoid having to hard code and therefore
    expose our systems:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We then connect to our FTP with an IP address and the credentials we set up
    through the flags. You can also pass the IP as `sys.argv` to avoid hard-coding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'I''ve set up a nonce value that won''t match the first directory for the directory
    checking method. We also set the loop as `0` and configure the "up directory"
    command as a variable, similar to the directory traversal script in [Chapter 3](ch03.html
    "Chapter 3. Vulnerability Identification"), *Vulnerability Identification*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We then create our main loop to repeat forever and create our chosen directory
    call. We list the files in the directory we call and assign it a variable. You
    can opt to print the file listing here if you wish, as I have for diagnostic purposes,
    but it makes no difference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'For each file detected in the directory, we attempt to open it. It''s important
    we open the file with `rb` as this allows it to be read as a binary, making it
    available to be transferred as a binary. If it''s openable, we transfer it to
    the FTP with the `storbinary` command. We then close the file to complete the
    transaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'If, for whatever reason, we can''t open or transfer the file, we simply move
    on to the next one in the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We then check to see whether we have changed directories since the last command.
    If not, we break out of the main loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'If the directory listing doesn''t match, we set the `filecheck` variable to
    match the current directory, iterate the loop by `1`, and sleep for `10` seconds
    to avoid spamming the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, once everything else is complete, we close our connection to the FTP
    server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Creating an Twitter C2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up to a certain point, requesting random pages on the Internet is passable but
    once a **Security Operation Centre** (**SOC**) analyst takes a closer look at
    all the data that's vanishing up the tubes, it's going to be obvious that the
    requests are going to a dodgy site and therefore are likely associated with malicious
    traffic. Fortunately, social media helps out in this regard and allows us to hide
    data in plain sight.
  prefs: []
  type: TYPE_NORMAL
- en: We will create a script that connects to Twitter, reads tweets, performs commands
    based on those tweets, encrypts the response data, and posts it to Twitter. We'll
    also make a decode script.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Started
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this, you will need a Twitter account with an API key.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The script we will be using is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The decoding script is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'An example of what the script in progress looks like is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](img/B04044_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We import our libraries, as usual. There are numerous Twitter Python libraries;
    I''m just using the standard twitter API available at [https://code.google.com/p/python-twitter/](https://code.google.com/p/python-twitter/).
    The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'To meet the Twitter authentication requirements, we need to need to retrieve
    the **App token**, **App secret**, **User token**, and **User secret** from our
    **App page** at [developer.twitter.com](http://developer.twitter.com). We assign
    them to variables and set up our connection to the Twitter API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We set up an infinite loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We call the user timeline of the account that has been set up. It''s important
    that this App has both read and write privileges for the Twitter account. We then
    take the last text of the most recent tweet. We need to encode it as UTF-8 as
    there are often characters that the normal encoding won''t be able to handle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We then take the oxt-last tweet to use as the key for our encryption. We encode
    it as `hex` to avoid there being things like spaces matching with spaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We carry out the action by using the `subprocess` function. We encrypt the
    output with preset up XORing encryption and encode it as base64:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We split the encrypted and encoded response into 140 character chunks, to allow
    for the Twitter character cap. For each chunk, we create a Twitter status:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Because each step requires two tweets, I''ve left an hour gap between each
    command check, but it''s easy to change this for yourself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'For the decoding, import the `RC4` library, set your key tweet as the key,
    and put your reassembled base64 as the response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Set up a new `RC4` code with the key, decode the data from base64, and decrypt
    it with the key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Creating a simple Netcat shell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following script we're going to create leverages the use of raw sockets
    to exfiltrate data from a network. The general idea of this shell is to create
    a connection between the compromised machine and your own machine through a Netcat
    (or other program) session and send commands to the machine this way.
  prefs: []
  type: TYPE_NORMAL
- en: The beauty of this Python script is the undetectable nature of it, as it appears
    as a completely legitimate script.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is the script that will establish a connection through Netcat and read
    the input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To start the script as normal, we need to import our modules that will be used
    throughout the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'We then need to define our variables: these values are the IP and port of the
    attacking machine to establish a connection with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: We then move on to defining the original connection; we can then assign a value
    to our established value and refer to this later on to read the input and send
    the standard output.
  prefs: []
  type: TYPE_NORMAL
- en: 'We refer back to the host and port value that we previously set and create
    the connection. We assign the established connection the value of `go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: We can then introduce the block of code that will do the waiting portion for
    us. This will be awaiting commands to be sent to it through the attacking machine's
    Netcat session. We ensure that data that gets sent through the session is piped
    into the shell and the standard output of this is then returned to us through
    the established Netcat session, thus giving us shell access through our reverse
    connection.
  prefs: []
  type: TYPE_NORMAL
- en: 'We give the name data to the values that are passed to the compromised machine
    through the Netcat session. A value is added to the script to exit the session
    when the user is done; we''ve chosen `exit` for this, which means entering exit
    into our Netcat session will terminate the established connection. We then get
    down to the nitty gritty parts in which the data is opened (read) and piped into
    the shell for us. Once this has been done, we ensure the `stdout` value is read
    and given a value of `stdout` (this could be anything), which we then send back
    to ourselves via the `go` session that we established earlier. The code is as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The final portion of our script is our error-checking and running portion.
    Before the script runs, we make sure we let Python know that we have a mechanism
    in place to check whether the session is active by using our previous true statement.
    If the connection is lost, the Python script will attempt to re-establish a connection
    with the attacking machine, making it a persistent backdoor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
