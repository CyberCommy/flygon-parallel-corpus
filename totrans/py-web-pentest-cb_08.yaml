- en: Chapter 8. Payloads and Shells
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Extracting data through HTTP requests
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an HTTP C2
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an FTP C2
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an Twitter C2
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a simple Netcat shell
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will be looking at the creation of reverse shells and payloads
    in Python. Once an upload vulnerability has been identified on a Linux or Mac
    system, Python payloads are in the sweet spot of next steps. They are easy to
    craft or customize to match a specific system, have clear functionality, and best
    of all, almost all Mac and Linux systems come with Python 2.7 by default.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: Extracting data through HTTP requests
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first script we''ll being creating will use a very simple technique to
    extract data from the target server. There are three basic steps: run the commands
    on the target, transfer the output through HTTP requests to the attacker, and
    view the results.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Getting Ready
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This recipe requires a web server that is accessible on the attacker''s side
    in order to receive the HTTP request from the target. Luckily, Python has a really
    simple way to start a web server:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This will start a HTTP web server on port `8000`, serving up any files in the
    current directory. Any requests it receives are printed out directly to the console,
    making this a really quick way to grab the data and are therefore a nice addition
    to this script.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is the script that will run various commands on the server and transfer
    the output through a web request:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: How it works…
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After the imports, the first part of the script creates an array of commands:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This is an example of three standard Linux commands that could give useful information
    back to the attacker. Note that there's an assumption here that the target server
    is running Linux. Use scripts from the previous chapters for reconnaissance, in
    order to determine the target's operating system and replace the commands in this
    array with Windows equivalents, if necessary.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we have the main `for` loop:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This part of code executes the command and grabs the output from `subprocess`
    (piping both standard out and standard error into a single `subprocess.PIPE`).
    It then adds the result to the out dictionary. Notice that we use a `try` and
    `except` statement here, as any command that fails to run will cause an exception.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we have a single HTTP request:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This uses `urllib.encode` to transform the dictionary into URL encoded key/value
    pairs. This means that any characters that could affect the URL, for example,
    `&` or `=`, will be converted to their URL encoded equivalent, for example, `%26`
    and `%3D`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that there will be no output on the script side; everything is passed
    over in the HTTP request to the attacker''s web server (the example uses localhost
    on port `8000`). The `GET` request looks like the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/B04044_08_01.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
- en: Creating an HTTP C2
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The issue with brazenly presenting your commands in URLs is that even a half-asleep
    log analyst will spot it. There are multiple methods of hiding requests, but when
    you don't know what the response text is going to look like, you need to provide
    a solid method of disguising the output and returning it to your server.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: We will create a script that masks command and control activities as HTTP traffic,
    takes commands from comments on a web page, and returns the output into a guestbook.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Getting Started
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this, you will need a functioning web server with two pages, one to host
    your comments and one to host your retrieval page.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: 'Your comment page should just have standard content. For this, I''m using the
    Nginx default home page and adding comments to it at the end. A comment should
    be expressed as:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The retrieval page can be as simple as:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Basically, what this PHP does is take an incoming value in the `POST` request
    named `comment` and places it in a database. It's very rudimentary and does not
    distinguish between multiple incoming commands if you have multiple shells going.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The script we will be using is as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The following shows an example of the output produced when using this script:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: How it works…
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As ever, we import the necessary libraries and get the script going:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'As this script has a built-in self deletion method, we can set it up to run
    forever with the following loop:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We make a request to check whether there are any comments on our preconfigured
    page. If there are, we put them in a list. We use very basic `regex` to perform
    this check:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The first thing we do is check for an empty comment. This signifies to the
    script that it should delete itself, a very important mechanism for hands-off
    C2 scripts. If you wish the script to delete itself, just leave an empty comment
    on your page. The script deletes itself by looking for its own name and removing
    that name:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If the comment isn''t blank, we attempt to pass it to the system with the `subprocess`
    command. It''s important that you use .`split()` on the command to account for
    how `subprocess` handles multi-part commands. We use `.check_output` to return
    whatever output the command gives directly to the variable that we assign:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If the command fails, we set the response value to be `command failed`:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We take the `response` variable and assign it to a key that matches our PHP
    script in a dictionary. In this circumstance, the field name is `comment` and
    thus we assign our output to a comment. We base64 the output in order to account
    for any random variables, such as spaces or code that may interfere with our script:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now the data has been assigned, we send it in a `POST` request to our preconfigured
    server and wait `30` seconds to again check for further instructions in the comments:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Creating an FTP C2
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This script is a quick and dirty file-theft tool. It runs in a straight line
    up the directories, nabbing everything it comes into contact with. It then exports
    these to an `FTP` directory that it's pointed at. In situations where you can
    drop a file and want to quickly get the contents of the server, this is ideal
    as a starting point.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: We will create a script that connects to an FTP, grabs the files in the current
    directory, and exports them to the FTP. It then jumps up into the next directory
    and repeats. When it encounters two directory listings that are the same (that
    is, it has hit the root), it stops.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Getting Started
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this, you will need a functioning FTP server. I'm using `vsftpd`, but you
    may use whatever you please. You'll need to either hard code the credentials into
    the script (not advisable) or send them with the credentials as flags.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The script we will be using is as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: How it works…
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As ever, we import our libraries and set up our variables. We have set the
    username and password as `sys.argv` to avoid having to hard code and therefore
    expose our systems:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We then connect to our FTP with an IP address and the credentials we set up
    through the flags. You can also pass the IP as `sys.argv` to avoid hard-coding:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'I''ve set up a nonce value that won''t match the first directory for the directory
    checking method. We also set the loop as `0` and configure the "up directory"
    command as a variable, similar to the directory traversal script in [Chapter 3](ch03.html
    "Chapter 3. Vulnerability Identification"), *Vulnerability Identification*:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We then create our main loop to repeat forever and create our chosen directory
    call. We list the files in the directory we call and assign it a variable. You
    can opt to print the file listing here if you wish, as I have for diagnostic purposes,
    but it makes no difference:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'For each file detected in the directory, we attempt to open it. It''s important
    we open the file with `rb` as this allows it to be read as a binary, making it
    available to be transferred as a binary. If it''s openable, we transfer it to
    the FTP with the `storbinary` command. We then close the file to complete the
    transaction:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If, for whatever reason, we can''t open or transfer the file, we simply move
    on to the next one in the list:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We then check to see whether we have changed directories since the last command.
    If not, we break out of the main loop:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If the directory listing doesn''t match, we set the `filecheck` variable to
    match the current directory, iterate the loop by `1`, and sleep for `10` seconds
    to avoid spamming the server:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Finally, once everything else is complete, we close our connection to the FTP
    server:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Creating an Twitter C2
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up to a certain point, requesting random pages on the Internet is passable but
    once a **Security Operation Centre** (**SOC**) analyst takes a closer look at
    all the data that's vanishing up the tubes, it's going to be obvious that the
    requests are going to a dodgy site and therefore are likely associated with malicious
    traffic. Fortunately, social media helps out in this regard and allows us to hide
    data in plain sight.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: We will create a script that connects to Twitter, reads tweets, performs commands
    based on those tweets, encrypts the response data, and posts it to Twitter. We'll
    also make a decode script.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Getting Started
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this, you will need a Twitter account with an API key.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The script we will be using is as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The decoding script is as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'An example of what the script in progress looks like is as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](img/B04044_08_02.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
- en: How it works…
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We import our libraries, as usual. There are numerous Twitter Python libraries;
    I''m just using the standard twitter API available at [https://code.google.com/p/python-twitter/](https://code.google.com/p/python-twitter/).
    The code is as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'To meet the Twitter authentication requirements, we need to need to retrieve
    the **App token**, **App secret**, **User token**, and **User secret** from our
    **App page** at [developer.twitter.com](http://developer.twitter.com). We assign
    them to variables and set up our connection to the Twitter API:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We set up an infinite loop:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We call the user timeline of the account that has been set up. It''s important
    that this App has both read and write privileges for the Twitter account. We then
    take the last text of the most recent tweet. We need to encode it as UTF-8 as
    there are often characters that the normal encoding won''t be able to handle:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We then take the oxt-last tweet to use as the key for our encryption. We encode
    it as `hex` to avoid there being things like spaces matching with spaces:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We carry out the action by using the `subprocess` function. We encrypt the
    output with preset up XORing encryption and encode it as base64:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We split the encrypted and encoded response into 140 character chunks, to allow
    for the Twitter character cap. For each chunk, we create a Twitter status:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Because each step requires two tweets, I''ve left an hour gap between each
    command check, but it''s easy to change this for yourself:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'For the decoding, import the `RC4` library, set your key tweet as the key,
    and put your reassembled base64 as the response:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Set up a new `RC4` code with the key, decode the data from base64, and decrypt
    it with the key:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Creating a simple Netcat shell
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following script we're going to create leverages the use of raw sockets
    to exfiltrate data from a network. The general idea of this shell is to create
    a connection between the compromised machine and your own machine through a Netcat
    (or other program) session and send commands to the machine this way.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: The beauty of this Python script is the undetectable nature of it, as it appears
    as a completely legitimate script.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is the script that will establish a connection through Netcat and read
    the input:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: How it works…
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To start the script as normal, we need to import our modules that will be used
    throughout the script:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We then need to define our variables: these values are the IP and port of the
    attacking machine to establish a connection with:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We then move on to defining the original connection; we can then assign a value
    to our established value and refer to this later on to read the input and send
    the standard output.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: 'We refer back to the host and port value that we previously set and create
    the connection. We assign the established connection the value of `go`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们回顾一下之前设置的主机和端口值，并创建连接。我们将已建立的连接赋予`go`的值：
- en: '[PRE42]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We can then introduce the block of code that will do the waiting portion for
    us. This will be awaiting commands to be sent to it through the attacking machine's
    Netcat session. We ensure that data that gets sent through the session is piped
    into the shell and the standard output of this is then returned to us through
    the established Netcat session, thus giving us shell access through our reverse
    connection.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以引入一段代码，用于等待部分。这将通过攻击机的Netcat会话等待发送给它的命令。我们确保通过会话发送的数据被导入到shell中，并且其标准输出通过已建立的Netcat会话返回给我们，从而通过反向连接为我们提供shell访问权限。
- en: 'We give the name data to the values that are passed to the compromised machine
    through the Netcat session. A value is added to the script to exit the session
    when the user is done; we''ve chosen `exit` for this, which means entering exit
    into our Netcat session will terminate the established connection. We then get
    down to the nitty gritty parts in which the data is opened (read) and piped into
    the shell for us. Once this has been done, we ensure the `stdout` value is read
    and given a value of `stdout` (this could be anything), which we then send back
    to ourselves via the `go` session that we established earlier. The code is as
    follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们给通过Netcat会话传递给受损机器的值命名为数据。脚本中添加了一个值，用于在用户完成操作时退出会话；我们选择了`exit`，这意味着在Netcat会话中输入exit将终止已建立的连接。然后，我们开始处理数据的细节部分，其中数据被打开（读取）并被导入到shell中。完成后，我们确保读取`stdout`值并赋予一个值`stdout`（这可以是任何值），然后通过之前建立的`go`会话将其发送回给我们自己。代码如下：
- en: '[PRE43]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The final portion of our script is our error-checking and running portion.
    Before the script runs, we make sure we let Python know that we have a mechanism
    in place to check whether the session is active by using our previous true statement.
    If the connection is lost, the Python script will attempt to re-establish a connection
    with the attacking machine, making it a persistent backdoor:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们脚本的最后部分是错误检查和运行部分。在脚本运行之前，我们确保让Python知道我们有一个机制来检查会话是否处于活动状态，方法是使用我们之前的真实语句。如果连接丢失，Python脚本将尝试重新与攻击机建立连接，使其成为一个持久的后门：
- en: '[PRE44]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
