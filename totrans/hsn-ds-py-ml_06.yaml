- en: Recommender Systems
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's talk about my personal area of expertiseâ€”recommender systems, so systems
    that can recommend stuff to people based on what everybody else did. We'll look
    at some examples of this and a couple of ways to do it. Specifically, two techniques
    called user-based and item-based collaborative filtering. So, let's dive in.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'I spent most of my career at [amazon.com](http://amazon.com) and [imdb.com](http://imdb.com),
    and a lot of what I did there was developing recommender systems; things like
    *people who bought this also bought*, or *recommended for you*, and things that
    did movie recommendations for people. So, this is something I know a lot about
    personally, and I hope to share some of that knowledge with you. We''ll walk through,
    step by step, covering the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: What are recommender systems?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User-based collaborative filtering
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Item-based collaborative filtering
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding movie similarities
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making movie recommendations to people
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improving the recommender's results
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are recommender systems?
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Well, like I said Amazon is a great example, and one I'm very familiar with.
    So, if you go to their recommendations section, as shown in the following image,
    you can see that it will recommend things that you might be interested in purchasing
    based on your past behavior on the site.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e3f5a477-dc07-4d71-91b0-2e162b81c327.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
- en: The recommender system might include things that you've rated, or things that
    you bought, and other data as well. I can't go into the details because they'll
    hunt me down, and you know, do bad things to me. But, it's pretty cool. You can
    also think of the *people who bought this also bought* feature on Amazon as a
    form of recommender system.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: The difference is that the recommendations you're seeing on your Amazon recommendations
    page are based on all of your past behavior, whereas people *who bought this also
    bought* or *people who viewed this also viewed*, things like that, are just based
    on the thing you're looking at right now, and showing you things that are similar
    to it that you might also be interested in. And, it turns out, what you're doing
    right now is probably the strongest signal of your interest anyhow.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: 'Another example is from Netflix, as shown in the following image (the following
    image is a screenshot from Netflix):'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f8319d5d-76ea-47f6-9d37-d54a0170f30b.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
- en: They have various features that try to recommend new movies or other movies
    you haven't seen yet, based on the movies that you liked or watched in the past
    as well, and they break that down by genre. They have kind of a different spin
    on things, where they try to identify the genres or the types of movies that they
    think you're enjoying the most and they then show you more results from those
    genres. So, that's another example of a recommender system in action.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: The whole point of it is to help you discover things you might not know about
    before, so it's pretty cool. You know, it gives individual movies, or books, or
    music, or whatever, a chance to be discovered by people who might not have heard
    about them before. So, you know, not only is it cool technology, it also kind
    of levels the playing field a little bit, and helps new items get discovered by
    the masses. So, it plays a very important role in today's society, at least I'd
    like to think so! There are few ways of doing this, and we'll look at the main
    ones in this chapter.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: User-based collaborative filtering
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, let''s talk about recommending stuff based on your past behavior. One
    technique is called user-based collaborative filtering, and here''s how it works:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Collaborative filtering, by the way, is just a fancy name for saying recommending
    stuff based on the combination of what you did and what everybody else did, okay?
    So, it's looking at your behavior and comparing that to everyone else's behavior,
    to arrive at the things that might be interesting to you that you haven't heard
    of yet.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: The idea here is we build up a matrix of everything that every user has ever
    bought, or viewed, or rated, or whatever signal of interest that you want to base
    the system on. So basically, we end up with a row for every user in our system,
    and that row contains all the things they did that might indicate some sort of
    interest in a given product. So, picture a table, I have users for the rows, and
    each column is an item, okay? That might be a movie, a product, a web page, whatever;
    you can use this for many different things.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: I then use that matrix to compute the similarity between different users. So,
    I basically treat each row of this as a vector and I can compute the similarity
    between each vector of users, based on their behavior.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Two users who liked mostly the same things would be very similar to each other
    and I can then sort this by those similarity scores. If I can find all the users
    similar to you based on their past behavior, I can then find the users most similar
    to me, and recommend stuff that they liked that I didn't look at yet.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s look at a real example, and it''ll make a little bit more sense:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6934cbac-7e47-42d5-b5ab-de9465b3144d.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
- en: Let's say that this nice lady in the preceding image watched Star Wars and The
    Empire Strikes Back and she loved them both. So, we have a user vector, of this
    lady, giving a 5-star rating to Star Wars and The Empire Strikes Back.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: Let's also say Mr. Edgy Mohawk Man comes along and he only watched Star Wars.
    That's the only thing he's seen, he doesn't know about The Empire Strikes Back
    yet, somehow, he lives in some strange universe where he doesn't know that there
    are actually many, many Star Wars movies, growing every year in fact.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: We can of course say that this guy's actually similar to this other lady because
    they both enjoyed Star Wars a lot, so their similarity score is probably fairly
    good and we can say, okay, well, what has this lady enjoyed that he hasn't seen
    yet? And, The Empire Strikes Back is one, so we can then take that information
    that these two users are similar based on their enjoyment of Star Wars, find that
    this lady also liked The Empire Strikes Back, and then present that as a good
    recommendation for Mr. Edgy Mohawk Man.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: We can then go ahead and recommend The Empire Strikes Back to him and he'll
    probably love it, because in my opinion, it's actually a better film! But I'm
    not going to get into geek wars with you here.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Limitations of user-based collaborative filtering
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, unfortunately, user-based collaborative filtering has some limitations.
    When we think about relationships and recommending things based on relationships
    between items and people and whatnot, our mind tends to go on relationships between
    people. So, we want to find people that are similar to you and recommend stuff
    that they liked. That''s kind of the intuitive thing to do, but it''s not the
    best thing to do! The following is the list of some limitations of user-based
    collaborative filtering:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: One problem is that people are fickle; their tastes are always changing. So,
    maybe that nice lady in the previous example had sort of a brief science fiction
    action film phase that she went through and then she got over it, and maybe later
    in her life she started getting more into dramas or romance films or romcoms.
    So, what would happen if my Edgy Mohawk guy ended up with a high similarity to
    her just based on her earlier sci-fi period, and we ended up recommending romantic
    comedies to him as a result? That would be bad. I mean, there is some protection
    against that in terms of how we compute the similarity scores to begin with, but
    it still pollutes our data that people's tastes can change over time. So, comparing
    people to people isn't always a straightforward thing to do, because people change.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The other problem is that there's usually a lot more people than there are things
    in your system, so 7 billion people in the world and counting, there's probably
    not 7 billion movies in the world, or 7 billion items that you might be recommending
    out of your catalog. The computational problem finding all the similarities between
    all of the users in your system is probably much greater than the problem of finding
    similarities between the items in your system. So, by focusing the system on users,
    you're making your computational problem a lot harder than it might need to be,
    because you have a lot of users, at least hopefully you do if you're working for
    a successful company.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个问题是在你的系统中通常会有比物品更多的人，全球有70亿人口，而且还在增加，世界上可能并不会有70亿部电影，或者你的目录中可能不会有70亿个物品需要推荐。在你的系统中找到所有用户之间的相似性可能比找到物品之间的相似性更困难。因此，通过将系统重点放在用户上，你让计算问题变得更加困难，因为你有很多用户，至少希望如此，如果你在一家成功的公司工作的话。
- en: The final problem is that people do bad things. There's a very real economic
    incentive to make sure that your product or your movie or whatever it is gets
    recommended to people, and there are people who try to game the system to make
    that happen for their new movie, or their new product, or their new book, or whatever.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一个问题是人们会做坏事。确保你的产品、电影或其他任何东西被推荐给人们有着非常现实的经济激励，有些人会试图操纵系统，让他们的新电影、新产品或新书等被推荐。
- en: It's pretty easy to fabricate fake personas in the system by creating a new
    user and having them do a sequence of events that likes a lot of popular items
    and then likes your item too. This is called a **shilling attack**, and we want
    to ideally have a system that can deal with that.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在系统中制造假身份非常容易，只需创建一个新用户，让他们执行一系列喜欢很多流行物品的事件，然后也喜欢你的物品。这被称为**炒作攻击**，我们希望能够拥有一个能够处理这种情况的系统。
- en: There is research around how to detect and avoid these shilling attacks in user-based
    collaborative filtering, but an even better approach would be to use a totally
    different approach entirely that's not so susceptible to gaming the system.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 关于如何检测和避免基于用户的协同过滤中的炒作攻击有研究，但更好的方法是使用一种完全不容易被操纵系统的全新方法。
- en: That's user-based collaborative filtering. Again, it's a simple concept-you
    look at similarities between users based on their behavior, and recommend stuff
    that a user enjoyed that was similar to you, that you haven't seen yet. Now, that
    does have its limitations as we talked about. So, let's talk about flipping the
    whole thing on its head, with a technique called item-based collaborative filtering.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是基于用户的协同过滤。再次强调，这是一个简单的概念-你根据用户的行为相似性来推荐东西，推荐那些你还没有看过但与你喜欢的东西相似的东西。正如我们所讨论的，这也有其局限性。因此，让我们来谈谈用一种称为基于物品的协同过滤的技术来颠覆整个概念。
- en: Item-based collaborative filtering
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于物品的协同过滤
- en: Let's now try to address some of the shortcomings in user-based collaborative
    filtering with a technique called item-based collaborative filtering, and we'll
    see how that can be more powerful. It's actually one of the techniques that Amazon
    uses under the hood, and they've talked about this publicly so I can tell you
    that much, but let's see why it's such a great idea. With user-based collaborative
    filtering we base our recommendations on relationships between people, but what
    if we flip that and base them on relationships between items? That's what item-based
    collaborative filtering is.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们尝试用一种称为基于物品的协同过滤的技术来解决基于用户的协同过滤的一些缺点，我们将看到这种技术是如何更加强大的。实际上，这是亚马逊在幕后使用的技术之一，他们公开谈论过这一点，所以我可以告诉你这么多，但让我们看看为什么这是一个如此好的主意。基于用户的协同过滤是基于人与人之间的关系来进行推荐的，但如果我们将其转变为基于物品之间的关系呢？这就是基于物品的协同过滤。
- en: Understanding item-based collaborative filtering
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解基于物品的协同过滤
- en: This is going to draw on a few insights. For one thing, we talked about people
    being fickle-their tastes can change over time, so comparing one person to another
    person based on their past behavior becomes pretty complicated. People have different
    phases where they have different interests, and you might not be comparing the
    people that are in the same phase to each other. But, an item will always be whatever
    it is. A movie will always be a movie, it's never going to change. Star Wars will
    always be Star Wars, well until George Lucas tinkers with it a little bit, but
    for the most part, items do not change as much as people do. So, we know that
    these relationships are more permanent, and there's more of a direct comparison
    you can make when computing similarity between items, because they do not change
    over time.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这将涉及到一些见解。首先，我们谈到人们喜新厌旧，他们的口味会随时间改变，因此基于他们的过去行为来比较一个人和另一个人变得非常复杂。人们有不同的阶段，他们有不同的兴趣，你可能不会将处于相同阶段的人进行比较。但是，物品永远是什么它是的。一部电影永远是一部电影，它永远不会改变。星球大战永远是星球大战，至少在乔治·卢卡斯稍微改动一下之前是这样的，但总的来说，物品不会像人一样改变。因此，我们知道这些关系更加持久，而且在计算物品之间的相似性时可以进行更直接的比较，因为它们随时间不会改变。
- en: The other advantage is that there are generally fewer things that you're trying
    to recommend than there are people you're recommending to. So again, 7 billion
    people in the world, you're probably not offering 7 billion things on your website
    to recommend to them, so you can save a lot of computational resources by evaluating
    relationships between items instead of users, because you will probably have fewer
    items than you have users in your system. That means you can run your recommendations
    more frequently, make them more current, more up-to-date, and better! You can
    use more complicated algorithms because you have less relationships to compute,
    and that's a good thing!
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: It's also harder to game the system. So, we talked about how easy it is to game
    a user-based collaborative filtering approach by just creating some fake users
    that like a bunch of popular stuff and then the thing you're trying to promote.
    With item-based collaborative filtering that becomes much more difficult. You
    have to game the system into thinking there are relationships between items, and
    since you probably don't have the capability to create fake items with fake ties
    to other items based on many, many other users, it's a lot harder to game an item-based
    collaborative filtering system, which is a good thing.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: While I'm on the topic of gaming the system, another important thing is to make
    sure that people are voting with their money. A general technique for avoiding
    shilling attacks or people trying to game your recommender system, is to make
    sure that the signal behavior is based on people actually spending money. So,
    you're always going to get better and more reliable results when you base recommendations
    on what people actually bought, as opposed to what they viewed or what they clicked
    on, okay?
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: How item-based collaborative filtering works?
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Alright, let's talk about how item-based collaborative filtering works. It's
    very similar to user-based collaborative filtering, but instead of users, we're
    looking at items.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: So, let's go back to the example of movie recommendations. The first thing we
    would do is find every pair of movies that is watched by the same person. So,
    we go through and find every movie that was watched by identical people, and then
    we measure the similarity of all those people who viewed that movie to each other.
    So, by this means we can compute similarities between two different movies, based
    on the ratings of the people who watched both of those movies.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: So, let's presume I have a movie pair, okay? Maybe Star Wars and The Empire
    Strikes Back. I find a list of everyone who watched both of those movies, then
    I compare their ratings to each other, and if they're similar then I can say these
    two movies are similar, because they were rated similarly by people who watched
    both of them. That's the general idea here. That's one way to do it, there's more
    than one way to do it!
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: And then I can just sort everything by the movie, and then by the similarity
    strength of all the similar movies to it, and there's my results for *people who
    liked also liked*, or *people who rated this highly also rated this highly* and
    so on and so forth. And like I said, that's just one way of doing it.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s step one of item-based collaborative filtering-first I find relationships
    between movies based on the relationships of the people who watched every given
    pair of movies. It''ll make more sense when we go through the following example:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/74684baa-3636-45ba-b60d-f47a02bc9bd2.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
- en: For example, let's say that our nice young lady in the preceding image watched
    Star Wars and The Empire Strikes Back and liked both of them, so rated them both
    five stars or something. Now, along comes Mr. Edgy Mohawk Man who also watched
    Star Wars and The Empire Strikes Back and also liked both of them. So, at this
    point we can say there's a relationship, there is a similarity between Star Wars
    and The Empire Strikes Back based on these two users who liked both movies.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: What we're going to do is look at each pair of movies. We have a pair of Star
    Wars and Empire Strikes Back, and then we look at all the users that watched both
    of them, which are these two guys, and if they both liked them, then we can say
    that they're similar to each other. Or, if they both disliked them we can also
    say they're similar to each other, right? So, we're just looking at the similarity
    score of these two users' behavior related to these two movies in this movie pair.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的是查看每一对电影。我们有一对《星球大战》和《帝国反击战》，然后我们查看所有观看这两部电影的用户，这两个人，如果他们都喜欢这两部电影，那么我们可以说它们彼此相似。或者，如果他们都不喜欢，我们也可以说它们彼此相似，对吧？所以，我们只是在查看这两个用户与这对电影的相似度得分。
- en: So, along comes Mr. Moustachy Lumberjack Hipster Man and he watches The Empire
    Strikes Back and he lives in some strange world where he watched The Empire Strikes
    Back, but had no idea that Star Wars the first movie existed.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 然后来了一个留着小胡子的伐木工艺师，他看了《帝国反击战》，他生活在一个奇怪的世界，他看了《帝国反击战》，但不知道《星球大战》这部第一部电影的存在。
- en: '![](img/2729d221-c540-4873-aed9-f90fde537c91.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2729d221-c540-4873-aed9-f90fde537c91.png)'
- en: 'Well that''s fine, we computed a relationship between The Empire Strikes Back
    and Star Wars based on the behavior of these two people, so we know that these
    two movies are similar to each other. So, given that Mr. Hipster Man liked The
    Empire Strikes Back, we can say with good confidence that he would also like Star
    Wars, and we can then recommend that back to him as his top movie recommendation.
    Something like the following illustration:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，我们根据这两个人的行为计算了《帝国反击战》和《星球大战》之间的关系，所以我们知道这两部电影彼此相似。因此，鉴于小胡子先生喜欢《帝国反击战》，我们可以有信心地说他也会喜欢《星球大战》，然后我们可以将这部电影推荐给他作为他的首选电影推荐。就像下面的插图一样：
- en: '![](img/bfd19c04-77f4-45d7-a7f5-b37501dde222.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bfd19c04-77f4-45d7-a7f5-b37501dde222.png)'
- en: You can see that you end up with very similar results in the end, but we've
    kind of flipped the whole thing on its head. So, instead of focusing the system
    on relationships between people, we're focusing them on relationships between
    items, and those relationships are still based on the aggregate behavior of all
    the people that watch them. But fundamentally, we're looking at relationships
    between items and not relationships between people. Got it?
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到最终结果非常相似，但我们已经颠覆了整个事情的本质。所以，我们不再把系统的重点放在人与人之间的关系上，而是放在物品之间的关系上，而这些关系仍然是基于所有观看它们的人的集体行为。但从根本上讲，我们正在研究物品之间的关系，而不是人与人之间的关系。明白了吗？
- en: Collaborative filtering using Python
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Python进行协同过滤
- en: Alright, so let's do it! We have some Python code that will use Pandas, and
    all the various other tools at our disposal, to create movie recommendations with
    a surprisingly little amount of code.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，让我们开始吧！我们有一些Python代码，将使用Pandas和我们可以使用的各种其他工具，用非常少的代码创建电影推荐。
- en: The first thing we're going to do is show you item-based collaborative filtering
    in practice. So, we'll build up *people who watched also watched* basically, you
    know, *people who rated things highly also rated this thing highly*, so building
    up these movie to movie relationships. So, we're going to base it on real data
    that we got from the MovieLens project. So, if you go to MovieLens.org, there's
    actually an open movie recommender system there, where people can rate movies
    and get recommendations for new movies.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的第一件事是向你展示基于物品的协同过滤的实践。所以，我们将建立“看过这个电影的人也看过”的关系，基本上就是“喜欢某些东西的人也喜欢这个东西”，所以我们将基于我们从MovieLens项目中获得的真实数据来构建这些电影之间的关系。所以，如果你去MovieLens.org，那里实际上有一个开放的电影推荐系统，人们可以对电影进行评分，并获得新电影的推荐。
- en: 'And, they make all the underlying data publicly available for researchers like
    us. So, we''re going to use some real movie ratings data-it is a little bit dated,
    it''s like 10 years old, so keep that in mind, but it is real behavior data that
    we''re going to be working with finally here. And, we will use that to compute
    similarities between movies. And, that data in and of itself is useful. You can
    use that data to say *people who liked also liked*. So, let''s say I''m looking
    at a web page for a movie. the system can then say: *if you liked this movie,
    and given that you''re looking at it you''re probably interested in it, then you
    might also like these movies*. And that''s a form of a recommender system right
    there, even though we don''t even know who you are.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 他们将所有的基础数据公开供研究人员使用。因此，我们将使用一些真实的电影评分数据-它有点过时，大约是10年前的，所以请记住这一点，但这是我们最终要使用的真实行为数据。我们将使用这些数据来计算电影之间的相似性。这些数据本身就很有用。你可以使用这些数据来说“喜欢这部电影的人也喜欢……”。所以，假设我正在查看一部电影的网页。系统可以说：“如果你喜欢这部电影，并且考虑到你正在查看它，你可能也会喜欢这些电影。”即使我们不知道你是谁，这就是一种推荐系统的形式。
- en: Now, it is real-world data, so we're going to encounter some real-world problems
    with it. Our initial set of results aren't going to look good, so we're going
    to spend a little bit of extra time trying to figure out why, which is a lot of
    what you spend your time doing as a data scientist-correct those problems, and
    go back and run it again until we get results that makes sense.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这是真实世界的数据，所以我们将遇到一些真实世界的问题。我们最初的结果看起来不太好，所以我们将花一点额外的时间来尝试弄清楚原因，这正是作为数据科学家所花费时间的很大一部分-纠正这些问题，然后重新运行，直到得到有意义的结果。
- en: And finally, we'll actually do item-based collaborative filtering in its entirety,
    where we actually recommend movies to individuals based on their own behavior.
    So, let's do this, let's get started!
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将完全进行基于物品的协同过滤，根据个人的行为向他们推荐电影。所以，让我们开始吧！
- en: Finding movie similarities
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 寻找电影的相似性
- en: Let's apply the concept of item-based collaborative filtering. To start with,
    movie similarities-figure out what movies are similar to other movies. In particular,
    we'll try to figure out what movies are similar to Star Wars, based on user rating
    data, and we'll see what we get out of it. Let's dive in!
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: Okay so, let's go ahead and compute the first half of item-based collaborative
    filtering, which is finding similarities between items. Download and open the
    `SimilarMovies.ipynb` file.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0b57996b-9e77-449f-970c-42b1ca7f3f16.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
- en: In this case, we're going to be looking at similarities between movies, based
    on user behavior. And, we're going to be using some real movie rating data from
    the GroupLens project. GroupLens.org provides real movie ratings data, by real
    people who are using the [MovieLens.org](http://MovieLens.org) website to rate
    movies and get recommendations back for new movies that they want to watch.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: We have included the data files that you need from the GroupLens dataset with
    the course materials, and the first thing we need to do is import those into a
    Pandas DataFrame, and we're really going to see the full power of Pandas in this
    example. It's pretty cool stuff!
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the code
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first thing we're going to do is import the `u.data` file as part of the
    MovieLens dataset, and that is a tab-delimited file that contains every rating
    in the dataset.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note that you'll need to add the path here to where you stored the downloaded
    MovieLens files on your computer. So, the way that this works is even though we're
    calling `read_csv` on Pandas, we can specify a different separator than a comma.
    In this case, it's a tab.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re basically saying take the first three columns in the `u.data` file,
    and import it into a new DataFrame, with three columns: `user_id`, `movie_id`,
    and `rating`.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: What we end up with here is a DataFrame that has a row for every `user_id`,
    which identifies some person, and then, for every movie they rated, we have the
    `movie_id`, which is some numerical shorthand for a given movie, so Star Wars
    might be movie 53 or something, and their rating, you know, 1 to 5 stars. So,
    we have here a database, a DataFrame, of every user and every movie they rated,
    okay?
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: Now, we want to be able to work with movie titles, so we can interpret these
    results more intuitively, so we're going to use their human-readable names instead.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: If you're using a truly massive dataset, you'd save that to the end because
    you want to be working with numbers, they're more compact, for as long as possible.
    For the purpose of example and teaching, though, we'll keep the titles around
    so you can see what's going on.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'There''s a separate data file with the MovieLens dataset called `u.item`, and
    it is pipe-delimited, and the first two columns that we import will be the `movie_id`
    and the `title` of that movie. So, now we have two DataFrames: `r_cols` has all
    the user ratings and `m_cols` has all the titles for every `movie_id`. We can
    then use the magical `merge` function in Pandas to mush it all together.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Let's add a `ratings.head()` command and then run those cells. What we end up
    with is something like the following table. That was pretty quick!
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7e72bc4a-10dd-4530-a3a9-692349d14998.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
- en: We end up with a new DataFrame that contains the `user_id` and rating for each
    movie that a user rated, and we have both the `movie_id` and the `title` that
    we can read and see what it really is. So, the way to read this is `user_id` number
    `308` rated the `Toy Story (1995)` movie `4` stars, `user_id` number `287` rated
    the `Toy Story (1995)` movie `5` stars, and so on and so forth. And, if we were
    to keep looking at more and more of this DataFrame, we'd see different ratings
    for different movies as we go through it.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: 'Now the real magic of Pandas comes in. So, what we really want is to look at
    relationships between movies based on all the users that watched each pair of
    movies, so we need, at the end, a matrix of every movie, and every user, and all
    the ratings that every user gave to every movie. The `pivot_table` command in
    Pandas can do that for us. It can basically construct a new table from a given
    DataFrame, pretty much any way that you want it. For this, we can use the following
    code:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在Pandas的真正魔力显现出来了。因此，我们真正想要的是根据观看每对电影的所有用户之间的关系来查看电影之间的关系，因此最终我们需要一个包含每部电影、每个用户以及每个用户对每部电影的所有评分的矩阵。Pandas中的`pivot_table`命令可以为我们做到这一点。它基本上可以根据给定的DataFrame构建一个新表，几乎任何你想要的方式。为此，我们可以使用以下代码：
- en: '[PRE3]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: So, what we're saying with this code is-take our ratings DataFrame and create
    a new DataFrame called `movieRatings` and we want the index of it to be the user
    IDs, so we'll have a row for every `user_id`, and we're going to have every column
    be the movie title. So, we're going to have a column for every title that we encounter
    in that DataFrame, and each cell will contain the `rating` value, if it exists.
    So, let's go ahead and run it.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这段代码的意思是-取出我们的评分DataFrame并创建一个名为`movieRatings`的新DataFrame，我们希望它的索引是用户ID，所以我们将为每个`user_id`有一行，并且我们将每一列都是电影标题。因此，我们将为在该DataFrame中遇到的每个标题都有一列，并且如果存在的话，每个单元格将包含`rating`值。让我们继续运行它。
- en: 'And, we end up with a new DataFrame that looks like the following table:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们得到了一个新的DataFrame，看起来像下表：
- en: '![](img/2be0e510-8351-4be3-93c1-210bf6a1edef.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2be0e510-8351-4be3-93c1-210bf6a1edef.jpg)'
- en: It's kind of amazing how that just put it all together for us. Now, you'll see
    some `NaN` values, which stands for **Not a Number**, and its just how Pandas
    indicates a missing value. So, the way to interpret this is, `user_id` number
    `1`, for example, did not watch the movie `1-900 (1994)`, but `user_id` number
    `1` did watch `101 Dalmatians (1996)` and rated it `2` stars. The `user_id` number
    `1` also watched `12 Angry Men (1957)` and rated it `5` stars, but did not watch
    the movie `2 Days in the Valley (1996)`, for example, okay? So, what we end up
    with here is a sparse matrix basically, that contains every user, and every movie,
    and at every intersection where a user rated a movie there's a rating value.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这真是太神奇了，现在你会看到一些`NaN`值，代表**不是一个数字**，这就是Pandas表示缺失值的方式。因此，解释这个的方法是，例如，`user_id`编号`1`没有观看电影`1-900（1994）`，但`user_id`编号`1`观看了《101斑点狗》（1996）并给了它`2`星的评价。`user_id`编号`1`还观看了《愤怒的公牛》（1957）并给了它`5`星的评价，但没有观看电影《2天在山谷（1996）》，例如，明白了吗？因此，我们最终得到的是一个稀疏矩阵，其中包含了每个用户和每部电影，以及每个用户对每部电影的评分值。
- en: So, you can see now, we can very easily extract vectors of every movie that
    our user watched, and we can also extract vectors of every user that rated a given
    movie, which is what we want. So, that's useful for both user-based and item-based
    collaborative filtering, right? If I wanted to find relationships between users,
    I could look at correlations between these user rows, but if I want to find correlations
    between movies, for item-based collaborative filtering, I can look at correlations
    between columns based on the user behavior. So, this is where the real *flipping
    things on its head for user versus item-based similarities* comes into play.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，现在你可以看到，我们可以非常容易地提取出用户观看的每部电影的向量，也可以提取出每个评价了给定电影的用户的向量，这正是我们想要的。所以，这对基于用户和基于物品的协同过滤都很有用，对吧？如果我想要找到用户之间的关系，我可以查看这些用户行之间的相关性，但如果我想要找到电影之间的相关性，对于基于物品的协同过滤，我可以根据用户行为查看列之间的相关性。这就是真正*颠覆用户与基于物品相似性的*实现的地方。
- en: 'Now, we''re going with item-based collaborative filtering, so we want to extract
    columns, to do this let''s run the following code:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们要进行基于物品的协同过滤，所以我们要提取列，为此让我们运行以下代码：
- en: '[PRE4]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, with the help of that, let''s go ahead and extract all the users who rated
    `Star Wars (1977)`:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，借助这个，让我们继续提取所有评价了《星球大战（1977）》的用户：
- en: '![](img/a35302db-1296-42e7-aaee-6c24f1bb2954.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a35302db-1296-42e7-aaee-6c24f1bb2954.jpg)'
- en: And, we can see most people have, in fact, watched and rated `Star Wars (1977)`
    and everyone liked it, at least in this little sample that we took from the head
    of the DataFrame. So, we end up with a resulting set of user IDs and their ratings
    for `Star Wars (1977)`. The user ID `3` did not rate `Star Wars (1977)` so we
    have a `NaN` value, indicating a missing value there, but that's okay. We want
    to make sure that we preserve those missing values so we can directly compare
    columns from different movies. So, how do we do that?
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到大多数人实际上都观看并评价了《星球大战（1977）》，并且每个人都喜欢它，至少在我们从DataFrame的开头取出的这个小样本中是这样。因此，我们得到了一组用户ID及其对《星球大战（1977）》的评分。用户ID`3`没有对《星球大战（1977）》进行评分，因此我们有一个`NaN`值，表示那里有一个缺失值，但没关系。我们希望确保保留这些缺失值，以便我们可以直接比较不同电影的列。那么我们该如何做呢？
- en: The corrwith function
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: corrwith函数
- en: 'Well, Pandas keeps making it easy for us, and has a `corrwith` function that
    you can see in the following code that we can use:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，Pandas一直让我们很容易，它有一个`corrwith`函数，你可以在下面的代码中看到，我们可以使用它：
- en: '[PRE5]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'That code will go ahead and correlate a given column with every other column
    in the DataFrame, and compute the correlation scores and give that back to us.
    So, what we''re doing here is using `corrwith` on the entire `movieRatings` DataFrame,
    that''s that entire matrix of user movie ratings, correlating it with just the
    `starWarsRatings` column, and then dropping all of the missing results with `dropna`.
    So, that just leaves us with items that had a correlation, where there was more
    than one person that viewed it, and we create a new DataFrame based on those results
    and then display the top 10 results. So again, just to recap:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: We're going to build the correlation score between Star Wars and every other
    movie.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drop all the `NaN` values, so that we only have movie similarities that actually
    exist, where more than one person rated it.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: And, we're going to construct a new DataFrame from the results and look at the
    top 10 results.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'And here we are with the results shown in the following screenshot:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c4971b0b-0ab9-4c7c-b956-336877569bb4.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
- en: We ended up with this result of correlation scores between each individual movie
    for Star Wars and we can see, for example, a surprisingly high correlation score
    with the movie `'Til There Was You (1997)`, a negative correlation with the movie
    `1-900 (1994)`, and a very weak correlation with `101 Dalmatians (1996)`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: Now, all we should have to do is sort this by similarity score, and we should
    have the top movie similarities for Star Wars, right? Let's go ahead and do that.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Just call `sort_values` on the resulting DataFrame, again Pandas makes it really
    easy, and we can say `ascending=False`, to actually get it sorted in reverse order
    by correlation score. So, let''s do that:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c3283e10-bc89-4e89-b2df-228c29a90a9a.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
- en: 'Okay, so `Star Wars (1977)` came out pretty close to top, because it is similar
    to itself, but what''s all this other stuff? What the heck? We can see in the
    preceding output, some movies such as: `Full Speed (1996)`, `Man of the Year (1995)`,
    `The Outlaw (1943)`. These are all, you know, fairly obscure movies, that most
    of them I''ve never even heard of, and yet they have perfect correlations with
    Star Wars. That''s kinda weird! So, obviously we''re doing something wrong here.
    What could it be?'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: Well, it turns out there's a perfectly reasonable explanation, and this is a
    good lesson in why you always need to examine your results when you're done with
    any sort of data science task-question the results, because often there's something
    you missed, there might be something you need to clean in your data, there might
    be something you did wrong. But you should also always look skeptically at your
    results, don't just take them on faith, okay? If you do so, you're going to get
    in trouble, because if I were to actually present these as recommendations to
    people who liked Star Wars, I would get fired. Don't get fired! Pay attention
    to your results! So, let's dive into what went wrong in our next section.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Improving the results of movie similarities
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's figure out what went wrong with our movie similarities there. We went
    through all this exciting work to compute correlation scores between movies based
    on their user ratings vectors, and the results we got kind of sucked. So, just
    to remind you, we looked for movies that are similar to Star Wars using that technique,
    and we ended up with a bunch of weird recommendations at the top that had a perfect
    correlation.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: And, most of them were very obscure movies. So, what do you think might be going
    on there? Well, one thing that might make sense is, let's say we have a lot of
    people watch Star Wars and some other obscure film. We'd end up with a good correlation
    between these two movies because they're tied together by Star Wars, but at the
    end of the day, do we really want to base our recommendations on the behavior
    of one or two people that watch some obscure movie?
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Probably not! I mean yes, the two people in the world, or whatever it is, that
    watch the movie Full Speed, and both liked it in addition to Star Wars, maybe
    that is a good recommendation for them, but it's probably not a good recommendation
    for the rest of the world. We need to have some sort of confidence level in our
    similarities by enforcing a minimum boundary of how many people watched a given
    movie. We can't make a judgment that a given movie is good just based on the behavior
    of one or two people.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s try to put that insight into action using the following code:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: What we're going to do is try to identify the movies that weren't actually rated
    by many people and we'll just throw them out and see what we get. So, to do that
    we're going to take our original ratings DataFrame and we're going to say `groupby('title')`,
    again Pandas has all sorts of magic in it. And, this will basically construct
    a new DataFrame that aggregates together all the rows for a given title into one
    row.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: 'We can say that we want to aggregate specifically on the rating, and we want
    to show both the size, the number of ratings for each movie, and the mean average
    score, the mean rating for that movie. So, when we do that, we end up with something
    like the following:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4dd625f7-1287-4e3e-bdbb-2980fd513f4c.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
- en: This is telling us, for example, for the movie `101 Dalmatians (1996)`, `109`
    people rated that movie and their average rating was 2.9 stars, so not that great
    of a score really! So, if we just eyeball this data, we can say okay well, movies
    that I consider obscure, like `187 (1997)`, had `41` ratings, but `101 Dalmatians
    (1996)`, I've heard of that, you know `12 Angry Men (1957)`, I've heard of that.
    It seems like there's sort of a natural cutoff value at around 100 ratings, where
    maybe that's the magic value where things start to make sense.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go ahead and get rid of movies rated by fewer than 100 people, and yes,
    you know I''m kind of doing this intuitively at this point. As we''ll talk about
    later, there are more principled ways of doing this, where you could actually
    experiment and do train/test experiments on different threshold values, to find
    the one that actually performs the best. But initially, let''s just use our common
    sense and filter out movies that were rated by fewer than 100 people. Again, Pandas
    makes that really easy to do. Let''s figure it out with the following example:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We can just say `popularMovies`, a new DataFrame, is going to be constructed
    by looking at `movieStats` and we're going to only take rows where the rating
    size is greater than or equal to `100`, and I'm then going to sort that by `mean`
    rating, just for fun, to see the top rated, widely watched movies.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/990a039d-2541-4504-af34-cd6d9c7320de.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
- en: What we have here is a list of movies that were rated by more than 100 people,
    sorted by their average rating score, and this in itself is a recommender system.
    These are highly-rated popular movies. `A Close Shave (1995)`, apparently, was
    a really good movie and a lot of people watched it and they really liked it.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: So again, this is a very old dataset, from the late 90s, so even though you
    might not be familiar with the film `A Close Shave (1995)`, it might be worth
    going back and rediscovering it; add it to your Netflix! `Schindler's List (1993)`
    not a big surprise there, that comes up on the top of most top movies lists. `The
    Wrong Trousers (1993)`, another example of an obscure film that apparently was
    really good and was also pretty popular. So, some interesting discoveries there
    already, just by doing that.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Things look a little bit better now, so let's go ahead and basically make our
    new DataFrame of Star Wars recommendations, movies similar to Star Wars, where
    we only base it on movies that appear in this new DataFrame. So, we're going to
    use the `join` operation, to go ahead and join our original `similarMovies` DataFrame
    to this new DataFrame of only movies that have greater than 100 ratings, okay?
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this code, we create a new DataFrame based on `similarMovies` where we extract
    the `similarity` column, join that with our `movieStats` DataFrame, which is our
    `popularMovies` DataFrame, and we look at the combined results. And, there we
    go with that output!
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d6cd490d-abff-4766-9c8c-f0aebddb1ead.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
- en: 'Now we have, restricted only to movies that are rated by more than 100 people,
    the similarity score to Star Wars. So, now all we need to do is sort that using
    the following code:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here, we''re reverse sorting it and we''re just going to take a look at the
    first 15 results. If you run that now, you should see the following:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/906e7c92-d6fd-439f-b4e0-8878d5f3d4b1.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
- en: This is starting to look a little bit better! So, `Star Wars (1977)` comes out
    on top because it's similar to itself, `The Empire Strikes Back (1980)` is number
    2, `Return of the Jedi (1983)` is number 3, `Raiders of the Lost Ark (1981)`,
    number 4\. You know, it's still not perfect, but these make a lot more sense,
    right? So, you would expect the three Star Wars films from the original trilogy
    to be similar to each other, this data goes back to before the next three films,
    and `Raiders of the Lost Ark (1981)` is also a very similar movie to Star Wars
    in style, and it comes out as number 4\. So, I'm starting to feel a little bit
    better about these results. There's still room for improvement, but hey! We got
    some results that make sense, whoo-hoo!
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, ideally, we''d also filter out Star Wars, you don''t want to be looking
    at similarities to the movie itself that you started from, but we''ll worry about
    that later! So, if you want to play with this a little bit more, like I said 100
    was sort of an arbitrary cutoff for the minimum number of ratings. If you do want
    to experiment with different cutoff values, I encourage you to go back and do
    so. See what that does to the results. You know, you can see in the preceding
    table that the results that we really like actually had much more than 100 ratings
    in common. So, we end up with `Austin Powers: International Man of Mystery (1997)`
    coming in there pretty high with only `130` ratings so maybe 100 isn''t high enough!
    `Pinocchio (1940)` snuck in at `101`, not very similar to Star Wars, so, you might
    want to consider an even higher threshold there and see what it does.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: Please keep in mind too, this is a very small, limited dataset that we used
    for experimentation purposes, and it's based on very old data, so you're only
    going to see older movies. So, interpreting these results intuitively might be
    a little bit challenging as a result, but not bad results.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: Now let's move on and actually do full-blown item-based collaborative filtering
    where we recommend movies to people using a more complete system, we'll do that
    next.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: Making movie recommendations to people
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Okay, let's actually build a full-blown recommender system that can look at
    all the behavior information of everybody in the system, and what movies they
    rated, and use that to actually produce the best recommendation movies for any
    given user in our dataset. Kind of amazing and you'll be surprised how simple
    it is. Let's go!
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s begin using the `ItemBasedCF.ipynb` file and let''s start off by importing
    the MovieLens dataset that we have. Again, we''re using a subset of it that just
    contains 100,000 ratings for now. But, there are larger datasets you can get from
    GroupLens.org-up to millions of ratings; if you''re so inclined. Keep in mind
    though, when you start to deal with that really big data, you''re going to be
    pushing the limits of what you can do in a single machine and what Pandas can
    handle. Without further ado, here''s the first block of code:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Just like earlier, we're going to import the `u.data` file that contains all
    the individual ratings for every user and what movie they rated, and then we're
    going to tie that together with the movie titles, so we don't have to just work
    with numerical movie IDs. Go ahead and hit the run cell button, and we end up
    with the following DataFrame.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d21be30a-3a4f-417e-a1eb-abc86facef19.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
- en: The way to read this is, for example, `user_id` number `308` rated `Toy Story
    (1995)` a `4` star, and `user_id` number `66` rated `Toy Story (1995)` a `3` star.
    And, this will contain every rating, for every user, for every movie.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: 'And again, just like earlier, we use the wonderful `pivot_table` command in
    Pandas to construct a new DataFrame based on the information:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here, each row is the `user_id`, the columns are made up of all the unique
    movie titles in my dataset, and each cell contains a rating:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fb55cd2e-1591-44f9-8ca7-5eccca6cbdbe.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
- en: What we end up with is this incredibly useful matrix shown in the preceding
    output, that contains users for every row and movies for every column. And we
    have basically every user rating for every movie in this matrix. So, `user_id`
    number `1`, for example, gave `101 Dalmatians (1996)` a 2-star rating. And, again
    all these `NaN` values represent missing data. So, that just indicates, for example,
    `user_id` number `1` did not rate the movie `1-900 (1994)`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: Again, it's a very useful matrix to have. If we were doing user-based collaborative
    filtering, we could compute correlations between each individual user rating vector
    to find similar users. Since we're doing item-based collaborative filtering, we're
    more interested in relationships between the columns. So, for example, doing a
    correlation score between any two columns, which will give us a correlation score
    for a given movie pair. So, how do we do that? It turns out that Pandas makes
    that incredibly easy to do as well.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: It has a built-in `corr` function that will actually compute the correlation
    score for every column pair found in the entire matrix-it's almost like they were
    thinking of us.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Let's go ahead and run the preceding code. It's a fairly computationally expensive
    thing to do, so it will take a moment to actually come back with a result. But,
    there we have it!
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0780a7b9-67fc-4abf-b9f2-980fd8d6d900.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
- en: So, what do we have in the preceding output? We have here a new DataFrame where
    every movie is on the row, and in the column. So, we can look at the intersection
    of any two given movies and find their correlation score to each other based on
    this `userRatings` data that we had up here originally. How cool is that? For
    example, the movie `101 Dalmatians (1996)` is perfectly correlated with itself
    of course, because it has identical user rating vectors. But, if you look at `101
    Dalmatians (1996)` movie's relationship to the movie `12 Angry Men (1957)`, it's
    a much lower correlation score because those movies are rather dissimilar, makes
    sense, right?
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: I have this wonderful matrix now that will give me the similarity score of any
    two movies to each other. It's kind of amazing, and very useful for what we're
    going to be doing. Now just like earlier, we have to deal with spurious results.
    So, I don't want to be looking at relationships that are based on a small amount
    of behavior information.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: It turns out that the Pandas `corr` function actually has a few parameters you
    can give it. One is the actual correlation score method that you want to use,
    so I'm going to say use `pearson` correlation.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You''ll notice that it also has a `min_periods` parameter you can give it,
    and that basically says I only want you to consider correlation scores that are
    backed up by at least, in this example, 100 people that rated both movies. Running
    that will get rid of the spurious relationships that are based on just a handful
    of people. The following is the matrix that we get after running the code:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/be91ed35-4a07-404c-888f-8997bbad50fd.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
- en: It's a little bit different to what we did in the item similarities exercise
    where we just threw out any movie that was rated by less than 100 people. What
    we're doing here, is throwing out movie similarities where less than 100 people
    rated both of those movies, okay? So, you can see in the preceding matrix that
    we have a lot more `NaN` values.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: In fact, even movies that are similar to themselves get thrown out, so for example,
    the movie `1-900 (1994)` was, presumably, watched by fewer than 100 people so
    it just gets tossed entirely. The movie, `101 Dalmatians (1996)` however, survives
    with a correlation score of `1`, and there are actually no movies in this little
    sample of the dataset that are different from each other that had 100 people in
    common that watched both. But, there are enough movies that survive to get meaningful
    results.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: Understanding movie recommendations with an example
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, what we do with this data? Well, what we want to do is recommend movies
    for people. The way we do that is we look at all the ratings for a given person,
    find movies similar to the stuff that they rated, and those are candidates for
    recommendations to that person.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by creating a fake person to create recommendations for. I''ve
    actually already added a fake user by hand, ID number `0`, to the MovieLens dataset
    that we''re processing. You can see that user with the following code:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This gives the following output:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/723e6a27-f98b-476f-9fa4-a86eb43705e6.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
- en: That kind of represents someone like me, who loved Star Wars and The Empire
    Strikes Back, but hated the movie Gone with the Wind. So, this represents someone
    who really loves Star Wars, but does not like old style, romantic dramas, okay?
    So, I gave a rating of `5` star to `The Empire Strikes Back (1980)` and `Star
    Wars (1977)`, and a rating of `1` star to `Gone with the Wind (1939)`. So, I'm
    going to try to find recommendations for this fictitious user.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: So, how do I do that? Well, let's start by creating a series called `simCandidates`
    and I'm going to go through every movie that I rated.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: For `i` in range `0` through the number of ratings that I have in `myRatings`,
    I am going to add up similar movies to the ones that I rated. So, I'm going to
    take that `corrMatrix` DataFrame, that magical one that has all of the movie similarities,
    and I am going to create a correlation matrix with `myRatings`, drop any missing
    values, and then I am going to scale that resulting correlation score by how well
    I rated that movie.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: So, the idea here is I'm going to go through all the similarities for The Empire
    Strikes Back, for example, and I will scale it all by 5, because I really liked
    The Empire Strikes Back. But, when I go through and get the similarities for Gone
    with the Wind, I'm only going to scale those by 1, because I did not like Gone
    with the Wind. So, this will give more strength to movies that are similar to
    movies that I liked, and less strength to movies that are similar to movies that
    I did not like, okay?
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: 'So, I just go through and build up this list of similarity candidates, recommendation
    candidates if you will, sort the results and print them out. Let''s see what we
    get:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0178ab85-f77e-49f4-8fc6-84cad1b327ac.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
- en: Hey, those don't look too bad, right? So, obviously `The Empire Strikes Back
    (1980)` and `Star Wars (1977)` come out on top, because I like those movies explicitly,
    I already watched them and rated them. But, bubbling up to the top of the list
    is `Return of the Jedi (1983)`, which we would expect and `Raiders of the Lost
    Ark (1981)`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: Let's start to refine these results a little bit more. We're seeing that we're
    getting duplicate values back. If we have a movie that was similar to more than
    one movie that I rated, it will come back more than once in the results, so we
    want to combine those together. If I do in fact have the same movie, maybe that
    should get added up together into a combined, stronger recommendation score. Return
    of the Jedi, for example, was similar to both Star Wars and The Empire Strikes
    Back. How would we do that?
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Using the groupby command to combine rows
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll go ahead and explore that. We''re going to use the `groupby` command
    again to group together all of the rows that are for the same movie. Next, we
    will sum up their correlation score and look at the results:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Following is the result:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e89d095e-95a3-4e15-91f4-246750914a92.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
- en: Hey, this is looking really good!
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: So `Return of the Jedi (1983)` comes out way on top, as it should, with a score
    of 7, `Raiders of the Lost Ark (1981)` a close second at 5, and then we start
    to get to `Indiana Jones and the Last Crusade (1989)`, and some more movies, `The
    Bridge on the River Kwai (1957)`, `Back to the Future (1985),``The Sting (1973`).
    These are all movies that I would actually enjoy watching! You know, I actually
    do like old-school Disney movies too, so `Cinderella (1950)` isn't as crazy as
    it might seem.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we need to do is filter out the movies that I've already rated,
    because it doesn't make sense to recommend movies you've already seen.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Removing entries with the drop command
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So, I can quickly drop any rows that happen to be in my original ratings series
    using the following code:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Running that will let me see the final top 10 results:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d3be67f7-7bc8-4daf-8fe9-6f1d17e304ec.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
- en: And there we have it! `Return of the Jedi (1983)`, `Raiders of the Lost Ark
    (1981)`, `Indiana Jones and the Last Crusade (1989)`, all the top results for
    my fictitious user, and they all make sense. I'm seeing a few family-friendly
    films, you know, `Cinderella (1950)`, `The Wizard of Oz (1939)`, `Dumbo (1941)`,
    creeping in, probably based on the presence of Gone with the Wind in there, even
    though it was weighted downward it's still in there, and still being counted.
    And, there we have our results, so. There you have it! Pretty cool!
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: We have actually generated recommendations for a given user and we could do
    that for any user in our entire DataFrame. So, go ahead and play with that if
    you want to. I also want to talk about how you can actually get your hands dirty
    a little bit more, and play with these results; try to improve upon them.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: There's a bit of an art to this, you know, you need to keep iterating and trying
    different ideas and different techniques until you get better and better results,
    and you can do this pretty much forever. I mean, I made a whole career out of
    it. So, I don't expect you to spend the next, you know, 10 years trying to refine
    this like I did, but there are some simple things you can do, so let's talk about
    that.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Improving the recommendation results
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As an exercise, I want to challenge you to go and make those recommendations
    even better. So, let's talk about some ideas I have, and maybe you'll have some
    of your own too that you can actually try out and experiment with; get your hands
    dirty, and try to make better movie recommendations.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: Okay, there's a lot of room for improvement still on these recommendation results.
    There's a lot of decisions we made about how to weigh different recommendation
    results based on your rating of that item that it came from, or what threshold
    you want to pick for the minimum number of people that rated two given movies.
    So, there's a lot of things you can tweak, a lot of different algorithms you can
    try, and you can have a lot of fun with trying to make better movie recommendations
    out of the system. So, if you're feeling up to it, I'm challenging you to go and
    do just that!
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: Here are some ideas on how you might actually try to improve upon the results
    in this chapter. First, you can just go ahead and play with the `ItembasedCF.ipynb`
    file and tinker with it. So, for example, we saw that the correlation method actually
    had some parameters for the correlation computation, we used Pearson in our example,
    but there are other ones you can look up and try out, see what it does to your
    results. We used a minimum period value of 100, maybe that's too high, maybe it's
    too low; we just kind of picked it arbitrarily. What happens if you play with
    that value? If you were to lower that for example, I would expect you to see some
    new movies maybe you've never heard of, but might still be a good recommendation
    for that person. Or, if you were to raise it higher, you would see, you know nothing
    but blockbusters.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes you have to think about what the result is that you want out of a
    recommender system. Is there a good balance to be had between showing people movies
    that they've heard of and movies that they haven't heard of? How important is
    discovery of new movies to these people versus having confidence in the recommender
    system by seeing a lot of movies that they have heard of? So again, there's sort
    of an art to that.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: We can also improve upon the fact that we saw a lot of movies in the results
    that were similar to Gone with the Wind, even though I didn't like Gone with the
    Wind. You know we weighted those results lower than similarities to movies that
    I enjoyed, but maybe those movies should actually be penalized. If I hated Gone
    with the Wind that much, maybe similarities to Gone with the Wind, like The Wizard
    of Oz, should actually be penalized and, you know lowered in their score instead
    of raised at all.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: That's another simple modification you can make and play around with. There
    are probably some outliers in our user rating dataset, what if I were to throw
    away people that rated some ridiculous number of movies? Maybe they're skewing
    everything. You could actually try to identify those users and throw them out,
    as another idea. And, if you really want a big project, if you really want to
    sink your teeth into this stuff, you could actually evaluate the results of this
    recommender engine by using the techniques of train/test. So, what if instead
    of having an arbitrary recommendation score that sums up the correlation scores
    of each individual movie, actually scale that down to a predicted rating for each
    given movie.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: If the output of my recommender system were a movie and my predicted rating
    for that movie, in a train/test system I could actually try to figure out how
    well do I predict movies that the user has in fact watched and rated before? Okay?
    So, I could set aside some of the ratings data and see how well my recommender
    system is able to predict the user's ratings for those movies. And, that would
    be a quantitative and principled way to measure the error of this recommender
    engine. But again, there's a little bit more of an art than a science to this.
    Even though the Netflix prize actually used that error metric, called root-mean-square
    error is what they used in particular, is that really a measure of a good recommender
    system?
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: Basically, you're measuring the ability of your recommender system to predict
    the ratings of movies that a person already watched. But isn't the purpose of
    a recommender engine to recommend movies that a person hasn't watched, that they
    might enjoy? Those are two different things. So unfortunately, it's not very easy
    to measure the thing you really want to be measuring. So sometimes, you do kind
    of have to go with your gut instinct. And, the right way to measure the results
    of a recommender engine is to measure the results that you're trying to promote
    through it.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: Maybe I'm trying to get people to watch more movies, or rate new movies more
    highly, or buy more stuff. Running actual controlled experiments on a real website
    would be the right way to optimize for that, as opposed to using train/test. So,
    you know, I went into a little bit more detail there than I probably should have,
    but the lesson is, you can't always think about these things in black and white.
    Sometimes, you can't really measure things directly and quantitatively, and you
    have to use a little bit of common sense, and this is an example of that.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: Anyway, those are some ideas on how to go back and improve upon the results
    of this recommender engine that we wrote. So, please feel free to tinker around
    with it, see if you can improve upon it however you wish to, and have some fun
    with it. This is actually a very interesting part of the book, so I hope you enjoy
    it!
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, go give it a try! See if you can improve on our initial results there. There's
    some simple ideas there to try to make those recommendations better, and some
    much more complicated ones too. Now, there's no right or wrong answer; I'm not
    going to ask you to turn in your work, and I'm not going to review your work.
    You know, you decide to play around with it and get some familiarity with it,
    and experiment, and see what results you get. That's the whole point - just to
    get you more familiar with using Python for this sort of thing, and get more familiar
    with the concepts behind item-based collaborative filtering.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: We've looked at different recommender systems in this chapter-we ruled out a
    user-based collaborative filtering system and dove straight in to an item-based
    system. We then used various functions from pandas to generate and refine our
    results, and I hope you've seen the power of pandas here.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll take a look at more advanced data mining and machine
    learning techniques including K-nearest neighbors. I look forward to explaining
    those to you and seeing how they can be useful.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
