- en: Working with Protocol Buffers and GRPC
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are going to enter the world of protocol buffers. We are
    going to discover the benefits of using protocol buffers instead of JSON, and
    where to use both. We will use Google's `proto` library to compile protocol buffers.
    We will try to write a few web services with protocol buffers that can talk to
    either Go, or other applications such as Python, NodeJS, and so on. Then, we will
    explain GRPC, an advanced simplified form of RPC. We will learn how GRPC and protocol
    buffers can help us build services that can be consumed by any client. We will
    also discuss HTTP/2 and its benefits over plain HTTP/1.1 JSON-based services.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'In short, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Protocol buffers introduction
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Format of the protocol buffers
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compilation process of a protobuf
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GRPC, a modern RPC library
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bidirectional streaming with GRPC
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting the code
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can get the code samples for this chapter from [https://github.com/narenaryan/gorestful/tree/master/chapter6](https://github.com/narenaryan/gorestful/tree/master/chapter6).
    This chapter's examples are a combination of single programs and projects. So,
    copy the respective directory to your `GOPATH` to run the code samples properly.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to protocol buffers
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'HTTP/1.1 is the standard that is adopted by the web community. In recent times,
    HTTP/2 is becoming more popular because of its advantages. Some of the benefits
    of using HTTP/2 are:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Encryption of data via TLS (HTTPS)
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compression of headers
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Single TCP connection
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fallback to HTTP/1.1
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support from all major browsers
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The technical definition from Google about protocol buffers is:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Protocol buffers are a flexible, efficient, automated mechanism for serializing
    structured data – think XML, but smaller, faster, and simpler. You define how
    you want your data to be structured once, then you can use special generated source
    code to easily write and read your structured data to and from a variety of data
    streams and using a variety of languages. You can even update your data structure
    without breaking deployed programs that are compiled against the "old" format.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: In Go, protocol buffers are coupled with HTTP/2\. They are a format like JSON
    but strictly typed, understandable only from the client to the server. First,
    we will understand why protobufs (short form of protocol buffers) exist and how
    to use them.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: 'Protocol buffers have many advantages over JSON/XML for serializing structured
    data, such as:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: They are simpler
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are 3 to 10 times smaller
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are 20 to 100 times faster
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are less ambiguous
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They generate data access classes that are easier to use programmatically
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Protocol buffer language
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A protocol buffer is a file with a minimalistic language syntax. We compile
    a protocol buffer and the target file is generated for a programming language.
    For example, in Go, the compiled file will be a `.go` file with structs mapping
    the protobuf file. In Java, a class file will be created. Think protocol buffer
    as the skeleton for data with a particular order. We need to know the types before
    jumping into the actual code. In order to make things easier, I am going to first
    show JSON and its equivalent in protocol buffers. Then, we will implement a solid
    example.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Here, we are going to use **proto3** as our protocol buffer version. There are
    slight variations in versions, but the latest one was released with improvements.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many types of protocol buffer elements. Some of them are:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Scalar values
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enumerations
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Default values
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nested values
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unknown types
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'First, let us see how to define a message type in a protobuf. Here, we try
    to define a simple network interface message:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The syntax may look new. In the preceding code, we were defining a message
    type called `NetworkInterface`.It has four fields: *index*, *maximum transmission
    unit (MTU)*, *name*, and *hardware address (MAC)*. If we wish to write the same
    in JSON, it would look like this:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The field names are changed to comply with the JSON style guide, but the essence
    and structure are the same. But, what are the sequential numbers (1,2,3,4) given
    to fields in the protobuf file? They are the ordering tags given to serialize
    and deserialize protocol buffer data between two systems. It is like hinting the
    protocol buffer encoding/decoding systems to write/read the data in that particular
    order, respectively. When the preceding protobuf file is compiled and the programming
    language target is generated, the protocol buffer message will be converted to
    a Go struct and fields are filled with empty default values.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Scalar values
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The types we assigned to the fields in the `networkInterface` message are scalar
    types. These types are similar to Go types and exactly match with them. For other
    programming languages, they will be converted to the respective types. A protobuf
    is designed keeping Go in mind, so the majority of types such as `int`, `int32`,
    `int64`, `string`, and `bool`are exactly the same, but a few vary. They are:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '| **Go type** | **Protobuf type** |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
- en: '| `float32` | `float` |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
- en: '| `float64` | `double` |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
- en: '| `uint32` | `fixed32` |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
- en: '| `uint64` | `fixed64` |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
- en: '| `[]byte` | `bytes` |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
- en: 'These things should be kept in mind while defining messages in protbuf files.
    Apart from that, we are free to use other Go types as normal scalar types. **Default
    values **are the values that will be filled with those types if the user doesn''t
    assign a value to those scalar values. We all know that in any given programming
    language, variables are defined and assigned. Defining allocates memory for the
    variable and assigning fills the variable with a value. In analogy, the scalar
    fields we defined in the preceding message will be assigned with default values.
    Let us see the default values for the given types:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '| **Protobuf type** | **Default value** |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
- en: '| `string` | `""` |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
- en: '| `bytes` | `empty bytes[]` |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
- en: '| `bool` | `false` |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
- en: '| `int`, `int32`, `int64`, `float`, `double` | `0` |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
- en: '| `enum` | `0` |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
- en: Since protocol buffers make an agreement between end systems using a data structure,
    they don't take additional space for keys in JSON.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: Enumerations and repeated fields
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Enumerations provide the ordering of numbers for a given set of elements. The
    default order of values is from zero to *n*. So, in protocol buffer messages,
    we can have an enumeration type. Let us see an example of the `enum`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'What if we need to assign the same values for the multiple enumeration members.
    Protobuf3 allows an option called **allow aliases **to assign two different members
    the same value. For example:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, `STARTED` and `RUNNING` both have a `1` tag. This means that both can
    have the same value in the data. If we try to remove duplicated values, we should
    also remove the `allow_alias`option. Otherwise, the proto compiler throws an error
    (we will see shortly what a proto compiler is).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '`Repeated` fields are the fields in the message of a protocol buffer that represent
    a list of items. In JSON, we have a list of elements for a given key. Similarly,
    repeated fields allow us to define an array/list of elements of a particular type:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the preceding code, the third field is a repeated field, which means it
    is an array/list of proxies. The value could be something such as `["100.104.112.10",
    "100.104.112.12"]`, and so on. Apart from repeated fields, we can also use other
    messages as types. It is analogous to nested JSON. For example, take a look at
    the following code:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We see we have a nested `innerJSON`as one of the members of `outerJSON`. How
    can we model the same thing in protobufs? We can do it using the nested messages,
    as shown in the following code:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, we are nesting the `Proxy` type into the `Site`. We will soon see a real
    example with all these types of fields.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: Compiling a protocol buffer with protoc
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Until now, we have discussed how to write a protocol buffer file that is previously
    written in JSON or another data format. But, how do we actually integrate it into
    our programs? Remember that protocol buffers are data formats, no more than that.
    They are a format of communication between various systems, similar to JSON. These
    are the practical steps we follow for using protobufs in our Go programs:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: Install the `protoc` command-line tool and the `proto` library.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a protobuf file with the `.proto` extension.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compile it to target a programming language (here, it is Go).
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import structs from the generated target file and serialize the data.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On a remote machine, receive the serialized data and decode it into a struct
    or class.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Take a look at the following diagram:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6db67127-8a0c-4e2e-b2c9-b4ae112087c7.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
- en: 'The first step is to install the `protobuf` compiler on our machine. For this,
    download the `protobuf` package from [https://github.com/google/protobuf/releases](https://github.com/google/protobuf/releases).
    On macOS X, we can install `protobuf` using this command:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'On Ubuntu or Linux, we can copy `protoc` to the `/usr/bin` folder:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'On Windows, we can just copy the executable (`.exe`) from [https://github.com/google/protobuf/releases/download/v3.3.0/protoc-3.3.0-win32.zip](https://github.com/google/protobuf/releases/download/v3.3.0/protoc-3.3.0-win32.zip) to
    the `PATH` environment variable. Let us write a simple protocol buffer to illustrate
    how to compile and use structs from the target file. Create a folder called `protofiles`
    in `$GOPATH/src/github.com/narenaryan` (this is the place for our Go projects)
    using the following command:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Here, create a file called `person.proto`, which models a person''s information.
    Add a few messages to it, as shown in the following code snippet:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We created two main messages called `AddressBook` and `Person`.`AddressBook`
    has a list of persons. A `Person` has a `name`, `id`, `email`, and `phone Number`. 
    In the second line, we declared the package as `protofiles` like this:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This tells the compiler to add the generating file in relation to the given
    package name. Go cannot consume this `.proto` file directly.  We need to compile
    it to a valid Go file. When compiled, this package name `protofiles` will be used
    to set the  package of the output file (Go in this case). To compile this protocol
    buffer file, traverse to the `protofiles` directory and run this command:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This command converts the given protocol buffer file(s) to the Go file(s) with
    the same name. You will see that, after running this command, there is a new file
    created in the same directory:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The new file name is `person.pb.go`.If we open and inspect this file, it contains
    the following important block:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This is just a part of that file. There will be many getter and setter methods
    created for the given structs such as `Person` and `AddressBook` in the output
    file. This code is automatically generated. We need to consume this code in the
    main program to create protocol buffer strings. Now, let us create a new directory
    called `protobufs`.This holds the `main.go` file that uses the `Person` struct
    from the `person.pb.go` file:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, for Go to serialize a struct to the protobinary format, we need to install
    the Go proto driver. Install it using the `go get` command:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'After this, let us compose `main.go`:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We are importing the **protocol buffer** (**pb**) from the `protofiles` package.
    There are structs that are mapped to the given protobuf in the `proto files.`
    We used the `Person` struct and initialized it. Then, we serialized the struct
    using the `proto.Marshal`function. If we run this program, the output looks like
    this:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The second output of marshaled data is not intuitive because the `proto` library
    serializes data into binary bytes. Another good thing about protocol buffers in
    Go is that the structs generated by compiling the proto files can be used to generate
    JSON on the fly. Let us modify the preceding example to this. Call it `main_json.go`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If we run this, it prints a JSON string that can be sent to any client that
    can understand JSON:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Any other language or platform can easily load this JSON string and use the
    data instantly. So, what is the benefit of using protocol buffers instead of JSON?
    First of all, protocol buffers are intended for two backend systems to communicate
    with each other with less overhead. Since the size of the binary is less than
    text, protocol marshaled data is of less size than JSON.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: By using protocol buffers we map both JSON and protocol buffer formats to the
    Go struct. This gives the best of both worlds by converting one format to another
    on the fly.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: But, protocol buffers are just a data format. They don't have any importance
    if we don't communicate. So here, protocol buffers are used to pass messages between
    two end systems in the form of RPC. We saw how RPC works and also created an RPC
    client and server in the previous chapters. Now, we are going to extend that knowledge
    to use **Google Remote Procedure Call** (**GRPC**) with protocol buffers to scale
    our microservice communications. A server and client, in this case, can talk with
    each other in protocol buffer format.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to GRPC
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GRPC is a transport mechanism that sends and receives messages between two systems.
    These two systems are traditionally a server and a client. As we described in
    the previous chapters, RPC can be implemented in Go for transferring JSON. We
    called it a JSON RPC service. Similarly, Google RPC is specially designed to transfer
    data in the form of protocol buffers.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: GRPC makes the service creation easy and elegant. It provides a nice set of
    APIs to define services and start running them. In this section, we will mainly
    focus on how to create a GRPC service and use it. The main advantage of GRPC is
    that it can be understood by multiple programming languages. Protocol buffers
    provide a common data structure. So, the combination enables the seamless communication
    between various tech stacks and systems. This is the integral concept of distributed
    computing.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: Square, Netflix, and so on leverage this GRPC to scale their huge traffic-prone
    services. Google's former product manager, Andrew Jessup, said in a conference
    that at Google, billions of GRPC calls are processed every single day. If any
    business organization needs to embrace what Google does, it too can handle the
    traffic demand with these tweaks in the services.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to install the `grpc` Go library and a `protoc-gen` plugin before writing
    the services. Install them using the following commands:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'GRPC has the following benefits over traditional HTTP/REST/JSON architecture:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: GRPC uses HTTP/2, which is a binary protocol
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Header compression is possible in HTTP/2, which means less overhead
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can multiplex many requests on one connection
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Usage of protobufs for strict typing of data
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Streaming of requests or responses is possible instead of request/response transactions
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Take a look at the following diagram:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8c77a0c5-6a5f-452f-b00f-d52b9b258101.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
- en: 'The diagram clearly shows that any backend system or mobile app can directly
    communicate to a GRPC server by firing a protocol buffer request. Let us write
    a money transaction service in Go using GRPC and protocol buffers. Here, we are
    going to show how the client and server can be implemented. The steps are:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: Create the protocol buffer file for the service and messages.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compile the protocol buffer file.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the generated Go package for creating a GRPC server.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a GRPC client that talks to the server.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For this project, create a folder called `datafiles` in your Go workspace (here,
    it is `$GOPATH/src/github.com/narenaryan/`):'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Create a file called `transaction.proto` in it with messages and a service
    defined. We will shortly see what a service is:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This is a minimalistic protocol buffer for a money transaction on the server.
    We already saw about message keywords in the proto file. The last keyword, `service`,
    is new to us. `service` tells GRPC to treat it as a service, and all the RPC methods
    will act as an interface for a server that implements this. A struct that implements
    a Go interface should implement all its functions. Now, let us compile this file:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This command is slightly bigger than the one we used previously. This is because
    here we are using the `protoc-gen-go` plugin. The command simply says to use data
    files as the input directory for proto files and use the same directory for outputting
    the target Go files. Now, if we see the filesystem, there will be two files:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, create two more directories for server and client logic in `$GOPATH/src/github.com/narenaryan/grpc_example`.
    The server implements the interface that is generated from the proto file:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, add a file called `server.go` to the `grpcServer` directory, which implements
    the transaction service:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: There are a lot of things happening in the preceding file. First, we imported
    all the necessary imports. The new ones here are `context` and `reflection`.Context
    is used to create a `context` variable, which lives throughout an RPC request's
    lifetime. Both of these libraries are used by GRPC for its internal functions.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: 'Before explaining the next sections, if we open the generated `transaction.pb.go`
    file, we can clearly see that there are two important things:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: The `RegisterMoneyTransactionServer` function
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `MakeTransaction` function as part of the  `MoneyTransactionServer` interface
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In order to implement a service, we need both of these things; `MakeTransaction`
    for the actual service functionality, and `RegisterMoneyTransactionServer` for
    registering the service (that is, create an RPC server to run on a port).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: 'The `in` variable of `MakeTransaction` has the RPC request details. It is basically
    a struct that maps to the `TransactionRequest` message we defined in the protocol
    buffer file. What returns from `MakeTransaction` is `TransactionResponse`.This
    function signature matches with the one we defined in the protocol buffer file
    initially:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, let us write a client. We can write a client (or) server in any programming
    language, but here we are writing both a client and server in Go for understanding
    the Go GRPC API. Add a file called `client.go` in the `grpcClient` directory:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This client is also using the `grpc`package. It uses an empty context called
    `context.Background()`to pass to the `MakeTransaction`function. The second argument
    of the function is the `TransactionRequest` struct:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'It clearly maps with the theory we discussed in the previous section. Now,
    let us run it and see the output. Open a new console and run the GRPC server by
    using the following command:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The TCP server starts listening on port `50051`. Now, open one more terminal/shell
    and start the client program that talks to this server:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'It prints the output of the successful transaction:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'At the same time, the server logs this message to the console:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Here, the client made a single request to the GRPC server and passed details
    of `From A/c` number, `To A/c` number, and `Amount`. The server picks those details,
    processes them, and sends a response back saying everything is fine.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Since I am running code samples on my machine, I have `narenaryan` as the project
    directory under [github.com](https://github.com/). You can replace it with any
    other name.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Bidirectional streaming with GRPC
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main advantage of GRPC over traditional HTTP/1.1 is that it uses a single
    TCP connection for sending and receiving multiple messages between the server
    and the client. We saw the example of a money transaction before. Another real-world
    use case is a GPS installed in a taxi. Here, the taxi is the client that sends
    its geographical points to the server along its route. Finally, the server can
    calculate the total fare amount depending on the time spent between points and
    the total distance.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Another such use case is when a server needs to notify the client whenever some
    processing is performed. This is called a server push model. The server can send
    a stream of results back when a client asked for them only once. This is different
    to polling, where the client requests something each and every time. This can
    be useful when there are a series of time-taking steps that need to be done. The
    GRPC client can escalate that job to the GRPC server. Then, the server takes its
    time and relays the message back to the client, which reads them and does something
    useful. Let us implement this.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: 'This concept is similar to WebSockets, but between any type of platform. Create
    a project called `serverPush`:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, write in `datafiles` a protocol buffer that is similar to the previous
    one:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We have two messages and one service defined in the protocol buffer file. The
    exciting part is in the service; we are returning a stream instead of a plain
    response:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The use case of this project is: *the client sends a money transfer request
    to the server, the server does a few tasks and sends those step details as a stream
    of responses back to the server*. Now, let us compile that proto file:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This creates a new file called `transaction.pb.go` in the `datafiles` directory.
    We use the definitions in this file in our server and client programs, which we
    will create shortly. Now, let us write the GRPC server code. This code is a bit
    different compared to the previous example because of the introduction of streams:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now, add this program to the file:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '`MakeTransaction`is the function that interests us. It takes a request and
    a stream as its arguments. In the function, we are looping through the number
    of steps (here, it is three), and performing the computation. The server is simulating
    the mock I/O or computation using the `time.Sleep`function:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This function sends a stream response from the server to the client. Now, let
    us compose the client program. This is also a bit different to the basic GRPC
    client that we saw in the preceding code. Create a new directory for the client
    program:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now, start writing the client logic in that file:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Here, `ReceiveStream`is the custom function we wrote for the sake of sending
    a request and receiving a stream of messages. It takes two arguments: `MoneyTransactionClient`and
    `TransactionRequest`.It uses the first argument to create a stream and starts
    listening to it. Whenever the server exhausts all the messages, the client will
    stop listening and terminate. Then, an `io.EOF` error will be returned if the
    client tries to receive messages. We are logging the responses collected from
    the GRPC server. The second argument, `TransactionRequest`,is used to send the
    request to the server for the first time. Now, running it will make it more clear
    to us. On terminal one, run the GRPC server:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'It will keep on listening for incoming requests. Now, run the client on the
    second terminal to see the action:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'This outputs the following to the console:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'At the same time, the server also logs its own messages on terminal one:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'This process happens in sync with the server. The client stays alive until
    all the streaming messages are sent back. The server can handle any number of
    clients at a given time. Every client request is considered as an individual entity.
    This is an example of the server sending a stream of responses. There are other
    cases that can also be implemented with protocol buffers and GRPC:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: The client sending streamed requests to get one final response from the server
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端发送流式请求，以从服务器获取最终响应。
- en: The client and server are both sending streamed requests and responses at the
    same time
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端和服务器都同时发送流式请求和响应
- en: The official GRPC team has provided a nice example of routing a taxi on GitHub.
    You can take a look at it to learn more about the functioning of bidirectional
    streams at
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 官方的GRPC团队在GitHub上提供了一个很好的出租车路线示例。您可以查看它以了解双向流的功能。
- en: '[https://github.com/grpc/grpc-go/tree/master/examples/route_guide](https://github.com/grpc/grpc-go/tree/master/examples/route_guide).'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/grpc/grpc-go/tree/master/examples/route_guide](https://github.com/grpc/grpc-go/tree/master/examples/route_guide)。'
- en: Summary
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we started our journey by understanding the basics of protocol
    buffers. Then, we came across the protocol buffers language, which has many types
    such as scalar, enumeration, and repeated types. We saw a few analogies between
    JSON and protocol buffers. We learned why protocol buffers are more memory efficient
    than the plain JSON data format. We defined a sample protocol buffer by simulating
    a network interface. The `message`keyword is used to define messages in a protocol
    buffer.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们从理解协议缓冲的基础知识开始我们的旅程。然后，我们遇到了协议缓冲语言，它有许多类型，如标量、枚举和重复类型。我们看到了JSON和协议缓冲之间的一些类比。我们了解了为什么协议缓冲比纯JSON数据格式更节省内存。我们通过模拟网络接口定义了一个样本协议缓冲。`message`关键字用于在协议缓冲中定义消息。
- en: Next, we installed the `protoc` compiler to compile our files written in the
    protocol buffer language. Then, we saw how to compile a `.proto` file to generate
    a `.go` file. This Go file has all the structs and interfaces for the main program
    to consume. Next, we wrote a protocol buffer for an address book and person.We
    saw how to use `grpc.Marshal`to serialize Go structs into binary, transmittable
    data. We also found out that the conversion from protocol buffer to JSON and vice
    versa is very easily achievable in Go.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们安装了`protoc`编译器来编译我们用协议缓冲语言编写的文件。然后，我们看到如何编译`.proto`文件以生成一个`.go`文件。这个Go文件包含了主程序消耗的所有结构和接口。接下来，我们为一个地址簿和人员编写了一个协议缓冲。我们看到了如何使用`grpc.Marshal`将Go结构序列化为二进制可传输数据。我们还发现，在Go中，协议缓冲与JSON之间的转换非常容易实现。
- en: We then moved to GRPC, an RPC technology from Google using protocol buffers.
    We saw the benefits of HTTP/2 and GRPC. We then defined a GRPC service and data
    in the form of protocol buffers. Next, we implemented a GRPC server and GRPC in
    respect to the file generated from `.proto`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们转向了使用协议缓冲的谷歌RPC技术GRPC。我们看到了HTTP/2和GRPC的好处。然后，我们定义了一个GRPC服务和协议缓冲形式的数据。接下来，我们实现了一个GRPC服务器和GRPC，关于从`.proto`生成的文件。
- en: GRPC provides a bidirectional and multiplexed transport mechanism. This means
    that it can use a single TCP connection for all its message transmissions. We
    implemented one such scenario where the client sends a message to a server and
    the server replies back with a stream of messages.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: GRPC提供了双向和多路传输机制。这意味着它可以使用单个TCP连接进行所有消息传输。我们实现了一个这样的场景，客户端向服务器发送消息，服务器回复一系列消息。
