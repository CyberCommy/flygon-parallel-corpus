- en: Working with Protocol Buffers and GRPC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are going to enter the world of protocol buffers. We are
    going to discover the benefits of using protocol buffers instead of JSON, and
    where to use both. We will use Google's `proto` library to compile protocol buffers.
    We will try to write a few web services with protocol buffers that can talk to
    either Go, or other applications such as Python, NodeJS, and so on. Then, we will
    explain GRPC, an advanced simplified form of RPC. We will learn how GRPC and protocol
    buffers can help us build services that can be consumed by any client. We will
    also discuss HTTP/2 and its benefits over plain HTTP/1.1 JSON-based services.
  prefs: []
  type: TYPE_NORMAL
- en: 'In short, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Protocol buffers introduction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Format of the protocol buffers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compilation process of a protobuf
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GRPC, a modern RPC library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bidirectional streaming with GRPC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting the code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can get the code samples for this chapter from [https://github.com/narenaryan/gorestful/tree/master/chapter6](https://github.com/narenaryan/gorestful/tree/master/chapter6).
    This chapter's examples are a combination of single programs and projects. So,
    copy the respective directory to your `GOPATH` to run the code samples properly.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to protocol buffers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'HTTP/1.1 is the standard that is adopted by the web community. In recent times,
    HTTP/2 is becoming more popular because of its advantages. Some of the benefits
    of using HTTP/2 are:'
  prefs: []
  type: TYPE_NORMAL
- en: Encryption of data via TLS (HTTPS)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compression of headers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Single TCP connection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fallback to HTTP/1.1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support from all major browsers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The technical definition from Google about protocol buffers is:'
  prefs: []
  type: TYPE_NORMAL
- en: Protocol buffers are a flexible, efficient, automated mechanism for serializing
    structured data – think XML, but smaller, faster, and simpler. You define how
    you want your data to be structured once, then you can use special generated source
    code to easily write and read your structured data to and from a variety of data
    streams and using a variety of languages. You can even update your data structure
    without breaking deployed programs that are compiled against the "old" format.
  prefs: []
  type: TYPE_NORMAL
- en: In Go, protocol buffers are coupled with HTTP/2\. They are a format like JSON
    but strictly typed, understandable only from the client to the server. First,
    we will understand why protobufs (short form of protocol buffers) exist and how
    to use them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Protocol buffers have many advantages over JSON/XML for serializing structured
    data, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: They are simpler
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are 3 to 10 times smaller
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are 20 to 100 times faster
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are less ambiguous
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They generate data access classes that are easier to use programmatically
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Protocol buffer language
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A protocol buffer is a file with a minimalistic language syntax. We compile
    a protocol buffer and the target file is generated for a programming language.
    For example, in Go, the compiled file will be a `.go` file with structs mapping
    the protobuf file. In Java, a class file will be created. Think protocol buffer
    as the skeleton for data with a particular order. We need to know the types before
    jumping into the actual code. In order to make things easier, I am going to first
    show JSON and its equivalent in protocol buffers. Then, we will implement a solid
    example.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we are going to use **proto3** as our protocol buffer version. There are
    slight variations in versions, but the latest one was released with improvements.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many types of protocol buffer elements. Some of them are:'
  prefs: []
  type: TYPE_NORMAL
- en: Scalar values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enumerations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Default values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nested values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unknown types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'First, let us see how to define a message type in a protobuf. Here, we try
    to define a simple network interface message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The syntax may look new. In the preceding code, we were defining a message
    type called `NetworkInterface`.It has four fields: *index*, *maximum transmission
    unit (MTU)*, *name*, and *hardware address (MAC)*. If we wish to write the same
    in JSON, it would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The field names are changed to comply with the JSON style guide, but the essence
    and structure are the same. But, what are the sequential numbers (1,2,3,4) given
    to fields in the protobuf file? They are the ordering tags given to serialize
    and deserialize protocol buffer data between two systems. It is like hinting the
    protocol buffer encoding/decoding systems to write/read the data in that particular
    order, respectively. When the preceding protobuf file is compiled and the programming
    language target is generated, the protocol buffer message will be converted to
    a Go struct and fields are filled with empty default values.
  prefs: []
  type: TYPE_NORMAL
- en: Scalar values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The types we assigned to the fields in the `networkInterface` message are scalar
    types. These types are similar to Go types and exactly match with them. For other
    programming languages, they will be converted to the respective types. A protobuf
    is designed keeping Go in mind, so the majority of types such as `int`, `int32`,
    `int64`, `string`, and `bool`are exactly the same, but a few vary. They are:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Go type** | **Protobuf type** |'
  prefs: []
  type: TYPE_TB
- en: '| `float32` | `float` |'
  prefs: []
  type: TYPE_TB
- en: '| `float64` | `double` |'
  prefs: []
  type: TYPE_TB
- en: '| `uint32` | `fixed32` |'
  prefs: []
  type: TYPE_TB
- en: '| `uint64` | `fixed64` |'
  prefs: []
  type: TYPE_TB
- en: '| `[]byte` | `bytes` |'
  prefs: []
  type: TYPE_TB
- en: 'These things should be kept in mind while defining messages in protbuf files.
    Apart from that, we are free to use other Go types as normal scalar types. **Default
    values **are the values that will be filled with those types if the user doesn''t
    assign a value to those scalar values. We all know that in any given programming
    language, variables are defined and assigned. Defining allocates memory for the
    variable and assigning fills the variable with a value. In analogy, the scalar
    fields we defined in the preceding message will be assigned with default values.
    Let us see the default values for the given types:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Protobuf type** | **Default value** |'
  prefs: []
  type: TYPE_TB
- en: '| `string` | `""` |'
  prefs: []
  type: TYPE_TB
- en: '| `bytes` | `empty bytes[]` |'
  prefs: []
  type: TYPE_TB
- en: '| `bool` | `false` |'
  prefs: []
  type: TYPE_TB
- en: '| `int`, `int32`, `int64`, `float`, `double` | `0` |'
  prefs: []
  type: TYPE_TB
- en: '| `enum` | `0` |'
  prefs: []
  type: TYPE_TB
- en: Since protocol buffers make an agreement between end systems using a data structure,
    they don't take additional space for keys in JSON.
  prefs: []
  type: TYPE_NORMAL
- en: Enumerations and repeated fields
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Enumerations provide the ordering of numbers for a given set of elements. The
    default order of values is from zero to *n*. So, in protocol buffer messages,
    we can have an enumeration type. Let us see an example of the `enum`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'What if we need to assign the same values for the multiple enumeration members.
    Protobuf3 allows an option called **allow aliases **to assign two different members
    the same value. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Here, `STARTED` and `RUNNING` both have a `1` tag. This means that both can
    have the same value in the data. If we try to remove duplicated values, we should
    also remove the `allow_alias`option. Otherwise, the proto compiler throws an error
    (we will see shortly what a proto compiler is).
  prefs: []
  type: TYPE_NORMAL
- en: '`Repeated` fields are the fields in the message of a protocol buffer that represent
    a list of items. In JSON, we have a list of elements for a given key. Similarly,
    repeated fields allow us to define an array/list of elements of a particular type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, the third field is a repeated field, which means it
    is an array/list of proxies. The value could be something such as `["100.104.112.10",
    "100.104.112.12"]`, and so on. Apart from repeated fields, we can also use other
    messages as types. It is analogous to nested JSON. For example, take a look at
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We see we have a nested `innerJSON`as one of the members of `outerJSON`. How
    can we model the same thing in protobufs? We can do it using the nested messages,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are nesting the `Proxy` type into the `Site`. We will soon see a real
    example with all these types of fields.
  prefs: []
  type: TYPE_NORMAL
- en: Compiling a protocol buffer with protoc
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Until now, we have discussed how to write a protocol buffer file that is previously
    written in JSON or another data format. But, how do we actually integrate it into
    our programs? Remember that protocol buffers are data formats, no more than that.
    They are a format of communication between various systems, similar to JSON. These
    are the practical steps we follow for using protobufs in our Go programs:'
  prefs: []
  type: TYPE_NORMAL
- en: Install the `protoc` command-line tool and the `proto` library.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a protobuf file with the `.proto` extension.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compile it to target a programming language (here, it is Go).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import structs from the generated target file and serialize the data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On a remote machine, receive the serialized data and decode it into a struct
    or class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Take a look at the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6db67127-8a0c-4e2e-b2c9-b4ae112087c7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The first step is to install the `protobuf` compiler on our machine. For this,
    download the `protobuf` package from [https://github.com/google/protobuf/releases](https://github.com/google/protobuf/releases).
    On macOS X, we can install `protobuf` using this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'On Ubuntu or Linux, we can copy `protoc` to the `/usr/bin` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'On Windows, we can just copy the executable (`.exe`) from [https://github.com/google/protobuf/releases/download/v3.3.0/protoc-3.3.0-win32.zip](https://github.com/google/protobuf/releases/download/v3.3.0/protoc-3.3.0-win32.zip) to
    the `PATH` environment variable. Let us write a simple protocol buffer to illustrate
    how to compile and use structs from the target file. Create a folder called `protofiles`
    in `$GOPATH/src/github.com/narenaryan` (this is the place for our Go projects)
    using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, create a file called `person.proto`, which models a person''s information.
    Add a few messages to it, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We created two main messages called `AddressBook` and `Person`.`AddressBook`
    has a list of persons. A `Person` has a `name`, `id`, `email`, and `phone Number`. 
    In the second line, we declared the package as `protofiles` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This tells the compiler to add the generating file in relation to the given
    package name. Go cannot consume this `.proto` file directly.  We need to compile
    it to a valid Go file. When compiled, this package name `protofiles` will be used
    to set the  package of the output file (Go in this case). To compile this protocol
    buffer file, traverse to the `protofiles` directory and run this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This command converts the given protocol buffer file(s) to the Go file(s) with
    the same name. You will see that, after running this command, there is a new file
    created in the same directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The new file name is `person.pb.go`.If we open and inspect this file, it contains
    the following important block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This is just a part of that file. There will be many getter and setter methods
    created for the given structs such as `Person` and `AddressBook` in the output
    file. This code is automatically generated. We need to consume this code in the
    main program to create protocol buffer strings. Now, let us create a new directory
    called `protobufs`.This holds the `main.go` file that uses the `Person` struct
    from the `person.pb.go` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, for Go to serialize a struct to the protobinary format, we need to install
    the Go proto driver. Install it using the `go get` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'After this, let us compose `main.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We are importing the **protocol buffer** (**pb**) from the `protofiles` package.
    There are structs that are mapped to the given protobuf in the `proto files.`
    We used the `Person` struct and initialized it. Then, we serialized the struct
    using the `proto.Marshal`function. If we run this program, the output looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The second output of marshaled data is not intuitive because the `proto` library
    serializes data into binary bytes. Another good thing about protocol buffers in
    Go is that the structs generated by compiling the proto files can be used to generate
    JSON on the fly. Let us modify the preceding example to this. Call it `main_json.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run this, it prints a JSON string that can be sent to any client that
    can understand JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Any other language or platform can easily load this JSON string and use the
    data instantly. So, what is the benefit of using protocol buffers instead of JSON?
    First of all, protocol buffers are intended for two backend systems to communicate
    with each other with less overhead. Since the size of the binary is less than
    text, protocol marshaled data is of less size than JSON.
  prefs: []
  type: TYPE_NORMAL
- en: By using protocol buffers we map both JSON and protocol buffer formats to the
    Go struct. This gives the best of both worlds by converting one format to another
    on the fly.
  prefs: []
  type: TYPE_NORMAL
- en: But, protocol buffers are just a data format. They don't have any importance
    if we don't communicate. So here, protocol buffers are used to pass messages between
    two end systems in the form of RPC. We saw how RPC works and also created an RPC
    client and server in the previous chapters. Now, we are going to extend that knowledge
    to use **Google Remote Procedure Call** (**GRPC**) with protocol buffers to scale
    our microservice communications. A server and client, in this case, can talk with
    each other in protocol buffer format.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to GRPC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GRPC is a transport mechanism that sends and receives messages between two systems.
    These two systems are traditionally a server and a client. As we described in
    the previous chapters, RPC can be implemented in Go for transferring JSON. We
    called it a JSON RPC service. Similarly, Google RPC is specially designed to transfer
    data in the form of protocol buffers.
  prefs: []
  type: TYPE_NORMAL
- en: GRPC makes the service creation easy and elegant. It provides a nice set of
    APIs to define services and start running them. In this section, we will mainly
    focus on how to create a GRPC service and use it. The main advantage of GRPC is
    that it can be understood by multiple programming languages. Protocol buffers
    provide a common data structure. So, the combination enables the seamless communication
    between various tech stacks and systems. This is the integral concept of distributed
    computing.
  prefs: []
  type: TYPE_NORMAL
- en: Square, Netflix, and so on leverage this GRPC to scale their huge traffic-prone
    services. Google's former product manager, Andrew Jessup, said in a conference
    that at Google, billions of GRPC calls are processed every single day. If any
    business organization needs to embrace what Google does, it too can handle the
    traffic demand with these tweaks in the services.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to install the `grpc` Go library and a `protoc-gen` plugin before writing
    the services. Install them using the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'GRPC has the following benefits over traditional HTTP/REST/JSON architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: GRPC uses HTTP/2, which is a binary protocol
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Header compression is possible in HTTP/2, which means less overhead
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can multiplex many requests on one connection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Usage of protobufs for strict typing of data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Streaming of requests or responses is possible instead of request/response transactions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Take a look at the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8c77a0c5-6a5f-452f-b00f-d52b9b258101.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The diagram clearly shows that any backend system or mobile app can directly
    communicate to a GRPC server by firing a protocol buffer request. Let us write
    a money transaction service in Go using GRPC and protocol buffers. Here, we are
    going to show how the client and server can be implemented. The steps are:'
  prefs: []
  type: TYPE_NORMAL
- en: Create the protocol buffer file for the service and messages.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compile the protocol buffer file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the generated Go package for creating a GRPC server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a GRPC client that talks to the server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For this project, create a folder called `datafiles` in your Go workspace (here,
    it is `$GOPATH/src/github.com/narenaryan/`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file called `transaction.proto` in it with messages and a service
    defined. We will shortly see what a service is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a minimalistic protocol buffer for a money transaction on the server.
    We already saw about message keywords in the proto file. The last keyword, `service`,
    is new to us. `service` tells GRPC to treat it as a service, and all the RPC methods
    will act as an interface for a server that implements this. A struct that implements
    a Go interface should implement all its functions. Now, let us compile this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This command is slightly bigger than the one we used previously. This is because
    here we are using the `protoc-gen-go` plugin. The command simply says to use data
    files as the input directory for proto files and use the same directory for outputting
    the target Go files. Now, if we see the filesystem, there will be two files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, create two more directories for server and client logic in `$GOPATH/src/github.com/narenaryan/grpc_example`.
    The server implements the interface that is generated from the proto file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, add a file called `server.go` to the `grpcServer` directory, which implements
    the transaction service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: There are a lot of things happening in the preceding file. First, we imported
    all the necessary imports. The new ones here are `context` and `reflection`.Context
    is used to create a `context` variable, which lives throughout an RPC request's
    lifetime. Both of these libraries are used by GRPC for its internal functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before explaining the next sections, if we open the generated `transaction.pb.go`
    file, we can clearly see that there are two important things:'
  prefs: []
  type: TYPE_NORMAL
- en: The `RegisterMoneyTransactionServer` function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `MakeTransaction` function as part of the  `MoneyTransactionServer` interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In order to implement a service, we need both of these things; `MakeTransaction`
    for the actual service functionality, and `RegisterMoneyTransactionServer` for
    registering the service (that is, create an RPC server to run on a port).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `in` variable of `MakeTransaction` has the RPC request details. It is basically
    a struct that maps to the `TransactionRequest` message we defined in the protocol
    buffer file. What returns from `MakeTransaction` is `TransactionResponse`.This
    function signature matches with the one we defined in the protocol buffer file
    initially:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let us write a client. We can write a client (or) server in any programming
    language, but here we are writing both a client and server in Go for understanding
    the Go GRPC API. Add a file called `client.go` in the `grpcClient` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This client is also using the `grpc`package. It uses an empty context called
    `context.Background()`to pass to the `MakeTransaction`function. The second argument
    of the function is the `TransactionRequest` struct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'It clearly maps with the theory we discussed in the previous section. Now,
    let us run it and see the output. Open a new console and run the GRPC server by
    using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The TCP server starts listening on port `50051`. Now, open one more terminal/shell
    and start the client program that talks to this server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'It prints the output of the successful transaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'At the same time, the server logs this message to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Here, the client made a single request to the GRPC server and passed details
    of `From A/c` number, `To A/c` number, and `Amount`. The server picks those details,
    processes them, and sends a response back saying everything is fine.
  prefs: []
  type: TYPE_NORMAL
- en: Since I am running code samples on my machine, I have `narenaryan` as the project
    directory under [github.com](https://github.com/). You can replace it with any
    other name.
  prefs: []
  type: TYPE_NORMAL
- en: Bidirectional streaming with GRPC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main advantage of GRPC over traditional HTTP/1.1 is that it uses a single
    TCP connection for sending and receiving multiple messages between the server
    and the client. We saw the example of a money transaction before. Another real-world
    use case is a GPS installed in a taxi. Here, the taxi is the client that sends
    its geographical points to the server along its route. Finally, the server can
    calculate the total fare amount depending on the time spent between points and
    the total distance.
  prefs: []
  type: TYPE_NORMAL
- en: Another such use case is when a server needs to notify the client whenever some
    processing is performed. This is called a server push model. The server can send
    a stream of results back when a client asked for them only once. This is different
    to polling, where the client requests something each and every time. This can
    be useful when there are a series of time-taking steps that need to be done. The
    GRPC client can escalate that job to the GRPC server. Then, the server takes its
    time and relays the message back to the client, which reads them and does something
    useful. Let us implement this.
  prefs: []
  type: TYPE_NORMAL
- en: 'This concept is similar to WebSockets, but between any type of platform. Create
    a project called `serverPush`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, write in `datafiles` a protocol buffer that is similar to the previous
    one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We have two messages and one service defined in the protocol buffer file. The
    exciting part is in the service; we are returning a stream instead of a plain
    response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The use case of this project is: *the client sends a money transfer request
    to the server, the server does a few tasks and sends those step details as a stream
    of responses back to the server*. Now, let us compile that proto file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates a new file called `transaction.pb.go` in the `datafiles` directory.
    We use the definitions in this file in our server and client programs, which we
    will create shortly. Now, let us write the GRPC server code. This code is a bit
    different compared to the previous example because of the introduction of streams:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, add this program to the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '`MakeTransaction`is the function that interests us. It takes a request and
    a stream as its arguments. In the function, we are looping through the number
    of steps (here, it is three), and performing the computation. The server is simulating
    the mock I/O or computation using the `time.Sleep`function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'This function sends a stream response from the server to the client. Now, let
    us compose the client program. This is also a bit different to the basic GRPC
    client that we saw in the preceding code. Create a new directory for the client
    program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, start writing the client logic in that file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `ReceiveStream`is the custom function we wrote for the sake of sending
    a request and receiving a stream of messages. It takes two arguments: `MoneyTransactionClient`and
    `TransactionRequest`.It uses the first argument to create a stream and starts
    listening to it. Whenever the server exhausts all the messages, the client will
    stop listening and terminate. Then, an `io.EOF` error will be returned if the
    client tries to receive messages. We are logging the responses collected from
    the GRPC server. The second argument, `TransactionRequest`,is used to send the
    request to the server for the first time. Now, running it will make it more clear
    to us. On terminal one, run the GRPC server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'It will keep on listening for incoming requests. Now, run the client on the
    second terminal to see the action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'This outputs the following to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'At the same time, the server also logs its own messages on terminal one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'This process happens in sync with the server. The client stays alive until
    all the streaming messages are sent back. The server can handle any number of
    clients at a given time. Every client request is considered as an individual entity.
    This is an example of the server sending a stream of responses. There are other
    cases that can also be implemented with protocol buffers and GRPC:'
  prefs: []
  type: TYPE_NORMAL
- en: The client sending streamed requests to get one final response from the server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The client and server are both sending streamed requests and responses at the
    same time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The official GRPC team has provided a nice example of routing a taxi on GitHub.
    You can take a look at it to learn more about the functioning of bidirectional
    streams at
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/grpc/grpc-go/tree/master/examples/route_guide](https://github.com/grpc/grpc-go/tree/master/examples/route_guide).'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we started our journey by understanding the basics of protocol
    buffers. Then, we came across the protocol buffers language, which has many types
    such as scalar, enumeration, and repeated types. We saw a few analogies between
    JSON and protocol buffers. We learned why protocol buffers are more memory efficient
    than the plain JSON data format. We defined a sample protocol buffer by simulating
    a network interface. The `message`keyword is used to define messages in a protocol
    buffer.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we installed the `protoc` compiler to compile our files written in the
    protocol buffer language. Then, we saw how to compile a `.proto` file to generate
    a `.go` file. This Go file has all the structs and interfaces for the main program
    to consume. Next, we wrote a protocol buffer for an address book and person.We
    saw how to use `grpc.Marshal`to serialize Go structs into binary, transmittable
    data. We also found out that the conversion from protocol buffer to JSON and vice
    versa is very easily achievable in Go.
  prefs: []
  type: TYPE_NORMAL
- en: We then moved to GRPC, an RPC technology from Google using protocol buffers.
    We saw the benefits of HTTP/2 and GRPC. We then defined a GRPC service and data
    in the form of protocol buffers. Next, we implemented a GRPC server and GRPC in
    respect to the file generated from `.proto`.
  prefs: []
  type: TYPE_NORMAL
- en: GRPC provides a bidirectional and multiplexed transport mechanism. This means
    that it can use a single TCP connection for all its message transmissions. We
    implemented one such scenario where the client sends a message to a server and
    the server replies back with a stream of messages.
  prefs: []
  type: TYPE_NORMAL
