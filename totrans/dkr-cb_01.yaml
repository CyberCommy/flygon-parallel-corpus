- en: Chapter 1. Introduction and Installation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Verifying the requirements for Docker installation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing Docker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pulling an image and running a container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a nonroot user to administer Docker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the Docker host with Docker Machine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding help with the Docker command line
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the very start of the IT revolution, most applications were deployed directly
    on physical hardware, over the host OS. Because of that single user space, runtime
    was shared between applications. The deployment was stable, hardware-centric,
    and had a long maintenance cycle. It was mostly managed by an IT department and
    gave a lot less flexibility to developers. In such cases, hardware resources were
    regularly underutilized.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram depicts such a setup:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introduction](../Images/image00262.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Traditional application deployment ([https://rhsummit.files.wordpress.com/2014/04/rhsummit2014-application-centric_packaging_with_docker_and_linux_containers-20140412riek7.pdf](https://rhsummit.files.wordpress.com/2014/04/rhsummit2014-application-centric_packaging_with_docker_and_linux_containers-20140412riek7.pdf))
  prefs: []
  type: TYPE_NORMAL
- en: 'To overcome the limitations set by traditional deployment, virtualization was
    invented. With hypervisors such as KVM, XEN, ESX, Hyper-V, and so on, we emulated
    the hardware for virtual machines (VMs) and deployed a guest OS on each virtual
    machine. VMs can have a different OS than their host; that means we are responsible
    for managing the patches, security, and performance of that VM. With virtualization,
    applications are isolated at VM level and defined by the life cycle of VMs. This
    gives better return on investment and higher flexibility at the cost of increased
    complexity and redundancy. The following diagram depicts a typical virtualized
    environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introduction](../Images/image00263.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Application deployment in a virtualized environment ([https://rhsummit.files.wordpress.com/2014/04/rhsummit2014-application-centric_packaging_with_docker_and_linux_containers-20140412riek7.pdf](https://rhsummit.files.wordpress.com/2014/04/rhsummit2014-application-centric_packaging_with_docker_and_linux_containers-20140412riek7.pdf))
  prefs: []
  type: TYPE_NORMAL
- en: After virtualization, we are now moving towards more application-centric IT.
    We have removed the hypervisor layer to reduce hardware emulation and complexity.
    The applications are packaged with their runtime environment and are deployed
    using containers. OpenVZ, Solaris Zones, and LXC are a few examples of container
    technology. Containers are less flexible compared to VMs; for example, we cannot
    run Microsoft Windows on a Linux OS. Containers are also considered less secure
    than VMs, because with containers, everything runs on the host OS. If a container
    gets compromised, then it might be possible to get full access to the host OS.
    It can be a bit too complex to set up, manage, and automate. These are a few reasons
    why we have not seen the mass adoption of containers in the last few years, even
    though we had the technology.
  prefs: []
  type: TYPE_NORMAL
- en: '![Introduction](../Images/image00264.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Application deployment with containers ([https://rhsummit.files.wordpress.com/2014/04/rhsummit2014-application-centric_packaging_with_docker_and_linux_containers-20140412riek7.pdf](https://rhsummit.files.wordpress.com/2014/04/rhsummit2014-application-centric_packaging_with_docker_and_linux_containers-20140412riek7.pdf))
  prefs: []
  type: TYPE_NORMAL
- en: With Docker, containers suddenly became first-class citizens. All big corporations
    such as Google, Microsoft, Red Hat, IBM, and others are now working to make containers
    mainstream.
  prefs: []
  type: TYPE_NORMAL
- en: Docker was started as an internal project by Solomon Hykes, who is the current
    CTO of Docker, Inc., at dotCloud. It was released as open source in March 2013
    under the Apache 2.0 license. With dotCloud's platform as a service experience,
    the founders and engineers of Docker were aware of the challenges of running containers.
    So with Docker, they developed a standard way to manage containers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Docker uses Linux''s underlying kernel features which enable containerization.
    The following diagram depicts the execution drivers and kernel features used by
    Docker. We''ll talk about execution drivers later. Let''s look at some of the
    major kernel features that Docker uses:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introduction](../Images/image00265.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The execution drivers and kernel features used by Docker ([http://blog.docker.com/wp-content/uploads/2014/03/docker-execdriver-diagram.png](http://blog.docker.com/wp-content/uploads/2014/03/docker-execdriver-diagram.png))
  prefs: []
  type: TYPE_NORMAL
- en: Namespaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Namespaces are the building blocks of a container. There are different types
    of namespaces and each one of them isolates applications from each other. They
    are created using the clone system call. One can also attach to existing namespaces.
    Some of the namespaces used by Docker have been explained in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: The pid namespace
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `pid` namespace allows each container to have its own process numbering.
    Each `pid` forms its own process hierarchy. A parent namespace can see the children
    namespaces and affect them, but a child can neither see the parent namespace nor
    affect it.
  prefs: []
  type: TYPE_NORMAL
- en: 'If there are two levels of hierarchy, then at the top level, we would see a
    process running inside the child namespace with a different PID. So, a process
    running in a child namespace would have two PIDs: one in the child namespace and
    the other in the parent namespace. For example, if we run a program on the container
    (`container.sh`), then we can see the corresponding program on the host as well.'
  prefs: []
  type: TYPE_NORMAL
- en: 'On the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The pid namespace](../Images/image00266.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'On the host:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The pid namespace](../Images/image00267.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The net namespace
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With the `pid` namespace, we can run the same program multiple times in different
    isolated environments; for example, we can run different instances of Apache on
    different containers. But without the `net` namespace, we would not be able to
    listen on port 80 on each one of them. The `net` namespace allows us to have different
    network interfaces on each container, which solves the problem I mentioned earlier.
    Loopback interfaces would be different in each container as well.
  prefs: []
  type: TYPE_NORMAL
- en: To enable networking in containers, we can create pairs of special interfaces
    in two different `net` namespaces and allow them to talk to each other. One end
    of the special interface resides inside the container and the other in the host
    system. Generally, the interface inside the container is named `eth0`, and in
    the host system, it is given a random name such as `vethcf1a`. These special interfaces
    are then linked through a bridge (`docker0`) on the host to enable communication
    between containers and route packets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the container, you would see something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The net namespace](../Images/image00268.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'And in the host, it would look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The net namespace](../Images/image00269.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Also, each `net` namespace has its own routing table and firewall rules.
  prefs: []
  type: TYPE_NORMAL
- en: The ipc namespace
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Inter Process Communication** (**ipc**) provides semaphores, message queues,
    and shared memory segments. It is not widely used these days but some programs
    still depend on it.'
  prefs: []
  type: TYPE_NORMAL
- en: If the `ipc` resource created by one container is consumed by another container,
    then the application running on the first container could fail. With the `ipc`
    namespace, processes running in one namespace cannot access resources from another
    namespace.
  prefs: []
  type: TYPE_NORMAL
- en: The mnt namespace
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With just a chroot, one can inspect the relative paths of the system from a
    chrooted directory/namespace. The `mnt` namespace takes the idea of a chroot to
    the next level. With the `mnt` namespace, a container can have its own set of
    mounted filesystems and root directories. Processes in one `mnt` namespace cannot
    see the mounted filesystems of another `mnt` namespace.
  prefs: []
  type: TYPE_NORMAL
- en: The uts namespace
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With the `uts` namespace, we can have different hostnames for each container.
  prefs: []
  type: TYPE_NORMAL
- en: The user namespace
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With `user` namespace support, we can have users who have a nonzero ID on the
    host but can have a zero ID inside the container. This is because the `user` namespace
    allows per namespace mappings of users and groups IDs.
  prefs: []
  type: TYPE_NORMAL
- en: There are ways to share namespaces between the host and container and container
    and container. We'll see how to do that in subsequent chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Cgroups
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Control Groups** (**cgroups**) provide resource limitations and accounting
    for containers. From the Linux Kernel documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Control Groups provide a mechanism for aggregating/partitioning sets of tasks,
    and all their future children, into hierarchical groups with specialized behaviour.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In simple terms, they can be compared to the `ulimit` shell command or the `setrlimit`
    system call. Instead of setting the resource limit to a single process, cgroups
    allow the limiting of resources to a group of processes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Control groups are split into different subsystems, such as CPU, CPU sets,
    memory block I/O, and so on. Each subsystem can be used independently or can be
    grouped with others. The features that cgroups provide are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Resource limiting**: For example, one cgroup can be bound to specific CPUs,
    so all processes in that group would run off given CPUs only'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Prioritization**: Some groups may get a larger share of CPUs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Accounting**: You can measure the resource usage of different subsystems
    for billing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Control**: Freezing and restarting groups'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some of the subsystems that can be managed by cgroups are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**blkio**: It sets I/O access to and from block devices such as disk, SSD,
    and so on'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cpu**: It limits access to CPU'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cpuacct**: It generates CPU resource utilization'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cpuset**: It assigns the CPUs on a multicore system to tasks in a cgroup'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Devices**: It devises access to a set of tasks in a cgroup'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Freezer**: It suspends or resumes tasks in a cgroup'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Memory**: It sets limits on memory use by tasks in a cgroup'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are multiple ways to control work with cgroups. Two of the most popular
    ones are accessing the cgroup virtual filesystem manually and accessing it with
    the `libcgroup` library. To use `libcgroup` in fedora, run the following command
    to install the required packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Once installed, you can get the list of subsystems and their mount point in
    the pseudo filesystem with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '![Cgroups](../Images/image00270.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Although we haven''t looked at the actual commands yet, let''s assume that
    we are running a few containers and want to get the cgroup entries for a container.
    To get those, we first need to get the container ID and then use the `lscgroup`
    command to get the cgroup entries of a container, which we can get from the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Cgroups](../Images/image00271.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more details, visit [https://docs.docker.com/articles/runmetrics/](https://docs.docker.com/articles/runmetrics/).
  prefs: []
  type: TYPE_NORMAL
- en: The Union filesystem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Union filesystem allows the files and directories of separate filesystems,
    known as layers, to be transparently overlaid to create a new virtual filesystem.
    While starting a container, Docker overlays all the layers attached to an image
    and creates a read-only filesystem. On top of that, Docker creates a read/write
    layer which is used by the container's runtime environment. Look at the *Pulling
    an image and running a container* recipe of this chapter for more details. Docker
    can use several Union filesystem variants, including AUFS, Btrfs, vfs, and DeviceMapper.
  prefs: []
  type: TYPE_NORMAL
- en: Docker can work with different execution drivers, such as `libcontainer`, `lxc`,
    and `libvirt` to manage containers. The default execution driver is `libcontainer`,
    which comes with Docker out of the box. It can manipulate namespaces, control
    groups, capabilities, and so on for Docker.
  prefs: []
  type: TYPE_NORMAL
- en: Verifying the requirements for Docker installation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker is supported on many Linux platforms, such as RHEL, Ubuntu, Fedora, CentOS,
    Debian, Arch Linux, and so on. It is also supported on many cloud platforms, such
    as Amazon EC2, Rackspace Cloud, and Google Compute Engine. With the help of a
    virtual environment, Boot2Docker, it can also run on OS X and Microsoft Windows.
    A while back, Microsoft announced that it would add native support to Docker on
    its next Microsoft Windows release.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, let's verify the requirements for Docker installation. We will
    check on the system with Fedora 21 installation, though the same steps should
    work on Ubuntu as well.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Log in as root on the system with Fedora 21 installed.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Docker is not supported on 32-bit architecture. To check the architecture on
    your system, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Docker is supported on kernel 3.8 or later. It has been back ported on some
    of the kernel 2.6, such as RHEL 6.5 and above. To check the kernel version, run
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Running kernel should support an appropriate storage backend. Some of these
    are VFS, DeviceMapper, AUFS, Btrfs, and OverlayFS.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Mostly, the default storage backend or driver is devicemapper, which uses the
    device-mapper thin provisioning module to implement layers. It should be installed
    by default on the majority of Linux platforms. To check for device-mapper, you
    can run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In most distributions, AUFS would require a modified kernel.
  prefs: []
  type: TYPE_NORMAL
- en: 'Support for cgroups and namespaces are in kernel for sometime and should be
    enabled by default. To check for their presence, you can look at the corresponding
    configuration file of the kernel you are running. For example, on Fedora, I can
    do something like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the preceding commands, we verified the requirements for Docker installation.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Installation document on the Docker website at [https://docs.docker.com/installation/](https://docs.docker.com/installation/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As there are many distributions which support Docker, we'll just look at the
    installation steps on Fedora 21 in this recipe. For others, you can refer to the
    installation instructions mentioned in the *See also* section of this recipe.
    Using Docker Machine, we can set up Docker hosts on local systems, on cloud providers,
    and other environments very easily. We'll cover that in a different recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Check for the prerequisites mentioned in the previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Install Docker using yum:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The preceding command will install Docker and all the packages required by it.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The default Docker daemon configuration file is located at `/etc/sysconfig/docker`,
    which is used while starting the daemon. Here are some basic operations:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To start the service:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'To verify the installation:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'To update the package:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'To enable the service start at boot time:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'To stop the service:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The installation document is on the Docker website at [https://docs.docker.com/installation/](https://docs.docker.com/installation/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pulling an image and running a container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I am borrowing this recipe from the next chapter to introduce some concepts.
    Don't worry if you don't find all the explanation in this recipe. We'll cover
    all the topics in detail later in this chapter or in the next few chapters. For
    now, let's pull an image and run it. We'll also get familiar with Docker architecture
    and its components in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Get access to a system with Docker installed.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To pull an image, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'List the existing images by using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '![How to do it…](../Images/image00272.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Create a container using the pulled image and list the containers as:![How to
    do it…](../Images/image00273.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Docker has client-server architecture. Its binary consists of the Docker client
    and server daemon, and it can reside in the same host. The client can communicate
    via sockets or the RESTful API to either a local or remote Docker daemon. The
    Docker daemon builds, runs, and distributes containers. As shown in the following
    diagram, the Docker client sends the command to the Docker daemon running on the
    host machine. The Docker daemon also connects to either the public or local index
    to get the images requested by the client:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](../Images/image00274.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Docker client-server architecture ([https://docs.docker.com/introduction/understanding-docker/](https://docs.docker.com/introduction/understanding-docker/))
  prefs: []
  type: TYPE_NORMAL
- en: So in our case, the Docker client sends a request to the daemon running on the
    local system, which then connects to the public Docker Index and downloads the
    image. Once downloaded, we can run it.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s explore some keywords we encountered earlier in this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Images**: Docker images are read-only templates and they give us containers
    during runtime. There is the notion of a base image and layers on top of it. For
    example, we can have a base image of Fedora or Ubuntu and then we can install
    packages or make modifications over the base image to create a new layer. The
    base image and new layer can be treated as a new image. For example, in following
    figure, **Debian** is the base image and **emacs** and **Apache** are the two
    layers added on top of it. They are highly portable and can be shared easily:![There''s
    more…](../Images/image00275.jpeg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker Image layers ([http://docs.docker.com/terms/images/docker-filesystems-multilayer.png](http://docs.docker.com/terms/images/docker-filesystems-multilayer.png))
  prefs: []
  type: TYPE_NORMAL
- en: Layers are transparently laid on top of the base image to create a single coherent
    filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: '**Registries**: A registry holds Docker images. It can be public or private
    from where you can download or upload images. The public Docker registry is called
    **Docker Hub**, which we will cover later.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Index**: An index manages user accounts, permissions, search, tagging, and
    all that nice stuff that''s in the public web interface of the Docker registry.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Containers**: Containers are running images that are created by combining
    the base image and the layers on top of it. They contain everything needed to
    run an application. As shown in preceding diagram, a temporary layer is also added
    while starting the container, which would get discarded if not committed after
    the container is stopped and deleted. If committed, then it would create another
    layer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Repository**: Different versions of an image can be managed by multiple tags,
    which are saved with different GUID. A repository is a collection of images tracked
    by GUIDs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The documentation on the Docker website at [http://docs.docker.com/introduction/understanding-docker/](http://docs.docker.com/introduction/understanding-docker/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With Docker 1.6, the Docker community and Microsoft Windows released a Docker
    native client for Windows [http://azure.microsoft.com/blog/2015/04/16/docker-client-for-windows-is-now-available](http://azure.microsoft.com/blog/2015/04/16/docker-client-for-windows-is-now-available)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a nonroot user to administer Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For ease of use, we can allow a nonroot user to administer Docker by adding
    them to a Docker group.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create the Docker group if it is not there already:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the user to whom you want to give permission to administer Docker:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Run the following command to allow the newly created user to administer Docker:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The preceding command will add a user to the Docker group. The added user will
    thus be able to perform all Docker operations. This can be the security risk.
    Visit [Chapter 9](part0092.xhtml#aid-2NNJO2 "Chapter 9. Docker Security"), *Docker
    Security* for more details.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the Docker host with Docker Machine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Earlier this year, Docker released Orchestration tools ([https://blog.docker.com/2015/02/orchestrating-docker-with-machine-swarm-and-compose/](https://blog.docker.com/2015/02/orchestrating-docker-with-machine-swarm-and-compose/))
    and Machine, Swarm, and Compose deploy containers seamlessly. In this recipe,
    we'll cover Docker Machine and look at the others in later chapters. Using the
    Docker Machine tool ([https://github.com/docker/machine/](https://github.com/docker/machine/)),
    you can set up Docker hosts locally on cloud with one command. It is currently
    in beta mode and not recommended for production use. It supports environments
    such as VirtualBox, OpenStack, Google, Digital Ocean, and others. For a complete
    list, you can visit [https://github.com/docker/machine/tree/master/drivers](https://github.com/docker/machine/tree/master/drivers).
    Let's use this tool and set up a host in Google Cloud.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will be using Docker Machine just for this recipe. Recipes mentioned in this
    or other chapters may or may not work on the host set up by Docker Machine.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Docker Machine does not appear with the default installation. You need to download
    it from its GitHub releases link ([https://github.com/docker/machine/releases](https://github.com/docker/machine/releases)).
    Please check the latest version and distribution before downloading. As a root
    user, download the binary and make it executable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'If you don''t have an account on **Google Compute Engine** (**GCE**), then
    you can sign up for a free trial ([https://cloud.google.com/compute/docs/signup](https://cloud.google.com/compute/docs/signup))
    to try this recipe. I am assuming that you have a project on GCE and have the
    Google Cloud SDK installed on the system on which you downloaded Docker Machine
    binary. If not, then you can follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Set up the Google Cloud SDK on your local system:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Create a project on GCE ([https://console.developers.google.com/project](https://console.developers.google.com/project))
    and get its project ID. Please note that the project name and its ID are different.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to the project home page and under the **APIs & auth** section, select **APIs**,
    and enable Google **Compute Engine API**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Assign the project ID we collected to a variable, `GCE_PROJECT`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following command and enter the code which is provided on the popped
    up web browser:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'List the existing hosts managed by Docker Machine:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '![How to do it…](../Images/image00276.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: You can manage multiple hosts with Docker Machine. The `*` indicates the active
    one.
  prefs: []
  type: TYPE_NORMAL
- en: 'To display the commands to set up the environment for the Docker client:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '![How to do it…](../Images/image00277.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: So, if you point the Docker client with the preceding environment variables,
    we would connect to the Docker daemon running on the GCE.
  prefs: []
  type: TYPE_NORMAL
- en: 'And to point the Docker client to use our newly created machine, run the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: From now on, all the Docker commands will run on the machine we provisioned
    on GCE, until the preceding environment variables are set.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Docker Machine connects to the cloud provider and sets up a Linux VM with Docker
    Engine. It creates a `.docker/machine/` directory under the current user's home
    directory to save the configuration.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Docker Machine provides management commands, such as `create`, `start`, `stop`,
    `restart`, `kill`, `remove`, `ssh`, and others to manage machines. For detailed
    options, look for the help option of Docker Machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use the `--driver/-d` option to create choosing one of the many endpoints
    available for deployment. For example, to set up the environment with VirtualBox,
    run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '![There''s more…](../Images/image00278.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Here, `dev` is the machine name. By default, the latest deployed machine becomes
    primary.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Documentation on the Docker website at [https://docs.docker.com/machine/](https://docs.docker.com/machine/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Guide to setting up Docker on Google Compute Engine at [https://docs.docker.com/installation/google/](https://docs.docker.com/installation/google/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding help with the Docker command line
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker commands are well documented and can be referred to whenever needed.
    Lots of documentation is available online as well, but it might differ from the
    documentation for the Docker version you are running.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Install Docker on your system.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'On a Linux-based system, you can use the `man` command to find help as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Subcommand-specific help can also be found with any of the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `man` command uses the `man` pages installed by the Docker package to show
    help.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Documentation on the Docker website at [http://docs.docker.com/reference/commandline/cli/](http://docs.docker.com/reference/commandline/cli/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
