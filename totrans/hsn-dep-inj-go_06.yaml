- en: Dependency Injection with Constructor Injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After examining one of the most unique forms of **dependency injection** (**DI**),
    monkey patching, in this chapter, we take it to the other extreme and look at
    perhaps the most *normal* or traditional, constructor injection.
  prefs: []
  type: TYPE_NORMAL
- en: While constructor injection is so ubiquitous that you may even have used it
    without realizing it, it has many subtleties, particularly concerning advantages
    and disadvantages, that bear examination.
  prefs: []
  type: TYPE_NORMAL
- en: Similar to the previous chapter, we will apply this technique to our sample
    service, where we will reap significant improvements.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Constructor injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advantages of constructor injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying constructor injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disadvantages of constructor injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It would be beneficial to be familiar with the code for our service that we
    introduced in [Chapter 4,](9b5a6d56-9d43-4a12-a580-6ca8b13b9201.xhtml) *Introduction
    to the ACME Registration Service* .
  prefs: []
  type: TYPE_NORMAL
- en: You might also find it useful to read and run the full versions of the code
    for this chapter, which are available at [https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/tree/master/ch06](https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/tree/master/ch06).
  prefs: []
  type: TYPE_NORMAL
- en: Instructions to obtain the code and configure the sample service are available
    in the README here [https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/](https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/).
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code for our service, with the changes from this chapter already
    applied, in `ch06/acme`.
  prefs: []
  type: TYPE_NORMAL
- en: Constructor injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When an object requires a dependency to work, the easiest way to ensure that
    dependency is always available is to require all users to supply it as a parameter
    to the object's constructor. This is known as **constructor injection**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s work through an example where we will extract a dependency, generalize
    it, and achieve constructor injection. Say we are we are building a website for
    an online community. For this site, we wish to send an email to new users when
    they sign up. The code for this could be like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve made the `*Mailer` private to ensure proper encapsulation of the internals
    of the class. We can inject the `*Mailer` dependency by defining it as a parameter
    to our constructor, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous example, we have included a guard clause. The purpose of this
    is to ensure that the supplied dependency is not `nil`. This is not necessary,
    and whether or not it is included depends mainly on personal style; it''s perfectly
    acceptable to do this instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: You might be tempted to think that we are done. After all, we are injecting
    the dependency, `Mailer`, into `WelcomeSender`.
  prefs: []
  type: TYPE_NORMAL
- en: Sadly, we are not quite there yet. In fact, we are missing the real purpose
    of DI. No, it's not testing, although we will get to that. The real purpose of
    DI is decoupling.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, our `WelcomeSender` cannot work without an instance of `Mailer`.
    They are tightly coupled. So, let's decouple them by applying the *Dependency
    Inversion Principle* section from [Chapter 2](53a15217-38a7-4622-9242-a57fe46335ec.xhtml),
    *SOLID Design Principles for Go*.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s look at the `Mailer` struct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We can introduce an abstraction by converting this into an interface based
    on the method signatures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Hang on, we only need to send emails. Let''s apply the *interface segregation
    principle* and reduce the interface to only the methods we use and update our
    constructor. Now, we have this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: With this one small change, a few handy things have happened. Firstly, our code
    is now entirely self-contained. This means any bugs, extensions, tests, or other
    changes will only involve this package. Second, we can use mocks or stubs to test
    our code, stopping us from spamming ourselves with emails and requiring a working
    email server for our tests to pass. Lastly, we are no longer tied to the `Mailer`
    class. If we wanted to change from a welcome email to an SMS or tweet, we could
    change our input parameter to a different `Sender` and be done.
  prefs: []
  type: TYPE_NORMAL
- en: By defining our dependency as an abstraction (as a local interface) and passing
    that dependency into our constructor, we have explicitly defined our requirements
    and given us greater freedom in our testing and extensions.
  prefs: []
  type: TYPE_NORMAL
- en: Addressing the duck in the room
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we dive too deep into constructor injection, we should spend a moment
    to talk about duck typing.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have previously mentioned Go''s support for implicit interfaces and how
    we can leverage it to perform dependency inversion and decouple objects. To those
    of you familiar with Python or Ruby, this may have felt like duck typing. For
    everyone else, what is duck typing? It''s described as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**If it looks like a duck, and it quacks like a duck, then it is a duck**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Or, put more technically:'
  prefs: []
  type: TYPE_NORMAL
- en: '**At runtime, dynamically determine an object''s suitability based only on
    the parts of that object that are accessed**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at a Go example to see if it supports duck typing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, our `Dog` type does not declare that it implements the `Talker`
    interface, as we might expect from Java or C#, and yet we are able to use it as
    a `Talker`.
  prefs: []
  type: TYPE_NORMAL
- en: 'From our example, it looks like Go might support duck typing, but there are
    a couple of problems:'
  prefs: []
  type: TYPE_NORMAL
- en: In duck typing, compatibility is determined at runtime; Go will check our `Dog`
    type implements `Talker` at compile time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In duck typing, suitability is only based on the parts of the object accessed.
    In the previous example, only the `Speak()` method is actually used. However,
    if our `Dog` type did not implement the `Shout()` method, then it would fail to
    compile.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So if it's not duck typing, what is it? Something somewhat similar called **structural
    typing**. Structural typing is a static typing system that determines suitability
    at compile time based on the type's structure. Don't let the less fancy name fool
    you; structural typing is immensely powerful and extremely useful. Go provides
    the safety of compile-time checking without the enforced formality of explicitly
    having to state the interfaces implemented.
  prefs: []
  type: TYPE_NORMAL
- en: Advantages of constructor injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For many programmers and programming languages, constructor injection is their
    default method for DI. It is perhaps no surprise therefore that it has numerous
    advantages.
  prefs: []
  type: TYPE_NORMAL
- en: '**Separation from the dependency life cycle**—Constructor injection, like most
    DI methods, separates the life cycle management of the dependency from the object
    that it''s being injected into. By doing this, the object becomes more straightforward
    and easier to understand.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Easy to implement**—As we saw in our previous examples, it''s easy to take
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'And change it to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '**Predictable and concise**—By moving the assignment of the dependency to the
    constructor, we are not only being explicit about our requirements, but we are
    also ensuring that the dependency is set and available to our methods. This is
    particularly true if we include a guard clause in the constructor. Without the
    constructor, each method might have to include a guard clause (as shown in the
    following example) or risk throwing a nil pointer exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of the following, which is much more concise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: By extension, methods can also assume that our dependency is in a good, ready
    state when accessing the dependency, thus removing the need to handle initialization
    delays or configuration issues anywhere outside the constructor. Additionally,
    there are no data races associated with accessing the dependency. It is set during
    construction and never changed.
  prefs: []
  type: TYPE_NORMAL
- en: '**Encapsulation**—Constructor injection provides a high degree of encapsulation
    regarding how the object uses the dependency. Consider what happens if we extend
    our previous `Car` example by adding a `FillPetrolTank()` method, as shown in
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: What happens to the previous code if we assumed that *filling the petrol tank* had
    nothing to do with the `Engine` and didn't populate one before calling this method?
  prefs: []
  type: TYPE_NORMAL
- en: 'Without constructor injection ensuring that we supply an `Engine`, this method
    would crash will a nil pointer exception. Alternatively, this method could have
    been written without constructor injection, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: However, this version now leaks the implementation detail that the method requires
    `Engine` to work.
  prefs: []
  type: TYPE_NORMAL
- en: '**Helps to uncover code smells**—It''s an easy trap to add *just one more* feature
    to an existing struct or interface. As we saw during our earlier discussions of
    the *single responsibility principle*, we should resist this urge and keep our
    objects and interfaces as small as possible. One easy way to spot when an object
    has too many responsibilities is to count its dependencies. Typically, the more
    responsibilities an object has, the more dependencies it will accumulate. Therefore
    with all the dependencies clearly listed in one place, the constructor, it''s
    easy to get a whiff that something might not be quite right.'
  prefs: []
  type: TYPE_NORMAL
- en: Improving test scenario coverage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first thing we will do is break the dependence on the upstream currency
    service in the test. Then, we will proceed to add tests to cover additional scenarios
    that we couldn''t cover before. This is what our test currently looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We are currently starting our entire HTTP server; this seems excessive, so let's
    reduce the test scope to just `RegisterHandler`.
  prefs: []
  type: TYPE_NORMAL
- en: This reduction in test scope will also improve the tests by eliminating other
    peripheral concerns, such as the HTTP router.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we know that we are going to have multiple similar scenarios to test, let''s
    start by adding a skeleton for a table-driven test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: From the original test, we can see that our inputs are an `*http.Request` and
    `*MockRegisterModel`. Both are a little complicated to create and configure, so
    we have chosen to build them with a function. Also, from the original test, we
    can see that the outputs of the test are an HTTP response code and the `Location`
    header.
  prefs: []
  type: TYPE_NORMAL
- en: These four objects, `*http.Request`, `*MockRegistrationModel`, the HTTP status
    code, and the `Location` header, will make up the configuration for our test scenarios,
    as seen in the previous code.
  prefs: []
  type: TYPE_NORMAL
- en: 'To complete our table-driven test, we copy the contents of the original test
    into the test loop and replace the inputs and outputs, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have all of the pieces in place, we write our tests scenarios,
    starting with the happy path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Next, we need to test whether our code handles errors well. So what kinds of
    errors can we expect? We could examine the code and look for code that looks like `if
    err != nil`.
  prefs: []
  type: TYPE_NORMAL
- en: That might feel like a useful shortcut, but consider this. If our tests mirror
    the current implementation, what happens when the implementation changes?
  prefs: []
  type: TYPE_NORMAL
- en: A better angle is to consider not the implementation but the feature itself
    and the situation or use of it. There are two answers that almost always apply.
    *User errors*, such as incorrect inputs, and *errors returned from dependencies*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our *user error* scenario looks as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'And our *errors returned from dependencies* is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: With those three tests in place we have reasonable test scenario coverage, but
    we have stumbled over a problem. Our *errors returned from dependencies* scenario
    results in an HTTP status code of `400` (Bad Request) instead of the expected
    HTTP `500` (Internal Server Error). After looking into the implementation of the
    model layer, it becomes evident that the `400` error is intentional and is supposed
    to indicate that the request was incomplete and therefore failed validation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our first instinct is likely to want to move the validation into the HTTP layer.
    But consider this: what happens if we add another server type, such as gRPC? This
    validation would still need to be performed. So how can we separate user errors
    from system errors?'
  prefs: []
  type: TYPE_NORMAL
- en: Another option would be to return a named error from the model for validation
    errors and a different one for other errors. It would be easy to detect and handle
    the responses separately. This would, however, cause our code to remain tightly
    coupled with the `model` package.
  prefs: []
  type: TYPE_NORMAL
- en: Another option is to split our call to the model package into two calls, perhaps
    `Validate()` and `Do()`,  but this detracts from the UX of our `model` package.
    I will leave it to you to decide whether these or another option works for you.
  prefs: []
  type: TYPE_NORMAL
- en: After making these changes to `RegisterHandler` and the other handlers in this
    package, we can use Go's test coverage tool to see if we missed any obvious scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: For Unix/Linux users, I have included the script in the source code for this
    chapter that I use to generate the coverage in HTML. The steps should be similar
    to other platforms. The script can be found at [https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/blob/master/ch06/pcov-html](https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/blob/master/ch06/pcov-html).
  prefs: []
  type: TYPE_NORMAL
- en: Please note, the test coverage percentage is not significant here. The critical
    thing to look at is what code has not been executed by any tests and decide whether
    that indicates an error that could reasonably occur and therefore a scenario that
    we need to add.
  prefs: []
  type: TYPE_NORMAL
- en: Now that our `RegisterHandler` is in much better shape, we can apply constructor
    injection in the same way to the other handlers in the `REST` package.
  prefs: []
  type: TYPE_NORMAL
- en: The results of these changes can be seen in the source code for this chapter
    at [https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/tree/master/ch06/acme/internal/rest](https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/tree/master/ch06/acme/internal/rest).
  prefs: []
  type: TYPE_NORMAL
- en: Applying constructor injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's apply constructor injection to our ACME registration service. This time
    we will be refactoring the REST package, starting with the `Register` endpoint.
    You may remember that `Register` is one of three endpoints in our service, the
    others being `Get` and `List`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Register` endpoint has three responsibilities:'
  prefs: []
  type: TYPE_NORMAL
- en: Validate the registration is complete and valid
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Call the currency conversion service to convert the registration price to the
    currency requested in the registration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Save the registration and the converted registration price into the database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code for our `Register` endpoint currently looks as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Disappointingly, we currently only have one test on this function, and it breaks
    way too easily. It requires both the database and our downstream exchange rate
    service to be accessible and configured.
  prefs: []
  type: TYPE_NORMAL
- en: While we can ensure our that local database is working, and any changes to it
    do not affect anyone but us, the downstream exchange rate service is on the internet
    and is rate limited. We have no control over it or when it works.
  prefs: []
  type: TYPE_NORMAL
- en: This means that even though we only have one test, that test has a high potential
    to be annoying to run and maintain because it can break at any time for reasons
    outside our control.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, we can not only remove these dependencies but also use mocks to
    create situations that we could not otherwise. For example, with mocks, we can
    test our error handling code for when the exchange rate service is down or out
    of quota.
  prefs: []
  type: TYPE_NORMAL
- en: Decoupling from the dependency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first step is to identify the dependency we wish to inject. For our handler,
    this is not the database or the exchange rate call. We wish to inject the next
    software layer, which in this case is the model layer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, we want to inject this line from our `register` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Following the same process we used easier, we first promote the object to a
    member variable, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'As this does nothing to decouple our code from the dependency, we then define
    our requirements as a local interface and update the member variable, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Building the constructor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that `RegisterHandler` requires an abstract dependency, we need to ensure
    that the dependency has been set by applying constructor injection, as shown in
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: With constructor injection applied, our `RegisterHandler` is less coupled to
    the model layer and our external resources (database and upstream service). We
    can leverage this looser coupling to improve and extend the test of our `RegisterHandler`.
  prefs: []
  type: TYPE_NORMAL
- en: Validating our improvements with the dependency graph
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we wrap up our work on the `REST` package, let's take stock of where
    we started, and where we are now. When we started, our handlers were tightly coupled
    with their matching `model` packages and poorly tested. Both of these problems
    have been resolved.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see whether our dependency graph is showing any signs of improvement:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4f8296e8-5655-44e8-9d61-3feda4dd019f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Sadly, it still looks the same as before. After digging into the code, we find
    the culprit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We are instantiating our model layer objects inside the constructor for our
    `Server` (part of the `REST` package). The fix is easy and hopefully obvious.
    We push the dependencies up one level, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Checking our dependency graph again, it finally now shows some improvement:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ebcea76d-8a3c-4d4a-bd7b-c33d36ca6ff7.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, it's flatter; the `REST` package has no dependence on the module
    layer (the `list`, `get`, and `register` packages).
  prefs: []
  type: TYPE_NORMAL
- en: There is still way too much dependence on the `data` and the `config` packages,
    but we will deal with that in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Disadvantages of constructor injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When it comes to DI, sadly there is no silver bullet. Despite the utility of
    constructor injection, it cannot be used in all cases. This section covers the
    disadvantages and limitations of constructor injection.
  prefs: []
  type: TYPE_NORMAL
- en: '**Can cause lots of changes**—When applying constructor injection to existing
    code, it can result in a lot of changes. This is particularly true if the code
    was initially written as functions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'As we saw in the previous section, to convert this to use constructor injection,
    we will have to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Convert from a function to a struct
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Convert the dependency on `*myShuffler` to something abstract by defining an
    interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a constructor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update all current usage of the function to use the constructor and to inject
    the dependency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of all the changes, the one that is most concerning is the last. Changes that
    occur locally, that is, in the same package, are easier to make and therefore
    less risky, but alterations to external packages, especially code that belongs
    to another team, are significantly more dangerous.
  prefs: []
  type: TYPE_NORMAL
- en: Other than being very careful, the best way to mitigate the risk is with tests.
    If the code has very little or no tests before the refactoring, it is beneficial
    to create some first before starting any refactoring.
  prefs: []
  type: TYPE_NORMAL
- en: DI with monkey patching might be an attractive candidate to swap out any dependencies
    in those tests. Yes, these tests will need to be refactored or removed after changing
    to constructor injection, but there is nothing wrong with that. Having tests will
    ensure that the code is working before the refactor, and those tests will continue
    to be informative during the refactoring. Or to put it a different way, the tests
    will help make the refactoring safer.
  prefs: []
  type: TYPE_NORMAL
- en: '**Can cause initialization issues**—When discussing the advantages of constructor
    injection, we mentioned separating the object from the life cycle of its dependencies.
    This code and the complexity still exist, they''ve just been pushed higher up
    the call graph. While being able to work on these concerns separately is definitely
    an advantage, it does create a secondary problem: object initialization order.
    Consider our ACME registration service. It has three layers, presentation, model,
    and data.'
  prefs: []
  type: TYPE_NORMAL
- en: Before the presentation layer can work, we need to have a working model layer.
  prefs: []
  type: TYPE_NORMAL
- en: Before the model layer can work, we need to have a working data layer.
  prefs: []
  type: TYPE_NORMAL
- en: Before the data layer can work properly, we must create a pool of database connections.
  prefs: []
  type: TYPE_NORMAL
- en: For a simple service, this has already become somewhat complicated. This complexity
    has led to the creation of many a DI framework, and we will investigate one such
    framework, Google's Wire, in [Chapter 10](3006fc58-da4c-49df-b109-10c57a86b7a7.xhtml),
    *Off-the-Shelf Injection*.
  prefs: []
  type: TYPE_NORMAL
- en: Another potential issue here is the sheer volume of objects that will be created
    at application start. While this does result in a slightly slower app start, once
    that initial *cost* has been paid, the application will no longer be delayed by
    dependency creation.
  prefs: []
  type: TYPE_NORMAL
- en: The last initialization issue to consider here is debugging.  When the creation
    of a dependency and its users are in the same part of the code, it is easier to
    understand and debug their life cycles and relationships.
  prefs: []
  type: TYPE_NORMAL
- en: '**The dangers of overuse**—Given that this technique is so easy to understand
    and use, it is also very easy to overuse. The most obvious sign of overuse is
    excessive constructor parameters. Excessive constructor parameters can indicate
    that the object has too many responsibilities, but it can also be a symptom of
    extracting and abstracting too many dependencies.'
  prefs: []
  type: TYPE_NORMAL
- en: Before extracting a dependency, think about encapsulation. What information
    do users of this object need to be aware of? The more information related to the
    implementation we can hide, the greater the flexibility we have to refactor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another aspect to consider is this: does the dependency need to be extracted,
    or can we leave it to configuration? Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: It is possible to abstract and inject `*http.Client`, but is that really necessary?
    In fact, the only aspect that really needs to change is the base URI. We will
    explore this approach further in [Chapter 8](a830a2d7-1e66-48eb-90d2-5b8f66dc40fe.xhtml),
    *Dependency Injection by Config*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Non-obvious requirement**—The use of a constructor in Go is not a required
    pattern. In some teams, it''s not even a standard pattern. As such, users might
    not even realize that the constructor exists and that they must use it. Given
    the code will likely crash rather spectacularly without the dependencies injected,
    this is unlikely to cause production issues, but it can be somewhat annoying.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Some teams have attempted to solve this problem by making the object private
    and only exporting the constructor and an interface, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This approach does ensure that the constructor is used, but it does have some
    costs.
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, we now have to keep the interface and the struct in sync. Not hard,
    but it is extra work and can get annoying.
  prefs: []
  type: TYPE_NORMAL
- en: Secondly, some users are tempted to use the interface rather than defining their
    own locally. This results in tight coupling between the user and the exported
    interface. This coupling can make it more difficult to make additions to the exported
    API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider using the previous example in another package, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Now, if we add another method to the `Client` interface, the aforementioned
    code will be broken.
  prefs: []
  type: TYPE_NORMAL
- en: '**Constructors are not inherited**—Unlike methods and *method injection*, which
    we will examine in the next chapter, constructors are not included when performing
    the composition; instead, we are required to remember the constructor exists and
    to use them.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another factor to consider when performing composition is that any parameter
    to the inner struct''s constructor will have to be added to the outer struct''s
    constructor, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: A relationship like the preceding one would severely discourage us from changing
    `InnerService` because we would be forced to make matching changes to `OuterService`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have examined DI with constructor injection. We have seen
    how easy it is to understand and apply. This is why it is the default choice for
    many programmers and in many situations.
  prefs: []
  type: TYPE_NORMAL
- en: We have seen how constructor injection brings a level of predictability to the
    relationship between an object and its dependencies, especially when we use guard
    clauses.
  prefs: []
  type: TYPE_NORMAL
- en: By applying constructor injection to our `REST` package, we were left with a
    collection of loosely coupled and easy-to-follow objects. Because of this, we
    were able to extend our test scenario coverage easily. We can also expect that
    any subsequent changes to the model layer are now unlikely to unduly affect our
    `REST` package.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will introduce DI with method injection, which (among
    other things) is a very convenient way to handle optional dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are the steps we used to adopt constructor injection?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a guard clause and when would you use it?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does constructor injection affect the life cycle of the dependency?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the ideal use cases for constructor injection?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
