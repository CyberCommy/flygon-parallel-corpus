- en: Chapter 4. Data Access Made Easy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**The Data Access Object** (**DAO**) design pattern is a simple and elegant
    way of abstracting database persistence from application business logic. This
    design ensures a clear separation of the two core parts of any enterprise application:
    the data access layer and the service (or business logic) layer. The DAO pattern
    is a well-understood Java EE programming structure, initially brought to prominence
    by Sun Microsystems in its Java EE Design Blueprints that has since been adopted
    by other programming environments such as the .NET framework.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following image illustrates where the DAO layer sits in the overall application
    structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Data Access Made Easy](img/5457_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Changing an implementation in the DAO layer should not affect the service layer
    in any way. This is achieved by defining DAO interfaces to encapsulate the persistence
    operations that the service layer can access. The DAO implementation itself is
    hidden to the service layer.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the DAO interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An interface in the Java programming language defines a set of method signatures
    and constant declarations. Interfaces expose behaviors (or *what* can be done)
    and define a contract that implementing classes promise to provide (*how* it is
    done). Our DAO layer will contain one interface and one implementing class per
    domain object.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The use of interfaces is an often misunderstood pattern in enterprise programming.
    The argument goes along the line, "Why add another set of Java objects to your
    codebase when they are not required". Interfaces do add to the number of lines
    of code that you write, but their beauty will be appreciated as soon as you are
    asked to refactor an aging project that was written with interfaces from the start.
    I have migrated an SQL-based persistence layer to a JPA persistence layer. The
    new DAO implementation replaced the old without any significant change in the
    service layer, thanks to the use of interfaces. Development was done in parallel
    to supporting the existing (old) implementation until we were ready to swap in
    the new implementation. This was a relatively painless process that would not
    have been as easily achieved without the use of interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start with the company interface.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the CompanyDao interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Navigate to **File** | **New File** from the menu and select **Java Interface**
    as shown in the following screenshot:![Adding the CompanyDao interface](img/5457_04_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Next** button and fill in the details as shown in the following
    screenshot:![Adding the CompanyDao interface](img/5457_04_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The name of the interface is `CompanyDao`. We could have named this interface
    using the uppercase acronym `CompanyDAO`. In keeping with the newer Java EE naming
    styles, we have decided to use the camel case form of the acronym. Recent examples
    of this style include the `Html`*, `Json`*, and `Xml`* classes and interfaces,
    an example of which is `javax.json.JsonObject`. We also believe that this form
    is easier to read. However, this does not prohibit you from using the uppercase
    acronym; there are many of these examples in Java EE as well (`EJB`*, `JAXB`*,
    and `JMS`* interfaces and classes to name a few). Whatever you choose, be consistent.
    Do not mix forms and create `CompanyDAO` and `ProjectDao` interfaces!
  prefs: []
  type: TYPE_NORMAL
- en: Note that the package `com.gieman.tttracker.dao` does not exist yet and will
    be created for you. Click on **Finish** to create your first interface, after
    which NetBeans will open the file in the editor.
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding the CompanyDao interface](img/5457_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The Company interface will define the persistence methods that we will use
    in our application. The core methods must include the ability to perform each
    CRUD operation in addition to any other operations appropriate to our business
    needs. We will add the following methods to this interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '`persist`: This method inserts a new company record'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`merge`: This method updates an existing company record'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`remove`: This method deletes a company record'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`find`: This method selects a company record using a primary key'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`findAll`: This method returns all the company records'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Note that the JPA terminologies `persist`, `merge`, `remove`, and `find` are
    equivalent to the SQL operations `insert`, `update`, `delete`, and `select`. Add
    the methods to `CompanyDao` as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We have defined a contract that the implementing class must promise to deliver.
    We will now add the `ProjectDao` interface.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the ProjectDao interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `ProjectDao` interface will define a similar set of methods to the `CompanyDao`
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You will note that all method signatures in the `ProjectDao` interface are
    identical to the `CompanyDao` interface. The only difference is in class types
    where `Company` is replaced by `project`. The same situation will occur in all
    the other interfaces that we are going to add (`TaskDao`, `UserDao`, and `TaskLogDao`).
    Each of the interfaces will require a definition for the `find` method that will
    look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the only functional difference in each of these methods is the
    returned type. The same can be said for the `persist`, `merge`, and `remove` methods.
    This situation lends itself perfectly to the use of Java generics.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a generic DAO interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This interface will be extended by each of our DAO interfaces. The `GenericDao`
    interface uses generics to define each method in a way that can be used by each
    descendent interface. These methods will then be available free of cost to the
    extending interfaces. Rather than defining a `find(Integer id)` method in each
    of the `CompanyDao`, `ProjectDao`, `TaskDao`, `UserDao`, and `TaskLogDao` interfaces,
    the `GenericDao` interface defines the generic method that is then available for
    all descendants.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is a powerful technique for enterprise application programming and should
    always be considered when designing or architecting an application framework.
    A well-structured design using Java generics will simplify change requests and
    maintenance for many years to come.
  prefs: []
  type: TYPE_NORMAL
- en: 'The generic interface definition looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now refactor the `CompanyDao` interface as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note the way in which we have extended the `GenericDao` interface using the
    `<Company, Integer>` types. The type parameters `<T, ID>` in the `GenericDao`
    interface become placeholders for the types specified in the `CompanyDao` definition.
    A `T` or `ID` that is found in the `GenericDao` interface will be replaced with
    `Company` and `Integer` in the `CompanyDao` interface. This automatically adds
    the `find`, `persist`, `merge`, and `remove` methods to `CompanyDao`.
  prefs: []
  type: TYPE_NORMAL
- en: Generics allow the compiler to check type correctness at compile-time. This
    improves code robustness. A good explanation of Java generics can be found at
    [http://docs.oracle.com/javase/tutorial/extra/generics/index.html](http://docs.oracle.com/javase/tutorial/extra/generics/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'In a similar way, we can now refactor the `ProjectDao` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Let's continue with the missing interfaces in the same manner.
  prefs: []
  type: TYPE_NORMAL
- en: The TaskDao interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Apart from the common generic methods, we will once again need a `findAll`
    method. This interface looks like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The UserDao interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will need a list of all the users in the system as well as a few finder
    methods to identify a user by different parameters. These methods will be required
    when we develop our frontend user interfaces and service layer functionality.
    The `UserDao` interface looks like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `UserDao` interface extends `GenericDao` with a `String` ID type.
    This is because the `User` domain entity has a `String` primary key type.
  prefs: []
  type: TYPE_NORMAL
- en: The TaskLogDao interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `TaskLogDao` interface will also need a few additional methods to be defined
    in order to allow different views into the task log data. These methods will once
    again be required when we develop our frontend user interfaces and service layer
    functionality.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note that our finder methods for the `TaskLogDao` interface have descriptive
    names that identify the purpose of the method. Each finder method will be used
    to retrieve a subset of task log entries that are appropriate for the business
    needs of the application.
  prefs: []
  type: TYPE_NORMAL
- en: This covers all the required interfaces for our application. It is now time
    to define the implementations for each of our interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the generic DAO implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will once again use Java generics to define a common ancestor class that
    will be extended by each of our implementation classes (`CompanyDaoImpl`, `ProjectDaoImpl`,
    `TaskDaoImpl`, `TaskLogDaoImpl`, and `UserDaoImpl`). The `GenericDaoImpl` and
    all other implementing classes will be added to the same `com.gieman.tttracker.dao`
    package as our DAO interfaces. Key lines of code in `GenericDaoImpl` are highlighted
    and will be explained in the following sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: There are a lot of new concepts in this class! Let's tackle them one at a time.
  prefs: []
  type: TYPE_NORMAL
- en: The Simple Logging Facade for Java
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Simple Logging Facade for Java or SLF4J is a simple abstraction for key
    logging frameworks including `java.util.logging`, `log4j` and `logback`. SLF4J
    allows the end user to plug in the desired logging framework at deployment time
    by simply including the appropriate implementation library. More information about
    SLF4J can be found at [http://slf4j.org/manual.html](http://slf4j.org/manual.html).
    Logging not only allows developers to debug code, but it can also provide a permanent
    record of actions and application state within your application. Examples of application
    state could be current memory usage, the number of authorized users currently
    logged on, or the number of pending messages awaiting processing. Log files are
    usually the first place to look at when analyzing production bugs, and they are
    an important component of any enterprise application.
  prefs: []
  type: TYPE_NORMAL
- en: Although the default Java logging is adequate for simple uses, it would not
    be appropriate for more sophisticated applications. The `log4J` framework ([http://logging.apache.org/log4j/1.2](http://logging.apache.org/log4j/1.2))
    and the `logback` framework ([http://logback.qos.ch](http://logback.qos.ch)) are
    examples of highly configurable logging frameworks. The `logback` framework is
    usually considered the successor of `log4j` as it offers some key advantages over
    `log4j` including better performance, less memory consumption, and automatic reloading
    of configuration files. We will use `logback` in our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The required SLF4J and `logback` libraries will be added to the application
    by adding the following dependency to `pom.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'You will also need to add the additional `logback.version` property to `pom.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now perform a **Clean and Build Project** to download the `logback-classic`,
    `logback-core`, and `slf4j-api` JAR files. This will then enable us to add the
    imports defined in `GenericDaoImpl` as well as the logger definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: All descendent classes will now be able to use the logger (it is declared as
    `protected`) but will not be able to change it (it is declared as `final`). We
    will start using the logger in [Chapter 5](ch05.html "Chapter 5. Testing the DAO
    Layer with Spring and JUnit"), *Testing the DAO Layer with Spring and JUnit*,
    where we will examine the `logback.xml` configuration file in detail.
  prefs: []
  type: TYPE_NORMAL
- en: The@PersistenceContext(unitName = "tttPU") line
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This one line annotating the `EntityManager` interface method is all that's
    required for Spring Framework to plug in or inject the `EclipseLink` implementation
    during runtime. The `EntityManager` interface defines methods for interacting
    with the persistence context such as `persist`, `merge`, `remove`, and `find`.
    A full listing of the `EntityManager` interface methods can be found at [http://docs.oracle.com/javaee/7/api/javax/persistence/EntityManager.html](http://docs.oracle.com/javaee/7/api/javax/persistence/EntityManager.html).
  prefs: []
  type: TYPE_NORMAL
- en: Our persistence context is defined in `persistence.xml` in which we have named
    it as `tttPU`. This is what binds `EntityManager` in `GenericDaoImpl` to the persistence
    context through the `@PersistenceContext` annotation `unitName` property. A persistence
    context is a set of entity instances (in our application, these are the `Company`,
    `Project`, `Task`, `User`, and `TaskLog` objects) in which, for any persistent
    entity, there is a unique entity instance. Within the persistence context, the
    entity instances and their lifecycle is managed.
  prefs: []
  type: TYPE_NORMAL
- en: The `EntityManager` API is used to create and remove persistent entity instances,
    to find entities by their primary key, and to query over entities. In our `GenericDaoImpl`
    class, the `EntityManager` instance `em` is used to perform the generic CRUD operations.
    Each descendent class will hence have access to these methods as well as the `em`
    instance itself (it is declared as protected).
  prefs: []
  type: TYPE_NORMAL
- en: The @Transactional annotation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `@Transactional` annotation is the cornerstone of Spring's declarative transaction
    management. It allows you to specify transactional behavior at an individual method
    level and is very simple to use. This option has the least impact on application
    code, and it does not require any complex configuration. In fact, it is completely
    non-invasive as there is no Java coding required for commits and rollbacks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring recommends that you only annotate classes (and methods of classes) with
    the `@Transactional` annotation as opposed to annotating interfaces (a full explanation
    can be found at [http://static.springsource.org/spring/docs/3.2.x/spring-framework-reference/html/transaction.html](http://static.springsource.org/spring/docs/3.2.x/spring-framework-reference/html/transaction.html)).
    For this reason, we will annotate all appropriate methods in the generic and implementing
    classes with one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `@Transactional` annotation is metadata that specifies that a method must
    have transactional semantics. For example, we could define metadata that defines
    starting a brand new read-only transaction when this method is invoked, suspending
    any existing transaction. The default `@Transactional` settings are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`propagation` setting is `Propagation.REQUIRED`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`readOnly` is false'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is a good practice to define all properties including default settings, as
    we have done previously. Let's examine these properties in detail.
  prefs: []
  type: TYPE_NORMAL
- en: The Propagation.REQUIRED property
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is the default value for transactions that do not specify a `propagation`
    setting. This property supports a current transaction if one exists or creates
    a new one if none exists. This ensures that the `Propagation.REQUIRED` annotated
    method will always have a valid transaction available and should be used whenever
    the data is modified in the persistence storage. This property is usually combined
    with `readOnly=false`.
  prefs: []
  type: TYPE_NORMAL
- en: The Propagation.SUPPORTS property
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This property supports a current transaction if one exists or executes non-transactionally
    if none exists. The `Propagation.SUPPORTS` property should be used if the annotated
    method does not modify the data (will not execute an `insert`, `update`, or `delete`
    statement against the database). This property is usually combined with `readOnly=true`.
  prefs: []
  type: TYPE_NORMAL
- en: The readOnly property
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This just serves as a hint for the actual transaction subsystem to allow optimization
    of executed statements if possible. It may be possible that the transaction manager
    may not be able to interpret this property. For self-documenting code, however,
    it is a good practice to include this property.
  prefs: []
  type: TYPE_NORMAL
- en: Other transaction properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Spring allows us to fine-tune transactional properties with additional options
    that are beyond the scope of this book. Browse the link that was mentioned earlier
    to find out more about how transactions can be managed in more complex scenarios
    including multiple transactional resources.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the DAO implementations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following DAO implementations will inherit the core CRUD operations from
    `GenericDaoImpl` and add their own class-specific methods as defined in the implemented
    interface. Each method will use the `@Transactional` annotation to define the
    appropriate transactional behavior.
  prefs: []
  type: TYPE_NORMAL
- en: The CompanyDaoImpl class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The full listing for our `CompanyDaoImpl` class is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The first thing to notice is the `@Repository("companyDao")` annotation. This
    annotation is used by Spring to automatically detect and process DAO objects when
    the application is loaded. The Spring API defines this annotation as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It indicates that an annotated class is a `Repository`, originally defined by
    Domain-Driven Design (Evans, 2003) as a mechanism for encapsulating storage, retrieval,
    and search behavior that emulate a collection of objects.
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of the annotation is to allow Spring to auto detect implementing
    classes through the `classpath` scanning and to process this class for data access
    exception translation (used by Spring to abstract database exception messages
    from the underlying implementation). The Spring application will then hold a reference
    to the implementing class under the key `companyDao`. It is considered as the
    best practice to match the key value with the name of the implemented interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `CompanyDaoImpl` class also introduces the use of the JPA named queries
    that were defined during the reverse engineering process in the previous chapter.
    The method call `em.createNamedQuery("Company.findAll")` creates the named query
    defined by the unique identifier `"Company.findAll"` in the persistence engine.
    This named query was defined in the `Company` class. Calling `getResultList()`
    executes the query against the database, returning a `java.util.List` of Company
    objects. Let''s now review the named query definition in the `Company` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We will make a minor change to this named query to arrange the results by `companyName`
    in ascending order. This will require the addition of an `ORDER BY` clause in
    the query statement. The final named queries definition in the `Company` class
    will now look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The ProjectDaoImpl class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This implementation is defined as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Once again, we will add the `ORDER BY` clause to the `Project.findAll` named
    query in the Project class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The TaskDaoImpl class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This class is defined as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Once again, we will add the `ORDER BY` clause to the `Task.findAll` named query
    in the Task class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The UserDaoImpl class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This `UserDaoImpl` class will require an additional named query in the `User`
    domain class to test a user''s logon credentials (username/password combination).
    The `UserDaoImpl` class definition follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The missing named query is `User.findByUsernamePassword` that is used to verify
    a user with the given username and password. The query definition must be added
    to the `User` class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Note that this definition allows a user to be matched by either the username
    or e-mail field. As is the common practice in web applications, a user may log
    on with either their unique logon name (username) or their e-mail address.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `findByEmail`, `findByUsername`, and `findByUsernamePassword` methods can
    only ever return `null` (no match found) or a single result as there cannot be
    more than one record in the database with these unique fields. Instead of using
    the `getResultList()` method to retrieve a `List` of results and testing for a
    list size of one, we could have used the code that is similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `getSingleResult()` method returns exactly one result or throws an exception
    if a single result could not be found. You will also notice the need to cast the
    returned result to the required `User` type. The calling method would also need
    to catch any exceptions that would be thrown from the `getSingleResult()` method
    unless the sample code given previously is changed to catch the exception.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We believe that the code in our `UserDaoImpl` interface is cleaner than the
    previous example that uses the `try`/`catch` function to wrap the `getSingleResult()`
    method. In both cases, however, the method returns `null` if the record cannot
    be found.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Exceptions should be used judiciously in enterprise programming and only for
    truly exceptional circumstances. Throwing exceptions should be avoided unless
    the exception indicates a situation that the calling code cannot recover from.
    It is far cleaner to return `null` (or perhaps true/false in appropriate scenarios)
    to indicate that a situation is not as expected.
  prefs: []
  type: TYPE_NORMAL
- en: We do not consider being unable to find a record by ID, or by e-mail or by e-mail
    address as an exceptional circumstance; it is possible that a different user has
    deleted the record, or there is simply no record with the e-mail specified. Returning
    `null` clearly identifies that the record was not found without the need to throw
    an exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'Regardless of whether you throw exceptions to indicate a record that cannot
    be found or use `null` as is our preference, your API should be documented to
    indicate the behavior. The `UserDaoImpl.findByUsernamePassword` method could,
    for example, be documented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Users of your API will then understand the expected behavior and code their
    interactions accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: The TaskLogDaoImpl class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The final DAO class in our application follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, we will refactor the `TaskLog` named queries as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We have removed several queries that will not be required and added three new
    ones as shown. The `TaskLog.findByUser` query will be used to list task logs assigned
    to a user for the given date range. Note the use of the `BETWEEN` key word to
    specify the date range. Also note the use of the `TemporalType.DATE` when setting
    the parameter in the `TaskLogDaoImpl.findByUser` method. This will ensure a strict
    date comparison, ignoring any time component, if present, in the arguments.
  prefs: []
  type: TYPE_NORMAL
- en: The `TaskLog.findTaskLogCountByTask` and `TaskLog.findTaskLogCountByUser` named
    queries will be used in our service layer to test if deletions are permitted.
    We will implement checks to ensure that a user or a task may not be deleted if
    valid task logs are assigned.
  prefs: []
  type: TYPE_NORMAL
- en: A better domain layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s now revisit the domain layer created in [Chapter 3](ch03.html "Chapter 3. Reverse
    Engineering the Domain Layer with JPA"), *Reverse Engineering the Domain Layer
    with JPA*. Defining an ancestor class for all entities in this layer is not only
    the best practice but will also make our domain layer far easier to enhance in
    the future. Our ancestor class is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Although this class has an empty implementation, we will add functionality in
    subsequent chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will also define an appropriate interface that has one generic method to
    return the ID of the entity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Our domain layer can now extend our base `AbstractEntity` class and implement
    the `EntityItem` interface. The changes required to our `Company` class follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'In a similar way, we can change the remaining domain classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: We will now be well prepared for future changes in the domain layer.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise – a simple change request
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This simple exercise will again demonstrate the power of generics. Each record
    inserted into the database should now be logged at using `logger.info()` with
    the message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition, records that are deleted should be logged using `logger.warn()`
    with the message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: In both cases, the `?` token should be replaced with the ID of the entity being
    inserted or deleted while the `className` token should be replaced with the class
    name of the entity being inserted or deleted. This is a trivial change when using
    generics, as the code can be added to the `persist` and `remove` methods of the
    `GenericDaoImpl` class. Without the use of generics, each of the `CompanyDaoImpl`,
    `ProjectDaoImpl`, `TaskDaoImpl`, `UserDaoImpl`, and `TaskLogDaoImpl` classes would
    need to have this change made. When you consider that enterprise applications
    may have 20, 30, 40, or more tables represented in the DAO layer, such a trivial
    change may not be so trivial without the use of generics.
  prefs: []
  type: TYPE_NORMAL
- en: Your task is to implement the change request as outlined previously. Note that
    this exercise will introduce you to the `instanceof` operator.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter has introduced the Data Access Object design pattern and defined
    a set of interfaces that will be used in our 3T application. The DAO design pattern
    clearly separates the persistence layer operations from the business logic of
    the application. As will be introduced in the next chapter, this clear separation
    ensures that the data access layer is easy to test and maintain.
  prefs: []
  type: TYPE_NORMAL
- en: We have also introduced Java Generics as a technique to simplify application
    design by moving common functionality to an ancestor. The `GenericDao` interface
    and the `GenericDaoImpl` class define and implement methods that will be available
    free of cost to the extending components. Our implementations also introduced
    SLF4J, transactional semantics, and working with JPA named queries.
  prefs: []
  type: TYPE_NORMAL
- en: Our journey will now continue with [Chapter 5](ch05.html "Chapter 5. Testing
    the DAO Layer with Spring and JUnit"), *Testing the DAO Layer with Spring and
    JUnit*, where we will configure a testing environment and develop test cases for
    several of our DAO implementations.
  prefs: []
  type: TYPE_NORMAL
