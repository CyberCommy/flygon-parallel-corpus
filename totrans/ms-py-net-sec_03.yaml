- en: Socket Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: his chapter will introduce you to some of the basics of Python networking using
    the `socket` module. Along the way, we'll build clients, servers with TCP, and
    **user datagram** **protocol** (**UDP**) protocols. Sockets Programming covers
    using TCP and UDP sockets from Python for writing low-level network applications.
    We will also cover HTTPS and TLS for secure data transport.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the sockets and how to implement them in Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the TCP Programming Client and Server in Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand the UDP Programming Client and Server in Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand socket methods for resolving IP addresses and domains
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying all concepts in practical uses cases, such as port scanning, and managing
    exceptions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Examples and source code for this chapter are available in the GitHub repository
    in the `chapter 3` folder: [https://github.com/PacktPublishing/Mastering-Python-for-Networking-and-Security](https://github.com/PacktPublishing/Mastering-Python-for-Networking-and-Security).
  prefs: []
  type: TYPE_NORMAL
- en: You will need to install a Python distribution on your local machine with at
    least 2 GB memory and some basic knowledge about network protocols.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to sockets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sockets are the main component that allows us to take advantage of the operating
    system's capabilities to interact with the network. You can think of sockets as
    a point-to-point communication channel between a client and a server.
  prefs: []
  type: TYPE_NORMAL
- en: Network sockets are an easy way to establish a communication between processes
    that are on the same or different machines. The concept of a socket is very similar
    to that of UNIX file descriptors. Commands such as `read()` and `write()` ( to
    work with the file system ) work in a similar way to sockets.
  prefs: []
  type: TYPE_NORMAL
- en: A network socket address consists of an IP address and port number. The goal
    of a socket is to communicate processes through the network.
  prefs: []
  type: TYPE_NORMAL
- en: Network sockets in Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Communication between different entities in a network is based on Python's classic
    concept of sockets. A socket is defined by the IP address of the machine, the
    port on which it listens, and the protocol it uses.
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating a socket in Python it is done through the `socket.socket()` method.
    The general syntax of the socket method is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: These **arguments** represent the address families and the protocol of the transport
    layer.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on socket type, sockets are classified into flow sockets (`socket.SOCK_STREAM`)
    or datagram sockets (`socket.SOCK_DGRAM`), based on whether the service uses TCP
    or UDP. `socket.SOCK_DGRAM` is used for UDP communications, and `socket.SOCK_STREAM`
    for TCP connections.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sockets can also be classified according to the family. We have UNIX sockets
    (`socket.AF_UNIX`) which were created before the concept of networks and are based
    on files, the `socket.AF_INET` socket which is the one that interests us, the `socket.AF_INET6
    for IPv6` socket, and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/8617f5df-4575-4951-ab3a-1d6add4a165a.png)'
  prefs: []
  type: TYPE_IMG
- en: The socket module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Types and functions needed to work with sockets can be found in Python in the
    `socket` module. The `socket` module exposes all of the necessary pieces to quickly
    write TCP and UDP clients and servers. The `socket` module has almost everything
    you need to build a socket server or client. In the case of Python, the socket
    returns an object to which the socket methods can be applied.
  prefs: []
  type: TYPE_NORMAL
- en: This module comes installed by default when you install the Python distribution.
  prefs: []
  type: TYPE_NORMAL
- en: 'To check it, we can do so from the Python interpreter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/51894bae-8aea-48b5-baf5-676c2046591f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In this screenshot, we see all the constants and methods that we have available
    in this module. The constants we see in the first instance within the structure
    that has returned the object. Among the most-used constants, we can highlight
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'A typical call to build a socket that works at the TCP level is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Socket methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These are the general socket methods we can use in both clients and servers:'
  prefs: []
  type: TYPE_NORMAL
- en: '`socket.recv(buflen)`: This method receives data from the socket. The method
    argument indicates the maximum amount of data it can receive.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`socket.recvfrom(buflen)`: This method receives data and the sender''s address.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`socket.recv_into(buffer)`: This method receives data into a buffer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`socket.recvfrom_into(buffer)`: This method receives data into a buffer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`socket.send(bytes)`: This method sends bytes data to the specified target.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`socket.sendto(data, address)`: This method sends data to a given address.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`socket.sendall(data)`: This method sends all the data in the buffer to the
    socket.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`socket.close()`: This method releases the memory and finishes the connection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Server socket methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In a **client-server architecture**, there is a central server that provides
    services to a set of machines that connect. These are the main methods we can
    use from the point of view of the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '`socket.bind(address)`: This method allows us to connect the address with the
    socket, with the requirement that the socket must be open before establishing
    the connection with the address'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`socket.listen(count)`: This method accepts as a parameter the maximum number
    of connections from clients and starts the TCP listener for incoming connections'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`socket.accept()`: This method allows us to accept connections from the client.
    This method returns two values: `client_socket` and client address. `client_socket`
    is a new socket object used to send and receive data. Before using this method,
    you must call the `socket.bind(address)` and `socket.listen(q)` methods'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Client socket methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is the socket method we can use in our socket client for connecting with
    the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '`socket.connect(ip_address)`: This method connects the client to the server
    IP address'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can obtain more information about this method with the `help(socket)` command.
    We learn that this method does the same as the `connect_ex` method and also offers
    the possibility of returning an error in the event of not being able to connect
    with that address.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can obtain more information about these methods with the `help(socket)`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/6d26def8-753b-4270-8ae2-909cb98b0051.png)'
  prefs: []
  type: TYPE_IMG
- en: Basic client with the socket module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this example, we are testing how to send and receive data from a website.Once
    the connection is established, we can send and receive data. Communication with
    the socket can be done very easily thanks to two functions, `send ()` and `recv
    ()`, used for TCP communications. For UDP communication, we use `sendto ()`, and `recvfrom
    ()`
  prefs: []
  type: TYPE_NORMAL
- en: In this `socket_data.py` script, we create a socket object with the `AF_INET`
    and `SOCK_STREAM` parameters. We then connect the client to the remote host and
    send it some data. The last step is to receive some data back and print out the
    response. We use an infinite loop (while `True`) and we check whether the data
    variable is empty. If this condition occurs, we finish the loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the following code in the `socket_data.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Creating a simple TCP client and TCP server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The idea behind creating this application is that a socket client can establish
    a connection against a given host, port, and protocol. The socket server is responsible
    for receiving connections from clients in a specific port and protocol.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a server and client with sockets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To create a socket, the `socket.socket()` constructor is used, which can take
    the family, type, and protocol as optional parameters. By default, the `AF_INET`
    family and the `SOCK_STREAM` type are used.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will see how to create a couple of client and server scripts
    as an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we have to do is create a socket object for the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We now have to indicate on which port our server will listen using the bind
    method. For IP sockets, as in our case, the bind argument is a tuple that contains
    the host and the port. The host can be left empty, indicating to the method that
    you can use any name that is available.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `bind(IP,PORT)` method allows you to associate a host and a port with a
    specific socket, taking into account that ports `1-1024` are reserved for the
    standard protocols:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we use listen to make the socket accept incoming connections and to
    start listening. The listen method requires a parameter that indicates the number
    of maximum connections we want to accept.
  prefs: []
  type: TYPE_NORMAL
- en: The `accept` method keeps waiting for incoming connections, blocking execution
    until a message arrives.
  prefs: []
  type: TYPE_NORMAL
- en: 'To accept requests from a client socket, the `accept()` method should be used.
    In this way, the server socket waits to receive an input connection from another
    host:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We can obtain more information about these methods with the `help(socket)`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/d1606fe2-424f-4112-9426-0d1abf78022c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once we have this socket object, we can communicate with the client through
    it, using the `recv` and `send` methods (or `recvfrom` and `sendfrom` in UDP)
    that allow us to receive or send messages, respectively. The send method takes
    as parameters the data to send, while the `recv` method takes as a parameter the
    maximum number of bytes to accept:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'To create a client, we have to create the socket object, use the connect method
    to connect to the server, and use the send and recv methods we saw earlier. The
    connect argument is a tuple with host and port, exactly like bind:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Let's see a complete example. In this example, the client sends to the server
    any message that the user writes and the server repeats the received message.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the TCP serverIn this example, we are going to create a multithreaded
    TCP server.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The server socket opens a TCP socket on `localhost:9999` and listens to requests
    in an infinite loop. When you receive a request from the client socket, it will
    return a message indicating that a connection has been made from another machine.
  prefs: []
  type: TYPE_NORMAL
- en: The while loop keeps the server program alive and does not allow the code to
    end. The `server.listen(5)` statement listens to the connection and waits for
    the client. This instruction tells the server to start listening with the maximum
    backlog of connections set to `5`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the following code in the `tcp_server.py` file inside the `tcp_client_server`
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Implementing the TCP client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The client socket opens the same type of socket as that on which the server
    is listening and sends a message. The server responds and ends its execution,
    closing the client socket.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the following code in the `tcp_client.py` file inside the `tcp_client_server`
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, the `new: s.connect((host,port))` method connects the
    client to the server, and the `s.recv(1024)` method receives the strings sent
    by the server.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a simple UDP client and UDP server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we review how you can set up your own UDP client-server application
    with Python's `Socket` module. The application will be a server that listens for
    all connections and messages over a specific port and prints out any messages
    to the console.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to the UDP protocol
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'UDP is a protocol that is on the same level as TCP, that is, above the IP layer.
    It offers a service in disconnected mode to the applications that use it. This
    protocol is suitable for applications that require efficient communication that
    doesn''t have to worry about packet loss. The typical applications of UDP are
    internet telephony and video-streaming. The header of a UDP frame is composed
    of four fields:'
  prefs: []
  type: TYPE_NORMAL
- en: The UDP port of origin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The UDP destination port
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The length of the UDP message
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The chekSum as the error-control field
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The only difference regarding working with TCP in Python is that when creating
    the socket, you have to use `SOCK_DGRAM` instead of `SOCK_STREAM`.
  prefs: []
  type: TYPE_NORMAL
- en: The main difference between TCP and UDP is that UDP is not connection-oriented,
    this means that there is no guarantee our packets will reach their destinations,
    and no error notification if a delivery fails.
  prefs: []
  type: TYPE_NORMAL
- en: UDP client and server with the socket module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this example, we'll create a synchronous UDP server, which  means each request
    must wait until the end of the process of the previous request. The `bind()` method
    will be used to associate the port with the IP address. For the reception of the
    message, we use the `recvfrom()` and `sendto()` methods for the sending.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the UDP Server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The main difference with TCP is that UDP does not control the errors of the
    packets that are sent. The only difference between a TCP socket and a UDP socket
    that must specify `SOCK_DGRAM` instead of `SOCK_STREAM` when creating the socket
    object. Use the following code to create the UDP server:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the following code in the **`udp_server.py` **file inside the `udp_client_server`
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code, we see that `socket.SOCK_DGRAM` creates a UDP socket,
    and data, **`addr = s.recvfrom(buffer)`** returns the data and the source's address.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have finished our server, we need to implement our client program.
    The server that will be continuously listening on our defined IP address and port
    number for any UDP messages. It is essential that this server is run prior to
    the execution of the Python client script or the client script will fail.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the UDP client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To begin implementing the client, we will need to declare the IP address that
    we will be trying to send our UDP messages to, as well as the port number. This
    port number is arbitrary but you must ensure you aren''t using a socket that has
    already been taken:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now it''s time to create the socket through which we will be sending our UDP
    message to the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, once we''ve constructed our new socket, it''s time to write the
    code that will send our UDP message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'You can find the following code in the **`udp_client.py` **fileinside the `udp_client_server`
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'If we try to use `SOCK_STREAM` with the UDP socket, we get  `error: Traceback
    (most recent call last): File ".\udp_server.py", line 15, in <module> data,addr
    = socket_server.recvfrom(buffer)socket.error: [Errno 10057] A request to send
    or receive data was disallowed because the socket is not connected and no address
    was supplied`.'
  prefs: []
  type: TYPE_NORMAL
- en: Resolving IP addresses and domains
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have looked at how to build sockets in Python, both oriented
    to connection with TCP and not oriented to connection with UDP. In this section,
    we'll review useful methods to get more information about an IP address or domain.
  prefs: []
  type: TYPE_NORMAL
- en: Gathering information with sockets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Useful methods to gather more information are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`gethostbyaddr(address)`: Allows us to obtain a domain name from the IP address'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gethostbyname(hostname)`: Allows us to obtain an IP address from a domain
    name'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can get more information about these methods with the `help(socket)` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/dcfa6c52-52f4-4d99-95c6-fe9fcf06dd81.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now we are going to detail some methods related to the host, IP address, and
    domain resolution. For each one, we will show a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`socket.gethostbyname(hostname)`: This method converts a hostname to the IPv4
    address format. The IPv4 address is returned in the form of a string. This method
    is equivalent to the `nslookup` command we can find in many operating systems:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '`socket.gethostbyname_ex(name)`: This method returns many IP addresses for
    a single domain name. It means one domain runs on multiple IPs:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '`socket.getfqdn([domain])`: This is used to find the fully-qualified name of
    a domain:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '`socket.gethostbyaddr(ip_address)`: This method returns a tuple (`hostname`,
    `name`, `ip_address_list`) where hostname is the hostname that responds to the
    given IP address, the name is a list of names associated with the same address,
    and `the_address_list` is a list of IP addresses for the same network interface
    on the same host:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '`socket.getservbyname(servicename[, protocol_name])`: This method allows you
    to obtain the port number from the port name:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '`socket.getservbyport(port[, protocol_name])`: This method performs the reverse
    operation of the previous, allowing you to obtain the port name from the port
    number:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The following script is an example of how we can use these methods to obtain
    information from Google servers.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the following code in the `socket_methods.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `socket.connect_ex(address)` method is used to implement port-scanning with
    sockets. This script shows ports are open in the localhost machine with the loopback
    IP address interface of `127.0.0.1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the following code in the `socket_ports_open.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Reverse lookup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This command obtains the host name from the IP address. For this task, we can
    use the `gethostbyaddr()` function. In this script, we obtain the host name from
    the IP address of `8.8.8.8`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the following code in the `socket_reverse_lookup.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Practical use cases for sockets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll review how we can implement port-scanning with sockets
    and how to manage exceptions when we are working with sockets.
  prefs: []
  type: TYPE_NORMAL
- en: Port scanner with sockets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sockets are the fundamental building block for network communications and in
    an easy way we can check whether a specific port is open, closed, or filtered
    by calling the `connect_ex` method.
  prefs: []
  type: TYPE_NORMAL
- en: For example, we could have a function that accepts by parameters an IP and a
    list of ports and return for each port whether it is open or closed.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we need to import the socket and `sys` modules. If we execute
    the function from our main program, we see how it checks each of the ports and
    returns whether it is open or closed for a specific IP address. The first parameter
    can be either an IP address or a domain name since the module is able to resolve
    a name from an IP and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the following code in the `check_ports_socket.py`file inside the `port_scan`
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The following Python code will allow you to scan a local or remote host for
    open ports. The program scans for select ports on a certain IP address entered
    by the user and reflects the open ports back to the user. If the port is closed,
    it also shows information about the reason for that, for example by timeout connection.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the following code in the `socket_port_scanner.py`file inside the `port_scan`
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'The script starts with information related to the IP address and ports introduced
    by the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We continue the script with a for loop from `startPort` to `endPort` to analyze
    each port in between.We finish by showing the total time to complete the port
    scanning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'In the execution of the previous script, we can see ports that are open and
    the time in seconds for complete port-scanning:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/4cd90073-6b11-4d10-bc57-cf996c26d4db.png)'
  prefs: []
  type: TYPE_IMG
- en: The following Python script will allow us to scan an IP address with the `portScanning`
    and `socketScan` functions. The program scans for selected ports on a specific
    domain resolved from the IP address entered by the user by parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this script, the user must enter as mandatory parameters the host and a
    port, separated by a comma:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/fb2d53e2-8076-426f-a13f-c52a0c3148e9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can find the following code in the `socket_portScan.py`file inside the `port_scan`
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This is our main program when we get mandatory parameters host and ports for
    the script execution. Once we have obtained these parameters, we call the `portScanning`
    function which will resolve the IP address and host name, and will call the `socketScan`
    function that will use the `socket` module to determine the port state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'In the execution of the previous script, we can see that all ports are closed
    in the `google-public-dns-a.google.com` domain:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/45a671e7-9e5a-47e5-84df-0880e69b1ec8.png)'
  prefs: []
  type: TYPE_IMG
- en: Managing socket exceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to handle exceptions, we''ll use the try and except blocks. Different
    types of exceptions are defined in Python''s socket library for different errors.
    These exceptions are described here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`exception socket.timeout`: This block catches exceptions related to the expiration
    of waiting times.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`exception socket.gaierror`: This block catches errors during the search for
    information about IP addresses, for example when we are using the `getaddrinfo()`
    and `getnameinfo()` methods.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`exception socket.error`: This block catches generic input and output errors
    and communication. This is a generic block where you can catch any type of exception.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next example shows you how to handle the exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the following code in the `manage_socket_errors.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous script, when a connection timeout with an IP address occurs,
    it throws an exception related to the socket connection with the server. If you
    try to get information about specific domains or IP addresses that don''t exist,
    it will probably throw a `socket.gaierror` exception with the `connection error
    to the server:[Errno 11001] getaddrinfo failed` message. If the connection with
    our target is not possible, it will throw a `socket.error` exception with the `Connection
    error: [Errno 10061] No connection could be made because the target machine actively
    refused it` message.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we reviewed the `socket` module for implementing client-server
    architectures in Python with the TCP and UDP protocols.We also reviewed the main
    functions and methods for resolving IP address from domains and vice versa. Finally,
    we implemented practical use cases, such as port scanning with sockets and how
    to manage exceptions when an error is produced.
  prefs: []
  type: TYPE_NORMAL
- en: In the next *[chapter](9e79dfe8-9de4-4aaf-9d24-42b67a7da39c.xhtml)*, we will
    explore http requests packages for working with Python, the REST API, and authentication
    in servers.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What method of the `sockets` module allows a domain name to be resolved from
    an IP address?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What method of the `socket` module allows a server socket to accept requests
    from a client socket from another host?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What method of the `socket` module allows you to send data to a given address?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What method of the `socket` module allows you to associate a host and a port
    with a specific socket?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the the difference between the TCP and UDP protocol and how do you implement
    them in Python with the `socket` module?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What method of the `socket` module allows you to convert a hostname to the IPv4
    address format?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What method of the `socket` module allows you to implement port-scanning with
    sockets and check the port state?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What exception of the `socket` module allows you catch exceptions related to
    the expiration of waiting times?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What exception of the `socket` module allows you catch errors during the search
    for information about IP addresses?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What exception of the socket `module` allows you catch generic input and output
    errors and communications?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In these links, you will find more information about the mentioned tools and
    the official Python documentation for some of the commented modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://wiki.python.org/moin/HowTo/Sockets](https://wiki.python.org/moin/HowTo/Sockets)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.python.org/2/library/socket.html](https://docs.python.org/2/library/socket.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.python.org/3/library/socket.html](https://docs.python.org/3/library/socket.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.geeksforgeeks.org/socket-programming-python/](https://www.geeksforgeeks.org/socket-programming-python/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://realpython.com/python-sockets/](https://realpython.com/python-sockets/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What's New in Sockets for Python 3.7: [https://www.agnosticdev.com/blog-entry/python/whats-new-sockets-python-37](https://www.agnosticdev.com/blog-entry/python/whats-new-sockets-python-37)
  prefs: []
  type: TYPE_NORMAL
