- en: Chapter 9. Conquer Forms with HTML5 and CSS3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before HTML5, adding things such as date pickers, placeholder text, and range
    sliders into forms has always needed JavaScript. Similarly, there has been no
    easy way to tell users what we expect them to input into certain input fields,
    for example, whether we want users to input telephone numbers, e-mail addresses,
    or URLs. The good news is that HTML5 largely solves these common problems.
  prefs: []
  type: TYPE_NORMAL
- en: We have two main aims in this chapter. Firstly, to understand HTML5 form features
    and secondly, to understand how we can lay out forms more simply for multiple
    devices with the latest CSS features.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn how to:'
  prefs: []
  type: TYPE_NORMAL
- en: Easily add placeholder text into relevant form input fields
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disable auto-completion of form fields where necessary
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set certain fields to be required before submission
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specify different input types such as e-mail, telephone number, and URL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create number range sliders for easy value selection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Place date and color pickers into a form
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn how we can use a regular expression to define an allowed form value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to style forms using Flexbox
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTML5 forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I think the easiest way to get to grips with HTML5 forms is to work our way
    through an example form. From the finest of daytime TV examples, I have one I
    made earlier. A minor introduction is needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Two facts: firstly, I love films. Secondly, I''m very opinionated on what is
    a good film and what is not.'
  prefs: []
  type: TYPE_NORMAL
- en: Every year, when the Oscar nominations are announced, I can't help feeling the
    wrong films have got 'the nod' from the Academy. Therefore, we will start with
    an HTML5 form that enables fellow cinephiles to vent their frustrations at the
    continual travesties of the Oscar nominations.
  prefs: []
  type: TYPE_NORMAL
- en: It's made up of a few `fieldset` elements, within which we are including a raft
    of the HTML5 form input types and attributes. Besides standard form input fields
    and text areas, we have a number spinner, a range slider, and placeholder text
    for many of the fields.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how it looks with no styles applied in Chrome:'
  prefs: []
  type: TYPE_NORMAL
- en: '![HTML5 forms](img/B03777_09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If we ''focus'' on the first field and start inputting text, the placeholder
    text is removed. If we blur focus without entering anything (by clicking outside
    of the input box again) the placeholder text re-appears. If we submit the form
    (without entering anything), the following happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '![HTML5 forms](img/B03777_09_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The great news is that all these user interface elements, including the aforementioned
    slider, placeholder text, and spinner, and the input validation, are all being
    handled natively by the browser via HTML5, and no JavaScript. Now, the form validation
    isn't entirely cross browser compatible, but we will get to that shortly. First
    of all, let's get a handle on all the new capabilities of HTML5 that relate to
    forms and make all this possible. Once we understand all the mechanics, we can
    get to work styling it up.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the component parts of HTML5 forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There''s a lot going on in our HTML5 powered form, so let''s break it down.
    The three sections of the form are each wrapped in a `fieldset` with a legend:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You can see from the previous code snippet that each input element of the form
    is also wrapped in a `div` with a label associated with each input (we could have
    wrapped the input with the label element if we wanted to too). So far, so normal.
    However, within this first input we've just stumbled upon our first HTML5 form
    feature. After common attributes of ID, name, and type, we have `placeholder`.
  prefs: []
  type: TYPE_NORMAL
- en: placeholder
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `placeholder` attribute looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Placeholder text within form fields is such a common requirement that the folks
    creating HTML5 decided it should be a standard feature of HTML. Simply include
    the `placeholder` attribute within your input and the value will be displayed
    by default until the field gains focus. When it loses focus, if a value has not
    been entered it will re-display the placeholder text.
  prefs: []
  type: TYPE_NORMAL
- en: Styling the placeholder text
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can style the `placeholder` attribute with the `:placeholder-shown` pseudo
    selector. Be aware that this selector has been through a number of iterations
    so ensure you have the prefixer tool set up to provide the fallback selectors
    for already implemented versions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: After the `placeholder` attribute, in the previous code snippet, the next HTML5
    form feature is the `required` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: required
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `required` attribute looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In supporting HTML5 capable browsers, by adding the Boolean (meaning you simply
    include the attribute or not) attribute `required` within the `input` element,
    it indicates that a value is required. If the form is submitted without the field
    containing the requisite information, a warning message should be displayed. The
    message displayed is specific (both in content and styling) to both the browser
    and the input type used.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve already seen what the `required` field browser message looks like in
    Chrome. The following screenshot shows the same message in Firefox:'
  prefs: []
  type: TYPE_NORMAL
- en: '![required](img/B03777_09_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `required` value can be used alongside many input types to ensure a value
    is entered. Notable exceptions are the `range`, `color`, `button`, and `hidden`
    input types as they almost always have a default value.
  prefs: []
  type: TYPE_NORMAL
- en: autofocus
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The HTML5 `autofocus` attribute allows a form to have a field already focused,
    ready for user input. The following code is an example of an `input` field wrapped
    in a `div` with the `autofocus` attribute added at the end:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Be careful when using this attribute. Cross browser confusion can reign if multiple
    fields have the `autofocus` attribute added. For example, if multiple fields have
    `autofocus` added, in Safari, the last field with the `autofocus` attributed is
    focused on page load. However, Firefox and Chrome do the opposite with the first
    `autofocus` field selected.
  prefs: []
  type: TYPE_NORMAL
- en: It's also worth considering that some users use the spacebar to quickly skip
    down the content of a web page once it's loaded. On a page where a form has an
    autofocused input field, it prevents this capability; instead it adds a space
    into the focused input field. It's easy to see how that could be a source of frustration
    for users.
  prefs: []
  type: TYPE_NORMAL
- en: If using the `autofocus` attribute, be certain it's only used once in a form
    and be sure you understand the implications for those who scroll with the spacebar.
  prefs: []
  type: TYPE_NORMAL
- en: autocomplete
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By default, most browsers aid user input by auto-completing the value of form
    fields where possible. While the user can turn this preference on and off within
    the browser, we can now also indicate to the browser when we don''t want a form
    or field to allow auto-completion. This is useful not just for sensitive data
    (bank account numbers for example) but also if you want to ensure users pay attention
    and enter something by hand. For example, for many forms I complete, if a telephone
    number is required, I enter a ''spoof'' telephone number. I know I''m not the
    only one that does that (doesn''t everyone?) but I can ensure that users don''t
    enter an autocompleted spoof number by setting the `autocomplete` attribute to
    off on the relevant input field. The following is a code example of a field with
    the `autocomplete` attribute set to `off`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also set entire forms (but not fieldsets) to not autocomplete by using
    the attribute on the form itself. The following is a code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: List and the associated datalist element
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This `list` attribute and the associated `datalist` element allow a number
    of selections to be presented to a user once they start entering a value in the
    field. The following is a code example of the `list` attribute in use with an
    associated `datalist`, all wrapped in a `div`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The value given in the `list` attribute (`awards`) refers to the ID of the `datalist`.
    Doing this associates the `datalist` with the input field. Although wrapping the
    options with a `<select>` element isn't strictly necessary, it helps when applying
    polyfills for browsers that haven't implemented the feature.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Amazingly, in mid-2015, the `datalist` element still isn't supported natively
    in iOS, Safari, or Android 4.4 and below ([http://caniuse.com/](http://caniuse.com/))
  prefs: []
  type: TYPE_NORMAL
- en: You can read the specification for `datalist` at [http://www.w3.org/TR/html5/forms.html](http://www.w3.org/TR/html5/forms.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'While the `input` field seems to be just a normal text input field, when typing
    in the field, a selection box appears below it (in supporting browsers) with matching
    results from the `datalist`. In the following screenshot, we can see the list
    in action (Firefox). In this instance, as `B` is present in all options within
    the `datalist`, all the values are shown for the user to select from:'
  prefs: []
  type: TYPE_NORMAL
- en: '![List and the associated datalist element](img/B03777_09_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'However, when typing `D` instead, only the matching suggestions appear as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![List and the associated datalist element](img/B03777_09_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `list` and `datalist` don't prevent a user entering different text in the
    input box but they do provide another great way of adding common functionality
    and user enhancement through HTML5 markup alone.
  prefs: []
  type: TYPE_NORMAL
- en: HTML5 input types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: HTML5 adds a number of extra input types, which amongst other things, enable
    us to limit the data that users input without the need for extraneous JavaScript
    code. The most comforting thing about these new input types is that by default,
    where browsers don't support the feature, they degrade to a standard text input
    box. Furthermore, there are great polyfills available to bring older browsers
    up to speed, which we will look at shortly. In the meantime, let's look at these
    new HTML5 input types and the benefits they provide.
  prefs: []
  type: TYPE_NORMAL
- en: email
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can set an input to the `email` type like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Supporting browsers will expect a user input that matches the syntax of an
    e-mail address. In the following code example `type="email"` is used alongside
    `required` and `placeholder`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'When used in conjunction with required, submitting a non-conforming input will
    generate a warning message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![email](img/B03777_09_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Furthermore, many touch screen devices (for example, Android, iPhone, and so
    on) change the input display based upon this input type. The following screenshot
    shows how an input `type="email"` screen looks on the iPad. Notice the `@` symbol
    for been added to the software keyboard for easy email address completion:'
  prefs: []
  type: TYPE_NORMAL
- en: '![email](img/B03777_09_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: number
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can set an input field to a type of number like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'A supporting browser expects a number to be entered here. Supporting browsers
    also provide what''s called **spinner controls**. These are tiny pieces of user
    interface that allow users to easily click up or down to alter the value input.
    The following is a code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'And the following screenshot shows how it looks in a supporting browser (Chrome):'
  prefs: []
  type: TYPE_NORMAL
- en: '![number](img/B03777_09_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Implementation of what happens if you don't enter a number varies. For example,
    Chrome and Firefox do nothing until the form is submitted, at which point they
    pop up a warning above the field. Safari on the other hand, simply does nothing,
    and merely lets the form be submitted. Internet Explorer 11 simply empties the
    field as soon as focus leaves it.
  prefs: []
  type: TYPE_NORMAL
- en: min and max ranges
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You''ll notice in the previous code example, we have also set a minimum and
    maximum allowed range, similar to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Numbers outside of this range (should) get special treatment.
  prefs: []
  type: TYPE_NORMAL
- en: You probably won't be surprised to learn that browser implementation of `min`
    and `max` ranges is varied. For example, Internet Explorer 11, Chrome, and Firefox,
    display a warning while Safari does nothing.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the step increments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can alter the step increments (granularity) for the spinner controls of
    various input types with the use of the `step` attribute. For example, to step
    10 units at a time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: url
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can set an input field to expect a URL like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'As you might expect, the `url` input type is for URL values. Similar to the
    `tel` and `email` input types; it behaves almost identically to a standard text
    input. However, some browsers add specific information to the warning message
    provided when submitted with incorrect values. The following is a code example
    including the `placeholder` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows what happens when an incorrectly entered URL
    field is submitted in Chrome:'
  prefs: []
  type: TYPE_NORMAL
- en: '![url](img/B03777_09_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Like `type="email"`, touch screen devices often amend the input display based
    upon this input type. The following screenshot shows how an input `type="url"`
    screen looks on the iPad:'
  prefs: []
  type: TYPE_NORMAL
- en: '![url](img/B03777_09_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Notice the *.com* key? Because we've used a URL input type they are presented
    by the device for easy URL completion (on iOS, if you're not going to a .com site
    you can press and hold for a few other popular top level domains).
  prefs: []
  type: TYPE_NORMAL
- en: tel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Set an input field to expect a telephone number like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s a more complete example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Although, a number format is expected on many browsers, even modern evergreen
    ones such as Internet Explorer 11, Chrome, and Firefox, it merely behaves like
    a text input field. When an incorrect value is input, they fail to provide a suitable
    warning message when the field loses focus or on form submission.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, better news is that, like the `email` and `url` input types, touch
    screen devices often thoughtfully accommodate this kind of input with an amended
    input display for easy completion; here''s the `tel` input when accessed with
    an iPad (running iOS 8.2):'
  prefs: []
  type: TYPE_NORMAL
- en: '![tel](img/B03777_09_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Notice the lack of alphabet characters in the keyboard area? This makes it much
    faster for users to enter a value in the correct format.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Quick tip**'
  prefs: []
  type: TYPE_NORMAL
- en: 'If the default blue color of telephone numbers in iOS Safari annoys you when
    you use a `tel` input, you can amend it with the following selector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: search
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can set an input as a search type like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The `search` input type works like a standard text input. Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'However, software keyboards (such as those found on mobile devices) often provided
    a more tailored keyboard. Here''s the iOS 8.2 keyboard that appears when a `search`
    input type gets focus:'
  prefs: []
  type: TYPE_NORMAL
- en: '![search](img/B03777_09_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can set an input to expect a certain pattern input like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `pattern` attribute allows you to specify, via a regular expression, the
    syntax of data that should be allowed in a given input field.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Learn about regular expressions**'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you''ve never encountered regular expressions before, I''d suggest starting
    here: [http://en.wikipedia.org/wiki/Regular_expressions](http://en.wikipedia.org/wiki/Regular_expressions)'
  prefs: []
  type: TYPE_NORMAL
- en: Regular expressions are used across many programming languages as a means of
    matching possible strings. While the format is intimidating at first, they are
    incredibly powerful and flexible. For example, you could build a regular expression
    to match a password format, or select a certain style CSS class naming pattern.
    To help build up your own regex pattern and get a visual understanding of how
    they work, I'd recommend starting with a browser based tool like [http://www.regexr.com/](http://www.regexr.com/).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Such is my commitment to this book, I searched the Internet for approximately
    458 seconds to find a regular expression that would match a first and last name
    syntax. By entering the regular expression value within the `pattern` attribute,
    it makes supporting browsers expect a matching input syntax. Then, when used in
    conjunction with the `required` attribute, incorrect entries get the following
    treatment in supporting browsers. In this instance, I tried submitting the form
    without providing a last name.
  prefs: []
  type: TYPE_NORMAL
- en: Again, browsers do things differently. Internet Explorer 11 requests that the
    field is entered correctly, Safari, Firefox, and Chrome do nothing (they just
    behave like a standard text input).
  prefs: []
  type: TYPE_NORMAL
- en: color
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Want to set an input field to receive a hexadecimal color value? You can do
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The `color` input type invokes a color picker in supporting browsers (currently
    just Chrome and Firefox), allowing users to select a color value in a hexadecimal
    value. The following code is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Date and time inputs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The thinking behind the new `date` and `time` input types is to provide a consistent
    user experience for choosing dates and times. If you've ever bought tickets to
    an event online, chances are that you have used a date picker of one sort or another.
    This functionality is almost always provided via JavaScript (typically jQuery
    UI library) but the hope is to make this common necessity possible merely with
    HTML5 markup.
  prefs: []
  type: TYPE_NORMAL
- en: date
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following code is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Similar to the `color` input type, native browser support is thin on the ground,
    defaulting on most browsers to a standard text input box. Chrome and Opera are
    the only two of the modern browsers to have implemented this functionality. That's
    not surprising as they both use the same engine (known as **Blink** in case you
    were interested).
  prefs: []
  type: TYPE_NORMAL
- en: '![date](img/B03777_09_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There are a variety of different `date` and `time` related input types available.
    What follows is a brief overview of the others.
  prefs: []
  type: TYPE_NORMAL
- en: month
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following code is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The interface allows the user to select a single month and provides the input
    as a year and month for example 2012-06\. The following screenshot shows how it
    looks in the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![month](img/B03777_09_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: week
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following code is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: When the `week` input type is used, the picker allows the user to select a single
    week within a year and provides the input in the 2012-W47 format.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows how it looks in the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![week](img/B03777_09_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: time
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following code is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The `time` input type allows a value in the 24-hour format, for example 23:50.
  prefs: []
  type: TYPE_NORMAL
- en: It displays in supporting browsers with spinner controls but only allows relevant
    time values.
  prefs: []
  type: TYPE_NORMAL
- en: range
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `range` input type creates a slider interface element. Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'And the following screenshot shows how it looks in Firefox:'
  prefs: []
  type: TYPE_NORMAL
- en: '![range](img/B03777_09_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The default range is from 0 to 100\. However, by specifying a `min` and `max`
    value in our example we have limited it to between 1 and 10.
  prefs: []
  type: TYPE_NORMAL
- en: 'One big problem I''ve encountered with the `range` input type is that the current
    value is never displayed to the user. Although the range slider is only intended
    for vague number selections, I''ve often wanted to display the value as it changes.
    Currently, there is no way to do this using HTML5\. However, if you absolutely
    must display the current value of the slider, it can be achieved easily with some
    simple JavaScript. Amend the previous example to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve added two things, an `onchange` attribute and also a `span` element
    with the ID of range. Now, we''ll add the following tiny piece of JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: All this does is get the current value of the range slider and display it in
    the element with an ID of range (our `span` tag). You can then use whatever CSS
    you deem appropriate to change the appearance of the value.
  prefs: []
  type: TYPE_NORMAL
- en: There are a few other form related features that are new in HTML5\. You can
    read the full specification at [http://www.w3.org/TR/html5/forms.html](http://www.w3.org/TR/html5/forms.html).
  prefs: []
  type: TYPE_NORMAL
- en: How to polyfill non-supporting browsers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All this HTML5 form malarkey is all well and good. There seems however, to
    be two things that put a serious dent in our ability to use them: disparity between
    how supporting browsers implement the features, and how to deal with browsers
    that don''t support the features at all.'
  prefs: []
  type: TYPE_NORMAL
- en: If you need to support some of these features in older or non-supporting browsers
    then consider Webshims Lib, which you can download at [http://afarkas.github.com/webshim/demos/](http://afarkas.github.com/webshim/demos/).
    It is a polyfill library written by Alexander Farkas that can load form polyfills
    to make non-supporting browsers handle HTML5 based form features.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Exercise caution with polyfills**'
  prefs: []
  type: TYPE_NORMAL
- en: Whenever you reach for a polyfill script remember to consider carefully. While
    they can be very handy, they add weight to your project. For example, Webshims
    also requires jQuery so there's yet another dependency needed if you weren't using
    jQuery before. Unless polyfilling older browsers is essential, I steer clear.
  prefs: []
  type: TYPE_NORMAL
- en: The handy thing about Webshims is that it only adds polyfills as needed. If
    being viewed by a browser that supports these HTML5 features natively it adds
    very little. Older browsers, although they need to load more code (as they are
    less capable by default), get a similar user experience, albeit with the relevant
    functionality created with the help of JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'But it isn''t just older browsers that benefit. As we''ve seen, many modern
    browsers haven''t implemented the HTML5 form features fully. Employing Webshims
    lib to the page also fills any gaps in their capability. For example, Safari doesn''t
    offer any warning when a HTML5 form is submitted with required fields empty. No
    feedback is given to the user as to what the problem is: hardly ideal. With Webshims
    lib added to the page, the following happens in the aforementioned scenario.'
  prefs: []
  type: TYPE_NORMAL
- en: So when Firefox isn't able to provide a spinner for a `type="number"` attribute,
    Webshims lib provides a suitable, jQuery powered, fallback. In short, it's a great
    tool, so let's get this beautiful little package installed and hooked up and then
    we can carry on writing forms with HTML5, safe in the knowledge that all users
    will see what they need to use our form (except those two people using IE6 with
    JavaScript turned off—you know who you are—now pack it in!).
  prefs: []
  type: TYPE_NORMAL
- en: First download Webshims lib ([http://github.com/aFarkas/webshim/downloads](http://github.com/aFarkas/webshim/downloads))
    and extract the package. Now copy the `js-webshim` folder to a relevant section
    of your web page. For simplicity, for this example I've copied it into the website
    root.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now add the following code into the section of your page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s go through this a section at a time. Firstly, we link to a local copy
    of the jQuery library (get the latest version at [www.jquery.com](http://www.jquery.com))
    and the Webshim script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, I''m telling the script to load all needed polyfills:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: And that's all there is to it. Now, missing functionality is automatically added
    by the relevant polyfill. Excellent!
  prefs: []
  type: TYPE_NORMAL
- en: Styling HTML5 forms with CSS3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our form is now fully functional across browsers so now we need to make it a
    little more appealing across different viewport sizes. Now, I don't consider myself
    a designer, but by applying some of the techniques we've learned throughout the
    previous chapters, I still think we can improve the aesthetics of our form.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can view the styled form at `example_09-02`, and remember, if you don't
    already have the example code, you can grab it at [http://rwd.education](http://rwd.education).
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, I''ve also included two versions of the style sheet: `styles.css`
    is the version that includes vendor prefixes (added via Autoprefixer) and `styles-unprefixed.css`
    is the CSS as written. The latter is probably easier to look at if you want to
    see how anything is being applied.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how the form looks in a small viewport with some basic styling applied:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Styling HTML5 forms with CSS3](img/B03777_09_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And here it is at a larger viewport:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Styling HTML5 forms with CSS3](img/B03777_09_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you look at the CSS you'll see many of the techniques we've looked at throughout
    previous chapters applied. For example, Flexbox ([Chapter 3](ch03.html "Chapter 3. Fluid
    Layouts and Responsive Images"), *Fluid Layouts and Responsive Images*) has been
    used to create uniform spacing and flexibility for elements; transforms and transitions
    ([Chapter 8](ch08.html "Chapter 8. Transitions, Transformations, and Animations"),
    *Transitions, Transformations, and Animations*) so that the focused input fields
    grow and the ready/submit button flips vertically when it gains focus. Box-shadows
    and gradients ([Chapter 6](ch06.html "Chapter 6. Stunning Aesthetics with CSS3"),
    *Stunning Aesthetics with CSS3*) are used to emphasize different areas of the
    form. Media queries ([Chapter 2](ch02.html "Chapter 2. Media Queries – Supporting
    Differing Viewports"), *Media Queries – Supporting Differing Viewports*) are being
    used to switch the Flexbox direction for different viewport sizes and CSS Level
    3 selectors ([Chapter 5](ch05.html "Chapter 5. CSS3 – Selectors, Typography, Color
    Modes, and New Features"), *CSS3 – Selectors, Typography, Color Modes, and New
    Features*) are being used for selector negation.
  prefs: []
  type: TYPE_NORMAL
- en: We won't go over those techniques in detail here again. Instead, we will focus
    on a couple of peculiarities. Firstly, how to visually indicate required fields
    (and for bonus points indicate a value has been entered) and secondly, how to
    create a 'fill' effect when a field gets user focus.
  prefs: []
  type: TYPE_NORMAL
- en: Indicating required fields
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can indicate required input fields to a user using CSS alone. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'With that selector we could add a border or outline to the required fields
    or add a `background-image` inside the field. Basically the sky''s the limit!
    We could also use a specific selector to target an input field that is required,
    only when it gains focus. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: However, that would apply styles to the input box itself. What if we want to
    amend styles on the associated `label` element? I've decided I'd like to indicate
    required fields with a little asterisk symbol to the side of the label. But this
    presents a problem. Generally, CSS only lets us affect a change on elements if
    they are children of an element, the element itself, or a general or adjacent
    sibling of an element that receives 'state' (when I say state I'm talking about
    `hover`, `focus`, `active`, `checked`, and so on). In the following examples I'm
    using `:hover` but that would obviously be problematic for touch based devices.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: With the preceding selector, styles are applied to `item-child` when item is
    hovered over.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: With this selector, when the item is hovered over, styles are applied to `item-general-sibling`
    if it is at the same DOM level as item and follows it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Here, when the item is hovered over, styles are applied to `item-adjacent-sibling`
    if it is the adjacent sibling element of item (straight after it in the DOM).
  prefs: []
  type: TYPE_NORMAL
- en: 'So, back to our issue. If we have a form with labels and fields like this,
    with the label above the input (to give us the requisite basic layout), it leaves
    us a little stuck:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: In this situation, using just CSS, there is no way to change the style of the
    label based upon whether the input is required or not (as it comes after the label
    in the markup). We could switch the order of those two elements in the markup
    but then we would end up with the label underneath the input.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, Flexbox gives us the ability to visually reverse the order of elements
    (read all about that in [Chapter 3](ch03.html "Chapter 3. Fluid Layouts and Responsive
    Images"), *Fluid Layouts and Responsive Images*, if you haven''t already) with
    ease. That allows us to use this markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'And then simply apply `flex-direction: row-reverse` or `flex-direction: column-reverse`
    to the parent. These declarations reverse the visual order of their child elements,
    allowing the desired aesthetic of the label above (smaller viewports), or to the
    left (larger viewports) of the input. Now we can get on with actually providing
    some indication of required fields and when they have received input.'
  prefs: []
  type: TYPE_NORMAL
- en: Thanks to our revised markup, the adjacent sibling selector now makes this possible.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'This selector essentially says, for every label that follows an input with
    a `required` attribute, apply the enclosed rules. Here is the CSS for that section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Then, if you focus on a required input and enter a relevant value, the asterisk
    changes color to green. It's a subtle but helpful touch.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are more selectors (both implemented and being specified) alongside all
    the ones we have already looked at. For the most up to date list, take a look
    at the latest editors draft of the Selectors Level 4 specification: [http://dev.w3.org/csswg/selectors-4/](http://dev.w3.org/csswg/selectors-4/)'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a background fill effect
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Back in [Chapter 6](ch06.html "Chapter 6. Stunning Aesthetics with CSS3"), *Stunning
    Aesthetics with CSS3*, we learned how to generate linear and radial gradients
    as background-images. Sadly, it isn't possible to transition between two background-images
    (which makes sense as the browser effectively rasterizes the declaration into
    an image). However, we can transition between values of associated properties
    like `background-position` and `background-size`. We'll use this factor to create
    a fill effect when an `input` or `textarea` receives focus.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the properties and values added to the input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: In the first rule, a solid white radial gradient is being generated but positioned
    offset out of view. The background color that sits behind (the HEX value after
    the `radial-gradient`) is not offset and so provides a default color. When the
    input gains focus, the background position on the `radial-gradient` is set back
    to the default and because we have a transition on the background-image set, we
    get a nice transition between the two. The result being the appearance that the
    input is 'filled' with a different color when it gains focus.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Different browsers each have their own proprietary selectors and capabilities
    when it comes to styling parts of the native UI. For a handy list of lots of the
    specific selectors, Aurelius Wendelken compiled an impressive list. I made my
    own copy of it (or 'fork' in Git version control speak) for prosperity, which
    you can find at [https://gist.github.com/benfrain/403d3d3a8e2b6198e395](https://gist.github.com/benfrain/403d3d3a8e2b6198e395)
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned how to use a host of new HTML5 form attributes.
    They enable us to make forms more usable than ever before and the data they capture
    more relevant. Furthermore, we can future-proof this new markup when needed with
    JavaScript polyfill scripts so that all users experience similar form features,
    regardless of the capability of their browser.
  prefs: []
  type: TYPE_NORMAL
- en: We're nearing the end of our responsive HTML5 and CSS3 journey. While we have
    covered an enormous amount in our time together, I'm conscious I'll never manage
    to impart all the information for every eventuality you'll encounter. Therefore,
    in the last chapter I'd like to take a higher level look at approaching a responsive
    web design and try and relate some solid best practices for getting your next/first
    responsive project off on the right footing.
  prefs: []
  type: TYPE_NORMAL
