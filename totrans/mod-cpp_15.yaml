- en: Streams and Filesystems
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problems
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here are the problem-solving sections for this chapter.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 32\. Pascal's triangle
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Write a function that prints up to 10 rows of Pascal's triangle to the console.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: 33\. Tabular printing of a list of processes
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Suppose you have a snapshot of the list of all processes in a system. The information
    for each process includes name, identifier, status (which can be either *running*
    or *suspended*), account name (under which the process runs), memory size in bytes,
    and platform (which can be either 32-bit or 64-bit). Your task is to write a function
    that takes such a list of processes and prints them to the console alphabetically,
    in tabular format. All columns must be left-aligned, except for the memory column
    which must be right-aligned. The value of the memory size must be displayed in
    KB. The following is an example of the output of this function:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 34\. Removing empty lines from a text file
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Write a program that, given the path to a text file, modifies the file by removing
    all empty lines. Lines containing only whitespaces are considered empty.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: 35\. Computing the size of a directory
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Write a function that computes the size of a directory, in bytes, recursively.
    It should be possible to indicate whether symbolic links should be followed or
    not.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: 36\. Deleting files older than a given date
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Write a function that, given the path to a directory and a duration, deletes
    all the entries (files or subdirectories) older than the specified duration, in
    a recursive manner. The duration can represent anything, such as days, hours,
    minutes, seconds, and so on, or a combination of that, such as one hour and twenty
    minutes. If the specified directory is itself older than the given duration, it
    should be deleted entirely.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: 37\. Finding files in a directory that match a regular expression
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Write a function that, given the path to a directory and a regular expression,
    returns a list of all the directory entries whose names match the regular expression.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: 38\. Temporary log files
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create a logging class that writes text messages to a discardable text file.
    The text file should have a unique name and must be located in a temporary directory.
    Unless specified otherwise, this log file should be deleted when the instance
    of the class is destroyed. However, it should be possible to retain the log file
    by moving it to a permanent location.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Solutions
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here are the solutions for the above problem-solving sections.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: 32\. Pascal's triangle
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Pascal''s triangle is a construction representing binomial coefficients. The
    triangle starts with a row that has a single value of 1\. Elements of each row
    are constructed by summing the numbers above, to the left and right, and treating
    blank entries as 0\. Here is an example of the triangle with five rows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To print the triangle, we must:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Shift the output position to the right with an appropriate number of spaces,
    so that the top is projected on the middle of the triangle's base.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compute each value by summing the above left and right values. A simpler formula
    is that for a row `i` and column `j`, each new value `x` is equal to the previous
    value of `x` multiplied by `(i - j) / (j + 1)`, where `x` starts at 1.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is a possible implementation of a function that prints the triangle:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following program asks the user to enter the number of levels and prints
    the triangle to the console:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 33\. Tabular printing of a list of processes
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To solve this problem, we will consider the following class representing information
    about a process:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In order to print the status and platform as text and not as numerical values,
    we need conversion functions from the enumerations to `std::string`:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The processes are required to be sorted alphabetically by process name. Therefore,
    the first step would be to sort the input range of processes. For the printing
    itself, we should use the I/O manipulators:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The following program defines a list of processes (you can actually retrieve
    the list of running processes using operating system-specific APIs) and prints
    it to the console in the requested format:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 34\. Removing empty lines from a text file
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A possible approach to solving this task is to do the following:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: Create a temporary file to contain only the text you want to retain from the
    original file
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Read line by line from the input file and copy to the temporary file all lines
    that are not empty
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete the original file after finishing processing it
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Move the temporary file to the path of the original file
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'An alternative is to move the temporary file and overwrite the original one.
    The following implementation follows the steps listed. The temporary file is created
    in the temporary directory returned by `filesystem::temp_directory_path()`:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 35\. Computing the size of a directory
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To compute the size of a directory, we have to iterate through all the files
    and sum the size of individual files.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '`filesystem::recursive_directory_iterator` is an iterator from the `filesystem`
    library that allows iterating all the entries of a directory in a recursive manner.
    It has various constructors, some of them taking a value of the type `filesystem::directory_options` that
    indicates whether symbolic links should be followed or not. The general purpose
    `std::accumulate()` algorithm can be used to sum together the file sizes. Since
    the total size of a directory could exceed 2 GB, you should not use `int` or `long`,
    but `unsigned long long` for the sum type. The following function shows a possible
    implementation for the required task:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 36\. Deleting files older than a given date
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To perform filesystem operations, you should be using the `filesystem` library.
    For working with time and duration, you should be using the `chrono` library.
    A function that implements the requested functionality has to do the following:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Check whether the entry indicated by the target path exists and is older than
    the given duration, and if so, delete it
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If it is not older and it''s a directory, iterate through all its entries and
    call the function recursively:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: An alternative to using `directory_iterator` and recursively calling `remove_files_older_than()`
    would be to use `recursive_directory_iterator` and simply delete the entry if
    older than the given duration. However, this approach would employ undefined behavior,
    because if a file or a directory is deleted or added to the directory tree after
    the recursive directory iterator has been created, it is not specified whether
    the change would be observed through the iterator. Therefore, this method should
    be avoided.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: The `is_older_than()` function template determines the time that has passed
    since the system's clock epoch for the current moment and the last file writing
    operation and checks whether the difference of the two is greater than the specified
    duration.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: 'The `remove_files_older_than()` function can be used as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 37\. Finding files in a directory that match a regular expression
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Implementing the specified functionality should be straightforward: iterate
    recursively through all the entries of the specified directory and retain all
    the entries that are regular files and whose name matches the regular expression.
    To do that, you should use the following:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '`filesystem::recursive_directory_iterator` to iterate through directory entries'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`regex` and `regex_match()` to check whether the filename matches the regular
    expression'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`copy_if()` and `back_inserter` to copy, at the end of a `vector`, the directory
    entries that match a specific criteria.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Such a function may look like this:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'With this available, we can write the following code:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 38\. Temporary log files
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The logging class that you have to implement for this task should:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: Have a constructor that creates a text file in a temporary directory and opens
    it for writing
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: During destruction, if the file still exists, close and delete it
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Have a method that closes the file and moves it to a permanent path
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一个关闭文件并将其移动到永久路径的方法
- en: Overloads `operator<<` to write a text message to the output file
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重载`operator<<`以将文本消息写入输出文件
- en: 'In order to create unique names for the file, you could use a UUID (also known
    as GUID). The C++ standard does not support any functionality related to that,
    but there are third-party libraries, such as `boost::uuid`, *CrossGuid*, or `stduuid`,
    which is actually a library that I created. For this implementation, I will use
    the last one. You can find it at [https://github.com/mariusbancila/stduuid](https://github.com/mariusbancila/stduuid):'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了为文件创建唯一的名称，可以使用 UUID（也称为 GUID）。C++标准不支持与此相关的任何功能，但有第三方库，如`boost::uuid`、*CrossGuid*或`stduuid`，实际上是我创建的一个库。对于这个实现，我将使用最后一个。你可以在[https://github.com/mariusbancila/stduuid](https://github.com/mariusbancila/stduuid)找到它。
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'An example of using this class is as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个类的一个例子如下：
- en: '[PRE15]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
