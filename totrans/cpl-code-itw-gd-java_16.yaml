- en: '*Chapter 13*:'
  prefs: []
  type: TYPE_NORMAL
- en: Trees and Graphs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter covers one of the trickiest topics asked in interviews: trees
    and graphs. While there are tons of problems related to these two topics, only
    a handful of them are actually encountered in interviews. Therefore, it is very
    important to prioritize the most popular problems with trees and graphs.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we'll start with a brief overview of trees and graphs. Later,
    we'll tackle the most popular and challenging problems encountered in interviews
    at IT giants such as Amazon, Microsoft, Adobe, and other companies. By the end
    of this chapter, you'll know how to answer interview questions and solve coding
    challenges regarding trees and graphs in an efficient and comprehensive way.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Trees in a nutshell
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Graphs in a nutshell
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coding challenges
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the code present in this chapter can be found on GitHub at [https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/tree/master/Chapter13](https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/tree/master/Chapter13).
  prefs: []
  type: TYPE_NORMAL
- en: Trees in a nutshell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A tree is a non-linear data structure that organizes data hierarchically in
    nodes and cannot contain cycles. A tree has a specific terminology that may vary
    slightly, but commonly, the following notions are adopted:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Root** is the topmost node.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Edge** is the link or connection between two nodes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Parent** is a node that has an edge to a child node.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Child** is a node that has a parent node.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Leaf** is a node that does not have a child node.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Height** is the length of the longest path to a leaf.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Depth** is the length of the path to its root.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram exemplifies these terms when used on a tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.1 – Tree terminology'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.1_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.1 – Tree terminology
  prefs: []
  type: TYPE_NORMAL
- en: Typically, any tree can have a root. The nodes of the tree can respect a certain
    order (or not), can store any type of data, and may have links to their parents.
  prefs: []
  type: TYPE_NORMAL
- en: Tree coding challenges are rife with ambiguous details and/or incorrect assumptions.
    It is very important to clarify every single detail with the interviewer in order
    to eliminate ambiguity. One of the most important aspects refers to the type of
    tree. Let's take a look at the most common types of trees.
  prefs: []
  type: TYPE_NORMAL
- en: General tree
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Roughly speaking, we can categorize trees into binary trees and the rest of
    the allowed trees. A binary tree is a tree in which each node has up to two children.
    In the following diagram, the left-hand side image is of a non-binary tree, while
    the right-hand side image is of a binary tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.2 – Non-binary tree versus binary tree'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.2_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.2 – Non-binary tree versus binary tree
  prefs: []
  type: TYPE_NORMAL
- en: 'In terms of code, a binary tree can be shaped as follows (this implementation
    is used later in the *Coding challenges* section, so keep this in mind):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, each `Node` keeps references to two other `Node` elements, as
    well as a generic data (element). The left and right nodes represent the children
    of the current node. Most tree coding challenges that are encountered in interviews
    use binary trees, so they deserve special attention. Binary trees can be categorized
    as follows.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing binary tree traversal
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before attending a technical interview, you must know how to traverse a binary
    tree. Often, traversing a binary tree will not be a problem in itself, but you
    have to be comfortable with the **Breadth-first Search** (**BFS**) and the **Depth-first
    Search** (**DFS**) algorithms, along with their three variations: **Pre-Order**,
    **In-Order**, and **Post-Order**. The following diagram represents the result
    of each traversal type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.3 – Binary tree traversal'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.3_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.3 – Binary tree traversal
  prefs: []
  type: TYPE_NORMAL
- en: Let's have a brief overview of the BFS and DFS algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: Breadth-first Search (BFS) for trees
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'BFS for trees is also referred as Level-Order traversal. The main idea is to
    maintain a queue of nodes that will ensure the order of traversal. Initially,
    the queue contains only the root node. The steps of the algorithm are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Pop the first node from the queue as the current node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Visit the current node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the current node has a left node, then enqueue that left node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the current node has a right node, then enqueue that right node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat from *step 1* until the queue is empty.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In terms of code, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Next, let's focus on DFS.
  prefs: []
  type: TYPE_NORMAL
- en: Depth-first Search (DFS) for trees
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'DFS for trees has three variations: **Pre-Order**, **In-Order**, and **Post-Order**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pre-Order traversal visits the current node before its child nodes, as follows
    **(root | left sub-tree | right sub-tree)**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In-Order traversal visits the left branch, then the current node, and finally,
    the right branch, as follows **(left sub-tree | root | right sub-tree)**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Post-Order visits the current node after its child nodes, as follows **(left
    sub-tree | right sub-tree | root)**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The complete application is called *BinaryTreeTraversal*. Besides the preceding
    examples, the complete code also contains BFS and DFS implementations that return
    a `List` and an `Iterator`.
  prefs: []
  type: TYPE_NORMAL
- en: Binary Search Tree
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A **Binary Search Tree** (**BST**) is a binary tree that follows an ordering
    rule. Typically, in a BST, the left descendants (all the elements on the left-hand
    side of the root) are smaller than or equal to the root element and, the right
    descendants (all the elements on the right-hand side of the root) are bigger than
    the root element. However, this order doesn''t apply to just the root element.
    It applies to each node, *n*, so, in a BST, the *left descendants of n* ≤ *n*
    < *right* *descendants of n*. In the following diagram, the image on the left
    is of a binary tree, while the image on the right is of a BST:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.4 – Binary tree versus binary search tree'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.4_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.4 – Binary tree versus BST
  prefs: []
  type: TYPE_NORMAL
- en: Commonly, a BST doesn't accept duplicates, but when it does, they can be on
    one side (for example, only on the left-hand side) or on both sides. The duplicates
    can also be stored in a separated hash map, or directly in the structure of the
    tree via a counter. Pay attention and clarify these details with the interviewer.
    Handling duplicates in a BST is a problem encounter in interviews at Amazon, Flipkart,
    and Microsoft, which is why it will be tackled in the *Coding challenges* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the code bundled with this book, you can find an application called *BinarySearchTreeTraversal*
    that exposes the following set of methods: `insert(T element)`, `contains(T element)`,
    `delete(T element)`, `min()`, `max()`, `root()`, `size()`, and `height()`. Moreover,
    it contains an implementation of BFS and DFS for printing nodes and for returning
    nodes as a `List` or an `Iterator`. Take your time and dissect the code.'
  prefs: []
  type: TYPE_NORMAL
- en: Balanced and unbalanced binary trees
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When a binary tree guarantees O(log n) times for insert and find operations,
    we can say that we have a *balanced* binary tree, but one that''s not necessarily
    as balanced as it could be. When the difference between the heights of the left
    sub-tree and the right sub-tree for any node in the tree is no more than 1, then
    the tree is *height-balanced*. In the following diagram, the left-hand side tree
    is an unbalanced binary tree, the middle tree is a balanced binary tree but not
    height-balanced, and the right-hand side tree is a height-balanced tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.5 – Unbalanced binary tree versus balanced binary tree versus height
    balanced binary tree'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.5_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.5 – Unbalanced binary tree versus balanced binary tree versus height-balanced
    binary tree
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two types of balanced trees: Red-Black trees and AVL trees.'
  prefs: []
  type: TYPE_NORMAL
- en: Red-Black tree
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A Red-Black tree is a self-balancing BST where each node is under the incident
    of the following rules:'
  prefs: []
  type: TYPE_NORMAL
- en: Every node is either red or black
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The root node is always black
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every leaf (NULL) is black
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both children of a red node are black
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every path from a node to a NULL node has the same number of black nodes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram represents a Red-Black tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.6 – Red-Black tree example'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.6_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.6 – Red-Black tree example
  prefs: []
  type: TYPE_NORMAL
- en: A Red-Black tree never gets terribly unbalanced. If all the nodes are black,
    then the tree becomes a *perfectly balanced tree*. The Red-Black tree becomes
    its maximum height when the nodes in its longest path are alternate black and
    red nodes. The height of a Black-Red tree is always less than or equal to 2log2(n+1),
    so its height is always in the order of O(log n).
  prefs: []
  type: TYPE_NORMAL
- en: Because of their complexity and time to implement, the problems that involve
    Red-Black trees are not a common topic in interviews. However, when they occur,
    the problem may ask you to implement the insert, delete, or find operations. In
    the code bundled with this book, you can find a Red-Black tree implementation
    that shows these operations at work. Take your time studying the code and getting
    familiar with the Red-Black tree concept. The application is called *RedBlackTreeImpl*.
  prefs: []
  type: TYPE_NORMAL
- en: More implementations that you may want to check out can be found at [github.com/williamfiset/data-structures/blob/master/com/williamfiset/datastructures/balancedtree/RedBlackTree.java](http://github.com/williamfiset/data-structures/blob/master/com/williamfiset/datastructures/balancedtree/RedBlackTree.java)
    and [algs4.cs.princeton.edu/33balanced/RedBlackBST.java.html](http://algs4.cs.princeton.edu/33balanced/RedBlackBST.java.html).
    For a graphical visualization, please consider [www.cs.usfca.edu/~galles/visualization/RedBlack.html](http://www.cs.usfca.edu/~galles/visualization/RedBlack.html).
  prefs: []
  type: TYPE_NORMAL
- en: If you need to deep dive into this topic, I strongly recommend that you read
    a book dedicated to data structures since this is a quite vast topic.
  prefs: []
  type: TYPE_NORMAL
- en: AVL tree
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An **AVL** tree (named after their inventors, **A**delson-**V**elsky and **L**andis)
    is a self - balancing BST that respects the following rules:'
  prefs: []
  type: TYPE_NORMAL
- en: The height of a sub-tree can differ at most by 1.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The balance factor (*BN*) of a node (*n*) is -1, 0, or 1 and is defined as
    the height (*h*) difference: *BN=h*(*right_subtree*(*n*)) *- h*(*left_subtree*(*n*))or
    *BN=h*(*left_subtree*(*n*)) *- h*(*right_subtree(n*)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram represents an AVL tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.7 – AVL tree sample'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.7_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.7 – AVL tree example
  prefs: []
  type: TYPE_NORMAL
- en: An AVL tree allows all operations (insert, delete, find min, find max, and so
    on) to perform in O(log n), where *n* is the number of nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Because of their complexity and time to implement, the problems that involve
    AVL trees are not a common topic in interviews. However, when they occur, the
    problem may ask you to implement the insert, delete, or find operations. In the
    code bundled with this book, you can find an AVL tree implementation that shows
    these operations at work. Take your time studying the code and getting familiar
    with the AVL trees concept. The application is called *AVLTreeImpl*.
  prefs: []
  type: TYPE_NORMAL
- en: More implementations that you may want to check out can be found at [github.com/williamfiset/data-structures/blob/master/com/williamfiset/datastructures/balancedtree/AVLTreeRecursiveOptimized.java](http://github.com/williamfiset/data-structures/blob/master/com/williamfiset/datastructures/balancedtree/AVLTreeRecursiveOptimized.java)
    and [algs4.cs.princeton.edu/code/edu/princeton/cs/algs4/AVLTreeST.java.html](http://algs4.cs.princeton.edu/code/edu/princeton/cs/algs4/AVLTreeST.java.html).
    For a graphical visualization, please consider [www.cs.usfca.edu/~galles/visualization/AVLtree.html](http://www.cs.usfca.edu/~galles/visualization/AVLtree.html).
  prefs: []
  type: TYPE_NORMAL
- en: If you need to deep dive into this topic, I strongly recommend that you read
    a book dedicated to data structures since this is a quite vast topic.
  prefs: []
  type: TYPE_NORMAL
- en: Complete binary tree
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A complete binary tree is a binary tree in which every level, except possibly
    the last, is fully filled. Moreover, all the nodes are as far left as possible.
    In the following diagram, the left-hand side shows a non-complete binary tree,
    while the right-hand side shows a complete binary tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.8 – A non-complete binary tree versus a complete binary tree'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.8_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.8 – A non-complete binary tree versus a complete binary tree
  prefs: []
  type: TYPE_NORMAL
- en: A complete binary tree must be filled from left to right, so the left-hand side
    tree shown in the preceding diagram is not complete. A complete binary tree with
    *n* nodes always has O(log n) height.
  prefs: []
  type: TYPE_NORMAL
- en: Full binary tree
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A full binary tree is a binary tree in which every node has two children or
    none. In other words, a node cannot have only one child. In the following diagram,
    the left-hand side shows a non-full binary tree, while the right-hand side shows
    a full binary tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.9 – A non-full binary tree versus a full binary tree'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.9_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.9 – A non-full binary tree versus a full binary tree
  prefs: []
  type: TYPE_NORMAL
- en: The left-hand side tree in the preceding diagram is not full because node 68
    has one child.
  prefs: []
  type: TYPE_NORMAL
- en: Perfect binary tree
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A perfect binary tree is complete and full at the same time. The following
    diagram shows one such tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.10 – Perfect binary tree'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.10_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.10 – Perfect binary tree
  prefs: []
  type: TYPE_NORMAL
- en: So, in a perfect binary tree, all the leaf nodes are at the same level. This
    means that the last level contains the maximum number of nodes. These kinds of
    tree are pretty rare in interviews.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's discuss binary heaps in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Binary Heaps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In a nutshell, a Binary Heap is a complete binary tree that has a *heap property*.
    When the elements are in ascending order (the heap property says that the element
    of each node is greater than or equal to the element of its parent), we have a
    Min Binary Heap (the minimum element is the root element), while when they are
    in descending order (the heap property says that the element of each node is less
    than or equal to the element of its parent), we have a Max Binary Heap (the maximum
    element is the root element).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows a complete binary tree (left-hand side), a Min
    Binary Heap (in the middle), and a Max Binary Heap (right-hand side):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.11 – Complete binary tree and min and max heaps'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.11_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.11 – Complete binary tree and min and max heaps
  prefs: []
  type: TYPE_NORMAL
- en: A Binary Heap is not sorted. It is partially ordered. There is no relationship
    between the nodes on any given level.
  prefs: []
  type: TYPE_NORMAL
- en: 'A Binary Heap is typically represented as an array (let''s denote it as *heap*)
    whose root is at *heap*[0]. More importantly, for *heap*[*i*], we have that the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*heap*[(*i* - 1) / 2]: Returns the parent node'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*heap*[(2 * *i*) + 1]: Returns the left child node'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*heap*[(2 * *i*) + 2]: Returns the right child node'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A Max Binary Heap, when implemented via an array, looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The common operations that are used with a heap are `add()`, `poll()`, and `peek()`.
    After adding or polling an element, we must fix the heap so that it respects the
    heap property. This step is commonly referenced as *heapifying* the heap.
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding an element to a heap is an O(log n) time operation. The new element
    is added at the end of the heap tree. If the new element is smaller than its parent,
    then we don''t need to do anything. Otherwise, we have to traverse the heap upward
    to fix the violated heap property. This operation is known as *heapify-up*. The
    algorithm behind *heapify-up* has two steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start from the end of the heap as the current node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: While the current node has a parent and the parent is less than the current
    node, swap these nodes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Polling an element from a heap is also an O(log n) time operation. After we''ve
    polled the root element of the heap, we have to fix the heap so that it respects
    the heap property. This operation is known as *heapify-down*. The algorithm behind
    *heapify-down* has three steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start from the root of the heap as the current node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Determine the largest node between the children of the current node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the current node is less than its largest children, then swap these two nodes
    and repeat from *step 2*; otherwise, there is nothing else to do, so stop.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, peeking is an O(1) operation that returns the root element of the heap.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the code bundled with this book, you can find an application called *MaxHeap*
    that exposes the following set of methods: `add(T element)`, `peek()`, and `poll()`.'
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: A special case of a tree is known as a Trie. Also known as a *digital tree*
    or a *prefix tree,* a Trie is an ordered tree structure used commonly for storing
    strings. Its name comes from the fact that Trie is a re*Trie*val data structure.
    Its performance is better than a binary tree. Trie is detailed in my book, *Java
    Coding Problems* ([https://www.packtpub.com/programming/java-coding-problems](https://www.packtpub.com/programming/java-coding-problems)),
    next to other data structures such as tuples, disjoint-set, binary indexed trees
    (Fenwick trees), and Bloom filters.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's have a brief overview of graphs.
  prefs: []
  type: TYPE_NORMAL
- en: Graphs in a nutshell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A graph is a data structure that's used to represent a collection of nodes that
    can be connected with edges. For example, a graph can be used to represent a network
    of members on a social media platform, so it is a great data structure for representing
    real-life connections. A tree (as detailed in the previous section) is a particular
    type of graph. In other words, a tree is a graph without cycles. In graph terms,
    a graph without cycles is called an *acyclic graph*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The specific terminology for graphs involves two main terms:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Vertex** represents the information (for example, a member, a dog, or a value)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Edge** is the connection or the relationship between two vertices'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The connection can be unidirectional (as in the case of binary trees) or bidirectional.
    When the connection is bidirectional (such as a two-way street), the graph is
    known as an *undirected graph* and it has *undirected edges*. When the connection
    is unidirectional (such as a one-way street), then the graph is known as a *directed
    graph* and it has *directed edges*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The edges of a graph can carry information known as the weight (for example,
    the length of a road). In this case, the graphs are called *weighted graphs*.
    When a graph has a single edge that points to the same vertex, it is called a
    *self-loop graph*. The following diagram provides representations for each of
    these graph types:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.12 – Graph types'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.12_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.12 – Graph types
  prefs: []
  type: TYPE_NORMAL
- en: Unlike binary trees, representing graphs via node links is not practical. In
    computers, a graph is commonly represented via the adjacency matrix or adjacency
    list. Let's tackle the former; that is, the adjacency matrix.
  prefs: []
  type: TYPE_NORMAL
- en: Adjacency matrix
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An adjacency matrix is represented by a boolean two-dimensional array (or an
    integer two-dimensional array that contains only 0s and 1s) of size *n* x *n*,
    where *n* is the number of vertices. If we denote this two-dimensional array as
    a *matrix,* then *matrix*[*i*][*j*] is true (or 1) if there is an edge from vertex
    *i* to vertex *j*; otherwise, it is false (or 0). The following diagram shows
    an example of an adjacency matrix for an undirected graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.13 – An adjacency matrix for an undirected graph'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.13_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.13 – An adjacency matrix for an undirected graph
  prefs: []
  type: TYPE_NORMAL
- en: In order to save space, a bit-matrix can be used as well.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of weighted graphs, the adjacency matrix can store the weight of
    the edge, while 0 can be used to indicate the absence of the edge.
  prefs: []
  type: TYPE_NORMAL
- en: 'Implementing a graph based on the adjacency matrix can be done as follows (all
    we need is the list of vertices since the edges are passed to each method that
    has to traverse the graph as the adjacency matrix):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Another approach we can use to represent a graph in a computer is the adjacency
    list.
  prefs: []
  type: TYPE_NORMAL
- en: Adjacency list
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An adjacency list is an array of lists whose size is equal to the number of
    vertices in the graph. Every vertex is stored in this array and it stores a list
    of adjacent vertices. In other words, the list at index *i* of the array contains
    the adjacent vertices of the vertex stored in the array at index *i*. The following
    diagram shows an example of an adjacency list for an undirected graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.14 – An adjacency list for an undirected graph'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.14_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.14 – An adjacency list for an undirected graph
  prefs: []
  type: TYPE_NORMAL
- en: 'Implementing a graph based on the adjacency list can be done as follows (here,
    we are using a `Map` to implement the adjacency list):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Next, let's briefly cover the traversal of a graph.
  prefs: []
  type: TYPE_NORMAL
- en: Graph traversal
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The two most common ways to traverse a graph are via **Depth-first Search**
    (**DFS**) and **Breadth-first Search** (**BFS**). Let's have a rundown of each.
    **BFS** is mainly used for graphs.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of graphs, we must consider that a graph may have cycles. A plain
    BFS implementation (as you saw in the case of binary trees) doesn''t take cycles
    into account, so we risk an infinite loop while traversing the BFS queue. Eliminating
    this risk can be done via an additional collection that holds the visited nodes.
    The steps for this algorithm are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Mark the start node (current node) as visited (add it to the collection of visited
    nodes) and add it to the BFS queue.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pop the current node from the queue.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Visit the current node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get the adjacent nodes of the current node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Loop the adjacent nodes. For each non-null and unvisited node, do the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. Mark it as visited (add it to the collection of visited nodes).
  prefs: []
  type: TYPE_NORMAL
- en: b. Add it to the queue.
  prefs: []
  type: TYPE_NORMAL
- en: Repeat from *step 2* until the queue is empty.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Depth-first Search (DFS) for graphs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the case of graphs, we can implement the DFS algorithm via recursion or iterative
    implementation.
  prefs: []
  type: TYPE_NORMAL
- en: DFS for graphs via recursion
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The steps for implementing the DFS algorithm for graphs via recursion are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Start from the current node (the given node) and mark the current node as visited
    (add it to the collection of visited nodes).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Visit the current node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Traverse the unvisited adjacent vertices via recursion.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: DFS for graphs – iterative implementation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The iterative implementation of the DFS algorithm relies on a `Stack`. The
    steps are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Start from the current node (the given node) and push the current node into
    `Stack`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'While `Stack` is not empty, do the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. Pop the current node from `Stack.`
  prefs: []
  type: TYPE_NORMAL
- en: b. Visit the current node.
  prefs: []
  type: TYPE_NORMAL
- en: c. Mark the current node as visited (add it to the collection of visited nodes).
  prefs: []
  type: TYPE_NORMAL
- en: d. Push the unvisited adjacent vertices into `Stack`.
  prefs: []
  type: TYPE_NORMAL
- en: In the code bundled with this book, you can find a graph implementation based
    on the adjacency matrix called *GraphAdjacencyMatrixTraversal.* You can also find
    one based on the adjacency list called *GraphAdjacencyListTraversal.* Both applications
    contain BFS and DFS implementations.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenges
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have had a brief overview of trees and graphs, it is time to challenge
    ourselves with the 25 most popular coding problems encountered in interviews about
    these topics.
  prefs: []
  type: TYPE_NORMAL
- en: As usual, we have a mix of problems that are usually encountered by the top
    companies of the world, including IT giants such as Amazon, Adobe and Google.
    So, let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 1 – Paths between two nodes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`true` if there is a path (route) between two given nodes.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: Let''s consider the directed graph shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.15 – Paths from D to E and vice versa'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.15_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.15 – Paths from D to E and vice versa
  prefs: []
  type: TYPE_NORMAL
- en: 'If we consider nodes *D* and *E*, then we can see that from *D* to *E*, there
    are three paths, while from *E* to *D*, there are none. So, if we start from *D*
    and traverse the graph (via BFS or DFS) then, at some point, we have to pass through
    node *E*, otherwise there will be no path between *D* and *E*. So, the solution
    to this problem consists of starting from one of the given nodes and traversing
    the graph until we reach the second given node or until there are no more valid
    moves. For example, we can do this via BFS as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The complete application is called *DirectedGraphPath.*
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 2 – Sorted array to minimal BST
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Amazon**, **Google**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem**: Consider you''ve been given a sorted (ascending order) array of
    integers. Write a snippet of code that creates the minimal BST from this array.
    We define the minimal BST as the BST with the minimum height.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: Consider the given array as {-2, 3, 4, 6, 7, 8, 12, 23, 90}.
    The minimal BST that can be created from this array looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.16 – Sorted array to minimal BST'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.16_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.16 – Sorted array to minimal BST
  prefs: []
  type: TYPE_NORMAL
- en: In order to obtain a BST of minimal height, we must strive to distribute an
    equal number of nodes in the left and right sub-trees. With this statement in
    mind, note that we can choose the middle of the sorted array as the root. The
    elements of the array on the left-hand side of the middle are smaller than the
    middle, so they can form the left sub-tree. The elements of the array on the right-hand
    side of the middle are greater than the middle, so they can form the right sub-tree.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we can choose 7 as the root of the tree. Next, -2, 3, 4, and 6 should form
    the left sub-tree, while 8, 12, 23, and 90 should form the right sub-tree. However,
    we know that we cannot simply add these elements to the left or right sub-trees
    since we have to respect the BST property: in a BST, for each node, *n*, the *left
    descendants of n ≤ n < right descendants of n*.'
  prefs: []
  type: TYPE_NORMAL
- en: However, we can simply follow the same technique. If we consider -2, 3, 4, and
    6 as an array, then its middle is 3, and if we consider 8, 12, 24, and 90 as an
    array, then its middle is 12\. So, 3 is the root of the left sub-sub-tree containing
    -2, and the right sub-sub-tree is the one that contains 4 and 6\. Similarly, 12
    is the root of the left sub-sub-tree containing 8, and the right sub-sub-tree
    is the one that contains 24 and 90\.
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, I think we have enough experience to intuit that the same technique can
    be applied until we''ve processed all the sub-arrays. Moreover, it is quite intuitive
    that this solution can be implemented via recursion (if you don''t consider recursion
    one of your top skills, review [*Chapter 8*](B15403_08_Final_JM_ePub.xhtml#_idTextAnchor161)*,
    Recursion and Dynamic Programming*). So, we can resume our algorithm in four steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Insert the middle element of the array into the tree.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Insert the elements of the left sub-array into the left sub-tree.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Insert the elements of the right sub-array into the right sub-tree.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Trigger the recursive call.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following implementation puts these steps into code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The complete application is called *SortedArrayToMinBinarySearchTree.*
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 3 – List per level
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Problem**: Consider you''ve been given a binary tree. Write a snippet of
    code that creates a list of elements for each level of the tree (for example,
    if the tree has a depth of *d*, then you''ll have *d* lists).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: Let''s consider the binary tree shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.17 – List per level'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.17_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.17 – List per level
  prefs: []
  type: TYPE_NORMAL
- en: So, we have a binary tree of depth 3\. On depth 0, we have the root, 40\. On
    depth 1, we have 47 and 45\. On depth 2, we have 11, 13, 44, and 88\. Finally,
    on depth 3, we have 3 and 1\.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is quite intuitive to think like this: if we traverse the binary tree level
    by level, then we can create a list of elements for each level. In other words,
    we can adapt the BFS algorithm (also known as Level-Order traversal) in such a
    way that we capture the elements at each traversed level. More precisely, we start
    by traversing the root (and create a list containing this element), continue by
    traversing level 1 (and create a list containing the elements from this level),
    and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When we reach level *i*, we will have already fully visited all the nodes on
    the previous level, *i*-1\. This means that to get the elements on level *i*,
    we must traverse all the children of the nodes of the previous level, *i*-1\.
    The following solution runs in O(n) time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The complete application is called *ListPerBinaryTreeLevel.*
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 4 – sub-tree
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Adobe**, **Microsoft**, **Flipkart**'
  prefs: []
  type: TYPE_NORMAL
- en: '`true` if *q* is a sub-tree of *p*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: Consider the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.18 – Binary tree’s sub-tree of another binary tree'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.18_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.18 – Binary tree's sub-tree of another binary tree
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, the binary tree in the middle, *q*, is a sub-tree of the *p1*
    binary tree (left-hand side) but is not a sub-tree of the *p2* binary tree (right-hand
    side).
  prefs: []
  type: TYPE_NORMAL
- en: 'Moreover, this diagram reveals two cases:'
  prefs: []
  type: TYPE_NORMAL
- en: If the root of *p* matches the root of *q* (*p.root.element == q.root.element*),
    then the problem reduces to check whether the right sub-tree of *q* is the same
    as the right sub-tree of *p,* or whether the left sub-tree of *q* is the same
    as the left sub-tree of *p*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the root of *p* doesn't match the root of *q* (*p.root.element != q.root.element*),
    then the problem reduces to check whether the left sub-tree of *p* is the same
    as *q,* or whether the right sub-tree of *p* is the same as *q*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In order to implement the first bullet, we need two methods. To better understand
    why we need two methods, check out the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.19 – Roots and leaves match but the intermediate nodes don’t'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.19_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.19 – Roots and leaves match but the intermediate nodes don't
  prefs: []
  type: TYPE_NORMAL
- en: If the roots of *p* and *q* match but some of the nodes from the left/right
    sub-trees don't match, then we have to go back to where we started with *p* and
    *q* to check whether *q* is a sub-tree of *p*. The first method should check whether
    the trees are the same once their roots are the same. The second method should
    handle the case where we find that the trees are not the same but start at a certain
    node. Pay attention to this aspect, since many candidates don't take it into account.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in terms of code, we have the following (for *n* nodes, this runs in O(n)
    time):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The application is called *BinaryTreeSubtree**.*
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 5 – Landing reservation system
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Amazon**, **Adobe**, **Microsoft**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem**: Consider an airport with a single runway. This airport receives
    landing requests from different airplanes. A landing request contains the landing
    time (for example, 9:56) and the time in minutes needed to complete the procedure
    (for example, 5 minutes). We denote it as 9:56 (5). Write a snippet of code that
    uses a BST to design this reservation system. Since there is a single runway,
    the code should reject any landing request that overlaps an existing one. The
    order of requests dictates the order of reservations.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: Let''s consider a time screenshot of our landing timeline (the
    order for the landing requests was 10:10 (3), 10:14 (3), 9:55 (2), 10:18 (1),
    9:58 (5), 9:47 (2), 9:41 (2), 10:22 (1), 9:50 (6), and 10:04 (4). This can be
    seen in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.20 – Timeline screenshot'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.20_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.20 – Timeline screenshot
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we have already done several reservations, as follows: at 9:41, an airplane
    will land and it will need 2 minutes to complete the procedure; at 9:47 and 9:55,
    there are two other airplanes that need 2 minutes to complete landing; at 9:58,
    we have an airplane that needs 5 minutes to complete landing; and so on. Moreover,
    we also have two new landing requests denoted in the diagram as *R1* and *R2*.'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we cannot approve the *R1* landing request. The landing time is
    9:50 and it needs 6 minutes to complete, so it ends at 9:56\. However, at 9:56,
    we already have the airplane from 9:55 on the runway. Since we have a single runway,
    we reject this landing request. We consider such cases as overlappings.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, we approve the *R2* landing request. The request time is
    10:04 and it needs 4 minutes to complete, so it ends at 10:08\. At 10:08, there
    is no other airplane on the runway since the next landing is at 10:10.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we have to use a BST to solve this problem, but using an array (sorted
    or unsorted) or a linked list (sorted or unsorted) is also a valid approach. Using
    an unsorted array (or linked list) will need O(1) time for inserting a landing
    request and O(n) time for checking the potential overlapping. If we were to use
    a sorted array (or linked list) and the Binary Search algorithm, then we could
    check the potential overlapping in O(log n). However, to insert a landing request,
    we will need O(n) because we have to shift all the elements to the right from
    the position of insertion.
  prefs: []
  type: TYPE_NORMAL
- en: 'How about using a BST? First, let''s represent the preceding timeline screenshot
    as a BST. Check out the following diagram (the order of the landing requests was
    10:10 (3), 10:14 (3), 9:55 (2), 10:18 (1), 9:58 (5), 9:47 (2), 9:41 (2), 10:22
    (1), *9:50 (6)*, and 10:04 (4)):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.21 – Timeline screenshot as a BST'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.21_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.21 – Timeline screenshot as a BST
  prefs: []
  type: TYPE_NORMAL
- en: This time, for each landing request, we only have to scan half of the tree.
    This is the consequence of using a BST (all the nodes on the left are smaller
    than all the nodes on the right, so a landing request time can only be in the
    left or the right sub-tree). For example, the landing request at 10:04 is less
    than the root (10:10), so it goes in the left sub-tree. If, at any given landing
    request, we encounter an overlapping, then we just return without inserting the
    corresponding node into the tree. We can find the potential overlappings in O(h),
    where *h* is the height of the BST, and we can insert it in O(1) time.
  prefs: []
  type: TYPE_NORMAL
- en: 'An overlapping is given by the following simple computation (we''re using the
    Java 8 Date-Time API, but you can reduce it to simple integers as well – if you
    are not familiar with the Java 8 Date-Time API, then I strongly recommend that
    you buy my book, *Java Coding Problems*, published by Packt ([https://www.packtpub.com/programming/java-coding-problems](https://www.packtpub.com/programming/java-coding-problems)).
    This book has an astonishing chapter about this topic that is a *must-read* for
    any candidate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'So, in *t1*, we compute the time between the (*landing time* + *time needed
    to complete*) of the current node and the *landing time* of the current request.
    In *t2*, we compute the time between the *landing time* of the current node and
    the (*current request landing time* + *time needed to complete*). If *t1* is less
    than or equal to *t2*, then we have found an overlapping, so we reject the current
    landing request. Let''s see the complete code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we can easily print the timeline by using the In-Order traversal
    of a BST. The complete application is called *BinaryTreeLandingReservation.*
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 6 – Balanced binary tree
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Amazon**, **Microsoft**'
  prefs: []
  type: TYPE_NORMAL
- en: '`true` if the binary tree is balanced.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: So, in order to have a balanced binary tree, for each node, the
    two sub-trees cannot differ in height by more than one. Conforming to this statement,
    the image on the right represents a balanced binary tree, while the image on the
    left represents an unbalanced binary tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.22 – Unbalanced and balanced binary trees'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.22_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.22 – Unbalanced and balanced binary trees
  prefs: []
  type: TYPE_NORMAL
- en: The binary tree on the left is unbalanced since the difference between the heights
    of the left sub-trees corresponding to nodes 40 (the root) and 30 and the right
    sub-trees is greater than one (for example, the *left-height*(40) = 4 while the
    *right-height*(40) = 2).
  prefs: []
  type: TYPE_NORMAL
- en: The right-hand side binary tree is balanced since, for each node, the difference
    between the height of the left sub-tree and the right sub-tree is not greater
    than one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on this example, we can intuit that a simple solution consists of a recursive
    algorithm. We can traverse each node and compute the height of the left and right
    sub-trees. If the difference between these heights is greater than one, then we
    return `false`. In terms of code, this is quite straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This approach performs in O(n log n) time because, on each node, we apply the
    recursion through its entire sub-tree. So, the problem is the number of `height()`
    calls. At this moment, the `height()` method only computes the heights. But it
    can be improved to check whether the tree is balanced as well. All we need to
    do is signal an unbalanced sub-tree via an error code. On the other hand, for
    a balanced tree, we return the corresponding height. In place of an error code,
    we can use `Integer.MIN_VALUE`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This code runs in O(n) time and O(h) space, where *h* is the height of the tree.
    The application is called *BinaryTreeBalanced.*
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 7 – Binary tree is a BST
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Amazon**, **Google**, **Adobe**, **Microsoft**, **Flipkart**'
  prefs: []
  type: TYPE_NORMAL
- en: '`true` if this tree is a **Binary Search Tree** (**BST**).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: Right from the start, we notice that the problem is explicitly
    mentioning that the given binary tree may contain duplicates. Why is this important?
    Because if the binary tree doesn''t allow duplicates, then we can rely on a simple
    In-Order traversal and an array. If we add each traversed element to an array,
    then the resulting array will be sorted only if the binary tree is a BST. Let''s
    clarify this aspect via the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.23 – Valid and invalid BSTs'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.23_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.23 – Valid and invalid BSTs
  prefs: []
  type: TYPE_NORMAL
- en: We know that the BST property says that for each node, *n*, of a BST, the *left
    descendants of n ≤ n < right descendants of n*. This means that the first two
    binary trees shown in the previous diagram are valid BST, while the last one is
    not a valid BST. Now, adding the elements of the middle and the last binary tree
    to the array will result in an array of [40, 40]. This means we cannot validate
    or invalidate a BST based on this array since we cannot distinguish between the
    trees. So, in conclusion, you should rely on this simple algorithm if the given
    binary tree doesn't accept duplicates.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, it''s time to take this a step further. Let''s examine the *left descendants
    of n ≤ n < right descendants of n* statement shown in the following binary tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.24 – Invalid BST](img/Figure_13.24_B15403.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.24 – Invalid BST
  prefs: []
  type: TYPE_NORMAL
- en: Check this out! For each node, *n*, we can write that *n.left ≤ n < n.right*,
    but it is clear that 55 is in the wrong place. So, let's reinforce that all the
    left nodes of the current node should be less than or equal to the current node,
    which must be less than all the right nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In other words, it is not enough to validate the left and right nodes of the
    current node. We must validate each node against a range of nodes. More precisely,
    all the nodes of a left or a right sub-tree should be validated against a range
    bounded by the minimum accepted element, respectively the maximum accepted element
    (*min, max*). Let''s consider the following tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.25 – Validating a BST'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.25_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.25 – Validating a BST
  prefs: []
  type: TYPE_NORMAL
- en: 'We start from the root (40) and we consider (*min*=null, *max*=null), so 40
    meets the condition since there is no minimum or maximum limit. Next, we go to
    the left sub-tree (let''s denote this sub-tree as 40-left-sub-tree). All the nodes
    from the 40-left-sub-tree should range between (null, 40). Next, we go to the
    left again, and we meet the 35-left-sub-tree, which should range between (null,
    35). Basically, we continue to go left until there are no nodes left. At this
    point, we start going to the right, so the 35-right-sub-tree should range between
    (35, 40), the 40-right-sub-tree should range between (40, null), and so on. So,
    when we go to the left, the maximum value gets updated. When we go to the right,
    the minimum gets updated. If anything goes wrong, then we stop and return `false`.
    Let''s see the code based on this algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The complete application is called *BinaryTreeIsBST.*
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 8 – Successor node
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Google**, **Microsoft**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem**: Consider you''ve been given a **Binary Search Tree** (**BST**)
    and a node from this tree. Write a snippet of code that prints the successor node
    of the given node in the context of In-Order traversal.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: So, let''s recall the In-Order traversal of a binary tree. This
    **Depth-first Search** (**DFS**) flavor traverses the left sub-tree, then the
    current node, and then the right sub-tree. Now, let''s assume that we arbitrarily
    choose a node from a BST (let''s denote it as *n*) and we want to find its successor
    (let''s denote it as *s*) in the context of In-Order traversal.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider the following diagram as the given BST. We can use it as support
    for distinguishing between the possible cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.26 – BST sample with start and successor nodes'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.26_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.26 – BST sample with start and successor nodes
  prefs: []
  type: TYPE_NORMAL
- en: As shown in the preceding diagram, we denoted two main cases as (a) and (b).
    In case (a), the node, *n*, has the right sub-tree. In case (b), the node, *n*,
    doesn't contain the right sub-tree.
  prefs: []
  type: TYPE_NORMAL
- en: Case (a), exemplified in the left-hand side BST, reveals that if the node, *n*,
    has the right sub-tree, then the successor node, *s*, is the leftmost node of
    this right sub-tree. For example, for *n*=50, the successor node is 54.
  prefs: []
  type: TYPE_NORMAL
- en: 'Case (b) has two sub-cases: a simple case and a tricky case. The simple case
    is exemplified by the middle BST shown in the preceding diagram. When the node,
    *n*, doesn''t contain the right sub-tree and *n* is the left child of its parent,
    then the successor node is this parent. For example, for *n*=40, the successor
    node is 50\. This is the simple sub-case of (b).'
  prefs: []
  type: TYPE_NORMAL
- en: The tricky sub-case of (b) is exemplified by the right-hand side BST shown in
    the preceding diagram. When the node, *n*, doesn't contain the right sub-tree
    and *n* is the right child of its parent, then we have to traverse upward until
    *n* becomes the left child of its parent. Once we've done that, we return this
    parent. For example, if *n*=59, then the successor node is 60.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, we must consider that if *n* is the last node in the traversal, then
    we return the root's parent, which can be null.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we glue these cases to form some pseudocode, then we get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can translate this pseudocode into code, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The complete application is called *BinarySearchTreeSuccessor**.* This application
    also contains the same problem, but is resolved via Pre-Order and Post-Order traversal.
    Before checking the solutions for the Pre-Order and Post-Order contexts, you should
    challenge yourself by identifying the possible cases and sketching the pseudocode
    and its implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 9 – Topological sort
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Amazon**, **Google**, **Adobe**, **Microsoft**, **Flipkart**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem**: Consider you''ve been given a **Directed Acyclic Graph** (**DAG**);
    that is, a directed graph without cycles. Write a snippet of code that returns
    the linear ordering of vertices such that for every directed edge, *XY*, vertex
    *X* comes before *Y* in the ordering. In other words, for every edge, the source
    node comes before the destination. This is also known as topological sort, and
    it only works for DAGs.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: Let''s dive into this problem via the following DAG:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.27 – Directed acyclic graph (DAG)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.27_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.27 – Directed acyclic graph (DAG)
  prefs: []
  type: TYPE_NORMAL
- en: Let's start the topological sort from vertex D. Before vertex D, there is no
    other vertex (no edge), so we can add D to the result, (D). From D, we can go
    to B or A. Let's go to vertex A. We cannot add A to the result because we didn't
    process vertex B of edge BA, so let's go to vertex B. Before B, we have only D,
    which was added to the result, so we can add B to the result, (D, B). From B,
    we can go to A, E, C, and F. We cannot go to C since we didn't process AC, and
    we cannot go to F since we didn't process CF. However, we can go to A since DA
    and BA have been processed, and we can go to E since before E, there's only B,
    which is in the result. Notice that the topological sort may provide different
    results. Let's go to E. Due to this, E is added to the result (D, B, E). Next,
    we can add A to the result, which allows us to add C, which allows us to add F.
    So, the result is now (D, B, E, A, C, F). From F, we can go to G. Since EG has
    been processed, we can add G to the result. Finally, from G, we go to H and we
    obtain the topological sort result as (D, B, E, A, C, F, G, H).
  prefs: []
  type: TYPE_NORMAL
- en: This traversal is just an arbitrary traversal that we cannot put it into code.
    However, we know that a graph can be traversed via the BFS and DFS algorithms.
    If we try to think in the context of DFS, then we start from node D and we traverse
    B, A, C, F, G, H, and E. While we perform the DFS traversal, we cannot simply
    add the vertices to the result since we break the problem requirement (for every
    directed edge, *XY*, vertex *X* comes before *Y* in the ordering). However, we
    can use a `Stack` and push a vertex into this stack after traversing all its neighbors.
    This means that H is the first vertex that's pushed into the stack, followed by
    G, F, C, A, E, B, and D. Now, popping from the stack until it is empty will give
    us the topological sort as D, B, E, A, C, F, G, and H.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, topological sort is just a DFS flavor based on a `Stack` that can be implemented
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The complete application is called *GraphTopologicalSort.*
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 10 – Common ancestor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Amazon**, **Google**, **Microsoft**, **Flipkart**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem**: Consider you''ve been given a binary tree. Write a snippet of
    code that finds the first common ancestor of two given nodes. You cannot store
    additional nodes in a data structure.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: The best way to analyze this kind of problem is by taking some
    paper and a pen and drawing a binary tree with some samples. Notice that the problem
    doesn''t say that this is a BST. Practically, it can be any valid binary tree.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following diagram, we have three possible scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.28 – Finding the first common ancestor'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.28_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.28 – Finding the first common ancestor
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we can see that the given nodes can be in different sub-trees (left-
    and right-hand trees) or in the same sub-tree (middle tree). So, we can traverse
    the tree starting from the root using a method of the `commonAncestor(Node root,
    Node n1, Node n2)` type and return it as follows (*n1* and *n2* are the two given
    nodes):'
  prefs: []
  type: TYPE_NORMAL
- en: Returns *n1* if the root's sub-tree includes *n1* (and doesn't include *n2*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns *n2* if the root's sub-tree includes *n2* (and doesn't include *n1*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns `null` if neither *n1* nor *n2* are in the root's sub-tree
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Else, it returns the common ancestor of *n1* and *n2*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When `commonAncestor(n.left, n1, n2)` and `commonAncestor(n.right, n1, n2)`
    return non-null values, this means that *n1* and *n2* are in different sub-trees
    and *n* is the common ancestor. Let''s see this in terms of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The complete application is called *BinaryTreeCommonAncestor.*
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 11 – Chess knight
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Amazon**, **Microsoft**, **Flipkart**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem**: Consider you''ve been given a chess board and a knight. Initially,
    the knight is placed in a cell (start cell). Write a snippet of code that computes
    the minimum number of moves needed to move the knight from the start cell to a
    given target cell.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: Let''s consider an example. The chess board is 8x8 in size and
    the knight starts from cell (1, 8). The target cell is (8, 1). As the following
    image reveals, the knight needs to make a minimum of 6 moves to go from cell (1,
    8) to cell (8, 1):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.29 – Moving the knight from cell (1, 8) to cell (8, 1)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.29_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.29 – Moving the knight from cell (1, 8) to cell (8, 1)
  prefs: []
  type: TYPE_NORMAL
- en: 'As this image reveals, a knight can move from an (*r, c*) cell to eight other
    valid cells, as follows: (*r*+2*, c*+1), (*r*+1*, c*+2), (*r*-1*,c*+2), (*r*-2*,
    c*+1), (*r*-2*, c*-1), (*r*-1*, c*-2), (*r*+1*, c*-2), and (*r*+2*, c*-1). So,
    there are eight possible movements. If we think of these possible movements as
    directions (edges) and the cells as vertices, then we can visualize this problem
    in the context of a graph. The edges are the possible moves, while the vertices
    are the possible cells for the knight. Each move holds the distance from the current
    cell to the start cell. For each move, the distance is increased by 1\. So, in
    the context of a graph, the problem reduces to finding the shortest path in a
    graph. Hence, we can use BFS to solve this problem.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The steps for this algorithm are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an empty queue.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enqueue the starting cell so that it has a distance of 0 from itself.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As long as the queue is not empty, do the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. Pop the next unvisited cell from the queue.
  prefs: []
  type: TYPE_NORMAL
- en: b. If the popped cell is the target cell, then return its distance.
  prefs: []
  type: TYPE_NORMAL
- en: c. If the popped cell is not the target cell, then mark this cell as visited
    and enqueue each of the eight possible movements into the queue by increasing
    the distance by 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we rely on the BFS algorithm, we know that all the cells whose shortest
    path is 1 are visited first. Next, the visited cells are the adjacent cells whose
    shortest paths are 1+1=2 and so on; hence any cell whose shortest path is equal
    to the *shortest path of its parent* + 1\. This means that when we traverse the
    target cell for the first time, it gives us the final result. This is the shortest
    path. Let''s see the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The application is called *ChessKnight.*
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 12 – Printing binary tree corners
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Amazon**, **Google**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem**: Consider you''ve been given a binary tree. Write a snippet of
    code that prints the corners of this tree at each level.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: Let''s consider the following tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.30 – Printing binary tree corners'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.30_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.30 – Printing binary tree corners
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the main idea is to print the leftmost and rightmost nodes at each level.
    This means that a Level-Order traversal (BFS) can be useful since we can traverse
    each level. All we have to do is identify the first and the last node on each
    level. To do this, we need to adjust the classical Level-Order traversal by adding
    a condition that''s meant to determine whether the current node represents a corner.
    The code speaks for itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The application is called *BinaryTreePrintCorners.*
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 13 – Max path sum
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Amazon**, **Google**, **Adobe**, **Microsoft**, **Flipkart**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem**: Consider you''ve been given a non-empty binary tree. Write a snippet
    of code that computes the maximum path sum. A path is considered any sequence
    of nodes starting from any node and ending in any node in the tree, along with
    the parent-child connections. The path must contain at least one node and may
    or may not go through the root of the tree.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: The following diagram shows three examples of a max path sum:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.31 – Three examples of a max path sum'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.31_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.31 – Three examples of a max path sum
  prefs: []
  type: TYPE_NORMAL
- en: 'Finding a solution to this problem requires us to identify the number of ways
    in which the current node can be a part of the maximum path. By inspecting the
    preceding examples, we can isolate four cases, as shown in the following diagram
    (take your time and look at more examples until you reach the same conclusion):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.32 – Number of ways the current node can be a part of the maximum
    path'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.32_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.32 – Number of ways the current node can be a part of the maximum
    path
  prefs: []
  type: TYPE_NORMAL
- en: 'So, a node that is part of the max path is put into one of the following four
    cases:'
  prefs: []
  type: TYPE_NORMAL
- en: The node is the only node in the max path
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The node is part of the max path next to its left child
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The node is part of the max path next to its right child
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The node is part of the max path next to its left and right children
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'These four steps lead us to a clear conclusion: we must iterate over all the
    nodes of the tree. A good choice is the DFS algorithm, but, more precisely, the
    Post-Order tree traversal, which imposes the traversal order as **left sub-tree**
    | **right sub-tree** | **root**. While we traverse the tree, we pass the maximum
    of the rest of the tree to the parent. The following diagram reveals this algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.33 – Post-order traversal and passing the maximum in the tree to
    the parent'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.33_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.33 – Post-order traversal and passing the maximum in the tree to the
    parent
  prefs: []
  type: TYPE_NORMAL
- en: 'So, if we apply this algorithm step by step to the preceding diagram, we get
    the following (remember that this is a Post-Order traversal):'
  prefs: []
  type: TYPE_NORMAL
- en: 41 does not have children, so 41 is added to max(0, 0), 41+max(0, 0)=41.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 3 only has the left child, -5, so 3 is added to max(-5, 0), 3+max(-5, 0)=3.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: -2 is added to the max(41, 3) sub-trees, so -2+max(41, 3)=39.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: -7 does not have children, so -7 is added to max(0, 0), -7+max(0, 0)=-7.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 70 does not have children, so 70 is added to max(0, 0), 70+max(0, 0)=70.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: -1 is added to the max(-7, 70) sub-trees, so -1+70=69.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 50 is added to the maximum of the left (39) and the right (69) sub-trees, so
    39+69+50=158 (this is the max path sum).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code reveals the implementation of this algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The application is called *BinaryTreeMaxPathSum.*
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 14 – Diagonal traversal
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Amazon**, **Adobe**, **Microsoft**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem**: Consider you''ve been given a non-empty binary tree. Write a snippet
    of code that prints all the nodes for each negative diagonal (\). A negative diagonal
    has a negative slope.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: If you are not familiar with the notion of a binary tree negative
    diagonal, then ensure you clarify this aspect with the interviewer. They will
    probably provide you with an example, similar to the one shown in the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.34 – Negative diagonals of a binary tree'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.34_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.34 – Negative diagonals of a binary tree
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding diagram, we have three diagonals. The first diagonal contains
    nodes 50, 12, and 70\. The second diagonal contains nodes 45, 3, 14, and 65\.
    Finally, the third diagonal contains nodes 41 and 11.
  prefs: []
  type: TYPE_NORMAL
- en: Recursion-based solution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One solution to this problem is to use recursion and *hashing* (if you are not
    familiar with the concept of hashing, then please read [*Chapter 6*](B15403_06_Final_JM_ePub.xhtml#_idTextAnchor080)*,
    Object-Oriented Programming*, the *Hash table* problem). In Java, we can use hashing
    via the built-in `HashMap` implementation, so there is no need to write a hashing
    implementation from scratch. But how is this `HashMap` useful? What should we
    store in an entry (key-value pair) of this map?
  prefs: []
  type: TYPE_NORMAL
- en: 'We can associate each diagonal in the binary tree with a key in the map. Since
    each diagonal (key) contains multiple nodes, it is very convenient to represent
    the value as a `List`. While we traverse the binary tree, we need to add the current
    node to the proper `List`, so under the proper diagonal. For example, here, we
    can perform a Pre-Order traversal. Every time we go to the left sub-tree, we increase
    the diagonal by 1, and every time we go to the right sub-tree, we maintain the
    current diagonal. This way, we obtain something similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.35 – Pre-Order traversal and increasing the diagonal by 1 for the
    left child'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.35_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.35 – Pre-Order traversal and increasing the diagonal by 1 for the
    left child
  prefs: []
  type: TYPE_NORMAL
- en: 'The time complexity of the following solution is O(n log n) with an auxiliary
    space of O(n), where *n* is the number of nodes in the tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's look at another solution for this problem.
  prefs: []
  type: TYPE_NORMAL
- en: Iterative-based solution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Solving this problem can be done iteratively as well. This time, we can employ
    Level-Order traversal and enqueue the nodes of a diagonal using a `Queue`. The
    main pseudocode for this solution can be written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'When this pseudocode is put into code, we get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code runs in O(n) time with an auxiliary space of O(n), where
    *n* is the number of nodes in the tree. The complete application is called *BinaryTreePrintDiagonal.*
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 15 – Handling duplicates in BSTs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Amazon**, **Microsoft**, **Flipkart**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem**: Consider you''ve been given a BST that allows duplicates. Write
    an implementation that supports the insert and delete operations while handling
    duplicates.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: We know that the property of a BST claims that for each node,
    *n*, we know that the *left descendants of n ≤ n < right descendants of n*. Commonly,
    problems that involve BSTs don''t allow duplicates, so duplicates cannot be inserted.
    However, if duplicates are allowed, then our convention will be to insert the
    duplicate into the left sub-tree.'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, the interviewer probably expects to see an implementation that allows
    us to associate a count with each node, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.36 – Handling duplicates in a BST'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.36_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.36 – Handling duplicates in a BST
  prefs: []
  type: TYPE_NORMAL
- en: 'To provide this implementation, we need to modify the structure of a classical
    BST so that it supports a counter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Every time we create a new node (a node that doesn't exist in the tree), the
    counter will be equal to 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we insert a node, we need to distinguish between a new node and a duplicate
    node. If we insert a duplicate node, then all we need to do is increase the counter
    of that node by one, without creating a new node. The relevant part of the insert
    operation is listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Deleting a node follows similar logic. If we delete a duplicate node, then
    we just decrease its counter by one. If the counter is already equal to 1, then
    we just delete the node. The relevant code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The complete application is called *BinarySearchTreeDuplicates.* Another solution
    to this problem consists of using a hash table to keep count of the nodes. This
    way, you don't modify the tree structure. Challenge yourself and complete this
    implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 16 – Isomorphism of binary trees
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Amazon**, **Google**, **Microsoft**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem**: Consider you''ve been given two binary trees. Write a snippet
    of code that decides whether these two binary trees are isomorphic to each other.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: If you are not familiar with the term *isomorphic*, then you
    have to clarify this with the interviewer. This term is very well-defined in mathematics,
    but the interviewer probably won''t give a mathematical explanation/demonstration,
    and, as you know, mathematicians have their own language that hardly passes for
    fluent and easy-to-understand English. Moreover, in mathematics, the notion of
    isomorphism refers to any two structures, not only binary trees. So, the interviewer
    will probably give you an explanation, as follows (let''s denote the trees as
    *T1* and *T2*):'
  prefs: []
  type: TYPE_NORMAL
- en: '**Definition 1**: *T1 and T2 are isomorphic if T1 can be changed to T2 via
    swapping the children several times. T1 and T2 don''t have to be the same physical
    shape at all.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Definition 2**: *T1 and T2 are isomorphic if you can translate T1 into T2
    and T2 into T1 without losing information.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Definition 3**: *Think of two strings, AAB and XXY. If A is transformed into
    X and B is transformed into Y, then AAB becomes XXY, so these two strings are
    isomorphic. So, two binary trees are isomorphic if T2 is a structure-wise mirror
    of T1.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'No matter what definition you get from the interviewer, I am pretty sure that
    all of them will attempt to give you an example. The following diagram shows a
    bunch of examples of isomorphic binary trees:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.37 – Isomorphic binary tree examples'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.37_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.37 – Isomorphic binary tree examples
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on the preceding definitions and examples, we can shape the following
    algorithm for determining whether two binary trees are isomorphic:'
  prefs: []
  type: TYPE_NORMAL
- en: If *T1* and *T2* are `null`, then they are isomorphic, so return `true.`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If *T1* or *T2* is `null`, then they are not isomorphic, so return `false.`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If *T1.data* is not equal to *T2.data,* then they are not isomorphic, so return
    `false.`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Traverse the left sub-tree of *T1* and the left sub-tree of *T2*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Traverse the right sub-tree of *T1* and the right sub-tree of *T2*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. If the structures of *T1* and *T2* are identical, then return `true.`
  prefs: []
  type: TYPE_NORMAL
- en: b. If the structures of *T1* and *T2* are not identical, then we check whether
    one tree (or sub-tree) is mirroring another tree (sub-tree),
  prefs: []
  type: TYPE_NORMAL
- en: Traverse the left sub-tree of *T1* and the right sub-tree of *T2.*
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Traverse the right sub-tree of *T1* and the left sub-tree of *T2*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. If the structures are mirrored, then return `true`; otherwise, return `false.`
  prefs: []
  type: TYPE_NORMAL
- en: 'Putting this algorithm into code results in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The complete application is called *TwoBinaryTreesAreIsomorphic.*
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 17 – Binary tree right view
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Amazon**, **Google**, **Adobe**, **Microsoft**, **Flipkart**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem**: Consider you''ve been given a binary tree. Write a snippet of
    code that prints the right view of this tree. Printing the *right view* means
    printing all the nodes that you can see if you look at the binary tree from its
    right-hand side.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: If you''re unsure what the right view of a binary tree is, then
    clarify this with the interviewer. For example, the following diagram highlights
    the nodes that represent the right view of a binary tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.38 – Right view of a binary tree'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.38_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.38 – Right view of a binary tree
  prefs: []
  type: TYPE_NORMAL
- en: 'So, if you are placed in the right-hand side of this tree, you''ll only see
    nodes 40, 45, 44, 9, and 2\. If we think about Level-Order traversal (BFS), we
    obtain the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '**40**, 47, **45**, 11, 3, **44**, 7, 5, **9**, **2**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The highlighted nodes are the ones that represent the right view. However, each
    of these nodes represents the rightmost node at each level in the tree. This means
    that we can adjust the BFS algorithm and print the last node of each level.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is an O(n) complexity time algorithm with an auxiliary O(n) space (represented
    by the queue), where *n* is the number of nodes in the tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can implement a recursive solution as well.
  prefs: []
  type: TYPE_NORMAL
- en: This is an O(n) complexity time algorithm with an auxiliary O(n) space (represented
    by a map), where *n* is the number of nodes in the tree. You can find the recursive
    approach in the code bundled with this book in the *BinaryTreeRightView* application.
    Challenge yourself and implement the binary tree's left view.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 18 – kth largest element
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Google**, **Flipkart**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem**: Consider you''ve been given a BST. Write a snippet of code that
    prints the *k*th largest element without changing the BST.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: Let''s consider the following BST:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.39 – kth largest element in a BST'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.39_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.39 – kth largest element in a BST
  prefs: []
  type: TYPE_NORMAL
- en: For *k*=1, we can see that 56 is the first largest element. For *k*=2, we can
    see that 55 is the second largest element, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The brute-force solution is quite simple and will run in O(n) time, where *n*
    is the number of nodes in the tree. All we have to do is extract an array and
    place it in the In-Order traversal **(left sub-tree | right sub-tree | root)**
    of the tree: 45, 47, 50, 52, 54, 55, 56\. Once we''ve done that, we can find the
    *k*th element as *array*[*n-k*]. For example, for *k*=3, the third element is
    *array*[7-3] = *array*[4]=54\. You can challenge yourself if you wish and provide
    this implementation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, another approach that runs in O(k+h) complexity time, where *h* is
    the height of the BST, can be written based on the Reverse-In-Order traversal
    **(right sub-tree | left sub-tree | root)**, which gives us the elements in descending
    order: 56, 55, 54, 52, 50, 47, 45.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The code speaks for itself (the `c` variable counts the visited nodes):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The complete application is called *BinarySearchTreeKthLargestElement.*
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 19 – Mirror binary tree
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Amazon**, **Google**, **Adobe**, **Microsoft**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem**: Consider you''ve been given a binary tree. Write a snippet of
    code that constructs the mirror of this tree.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: A mirrored tree looks as follows (the tree on the right is the
    mirrored version of the left-hand side tree):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.40 – Given tree and the mirrored tree'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.40_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.40 – Given tree and the mirrored tree
  prefs: []
  type: TYPE_NORMAL
- en: So, a mirrored tree is like a horizontal flip of the given tree. To create the
    mirror of a tree, we have to decide whether we will return the mirror tree as
    a new tree or mirror the given tree in place.
  prefs: []
  type: TYPE_NORMAL
- en: Mirroring the given tree in a new tree
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Returning the mirror as a new tree can be done via a recursive algorithm that
    follows these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.41 - Recursive Algorithm](img/Figure_13.41_B15403_Recursive_Algorithm.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.41 - Recursive Algorithm
  prefs: []
  type: TYPE_NORMAL
- en: 'In terms of code, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's try to mirror the given tree in place.
  prefs: []
  type: TYPE_NORMAL
- en: Mirroring the given tree in place
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Mirroring the given tree in place can be done via recursion as well. This time,
    the algorithm follows these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Mirror the left sub-tree of the given tree.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Mirror the right sub-tree of the given tree.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Swap the left and right sub-trees (swap their pointers).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In terms of code, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The complete application is called *MirrorBinaryTree.*
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 20 – Spiral-level order traversal of a binary tree
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Amazon**, **Google**, **Microsoft**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem**: Consider you''ve been given a binary tree. Write a snippet of
    code that prints the spiral-level traversal of this binary tree. More precisely,
    all the nodes present at level 1 should be printed from left to right, followed
    by all the nodes present at level 2 printed from right to left, followed by all
    the nodes present at level 3 printed from left to right, and so on. So, odd levels
    should be printed from left to right and even levels should be printed from right
    to left.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: The spiral-level traversal can be formulated in two ways, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Odd levels should be printed from left to right and even levels from right to
    left.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Odd levels should be printed from right to left and even levels from left to
    right.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram represents these statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.42 – Spiral order traversal'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.41_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.42 – Spiral order traversal
  prefs: []
  type: TYPE_NORMAL
- en: So, on the left-hand side, we obtain 50, 12, 45, 12, 3, 65, 70, 24, and 41\.
    On the other hand, on the right-hand side, we obtain 50, 45, 12, 70, 65, 3, 12,
    41, and 24.
  prefs: []
  type: TYPE_NORMAL
- en: Recursive approach
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's try to implement the spiral order traversal from the left-hand side of
    the preceding diagram. Notice that the odd levels should be printed from left
    to right, while the even levels should be printed in reverse order. Basically,
    we need to adjust the well-known Level-Order traversal by flipping the direction
    of the even levels. This means that we can use a boolean variable to alternate
    the printing order. So, if the boolean variable is `true` (or 1), then we print
    the current level from left to right; otherwise, we print it from right to left.
    At each iteration (level), we flip the boolean value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Applying this via recursion can be done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This code runs in O(n2) time, which is quite inefficient. Can we do this more
    efficiently? Yes – we can do it in O(n) time with extra space, O(n), via an iterative
    approach.
  prefs: []
  type: TYPE_NORMAL
- en: Iterative approach
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's try to implement the spiral order traversal from the right-hand side of
    the given diagram. We'll do this via an iterative approach this time. Mainly,
    we can use two stacks (`Stack`) or a double ended queue (`Deque`). Let's learn
    how we can do this via two stacks.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main idea of using two stacks is quite straightforward: we use one stack
    to print the left-to-right nodes and the other stack to print the right-to-left
    nodes. At each iteration (or level), we have the corresponding nodes in one of
    the stacks. While we print the nodes from a stack, we push the nodes of the next
    level into the other stack.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code puts these statements into code form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The complete application is called *BinaryTreeSpiralTraversal.* In this application,
    you can also find the implementation based on a `Deque`.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 21 – Nodes at a distance k from leafs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Amazon**, **Google**, **Microsoft**, **Flipkart**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem**: Consider you''ve been given a binary tree of integers and an integer,
    *k*. Write a snippet of code that prints all the nodes that are at a distance
    *k* from a leaf node.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: We can intuit that a distance of *k* from a leaf means *k* levels
    above the leaf. But to clarify any doubts, let''s follow the classical approach
    and try to visualize an example. The following diagram represents a binary tree;
    the highlighted nodes (40, 47, and 11) represent the nodes that are at a distance
    of *k*=2 from a leaf node:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.43 – Nodes at a distance of  k=2 from any leaf node'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.42_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.43 – Nodes at a distance of k=2 from a leaf node
  prefs: []
  type: TYPE_NORMAL
- en: 'From the preceding diagram, we can make the following observations:'
  prefs: []
  type: TYPE_NORMAL
- en: Node 40 is at a distance of 2 from leaf 44\.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Node 47 is at a distance of 2 from leaf 9 and leaf 5\.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Node 11 is at a distance of 2 from leaf 2.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we look at each level, then we can see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The nodes at distance 1 from a leaf node are 3, 11, 7, and 45.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The nodes at distance 2 from a leaf node are 11, 47, and 40.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The nodes at distance 3 from a leaf node are 40 and 47.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The node at distance 4 from a leaf node is 40 .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, the root node is the greatest distance away from a leaf, and *k* doesn't
    make sense to be greater than the number of levels; that is, 1\. If we start from
    the root and we go down the tree until we find a leaf, then the resulting path
    should contain a node that it is at a distance of *k* from that leaf.
  prefs: []
  type: TYPE_NORMAL
- en: For example, a possible path is 40 (the root), 47, 11, 7, and 2 (the leaf).
    If *k*=2, then node 11 is at a distance of 2 from the leaf. Another possible path
    is 40 (the root), 47, 11, and 5 (the leaf). If *k*=2, then node 47 is at a distance
    of 2 from the leaf. Yet another path is 40 (the root), 47, 3, and 9 (the leaf).
    If *k*=2, then node 47 is at a distance of 2 from the leaf. We already found this
    node; therefore, we now have to pay attention and remove the duplicates.
  prefs: []
  type: TYPE_NORMAL
- en: The paths that have been listed so far indicate that there's a Pre-Order traversal
    of the tree **(root | left sub-tree | right sub-tree)**. During the traversal,
    we must keep track of the current path. In other words, the constructed path is
    made up of the ancestors of the current node in the Pre-Order traversal. When
    we find a leaf node, we have to print the ancestor that is at a distance *k* from
    this leaf.
  prefs: []
  type: TYPE_NORMAL
- en: 'To eliminate duplicates, we can use a `Set` (let''s denote it as `nodesAtDist`),
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code runs in O(n) time complexity and auxiliary space O(n), where
    *n* is the number of nodes in the tree. The complete application is called *BinaryTreeDistanceFromLeaf.*
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 22 – Pair for a given sum
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Amazon**, **Google**, **Adobe**, **Microsoft**, **Flipkart**'
  prefs: []
  type: TYPE_NORMAL
- en: '`true` if there is a pair of nodes that have this sum.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: Let''s consider the BST shown in the following diagram and *sum*=74:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.44 – The pair for sum=74 contains nodes 6 and 68'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.43_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.44 – The pair for sum=74 contains nodes 6 and 68
  prefs: []
  type: TYPE_NORMAL
- en: So, for *sum*=74, we can find the pair (6, 68). If *sum*=89, then the pair is
    (43, 46). If *sum*=99, then the pair is (50, 49). The nodes that form the pair
    can be from the same sub-tree or different sub-trees and can include the root
    and leaf nodes as well.
  prefs: []
  type: TYPE_NORMAL
- en: One solution to this problem relies on *hashing* and recursion. Mainly, we traverse
    the tree using In-Order traversal (`HashSet`). Moreover, before inserting the
    current node into the set, we check whether (*the given sum - the current node's
    element*) is present in the set. If it is, then we have found a pair, so we stop
    the process and return `true`. Otherwise, we insert the current node into the
    set and continue this process until we find a pair, or the traversal is done.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for this is listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The runtime of this code is O(n) with an auxiliary space of O(n). The complete
    application is called *BinarySearchTreeSum.*
  prefs: []
  type: TYPE_NORMAL
- en: Another solution that you may like to consider and challenge yourself with starts
    from the fact that a BST, when traversed using In-Order traversal, outputs the
    nodes in sorted order. This means that if we scan the BST and store the outputs
    in an array, then the problem is exactly the same as finding the pair for the
    given sum in an array. But this solution requires two traversals of all the nodes
    and an auxiliary space of O(n).
  prefs: []
  type: TYPE_NORMAL
- en: 'Another approach starts from the BST property: *left descendants of n ≤ n <
    right descendants of n*. In other words, the minimum node in the tree is the leftmost
    node (in our case, 6) and the maximum node in the tree is the rightmost node (in
    our case, 71). Now, consider two traversals of the tree:'
  prefs: []
  type: TYPE_NORMAL
- en: A Forward In-Order traversal (the leftmost node is the first visited node)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Reverse In-Order traversal (the rightmost node is the first visited node)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let''s evaluate the (*minimum + maximum*) expression:'
  prefs: []
  type: TYPE_NORMAL
- en: If (*minimum + maximum*) < *sum*, then go to the next *minimum* (next node returned
    by the Forward In-Order traversal).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If (*minimum + maximum*) > *sum*, then go to the next *maximum* (next node returned
    by the Reverse In-Order traversal).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If (*minimum + maximum*) = *sum*, then return `true.`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The main problem here is that we need to manage these two traversals. An approach
    can rely on two stacks. In one stack, we store the outputs of the Forward In-Order
    traversal, while in another stack, we store the outputs of the Reverse In-Order
    traversal. When we reach the *minimum* (leftmost) and the *maximum* (rightmost)
    nodes, we must pop the tops of the stacks and perform an equality check against
    the given *sum*.
  prefs: []
  type: TYPE_NORMAL
- en: 'This equality check passes through one of the preceding checks (given by the
    preceding three bullets) and is interpreted as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: If (*minimum + maximum*) < *sum*, then we go to the right sub-tree of the popped
    node via the Forward In-Order traversal. This is how we can find the next greatest
    element.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If (*minimum + maximum*) > *sum*, then we go to the left sub-tree of the popped
    node via the Reverse In-Order traversal. This is how we can find the next smallest
    element.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If (*minimum + maximum*) = *sum*, then we have found a pair that validates the
    given *sum*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The algorithm is applied as long as the Forward In-Order and Reverse In-Order
    traversals do not meet. Let''s see the code for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The runtime of this code is O(n) with an auxiliary space of O(n). The complete
    application is called *BinarySearchTreeSum.*
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 23 – Vertical sums in a binary tree
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Amazon**, **Google**, **Flipkart**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem**: Consider you''ve been given a binary tree. Write a snippet of
    code that computes the vertical sums for this binary tree.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: In order to have a clear picture of this problem, it is very
    important that you sketch a meaningful diagram. It will be quite useful to use
    a notebook with squares (a math notebook). This is useful because you must draw
    the edges between the nodes at 45 degrees; otherwise, it is possible that you
    won''t see the vertical axes of the nodes correctly. Commonly, when we draw a
    binary tree, we don''t care about the angle between the nodes, but in this case,
    this is a vital aspect for understanding the problem and finding a solution to
    it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram is a sketch of the binary tree. It shows some helpful
    landmarks that will lead us to the solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.45 – Vertical sums in a binary tree'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.44_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.45 – Vertical sums in a binary tree
  prefs: []
  type: TYPE_NORMAL
- en: If we scan the tree from the left-hand side to the right-hand side, we can identify
    seven vertical axes whose sums are 5, 7, 16, 35, 54, 44, and 6\. At the top of
    the diagram, we've added the horizontal distance of each node from the root node.
    If we consider the root node as having the distance 0, then we can easily uniquely
    identify each vertical axis from the left or the right of the root by decreasing,
    respectively increasing 1 as, -3, -2, -1, 0 (the root), 1, 2, 3.
  prefs: []
  type: TYPE_NORMAL
- en: Each axis is uniquely identified by its distance from the root, and each axis
    holds the nodes that we have to sum up. If we think about the unique distance
    of an axis as a key and the sum of the nodes on this axis as a value, then we
    can intuit that this problem can be solved via *hashing* (if you are not familiar
    with the concept of hashing, then please take a look at [*Chapter 6*](B15403_06_Final_JM_ePub.xhtml#_idTextAnchor080)*,
    Object-Oriented Programming*, the *Hash table* problem). In Java, we can use hashing
    via the built-in `HashMap` implementation, so there is no need to write a hashing
    implementation from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: But how can we fill up this map? It is quite obvious that we have to traverse
    the tree while we are filling up the map. We can start from the root and add the
    key to the map as 0 (0 corresponds to the axis that contains the root) and the
    value as the root (21). Next, we can use recursion to go to the left-axis of the
    root by decreasing the distance from the root by 1\. We can also use recursion
    to go through the right-axis of the root by increasing the distance from the root
    by 1\. At every node, we update the value in the map that corresponds to the key
    that identifies the current axis. So, if we recursively follow path **root**|**left
    sub-tree**|**right sub-tree**, then we use the Pre-Order traversal of a binary
    tree.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the end, our map should contain the following key-value pairs: (-3, 5),
    (-2, 7), (-1, 16), (0, 35), (1, 54), (2, 44), and (3, 6).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Putting this algorithm into code results in the following (`map` contains the
    vertical sums):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code runs in O(n log n) time with an auxiliary space of O(n),
    where *n* is the total number of nodes of the tree. Adding to a map has an O(log
    n) complexity time and since we make an addition for each node of the tree, this
    means we get O(n log n). For an interview, the solution presented here should
    be enough. However, you can challenge yourself and decrease the complexity of
    time to O(n) by using an additional doubly linked list. Mainly, you need to store
    each vertical sum in a node of a linked list. First, add the vertical sum corresponding
    to the axis that contains the root to the linked list. Then, *node.next* and *node.prev*
    of the linked list should store the vertical sums of the axis from the left and
    the right of the root axis. Finally, rely on recursion to update the linked list
    while traversing the tree.
  prefs: []
  type: TYPE_NORMAL
- en: The complete application is called *BinaryTreeVerticalSum.*
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 23 – Converting a max heap into a min heap
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Amazon**, **Google**, **Adobe**, **Microsoft**, **Flipkart**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem**: Consider you''ve been given an array representing a Min Binary
    Heap. Write a snippet of code that converts the given Min Binary Heap into a Max
    Binary Heap in linear time and without extra space.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: The solution to this problem is inspired by the *Heap Sort* algorithm
    (this algorithm is presented in [*Chapter 14*](B15403_14_Final_JM_ePub.xhtml#_idTextAnchor340)*,
    Sorting and Searching*).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Initially, this problem may sound complicated, but after a few minutes of reflection,
    you may come to the conclusion that the problem can be reduced to building a Max
    Binary Heap from an unsorted array. So, the fact that the given array is, or isn''t,
    a Min Binary Heap is not important. We can build the required Max Binary Heap
    from any array (sorted or unsorted) by following two steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start from the rightmost, bottommost node (last internal node) of the given
    array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Heapify* all the nodes via the bottom-up technique.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The code speaks for itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The runtime of this code is O(n) with no extra space needed. The complete application
    is called *MaxHeapToMinHeap.* It also contains the conversion of a Min Binary
    Heap into a Max Binary Heap.
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 24 – Finding out whether a binary tree is symmetric
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Amazon**, **Google**, **Adobe**, **Microsoft**, **Flipkart**'
  prefs: []
  type: TYPE_NORMAL
- en: '`true` if this binary tree is symmetric (a mirror image of itself or not; the
    left sub-tree and right sub-tree are mirror images of each other).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: First, let''s take a look at a diagram containing symmetric and
    asymmetric binary trees. The binary trees labeled (a), (b), and (d) are asymmetric,
    while the binary trees labeled (c), (e), and (f) are symmetric. Notice that a
    binary tree is symmetric if both the structure and the data are symmetric:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.46 – Symmetric and asymmetric binary tree examples'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_13.45_B15403.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.46 – Symmetric and asymmetric binary tree examples
  prefs: []
  type: TYPE_NORMAL
- en: 'We can think of this problem as mirroring *root.left* and checking whether
    it is identical to *root.right*. If they are identical, then the binary tree is
    symmetric. However, we can also express the symmetry of two binary trees via three
    conditions, as follows (the easiest way to understand these conditions is to take
    each of them and pass them to the samples shown in the preceding diagram):'
  prefs: []
  type: TYPE_NORMAL
- en: The root node's elements are the same.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The left sub-tree of the left tree and the right sub-tree of the right tree
    must be mirror images.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The right sub-tree of the left tree and the left sub-tree of the right tree
    must be mirror images.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'I think that we have enough experience to recognize that these conditions can
    be implemented via recursion, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The time complexity of this code is O(n) with O(h) extra space, where *h* is
    the height of the tree. How about an iterative implementation? We can provide
    an iterative implementation via a queue. The following code is the best explanation
    for this approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The time complexity of this code is O(n) with O(h) extra space, where *h* is
    the height of the tree. The complete application is called *IsSymmetricBinaryTree.*
  prefs: []
  type: TYPE_NORMAL
- en: Coding challenge 25 – Connecting *n* ropes at the minimum cost
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Amazon**, **Google**, **Adobe**, **Microsoft**, **Flipkart**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Problem**: Consider you''ve been given an array containing the lengths of
    *n* ropes, and we need to connect all these ropes to a single rope. Consider that
    connecting two ropes has a cost equal to the sum of their lengths. Write a snippet
    of code that connects all the ropes to a single rope at the minimum cost.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solution**: Let''s consider that we have four ropes whose lengths are 1,
    3, 4, and 6\. Let''s connect the shortest two ropes first. This means we need
    to connect ropes 1 and 3, which has a cost of 1+3=4\. Continuing with the same
    logic, the next two ropes are 4 (the one we just obtained) and 4 in length. The
    cost is 4+4=8, so the total cost is 4+8=12\. We have two ropes left that are 8
    and 6 in length. The cost of connecting them is 8+6=14\. Hence, the total and
    final cost is 12+14=26.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's try another strategy. Let's connect the longest two ropes first.
    This means we need to connect ropes 4 and 6, which has a cost of 4+6=10\. Continuing
    with the same logic, the next two ropes are 10 (the one we just obtained) and
    3 in length. The cost is 10+3=13, so the total cost is 10+13=23\. We have two
    ropes left that are 13 and 1 in length. The cost of connecting them is 13+1=14\.
    Therefore, the total and final cost is 23+14=37.
  prefs: []
  type: TYPE_NORMAL
- en: Since 37>26, it is obvious that the first approach is better than the second
    one. But what's the catch? Well, in case you haven't noticed yet, the lengths
    of the ropes that are connected first occur in the rest of the connections. For
    example, when we connect ropes 1 and 3, we write 1+3=4\. So, 4 is the total cost
    so far. Next, we add 4+4=8, so the new total cost is the previous total cost +
    8, which is 4+8, but 4 was obtained from 1+3, so 1+3 occurs again. Finally, we
    connect 8+6=14\. The new total cost is the previous cost + 14, which is 12 + 14,
    but 12 was obtained from 4+8, and 4 was obtained from 1+3, so 1+3 occurs again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Analyzing the preceding statement leads us to the conclusion that we can obtain
    the minimum cost of connecting all the ropes if the repeated added rope is the
    smallest, then the second smallest, and so on. In other words, we can think of
    the algorithm for this as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Sort the ropes by their lengths in descending order.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect the first two ropes and update the partial minimum cost.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Replace the first two ropes with the resulting one.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat from *step 1* until there is a single rope left (the result of connecting
    all the ropes).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After implementing this algorithm, we should obtain the final minimum cost.
    If we try to implement this algorithm via a sorting algorithm such as Quick Sort
    or Merge Sort, then the result will perform in O(n2 log n) time. As you know from
    [*Chapter 7*](B15403_07_Final_JM_ePub.xhtml#_idTextAnchor135)*, Big O Analysis
    of Algorithms*, these sorting algorithms perform in O(n log n) time, but we have
    to sort the array each time two ropes are connected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Can we do this better? Yes, we can! At any moment, we only need the two ropes
    with the smallest lengths; we don''t care about the rest of the array. In other
    words, we need a data structure that gives us efficient access to the minimum
    element. Hence, the answer is a Min Binary Heap. Adding and removing from a Min
    Binary Heap is an O(log n) complexity time operation. The algorithm for this can
    be expressed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Create the Min Binary Heap from the array of rope lengths (O(log n)).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Poll the root of the Min Binary Heap, which will give us the smallest rope (O(log
    n)).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Poll the root again, which will give us the second smallest rope (O(log n)).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect two ropes (sum up their lengths) and put the result back into the Min
    Binary Heap.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat from *step 2* until there is a single rope left (the result of connecting
    all the ropes).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'So, the algorithm that performs in O(n log n) complexity time is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The complete application is called *HeapConnectRopes.*
  prefs: []
  type: TYPE_NORMAL
- en: Advanced topics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Right from the start, you should know that the following topics are rarely
    encountered in technical interviews. First, let me enumerate these topics as a
    non-exhaustive list:'
  prefs: []
  type: TYPE_NORMAL
- en: AVL trees (a brief description and an implementation are available in the code
    bundled with this book)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Red-Black trees (a brief description and an implementation are available in
    the code bundled with this book)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dijkstra's algorithm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rabin-Karp substring search
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Bellman-Ford algorithm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Floyd-Warshall algorithm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interval trees
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Minimum spanning trees
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: B-trees
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bipartite graph
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Graph coloring
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: P, NP, and NP-complete
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combinatory and probability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regular expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you have mastered all the problems covered in this book, then I strongly
    recommend that you continue learning by looking into the aforementioned topics.
    If you don't do this, then please consider all the problems as having a higher
    priority than these topics.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the topics outlined here may or may not be asked in interviews. They
    represent complex algorithms that you either know or you don't – the interviewer
    cannot get a true insight into your logic and thinking capabilities just because
    you are able to reproduce a famous algorithm. The interviewer wants to see that
    you are capable of exploiting your knowledge. These algorithms don't reveal your
    capability to solve a problem that you haven't seen before. It is obvious that
    you cannot intuit such complex algorithms, so your footprint is almost insignificant.
    Don't worry if you don't know these algorithms! They don't make you look smarter
    or stupider! Furthermore, since they are complex, they require a lot of time to
    implement, and, in an interview, time is limited.
  prefs: []
  type: TYPE_NORMAL
- en: However, it doesn't hurt to study more! That's a rule, so if you have the time,
    then take a look at these advanced topics as well.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This was one of the tough chapters of this book and a *must-read* for any technical
    interview. Trees and graphs are such wide, wonderful, and challenging topics that
    entire books have been dedicated to them. However, when you have to prepare for
    an interview, you don''t have the time to study tons of books and deep dive into
    every topic. This is exactly where the magic of this chapter comes into the picture:
    this chapter (just like the entire book) is totally focused on the fact that you
    must achieve your goal: ace a technical interview.'
  prefs: []
  type: TYPE_NORMAL
- en: In other words, this chapter contained the most popular tree and graph problems
    that may be encountered in technical interviews, along with meaningful figures,
    comprehensive explanations, and clear and clean code.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll tackle problems related to sorting and searching.
  prefs: []
  type: TYPE_NORMAL
