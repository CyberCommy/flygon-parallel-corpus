- en: Appendix
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: About
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This section is included to assist the students to perform the activities in
    the book. It includes detailed steps that are to be performed by the students
    to achieve the objectives of the activities.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 1 - Anatomy of Portable C++ Software
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Activity 1: Adding a New Source-Header File Pair to the Project'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this activity, we will create a new source-header file pair that contains
    a new function named `sum`. It takes two parameters and returns their sum. This
    file pair will be added to the existing project. Follow these steps to implement
    this activity:'
  prefs: []
  type: TYPE_NORMAL
- en: First, open the Eclipse IDE with the existing project that we created in *Exercise
    3*, *Adding New Source Files to CMake and Eclipse CDT*. Right-click on the `.cpp`
    and `.h` files separately or use the new class wizard and later remove the class
    code. Using the new class wizard is handy since it also creates useful boilerplate
    code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select `SumFunc` and click on the **Finish** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, edit the `SumFunc.h` file to look like the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note that we will actually delete the class and provide a single function instead.
    We could have created these two files separately. However, the `add class` function
    creates them both and adds some boilerplate code that we will make use of. Here,
    our file starts and ends with an `include` guard, which is a common strategy to
    prevent the double-inclusion problem. We have the forward declaration of our function,
    which lets other files call the function after including this header file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, edit the `SumFunc.cpp` file as illustrated here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In this file, we include header files and provide the body of our function,
    which adds and returns two given integers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `CMakeFiles.txt` file so that its `add_executable` section reflects
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Here, we added the `src/SumFunc.cpp` file to the list of executable source files
    so that it is linked into the executable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Make the following changes in `CxxTemplate.cpp`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The complete code of this file can be found here: [https://github.com/TrainingByPackt/Advanced-CPlusPlus/blob/master/Lesson1/Activity01/src/CxxTemplate.cpp](https://github.com/TrainingByPackt/Advanced-CPlusPlus/blob/master/Lesson1/Activity01/src/CxxTemplate.cpp).'
  prefs: []
  type: TYPE_NORMAL
- en: Here, we added a line in which we call the `sum` function with `3` and `4` and
    print the result to the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'Build and run the project (**Project** | **Build All** | **Run** | **Run**).
    The output you see should be as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 1.57: The output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14583_01_57.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.57: The output'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: With this activity, you practiced adding a new source-header file pair to your
    project. These file pairs are a very common pattern in C++ development. They can
    host global functions such as the ones we had in this activity. More commonly,
    they host classes and their definitions. Throughout your development effort, you
    will be adding many more source-header file pairs to your application. Therefore,
    it is important to get used to adding them and not dragging your feet, which would
    result in large monolithic files that are difficult to maintain and test.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 2: Adding a New Class and Its Test'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this activity, we will add a new class that simulates `1D` linear motion.
    The class will have double fields for `position` and `velocity`. It will also
    have a `advanceTimeBy()` method, which receives a double `dt` parameter, which
    modifies `position` based on the value of `velocity`. Use `EXPECT_DOUBLE_EQ` instead
    of `EXPECT_EQ` for double values. In this activity, we will add a new class and
    its test to the project. Follow these steps to perform this activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the Eclipse IDE with our existing project. To create a new class, right-click
    the `LinearMotion1D` as the name and create the class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the `LinearMotion1D.h` file that we created in the previous step. Add
    the `position` and `velocity` `double` fields into it. Also, add the forward reference
    to the `advanceTimeBy` method, which takes a `double dt` variable as a parameter.
    The constructors and destructors were already in the class. The following is the
    end result of these changes in `LinearMotion1D.h`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now open `LinearMotion1D.cpp` and add the implementation for the `advanceTimeBy`
    method. Our `velocity` is a field in our class and the time difference is a parameter
    to this method. A change in `position` is equal to the `velocity` multiplied by
    the time change, so we calculate the result and add it to the `position` variable.
    We also use the existing constructor code to initialize `position` and `velocity`
    to 0\. The following is the end result of these changes in `LinearMotion1D.cpp`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Create a test for this class. Right-click the `LinearMotion1DTest.cpp` as the
    name and create it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now open `LinearMotion1DTest.cpp`. Create two tests for motions in two different
    directions, left and right. For each of them, create a `LinearMotion1D` object,
    initialize its position and velocity, and call `advanceTimeBy` to actually have
    the motion happen. Then, check whether it moved to the same location that we expected.
    The following is the end result of these changes in `LinearMotion1DTest.cpp`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now modify our CMake configuration files so that these source files that we
    generated are also used. For the `LinearMotion1D` class, add its `.cpp` file as
    an executable so that it is compiled and linked together with the other source
    files. Here is what the `add_executable` section of `CMakeLists.txt` becomes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'For the tests that we just created, edit `LinearMotion1DTest.cpp`, and the
    source file of the class that it uses, `LinearMotion1D.cpp`. Since they are in
    different directories, access them as `../src/LinearMotion1D.cpp`. Here is what
    the `add_executable` section of `tests/CMakeLists.txt` becomes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Build the project and run the tests. We will see that all the tests are successful:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 1.58: All tests are successful'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14583_01_58.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.58: All tests are successful'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: With this activity, you performed the task of adding a new class and its test
    to the project. You created a class that simulates one-dimensional motion and
    you wrote unit tests to ensure that it is working properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 3: Making Code More Readable'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this activity, you will practice improving the quality of a given code.
    Follow these steps to implement this activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Eclipse CDT and create a class in a source-header file pair in Eclipse.
    To do this, right-click the **src** folder in **Project Explorer**. Select **New**
    | **Class** from the pop-up menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Type `SpeedCalculator` as the header filename and click **Finish**. It will
    create two files: **SpeedCalculator.h** and **SpeedCalculator.cpp**. We provided
    the code for both files above. Add the code that was provided for each file.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now we need to add the class to the CMake project. Open the **CMakeLists.txt**
    file in the root of your project (outside the **src** folder) and make the following
    change in the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Now select **File** | **Save All** to save all the files and build the project
    by selecting **Project** | **Build All**. Make sure there are no errors.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create an instance of the `SpeedCalculator` class in our `main()` function
    and call its `run()` method. Open `main` function by adding the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: To fix the style, simply use **Source** | **Format** and choose to format the
    entire file. Luckily, the variable names do not have any problems.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Simplify the code to make it more understandable. The loop in `calculateAndPrintSpeedData`
    is doing a couple of things at the same time. It''s calculating the speed, finding
    the minimum and maximum values of it, checking whether we crossed a threshold,
    and storing the speed. If the speed was a transient value, taking it apart would
    mean storing it somewhere to loop on it one more time. However, since we are storing
    it in the speeds array anyway, we can loop one more time on it for clarity of
    code. Here is the updated version of the loop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This is somewhat a matter of taste, but making the big `for` loop lighter helps
    with the readability. In addition, it separates the tasks and removes the possibility
    of them interacting with each other during a loop iteration. The first loop creates
    and saves the speed values. The second loop finds the minimum and maximum speed
    values. The third loop determines how long the speed limit was crossed for. Note
    that this is a slightly less efficient implementation; however, it clearly separates
    the actions taken and we do not have to mentally separate the discrete actions
    in the long iteration of a loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the preceding code and observe the problem at runtime. While the code is
    better in terms of style now, it suffers from several mistakes, some of which
    will create runtime errors. First, when we run the application, we see the following
    output in Eclipse:![Figure 1.59: Program output in Eclipse CDT'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14583_01_59.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.59: Program output in Eclipse CDT'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note `0`, it means there was a problem with our code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the program manually in the console. Here''s the output we get:![Figure
    1.60: Program output in the terminal with the error'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14583_01_60.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.60: Program output in the terminal with the error'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Unfortunately, we do not get the segmentation fault error output in Eclipse,
    therefore you have to check the exit value in the Eclipse console view. To find
    the problem, we will use the debugger in the next step.
  prefs: []
  type: TYPE_NORMAL
- en: 'Press the debug toolbar button in Eclipse to start the application in debug
    mode. Press the resume button to continue execution. It will stop at line 40 of
    `SpeedCalculator.cpp`, right when an error is about to happen. If you hover over
    `speeds`, you realize that it is an invalid memory reference:![Figure 1.61: Invalid
    memory reference'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14583_01_61.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.61: Invalid memory reference'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Upon further examination, we realize that we never initialized the `speeds`
    pointer to anything. Allocate memory for it in our speed calculator function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Run it again. We get the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Note that this was an assertion that the code had to make sure that the calculated
    `dt` was always larger than zero. This is something that we are sure of, and we
    would like it to help us catch errors during development. Assert statements are
    ignored in the production builds, so you can place them liberally in your code
    as safeguards to catch errors during development. Especially since C++ lacks many
    safety checks compared to higher-level languages, placing `assert` statements
    in potentially unsafe code helps catch errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s investigate why our `dt` ended up not larger than zero. For this, we
    fire up the debugger again. It stops at this strange place:![Figure 1.62: Debugger
    stopped at a library without source code'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14583_01_62.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.62: Debugger stopped at a library without source code'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The actual error is raised deep inside a library. However, our own functions
    are still on the stack and we can investigate their state at that time. Click
    on `dt` becomes `i` is `timesInSeconds[10]`, which is the non-existent eleventh
    element of the array. Thinking further, we realize that we can only have 9 position-pair
    subtractions, thus 9 speeds, when we have 10 positions. This is a very common
    and hard-to-catch mistake as C++ does not enforce you to stay within the array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Rework our whole code for this problem:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, our code seems to run without any errors as we can see in the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.65: Program output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14583_01_65.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.65: Program output'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'However, there is a curious point here: `0`, no matter how many times you run
    it. To investigate, let''s put a breakpoint at the following line:![Figure 1.66:
    Placing a breakpoint'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14583_01_66.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.66: Placing a breakpoint'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'When we debug our code, we see that it never stops here. This is obviously
    wrong. Upon further investigation, we realize that `minSpeed` is initially 0,
    and every other speed value is larger than that. We should initialize it to either
    something very large, or we need to get the very first element as the minimum
    value. Here, we choose the second approach:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'While `maxSpeed` did not need this, it''s good to be consistent. Now when we
    run the code, we see that we do not get `0` as our minimum speed anymore:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.67: Program output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14583_01_67.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.67: Program output'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Our code seems to be running fine. However, there is another mistake that we
    have made. When we debug our code, we see that our first elements are not zero:![Figure
    1.68: Values of variables'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14583_01_68.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.68: Values of variables'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The pointer dereferenced the first element in the array. We had initialized
    elements to zero here, but they do not seem to be zero. Here is the updated code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'When we investigate, we realize that we start the loop at zero and overwrite
    the first items. Furthermore, we try to access `positions[0 - 1]`, which is a
    mistake and another example of C++ not enforcing array boundaries. When we let
    the loop start from 1, all these problems are gone:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output generated with the updated code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.69: Program output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14583_01_69.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.69: Program output'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Just by looking at this code, we cannot tell the difference. It's all random
    values that do not look very different than before. Such bugs are very hard to
    find and can cause random behavior, leaving us with hard-to-track errors. Things
    that you can do to avoid such errors include being extra careful when dereferencing
    pointers, especially in loops; separating code into functions and writing unit
    tests for them; and using `assert` statements liberally to enforce things that
    the compiler or the runtime does not.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 2A - No Ducks Allowed – Types and Deduction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Activity 1: Graphics Processing'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this activity, we will implement two classes (`Point3d` and `Matrix3d`),
    along with the multiplication operators so that we can translate, scale, and rotate
    points. We will also implement some helper methods that create the necessary matrices
    for the transformations. Follow these steps to implement this activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Load the prepared project from the `CMake Build (Portable)`. Build and configure
    the launcher and run the unit tests (which fail). Recommend that the name that's
    used for the test runner is `L2AA1graphicstests`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: CMake Configuration
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Follow *step 9* of *Exercise 1*, *Declaring Variables and Exploring Sizes*,
    to configure the project as a CMake project.
  prefs: []
  type: TYPE_NORMAL
- en: Add a test for the `Point3d` class to verify that the default constructor creates
    an `origin point [0, 0, 0, 1]`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the **point3dTests.cpp** file and add the following line at the top.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Replace the failing existing test with the following test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This test requires us to write an access operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Replace the current class definition in **point3d.hpp** file with the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The test now builds and runs but fails.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the declaration for the default constructor to the `Point3d` declaration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the implementation to the **point3d.cpp** file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The test now builds, runs, and passes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the next test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This test fails to compile. Therefore, we need to implement another constructor
    – the one that takes `std::initializer_list<>` as an argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following include to the header file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following constructor declaration to the Point3d class in the header
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code to the implementation file. This code ignores error
    handling, which will be added in *Lesson 3*, *The Distance Between Can and Should
    – Objects, Pointers, and Inheritance*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The tests should now build, run, and pass.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The tests should still build, run, and pass.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is now time to refactor the test cases by moving the verification loop into
    a templated function in the `Point3dTest` class. Add the following template inside
    this class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This now means that the last test can be rewritten as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: It is just as important to keep your tests readable in the same way as your
    production code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, add support for the equality and inequality operators through the following
    tests:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'To implement these, add the following declarations/definition in the header
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, add the equality implementation in the .cpp file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'When we first added `Point3d`, we implemented a constant accessor. Add the
    following test, where we need a non-constant accessor so that we can assign it
    to the member:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'To get this test to build, add the following accessor to the header:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Note that it returns a reference. Thus, we can assign it to a member value.
  prefs: []
  type: TYPE_NORMAL
- en: 'To finish off `Point3d`, add lines to the class declaration for the default
    copy constructor and copy assignment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Now, add the `Matrix3d` classes. First, create two empty files, `matrix3d.hpp`
    and `matrix3d.cpp`, in the top-level folder of the current project and then add
    an empty file in the tests folder called `matrix3dTests.cpp`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the CmakeLists.txt file in the top folder and add **matrix3d.cpp** to
    the following line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the `../matrix3d.cpp` to the definition of `SRC_FILES`, and add `TEST_FILES`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The existing `point3d` tests should still build, run, and pass if you made those
    changes correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following test plumbing to `matrix3dTests.cpp`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Build and run the tests. The test that we just added should fail.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Replace DummyTest with the following test in `Matrix3d` class. We will do this
    now in **matrix3d.hpp**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following definition to **matrix3d.hpp**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The tests will now build but still fail because we haven't created a default
    constructor that creates an identity matrix.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the declaration of the default constructor to the header file in the public
    section of `Matrix3d`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Add this definition to **matrix3d.cpp**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The tests now build and pass.
  prefs: []
  type: TYPE_NORMAL
- en: 'Refactor the code slightly to make it more readable. Modify the header to read
    like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the **matrix3d.cpp** file to use the constants:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Rebuild the tests and make sure that they still pass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, we need to add the initializer list constructor. To do that, add the following
    test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the include file for the initializer list support and declare the constructor
    in **matrix3d.hpp**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, add the implementation of the constructor to the .cpp file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'To improve the readability of our tests, add a helper method to the test framework.
    In the `Matrix3dTest` class, declare the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the definition of the helper method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Write a test to multiply two matrices and get a new matrix (expected will be
    calculated by hand):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'In the header file, define `operator*=`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, implement the inline version of `operator*` (outside the class declaration):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'And the implementation to the **matrix3d.cpp** file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Build and run the tests – again, they should pass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Introduce a second helper function to the test class by declaring it in the
    `Matrix3dTest` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, declare it so that we can use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the one test to use it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Write one sanity check test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Build and run the tests – they should still pass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, we need to be able to multiply points and matrices. Add the following
    test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'In `Matrix3d` class declaration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the definition of the operator to the **matrix3d.cpp** file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Build and run the tests. They should all be passing again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the top of **matrix3dtests.cpp**, add the include file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Start adding the transformation matrix factory methods. Using the following
    tests, we will develop the various factory methods (the tests should be added
    one at a time):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following declarations to the matrix3d header file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: At the top of the matrix3d implementation file, add `#include <cmath>`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, add the following implementations to the `matrix3d` implementation
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'To get this to compile and pass the test, we need to add one more accessor
    to the declaration of `matrix3d`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Build and run all the tests again to show that they all pass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `point3d.hpp`, add the include for `<ostream>` and add the following friend
    declaration to the Point3d class at the end:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Write the inline implementation of the operator after the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the **main.cpp** file and remove the comment delimiters, //, from the
    line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Build and run the application called `graphics` – you will need to create a
    new Run Configuration. If your implementations of `Point3d` and `Matrix3d` are
    correct, then the program will display the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/C14583_02A_53.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2A.53: Successfully running the activity program'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In this activity, we implemented two classes that form the basis of all the
    operations that are required to implement 3D graphics rendering. We used operator
    overloading to achieve this so that Matrix3d and Point3d can be used as if they
    were native types. This can be easily extended to deal with vectors of points,
    which is required if we wish to manipulate whole objects.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter – 2B - No Ducks Allowed – Templates and Deduction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Activity 1: Developing a Generic "contains" Template Function'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this activity, we will implement several helper classes that will be used
    to detect the `std::string` class case and the `std::set` case and then use them
    to tailor the contains function to the particular container. Follow these steps
    to implement this activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Load the prepared project from the `L2BA1tests`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the **containsTests.cpp** file and replace the existing test with the
    following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: This test requires us to write a set of helper templates to detect if the container
    class supports a static member variable called npos.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to the **contains.hpp** file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: The tests now run and pass.
  prefs: []
  type: TYPE_NORMAL
- en: Add the following tests to the `find()` method that takes one argument.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code to the **contains.hpp** file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: The tests now run and pass.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the implementation for the generic container; in this case, the vector.
    Write the following tests in the **containsTest.cpp** file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the basic implementation of `contains` to the **contains.hpp** file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: The tests now run and pass.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to add the tests for the `set` special case to **containsTest.cpp**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'The implementation of `contains` is updated to test for the built-in `set::find()`
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: The tests now run and pass.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the tests for the `string` special case to the **containsTest.cpp** file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following implementation of `contains` to test for the presence of
    `npos` and tailor the use of the `find()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: The tests now run and pass.
  prefs: []
  type: TYPE_NORMAL
- en: 'Build and run the application called `contains`. Create a new Run Configuration.
    If your implementation of the contains template is correct, then the program will
    display the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2B.36: Output from the successful implementation of contains'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14583_02B_36.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2B.36: Output from the successful implementation of contains'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In this activity, we used various templating techniques in conjunction with
    SFINAE to select the appropriate implementation of a `contains()` function based
    upon the capability of the containing class. We could have achieved the same result
    using a generic template function and some specialized templates, but we took
    the path less travelled and flexed our newly found template skills.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 3 - The Distance between Can and Should – Objects, Pointers and Inheritance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Activity 1: Implementing Graphics Processing with RAII and Move'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this activity, we will develop our previous `Matrix3d` and `Point3d` classes
    to use a `unique_ptr<>` to manage the memory associated with the data structures
    that are required to implement these graphics classes. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Load the prepared project from the **Lesson3/Activity01** folder and configure
    the Current Builder for the project to be **CMake Build (Portable)**. Build and
    configure the launcher and run the unit tests. We recommend that the name that's
    used for the tests runner is **L3A1graphicstests**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open `acpp::gfx`, is a new feature of C++17\. Previously, it would have required
    the explicit use of the `namespace` keyword twice. Also, beware that, in trying
    to be helpful, your friendly neighborhood IDE may insert the closing brace just
    after the line that you put the namespace declaration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat the same treatment for **matrix3d.hpp**, **matrix3d.cpp**, and **point3d.cpp**
    – ensure that the include files are not included in the scope of the namespace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the respective files (**main.cpp**, **matrix3dTests.cpp**, and **point3dTests.cpp**),
    just after completing the #include directives, insert the following line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Now, run all the tests. All **18** existing tests should pass again. We have
    successfully put our classes into a namespace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we will move onto converting the `Matrix3d` class to use heap allocated
    memory. In the `#include <memory>` line to give us access to the `unique_ptr<>`
    template.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, change the type of the declaration for `m_data`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: From this point forward, we will use the compiler and its errors to give us
    hints as to what needs fixing. Attempting to build the tests now reveals that
    we have a problem with the following two methods in the header file
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: The problem here is that `unique_ptr` holds a pointer to a single dimension
    array and not a two- dimensional array. So, we need to convert the row and column
    into a single index.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new method called `get_index()` to get the one-dimensional index from
    the row and column and update the preceding functions to use it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'After recompiling, the next error from the compiler refers to the following
    inline function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Whereas before, the default copy constructor was sufficient for our purposes,
    it just did a shallow copy of all the elements of the array and that was correct.
    We now have indirection to the data we need to copy and so we need to implement
    a deep copy constructor and copy assignment. We will also need to address the
    existing constructors. For now, just add the constructor declarations to the class
    (adjacent to the other constructors):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Attempting to build the tests will now show that we have resolved all the issues
    in the header file, and that we can move onto the implementation file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the two constructors to initialize `unique_ptr` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'We now need to address the single-dimensional array look-up. We need to change
    the statements of the `m_data[i][j]` type with `m_data[get_index(i,j)]`. Change
    the default constructor to read like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Change the initializer list constructor to be the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Change the multiplication operator, being careful with the indices:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: With these changes in place, we have fixed all the compiler errors, but now
    we have a linker error to deal with – the copy constructor that we only declared
    back in step 11.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the **matrix3d.cpp** file add the following definitions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'The tests will now build and all of them will pass. The next step is to force
    a move constructor. Locate the `createTranslationMatrix()` method in **matrix3d.cpp**
    and change the return statement as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: In `move` constructor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: Rebuild the tests. Now, we get an error related to the move constructor not
    being present.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the implementation of the constructor into **matrix3d.cpp** and rebuild
    the tests.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Rebuild and run the tests. They all pass again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Just to confirm that the move constructor is being called, add `#include <iostream>`
    to `cerr`). After the check, make the line a comment again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Just a quick note about the move constructor – we did not explicitly initialize
    `m_data` like we did for the other constructors. This means that it will be initialized
    as empty and then swapped with the parameter that is passed in, which is a temporary
    and so it is acceptable for it to not hold an array after the transaction – it
    removes one allocation and deallocation of memory.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's convert the `Point3d` class so that it can use heap allocated memory.
    In the `#include <memory>` line so that we have access to the `unique_ptr<>` template.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, change the type of the declaration for `m_data` to be like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'The compiler now tells us that we have a problem with the insertion operator
    (<<) in `unique_ptr`: Replace the implementation with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Open `unique_ptr` and change the initialization loop since a ranged for cannot
    be used on the `unique_ptr`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Modify the other constructor by initializing the `unique_ptr`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: Now all the tests run and pass, like they did previously.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, if we run the original application, **L3graphics**, then the output will
    be identical to the original, but the implementation uses RAII to allocate and
    manage the memory that's used for the matrices and points.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/C14583_03_52.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.52: Activity 1 output after successful conversion to use RAII'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Activity 2: Implementing classes for Date Calculations'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this activity, we will implement two classes, `Date` and `Days` that will
    make it very easy for us to work with dates and the time differences between them.
    Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Load the prepared project from the **Lesson3/Activity02** folder and configure
    the Current Builder for the project to be **CMake Build (Portable)**. Build and
    configure the launcher and run the unit tests. We recommend that the name that's
    used for the tests runner is **L3A2datetests**. The project has dummy files and
    one failing test.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the `Date` class to allow access to the stored values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the `DateTest` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: Normally, you would refactor this test as the tests develop, but we will pull
    it out up front.
  prefs: []
  type: TYPE_NORMAL
- en: 'Replace `ASSERT_FALSE()` in the existing test with the following test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: Rebuild and run the tests – they should now all pass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'To make this test we need to add the following two constructors to the `Date`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'We now need to introduce the functions to convert to/from the `date_t` type.
    Add the following alias to the **date.hpp** file inside our namespace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'To the `Date` class, add the declaration of the following method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, add the following test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: As we are doing (`TDD`), we add the minimal implementation of the method to
    pass the test.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we add the next test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'We continue to add one more test and then another, all the time refining the
    algorithm in `ToDateT()` firstly to deal with dates in `1970`, then `1-Jan-1971`,
    and then a date in `1973`, which means we span one leap year, and so on. The full
    set of tests that are used to develop the `ToDateT()` method are as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'To pass all of these tests, we add the following items to the declaration of
    the `Date` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'The implementation of `ToDateT()` and the supporting methods in **date.cpp**
    is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that `ToDateT()` is working, we turn to its inverse, that is, `FromDateT()`.
    Again, we build up the tests one at a time to develop the algorithm over a range
    of dates. The following tests were used:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following declarations to the header file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the following implementation since the preceding tests are added one at
    a time:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have the supporting routines ready, we can implement the real feature
    of the `Date` class difference between two dates and determine the new date by
    adding a number of days. Both of these operations need a new type (class) `Days`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following implementation of `Days` to the header (above `Date`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'The first operator will be an addition of `Days` to `Date`. Add the following
    method declaration (inside the public section of the `Date` class) :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, add the inline implementation (outside the `Date` class) to the header
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'Write the following tests to verify the `sum` operation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: The actual implementation of the `sum` operation is simply based on the two
    support methods
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run the tests, they all build and this test passes. But this is not
    the desired outcome. We do not want them to be able to add naked integers to our
    dates. (A future version may add months and years, so what does adding an integer
    mean?). To make this fail by causing the build to fail, we change the Days constructor
    to be `explicit`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the build fails, so we need to fix the test by changing the addition line
    to cast to `Days` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: All tests should pass again.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final functionality we want is the difference between two dates. Here are
    the tests that were used to verify the implementation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following declaration of the function to the public section of the
    `Date` class in the header file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following code after the Date class in the header file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: Because we made the `Days` constructor explicit, we must call it in the return
    statement. With all these changes in place, all the tests should pass.
  prefs: []
  type: TYPE_NORMAL
- en: 'Configure `L3A2date` as a `datetools` binary and open main.cpp in the editor.
    Remove the comment from the definition of `ACTIVITY2`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'Build and then run the sample application. This will produce the following
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.53: Output of successful Date sample application'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14583_03_53.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.53: Output of successful Date sample application'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We have implemented all of the requirements of the Date and Days classes and
    delivered them all with unit tests. The unit tests allowed us to implement incremental
    functionality to build up the two complicated algorithms, `ToDateT` and `FromDateT`
    which form the underlying support for the functionality that we wanted to deliver.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 4 - Separation of Concerns - Software Architecture, Functions, Variadic
    Templates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Activity 1: Implement a multicast event handler'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Load the prepared project from the **Lesson4/Activity01** folder and configure
    the Current Builder for the project to be CMake Build (Portable). Build the project,
    configure the launcher and run the unit tests (which fail the one dummy test).
    Recommend that the name used for the tests runner is *L4delegateTests*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In **delegateTests.cpp**, replace the failing dummy test with the following
    test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'This now fails to build, so we need to add a new method to `Delegate`. As this
    will evolve into a template, we will do all of this development in the header
    file. In **delegate.hpp**, and the following definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: The test now runs and passes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following line to the existing test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, the build fails, so we update the `Delegate` definition as follows (we
    could have had Notify call `operator()`, but this is easier to read):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: The test again runs and passes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we add the next test, we are going to add some infrastructure to help
    us develop our tests. The easiest thing to do with handlers is have them write
    to `std::cout`, and to be able to verify that they were called, we need to capture
    the output. To do this, re-route the standard output stream to a different buffer
    by changing the `DelegateTest` class as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: Also add the include statements for `<iostream>`, `<sstream>` and `<string>`
    to the top of the file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With this support framework in place, add the following test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'To make the tests build and run again, add the following code in the **delegate.h**
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: 'Along with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: The tests now build, but our new test fails.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `Notify()` method to be:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: 'The tests now build and our new test passes, but the original test now fails.
    The call to the delegate is throwing an exception, so we need to check that the
    delegate is not empty before calling it. Write the following code to do this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: All the tests now run and pass.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now need to add multicast support to the `Delegate` class. Add the new test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, this test now fails because the `operator+=()` only assigns to the
    member variable. We need to add a list to store our delegates. We choose vector
    so we can add to the end of the list as we want to call the delegates in the order
    that they are added. Add `#include <vector>` to the top of **delegate.hpp** and
    update Delegate replace **m_delegate** with **m_delegates** vector of the callbacks:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: The tests all run and pass again.
  prefs: []
  type: TYPE_NORMAL
- en: We now have the basic multicast `delegate` class implemented. We now need to
    convert it to a template- based class. Update the existing tests, by changing
    all of the declarations of `Delegate` to `Delegate<int>` in the three tests.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now update the Delegate class by adding `template<class Arg>` before the class
    to convert it to a template, and substituting the four occurrences of `int` with
    `Arg`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: All the tests now run and pass as previously, so it stills works for `int` arguments
    for the handlers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following test and re-run the tests to confirm that the template conversion
    is correct:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: 'Now it operates as a template that takes one argument. We need to convert it
    into a variadic template that takes zero or more arguments. Using the information
    from the last topic, update the template to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: The tests should still run and pass.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add two more tests – zero argument test, and a mutliple argument test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: All the tests run and pass showing that we have now implemented the desired
    `Delegate` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, change the Run configuration to execute the program `L4delegate`. Open
    the **main.cpp** file in the editor and change the definition at the top of the
    file to the following and run the program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.35: Output from the successful implementation of Delegate'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14583_04_35.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.35: Output from the successful implementation of Delegate'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In this activity, we started by implementing a class that provides the basic
    single delegate functionality and then added multicast capability. With that implemented,
    and unit tests in place, we were quickly able to convert to a template with one
    argument and then to a variadic template version. Depending on the functionality
    that you are developing, the approach of the specific implementation transitioning
    to a general form and then to an even more general form is the correct one. Development
    of variadic templates is not always obvious.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 5 - The Philosophers' Dinner – Threads and Concurrency
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Activity 1: Creating a Simulator to Model the Work of the Art Gallery'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Art Gallery work simulator is an application that simulates how the visitors
    and the watchman behave. There is a quantity limit for visitors, that is, only
    50 people can be inside the gallery simultaneously. Visitors constantly come to
    the gallery. The watchman checks if the limit of visitors has been exceeded. If
    so, it asks new visitors to wait and puts them on a waiting list. If not, it allows
    them to enter the gallery. Visitors can leave the gallery at any time. If somebody
    leaves the gallery, the watchman lets somebody from the waiting list enter the
    gallery.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to implement this activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a file that will contain all the constants that we need for this project
    – `Common.hpp`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the include guards and the first variable, `CountPeopleInside`, which represents
    that the limit for visitors is 50 people:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, create a header and the source files for the `Person` class, that is,
    `Person.hpp` and `Person.cpp`. Also, add the include guards. Define the `Person`
    class and delete the copy constructor and copy assignment operator; we will only
    use the user-defined default constructor, move constructor, and move assignment
    operator and default destructor. Add a private variable called `m_Id`; we will
    use it for logging. Also, add a private static variable called `m_NextId`; it
    will be used for generating unique IDs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: 'In the source file, define our static variable, `m_NextId`. Then, in the constructor,
    initialize the `m_Id` variable with the value of `m_NextId`. Print the log in
    the constructor. Implement the move copy constructor and the move assignment operator.
    Now, implement thread-safe storage for our `Person` objects. Create the required
    header and source files, that is, `Persons.hpp` and `Persons.cpp`. Also, add the
    include guards. Include "`Person.hpp`" and the `<mutex>` and `<vector>` headers.
    Define the `Persons` class with a user-defined default constructor and default
    destructor. Declare the `add()` function for adding the Person and `get()` for
    getting the Person and removing it from the list. Define the `size()` function
    to get the count of Person elements, as well as `removePerson()`, which removes
    any person from the storage. In the private section, declare a variable of the
    mutex type, namely `m_Mutex`, and the vector to store Persons, namely `m_Persons`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: 'In the source file, declare the user-defined constructor where we reserve the
    size of the vector to be 50 elements (to avoid resizing during growth):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare the `add()` function, which takes an rvalue parameter of the `Person`
    type, locks the mutex, and adds `Person` to the vector using the `std::move()`
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare the `get()` function, which locks the mutex and returns the last element
    and then removes it from the vector. If the vector is empty, it will throw an
    exception:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare the `size()` function, which returns the size of the vector:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, declare the `removePerson()` function, which locks the mutex and removes
    the last item from the vector:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, implement the PersonGenerator class, which is responsible for creating
    and removing Person items. Create the respective header and source files, that
    is, `PersonGenerator.hpp` and `PersonGenerator.cpp`. Also, add the include guards.
    Include the "`Person.hpp`", `<thread>`, and `<condition_variable>` headers. Define
    the `PersonGenerator` class. In the private section, define two `std::thread`
    variables, namely `m_CreateThread` and `m_RemoveThread`. In one thread, we will
    create new `Person` objects and will notify the user about removing `Person` objects
    in the other thread asynchronously. Define a reference to a shared variable of
    the `Persons` type, namely `m_CreatedPersons`. We will place every new person
    in it. `m_CreatedPersons` will be shared between several threads. Define two references
    to `std::condition_variable`, namely `m_CondVarAddPerson` and `m_CondVarRemovePerson`.
    They will be used for communication between threads. Define two references to
    the `std::mutex` variables, namely `m_AddLock` and `m_RemoveLock`. They will be
    used for receiving access to condition variables. Finally, define two references
    to a `bool` value, namely `m_AddNotified` and `m_RemoveNotified`. They will be
    used for checking whether the notification is true or false. Also, in the private
    section, define two functions that will be start functions for our threads – `runCreating()`
    and `runRemoving()`. Next, define two functions that will trigger condition variables,
    namely `notifyCreated()` and `notifyRemoved()`. In the public section, define
    a constructor that takes all the references that we defined in the private section
    as a parameter. Finally, define a destructor. This will ensure that the other
    default generated functions are deleted:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, move on to the source file. Include the `<stdlib.h>` file so that we can
    access the `srand()` and `rand()` functions, which are used for random number
    generation. Include the `<time.h>` header so that we can access the `time()` function,
    as well as the `std::chrono` namespace. They are used for when we work with time.
    Include the `<ratio>` file, which used for typedefs so that we can work with the
    time library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare the constructor and initialize all the parameters except the threads
    in the initializer list. Initialize the threads with the appropriate functions
    in the constructor body:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a destructor and check if the threads are joinable. Join them if not:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare the `runCreating()` function, which is the start function for the `m_CreateThread`
    thread. In this function, in an infinite loop, we will generate a random number
    from 1 to 10 and make the current thread sleep for this time. After this, create
    a Person value, add it to the shared container, and notify other threads about
    it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare the `runRemoving()` function, which is the start function for the `m_RemoveThread`
    thread. In this function, in an infinite loop, we will generate a random number
    from 20 to 30 and make the current thread sleep for this time. After this, notify
    the other threads that some of the visitors should be removed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare the `notifyCreated()` and `notifyRemoved()` functions. In their bodies,
    lock the appropriate mutex, set the appropriate bool variable to true, and call
    the `notify_all()` functions on the appropriate condition variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to create the files for our last class, Watchman, namely `Watchman.hpp`
    and `Watchman.cpp`. As usual, add the include guards. Include the "`Persons.hpp`",
    `<thread>`, <mutex>, and `<condition_variable>` headers. Define the `Watchman`
    class. In the private section, define two `std::thread` variables, namely `m_ThreadAdd`
    and `m_ThreadRemove`. In one of the threads, we will move new `Person` objects
    to the appropriate queue and will remove `Person` objects in the other thread
    asynchronously. Define the references to the shared `Persons` variables, namely
    `m_CreatedPeople`, `m_PeopleInside`, and `m_PeopleInQueue`. We will take every
    new person from the `m_CreatedPeople` list and move them to the `m_PeopleInside`
    list if the limit is not exceeded. We will move them to the `m_PeopleInQueue`
    list otherwise. They will be shared between several threads. Define two references
    to `std::condition_variable`, namely `m_CondVarAddPerson` and `m_CondVarRemovePerson`.
    They will be used for communication between threads. Define two references to
    the `std::mutex` variables, namely `m_AddMux` and `m_RemoveMux`. They will be
    used for receiving access to condition variables. Finally, define two references
    to a `bool` value, namely `m_AddNotified` and `m_RemoveNotified`. They will be
    used for checking if the notification is true or false. Also, in the private section,
    define two functions that will be start functions for our threads – `runAdd()`
    and `runRemove()`. In the public section, define a constructor that takes all
    the references that we defined in the private section as parameters. Now, define
    a destructor. Make sure that all the other default generated functions are deleted:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, move on to the source file. Include the "`Common.hpp`" header so that
    we can access the `m_CountPeopleInside` variable and the other necessary headers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare the constructor and initialize all the parameters except for the threads
    in the initializer list. Initialize the threads with the appropriate functions
    in the constructor''s body:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a destructor and check if the threads are joinable. Join them if not:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare the `runAdd()` function. Here, we create an infinite loop. In the loop,
    we are waiting for a condition variable. When the condition variable notifies,
    we take people from the `m_CreatedPeople` list and move them to the appropriate
    list, that is, `m_PeopleInside`, or `m_PeopleInQueue` if the limit has been exceeded.
    Then, we check if there are any people in the `m_PeopleInQueue` list and if `m_PeopleInside`
    is not full, we move them into this list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, declare the `runRemove()` function, where we will remove visitors from
    `m_PeopleInside`. Here, also in the infinite loop, we are waiting for the `m_CondVarRemovePerson`
    condition variable. When it notifies the thread, we remove people from the list
    of visitors. Next, we will check if there''s anybody in the `m_PeopleInQueue`
    list and if the limit is not exceeded, we add them to `m_PeopleInside`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, move to the `main()` function. First, create all the shared variables
    that we used in the `Watchman` and `PersonGenerator` classes. Next, create the
    `Watchman` and `PersonGenerator` variables and pass those shared variables to
    the constructors. At the end of the main function read the character to avoid
    closing the application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile and run the application. In the terminal, you will see logs from different
    threads about creating and moving people from one list to another. Your output
    will be similar to the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.27: The result of the application''s execution'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14583_05_27.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.27: The result of the application''s execution'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As you can see, all the threads communicate with each other in a very easy and
    clean way. We protected our shared data by using mutexes so that we can avoid
    race conditions. Here, we used an exception to warn about the empty lists and
    caught them in the thread's functions so that our threads handle exceptions on
    their own. We also checked if the thread is joinable before joining it in the
    destructor. This allowed us to avoid the unexpected termination of the program.
    Thus, this small project demonstrates our skills when it comes to working with
    threads.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 6 – Streams and I/O
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Activity 1 The Logging System for The Art Gallery Simulator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The thread-safe logger allows us to output data to the Terminal simultaneously.
    We implement this logger by inheriting from the `std::ostringstream` class and
    using a mutex for synchronization. We will implement a class that provides an
    interface for the formatted output and our logger will use it to extend the basic
    output. We define macro definitions for different logging levels to provide an
    interface that will be easy and clear to use. Follow these steps to complete this
    activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the project from Lesson6\.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new directory called logger inside the **src/** directory. You will
    get the following hierarchy:![Figure 6.25: The hierarchy of the project'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14583_06_25.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.25: The hierarchy of the project'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Create a header and source file called `LoggerUtils`. In `LoggerUtils.hpp`,
    add include guards. Include the <string> header to add support for working with
    strings. Define a namespace called logger and then define a nesting namespace
    called `utils`. In the `utils` namespace, declare the `LoggerUtils` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the public section, declare the following static functions: `getDateTime`,
    `getThreadId`, `getLoggingLevel`, `getFileAndLine`, `getFuncName`, `getInFuncName`,
    and `getOutFuncName`. Your class should look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: 'In `LoggerUtils.cpp`, add the required includes: the "`LoggerUtils.hpp`" header,
    `<sstream>` for `std::stringstream` support, and `<ctime>` for date and time support:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: 'Enter the `logger` and `utils` namespaces. Write the required function definitions.
    In the `getDateTime()` function, get the local time using the `localtime()` function.
    Format it into a string using the `strftime()` function. Convert it into the desired
    format using `std::stringstream`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `getThreadId()` function, get the current thread ID and convert it into
    the desired format using `std::stringstream`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `getLoggingLevel()` function, convert the given string into the desired
    format using `std::stringstream`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `getFileAndLine()` function, convert the given file and line into the
    desired format using `std::stringstream`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `getFuncName()` function, convert the function name into the desired
    format using `std::stringstream`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: In the `getInFuncName()` function convert the function name to the desired format
    using `std::stringstream`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `getOutFuncName()` function, convert the function name into the desired
    format using `std::stringstream`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a header file called `LoggerMacroses.hpp`. Add include guards. Create
    macro definitions for each `LoggerUtils` function: `DATETIME` for the `getDateTime()`
    function, `THREAD_ID` for the `getThreadId()` function, `LOG_LEVEL` for the `getLoggingLevel()`
    function, `FILE_LINE` for the `getFileAndLine()` function, `FUNC_NAME` for the
    `getFuncName()` function, `FUNC_ENTRY_NAME` for the `getInFuncName()` function,
    and `FUNC_EXIT_NAME` for the `getOutFuncName()` function. As a result, the header
    file should look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a header and source file called `StreamLogger`. In `StreamLogger.hpp`,
    add the required include guards. Include the `LoggerMacroses.hpp` and `LoggerUtils.hpp`
    header files. Then, include the `<sstream>` header for `std::ostringstream` support,
    the `<thread>` header for `std::thread` support, and the `<mutex>` header for
    `std::mutex` support:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: 'Enter the `namespace` logger. Declare the `StreamLogger` class, which inherits
    from the `std::ostringstream` class. This inheritance allows us to use an overloaded
    left shift operator, <<, for logging. We don''t set the output device, so the
    output will not be performed – just stored in the internal buffer. In the private
    section, declare a static `std::mutex` variable called `m_mux`. Declare constant
    strings so that you can store the logging level, file and line, and function name.
    In the public section, declare a constructor that takes the logging level, file
    and line, and function name as parameters. Declare a class destructor. The class
    declaration should look like as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: 'In `StreamLogger.cpp`, include the `StreamLogger.hpp` and `<iostream>` headers
    for `std::cout` support. Enter the `logger` namespace. Define the constructor
    and initialize all the members in the initializer list. Then, define the destructor
    and enter its scope. Lock the `m_mux` mutex. If the internal buffer is empty,
    output only the date and time, thread ID, logging level, file and line, and the
    function name. As a result, we will get the line in the following format: `[dateTtime][threadId][logLevel][file:line:
    ][name() --- ]`. If the internal buffer contains any data, output the same string
    with the buffer at the end. As a result, we will get the line in the following
    format: `[dateTtime][threadId][logLevel][file:line: ][name() --- ] | message`.
    The complete source file should look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a header file called `Logger.hpp` and add the required include guards.
    Include the `StreamLogger.hpp` and `LoggerMacroses.hpp` headers. Next, create
    the macro definitions for the different logging levels: `LOG_TRACE()`, `LOG_DEBUG()`,
    `LOG_WARN()`, `LOG_TRACE()`, `LOG_INFO()`, `LOG_ERROR()`, `LOG_TRACE_ENTRY()`,
    and `LOG_TRACE_EXIT()`.The complete header file should look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace all the `std::cout` calls with the appropriate macro definition call.
    Include the `logger/Logger.hpp` header in the `Watchman.cpp` source file. In the
    `runAdd()` function, replace all instances of `std::cout` with macro definitions
    for different logging levels. The `runAdd()` function should look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice how we use our new logger. We invoke the macro definition with parentheses
    and use the left shift operator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: Do the same replacement for the rest of code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Build and run the application. In the Terminal, you will see that log messages
    appear from the different threads with different logging levels and with useful
    information. After some time has passed, you will get some output similar to the
    following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.26: The execution result of the activity project'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14583_06_26.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 6.26: The execution result of the activity project'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As you can see, it's really easy to read and understand logs. You can easily
    change the `StreamLogger` class to write logs to the file on the filesystem if
    your needs differ. You can add any other information that you may need to debug
    your application using logs, such as output function parameters. You can also
    override the left shift operator for your custom types to output debug information
    easily.
  prefs: []
  type: TYPE_NORMAL
- en: In this project, we employed many things that we have learned about during this
    chapter. We created an additional stream for thread-safe output, we formatted
    the output to the desired representation, we employed `std::stringstream` to perform
    formatting data, and we used macro definitions for convenient logger usage. Thus,
    this project demonstrates our skills in working with concurrent I/O.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 7 - Everybody Falls, It's How You Get Back Up – Testing and Debugging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Activity 1: Checking the Accuracy of the Functions Using Test Cases and Understanding
    Test-Driven Development (TDD)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For this activity, we''ll develop the functions to parse the **RecordFile.txt**
    and **CurrencyConversion.txt** files and write test cases to check the accuracy
    of the functions. Follow these steps to implement this activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a configuration file named **parse.conf** and write the configurations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Note that only two variables are of interest here, that is, `currencyFile`
    and `recordFile`. The rest are meant for other environment variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: Create a header file named `CommonHeader.h` and declare all the utility functions,
    that is, `isAllNumbers()`, `isDigit()`, `parseLine()`, `checkFile()`, `parseConfig()`,
    `parseCurrencyParameters()`, `fillCurrencyMap()`, `parseRecordFile()`, `checkRecord()`,
    `displayCurrencyMap()`, and `displayRecords()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file named `trim()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: 'Write the following code to define the `isAllNumbers()`, `isDigit()`, and `parseLine()`
    functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: 'Write the following code to define the `parseCurrencyParameters()` and `checkRecord()`
    functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: 'Write the following code to define the `checkFile()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: 'Write the following code to define `parseConfig()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: 'Write the following code to define the `fillCurrencyMap()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: 'Write the following code to define the `parseRecordFile()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: 'Write the following code to define the `displayCurrencyMap()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: 'Write the following code to define the `displayRecords()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file named `parseConfig()`, `fillCurrencyMap()`, and `parseRecordFile()`
    functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the compiler. Compile and execute the `Util.o` and `ParseFiles` files
    have been generated:![Figure 7.25: New files generated'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14583_07_25.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.25: New files generated'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'After running the `ParseFiles` executable, we''ll receive the following output:![Figure
    7.26: New files generated'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14583_07_26.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.26: New files generated'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Create a file named `trim` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: 'Write the following test cases for the `isAllNumbers` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: 'Write the following test cases for the `isDigit` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: 'Write the following test cases for the `parseCurrencyParameters` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: 'Write the following test cases for the `checkFile` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The **NoFile**, **emptyFile**, **noHeaderFile**, and **correctHeaderFile**
    files that were used as input parameters in the preceding functions can be found
    here: [https://github.com/TrainingByPackt/Advanced-CPlusPlus/tree/master/Lesson7/Activity01](https://github.com/TrainingByPackt/Advanced-CPlusPlus/tree/master/Lesson7/Activity01).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following test cases for the `parseConfig` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The **parseMissingCurrency.conf**, **parseMissingRecord.conf**, and **parse.conf**
    files that were used as input parameters in the preceding functions can be found
    here: [https://github.com/TrainingByPackt/Advanced-CPlusPlus/tree/master/Lesson7/Activity01](https://github.com/TrainingByPackt/Advanced-CPlusPlus/tree/master/Lesson7/Activity01).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following test cases for the `fillCurrencyMap` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The **CurrencyWrongDelimiter.txt**, **CurrencyExtraColumn.txt**, and **CurrencyConversion.txt**
    files that were used as input parameters in the preceding functions can be found
    here: [https://github.com/TrainingByPackt/Advanced-CPlusPlus/tree/master/Lesson7/Activity01](https://github.com/TrainingByPackt/Advanced-CPlusPlus/tree/master/Lesson7/Activity01).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following test cases for the parseRecordFile function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: 'The **RecordWrongDelimiter.txt**, **RecordExtraColumn.txt**, and **RecordFile.txt**
    files that were used as input parameters in the preceding functions can be found
    here: [https://github.com/TrainingByPackt/Advanced-CPlusPlus/tree/master/Lesson7/Activity01](https://github.com/TrainingByPackt/Advanced-CPlusPlus/tree/master/Lesson7/Activity01).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the compiler. Compile and execute the `Util.cpp` and `ParseFileTestCases.cpp`
    files by writing the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is a screenshot of this. You will see all the commands stored
    in `Test.make` script file. Once executed, it will create the binary program that
    was meant for unit testing called `ParseFileTestCases`. You will also notice that
    a directory has been created in Project called `unitTesting`. In this directory,
    all the unit testing-related code is written, and a binary file is created. Also,
    the dependent library of the project, `Util.o`, is also created by compiling the
    project in the `Util.cpp` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/C14583_07_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.27: Executing all commands present in the script file'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Type the following command to run all the test cases:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: 'The output on the screen will display the total tests running, that is, 31
    from 8 test suites. It will also display the statistics of individual test suites,
    along with pass/fail results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.28: All tests running properly'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14583_07_28.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.28: All tests running properly'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Below is the screenshot of the next tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.29: All tests running properly'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14583_07_29.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 7.29: All tests running properly'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Finally, we checked the accuracy of the functions that we developed by parsing
    two files with the help of our test cases. This will ensure that our project will
    be running fine when it's integrated with different functions/modules that have
    test cases.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 8 - Need for Speed – Performance and Optimization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Activity 1: Optimizing a Spell Check Algorithm'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this activity, we''ll be developing a simple spell check demonstration and
    try to make it faster incrementally. You can use the skeleton file, **Speller.cpp**,
    as a starting point. Perform the following steps to implement this activity:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For the first implementation of the spell check (the full code can be found
    in `getMisspelt()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: 'Loop over the text words and check for words not in the dictionary with the
    `set::count()` method. Add the misspelled words to the result vector:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the terminal. Compile the program and run it as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: 'The following output will be generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.60: Example output of the solution for Step 1'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14583_08_60.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.60: Example output of the solution for Step 1'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Open the `unordered_set` header file to the program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, change the set type that''s used for the dictionary to `unordered_set`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the Terminal. Compile the program and run it as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: 'The following output will be generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.61: Example output of the solution for Step 2'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14583_08_61.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.61: Example output of the solution for Step 2'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'For the third and final version, that is, `BKDR` function. Add the following
    code to implement this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: Here, we used an integer template parameter so that we can create any number
    of different hash functions with the same code. Notice the use of the `16777215`
    constant, which is equal to `2^24 – 1`. This lets us use the fast bitwise-and
    operator instead of the modulus operator to keep the hashed integer less than
    `SIZE`. If you want to change the size, keep it as one less than a power of two.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s declare a vector<bool> for a bloom filter in `getMisspelt()` and
    populate it with the words in the dictionary. Use three hash functions. The BKDR
    hash can be seeded with values such as `131`, `3131`, `31313`, and so on. Add
    the following code to implement this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: 'Write the following code to create a loop that checks the words:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: The bloom filter is checked first and if it finds the word in the dictionary,
    we have to verify it, like we did previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the terminal. Compile the program and run it as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: 'The following output will be generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.62: Example output of the solution for Step 3'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14583_08_62.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 8.62: Example output of the solution for Step 3'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'In the preceding activity, we attempted to solve a real-world problem and make
    it more efficient. Let''s consider some points for each of the implementations
    in the three steps, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: For the first version, the most obvious solution with a `std::set` is used –
    however, the performance is likely to be low because the set data structure is
    based on a binary tree, which has `O(log N)` complexity for finding an element.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the second version, we can gain a large performance improvement simply by
    switching to `std::unordered_set`, which uses a hash table as the underlying data
    structure. If the hash function is good, the performance will be close to `O(1)`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third version, based on the **Bloom filter** data structure, requires some
    consideration.-The primary performance benefit of a bloom filter is because it
    is a compact data structure that does not actually store the actual elements in
    it, thereby providing very good cache performance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'From an implementation perspective, the following guidelines apply:'
  prefs: []
  type: TYPE_NORMAL
- en: '`vector<bool>` can be used as the backing store as it is an efficient way to
    store and retrieve bits.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The false positive percentage of the bloom filter should be minimal – anything
    more than 5% will not be efficient.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are many string hashing algorithms – the **BKDR** hash algorithm is used
    in the reference implementation. A comprehensive of string hash algorithms with
    implementation can be found here: [http://www.partow.net/programming/hashfunctions/index.html](http://www.partow.net/programming/hashfunctions/index.html).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The number of hash functions and the size for the bloom filter that's used are
    very critical to get the performance benefits.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The nature of the dataset should be taken into account when deciding what parameters
    the bloom filter should use – consider that, in this example, there are very few
    words that are misspelled, and the majority of them are in the dictionary.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are some questions worth probing, given the results we received:'
  prefs: []
  type: TYPE_NORMAL
- en: Why is the improvement in performance so meager with the Bloom Filter?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the effect of using a larger or smaller capacity Bloom filter?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What happens when fewer or more hash functions are used?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Under what conditions would this version be much faster than the one in **Speller2.cpp**?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are the answers to these questions:'
  prefs: []
  type: TYPE_NORMAL
- en: Why is the improvement in performance so meager with the Bloom Filter?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::unordered_set` performs one hash operation and perhaps a couple of memory
    accesses before reaching the value that''s stored. The Bloom filter we use performs
    three hash operations and three memory accesses. So, in essence, the work that''s
    done by the bloom filter is more than the hash table. Since there are only 31,870
    words in our dictionary, the cache benefits of the Bloom filter are lost. This
    is another case where the traditional analysis of data structures does not correspond
    to real-life results because of caching.'
  prefs: []
  type: TYPE_NORMAL
- en: What is the effect of using a larger or smaller capacity Bloom filter?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a larger capacity is used, the number of hash collisions reduce, along
    with false positives, but the caching behavior worsens. Conversely, when a smaller
    capacity is used, the hash collisions and the false positives increase, but the
    caching behavior improves.
  prefs: []
  type: TYPE_NORMAL
- en: What happens when fewer or more hash functions are used?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The more hash functions are used, the fewer the false positives, and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: Under what conditions would this version be much faster than the one in Speller2.cpp?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bloom filters work best when the cost of testing a few bits is less than the
    cost of accessing the value in the hash table. This only becomes true when the
    Bloom filter bits fit completely within the cache and the dictionary does not.
  prefs: []
  type: TYPE_NORMAL
