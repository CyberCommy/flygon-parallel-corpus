- en: WebAssembly - A Brief Look into Native Code on the Web
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The past few chapters have been all about how to leverage JavaScript in the
    modern web landscape. We have looked at frontend development, backend development,
    and even building and deploying applications through **continuous integration
    and continuous deployment** (**CI**/**CD**). Now, we are going to take a step
    back and look at two topics that can help enhance our development with native
    speed code.
  prefs: []
  type: TYPE_NORMAL
- en: WebAssembly is a specification for assembly for the web. Assembly is a one-to-one
    mapping for the language that computers understand. WebAssembly, on the other
    hand, is a one-to-one mapping for a virtual computer that can run these instructions.
    In this chapter, we will explore WebAssembly and how we can port native applications
    to the browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'Overall, we will explore the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding WebAssembly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up our environment to write WebAssembly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing WebAssembly modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Porting C applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Taking a look at a major application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, we should be able to develop not only in the WebAssembly
    text format but also in C for the web. We will also be able to turn binary WebAssembly
    into its text format in order to diagnose possible issues with our ported applications.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will need the following tools for this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: An editor, such as VS Code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Access to build and compile programs on our computer. This may mean needing
    administrator privileges in some environments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter's code, which can be found at [https://github.com/PacktPublishing/Hands-On-High-Performance-Web-Development-with-JavaScript/tree/master/Chapter13](https://github.com/PacktPublishing/Hands-On-High-Performance-Web-Development-with-JavaScript/tree/master/Chapter13).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding WebAssembly
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'WebAssembly is a specification for an instruction set that can be run on a
    machine. In our case, this machine is virtual. To comprehend how this translates
    into native speed applications and why the instructions are written the way they
    are, we need to have a basic understanding of how a program functions inside our
    computer. To understand WebAssembly, we will look at the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the flow of a basic program
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up our environment to code WebAssembly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding a program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s take a look at a very basic C program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This program has an entry point. In our case, it is the `main` function. From
    here, we utilize a function that is declared in the `stdio` header file (a header
    file gives us function declarations so that we don't have to fully import all
    of the code into this file). We utilize the `printf` function to print out `Hello,
    World!` to the console and then we `return` with a `0` to signify that we have
    a successful program.
  prefs: []
  type: TYPE_NORMAL
- en: Since we won't be talking about the C/C++ code that we will be writing in depth,
    for those that are interested, a great resource is [https://www.learn-c.org/](https://www.learn-c.org/).
  prefs: []
  type: TYPE_NORMAL
- en: While this is a program in a format that we, as programmers, generally understand, it
    needs to be turned into a format that the computer will actually understand. This
    means it needs to be compiled. This compilation process involves bringing in any
    external files (`stdio`, in this case) and linking them in. This also means we
    need to turn each of our instructions into one or more computer instructions.
  prefs: []
  type: TYPE_NORMAL
- en: Once the process of linking and compilation happens, we will usually get a binary
    file that can be read by our computer. If we opened this file in a byte reader,
    we would see a bunch of hexadecimal numbers. Each of these numbers corresponds
    to the instructions, data points, and so on, that we put in our file.
  prefs: []
  type: TYPE_NORMAL
- en: Now, this is just a basic understanding of how a program gets turned into something
    our computer understands and how the binary we created is understood by the computer.
    On most machines, a program runs as a stack of instructions and data. This means
    that it pulls instructions off of the top of the stack one at a time. These instructions
    can be anything from loading this number into a location or adding these two numbers
    together. As it peels these instructions off, it discards them.
  prefs: []
  type: TYPE_NORMAL
- en: We can store various pieces of data local to this stack, or we can store data
    at a global level. Those local to the stack are held on exactly that—the stack.
    Once that stack has been exhausted, we no longer have access to those variables.
  prefs: []
  type: TYPE_NORMAL
- en: The global ones are put into a location called the **heap**. The heap allows
    us to grab the data from anywhere in our system. Once the stack of our program
    has been exhausted, those heap objects can be left there if our program is still
    running.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we get a stack per function that we write. Because of this, we can
    treat each function as a mini-program. This means it will perform one task or
    a couple of tasks and then it will be exhausted, and we will go back to the stack
    of the function that called us. We can do two things when we exhaust this stack.
    The first thing we can do is go back to the stack of the function that called
    us with no data. Alternatively, we could give some data back (this is the `return`
    statement that we see in most languages).
  prefs: []
  type: TYPE_NORMAL
- en: Here, we can share data through these two mechanisms either by returning values
    from one of our subfunctions or by putting our results onto the heap so that others
    can access them. Putting it on the heap means that it will last for the duration
    of our program, but it also needs to be managed by us, whereas if we return values
    from the stack, it will be cleaned up as soon as the function that called us is
    exhausted. Most of the time, we will use simple data and return it through the
    stack. For complicated data, we will put it on the heap.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we look at WebAssembly, there''s one final note you should know about:
    if we put data on the heap, we need to tell other parts of our program where to
    find that data. To do this, we pass a pointer to that location. This pointer is
    just an address that tells us where to find this data. We will be utilizing this
    in our WebAssembly code.'
  prefs: []
  type: TYPE_NORMAL
- en: The topic of computers and how programs work is quite interesting. For those
    of you who are interested, it may be beneficial to take a formal course at a community
    college. For those that like to self-learn, the following resource is of great
    help: [https://www.nand2tetris.org/](https://www.nand2tetris.org/).
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's set up our environment so that we can program in WebAssembly.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up our environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To program in WebAssembly, we need to get the `wat2wasm` program on our machine.
    The best way to do this is to download the repository for the WebAssembly suite
    of programs and get them compiled for our computer. Follow these steps to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: We need to get a program called CMake onto our system. For Linux/OS X, this
    just means going to [https://cmake.org/download/](https://cmake.org/download/)
    and running the installer. For those of you who are on Windows, this is a bit
    lengthier. Go to [https://visualstudio.microsoft.com/vs/](https://visualstudio.microsoft.com/vs/)
    and get Visual Studio. Make sure to get the C/C++ modules for it. With both CMake
    and Visual Studio on our machines, we can now move on and compile the WebAssembly
    suite of tools.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Head to [https://github.com/WebAssembly/wabt](https://github.com/WebAssembly/wabt)
    and clone to an easily accessible location.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the CMake GUI tool. It should look similar to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/9ab392d7-69cc-498a-a272-79308dc1ef61.png)'
  prefs: []
  type: TYPE_IMG
- en: For the source code, go to the `wabt` folder that we downloaded from GitHub.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The location of the binaries should be in the `build` directory that we created
    in the `wabt` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With this, we can hit the Configure button. This should populate the panel in
    the middle of the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, just hit the Generate button. This should generate the files that we need
    to build our application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we will go into Visual Studio and build the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open Visual Studio and open the project from the File dropdown at the top left.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once the project is in, we can hit Build. This should build all of the binaries
    that we need for working with WebAssembly. The screen should look something like
    this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/87c69289-3dbb-4945-a3ee-2e7e4c3c39f5.png)'
  prefs: []
  type: TYPE_IMG
- en: If you are having trouble, the repository at [https://github.com/WebAssembly/wabt](https://github.com/WebAssembly/wabt)
    contains some excellent documentation on how to get the build done. The preceding
    instructions try to streamline the build process, but it can be difficult to get
    these projects up and running.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have built out our binaries, let''s make sure that we put them
    on our path so that we have easy access to them. On Windows, we can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to the search bar and type `path variables`. The first option should allow
    us to set up our environment variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/a62e5e40-947e-4e13-a041-5c685fb35059.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on the bottom right option called Environment Variables...:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/c193fd0a-5ebd-4c31-9681-a211561e2e7d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'For the bottom box, find the Path variable and click Edit...:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/a7c437ca-48db-424f-91f0-2aa27458efd4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on New and find the directory where all of the binaries are being held:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/13e6a73f-7f8a-47cf-a8ab-c1743ceda4bc.png)'
  prefs: []
  type: TYPE_IMG
- en: Once we've done this, we should be able to type `wat2wasm` into our command
    line and get the help documentation for the tool. Now, we are able to compile
    the text format of WebAssembly into a format that our browser expects!
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've added the WebAssembly binary toolkit to our system and can compile/decompile
    WebAssembly programs, let's start writing our first program in WebAssembly!
  prefs: []
  type: TYPE_NORMAL
- en: Writing WebAssembly modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A WebAssembly module is similar to a JavaScript module. We need to explicitly
    import anything we need from other WebAssembly/JavaScript modules. Whatever we
    write in our WebAssembly module can't be found by another WebAssembly module unless
    we explicitly export it. We can think of it as a JavaScript module – it is a sandboxed
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start off with the most basic and useless version of a WebAssembly module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'With this, we can go to the command line and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This preceding code will spit out a file with the `wasm` extension. This is
    what we need to pass into the web browser to run WebAssembly. All this shows us
    is that WebAssembly, just like ESNext for JavaScript, wants to have everything
    declared in modules. It is easier to think of it like so, which is what happens
    when loading in JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This means that all of the code loaded in the WebAssembly context can't spill
    into other WebAssembly modules that we set. Now, to load this `wasm` file into
    our browser, we need to utilize the static server that we utilized in [Chapter
    9](d1a2a4d4-8ed1-4d82-a098-835d61c01b86.xhtml), *Practical Example - Building
    a Static Server*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you''ve loaded this up, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a basic `index.html` file that looks as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside our `script` element, we will add the following code to load the module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We have loaded our first WebAssembly module into the browser. The API is heavily
    promise-based and due to this, we need to utilize the Fetch interface. Once we've
    fetched the object, it's loaded in the WebAssembly context for the browser, which
    means this object is available to us. This is the WebAssembly module that we have
    just loaded up!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go ahead and make a WebAssembly module that is a bit more useful. Let''s
    take in two numbers and add them together. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a file called `math.wat`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Put the following code into the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Compile this by running `wat2wasm math.wat`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Load the new `wasm` file into the browser and add the following to the `then`
    body:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Make sure that the static server is running by going into the folder and running
    the `static-server` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For those that have skipped ahead to this chapter, you can install a static
    server by running `npm install -g static-server`. This will install this static
    server globally. Then, all we need to do is run `static-server` in the folder
    that we want to deploy files from. Now that we've done this, we can hit our `index.html`
    file by going to `localhost:9080`.
  prefs: []
  type: TYPE_NORMAL
- en: If we launch our browser, go to `localhost:9080`, and open up the console, we
    will see that the number 300 has been printed out. We have just written our first
    accessible WebAssembly module!
  prefs: []
  type: TYPE_NORMAL
- en: Let's go over some of the concepts we covered in the preceding code. First,
    we defined a function. We stated that the name of this function is `$add` (all
    variables start with a dollar sign in WebAssembly). Then, we stated that it will
    take two parameters that we called `$p1` and `$p2`. Finally, we will output a
    result; that is, a 32-bit integer.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we take the two parameters and store them on our stack. Finally, we add
    them together and use this as a result. Remember at the beginning of this chapter
    when we talked about how programs are stacks? This showcases the exact same concept.
    We loaded our two variables onto the stack. We popped them off so that we could
    use them in the `add` function, which put a new value onto the stack. Finally,
    we popped that value off of the stack and returned it to the main function body;
    in our case, the module.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we exported the function so that our JavaScript code has access to it.
    This makes sure that our WebAssembly code is held in our sandbox, just like we
    want it to be. Now, as we mentioned previously, the object that is returned is
    the WebAssembly context. We grab the instance and look at the exports that are
    available. In our case, this is the `add` function, which we can now utilize in
    our JavaScript code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have learned how we can export WebAssembly modules into the JavaScript
    context, you may be wondering if we can load JavaScript functions into the WebAssembly
    context. We can! Let''s go ahead and add the following code to our `index.html` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we loaded in the `add` function we took from the JavaScript context and
    created an associated function that has the same function signature that our `add`
    function has in JavaScript. Now, we create a new `add` function called `$add2`
    that has a similar signature. We put our two parameters onto the stack and use
    the new `call` instruction. This instruction allows us to call other functions
    that have been declared in our context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we export this function, just like we did with the other `add` function.
    Now, if we compile our code, go back into our browser, and reload the page, we
    will see that the number 300 is printed out twice.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we know how to use WebAssembly functions in JavaScript and how to load
    JavaScript functions into WebAssembly. We are close to being able to write a program
    famous for being asked in an JavaScript coding interview. Before we do this, though,
    we will need to look at heap space and utilizing memory between JavaScript and
    WebAssembly.
  prefs: []
  type: TYPE_NORMAL
- en: Sharing memory between WebAssembly and JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have been working with one type of variable in WebAssembly. These
    are known as local variables, or stack variables. There is another type that will
    allow us to not only utilize them across our WebAssembly context but also share
    them between our JavaScript and our WebAssembly. But first, we will need to discuss
    the differences between the stack and the heap.
  prefs: []
  type: TYPE_NORMAL
- en: There is a difference between global/local variables and the stack/heap. For
    now, we are going to keep things simple and treat global variables as if they
    are on the heap and local variables as if they are on the stack. Later, our application
    will have a global state that is not on the heap, but it is best to try to keep
    the idea of the local equivalent to the stack and the global equivalent to the
    heap.
  prefs: []
  type: TYPE_NORMAL
- en: We talked about the stack when we talked about how programs run on a typical
    computer. The best way to think of this is a stack of wood. We will always pull
    from the top and always add to the top. This is the same way in programming. We
    add to the top of the stack and then we pull from those top items. As an example,
    let's take the `add` function that we created.
  prefs: []
  type: TYPE_NORMAL
- en: We grabbed the two parameters and added them to the stack. First, parameter
    one and then parameter two. When we called `$externalAdd` or even if we called
    the `add` function built into WebAssembly, it takes those two items off the stack
    and replaces them with one item, the result. When we return from a function, we
    take that item off the local function stack and pop it on the top of the stack
    of the context for whoever called us.
  prefs: []
  type: TYPE_NORMAL
- en: A heap is just like what its name implies. We have the blob of things that can
    be grabbed, changed, and replaced from everywhere. Anyone can get to the heap,
    put items into it, and read from it. It's like a heap of clothes – we can search
    through it and find the item we need, or we can just add to it at the end of the
    day.
  prefs: []
  type: TYPE_NORMAL
- en: The main difference between the two is that the stack will get cleaned up. Any
    variables that we created inside it, once the function returns, are cleaned up.
    On the other hand, the heap stays there. Since anyone has access to it, we have
    to explicitly get rid of it; otherwise, it will be there permanently. In garbage-collected
    environments, the best way to think of this is that our environment doesn't know
    who else has items on it, so it doesn't know what needs to be cleaned up and what
    doesn't.
  prefs: []
  type: TYPE_NORMAL
- en: In WebAssembly, we don't have a garbage-collected environment, so we have to
    recollect the heap once we are done with it in our JavaScript or WebAssembly context.
    In our examples, we won't be doing this, so note that this is something we would
    want to do in a production-style environment. To do this, we could just set the
    `memory` object in JavaScript to `null`. This will let the garbage collector know
    that no one is utilizing it anymore.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s learn how to share memory between JavaScript and WebAssembly and how
    that is equivalent to the heap. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a file named `sharing_resources.wat`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Put the following code inside the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Our first function stores the number `100` at memory location `0`. If we were
    storing an arbitrary amount of data, we would have to let whoever called us know
    how much we stored. However, in this case, we always know that it is just one
    number.
  prefs: []
  type: TYPE_NORMAL
- en: Our `read` function just reads that value from memory and returns it as a value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our script section inside the `index.html` file should look something like
    the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The top section should look different. First, we are creating a piece of memory
    that both JavaScript and WebAssembly can share. We are going to create and load
    only one section of memory. In the context of WebAssembly, this is 64 KB worth
    of data.
  prefs: []
  type: TYPE_NORMAL
- en: Once our WebAssembly has loaded, we store the number and then read it out. Now,
    we can see that we have a global state in WebAssembly, but how would we share
    this with our JavaScript? Well, that starting section of the code tells us how.
    We have access to the memory object, so we should be able to get at it. Let's
    go ahead and change our script a bit so that we can read the memory directly inside
    JavaScript instead of calling a function that does this for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code should do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can add this to the body after our WebAssembly has loaded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If we look inside our console, we should see the exact same output! The final
    test is to store something from JavaScript and grab it inside WebAssembly. We
    can achieve this by changing the script to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: If we save this and go back to our console, we should see that the number 200 is
    printed out!
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we know how to share memory between two instances and how we can utilize
    this to do some cool stuff. Let''s go ahead and put all of our skills to the test
    and create every programmer''s favorite program: FizzBuzz.'
  prefs: []
  type: TYPE_NORMAL
- en: Writing FizzBuzz in WebAssembly
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'FizzBuzz is a programming challenge that requires a user to take in a positive
    number loop from 1 to a chosen number and print out the results based on the following
    criteria:'
  prefs: []
  type: TYPE_NORMAL
- en: If the number is divisible by 3, then print *Fizz*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the number is divisible by 5, then print *Buzz*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the number is divisible by 15, then print *FizzBuzz*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s go ahead and kick this off by getting our JavaScript environment ready.
    The following code should look familiar, except for our new logging function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This function takes in the offset of the memory and the length of the data
    and prints it out. As we mentioned previously, we need to know where the data
    is, as well as its length, to be able to read it from the heap. Now, we can get
    into the heart of the program. Follow these steps to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file called `fizzbuzz.wat`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We know that we will need to import both our memory and the `console` function,
    just like we have been importing other functions. We also know that we will be
    creating a function called `fizzbuzz` and that we will be exporting this so that
    our JavaScript context can utilize it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The only interesting piece of the preceding code is the `global` section. This
    is a global variable that can be thought of as the stack of our context. It isn't
    on the heap, so the JavaScript context doesn't have access to it. We can also
    see the `mut` keyword in front of the declaration. This tells us that we are going
    to be changing the global variable from the various parts of our WebAsembly code.
    We are going to utilize this so that it holds the length of our print out.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will need to check for both conditions of FizzBuzz:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Both of our functions will take a number. For the `checkFizz` function, we will
    test to see if it is divisible by 3\. If it is, we will store the word *Fizz*
    in the memory heap where the global variable is and then update that global variable
    to the location after the word *Fizz*. For *Buzz*, we will do the exact same thing,
    except we will test to see if the number is divisible by 5\. If this is `true`,
    we will put *Buzz* in the global pointer location and update it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the `checkFizz` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Here, we grab the number that was passed in. Then, we put `3` on the stack and
    run the remainder function. If the result is equal to `0`, then we put the word
    *Fizz* into memory. Now, what's being put into memory may not look like the word
    *Fizz*, but if we look at the UTF8 decimal numbers for each of the letters, we
    will see that that is what we are putting into memory.
  prefs: []
  type: TYPE_NORMAL
- en: If we head back to our JavaScript code, we will see that we are utilizing a
    `TextDecoder`. This allows us to read these byte values and translate them into
    their string equivalent. Since WebAssembly only understands the concept of integers
    and floating-point numbers, this is how we have to deal with it for now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next is the `checkBuzz` function. It should look similar to the preceding code,
    except for the divisible, which is `5`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can write `fizzbuzz`. We will take in the integer and then loop from
    `1` to that value running our `checkFizz` and `checkBuzz` functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The loop is fairly simple. `br_if` tests to see whether our `start` variable
    equals what we put in. If it does, it will equal `1` and it will break out of
    the loop. Otherwise, it will increment the `start` variable by one. `(br 0)` is
    what keeps the loop going.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have finished the loop, we will get our global variable, wherever it
    finished up, and call the `log` function. Let''s compile this and run the following
    test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'By doing this, we should get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We have just written a nontrivial program in pure WebAssembly! By now, you should
    have realized why most people don't write in pure WebAssembly since what should
    have been a simple program took us quite a bit of coding.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll learn how to use a higher-level language, C, to write
    programs for the web.
  prefs: []
  type: TYPE_NORMAL
- en: Writing C/C++ for the web
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have taken a look at writing the low-level instruction language of
    WebAssembly. While this can be a fun exercise to take on, most of our projects
    will be much grander in scale and we will want to utilize a high-level language
    to accomplish our goals. While there are languages out there that will compile
    to WebAssembly that are similar to JavaScript ([https://github.com/AssemblyScript/assemblyscript](https://github.com/AssemblyScript/assemblyscript)),
    a good chunk of modules will be written while utilizing system languages such
    as C, C++, or Rust. In this section, we will take a look at writing C/C++ code
    for the browser.
  prefs: []
  type: TYPE_NORMAL
- en: The Rust language ([https://www.rust-lang.org/](https://www.rust-lang.org/))
    provides us with a safer alternative to C/C++. While utilizing it may be better
    in the long run, we are going to stick with C/C++ since this is what we will widely
    compile to WebAssembly for the foreseeable future since most programs are currently
    written in it.
  prefs: []
  type: TYPE_NORMAL
- en: 'For us to begin our C/C++ writing adventure, we will need to grab the Emscripten
    SDK to compile to WebAssembly. This can be found at [https://emscripten.org/index.html](https://emscripten.org/index.html).
    We will mostly be following the *Getting started* guide that Emscripten provides.
    Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will clone the Emscripten SDK by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Head into the directory by using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Pull the latest changes and the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have the preceding commands to aid us, we are ready to start writing
    C and C++ for the web! Let''s go ahead and start with an easy module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This basic C program is everybody''s favorite Hello World program. To compile
    this program, go ahead and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'If everything has been installed correctly, we should get the following two
    files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`a.out.wasm`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`a.out.js`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With these two files, we can utilize an `index.html` file and load them in,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We should get a printout of **Hello World!** to our console! Let''s go ahead
    and write another C program, just like the previous WebAssembly program we wrote –
    FizzBuzz:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: If we compile this and try to run it, we will see that nothing is found. The
    documentation states that it should be on the global `Module` variable, but if
    we check there, we will see that there is no `fizzbuzz` program to be found. Fortunately,
    Emscripten does dead code analysis for us and noticed that our C program doesn't
    have a `main` function and that it doesn't call the `fizzbuzz` function, so it
    eliminated it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To handle this, we can add an argument to our `emcc` call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: All of our functions will have an underscore before them. This helps us and
    the system differentiate what may be created in the JavaScript system and what
    is being created in the C/C++ context.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this, we can go into the browser and our developer console and type the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: We should see a printout! We have just compiled our first library function from
    C that can be used in our JavaScript code. Now, what if we want to try something
    a little more difficult? What if we want to run a JavaScript function inside our
    C/C++ code?
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we will have to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will need to put an `extern` declaration at the top of our file (Emscripten
    will look in the JS location first, but we can also pass a command-line flag to
    tell it where else to look):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will create an `external.js` file that will house our new function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can compile our program with the following line of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: After, we can head back to the browser and see that it prints out 300! Now,
    we know how to use external JavaScript in our C/C++ programs and we can grab our
    C/C++ code from the browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'All this time, we have been overwriting our files, but is there another way
    for us to handle this? Of course – we can call the `emcc` system with the `emcc
    -o <file_name.js>` flag. Therefore, we can compile our `extern.c` file and call
    it `extern.js` by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Alternatively, we can go to their website: [https://emscripten.org/](https://emscripten.org/).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we are able to write and compile C code for our browser, we will turn
    our attention to utilizing this power. Let's implement a hamming code generator
    that we can utilize in JavaScript that is written in C and can be compiled to
    WebAssembly.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a hamming code generator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we are going to write a complicated piece of software. A hamming code generator
    creates a piece of data that should be able to be recovered when it is transmitted
    between two mediums. These mediums could be anything from a computer to another
    computer or even a process to another process (although we should hope that data
    transmission between processes does not get corrupted). The data that we will
    be adding to accomplish this is known as hamming codes.
  prefs: []
  type: TYPE_NORMAL
- en: To write this piece of software, we will need to understand how a hamming code
    is generated and how we can use a verifier to make sure that the data that does
    cross from one medium to another is correct. Specifically, we will be looking
    at the creation of hamming data and the verification process. We won't be looking
    at recovering the data as this is close to the reverse process of creating the
    data.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand how hamming data is created, we will need to look at data at
    the bit level. This means that if we want to transmit the number 100, we need
    to know what that looks like in terms of bits. Bits are the lowest data unit for
    a computer. A bit can only be a 0 or a 1\. As we add more bits together, they
    represent the power of 2\. The following table should help showcase this a bit:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Bit 3** | **Bit 2** | **Bit 1** | **Bit 0** |'
  prefs: []
  type: TYPE_TB
- en: '| 8 | 4 | 2 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 2^3 | 2^2 | 2^1 | 2^0 |'
  prefs: []
  type: TYPE_TB
- en: As we can see, each bit location represents the next power of two. If we mix
    and match these bits together, we will find that we can represent all positive
    real numbers. There are also ways to represent negative and even floating-point
    numbers, but we will not be going into that here.
  prefs: []
  type: TYPE_NORMAL
- en: For those that are curious, an article on floating-point representation can
    be found here: [https://www.cprogramming.com/tutorial/floating_point/understanding_floating_point_representation.html.](https://www.cprogramming.com/tutorial/floating_point/understanding_floating_point_representation.html)
  prefs: []
  type: TYPE_NORMAL
- en: 'So, if we wanted to see these numbers in their binary form, we could go through
    them one at a time. The following table shows the decimal notation on the left
    and the binary representation on the right (decimal is what we are used to):'
  prefs: []
  type: TYPE_NORMAL
- en: '| 0 | 0000 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 0001 |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | 0010 |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | 0011 |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | 0100 |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | 0101 |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | 0110 |'
  prefs: []
  type: TYPE_TB
- en: '| 7 | 0111 |'
  prefs: []
  type: TYPE_TB
- en: '| 8 | 1000 |'
  prefs: []
  type: TYPE_TB
- en: Hopefully, this clarifies how bits and binary representation works. Now, we
    are going to move on to how hamming codes actually work. Hamming codes work by
    adding what is known as parity bits to special locations in the data transmission
    process. These parity bits will either be a 1 or a 0, depending on the type of
    parity that we select.
  prefs: []
  type: TYPE_NORMAL
- en: The two types of parity that we can choose are even parity and odd parity. Even
    parity means that when we add up all of the bit locations for that parity bit,
    they need to be an even number. If we choose odd parity, we need to add up all
    the bits for that parity location and check to make sure they are odd. Now, we
    need to decide what bits correspond to each parity bit location and even where
    the parity bits go.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will take a look at where the parity bits go. Parity bits will be
    at the bit location for each power of 2\. Just as we saw in the preceding table,
    we will host our parity bits at the following bit locations: 1, 2, 4, 8, and 16\.
    If we look at the preceding table, we will notice that these correspond to the
    bits where there is only a single bit set.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to decide which data bit locations correspond to our parity bit
    locations. Well, we might be able to guess these based on where the parity bits
    are located. For each data bit, we will look at if they have the corresponding
    parity bit set there. This can be seen in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Number (Decimal Format)** | **Is It A Parity Bit?** | **Parity Bits That
    Use This Data** |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | Yes | N/A |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | Yes | N/A |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | No | 1, 2 |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | Yes | N/A |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | No | 1, 4 |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | No | 2, 4 |'
  prefs: []
  type: TYPE_TB
- en: '| 7 | No | 1, 2, 4 |'
  prefs: []
  type: TYPE_TB
- en: '| 8 | Yes | N/A |'
  prefs: []
  type: TYPE_TB
- en: The final piece that we need to know about is how to mesh our data with the
    parity data. The best way to look at this is through an example. Let's take the
    number 100 and turn it into its binary representation. We could do this by hand
    or we could pull up a programmer's calculator, which most operating systems have.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we open up our calculator and type in 100, we should get the following binary
    representation of it: 1100100\. Now, to add our parity bits, we will need to shift
    our data bits based on whether we place a parity bit there or not. Let''s take
    this a step at a time:'
  prefs: []
  type: TYPE_NORMAL
- en: Is the first bit used as a parity bit? Yes, so we will place a 0 there and shift
    our data to the left once. We now have 11001000.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is the second bit used as a parity bit? Yes, so we will place a 0 there and
    shift our data to the left once. We now have 110010000.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Is the third bit used as a parity bit? No, so we can put our original first
    data bit there, which is a zero. Our data looks the same as before: 110010000.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Is the fourth bit used as a parity bit? Yes, so we will place a 0 there and
    shift our data to the left once. We now have 1100100000.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Is the fifth bit used as a parity bit? No, so we will place our original second
    data bit there, which is a zero. Our data looks the same as before: 1100100000.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Is the sixth bit used as a parity bit? No, so we will place our original third
    data bit there, which is a one. Our data looks the same as before: 1100100000.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Is the seventh bit used as a parity bit? No, so we will place our original
    fourth data bit there, which is a zero. Our data looks as follows: 1100100000.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Is the eight-bit used as a parity bit? Yes, so we will shift our data to the
    left one and place a zero there. Our data looks as follows: 11000100000.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For the rest of the numbers, they stay the same since we have no more parity
    bits to place. Now that we have our data, we have to set our parity bits. We will
    use even parity for our example and the code. The following table showcases the
    final number and the reason why we had to set a parity bit to one or zero:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Bit Location** | **Binary For Location** | **Do We Set It?** | **Count
    For Parity** |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 00001 | Yes | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 00010 | Yes | 3 |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 00011 | N/A |  |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 00100 | Yes | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 00101 | N/A |  |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 00110 | N/A |  |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 00111 | N/A |  |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 01000 | No | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 01001 | N/A |  |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 01010 | N/A |  |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 01011 | N/A |  |'
  prefs: []
  type: TYPE_TB
- en: As shown in the preceding table, we had to set the parity bits for the 1, 2,
    and 4 locations. Let's take a look at the second bit and go through the process.
    We will look for any bit locations where their binary representation has the second-bit
    set. If the bit is set at that location, we will count it. After adding up all
    of these numbers, if they add up to an odd number, we will need to set the parity
    bit location. For the second bit, we can see that the number 6, 10, and 11 locations
    have their second-bit set and that they have a 1 at them. This is why we have
    a count of three, which means we need to set our parity bit to make sure we have
    even parity.
  prefs: []
  type: TYPE_NORMAL
- en: This is a lot of information to take in, and rereading the preceding sections
    may help you understand how we got to this final parity number. If you want to
    find out more, go to [https://www.geeksforgeeks.org/hamming-code-in-computer-network/](https://www.geeksforgeeks.org/hamming-code-in-computer-network/).
  prefs: []
  type: TYPE_NORMAL
- en: Now, with all of this theory out of the way, let's go ahead and start writing
    our C program to be able to create parity data and also verify it.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s create a file called `hamming.c`. We will create this as a pure
    library file, so we won''t have the `main` function. Now, let''s go ahead and
    stub out our functions just to get an idea of what we want to do. Follow these
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To create our data, we will need to read in the data and move the data bits
    to the proper locations, the same way that we did previously. Let''s go ahead
    and call this function `placeBits`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: We can see something interesting about the method signature of the `placeBits`function.
    It is taking in an `int*`. For JavaScript developers, this will be a new concept.
    We are passing in the location of the data instead of passing in the data itself.
    This is known as passing by reference. Now, the idea is similar to what it's like
    in JavaScript; that is, if we pass an object, we are passing the reference to
    it. This means that when we make changes to that data, we will see these changes
    in the original function. It is the same concept as the previous one, but we have
    a bit more control over this. If we don't pass by reference, it would pass by
    value, meaning we would get a copy of the preceding data and we wouldn't see the
    changes reflected in our `createData` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to have a function that figures out if we set the parity bit for
    that location. We will call this `createParity`. It should have a method signature
    that looks like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Again, we are passing in a reference to the data instead of passing the data
    itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our data checking algorithm, we will be going through each parity bit and
    checking the respective data locations for each. We will call this function `checkAndVerifyData`
    and it will have the following method signature:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Now, instead of a Boolean, we will be passing back an `int`, where `-1` means
    that the data is bad and `1` means that the data is good. In basic C, we don't
    have the concept of a Boolean, so we use numbers to represent the concepts of
    true or false (there is a Boolean in the `stdbool` header, but if we look at it,
    it utilizes the concept of `0` being `false` and `1` being `true`, so it still
    utilizes the numbers underneath). We can also make the system more robust by making
    each negative number mean a specific error code. In our case, we will just use
    `-1`, but this can be improved.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can begin filling out our functions. First, we will place our data
    in the correct locations and make sure we have room for our parity bits. This
    will look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: First, we created a constant known as `INT_SIZE`. This allows us to handle different
    types of environments (although WebAssembly is supposed to be a standardized environment
    to work in, this allows us to use this C program elsewhere). We are also utilizing
    three special functions: `ceil`*,* `floor`, and `log2`. All of these can be found
    in the math library that comes with the standard library for C.
  prefs: []
  type: TYPE_NORMAL
- en: 'We get this by importing the header file at the top of our file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The iteration process works like so:'
  prefs: []
  type: TYPE_NORMAL
- en: It checks to see if we are at a parity bit section. If we are, we will skip
    it and move on to the next section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If we are not at a parity bit section, we will take the bit in our data at `dataIterator`.
    This counter keeps count of our location in the data that we passed in. All of
    the preceding operations are bit operations. The `|` tells us we are doing a bitwise
    or, which means that the bit will be set to a `1` if the left-hand side (the parity
    variable), the right-hand side (our equation), or both are `1`; otherwise, it
    will be a `0`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We do a bitwise AND on our data with the bit set at our `dataIterator`. This
    will let us know if we have a bit set there. Finally, we need to make sure that
    we shift that bit by the number of parity bits that are already set (this is `j
    – dataIterator`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If we reach the bottom of this `for` loop, then we check a data bit, so we need
    to increment our `dataIterator`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If bit operations are new to you, it would be a good idea to read up on them
    at [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can fill in our `createParity` method with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'This section can be a bit more complicated, but it is doing what we did by
    hand previously:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we are only going to handle a certain amount of bits for our data, so
    we will only use four parity bits. These parity bits correspond to the `0`, `1`,
    `2`, and `4`-bit locations, which are the decimal numbers 1, 2, 4, and 8.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, these bits are located at the `1`, `2`, `4`, and `8`-bit locations, which
    are represented as `1`, `2`, `8`, and `128` in decimal form. This just makes it
    easier if we need to set the parity bit located there.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, we will loop through each of our parity checks and see if our newly moved
    data has a bit set there:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: We are checking to make sure that the bit we are currently looking at is the
    data bit that we are worried about for that parity bit. If it is, we will add
    to the counter if the data bit is set there. We will do this by utilizing a bitwise
    AND with the data. If we don't get a zero, this means the bit is set, so we will
    add to the counter.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of this `for` loop, if we don't have even parity, we will need to
    set the parity bit at this location to get even parity.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, let''s compile our program with the following command-line operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to go to our `index.html` page in the browser and run the following
    command in our developer''s tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'By doing this, we should get the following output: `1579`. If we put this decimal
    number into our programmer''s calculator, we will get the following binary representation:
    `11000101011`. If we head back up and check when we did this by hand, we will
    see that we got the exact same thing! This means our hamming data generator is
    working. Now, let''s make the verification tool. Follow these steps to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside our `checkAndVerifyData` method, we will add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have a `verify` variable that will tell us if the data is good or not.
    If it isn't good, it will output our error status, which is a `-1`. Otherwise,
    we'll have run through the data and seen it was good, so we'll return a `1`. Next,
    we'll utilize the parity bits which, as we already know, are held at the decimal
    numbers `1`, `2`, `8`, and `128`. We will loop through these and check our hamming
    data with it by utilizing the `checkRow` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `checkRow` method will utilize similar concepts to our creation process.
    This looks as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Again, this should be very similar to our `createParity` method. We will run
    through the number and check to see if this is a parity bit number. If it is,
    we will utilize a bitwise AND operation at the location with a number we know
    has the bit set. If it is not equal to `0`, then the bit is set and we update
    our counter. We will return our counter modded with `2` since this will tell us
    if we have even parity.
  prefs: []
  type: TYPE_NORMAL
- en: 'This should always return an even number (in our case, `0`). If it doesn''t,
    we instantly error out. Let''s compile this with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can head into our browser and use the number we got from the `createData`
    method. Head into the developer console and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'It should print out a `1`, which means that we have good hamming data! Now,
    let''s try it with an example that we haven''t worked out by hand: the number
    `1000`. Run the following commands; we should get the same results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Now, we have a working hamming data creation method and a verification tool
    all written in C and running in the browser! This should help you understand how
    to port existing applications to the browser, but also how to utilize this powerful
    technology that allows you to run near-native speeds for computationally intensive
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: The final section of this chapter will take a look at one of the ports that's
    being utilized today, and even take a look at some of the code that goes into
    it. This library is utilized by a lot of application developers and is known as
    SQLite.
  prefs: []
  type: TYPE_NORMAL
- en: A look at SQLite in the browser
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SQLite is an embedded database that's used by thousands of applications. Instead
    of needing a server and a connection system like most databases, SQLite allows
    us to utilize it like any other library. But what's kept us from developing with
    this type of power in the browser has been a way to import this without needing
    native bindings. To utilize it in Node.js, we would need to utilize something
    like node-gyp and then create JavaScript bindings to the underlying C code.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have a way of utilizing this database in the browser without needing these
    native bindings, thanks to WebAssembly. For a version that has already been compiled
    for us, go to [https://github.com/kripken/sql.js/](https://github.com/kripken/sql.js/)
    and pull the repository into our local system. Let''s go ahead and set up our
    static server to bring in all of the files for us. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new directory called `sqlitetest`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside this directory, go ahead and run the following command to clone the
    repository from GitHub:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'With this, we can create a basic `index.html` file and add the following code
    to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'If we look inside our developer tools, we will see that we have the SQLite
    library up and running in our browser! Let''s go ahead and create some tables
    and populate them with some data:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to create a simple two-table database. These two tables will look
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| id | first_name | last_name | username |'
  prefs: []
  type: TYPE_TB
- en: '| <auto_increment> | <text> | <text> | <text> |'
  prefs: []
  type: TYPE_TB
- en: '| id | customer_id | op | timestamp |'
  prefs: []
  type: TYPE_TB
- en: '| <auto_increment> | <foreign_key> | <text> | <integer> |'
  prefs: []
  type: TYPE_TB
- en: Essentially, we will be simulating a remote procedure call server where, when
    customers make calls to it, we will log which operation they performed and the
    timestamp that they performed it at.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make these tables in our SQLite database, we will run the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Now, we have a simple two-table database that has everything we need in it to
    get moving.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go ahead and populate this with some data for each of the tables. We
    can do this with the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'With this bit of code, we have entered our test data. Now, let''s run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: We have successfully run a SQL database in our browser!
  prefs: []
  type: TYPE_NORMAL
- en: For more information on how to utilize this, go to [https://github.com/kripken/sql.js/](https://github.com/kripken/sql.js/).
    To get the SQLite reference documentation, go to [https://www.sqlite.org/lang.html](https://www.sqlite.org/lang.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, being able to run a SQL engine in our browser is awesome, but let''s take
    a look at how some of the underlying C code got turned into something that our
    browser understands. If we head to [https://www.sqlite.org/download.html](https://www.sqlite.org/download.html)
    and download the latest release, we can pull up the `sqlite3.c` code base. Now
    that we have the code base, let''s look for something that we might be able to
    see in the WebAssembly printout. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will utilize the `wasm2wat` tool that we received when we installed the
    wasm binary tools. Head into the `dist` folder of the `sqljs` folder and run the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can open that file to see the generated WebAssembly in a human-readable
    fashion. As we can see, it isn't that readable, but near the top, we can see a
    bunch of imports from Emscripten. We should realize that all of these are functions
    that Emscripten provides from their JavaScript API and that they are utilized
    to compile everything to WebAssembly and be usable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s go to the bottom of the file. We''ll notice that there are a bunch
    of exports that are named. Each of these should correspond to a function found
    in the `c` file. Let''s go ahead and take a look at a semi-simple one: `sqlite3_data_count`.
    It should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: We will see this return type in the C code if the pointer is NULL. If the result
    is NULL, we will return 0\. This is how we can debug C programs that we are porting
    to the web. While this isn't easy, it can help us when we need to do this type
    of debugging.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter covered just a taste of the libraries that have already been ported.
    Every day, more libraries are being ported, as well as languages, that can be
    compiled to WebAssembly.
  prefs: []
  type: TYPE_NORMAL
- en: 'A final note on WebAssembly: while we are still in the very beginnings of this
    technology, we have already seen many advancements. From being able to utilize
    multiple threads to newly supported multiple return values, we are starting to
    see this technology really take off.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to read and write WebAssembly. We also gained
    an understanding of how programs are understood by typical computers. On top of
    this, we wrote a program that is able to utilize this near-native speed. Finally,
    we took a look at an existing WebAssembly program and how that relates to the
    code it was generated from.
  prefs: []
  type: TYPE_NORMAL
- en: By now, we have learned quite a bit about the web development landscape. We
    have looked at coding in the browser and how we can utilize all of the new features
    to create feature-rich web applications. On top of this, we have seen how JavaScript
    can be used as our server-side code utilizing Node.js. Finally, we took a look
    at how to build and deploy our applications. By now, we should be comfortable
    building scalable applications and utilizing many of the modern features to create
    blazing fast applications.
  prefs: []
  type: TYPE_NORMAL
- en: Thank you for reading and I hope that this information helps create the next
    generation of web applications! Keep up with the development of the modern web
    and build the next amazing application!
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For those that are interested, the following link showcases the work that Mozilla
    is doing with WebAsesmbly and how they are really driving the technology forward: [https://hacks.mozilla.org/](https://hacks.mozilla.org/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Other amazing projects that have been created with WebAssembly can be found
    at the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Blazor**: [https://dotnet.microsoft.com/apps/aspnet/web-apps/blazor](https://dotnet.microsoft.com/apps/aspnet/web-apps/blazor)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Unity**: [https://blogs.unity3d.com/2018/08/15/webassembly-is-here/](https://blogs.unity3d.com/2018/08/15/webassembly-is-here/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Qt**: [https://doc.qt.io/qt-5/wasm.html](https://doc.qt.io/qt-5/wasm.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
