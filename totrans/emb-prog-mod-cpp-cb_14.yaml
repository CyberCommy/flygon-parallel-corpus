- en: Guidelines for Safety-Critical Systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The requirements for the code quality of embedded systems are usually higher
    than in other software domains. Since lots of embedded systems work without supervision
    or control expensive industrial equipment, the cost of error is high. It becomes
    even higher in safety-critical systems where software or hardware failure may
    lead to injuries or even death. Software for such systems must follow specific
    guidelines that aim to minimize the chances of bugs not being found during the
    debugging and testing stages.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll explore some of the requirements and best practices
    for safety-critical systems through the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the return values of all functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using static code analyzers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using preconditions and postconditions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring formal validation of code correctness
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These recipes will help you understand the requirements and guidelines for safety-critical
    systems, as well as the tools and methods used for certification and conformance
    testing.
  prefs: []
  type: TYPE_NORMAL
- en: Using the return values of all functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Neither the C nor C++ languages require developers to use the value returned
    by any function. It is totally acceptable to define a function that returns an
    integer and then invoke it in the code, ignoring its return value.
  prefs: []
  type: TYPE_NORMAL
- en: Such flexibility often causes software errors that may be difficult to diagnose
    and fix. Most commonly, it happens for functions returning error code. Developers
    may forget to add error condition checks for functions that are used often and
    rarely fail, such as `close`.
  prefs: []
  type: TYPE_NORMAL
- en: One of the most widely used coding standards for safety-critical systems is MISRA. It
    defines requirements for C and C++ languages—MISRA C and MISRA C++, respectively. 
    A recently introduced Adaptive AUTOSAR defines coding guidelines for the automotive
    industry. It is expected that the Adaptive AUTOSAR guidelines will be used as
    a base for the updated MISRA C++ guidelines in the near future.
  prefs: []
  type: TYPE_NORMAL
- en: 'Both MISRA and AUTOSAR coding guidelines ([https://www.autosar.org/fileadmin/user_upload/standards/adaptive/17-03/AUTOSAR_RS_CPP14Guidelines.pdf](https://www.autosar.org/fileadmin/user_upload/standards/adaptive/17-03/AUTOSAR_RS_CPP14Guidelines.pdf))
    for C++ require developers to use values returned by all non-void functions and
    methods. The corresponding rule is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '"Rule A0-1-2 (required, implementation, automated): The value returned by a
    function having a non-void return type that is not an overloaded operator shall
    be used."'
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to use this rule in our code.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to create two classes that save two timestamps in a file. One
    timestamp indicates when an instance was created, while the other indicates when
    the instance was destroyed. This is useful for code profiling, to measure how
    much time we have spent in a function or any other code block of interest. Follow
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In your working directory, that is, `~/test`, create a subdirectory called `returns`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use your favorite text editor to create a file called `returns.cpp` in the `returns` subdirectory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the first class to the `returns.cpp` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we add the second class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `main` function creates instances of both classes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we create a `CMakeLists.txt` file containing the build rules for our
    program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: You can now build and run the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have now created two classes, `TimeSaver1` and `TimeSaver2`, which look almost
    identical and do identical jobs. Both classes open a file in their constructors
    and call the `Update` function, which writes a timestamp into an open file.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, their destructors invoke the same `Update` function to add a second
    timestamp and close the file descriptor.
  prefs: []
  type: TYPE_NORMAL
- en: '`TimeSaver1`, however, breaks the *A0-1-2* rule and is unsafe. Let''s take
    a closer look at this. Its `Update` function invokes two functions, `time` and
    `write`. Both functions may fail, returning proper error code, but our implementation
    ignores it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, the destructor of `TimeSaver1` closes the open file by calling the `close` function.
    This may also fail, returning an error code, which we ignore:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The second class, `TimeSaver2`, complies with the requirement. We assign the
    result of the time call to the `tm` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If `Write` returns an error, we throw an exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, we throw an exception if `close` returns an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'To mitigate this kind of issue, the C++17 standard introduced a special attribute
    called `[[nodiscard]]`. If a function is declared with this attribute, or it returns
    a class or enumeration marked as `nodiscard`, the compiler should display a warning
    if its return value is discarded. To use this feature, we created a custom wrapper
    around the `write` function and declared it `nodiscard`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see this in the compiler output when we build our application, which
    also means we have the opportunity to fix it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0d3ff757-ae38-48be-b05c-de4b55b2ed2c.png)'
  prefs: []
  type: TYPE_IMG
- en: In fact, the compiler was able to recognize and report another issue in our
    code that we will discuss in the next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we build and run the application, we won''t see any output since all writes
    go to files. We can run the `ls` command to check that the program produces a
    result, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'From this, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bad36a2a-3f7f-40a6-855b-345fba095e31.png)'
  prefs: []
  type: TYPE_IMG
- en: As expected, two files are created by our program. They should be identical,
    but they are not. The file created by `TimeSaver1` is empty, meaning its implementation
    has an issue.
  prefs: []
  type: TYPE_NORMAL
- en: The file generated by `TimeSaver2` is valid, but does that mean that its implementation
    is 100 percent correct? Not necessarily, as we'll see in the next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: More information about the `[[nodiscard]]` attribute can be found on its reference
    page ([https://en.cppreference.com/w/cpp/language/attributes/nodiscard](https://en.cppreference.com/w/cpp/language/attributes/nodiscard)).
    Starting from C++20, the `nodiscard` attribute can include a string literal, explaining
    why the value should not be discarded; for example, `[[nodiscard("Check for write
    errors")]]`.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to understand that compliance with safety guidelines does make
    your code safer, but does not guarantee it. In our implementation of `TimeSaver2`,
    we use the value returned by `time`, but we do not check whether it is valid.
    Instead, we write to the output file unconditionally. Similarly, if `write` returns
    a non-zero number, it can still write less data to the file than requested. Even
    if your code formally matches the guidelines, it may contain related issues.
  prefs: []
  type: TYPE_NORMAL
- en: Using static code analyzers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All safety guidelines are defined as extensive sets of specific requirements
    to the source code or design of the application. Many of these requirements can
    be checked automatically by using static code analyzers.
  prefs: []
  type: TYPE_NORMAL
- en: '**Static code analyzers** are tools that can analyze the source code and warn
    developers if they detect code patterns that violate code quality requirements.
    They are extremely efficient when it comes to error detection and prevention.
    Since they can be run before the code is built, a lot of errors are fixed at the
    earliest stage of development, without involving the time-consuming testing and
    debugging process.'
  prefs: []
  type: TYPE_NORMAL
- en: Besides error detection and prevention, static code analyzers are used to prove
    that the code complies with target requirements and guidelines during the certification
    process.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to use a static code analyzer in our applications.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to create a simple program and run one of the many open source
    code analyzers that are available to check for potential issues. Follow these
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to the `~/test/returns` directory, which we created as part of the previous
    recipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Install the `cppcheck` tool from the repository. Make sure you are under the `root`
    account, not `user`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Change to the `user` account again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Run `cppcheck` against the `returns.cpp` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Analyze its output.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code analyzer can parse the source code of our applications and test it
    against a number of patterns representing bad coding practices.
  prefs: []
  type: TYPE_NORMAL
- en: A lot of code analyzers exist, from open source and free to use to expensive
    commercial products for enterprise use.
  prefs: []
  type: TYPE_NORMAL
- en: The **MISRA** coding standard that was mentioned in *Using the Return Values
    of All Functions* recipe is a commercial standard. This means that you need to
    buy a license to use it and, similarly, buy a certified code analyzer that can
    test code for MISRA compliance.
  prefs: []
  type: TYPE_NORMAL
- en: 'For learning purposes, we will use an open source code analyzer called `cppcheck`.
    It is widely used and already included in the Ubuntu repository. We can install
    it in the same way as any other Ubuntu package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we pass the source filename as a parameter. The check is fast and generates
    the following report:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/659c3b78-ca64-474f-8917-0345f48808e4.png)'
  prefs: []
  type: TYPE_IMG
- en: As we can see, it has detected two issues in our code, even before we have tried
    to build it. The first issue is in our safer, enhanced `TimeSaver2` class! To
    make it comply with A0-1-2 requirements, we need to check for the status code
    returned by `close` and throw an exception if an error occurs. However, we do
    this in a destructor, breaking C++ error handling mechanisms.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second issue that was detected by the code analyzer is a resource leak.
    This explains why `TimeSaver1` generates empty files. When opening a file, we
    accidentally assign the file descriptor to the local variable instead of the instance
    variable, that is, `fd`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can fix them and rerun `cppcheck` to make sure the issues have gone
    and that no new issues are introduced. Using code analyzers as part of the development
    workflow makes your code safer and your performance faster since you can detect
    and prevent issues in the early stages of the development cycle.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Though `cppcheck` is an open source tool, it supports a number of MISRA checks.
    This does not make it a certified tool for the validation of conformance to MISRA
    guidelines but allows you to understand how close your code is to the MISRA requirements
    and how much effort might be needed to make it compliant.
  prefs: []
  type: TYPE_NORMAL
- en: The MISRA check is implemented as an add-on; you can run it according to the
    instructions that can be found in the add-ons section of the GitHub repository
    for `cppcheck` ([https://github.com/danmar/cppcheck/tree/master/addons](https://github.com/danmar/cppcheck/tree/master/addons)).
  prefs: []
  type: TYPE_NORMAL
- en: Using preconditions and postconditions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we learned how to use static code analyzers to prevent
    coding errors at the early stages of development. Another powerful tool for error
    prevention is **programming by contract**.
  prefs: []
  type: TYPE_NORMAL
- en: Programming by contract is a practice in which developers explicitly define
    contracts or expectations for input values of a function or module, its results,
    and intermediate states. While intermediate states depend on implementation, the
    contracts for the input and output values can be defined as part of the public
    interface. These expectations are called **preconditions** and **preconditions**,
    respectively, and help avoid programming errors caused by vaguely defined interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to define preconditions and postconditions
    in our C++ code.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To test how preconditions and postconditions work, we will partially reuse
    the code of the **`TimeSaver1`** class we used in the previous recipe. Follow
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In your working directory, that is, `~/test`, create a subdirectory called `assert`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use your favorite text editor to create a file called `assert.cpp` in the `assert` subdirectory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the modified version of the `TimeSaver1` class to the `assert.cpp` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This is followed by a simple `main` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Put the build rules into the `CMakeLists.txt` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: You can now build and run the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here, we reused some of the code from the `TimeSaver1` class from the previous
    recipe. For simplicity, we removed the `Update` method, leaving only its constructor
    and destructor.
  prefs: []
  type: TYPE_NORMAL
- en: We intentionally kept the same error that was discovered by the static code
    analyzer in the previous recipe to check whether precondition and postcondition checks
    can be used to prevent such issues.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our constructor accepts a filename as a parameter. We do not have any particular
    restrictions on the filename, except that it should be valid. Two obviously invalid
    filenames are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A null pointer as a name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An empty name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We put these rules as preconditions using the `assert` macro:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'To use this macro, we need to include a header file, that is, `csassert`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we use the filename to open the file and store it in the `fd` variable.
    We assign it to the local variable, that is, `fd`, instead of the instance variable, `fd`.
    This is a coding error we want to detect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we put postconditions in the constructor. The only postcondition,
    in our case, is that the instance variable, `fd`, should be valid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Note how we prefix it with this to disambiguate it from local variables. In
    the same way, we add a precondition to the destructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We don't add any postconditions here because after the destructor returns, the
    instance is not valid anymore.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s test our code. In the `main` function, we create an instance of
    `TimeSaver1`, passing an empty filename as a parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'After we''ve built and run our program, we will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bcd001f1-c8c9-4e3f-bd48-a4dbc27177be.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The precondition check in the constructor has detected the violation of contracts
    and terminated the application. Let''s change the filename to a valid one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We build and run the application once again and get a different output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2a162765-e45c-4207-a02c-fe63f35de7c1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, all the preconditions have been met, but we violated the postcondition
    since we failed to update the instance variable, `fd`. Change line 16 by removing
    the type definition before `fd`, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Rebuilding and running the program again yields an empty output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8a57bd09-8c9e-4004-91b6-1a39c806c0e2.png)'
  prefs: []
  type: TYPE_IMG
- en: This indicates that all the expectations for the input parameters and results
    have been met. Even in a rudimentary form, programming using the contract helped
    us prevent two coding issues. That is why this technique is widely used in all
    areas of software development and in safety-critical systems in particular.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: More elaborate support for programming by contract was expected to be added
    to the C++20 standard. However, it has been deferred to a later standard. A description
    of the proposal can be found in the paper *A Contract Design*  ([http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0380r1.pdf](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0380r1.pdf))
    by G. Dos Reis, J. D. Garcia, J. Lakos, A. Meredith, N. Myers, B. Stroustrup.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the formal validation of code correctness
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Static code analyzers and the programming-by-contract methodology help developers
    significantly reduce the number of coding errors in their code. However, this
    is not sufficient in safety-critical software development. It is important to
    formally prove that the design of a software component is correct.
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of fairly complex methods to do this, along with tools to
    automate this process. In this recipe, we will explore one of the tools for formal
    software validation, called CPAchecker ([https://cpachecker.sosy-lab.org/index.php](https://cpachecker.sosy-lab.org/index.php)).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to download and install `CPAcheck` to our build environment, and
    then run it against a sample program. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open a Terminal with your build environment included.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make sure you have root permissions. If not, press *Ctrl* + *D* to exit from
    the *user* session back to the *root* session.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Install the Java runtime:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Switch to the user session and change directory to `/mnt`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Download and unpack the `CPACheck` archive, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Change directory to `CPAchecker-1.9-unix`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Run `CPAcheck` against an example file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Download the example file that intentionally contains a bug:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the checker against the new example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Switch to your web browser and open the `~/test/CPAchecker-1.9-unix/output/Report.html`
    report file that was generated by the tool.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To run `CPAcheck`, we need to install the Java runtime. This is available in
    the Ubuntu repository, and we use `apt-get` to install it.
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to download `CPAcheck` itself. We use the `wget` tool to download
    the archive file and feed it to `tar` utility immediately to extract it. When
    completed, the tool can be found in the `CPAchecker-1.9-unix` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use one of the pre-packaged example files to check how the tool works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'It generates the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ff8fcef6-80fd-45a3-9eed-4785e0e00f6b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can see, the tool has not discovered any issues with this file. There is
    no similar file that contains bugs in the `CPAcheck` archive, but we can download
    it from its site:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We run the tool again and get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ab5c77a6-4eb2-4ef5-8dea-d5ad44974a53.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, the result is different: an error was detected. We can open an HTML report
    generated by the tool for further analysis. Besides logs and statistics, it also
    displays a flow automation graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9fdfd67a-296b-404e-a6e3-ee5065fd6216.png)'
  prefs: []
  type: TYPE_IMG
- en: Formal validation methods and tools are complex and can deal with relatively
    simple applications, but they guarantee the correctness of application logic in
    all cases.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find more information about CPAchecker on its website ([https://cpachecker.sosy-lab.org/index.php](https://cpachecker.sosy-lab.org/index.php)).
  prefs: []
  type: TYPE_NORMAL
