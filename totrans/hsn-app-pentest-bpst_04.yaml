- en: Exploring the Stages of an Application Penetration Test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are going to understand the stages that are involved in
    the application penetration test and get a wide overview of the Burp Suite tool.
    Based on that knowledge, we are going to enumerate and gather information about
    our target.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Stages of an application penetration test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting to know Burp Suite better
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stages of an application pentest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is trivial to understand the stages of an application pentest as it lays
    the groundwork and ensures that the pentester covers all the possible endpoints
    and does an efficient scan. A web application pentest is broadly categorized in
    the following stages:'
  prefs: []
  type: TYPE_NORMAL
- en: Planning and reconnaissance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Client end code analysis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manual testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automated testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploiting discovered issues
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Digging deep for data exfiltration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Taking shells
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reporting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Among these stages, the planning and reconnaissance stage is the most important
    stage, as there are possibilities that a tester might miss out critical entry
    endpoints into the application, and those areas might go untested. Let's explore
    in a little more detail what happens in ...
  prefs: []
  type: TYPE_NORMAL
- en: Planning and reconnaissance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the planning and reconnaissance phase, we define the scope of the penetration
    test. This initial phase requires a lot of planning, and you need to answer questions,
    such as:'
  prefs: []
  type: TYPE_NORMAL
- en: What is the scope of the pentest?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are the restricted URLs?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are the various subdomains in scope?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Are there multiple applications hosted on the same domain in different folders?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Are there any other platforms where this application is hosted (that is, mobile
    applications, web applications, desktop applications, and so on)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once you have answered these questions, you will get some clarity on what is
    to be tested and what's not. Depending on whether it is a black box or a white
    box test, further enumeration takes places. In either of the cases, we will have
    to go ahead and discover all the files and folders of the application in scope
    and identify the endpoints. Later, in the next chapter, we will see how to discover
    new files and folders using Burp.
  prefs: []
  type: TYPE_NORMAL
- en: Client-end code analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Based on the type of test, we can perform code analysis too. For applications
    that are hosted as a part of white box testing, the entire code will be available
    to the tester and he can use custom tools to perform an entire code review and
    find vulnerabilities based on the code logic. Let's say it is a black box and
    code analysis needs to be done. Given a black box scenario, the only code analysis
    that would happen is the client-end code and the JavaScript library references.
    Based on the analysis, a tester can bypass certain validation logic implemented
    by these scripts and enable us to perform certain attacks.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be talking in detail about how we can bypass client-side
    logic by code manipulation. ...
  prefs: []
  type: TYPE_NORMAL
- en: Manual testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is the stage where the tester''s presence of mind helps him find various
    vulnerabilities in the application. In this phase, the attacker manually tests
    for flaws by fuzzing different input fields and checking the application response.
    There are times where a scanner will not be able to find certain vulnerabilities
    and user intervention is much needed, and this is where manual testing prospers.
    Certain vulnerabilities tend to be missed out by automated scanners, such as :'
  prefs: []
  type: TYPE_NORMAL
- en: Various business logic flaws
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Second-order SQL injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pentesting cryptographic parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Privilege escalation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sensitive information disclosures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Various business logic flaws
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Every application has its own set of logic to get some functions done. Business
    logic is generally a set of steps required to get a job completed. Let''s take
    an example where, if a user wants to purchase a product on the shopping site,
    he have to follow a series of steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Select an item
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Specify the quantity of the product
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter delivery information
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter card details
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Complete payment gateway procedures
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Purchase complete
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delivery pending
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delivery complete
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As you can see, a lot of steps are involved and this is where an automated scanner
    fails.
  prefs: []
  type: TYPE_NORMAL
- en: Second-order SQL injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SQL second-order works differently; one page in the web application takes the
    malicious user input and some other function on some other page or some other
    application retrieves this malicious content and parses it as a part of the query.
    Automated scanners are unable to detect such issues. However, Burp has an implemented
    logic that helps an attacker find out SQL second-order vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Pentesting cryptographic parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Applications where information is being sent to third parties, such as endpoints
    from shopping portal to payment gateway information, such as credit card details,
    the information is encrypted by a mutually agreed upon key. An automated scanner
    will not be able to scan such instances. If any endpoint is left exposed accidentally
    by the application, then by manual analysis, the pentester can test these cryptographic
    parameters for vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Exploiting discovered issues
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As discussed earlier, once the application is scanned using automated scanners
    and manual tests, this stage is then progressed. Findings such as SQL injection
    file upload bypass, XXE attacks, and so on, allow an attacker/tester to gain the
    capability to dig further and attack the application to take shells. So, once
    the issues are discovered in this stage, the pentester will go ahead and exploit
    those issues to see the extent to which the information can be extracted. This
    is the phase where an attacker can chain multiple vulnerabilities to see if he
    can cause a bigger bug. There are many submission reports on HackerOne that show
    how testers have chained multiple vulnerabilities that eventually lead to remote
    code execution.
  prefs: []
  type: TYPE_NORMAL
- en: Privilege escalation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Automated scanners do not have knowledge of the levels of roles or access available
    on the application and hence will never be able to spot these vulnerabilities.
    So manual intervention will always be required.
  prefs: []
  type: TYPE_NORMAL
- en: Sensitive information disclosures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The knowledge of an automated scanner to determine if the information is sensitive
    is usually done with the help of a few keywords and a combination of regex, such
    as a credit card regex or a phone number regex. Beyond that it, is all human intervention.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will cover in detail how we can do manual analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Automated testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Automated scanning is a phase carried out on a network and also on the web.
    Automated scanners help find out multiple flaws ranging from input validation
    bypass right up to SQL injection. Automated scanning is required to expedite multiple
    findings in a speedy manner. In automated scanning, the scanner fuzzes all the
    input parameters to find vulnerabilities that range in the OWASP Top 10, especially
    the outdated plugins and versions. It helps find sensitive files such as admin
    logins, as per the dictionary available with them. You should note that the application
    pentest should not be concluded on the basis of the automated scanning practice.
    Manual intervention should always be done to validate the findings. Many a time
    ...
  prefs: []
  type: TYPE_NORMAL
- en: Digging deep for data exfiltration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are times when the user is not able to take shells, or a situation might
    arise where the application might be vulnerable to blind SQL or XXE attacks; so
    what should be done now? Well, in this case, the attacker can still try to exfiltrate
    information using out-of-band techniques or simple techniques. Using these techniques,
    the attacker can exfiltrate a lot of information, such as extracting user credentials
    from the database, reading files via XXE injection, and much more. In later chapters,
    we will see how we can use out-of-band techniques for data exfiltration using
    Burp.
  prefs: []
  type: TYPE_NORMAL
- en: Taking shells
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Well, this is the favorite part of all the pentesters when they feel satisfied
    with the pentesting activities. Once the tester has a shell via any of the vulnerabilities,
    such as SQL, RFI, file upload, LFI combined, and so on, he can then try to see
    if he can elevate his privileges on the server. If he can make himself system
    or root, then it is a complete compromise and the testing can be concluded a complete
    success.
  prefs: []
  type: TYPE_NORMAL
- en: Reporting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once the testing is complete, then comes the most important phase: reporting.
    The reporting has to be done as precisely and elaborately as possible to explain
    to the organization about the vulnerabilities and their impact. This is because
    the organization will only understand the effort of the tester in the form of
    the report presented. You can also add the attacks tested and how the application
    protected against the attacks, giving the organization/developer the sense of
    how strong the application is.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting to know Burp Suite better
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to look at the rich set of features and capabilities
    Burp Suite provides the tester with. We will also be looking at the quick fixes
    that help automate the whole pentesting process with a low number of false positives.
    This will help beginners to understand the awesome capabilities that Burp provides
    when it comes to penstesting applications over the web.
  prefs: []
  type: TYPE_NORMAL
- en: Features of Burp Suite
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Burp Suite has a wide array of options that allow us to do pentesting efficiently.
    Once you open Burp Suite, you will see the following tabs:'
  prefs: []
  type: TYPE_NORMAL
- en: Dashboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Target
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Proxy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Intruder
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Repeater
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sequencer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decoder
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extender
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Project Options
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User Options
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is how it looks on Burp Suite:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2c08205f-b5f6-47f5-844a-6f060735e6fb.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's go ahead and understand all these options one by one so that we are well
    aware of the capabilities from here onward whenever we perform a pentest in the
    later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Dashboard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Burp Suite Dashboard is divided into the following three sections:'
  prefs: []
  type: TYPE_NORMAL
- en: Tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Issue Activity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advisory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Event Log
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This allows the user to have a complete view of what is happening when the
    tester runs an automated scan. The Dashboard looks like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5560f55b-f30f-4d11-982d-ad065d4641ef.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Tasks option, the tester can click on New scan and specify the website
    to be scanned. Along with the website name, there are other options, such as configuring
    the scan settings. Once you click on the New scan button, you will see a screen
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2f4e4f14-5787-49d6-a954-20925a08f49d.png)'
  prefs: []
  type: TYPE_IMG
- en: The ...
  prefs: []
  type: TYPE_NORMAL
- en: Target
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The **Target** tab allows you to view the entire site map of the application
    that is in scope. It shows the user all the folders and files detected on the
    application along with the building logic. There are a lot of additional features
    in the Target tab as well. Mapping can take place in two ways; one is by manual
    browsing and the other is by an automated crawler. If the tester is doing manual
    browsing, turn off the proxy intercept and browse the application. As the requests
    and responses for different pages keep populating in Burp Suite, the Target tab
    populates the detected structure as is. This allows the user to get an idea of
    how the application looks and the folder and file naming convention across the
    entire application. Well, as we know, instead of a manual approach on a huge website
    that has a lot of pages, the most suitable option to use an automated crawler,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a04159ef-0d7e-4e41-8040-07358a8df842.png)'
  prefs: []
  type: TYPE_IMG
- en: You can see in the Target tab that there are three subsections, **Site map**,
    **Scope**, and **Issue definitions**. Let's check what features the **Scope**
    tab offers. The **Scope** tab offers two key features; one is what web URLs to
    include in the scope and the other is what web URLs to exclude from scope.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, the tester can either enter a particular folder of a web URL, or the
    entire URL itself if the scope is the main URL. For example, let''s say the application
    to be tested is on [www.website.com/pentesting/](http://www.website.com/pentesting/),
    then the scope can be restricted to the pentesting folder only. If it is the entire
    website, then you can enter the website name itself, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/55e4c952-40ed-43a2-ab50-fe5c2241e15f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To add a URL, simply click on **Add** and enter the URL or the URL with the
    folder path. Once the user clicks **Add**, they will see a screen like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0fc9d353-4e37-4e96-8bd5-af4b8d5080c8.png)'
  prefs: []
  type: TYPE_IMG
- en: Similarly, **Exclude from scope** ensures that no tests or additional requests
    are sent to the **Exclude from scope** URLs. This is efficient when there are
    certain folders within the application that could be sensitive pages, such as
    the forgotten password feature or register feature.
  prefs: []
  type: TYPE_NORMAL
- en: 'When testing on a production environment, if that is included in the tests,
    then there will be a lot of spam, and clearing such information would be tedious
    and not appreciated by the client. Therefore, ensure to use this feature. The
    other way to do this is by right-clicking on the particular file and selecting
    if you want to exclude or include it in the scope. For example, if something needs
    to be included in the scope, it can be done as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c63a37fa-1a4d-455c-baf2-97fd23192a19.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you need to exclude a particular path or a file from scope, it can be done
    by right-clicking on the URL and selecting **Remove from scope**, as shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b85aedb0-d985-4cea-aa21-b1c5026c5a6a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'There is an advanced scope control feature as well. When you enable it in the
    Scope tab, it gives you the capability to enter the type of protocol, that is
    HTTP or HTTPS, and then the IP/IP range, along with the port number and file,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/52c14aef-fe74-4e40-ab45-4bf5259683db.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The issue definition contains all the definitions of all the vulnerabilities
    that can be detected by Burp. This gives us a great of idea of the rich detection
    of capabilities Burp Suite to find so many vulnerabilities, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/433bff9c-a1e3-4cbf-b52e-6dbdf11194c5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Burp also provides filters in the site map determining what is to be shown
    and what needs to be hidden. For example, how the request should be filtered,
    then the MIME types to be shown, followed by status code. There are other options,
    such as filter by search term, by extension, and by annotation. These are pretty
    self-explanatory and can be configured as per the user''s requirement as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b80d3466-2e58-48bd-b4cd-fc562afb2b08.png)'
  prefs: []
  type: TYPE_IMG
- en: This helps in getting a very clear picture of the sitemap.
  prefs: []
  type: TYPE_NORMAL
- en: Proxy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is the heart of the entire tool; everything that happens on Burp Suite
    happens via this place. The Proxy tab allows you to intercept the request and
    play with it by editing and sending it to repeater, intruder, or any of the Burp
    testing modules. This is the place where you can take a decision as to what the
    tester wants to do with the request. The **Proxy** tab is shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ee58d178-af24-4e0d-8295-e36300ca1c50.png)'
  prefs: []
  type: TYPE_IMG
- en: Once a request is intercepted, it can be viewed in different ways. The options
    available for a simple HTTP request are Raw, Params, Headers, and Hex. Based on
    the type of request, if it is a web socket request, then a web Socket tab will
    ...
  prefs: []
  type: TYPE_NORMAL
- en: Intruder
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is the core functionality of the application. This feature of Burp allows
    the user to automate the process that a user wants. The automation is used to
    perform attacks against web applications. This feature is highly customizable
    and can be used for various tasks, ranging from brute-force, right up to exploiting
    SQL injections and OS command injection, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fca804ba-a9fd-45b2-a39b-8a5ec7df8c27.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The Intruder has four subtabs, which are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Target**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Positions**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Payloads**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Options**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The **Target** tab shows the IP and port that the request is being sent to,
    along with the **Start attack** button. This button is clicked once and the setup
    for the particular request to be tested is done, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/792a5c3e-116d-4000-8ff5-a1bd84416d5f.png)'
  prefs: []
  type: TYPE_IMG
- en: The **Positions** tab in the **Intruder** is where the payload locations are
    selected. As seen in the following screenshot, the **Value** parameter of the
    `txtUsername` and `txtPassword` are highlighted. The **Add** button adds the delimiter;
    anything that is between two of those delimiters becomes one attack point. As
    we can see in the sample request, there are two locations where the automation
    needs to be done. The **Clear** button removes all the injection points from the
    request, and the **Auto** button adds all the parameters Burp highlights that
    can be attacked.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most interesting thing in this tab is the attack type. Burp supports four
    differentattack types:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Sniper**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Battering Ram**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pitchfork**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Clusterbomb**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/cb690b42-67e4-4a18-be99-6a764fdb1189.png)'
  prefs: []
  type: TYPE_IMG
- en: Let us understand the attack types in a bit more detail.
  prefs: []
  type: TYPE_NORMAL
- en: '**Sniper**: Sniper support a single set of payloads. What it will do is send
    one payload at a time. So let''s say there is one position that we wish to fuzz, then
    sniper is the best fit for that attack automation. It will not be efficient with
    two attack points because Sniper will send only a payload to the first attack
    point. Once the payload set is exhausted, it will send the payloads to the second
    attack point, leaving the first point to default. Sniper is always selected for
    a single input attack point. If we use Sniper in the preceding screenshot, it
    will first fuzz the username, keeping the password as `admin`, and then fuzz the
    password field, keeping the username field received in default in the request
    that is an admin.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Battering Ram**: Battering Ram also uses a single set of payloads. The interesting
    thing here is Battering Ram passes the same payload at multiple locations. This
    means that once the payload list is specified, it will send the first payload
    value in all the marked positions that are required to be fuzzed, and so on until
    the last payload. The number of payloads generated is equal to the payloads provided,
    irrespective of the fuzzing positions.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Pitchfork**: This attack uses multiple sets of payloads. Let''s say we have
    marked two places for fuzzing, similar to the preceding screenshot, and two payload
    sets are given; one is a username and the other is a password. When the attack
    is initiated, the first payload from the payload set is set in the first position,
    and the first payload in the second payload set is set in the second position,
    and the attack increments accordingly. The total number of attacks will be equal
    to the payload set with the least number of payloads.'
  prefs: []
  type: TYPE_NORMAL
- en: '**ClusterBomb**: This attack uses multiple sets of payloads. It is a complete
    permutation combination of all the payload positions. Let''s say there are two
    payload positions, username and password, and two different payload sets, username
    set, and password set. The attack happens in such a way that the first payload
    for position 1 is tested along will all the payload sets of position 2\. Once
    that is exhausted, then the second payload is set in position 1 and all the payloads
    from the second set are tested against that. So, in all, the total number of requests
    generated will be the product of the number of payloads in the payload sets. So,
    let''s say we have 10 payloads for position 1 and 10 payloads for position 2:
    the total number of requests that will be sent will be 100.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The next tab is the **Payloads** tab. It contains four different settings,
    which are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Payload Sets**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Payload Options**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Payload Processing**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Payload Encoding**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Payload Sets**: **Payload Sets** allows you to specify what type of payloads
    are to be entered at what payload position.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Payload Options**: This setting allows you to set the payloads. The tester
    can either set it from the available Burp list if it is a Professional edition
    or else load a custom set of files with the **Load ...** option, as shown in the
    following screenshot'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b753aa4a-1664-48fc-85af-1663bb39f97a.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Payload Processing**: This setting allows the user to perform different tasks
    for processing each payload before it is used. The rules, as shown in the following
    screenshot, can be configured before starting the attack:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3fa0e2dc-b46d-4519-86dc-c29996432969.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Payload Encoding**: This setting allows the auto encoding to be set to on
    or off with the help of the checkbox. The user can specify which characters need
    to be URL-encoded before being sent for the test, as per the dependency of the
    application being tested, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7d955a60-36a5-48a8-9b66-dd19d89c3502.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The last tab is the **Options** tab that allows the tester to configure other
    settings for the automation of attacks. It contains the following settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Request Headers**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Request Engine**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Attack Results**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Grep Match **'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Grep Extract**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Grep Payloads**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Redirections**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/68d074c8-c8aa-4c37-8800-6ff61c93e9b5.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Request Headers**: This setting allows the user to automatically **Update
    Content-Length header** based on the length of the payload, and also set the header
    of **Set Connection: close** so as to not utilize the resources of the application
    by putting it in a wait state.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Request Engine**: The Request Engine allows the user to control the speed
    of testing by specifying the number of threads to be used, the number of retries
    to be done on a network failure, pausing, throttling, and so on, as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d90564fc-08d7-4543-a9b4-20b70e098ec9.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Attack Results**: This setting allows the tester to select what information
    is to be captured based on the attack results.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Grep-Match**: This setting allows the user to get certain fields highlighted
    to give a quick view of a particular expression being invoked. For example, if
    a user is logged in successfully, there would be logout options, so if the user
    adds the expression logout here and enables this setting, then the request will
    be highlighted and easy to spot, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5413ccbe-5a87-45f8-a21e-438cde505812.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Grep Payloads**: This setting is used to flag results containing the same
    value as the submitted payload.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Redirections**: This setting tells Burp what to do in case of redirection
    being detected on sending requests.'
  prefs: []
  type: TYPE_NORMAL
- en: Repeater
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Repeater** allows the tester to submit the same request recursively by making
    modifications to it and checking how the server responds. Let''s say the tester
    is testing for an SQL injection or command injection flaw on one parameter of
    a particular request. The tester can capture the request in **Proxy** and send
    it to **Repeater**, manipulate the parameter and send it to the server check response,
    manipulate it again, and check the response. It''s like a manual debugger. Check
    the following screenshot for a clear understanding of the first request, which
    is a simple login request:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/88fd12f6-1c19-468e-aa23-e7955ed9747e.png)'
  prefs: []
  type: TYPE_IMG
- en: It responds with **OK**. However, if I change the value of the username ...
  prefs: []
  type: TYPE_NORMAL
- en: Comparer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Burp Comparer is a Burp feature used for comparing differences based on the
    word or byte comparison. The comparison can be used in a lot of conditions. For
    example, let''s say the user wants to compare the difference on a successful and
    a failed login response. Comparer would show the areas where there are byte differences.
    One of the other uses that we can think of is for testing SQL injection to see
    the difference. There are two types of comparison. To send responses to the Comparer,
    simply right-click on the response and **Send to Comparer**. For reference, have
    a look at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8ce39d9b-aeef-49ce-8059-a9a8c12557ea.png)'
  prefs: []
  type: TYPE_IMG
- en: 'For clarification, we have sent two different responses to Comparer: one of
    a successful login and another for an unsuccessful login. The **Comparer** toolbar
    would look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/59e39ceb-a268-4e2b-a7d8-03fd5e12dabc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The tester can then select one response from item 1 and another response from
    item 2, and click on **Compare by words**, and **Compare by bytes**. The tool
    will do a word-to-word comparison and show the differences like deletion, modification,
    and addition, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1829a014-2a63-4800-9068-680cd6abcd22.png)'
  prefs: []
  type: TYPE_IMG
- en: The comparison is shown in a color-coded scheme, as we can see in the preceding
    screenshot for **Modified**, **Deleted**, and **Added**.
  prefs: []
  type: TYPE_NORMAL
- en: Sequencer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Sequencer** is used for analyzing session cookies, CSRF tokens, and password
    reset tokens for randomness. We will be talking in more detail about this when
    we perform an analysis of **Session** tokens with the help of **Sequencer**.'
  prefs: []
  type: TYPE_NORMAL
- en: For more information on Burp Suite Sequencer, please visit [http://www.preflexsol.com/burpsuite.shtml](http://www.preflexsol.com/burpsuite.shtml)
  prefs: []
  type: TYPE_NORMAL
- en: Decoder
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This Burp utility allows the tester to Encode, Decode, and Hash data as and
    when encountered over the application. There are different types of encoders and
    hashes supported, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Encoders/Decoders | Plain | URL | HTML | Base64 | ASCII hex | Hex | Octal
    | Binary | Gzip |'
  prefs: []
  type: TYPE_TB
- en: 'The following is an example of base64 encoding the string password using the
    **Encode as ...** an option in the decoder:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8ff81d80-678f-4a44-9ff8-e23883e50cb5.png)'
  prefs: []
  type: TYPE_IMG
- en: There are quite a few types of hashes supported, ranging from SHA to SHA3-512,
    and then MD5, MD2, and so on. Play around with the decoder as it will be a really
    handy utility during pentests.
  prefs: []
  type: TYPE_NORMAL
- en: Extender
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This capability of Burp allows the tester to use different extensions written
    by independent people that serve as an add-on to the Burp features. Burp is very
    scalable; a user can even write his own code to create a Burp extension and embed
    it to take more advantage of Burp. In order to avail the full advantage of the
    extensions, the user has to provide a path to the Jython and JRuby JAR files.
    We will shortly see how to do that. Let''s look at the following Burp Extender
    page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cb75cfe3-6930-4a4f-8968-df53df88a0da.png)'
  prefs: []
  type: TYPE_IMG
- en: In the Extender section, go to the **Options** page and provide a path to the
    downloaded Jython JAR file. Jython JAR can be downloaded from [http://www.jython.org/downloads.html
    ...](http://www.jython.org/downloads.html)
  prefs: []
  type: TYPE_NORMAL
- en: Project options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Project options are similar to user options, but this tab stays specific to
    a particular project that is started. It contains the following subtabs:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Connections**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**HTTP **'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SSl **'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sessions**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Misc**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/053d8a03-d0e8-4926-8474-d7571f32e73e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The **Connections** tab contains a list of the following items:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Platform Authentication**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Upstream Proxy Server**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SOCKS Proxy**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****Timeouts****'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hostname Resolution**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****Out-of-Scope Requests****'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/cac0edbd-4707-439d-9d27-e3806e447486.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Platform Authentication**: **Platform Authentication** includes the authentications
    that are present usually before a user can access the application (for example,
    HTTP authentication, NTLMv1, NTLMv2 authentication, digest authentication, and
    so forth). So if the configuration is not done in the **User Options** tab, the
    setting can be used here. We will see in detail in the **User Options** menu the
    different options that are available.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Upstream Proxy Server**: Let''s say that in an organization, to access a
    particular application there needs to be a proxy configured. However, since we
    are redirecting the traffic to Burp as our proxy, how will the user redirect the
    request to a particular application via the organization proxy? This is where
    the Upstream Proxy Server comes into play. The Upstream Proxy Server allows you
    to configure the proxy for the organization, so that the request can be sent to
    the particular application that resides behind the proxy.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Timeouts**: There are a lot of requests that Burp sends to the application
    while performing testing. But how does it understand whether the request is complete
    or not, should it wait until the time the server responds, or what if there is
    a condition the server cannot access, or a response that is not available for
    some particular request? All the threads available for testing by Burp might just
    end up being utilized and in a wait state. Hence, the timeout feature, where the
    user can specify when to terminate a particular request based on the scenario.
    As we see in the following screenshot, there are four different types of timeout.
    Normal, open-ended responses, domain name resolution, and failed domain name resolution:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/35733913-3fa7-426a-89b3-346370d309fb.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Hostname Resolution**: Let''s say there is a scenario where the user wants
    to give an alias to a particular application hosted on a particular IP. Usually
    the DNS resolution happens in the hosts file or the DNS server level. Burp also
    gives the user the capability to specify, such that the user can say that `127.0.0.1` resolves
    to pentest in this configuration, and when the user enters `http://pentest/`,
    the localhost content will be shown. This kind of configurations can be done in
    the **Hostname Resolution** page.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Out-of-Scope Requests**:  Burp provides a feature that will prevent any out-of-scope
    requests being issued from Burp. The two features made available are to drop all
    the out-of-scope requests or to use the scope defined in the **Target** tab.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The next sub tab in **Project** options is **HTTP**. This contains all the
    settings pertaining to HTTP if not already configured in the user options section.
    The **HTTP** tab looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a8e75cce-71f9-4239-81f4-1ed7c56d5423.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The **HTTP** tab contains the following three settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Redirections **'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Streaming Responses**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Status 100 Requests**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Redirections**: In Burp, these settings allow the types of redirections that
    Burp should consider and process accordingly.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Streaming Responses**: These settings are used to specify URLs returning
    responses that stream indefinitely. What Burp will do is pass these responses
    directly through to the client.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Status 100 Responses**: With this setting, the user can control the way Burp
    handles the HTTP responses with status 100\. The user can either select to understand
    the response 100 or else remove 100 continue headers.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The next tab is the **SSL** tab. Here all the SSL-related configuration for
    the particular project can be set if not already configured in the **User Options**
    tab, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9ac68b05-9cda-40f7-8307-98eecdebf4d7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following three options are available:'
  prefs: []
  type: TYPE_NORMAL
- en: '**SSL Negotiation **'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Client SSL Certificates**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Server SSL Certificates**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SSL Negotiation**: There are often times when the user is not able to see
    the application because of **SSL Negotiation** errors. This is where the user
    can specify a specific negotiation to take place by manually saying which cipher
    to use. If you click on Use custom protocols and ciphers, the user gets a list
    of all the ciphers available and then can deselect the ones causing errors and
    then access the application, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6375465d-1c60-4dac-86d1-8d0586de32d7.png)'
  prefs: []
  type: TYPE_IMG
- en: If it still doesn't work, then there are workaround options available as well.
    The user can elect to automatically select compatible SSL parameters on negotiation
    failure or allow usage renegotiation, or even disable an SSL session.
  prefs: []
  type: TYPE_NORMAL
- en: '**Client SSL Certificates**: There are times when the application requires
    a specific certificate otherwise, content to the application is not rendered.
    These are also known as Client SSL Certificates. Burp provides a feature where
    a user can add a client certificate so that whenever the host requests it, it
    can be sent to the host. The **Client SSL Certificates** tab looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0517e814-4915-4c79-a922-55899dce2f76.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Server SSL Certificates**: This panel shows a list of unique SSL certificates
    received from web servers. The item can be double-clicked to view the entire certificate.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next is the **Sessions** tab, which handles all the session-related information
    for that particular project. There are three different settings available in the
    **Sessions** tab, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Session Handling Rules**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cookie Jar**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Macros**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/b6624e5b-f274-42f9-a72c-93b08a2d2d35.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Session Handling Rules**: Session rules allow the user to make Burp perform
    certain tasks for every HTTP request. Each rule has a defined scope and the definitions
    are available once the user clicks on the **Add** button of the **session handling
    rules** setting. There are many actions that can be done, such as adding session
    cookies, logging into the application, checking session validity, and so on. The
    following screenshot shows the definitions that are available in the session handling
    rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a98be63c-1df5-4a4d-a5ba-e44c475053d2.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Cookie jar**: Burp stores all the cookies issued by the website in a cookie
    jar. Session handling rules make use of these cookies and even update them to
    maintain the valid session with the application. Here, the tester can select from
    where all the cookies are supposed to be taken and maintained, namely **Proxy**,
    **Scanner**, **Repeater**, **Intruder**, **Sequencer**, and **Extender**.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Macros**: In simple terms, macros are like a set of sequences of more than
    one request. They can be used within session handling or performing things such
    as obtaining Anti-CSRF tokens. We will learn about this in more detail when we
    talk about Burp and its macros.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The next tab is the **Misc** tab, which contains all the miscellaneous settings
    for the particular project settings. The  following screenshot shows the **Misc**
    tab:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0bce0d73-e8fc-4873-a3dd-58f561408080.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following three main settings are available in **Misc**:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Scheduled Tasks **'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Burp Collaborator Server**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Logging**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scheduled Tasks**: In the scheduled task section, the user can specify a
    specific activity to be done mainly pertaining to the execution scheme. The user
    can select to pause or resume execution at a particular time so as to ensure timing
    constraints. The setting is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c676ec34-5a72-485c-8fb9-d0f02ec5e766.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Burp Collaborator Server**: Burp collaborator is an external service that
    is used to fetch out-of-band type vulnerabilities. Burp has a default collaborator
    server, but if the user wants he can configure his own collaborator server using
    this setting and can use the **Run Health Check** option to understand if it has
    been correctly configured. We will be looking at Burp collaborator in more detail
    when we talk about **Out-of-Band Injection** attacks.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Logging**: This is simple and straightforward. This setting allows the user
    to control the logging of HTTP requests. The user can select requests and responses
    from which part of the tools needs to be logged.'
  prefs: []
  type: TYPE_NORMAL
- en: This covers the **Project** **options** parts. Most of the time during a scan,
    these are not altered unless and until a special configuration is required, and
    hence it is good to have knowledge of all these settings to better understand
    what to do when a scenario arises. Let's move on to the next tab, the **User options**
    tab.
  prefs: []
  type: TYPE_NORMAL
- en: User options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **User options** tab contains all the settings a user can configure for
    Burp to run by default every time it is started. Most of the settings are similar
    to the ones seen in the **Project** **options**; the only difference is that this
    is a permanent configuration every time Burp is run, whereas the **Project options**
    are configured only when the project has special requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following four tabs are available in the **User options**:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Connections**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SSL **'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Display**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Misc**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/aa4d09e7-a2a9-44a6-8f5f-11b322fc27ae.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s look at the following screenshot to see the available settings for the **Connections**
    tab:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Connections** tab has the following set of options:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Platform Authentication  ...**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reconnaissance and file discovery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this module, we are going to see how to do reconnaissance to detect files
    and folders in the application via Burp. This phase is important because it helps
    in mapping the entire site structure, since there could be certain folders that
    aren't available via site hyperlinks but are at times available on the application.
    Often people end up finding a lot of sensitive folders and files hosted on the
    web application under the scope. The capability to detect such files and folders
    totally depends upon the strength of the wordlist available. Let us go ahead and
    see how we can do this using Burp Suite.
  prefs: []
  type: TYPE_NORMAL
- en: Using Burp for content and file discovery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this module, we are going to use **OWASP BWA** and do a discovery of all
    the files and folders in the set of applications available. We will see how to
    configure and set up the necessary parameters over Burp to perform a content discovery.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start the OWASP BWA VM and note down the IP address, access the application
    in a browser, and check your sitemap in Burp Suite. It should look something like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b46e2e2e-84dd-482d-8093-532232ed726d.png)'
  prefs: []
  type: TYPE_IMG
- en: Go ahead and right-click on the URL address, then select Engagement tools, and
    then click on Discover content. It will show you the different sets of parameters
    that you can specify to begin the automated ...
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a quick summary, we have seen the different stages of an application pentest
    and we will now start looking at the different vulnerabilities and how we can
    use Burp to find those vulnerabilities. Along with this, we have also seen the
    different functions available in Burp and what configurations are made available
    to the user to easily use the proxy interception.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter we will be planning the approach to application penetration
    testing
  prefs: []
  type: TYPE_NORMAL
