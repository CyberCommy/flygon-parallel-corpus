- en: Chapter 11. Inheritance in Kotlin
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will get to see inheritance in action. In fact, we have
    already seen it, but now we will examine it more closely, discuss the benefits,
    and write classes that we can inherit from. Throughout the chapter, I will show
    you several practical examples of inheritance, and at the end of the chapter we
    will improve our naval battle simulation from the previous chapter and show how
    we could have saved lots of typing and future debugging by using inheritance.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: '**Object-oriented programming** (**OOP**) and inheritance'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using inheritance with open classes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overriding functions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A bit more about polymorphism
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Abstract classes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inheritance example app
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To get started, let's talk a little more about the theory.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: OOP and inheritance
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen how we can reuse our own code, and other people's code, by instantiating/creating
    objects from classes. But this whole OOP thing goes even further than that.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: What if there is a class that has loads of useful functionality in it, but is
    not exactly what we want? Think about when we wrote the `Carrier` class. It was
    so close to the `Destroyer` class that we could have almost copy-and-pasted it.
    We can **inherit** from a class, and then further refine or add to how it works
    and what it does.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: 'You might be surprised to hear that we have done this already. In fact, we
    have done this with every single app we have created. When we use the `:` syntax,
    we are inheriting. You may recall this code from the `MainActivity` class:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, we are inheriting from the `AppCompatActivity` class all its functionality
    – or, more specifically, all the functionality that the designers of the class
    want us to have access to.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: 'We can even override a function and still rely, in part, on the overridden
    function in the class we inherit from. For example, we overrode the `onCreate`
    function every time we inherited the `AppCompatActivity` class. But we also called
    on the default implementation provided by the class designers when we did this:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Tip
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `super` keyword refers to the super class, which is a class that has been
    inherited from.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: And, in [Chapter 6](ch06.html "Chapter 6. The Android Lifecycle"), *The Android
    Lifecycle*, we overrode many more of the `Activity` class' lifecycle functions.
    Note that you can have more than one level of inheritance, although good design
    usually suggests that there are not too many levels. As an example, I have already
    mentioned that `AppCompatActivity` inherits from `Activity,` and we, in turn,
    have inherited from `AppCompatActivity`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: With this in mind, let's look at some example classes and see how we can extend
    them, just to see the syntax, as a first step, and to be able to say we have done
    it.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Using inheritance with open classes
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some terminology that would be useful to learn at this point is that the class
    that is inherited from is known as the **super** or **base** class. Other common
    ways to refer to this relationship is **parent** and **child** class. The child
    class inherits from the parent class.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: By default, a class cannot be inherited from. It is called a **final** class
    – not open for extending or inheriting from. It is very straightforward, however,
    to change a class so it can be inherited from. All we need to do is add the `open`
    keyword to the class declaration.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Basic inheritance examples
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Look at this next code, which uses the `open` keyword with the class declaration
    and enables the class to be inherited from:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Tip
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All the examples from this chapter can be found as completed classes in the
    `Chapter11/Chapter Examples` folder.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now go ahead and create objects of the `Soldier` type and call the `shoot`
    function, as in this next code:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The preceding code would still output `Bang bang bang` to the logcat window;
    we don''t have to inherit from it to use it. If we want to refine or specialize
    our use of the `Soldier` class, however, we could create a specialized type of
    `Soldier` and inherit the `shoot` function. We could create more classes, perhaps
    `Special Forces` and `Paratrooper`, and use the `:` syntax to inherit from `Soldier`.
    What follows is the code for a `SpecialForces` class:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Notice the use of the colon to indicate inheritance. It also adds a `sneakUpOnEnemy`
    function.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, consider the following code for a `Paratrooper` class:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The preceding code also makes `Paratrooper` inherit from `Soldier`, and it adds
    a `jumpOutOfPlane` function.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how we can use these two new child classes:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the preceding code, we instantiated a `SpecialForces` instance and a `Paratrooper`
    instance. The code demonstrates that both instances have access to the `shoot`
    function in the base class, and both classes have access to their own specialized
    functions. The output from the code would be as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: There is even more to inheritance than this. Let's look at what happens when
    we need to further refine the functionality of the base/super class.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: Overriding functions
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Overriding functions is something we have done already, but we need to discuss
    it further. We have overridden the `onCreate` function in every app we have written,
    and in [Chapter 6](ch06.html "Chapter 6. The Android Lifecycle"), *The Android
    Lifecycle*, we overrode many more of the functions from the `AppCompatActivity`
    class.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider that we might want to add a `Sniper` class. At first this might seem
    simple. Just code a class, inherit from `Soldier`, and add a `getIntoPosition`
    function, perhaps. What if we wanted to make the `Sniper` class shoot differently
    to the regular `Soldier`? Look at this code for a `Sniper` class, which overrides
    the `shoot` function and replaces it with a specialized version for the `Sniper`
    class:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You might be tempted to think the job was complete, but this causes a small
    problem. There is an error in the `Sniper` class, as shown in this next screenshot:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '![Overriding functions](img/B12806_11_01.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
- en: 'The error is because the `shoot` function was not written to be overridden.
    By default, functions are final, just like classes are. This means that the child
    class must use it as it is. The solution is to go back to the `Soldier` class
    and add the `open` keyword in front of the `shoot` function declaration. Here
    is the updated code for the `Soldier` class with the subtle, but vital, addition
    highlighted:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now we have fixed the error and can write the following code to instantiate
    the `Sniper` class and use the overridden `shoot` function:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This produces the following output:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We can see that the overridden function has been used. It is also interesting
    to note that, even though the child class has overridden a function from the parent
    class, it can still use the function from the parent if it wants to. Consider
    what might happen if the sniper ran out of ammo for his sniper rifle and needed
    to switch to his other weapon. Look at this reworked code for the `Sniper` class:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the new version of the `Sniper` class, there is a new property called `sniperAmmo`,
    and it is initialized to `3`. The overridden `shoot` function now uses a `when`
    expression to check whether `sniperAmmo` is above zero. If it is above zero, then
    the usual text is printed to the logcat window and `sniperAmmo` is decremented.
    This means that the expression will only return true three times. The `when` expression
    also handles what happens when it is false, and calls `super.shoot()`. This line
    of code calls the version of the `shoot` function from `Soldier` – the super class.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now try calling the `shoot` function on a `Sniper` instance four times,
    like in the following code, and observe what happens:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This is the output we get from the preceding code:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We can see that the first three calls to `sniper.shoot()` gets output from the
    overridden `shoot` function in the `Sniper` class, and the fourth still calls
    the overridden version, but the `false` branch of the `when` expression calls
    the super class version of `shoot` and we get the output from the `Soldier` class.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A working project based on the examples used so far for inheritance can be found
    in the `Chapter11` folder of the code download. It is called `Inheritance Examples`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Summary so far
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As if OOP were not useful enough already, we can now model real-world objects.
    We have also seen that we can make OOP even more useful by subclassing/extending/inheriting
    from other classes.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As usual, we might find ourselves asking this question about inheritance: why?
    The reason is something like this: if we write common code in the parent class,
    then we can update that common code, and all classes that inherit from it will
    also be updated. Furthermore, we can aid encapsulation with visibility modifiers
    because a subclass only gets to use public/protected instance variables and functions,
    and only gets to override open functions. So, designed properly, this also further
    enhances the benefits of encapsulation.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: More polymorphism
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We already know that polymorphism means many forms, but what does it mean to
    us?
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: 'Boiled down to its simplest, it means the following:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Any subclass can be used as part of code that uses the super class.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: This means that we can write code that is easier to understand, and simpler
    to change.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: Also, we can write code for the super class and rely on the fact that no matter
    how many times it is subclassed, the code will still work within certain parameters.
    Let's discuss an example.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: Suppose that we want to use polymorphism to help write a zoo management app.
    We will probably want to have a function, such as `feed`. Let's also say we have
    `Lion`, `Tiger,` and `Camel` classes, which all inherit from a parent class called
    `Animal`. We will also probably want to pass a reference to the animal to be fed
    into the `feed` function. This might seem like we need to write a feed function
    for each and every type of `Animal`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, however, we can write polymorphic functions with polymorphic arguments:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The preceding function has `Animal` as a parameter, which means that any object
    that is built from a class that inherits from `Animal` can be passed into it.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: So, you can even write code today and make another subclass in a week, month,
    or year, and the very same functions and data structures will still work.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: Also, we can enforce upon our subclasses a set of rules as to what they can
    and cannot do, as well as how they do it. So, clever design in one stage can influence
    it at other stages.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: But will we ever really want to instantiate an actual `Animal`?
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: Abstract classes and functions
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An abstract function is a function that is declared with the `abstract` keyword.
    No problem so far. However, an abstract function also has no body at all. To be
    clear, an abstract function has no code in it. So, why would we ever want to do
    this? The answer is that when we write an abstract function, we force any class
    that inherits from the class with the abstract function to implement/override
    that function. Here is a hypothetical abstract function:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: No body, no code, not even empty curly braces. Any class that wants to inherit
    from that class must implement the `attack` function with precisely the signature
    of the preceding declaration.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: An `abstract` class is a class that cannot be instantiated – cannot be made
    into an object. So, it's a blueprint that will never be used then? But that's
    like paying an architect to design your home and then never building it! You might
    be saying to yourself, "I kind of got the idea of an abstract function, but abstract
    classes are just silly."
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: If the designer of a class wants to force the user of a class to inherit before
    using their class, they can declare a class as `abstract`**.** Then, we cannot
    make an object from it; therefore, we must inherit from it first and make an object
    from the subclass.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an example. We make a class `abstract` by declaring it with
    the `abstract` keyword, like this:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Yes, but why?
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes we want a class that can be used as a polymorphic type, but we need
    to guarantee it can never be used as an object. For example, `Animal` doesn't
    really make sense on its own.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: We don't talk about animals, we talk about *types* of animals. We don't say,
    "Ooh, look at that lovely fluffy, white animal," or, "Yesterday we went to the
    pet shop and got an animal and an animal bed." It's just too, well, *abstract*.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: So, an `abstract` class is kind of like a template to be used by any class that
    inherits from it.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: We might want a `Worker` class and extend this to make `Miner`, `Steelworker`,
    `OfficeWorker`, and, of course, `Programmer`. But what exactly does a plain `Worker`
    do? Why would we ever want to instantiate one?
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: The answer is that we wouldn't want to instantiate one, but we might want to
    use it as a polymorphic type so that we can pass multiple worker subclasses between
    functions and have data structures that can hold all types of `Worker`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: We call this type of class an abstract class, and when a class has even one
    abstract function, it must be declared abstract itself. All abstract functions
    must be overridden by any class that inherits from it.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: This means that the abstract class can give some of the common functionality
    that would be available in all its subclasses. For example, the `Worker` class
    might have the `height`, `weight`, and `age` properties.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: It might also have the `getPayCheck` function, which is not abstract and is
    the same in all the subclasses, but a `doWork` function, which is abstract and
    must be overridden, because all the different types of worker `doWork` very differently.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Classes using the Inheritance example app
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have looked at the way we can create hierarchies of classes to model the
    system that fits our app. So, let's build a project to improve upon the naval
    battle we had in the previous chapter.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: Create a new project called `Basic Classes with` `Inheritance Example` using
    the Empty Activity template. As you have come to expect, the completed code can
    be found in the `Chapter11` folder.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what we are going to do:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Put most of the functionality of the `Carrier` and `Destroyer` classes into
    a `Ship` super class.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inherit from the `Ship` class for both `Carrier` and `Destroyer`, and therefore
    save a lot of code maintenance.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use polymorphism to adapt the `serviceShip` function in the `Shipyard` class
    so that it takes `Ship` as a parameter, and can therefore service any instance
    that inherits from `Ship`, thereby reducing the number of functions in the class.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will also see that not only is there less code achieving the same functionality
    as before, but it is more encapsulated than before as well.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Create a new class called `Ship` and code it as follows. We will then discuss
    how it compares to the `Destroyer` and `Carrier` classes of the previous project:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: First, you will notice that the class is declared `abstract`, so we know that
    we must inherit from this class and we cannot use it directly. Scan down to near
    the end of the code and you will see an abstract function called `attack`. We
    now know that when we inherit from `Ship`, we will need to override and provide
    the code for a function called `attack`. This is just what we need, because you
    might remember that aircraft carriers launch attacks and destroyers shoot shells.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Scan back to the top of the preceding code and you will see that the constructor
    declares four properties. Two of the properties are new and two have the same
    uses as the previous project, but how we call the constructor is what is interesting,
    and we will see that shortly.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: The two new properties are `maxAttacks` and `maxHullIntegrity`, so that `Shipyard`
    restores them back to a level appropriate for the specific type of ship.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: In the `init` block, the properties that were not initialized in the constructor
    are initialized. What follows is the `takeDamage` function, which has the same
    functionality as the `takeDamage` function from the previous project, except that
    it is in just the `Ship` class and not both the `Carrier` and `Destroyer` classes.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we have a `showStats` function for printing the stats related values
    to the logcat window, meaning that those properties can be private too.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Notice that all the properties are private except for `name` and one protected
    property called `attacksRemaining`. Remember that `protected` means that it is
    only visible inside instances that inherit from the `Ship` class.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, code the new `Destroyer` class as shown next:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, code the `Carrier` class that follows, and we can then compare `Destroyer`
    and `Carrier`:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Notice that both the preceding two classes receive only a `String` value called
    `name` as a constructor parameter. You will further notice that `name` is not
    declared with `val` or `var`, so it is not a property, just a throw-away parameter
    that will not persist. The first thing each of the classes does is inherit from
    `Ship` and call the constructor of the `Ship` class, passing in `name` along with
    the values appropriate for either `Destroyer` or `Carrier`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: Both classes have an attack-related property. `Destroyer` has `shotPower` and
    `Carrier` has `attackPower`. Then they both implement/override the `attack` function
    to suit the type of attack they will carry out. However, both types of attack
    will be triggered in the same way with the same function call.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: 'Code the new `Shipyard` class as shown next:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the `Shipyard` class, there is now only one function. It is a polymorphic
    function that takes a `Ship` instance as a parameter. It then calls the `serviceShip`
    function from the super class, which will restore the ammo/attacks and `hullIntegrity`
    back to the levels appropriate for the type of ship.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is true that the `Shipyard` class is superficial. We could have called `serviceShip`
    directly without passing the instance to another class. But it neatly demonstrates
    that we can treat two different classes as the same type because they inherit
    from the same type. The idea of polymorphism goes even further than this, as we
    will see in the next chapter when we talk about interfaces. After all, polymorphism
    means many things, not just two things.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, add code to the `onCreate` function in the `MainActivity` class to
    put our hard work in to action:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This code follows exactly the same pattern as the following:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Attacking the friendly ship
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fighting back and sinking the enemy carrier
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Printing the stats
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Visiting the shipyard for repairs and rearming
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Printing the stats again
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finishing off the final enemy
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'And now we can observe the output:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In the preceding output, we can see an almost identical output. However, we
    achieved it with less code and more encapsulation, and furthermore, if in six
    months we need a `Submarine` class that attacks with torpedoes, then we can add
    it without changing any of the preexisting code.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you haven't memorized everything, or if some of the code seemed a bit too
    in-depth, then you have still succeeded.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: If you just understand that OOP is about writing reusable, extendable, and efficient
    code through encapsulation, inheritance, and polymorphism, then you have the potential
    to be a Kotlin master.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: Simply put, OOP enables us to use other people's code, even when those other
    people were not aware of exactly what we would be doing at the time they did the
    work.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: All you have to do is keep practicing, because we will constantly be using these
    same concepts over and over again throughout the book, so you do not need to have
    even begun to master them at this point.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be revisiting some concepts from this one, as well
    as looking at some new aspects of OOP and how it enables our Kotlin code to interact
    with our XML layouts.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将重新审视本章的一些概念，以及探讨面向对象编程的一些新方面，以及它如何使我们的Kotlin代码与XML布局进行交互。
