- en: Testing Your Serverless Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will teach you how to test your serverless application locally
    using the AWS Serverless Application Model. We will also cover Go unit testing
    and performance testing with third-party tools, and how Lambda itself can be used
    to perform test harness.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is a follow-up to [Chapter 7](d0eca778-5a56-4b6c-8e89-80f13509db5f.xhtml),
    *Implementing a CI/CD Pipeline*, and hence it's recommended to read that chapter
    first to follow this one with ease. In addition, experience with test-driven development
    practices is recommended. The code bundle for this chapter is hosted on GitHub
    at [https://github.com/PacktPublishing/Hands-On-Serverless-Applications-with-Go](https://github.com/PacktPublishing/Hands-On-Serverless-Applications-with-Go).
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Unit testing your Lambda function means testing the function handler in total
    isolation (as far as possible) from external resources (such as the following
    events: DynamoDB, S3, Kinesis). These tests allow you to catch bugs before actually
    deploying your new changes to production and maintain the quality, reliability,
    and security of your source code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we write our first unit test, some background about testing in Golang
    might be helpful. To write a new test suite in Go, the filename must end with ` _test.go` and
    contain the functions with a `TestFUNCTIONNAME` prefix.  The `Test` prefix helps
    to identify the test routine. The files that end with the `_test` suffix will
    be excluded while building the deployment package and will be executed only if
    the `go test` command is issued. In addition, Go comes with a built-in `testing`
    package with a lot of helper functions. However, for simplicity, we will use a
    third-party package called `testify` that you can install with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an example of the Lambda function we built in the previous chapter
    to list all the movies in the DynamoDB table. The following represents the code
    we want to test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'To cover the code fully, we need to test all the edge cases. Examples of tests
    we can perform include:'
  prefs: []
  type: TYPE_NORMAL
- en: Testing the behavior without an IAM role assigned to the function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing with an IAM role assigned to the function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In order to simulate the Lambda function running without an IAM role, we can
    remove the credentials file or unset the AWS environment variables if you''re
    using them locally. Then, issue the `aws s3 ls` command to verify the AWS CLI
    cannot locate the AWS credentials. If you see the following message, you should
    be good to go:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Write your unit test in a file called `main_test.go`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The test function starts with the `Test` keyword, followed by the function
    name and the behavior we want to test. Next, it calls the `findAll` handler and
    compares the actual result with the expected response. Then, you can follow these
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Launch the test with the following command. The command will look for any tests
    in any of the files in the current folder and run them. Make sure to set the `TABLE_NAME`
    environment variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Great! Our test works because the expected and actual response body are equal
    to the **Error while scanning DynamoDB** value:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b4ba8220-279b-4562-92f4-29cdf384bd74.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Write another test function to validate the behavior of the handler if an IAM
    role is assigned to the Lambda function at runtime:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Once again, the test should pass as the expected and actual response body is
    not empty:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e9ea1546-d3a4-4e18-8d47-de990ba34e8c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You have now run a unit test in Go; let''s write another unit test for the
    Lambda function that expects an input parameter. Let''s take the `insert` method
    as an example. The code we want to test is the following (the full code can be
    found in the GitHub repository):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This scenario is an invalid payload as an input parameter. The function should
    return a `400` error with an `Invalid payload` message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Another use case is when given a valid payload; the function should insert
    the movie into the database and return a `200` success code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The two tests should successfully pass. This time, we will run the `go test`
    command in code coverage mode with the `-cover` flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We have 78% of the code covered by the unit test:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/13ecb74b-ad68-471c-a8ee-a3c87b2b656b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you want in-depth details about which statements are covered by the test
    and which are not, you can generate an HTML coverage report with the following
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'If you open `coverage.html` in the browser, you can see the statements that
    are not covered by the unit test:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d234993b-c1bf-4817-9348-fdd985d708ec.png)'
  prefs: []
  type: TYPE_IMG
- en: You can improve the unit test by taking advantage of Go's interface to mock
    the DynamoDB calls. This allows you to mock out the implementation of DynamoDB
    instead of using the concrete service client directly (for example, [https://aws.amazon.com/blogs/developer/mocking-out-then-aws-sdk-for-go-for-unit-testing/](https://aws.amazon.com/blogs/developer/mocking-out-then-aws-sdk-for-go-for-unit-testing/)).
  prefs: []
  type: TYPE_NORMAL
- en: Automated unit tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Having unit tests is great. Yet, a unit test without automation is not useful,
    so your CI/CD pipeline should have a testing stage to execute the unit test for
    every change committed to the code repository. This mechanism has many benefits,
    such as ensuring your codebase is in a bug-free state and allowing developers
    to detect and fix integration problems continuously, and thus avoid last-minute
    chaos on release dates. The following is an example of the pipeline we built in
    previous chapters to deploy the Lambda function automatically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'All changes to the Lambda function''s source code will trigger a new build
    and the unit tests will be re-executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a2bdf032-5bb6-4535-82e6-9df0a6af07ce.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you click on the Test stage, you will see the detailed `go test` command
    results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/80ce3d49-f65b-4387-876c-b1992f325189.png)'
  prefs: []
  type: TYPE_IMG
- en: Integration testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unlike unit testing, which tests a unit of the system, integration testing focuses
    on testing the Lambda function as a whole. So, how do we test Lambda functions
    in a local development environment without deploying them to AWS? Read on to find
    out more.
  prefs: []
  type: TYPE_NORMAL
- en: RPC communications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you read the code under the hood of the official Go library for AWS Lambda
    ([https://github.com/aws/aws-lambda-go](https://github.com/aws/aws-lambda-go)),
    you will notice that Go-based Lambda functions are invoked using `net/rpc` over
    **TCP**. Every Go Lambda function starts a server on a port defined by the `_LAMBDA_SERVER_PORT`
    environment variable and waits for incoming requests. To interact with the function,
    two RPC methods are used:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Ping`: Used to check whether the function is still alive and running'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Invoke`: Used to perform a request'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With this knowledge in mind, we can simulate a Lambda function's execution,
    and perform integration testing or pre-deploy tests to reduce the waiting time
    when deploying the function to AWS but before checking its new behavior. We can
    also fix the bugs during the early phases of the development life cycle before
    committing the new changes to the code repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example is a simple Lambda function that calculates the Fibonacci
    value of a given number. The Fibonacci series is the sum of the two previous numbers.
    The following code is an implementation of the Fibonacci series using recursion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The Lambda function is listening on a port over TCP, so we need to define the
    port by setting the `_LAMBDA_SERVER_PORT` environment variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'To invoke the function, you can either use the `invoke` method from the `net/rpc`
    go package or install a Golang library that abstracts the RPC communication into
    a single method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, invoke the function by setting the port on which it''s running and the
    number we want to calculate its Fibonacci number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Invoke the Fibonacci Lambda function with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'As a result, `fib(9)=34` is returned as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/72d7a601-bd42-4d7f-a922-c34269b10d76.png)'
  prefs: []
  type: TYPE_IMG
- en: Another approach is building an HTTP server using the `net/http` package to
    simulate the Lambda function running behind an API Gateway, and testing the function
    the same way you test any HTTP server to validate the handler.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will see how to use AWS Serverless Application Model
    to test Lambda functions locally in an easier manner.
  prefs: []
  type: TYPE_NORMAL
- en: Serverless Application Model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Serverless Application Model** (**SAM**), is a way to define serverless applications
    in AWS. It''s an extension to **CloudFormation** in the way it allows to define
    all resources needed to run your functions in AWS in a template file.'
  prefs: []
  type: TYPE_NORMAL
- en: Please see [Chapter 14](f843226f-e1bb-4a49-ae23-303a5b46fc03.xhtml), *Infrastructure
    as Code*, for instructions on how to use SAM to build serverless applications
    from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, AWS SAM allows you to create a development environment to test,
    debug, and deploy your functions locally. Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started, install the SAM CLI with the `pip` Python package manager:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Make sure to install all the prerequisites and ensure that the Docker engine
    is running. For more details, check out the official documentation at [https://docs.aws.amazon.com/lambda/latest/dg/sam-cli-requirements.html](https://docs.aws.amazon.com/lambda/latest/dg/sam-cli-requirements.html).
  prefs: []
  type: TYPE_NORMAL
- en: Once installed, run `sam --version`. If everything works as expected, it should
    output the SAM version (*v0.4.0* at the time of writing this book).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create `template.yml` for the SAM CLI, in which we will define the runtime
    and the required resources to run the function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The SAM file describes the runtime environment and the name of the handler containing
    the code your Lambda function will execute when invoked. Plus, the template defines
    the event that will trigger the function; in this case, it's an API Gateway endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: 'Build the deployment package for Linux:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the function locally using the `sam local` command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'An HTTP server will be running and listening on port `3000`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3a87d6d2-f4c5-4724-a0ca-f9773c53b1e1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you navigate to `http://localhost:3000/movies`, it should take a few minutes
    before returning a response as it needs to fetch a Docker image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7d01d552-40a9-4efc-88ea-0eb05322e4e0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'SAM local leverages the power of containers to run your Lambda function''s
    code in a Docker container. In the preceding screenshot, it''s pulling the `lambci/lambda:go1.x`
    Docker image from DockerHub (an image repository). You can confirm that by running
    the following command to list all available images on your machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output of the preceding command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5d6f0c47-6cdd-4a0f-a9a0-44a9af77c2dc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once the image is pulled, a new container will be created based on your `deployment`
    package:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f0a93574-b2b8-468d-9eb0-eedc237b867c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the browser, an error message will be displayed, as we forgot to set the
    DynamoDB table''s name:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/263599b2-995d-4e38-9864-95fc3466c5bb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can fix that by creating an `env.json` file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the `sam` command, this time with the `--env-var` argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: You can also declare environment variables in the same SAM template file with
    the `Environment` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'This time, you should have all the movies in the DynamoDB `movies` table, and
    the function should work as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5bf58d20-54a7-442c-b137-d7269c0322d0.png)'
  prefs: []
  type: TYPE_IMG
- en: Load testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've already seen how to use benchmark tools, such as Apache Benchmark, and
    how to test harness. In this section, we will look at how to use the Lambda itself
    as a **serverless testing** test platform.
  prefs: []
  type: TYPE_NORMAL
- en: 'The idea is simple: we will write a Lambda function that will call the Lambda
    function we want to test, and write its result to a DynamoDB table for reporting.
    Fortunately, no coding is required here, as the Lambda function is already available
    in the Blueprints section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f89c5a72-804b-45f7-b944-0667cbc6abe0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Give the function a name and create a new IAM role, as described in the following
    schema:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/444ab0b3-a64e-4ab6-b70f-69490d9a6ab7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on Create function and the function should be created with permissions granted
    to perform the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Push logs to CloudWatch.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Invoke other Lambda functions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write data to the DynamoDB table.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following screenshot gives you the glimpse of after the preceding task
    is completed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5cf896bd-c523-4fb9-a3f0-f80760c8b124.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Before launching the load test, we need to create a DynamoDB table in which
    the Lambda will record the output of the test. This table must have a hash key
    string of `testId` and a range number of `iteration`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/003994a1-840e-4eda-9522-c116044eb434.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once created, invoke the Lambda function using the following JSON schema. It
    will invoke the given function asynchronously 100 times. Specify a unique `event.testId`
    to differentiate each unit test run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The result will be recorded in the DynamoDB table given in the JSON schema:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1379afc6-c4e7-4fee-81a7-23ff50929bdb.png)'
  prefs: []
  type: TYPE_IMG
- en: You may want to modify the function's code to save additional information, such
    as running time, resource usage, and response time.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to write unit tests for the Lambda function
    to cover all the edge cases of the function. We also learned how to use AWS SAM
    to set up a local development environment to test and deploy the function locally,
    in order to ensure its behavior is working as expected before deploying it to
    AWS Lambda.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will cover how to troubleshoot and debug serverless
    applications using AWS-managed services such as CloudWatch and X-Ray.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Write a unit test for the `UpdateMovie` Lambda function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a unit test for the `DeleteMovie` Lambda function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify the `Jenkinsfile` provided in previous chapters to include the execution
    of automated unit tests.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify the `buildspec.yml` definition file to include the execution of unit
    tests, before pushing the deployment package to S3 using AWS CodeBuild.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a SAM template file for each Lambda function implemented in previous chapters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
