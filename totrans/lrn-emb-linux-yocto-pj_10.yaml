- en: Chapter 10. Real-time
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will be presented with information on the real-time component
    of the Yocto Project. Also, in the same context, a short discussion regarding
    the general purpose of an operating system and a real-time operating system will
    be explained. We will then move toward the PREEMPT_RT patches that try to change
    normal Linux into a full powered real-time operating system; we will try to look
    at it from more angles and at the end, sum it up and draw a conclusion out of
    it. This is not all, any real-time operation needs its applications, so a short
    presentation on the do's and don'ts of application writing that is suitable in
    the context of a real-time operating system, will also be presented. Keeping all
    of this in mind, I believe it's time to proceed with this chapter content; I hope
    you enjoy it.
  prefs: []
  type: TYPE_NORMAL
- en: You will find a more detailed explanation of real-time components in this chapter.
    Also, the relation between Linux and real-time will be shown to you. As everyone
    knows already, the Linux operation system was designed as a general purpose OS
    very similar to the already available UNIX. It is very easy to see the fact that
    a multiuser system, such as Linux, and a real-time one are somewhat in conflict.
    The main reason for this is that for a general purpose, multiple user operating
    systems, such as Linux, are configured to obtain a maximal average throughput.
    This sacrifices latencies that offer exactly the opposite requirements for a real-time
    operating system.
  prefs: []
  type: TYPE_NORMAL
- en: The definition for real time is fairly easy to understand. The main idea behind
    it in computing is that a computer or any embedded device is able to offer feedback
    to its environment in time. This is very different from being fast; it is, in
    fact, fast enough in the context of a system and fast enough is different for
    the automobile industry or nuclear power plants. Also, this kind of a system will
    offer reliable responses to take decisions that don't not affect any exterior
    system. For example, in a nuclear power plant, it should detect and prevent any
    abnormal conditions to ensure that a catastrophe is avoided.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding GPOS and RTOS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When Linux is mentioned, usually **General Purpose Operating System** (**GPOS**)
    is related to it, but over time, the need to have the same benefits as **Real-Time
    Operating System** (**RTOS**) for Linux has become more stringent. The challenge
    for any real-time system is to meet the given timing constrains in spite of the
    number and type of random asynchronous events. This is no simple task and an extensive
    number of papers and researches were done on theory of the real-time systems.
    Another challenge for a real-time system would be to have an upper limit on latency,
    called a scheduling deadline. Depending on how systems meet this challenge, they
    can be split into hard, firm, and soft:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Hard real-time system**: This represents system for which a deadline miss
    will result in a complete system failure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Firm real-time system**: This represents systems for which a deadline miss
    is acceptable but the system quality can be degraded. Also, after the deadline
    is missed, the result that is offered is not useful anymore.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Soft real-time system**: This represents systems for which missing of deadlines
    degrades the usefulness of the received result and consequently, of the quality
    of the system. In these kind of systems, the meeting of the deadline is seen as
    a goal than as a strict requirement.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are multiple reasons for Linux not being suitable as a RTOS:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Paging**: The page swap process through virtual memory is without limits.
    There is no method in place to know the time that will pass until you can get
    a page from a disk, and this implies that there is no upper limit to the delay
    caused by the fault in a page.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Coarsed-grained synchronization**: Here, the definition of the Linux kernel
    is not preemptible. This means that once a process is inside the kernel context,
    it cannot be preempted until it exits the context. At an event occurrence, the
    new event needs to wait for scheduling until the already available one exits the
    kernel context.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Batching**: An operation can be batched for a more efficient use of resources.
    The simplest example of this is the page freeing process. Instead of freeing each
    separate page, Linux is able to pass multiple pages and clean as many as possible.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Request reordering**: The I/O requests can be reordered for processes, making
    the process of using hardware more efficient.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fairness in scheduling**: This is a UNIX heritage and refers to the fact
    that a scheduler tries to be fair with all running processes. This property offers
    the possibility of lower priority processes that have been waiting for a long
    time to be scheduled before higher priority ones.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All the preceding characteristics constitute the reason why an upper boundary
    cannot be applied to the latency of a task or process, and also why Linux cannot
    become a hard real-time operating system. Let''s take a look at the following
    diagram which illustrates the approaches of Linux OS to offer real-time characteristics:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding GPOS and RTOS](img/image00361.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The first thing anyone can do to improve the latency of the standard Linux operating
    system would be to try and make a change to the scheduling policies. The default
    Linux time sharing scheduling policies are called **SCHED_OTHER**, and they use
    a fairness algorithm, giving all processes zero priority, the lowest one available.
    Other such scheduling policies are **SCHED_BATCH** for batch scheduling of the
    processes and the **SCHED_IDLE**, which is suitable for the scheduling of extremely
    low priority jobs. The alternatives to this scheduling policy are **SCHED_FIFO**
    and **SCHED_RR**. Both of them are intended as real-time policies and are time-critical
    applications that require precise control processes and their latencies.
  prefs: []
  type: TYPE_NORMAL
- en: To offer more real-time characteristics to a Linux operating system, there are
    also two more approaches that can be presented. The first one refers to a more
    preemptive implementation of the Linux kernel. This approach can take advantage
    of the already available spinlock mechanism used for SMP support, making sure
    that multiple processes are prevented from executing simultaneously, though in
    the context of a single processor, the spinlocks are no ops. The interrupt handling
    also requires modifications this rescheduling to make possible if another higher
    priority process appears; in this situation, a new scheduler might also be required.
    This approach offers the advantage of not changing the interaction of a user space
    and the advantage of using APIs, such as POSIX or others. The drawback of this
    is that the kernel changes are very serious and every time a kernel version changes,
    these changes need to be adapted accordingly. If this work was not enough already,
    the end result is not fully real-time operating system, but one that reduces the
    latency of the operating system.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other available implementation is interrupt abstraction. This approach
    is based on the fact that not all systems require a hard real-time determinism
    and most of them only require a section of their task to be executed in a real-time
    context. The idea behind this approach is to run Linux with the priority of an
    idle task under a real-time kernel and non-real-time tasks to continue to execute
    them as they normally do. This implementation fakes the disabling of an interrupt
    for the real-time kernel, but in fact, it is passed to the real-time kernel. For
    this type of implementation, there are three available solutions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**RTLinux**: It represents the original implementation of the interrupt abstraction
    approach and was developed at the Institute of Mining and Technology, New Mexico.
    Although it still has an open source implementation, most of the development is
    now done through FSMLabs engineers, later required by the Wind River System on
    the commercial version of it. The commercial support for RTLinux ended in August
    2011.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**RTAI**: It is an enhancement made to the RTLinux solution developed in the
    department of Aerospace Engineering from the Politecnico di Milano. This project
    is a very active with a high number of developers and has current releases available.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Xenomai**: It represents the third implementation. It''s history is a bit
    twisted: it appeared in August 2001, only to be merged with RTAI in 2013 to generate
    a real-time operating system that was fit for production. However, the fusion
    was dispersed in 2005 and it became an independent project again.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following diagram presents a basic RTLinux architecture.
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding GPOS and RTOS](img/image00362.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: A similar architecture, as shown in the preceding diagram, applies to the two
    other solutions since both of them were born from the RTLinux implementation.
    The difference between them is at the implementation level and each offers various
    benefits.
  prefs: []
  type: TYPE_NORMAL
- en: PREEMPT_RT
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The PREEMPT_RT patches are the first option for every developer when a real-time
    solution is required. For some developers, the PREEMPT_RT patches transform Linux
    into a real-time solution suitable for their needs. This solution could not replace
    a real-time operation system, but is, in fact, suitable for a large number of
    systems.
  prefs: []
  type: TYPE_NORMAL
- en: The biggest advantage that PREEMPT_RT has over other real-time solutions for
    Linux is that it actually transforms Linux into a real-time operating system.
    All the other alternatives usually create a microkernel that is executed as a
    hypervisor and Linux is only executed as a task of it, so the communication of
    real-time tasks with the non-real-time ones is done through this microkernel.
    For the PREEMPT_RT patch, this problem is no more.
  prefs: []
  type: TYPE_NORMAL
- en: The standard version of the Linux kernel is only able to offer soft real-time
    requirements, such as basic POSIX user space operations where no deadline is guaranteed.
    Adding patches, such as Ingo Molnar's PREEMPT_RT patch, and also Thomas Gheixner's
    patch with regards to a generic clock event layer that offers a high resolution
    support, you can say that you have a Linux kernel that offers high real-time capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the presence of the real-time preemption patch in the industry, a number
    of interesting opportunities have appeared, making it an option for firm and hard
    real-time applications in areas, such as industrial control or professional audio.
    This is mainly because of the design of the PREEMPT_RT patch and its aim toward
    integration inside the mainline kernel. We will learn about its usage further
    in the chapter. The following diagram shows the working of the Preemptible Linux
    Kernel:'
  prefs: []
  type: TYPE_NORMAL
- en: '![PREEMPT_RT](img/image00363.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The PREEMPT_RT patch transforms Linux from a general purpose operating system
    into a preemptible one using the following tricks:'
  prefs: []
  type: TYPE_NORMAL
- en: Protecting critical sections with the preemptible `rwlock_t preemptible` and
    `spinlock_t`. The use of the old solutions is still available using `raw_spinlock_t`,
    which shares the same API as `spinlock_t`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The kernel locking mechanisms is preempted by using `rtmutexes`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A priority inversion and priority inheritance mechanism is implemented for `mutexes`,
    `spinlocks` and `rw_semaphores`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting the available Linux timer API into one with a high resolution timer
    that offers the possibility of having timeouts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the usage of kernel threads for interrupt handlers. The real-time
    preemption patch treats soft interrupt handlers into the kernel thread context
    using a `task_struct` like structure for every user space process. There is also
    the possibility of registering an IRQ into the kernel context.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more information on priority inversion, [http://www.embedded.com/electronics-blogs/beginner-s-corner/4023947/Introduction-to-Priority-Inversion](http://www.embedded.com/electronics-blogs/beginner-s-corner/4023947/Introduction-to-Priority-Inversion)
    is a good starting point.
  prefs: []
  type: TYPE_NORMAL
- en: Applying the PREEMPT_RT patch
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before moving to the actual configuration part, you should download a suitable
    version for the kernel. The best inspiration source is [https://www.kernel.org/](https://www.kernel.org/),
    which should be the starting point because it does not contain any extra patches.
    After the source code is received, the corresponding `rt` patches version can
    be downloaded from [https://www.kernel.org/pub/linux/kernel/projects/rt/](https://www.kernel.org/pub/linux/kernel/projects/rt/).
    The kernel version chosen for this demonstration is the 3.12 kernel version, but
    if any other kernel version is required, the same steps can be taken with a similar
    end result. The development of the real-time preemption patches is very active,
    so any missing version support is covered very fast. Also, for other sublevel
    versions, the patches can be found in the `incr` or older subdirectories of that
    particular kernel version. The following is the example for sublevel versions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'After the source code is received, the sources need to be unpacked and the
    patches applied:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step involves the configuration of the kernel sources. The configuration
    differs from one architecture to another, but the general idea remains. The following
    configurations are required for a QEMU ARM machine supported inside Poky. To enable
    the PREEMPT_RT support for a machine, there are multiple options available. You
    can implement a low-latency support version, which is most suitable for a desktop
    computer using a kernel configuration fragment similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This option is one of the most often used and it also constitutes the primary
    source of usage of the PREEMPT_RT patches. The alternative of this would be to
    enable the fully preemptive support for the PREEMPT_RT patches using a configuration
    similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: If you're interested in configuring the kernel manually, it can use the `menuconfig`
    option. The following `CONFIG_PREEMPT*` configurations are available for easier
    access to the required options. The first image mainly contains the `CONFIG_PREEMPT`
    and `CONFIG_PREEMPT_COUNT` variables, which should be the first ones to enable.
    There is also a configuration option called `CONFIG_PREEMPT_NONE` that is used
    for no forced preemptive actions.
  prefs: []
  type: TYPE_NORMAL
- en: '![Applying the PREEMPT_RT patch](img/image00364.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In the following image, the `CONFIG_PREEMPT_RCU` and `CONFIG_PREEMPT_RT_FULL`
    configurations are available. More information related to `RCU` is available at
    [https://lwn.net/Articles/262464/](https://lwn.net/Articles/262464/).
  prefs: []
  type: TYPE_NORMAL
- en: '![Applying the PREEMPT_RT patch](img/image00365.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The third image contains the `CONFIG_PREEMPT__LL` configuration. Another interesting
    configuration is `CONFIG_PREEMPT_VOLUNTARY`, which also reduces the latency along
    with the `CONFIG_PREEMPT__LL` configuration, for a desktop computer.
  prefs: []
  type: TYPE_NORMAL
- en: One interesting argument against the *low-latency desktop* option is available
    at [https://sevencapitalsins.wordpress.com/2007/08/10/low-latency-kernel-wtf/](https://sevencapitalsins.wordpress.com/2007/08/10/low-latency-kernel-wtf/).
  prefs: []
  type: TYPE_NORMAL
- en: '![Applying the PREEMPT_RT patch](img/image00366.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The last one contains the `CONFIG_TREE_PREEMPT_RCU` configuration used to change
    the `RCU` implementation. The same process can be used to search and enable the
    other configurations that do not contain the search word in their name.
  prefs: []
  type: TYPE_NORMAL
- en: '![Applying the PREEMPT_RT patch](img/image00367.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: For more information regarding the PREEMPT_RT patch, refer to [http://varun-anand.com/preempt.html](http://varun-anand.com/preempt.html)
    and [http://www.versalogic.com/mediacenter/whitepapers/wp_linux_rt.asp](http://www.versalogic.com/mediacenter/whitepapers/wp_linux_rt.asp).
  prefs: []
  type: TYPE_NORMAL
- en: 'After the kernel image is obtained with the newly applied and configured real-time
    preemptible kernel patch, it needs to be booted to make sure the activity is done
    appropriately so that the end result can be usable. Using the `uname –a` command,
    the `patch rt*` revision number is visible and should be applied to the kernel
    version. Of course, there are other methods that can used to identify this information.
    An alternative for the `uname –a` command is the `dmesg` command on its output
    the string real-time preemption support should be visible, but only one method
    should be enough. The following image offers a representation of how the `uname
    –a` command output should look:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Applying the PREEMPT_RT patch](img/image00368.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Taking a look at the list of processes, it can be seen, as mentioned earlier,
    that the IRQ handler is treated using kernel threads. This information is visible
    in the next `ps` command output due to the fact that it is put between square
    brackets. Single IRQ handlers are represented by the `task_struct` structures
    that are similar to the user space ones, making them easily controllable from
    the user space:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The next bit of information that needs to be gathered involves the formatting
    of the interrupt process entries, which are a bit different than the ones used
    for a vanilla kernel. This output is visible by inspecting the `/proc/interrupts`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, information available in the fourth column provides the IRQ line notifications,
    such as: `[........N/ 0]`. Here, each dot represents an attribute and each attribute
    is a value, as described in the following points. Here is the order of their presence:'
  prefs: []
  type: TYPE_NORMAL
- en: '`I (IRQ_INPROGRESS)`: This refers to the IRQ handler that is active'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`D (IRQ_DISABLED)`: This represents the IRQ as being disabled'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`P (IRQ_PENDING)`: The IRQ here is presented as being in a pending state'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`R (IRQ_REPLAY)`: In this state, the IRQ has been replied to, but no ACK is
    received yet'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`A (IRQ_AUTODETECT)`: This represents the IRQ as being in an autodetect state'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`W (IRQ_WAITING)`: This refers to the IRQ being in an autodetect state, but
    not seen yet'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`L (IRQ_LEVEL)`: The IRQ is in a level-triggered state'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`M (IRQ_MASKED)`: This represents the state in which the IRQ is not visible
    as being masked anymore'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`N (IRQ_NODELAY)`: This is the state in which the IRQ must be executed immediately'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the preceding example, you can see that multiple IRQs are marked as visible
    and hard IRQs that are run in the kernel context. When an IRQ status is marked
    as `IRQ_NODELAY`, it shows the user that the handler of the IRQ is a kernel thread
    and it will be executed as one. The description of an IRQ can be changed manually,
    but this is not an activity that will be described here.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more information on how to change the real-time attributes for a process,
    a good starting point is the `chrt` tool, available at [http://linux.die.net/man/1/chrt](http://linux.die.net/man/1/chrt).
  prefs: []
  type: TYPE_NORMAL
- en: The Yocto Project -rt kernel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Inside Yocto, kernel recipes with PREEMPT_RT patches are applied. For the moment,
    there are only two recipes that incorporate the PREEMPT_RT patch; both are available
    inside the meta layer. The recipes that refer to kernel versions 3.10 and 3.14
    and their naming are `linux-yocto-rt_3.10.bb` and `linux-yocto-rt_3.14.bb`. The
    `–rt` ending in the naming indicates that these recipes fetch the PREEMPT_RT branches
    of the Linux kernel versions maintained by the Yocto community.
  prefs: []
  type: TYPE_NORMAL
- en: 'The format for the 3.14 kernel recipe is presented here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown, one of the recipes seemed to have a duplicated line and a patch is
    necessary to remove it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The preceding recipe is very similar to the base one. Here, I am referring to
    `linux-yocto_3.14.bb`; they are the recipes on which the PREEMPT_RT patches have
    been applied. The difference between them is that each one is taken from its specific
    branch, and until now, none of the Linux kernel versions with the PREEMPT_RT patches
    have provided support for the `qemumips64` compatible machine.
  prefs: []
  type: TYPE_NORMAL
- en: Disadvantages of the PREEMPT_RT patches
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Linux, a general purpose operating system that is optimized for throughput,
    is the exact opposite of what a real-time operating system is all about. Of course
    it offers a high throughput by using a large, multilayered cache, which is a nightmare
    for a hard real-time operating process.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to have a real-time Linux, there are two available options:'
  prefs: []
  type: TYPE_NORMAL
- en: The first one involves the use of the PREEMPT_RT patches, which offer preemption
    by minimizing the latency and executing all activities in a thread context.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second solution involves the use of real-time extensions that act as layers
    between Linux and the hardware used for the management of real-time tasks. This
    second solution includes the previously mentioned RTLinux, RTAI, and XENOMAI solutions,
    as well as other commercial solutions and variations that involve moving the layer
    and also separating it in multiple components.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The variations of the second option imply various solution from the isolation
    of the cores for real-time activities to the assignation of one for such tasks.
    There are also a lot of solutions that involve the usage of a hypervisor or a
    hook below the Linux kernel to serve a number of interrupts to the RTOS. The existence
    of these alternatives have been made available to the reader not only with other
    options, but also due to the fact that the PREEMPT_RT patch has its disadvantages.
  prefs: []
  type: TYPE_NORMAL
- en: One notable disadvantage is that the reduction of latency was done by forcing
    the kernel to preempt a task when a higher priority one appeared. This, of course,
    reduces the throughput for the system because it not only adds a number of context
    switches in the process but also makes the lower priority tasks wait longer than
    they would do the normal Linux kernel.
  prefs: []
  type: TYPE_NORMAL
- en: Another disadvantage of the `preempt-rt` patches is that they need to be ported
    from one kernel version to another and adapted from one architecture or software
    vendor to another. This only implies that knowledge of the Linux kernel should
    be available in-house for a particular vendor and it should adapt the solution
    for each of its available kernels. This fact alone has made it less likeable for
    BSP or Linux operating system providers.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One interesting presentation regarding the Linux pre-emption is available in
    the following link. It can be consulted for more information regarding a Linux
    real-time solution, and is available at [http://www.slideshare.net/jserv/realtime-linux](http://www.slideshare.net/jserv/realtime-linux).
  prefs: []
  type: TYPE_NORMAL
- en: Linux real-time applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having a real-time operating system may not always be enough for everyone. Some
    people would also require real-time optimized applications running over the operating
    system. To make sure an rt-application can be designed and interacted with, the
    required determinism is necessary on the operating system and hardware. With regard
    to the hardware configuration, the requirements involve a low-latency interrupt
    handling. The mechanisms causing the ISR latencies should register values around
    tens of microseconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'Regarding the kernel configuration required by real-time applications, the
    following configurations are necessary:'
  prefs: []
  type: TYPE_NORMAL
- en: '**On-demand CPU scaling**: Using this configuration helps with the creation
    of long-latency events when the CPU is in a low-power consumption mode.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**NOHZ**: This configurations disables the timer interrupt received by CPUs.
    With this option enabled, the latency spent on a CPU wake up is diminished.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To write an application, there are some things that need to be taken care of,
    such as making sure that the use of swap is disabled to diminish latencies caused
    by page faults. The use of global variables or arrays should be kept to a minimum.
    The 99 priority number is not configured to run an application, and other spin
    locks are not implemented instead, it uses priority inheritance futexes. Also
    avoid input/output operations and data sharing between applications.
  prefs: []
  type: TYPE_NORMAL
- en: For a device driver, the advice is a bit different. Previously, we mentioned
    that the interrupt handling for a real-time kernel is done in a thread context,
    but the hardware interrupt context can still play a role here. To recognize the
    hardware interrupt context from the interrupt handler, the `IRQF_NODELAY` flag
    can be used. If you use the `IRQF_NODELAY` context, make sure you avoid functions
    such as `wake_up()`, `up()`, or `complete()`.
  prefs: []
  type: TYPE_NORMAL
- en: Benchmarking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Linux operating system was for a very long time seen as a GPOS, but in the
    last couple of years, some projects tried to change this by modifying the Linux
    kernel into a RTOS. One such project is the PREEMPT_RT patch, which was mentioned
    previously.
  prefs: []
  type: TYPE_NORMAL
- en: In this section of the chapter, I will discuss a series of tests that could
    be executed for both versions of the Linux OS with or without applying the PREEMPT_RT
    patches. I should mention that for those of you who are interested in some actual
    results, there are a number of papers available that try to investigate the latency
    effect of the PREEMPT_RT or its advantages or disadvantages. One such example
    is available at [http://www.versalogic.com/downloads/whitepapers/real-time_linux_benchmark.pdf](http://www.versalogic.com/downloads/whitepapers/real-time_linux_benchmark.pdf).
  prefs: []
  type: TYPE_NORMAL
- en: 'Before continuing further, I believe it is my duty to define a number of technical
    terms that are necessary to properly understand some information:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Interrupt latency**: This indicates the time that has elapsed since an interrupt
    was generated and until the execution has been started in the interrupt handler.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scheduling latency**: This represents the time between the wake up signal
    of an event and a scheduler that has the opportunity to schedule a thread for
    it. It is also called a **dispatch latency**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Worst-case latency**: This indicates the time that has passed since a demand
    was issued and until the response to that demand was received.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Context-switch**: This represents the switching of the CPU from one process
    or thread to another. It only occurs in the kernel mode.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The **LPPTest** is included in the PREEMPT_RT patch and it contains a Linux
    driver that only changes a bit value on a parallel port to identify the response
    time. Another driver responds to the change in a bit value and a user space application
    that measures the results. The files to look for are `drivers/char/lpptest.c`
    and `scripts/testlpp.c`. To perform this test, two machines are required: one
    to send the signal and the other one to receive and send the response. This requirement
    is stringent since the use of a loopback cable can mess with the measurements.'
  prefs: []
  type: TYPE_NORMAL
- en: '**RealFeel** is a test for interrupt processing. The program uses `/dev/rtc`
    to fire a periodic interrupt, measures the duration between one interrupt to another,
    and compares it with the expected value. At the end, it prints the variation from
    the expected value indefinitely so that the variations can be exported in a log
    file to process later.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Linux Real-Time Benchmarking Framework** (**LRTB**) represents a set of scripts
    and drivers that are used to evaluate various performance counters for the Linux
    kernel with a real-time addition. It measures the load imposed by real-time patches
    and their ability to obtain a more deterministic response to interrupts.'
  prefs: []
  type: TYPE_NORMAL
- en: For the benchmarking phase, programs such as `hackbench`, `lmbench`, or even
    the `Ingo Molnar dohell` script can be used. There are, of course, a number of
    other tools that can be used for both testing (`cyclictest`, `hourglass`, and
    so on) or benchmarking (`unixbench`, `cache-calibrator`, or any other stress test
    that takes real-time performances to their limit), but I will let the user test
    them and apply the ones that suit their needs best.
  prefs: []
  type: TYPE_NORMAL
- en: The PREEMPT_RT patch improves the preemptiveness of the Linux kernel, but this
    does not mean it is the best solution to use. The usefulness of PREEMPT_RT patch
    can differ if various aspects of the application domain changes. With regard to
    the PREEMPT_RT patch, it is ready to be used in a hard real-time system. One conclusion
    cannot be made, but I must admit that it can be considered hard real-time material
    if it is used in life sustaining or mission-critical systems. This is a decision
    for everybody to make, and for this testing is required. One opinion that supports
    this is from Steven Rostedt, a Linux kernel developer who is the maintainer of
    the stable version of the real-time Linux kernel patch for Red Hat. It is available
    at [http://www.linux.com/news/featured-blogs/200-libby-clark/710319-intro-to-real-time-linux-for-embedded-developers](http://www.linux.com/news/featured-blogs/200-libby-clark/710319-intro-to-real-time-linux-for-embedded-developers).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some interesting information on this matter can be accessed at [http://elinux.org/Realtime_Testing_Best_Practices](http://elinux.org/Realtime_Testing_Best_Practices).
  prefs: []
  type: TYPE_NORMAL
- en: Meta-realtime
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `meta-realtime` layer is an initiative maintained by Bruce Ashfield from
    WindRiver, which planned to create a place where real-time activities related
    to the Linux kernel or system development. It was created as the placeholder for
    PREEMPT_RT, SCHED_DEADLINE, POSIX real-time, and alternative paring of general
    purpose operating systems and real-time operating systems, whether this involved
    a user space RTOS, a hypervisor, or an AMP solution. Also, this is where system
    partitioning, CPU isolation, and other related applications s reside. Of course,
    none of this would be considered complete without some performance profiling and
    benchmarking applications available for the whole Linux operating system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although this layer description sounds really exciting at first, its content
    is really poor. It is only able to incorporate a number of testing tools, more
    accurately, two of them: `schedtool-dl` and `rt-app`, as well as extra scripts
    that try to remotely run `rt-app` on the target machine and gather the resulting
    data.'
  prefs: []
  type: TYPE_NORMAL
- en: The first `schedtool-dl` application is a scheduler testing tool used for deadline
    scheduling. It appears from the need to change or make queries of the CPU-scheduling
    policies and even processes levels available under Linux. It can also be used
    to lock processes on various CPUs for SMP/NUMA systems, to avoid skipping in audio/video
    applications, and in general, to maintain a high level of interaction and responsiveness
    even under high loads.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: More information about the `schedtool-dl` application can be found at [https://github.com/jlelli/schedtool-dl](https://github.com/jlelli/schedtool-dl).
  prefs: []
  type: TYPE_NORMAL
- en: The next and last available application is `rt-app`, which is used as a test
    application for the simulation of real-time loads on a system. It does this by
    starting multiple threads at given periods of time. It offers support for SCHED_FIFO,
    SCHED_OTHER, SCHED_RR, SCHED_DEADLINE, as well as the **Adaptive Quality of Service
    Architecture** (**AQuoSA**) framework, which is an open source project that tries
    to offer adaptive **Quality of Service** (**QoS**) for the Linux kernel.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: More information about the `rt-app` application and the AQuoSa framework can
    be found at [https://github.com/scheduler-tools/rt-app](https://github.com/scheduler-tools/rt-app)
    and [http://aquosa.sourceforge.net/](http://aquosa.sourceforge.net/).
  prefs: []
  type: TYPE_NORMAL
- en: Besides the included packages, the layer also contains an image that incorporates
    them, but this is not nearly enough to make this layer one that contains substantial
    content. Although it does not contain a vast amount of information inside it,
    this layer has been presented in this chapter because it contains the starting
    point and offers a development point of view of all the information presented
    until now. Of course, a number of applications that should reside in this layer
    are already spread across multiple other layers, such as the `idlestat` package
    that is available in `meta-linaro`. However, this does not constitute the central
    point of this explanation. I only wanted to point out the most suitable place
    that can contain any real-time relate activities, and in my opinion, `meta-realtime`
    is this place.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you were given a short introduction to PREEMPT_RT and other
    alternative solutions for real-time problems of the Linux kernel. We also explored
    a number of tools and applications that can be used for related real-time activities.
    However, this presentation would not be complete without references made to the
    Yocto Project with regards not only to the recipes of the PREEMPT_RT Linux kernel,
    but also to `meta-realtime` layer applications. Developing an application suitable
    for a new context was also a concern, so this problem was tackled in the *Linux
    real-time applications* section. In the end, I hope that I was able to present
    a complete picture of this subject through links that were provided throughout
    the chapter to stir the curiosity of the reader.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, a short explanation of `meta-security` and `meta-selinux`
    layers will be given and a broader picture of the security requirements of the
    Linux ecosystem in general and the Yocto Project in particular, will be provided.
    Information regarding a number of tools and applications that try to secure our
    Linux systems will also be presented, but this is not all. Take a look at the
    next chapter; I am sure you will enjoy it.
  prefs: []
  type: TYPE_NORMAL
