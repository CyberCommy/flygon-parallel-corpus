- en: Chapter 16. Djangos Cache Framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A fundamental trade-off in dynamic websites is, well, they're dynamic. Each
    time a user requests a page, the web server makes all sorts of calculations, from
    database queries to template rendering to business logic to creating the page
    that your site's visitors see. This is a lot more expensive, from a processing-overhead
    perspective, than your standard read-a-file-off-the-filesystem server arrangement.
  prefs: []
  type: TYPE_NORMAL
- en: For most web applications, this overhead isn't a big deal. Most web applications
    aren't www.washingtonpost.com or www.slashdot.org; they're simply small- to medium-sized
    sites with so-so traffic. But for medium-to high-traffic sites, it's essential
    to cut as much overhead as possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s where caching comes in. To cache something is to save the result of
    an expensive calculation so that you don''t have to perform the calculation next
    time. Here''s some pseudocode explaining how this would work for a dynamically
    generated web page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Django comes with a robust cache system that lets you save dynamic pages so
    they don''t have to be calculated for each request. For convenience, Django offers
    different levels of cache granularity: You can cache the output of specific views,
    you can cache only the pieces that are difficult to produce, or you can cache
    your entire site.'
  prefs: []
  type: TYPE_NORMAL
- en: Django also works well with downstream caches, such as Squid (for more information
    visit [http://www.squid-cache.org/](http://www.squid-cache.org/)) and browser-based
    caches. These are the types of caches that you don't directly control, but to
    which you can provide hints (via HTTP headers) about which parts of your site
    should be cached, and how.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the cache
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The cache system requires a small amount of setup. Namely, you have to tell
    it where your cached data should live; whether in a database, on the filesystem
    or directly in memory. This is an important decision that affects your cache's
    performance.
  prefs: []
  type: TYPE_NORMAL
- en: Your cache preference goes in the `CACHES` setting in your settings file.
  prefs: []
  type: TYPE_NORMAL
- en: Memcached
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The fastest, most efficient type of cache supported natively by Django, Memcached
    (for more information visit [http://memcached.org/](http://memcached.org/)) is
    an entirely memory-based cache server, originally developed to handle high loads
    at LiveJournal.com and subsequently open-sourced by Danga Interactive. It's used
    by sites such as Facebook and Wikipedia to reduce database access and dramatically
    increase site performance.
  prefs: []
  type: TYPE_NORMAL
- en: Memcached runs as a daemon and is allotted a specified amount of RAM. All it
    does is provide a fast interface for adding, retrieving and deleting data in the
    cache. All data is stored directly in memory, so there's no overhead of database
    or filesystem usage.
  prefs: []
  type: TYPE_NORMAL
- en: 'After installing Memcached itself, you''ll need to install a Memcached binding.
    There are several Python Memcached bindings available; the two most common are
    python-memcached ([ftp://ftp.tummy.com/pub/python-memcached/](ftp://ftp.tummy.com/pub/python-memcached/))
    and pylibmc ([http://sendapatch.se/projects/pylibmc/](http://sendapatch.se/projects/pylibmc/)).
    To use Memcached with Django:'
  prefs: []
  type: TYPE_NORMAL
- en: Set `BACKEND` to `django.core.cache.backends.memcached.MemcachedCache` or `django.core.cache.backends.memcached.PyLibMCCache`
    (depending on your chosen memcached binding)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set `LOCATION` to `ip:port` values, where `ip` is the IP address of the Memcached
    daemon and `port` is the port on which Memcached is running, or to a `unix:path`
    value, where `path` is the path to a Memcached Unix socket file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this example, Memcached is running on localhost (`127.0.0.1`) port 11211,
    using the `python-memcached` binding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, Memcached is available through a local Unix socket file `/tmp/memcached.sock`
    using the `python-memcached` binding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: One excellent feature of Memcached is its ability to share a cache over multiple
    servers. This means you can run Memcached daemons on multiple machines, and the
    program will treat the group of machines as a *single* cache, without the need
    to duplicate cache values on each machine. To take advantage of this feature,
    include all server addresses in `LOCATION`, either separated by semicolons or
    as a list.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, the cache is shared over Memcached instances running on IP
    address `172.19.26.240` and `172.19.26.242`, both on port 11211:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following example, the cache is shared over Memcached instances running
    on the IP addresses `172.19.26.240` (port 11211), `172.19.26.242` (port 11212),
    and `172.19.26.244` (port 11213):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'A final point about Memcached is that memory-based caching has a disadvantage:
    because the cached data is stored in memory, the data will be lost if your server
    crashes.'
  prefs: []
  type: TYPE_NORMAL
- en: Clearly, memory isn't intended for permanent data storage, so don't rely on
    memory-based caching as your only data storage. Without a doubt, none of the Django
    caching backends should be used for permanent storage-they're all intended to
    be solutions for caching, not storage-but we point this out here because memory-based
    caching is particularly temporary.
  prefs: []
  type: TYPE_NORMAL
- en: Database caching
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Django can store its cached data in your database. This works best if you''ve
    got a fast, well-indexed database server. To use a database table as your cache
    backend:'
  prefs: []
  type: TYPE_NORMAL
- en: Set `BACKEND` to `django.core.cache.backends.db.DatabaseCache`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set `LOCATION` to `tablename`, the name of the database table. This name can
    be whatever you want, as long as it's a valid table name that's not already being
    used in your database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this example, the cache table''s name is `my_cache_table`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Creating the cache table
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before using the database cache, you must create the cache table with this
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This creates a table in your database that is in the proper format that Django's
    database-cache system expects. The name of the table is taken from `LOCATION`.
    If you are using multiple database caches, `createcachetable` creates one table
    for each cache. If you are using multiple databases, `createcachetable` observes
    the `allow_migrate()` method of your database routers (see below). Like `migrate`,
    `createcachetable` won't touch an existing table. It will only create missing
    tables.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple databases
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you use database caching with multiple databases, you'll also need to set
    up routing instructions for your database cache table. For the purposes of routing,
    the database cache table appears as a model named `CacheEntry`, in an application
    named `django_cache`. This model won't appear in the model cache, but the model
    details can be used for routing purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following router would direct all cache read operations to
    `cache_replica`, and all write operations to `cache_primary`. The cache table
    will only be synchronized onto `cache_primary`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: If you don't specify routing directions for the database cache model, the cache
    backend will use the `default` database. Of course, if you don't use the database
    cache backend, you don't need to worry about providing routing instructions for
    the database cache model.
  prefs: []
  type: TYPE_NORMAL
- en: Filesystem caching
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The file-based backend serializes and stores each cache value as a separate
    file. To use this backend set `BACKEND` to `'django.core.cache.backends.filebased.FileBasedCache'`
    and `LOCATION` to a suitable directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to store cached data in `/var/tmp/django_cache`, use this setting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'If you''re on Windows, put the drive letter at the beginning of the path, like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The directory path should be absolute-that is, it should start at the root of
    your filesystem. It doesn't matter whether you put a slash at the end of the setting.
    Make sure the directory pointed to by this setting exists and is readable and
    writable by the system user under which your web server runs. Continuing the above
    example, if your server runs as the user `apache`, make sure the directory `/var/tmp/django_cache`
    exists and is readable and writable by the user `apache`.
  prefs: []
  type: TYPE_NORMAL
- en: Local-memory caching
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is the default cache if another is not specified in your settings file.
    If you want the speed advantages of in-memory caching but don''t have the capability
    of running Memcached, consider the local-memory cache backend. To use it, set
    `BACKEND` to `django.core.cache.backends.locmem.LocMemCache`. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The cache `LOCATION` is used to identify individual memory stores. If you only
    have one `locmem` cache, you can omit the `LOCATION`; however, if you have more
    than one local memory cache, you will need to assign a name to at least one of
    them in order to keep them separate.
  prefs: []
  type: TYPE_NORMAL
- en: Note that each process will have its own private cache instance, which means
    no cross-process caching is possible. This obviously also means the local memory
    cache isn't particularly memory-efficient, so it's probably not a good choice
    for production environments. It's nice for development.
  prefs: []
  type: TYPE_NORMAL
- en: Dummy caching (for development)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Finally, Django comes with a dummy cache that doesn''t actually cache-it just
    implements the cache interface without doing anything. This is useful if you have
    a production site that uses heavy-duty caching in various places but a development/test
    environment where you don''t want to cache and don''t want to have to change your
    code to special-case the latter. To activate dummy caching, set `BACKEND` like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Using a custom cache backend
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While Django includes support for a number of cache backends out-of-the-box,
    sometimes you might want to use a customized cache backend. To use an external
    cache backend with Django, use the Python import path as the `BACKEND` of the
    `CACHES` setting, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: If you're building your own backend, you can use the standard cache backends
    as reference implementations. You'll find the code in the `django/core/cache/backends/`
    directory of the Django source.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Without a really compelling reason, such as a host that doesn't support them,
    you should stick to the cache backends included with Django. They've been well-tested
    and are easy to use.
  prefs: []
  type: TYPE_NORMAL
- en: Cache arguments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Each cache backend can be given additional arguments to control caching behavior.
    These arguments are provided as additional keys in the `CACHES` setting. Valid
    arguments are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`TIMEOUT`: The default timeout, in seconds, to use for the cache. This argument
    defaults to 300 seconds (5 minutes). You can set `TIMEOUT` to `None` so that,
    by default, cache keys never expire. A value of `0` causes keys to immediately
    expire (effectively don''t cache).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OPTIONS`: Any options that should be passed to the cache backend. The list
    of valid options will vary with each backend, and cache backends backed by a third-party
    library will pass their options directly to the underlying cache library.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Cache backends that implement their own culling strategy (that is, the `locmem`,
    `filesystem` and `database` backends) will honor the following options:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MAX_ENTRIES`: The maximum number of entries allowed in the cache before old
    values are deleted. This argument defaults to `300`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CULL_FREQUENCY`: The fraction of entries that are culled when `MAX_ENTRIES`
    is reached. The actual ratio is `1 / CULL_FREQUENCY`, so set `CULL_FREQUENCY`
    to `2` to cull half the entries when `MAX_ENTRIES` is reached. This argument should
    be an integer and defaults to `3`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A value of `0` for `CULL_FREQUENCY` means that the entire cache will be dumped
    when `MAX_ENTRIES` is reached. On some backends (`database` in particular) this
    makes culling *much* faster at the expense of more cache misses.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`KEY_PREFIX`: A string that will be automatically included (prepended by default)
    to all cache keys used by the Django server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VERSION`: The default version number for cache keys generated by the Django
    server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`KEY_FUNCTION`: A string containing a dotted path to a function that defines
    how to compose a prefix, version, and key into a final cache key.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this example, a filesystem backend is being configured with a timeout of
    60 seconds, and a maximum capacity of 1000 items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The per-site cache
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once the cache is set up, the simplest way to use caching is to cache your
    entire site. You''ll need to add `''django.middleware.cache.UpdateCacheMiddleware''`
    and `''django.middleware.cache.FetchFromCacheMiddleware''` to your `MIDDLEWARE_CLASSES`
    setting, as in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'No, that''s not a typo: the update middleware must be first in the list, and
    the fetch middleware must be last. The details are a bit obscure, but see Order
    of MIDDLEWARE_CLASSES) in the next chapter if you''d like the full story.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, add the following required settings to your Django settings file:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CACHE_MIDDLEWARE_ALIAS`: The cache alias to use for storage.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CACHE_MIDDLEWARE_SECONDS`: The number of seconds each page should be cached.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CACHE_MIDDLEWARE_KEY_PREFIX`-: If the cache is shared across multiple sites
    using the same Django installation, set this to the name of the site, or some
    other string that is unique to this Django instance, to prevent key collisions.
    Use an empty string if you don''t care.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FetchFromCacheMiddleware` caches `GET` and `HEAD` responses with `status 200`,
    where the request and response headers allow. Responses to requests for the same
    URL with different query parameters are considered to be unique pages and are
    cached separately. This middleware expects that a `HEAD` request is answered with
    the same response headers as the corresponding `GET` request; in which case it
    can return a cached `GET` response for `HEAD` request. Additionally, `UpdateCacheMiddleware`
    automatically sets a few headers in each `HttpResponse`:'
  prefs: []
  type: TYPE_NORMAL
- en: Sets the `Last-Modified` header to the current date/time when a fresh (not cached)
    version of the page is requested.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sets the `Expires` header to the current date/time plus the defined `CACHE_MIDDLEWARE_SECONDS`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sets the `Cache-Control` header to give a max age for the page-again, from the
    `CACHE_MIDDLEWARE_SECONDS` setting.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a view sets its own cache expiry time (that is, it has a `max-age` section
    in its
  prefs: []
  type: TYPE_NORMAL
- en: '`Cache-Control` header) then the page will be cached until the expiry time,
    rather than `CACHE_MIDDLEWARE_SECONDS`. Using the decorators in `django.views.decorators.cache`
    you can easily set a view''s expiry time (using the `cache_control` decorator)
    or disable caching for a view (using the `never_cache` decorator). See the using
    other headers section for more on these decorators.'
  prefs: []
  type: TYPE_NORMAL
- en: If `USE_I18N` is set to `True` then the generated cache key will include the
    name of the active language. This allows you to easily cache multilingual sites
    without having to create the cache key yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Cache keys also include the active language when `USE_L10N` is set to `True`
    and the current time zone when `USE_TZ` is set to `True`.
  prefs: []
  type: TYPE_NORMAL
- en: The per-view cache
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A more granular way to use the caching framework is by caching the output of
    individual views. `django.views.decorators.cache` defines a `cache_page` decorator
    that will automatically cache the view''s response for you. It''s easy to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '`cache_page` takes a single argument: the cache timeout, in seconds. In the
    above example, the result of the `my_view()` view will be cached for 15 minutes.
    (Note that I''ve written it as `60 * 15` for the purpose of readability. `60 *
    15` will be evaluated to `900`-that is, 15 minutes multiplied by 60 seconds per
    minute.)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The per-view cache, like the per-site cache, is keyed off of the URL. If multiple
    URLs point at the same view, each URL will be cached separately. Continuing the
    `my_view` example, if your URLconf looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: then requests to `/foo/1/` and `/foo/23/` will be cached separately, as you
    may expect. But once a particular URL (for example, `/foo/23/`) has been requested,
    subsequent requests to that URL will use the cache.
  prefs: []
  type: TYPE_NORMAL
- en: '`cache_page` can also take an optional keyword argument, `cache`, which directs
    the decorator to use a specific cache (from your `CACHES` setting) when caching
    view results.'
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, the `default` cache will be used, but you can specify any cache
    you want:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also override the cache prefix on a per-view basis. `cache_page` takes
    an optional keyword argument, `key_prefix`, which works in the same way as the
    `CACHE_MIDDLEWARE_KEY_PREFIX` setting for the middleware. It can be used like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `key_prefix` and `cache` arguments may be specified together. The `key_prefix`
    argument and the `KEY_PREFIX` specified under `CACHES` will be concatenated.
  prefs: []
  type: TYPE_NORMAL
- en: Specifying per-view Cache in the URLconf
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The examples in the previous section have hard-coded the fact that the view
    is cached, because `cache_page` alters the `my_view` function in place. This approach
    couples your view to the cache system, which is not ideal for several reasons.
    For instance, you might want to reuse the view functions on another, cache-less
    site, or you might want to distribute the views to people who might want to use
    them without being cached.
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution to these problems is to specify the per-view cache in the URLconf
    rather than next to the view functions themselves. Doing so is easy: simply wrap
    the view function with `cache_page` when you refer to it in the URLconf.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the old URLconf from earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the same thing, with `my_view` wrapped in `cache_page`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Template fragment caching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you're after even more control, you can also cache template fragments using
    the `cache` template tag. To give your template access to this tag, put
  prefs: []
  type: TYPE_NORMAL
- en: '`{% load cache %}` near the top of your template. The `{% cache %}` template
    tag caches the contents of the block for a given amount of time.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It takes at least two arguments: the cache timeout, in seconds, and the name
    to give the cache fragment. The name will be taken as is, do not use a variable.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Sometimes you might want to cache multiple copies of a fragment depending on
    some dynamic data that appears inside the fragment.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, you might want a separate cached copy of the sidebar used in the
    previous example for every user of your site. Do this by passing additional arguments
    to the `{% cache %}` template tag to uniquely identify the cache fragment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: It's perfectly fine to specify more than one argument to identify the fragment.
    Simply pass as many arguments to `{% cache %}` as you need. If `USE_I18N` is set
    to `True` the per-site middleware cache will respect the active language.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the `cache` template tag you could use one of the translation-specific
    variables available in templates to achieve the same result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The cache timeout can be a template variable, as long as the template variable
    resolves to an integer value.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if the template variable `my_timeout` is set to the value `600`,
    then the following two examples are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This feature is useful in avoiding repetition in templates. You can set the
    timeout in a variable, in one place, and just reuse that value. By default, the
    cache tag will try to use the cache called `template_fragments`. If no such cache
    exists, it will fall back to using the default cache. You may select an alternate
    cache backend to use with the `using` keyword argument, which must be the last
    argument to the tag.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: It is considered an error to specify a cache name that is not configured.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to obtain the cache key used for a cached fragment, you can use
    `make_template_fragment_key`. `fragment_name` is the same as second argument to
    the `cache` template tag; `vary_on` is a list of all additional arguments passed
    to the tag. This function can be useful for invalidating or overwriting a cached
    item, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The low-level cache API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, caching an entire rendered page doesn't gain you very much and is,
    in fact, inconvenient overkill. Perhaps, for instance, your site includes a view
    whose results depend on several expensive queries, the results of which change
    at different intervals. In this case, it would not be ideal to use the full-page
    caching that the per-site or per-view cache strategies offer, because you wouldn't
    want to cache the entire result (since some of the data changes often), but you'd
    still want to cache the results that rarely change.
  prefs: []
  type: TYPE_NORMAL
- en: 'For cases like this, Django exposes a simple, low-level cache API. You can
    use this API to store objects in the cache with any level of granularity you like.
    You can cache any Python object that can be pickled safely: strings, dictionaries,
    lists of model objects, and so forth. (Most common Python objects can be pickled;
    refer to the Python documentation for more information about pickling.)'
  prefs: []
  type: TYPE_NORMAL
- en: Accessing the cache
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can access the caches configured in the `CACHES` setting through a dictionary-like
    object: `django.core.cache.caches`. Repeated requests for the same alias in the
    same thread will return the same object.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: If the named key does not exist, `InvalidCacheBackendError` will be raised.
    To provide thread-safety, a different instance of the cache backend will be returned
    for each thread.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a shortcut, the default cache is available as `django.core.cache.cache`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This object is equivalent to `caches['default']`.
  prefs: []
  type: TYPE_NORMAL
- en: Basic usage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The basic interface is `set(key, value, timeout)` and `get(key)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The `timeout` argument is optional and defaults to the `timeout` argument of
    the appropriate backend in the `CACHES` setting (explained above). It''s the number
    of seconds the value should be stored in the cache. Passing in `None` for `timeout`
    will cache the value forever. A `timeout` of `0` won''t cache the value. If the
    object doesn''t exist in the cache, `cache.get()` returns `None`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We advise against storing the literal value `None` in the cache, because you
    won''t be able to distinguish between your stored `None` value and a cache miss
    signified by a return value of `None`. `cache.get()` can take a `default` argument.
    This specifies which value to return if the object doesn''t exist in the cache:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'To add a key only if it doesn''t already exist, use the `add()` method. It
    takes the same parameters as `set()`, but it will not attempt to update the cache
    if the key specified is already present:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'If you need to know whether `add()` stored a value in the cache, you can check
    the return value. It will return `True` if the value was stored, `False` otherwise.
    There''s also a `get_many()` interface that only hits the cache once. `get_many()`
    returns a dictionary with all the keys you asked for that actually exist in the
    cache (and haven''t expired):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'To set multiple values more efficiently, use `set_many()` to pass a dictionary
    of key-value pairs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Like `cache.set()`, `set_many()` takes an optional `timeout` parameter. You
    can delete keys explicitly with `delete()`. This is an easy way of clearing the
    cache for a particular object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to clear a bunch of keys at once, `delete_many()` can take a list
    of keys to be cleared:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Finally, if you want to delete all the keys in the cache, use `cache.clear()`.
    Be careful with this; `clear()` will remove everything from the cache, not just
    the keys set by your application.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: You can also increment or decrement a key that already exists using the `incr()`
    or `decr()` methods, respectively. By default, the existing cache value will be
    incremented or decremented by 1\. Other increment/decrement values can be specified
    by providing an argument to the increment/decrement call.
  prefs: []
  type: TYPE_NORMAL
- en: 'A `ValueError` will be raised if you attempt to increment or decrement a non-existent
    cache key.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: You can close the connection to your cache with `close()` if implemented by
    the cache backend.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Note that for caches that don't implement `close` methods `close()` is a no-op.
  prefs: []
  type: TYPE_NORMAL
- en: Cache key prefixing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you are sharing a cache instance between servers, or between your production
    and development environments, it's possible for data cached by one server to be
    used by another server. If the format of cached data is different between servers,
    this can lead to some very hard to diagnose problems.
  prefs: []
  type: TYPE_NORMAL
- en: To prevent this, Django provides the ability to prefix all cache keys used by
    a server. When a particular cache key is saved or retrieved, Django will automatically
    prefix the cache key with the value of the `KEY_PREFIX` cache setting. By ensuring
    each Django instance has a different `KEY_PREFIX`, you can ensure that there will
    be no collisions in cache values.
  prefs: []
  type: TYPE_NORMAL
- en: Cache versioning
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you change a running code that uses cached values, you may need to purge
    any existing cached values. The easiest way to do this is to flush the entire
    cache, but this can lead to the loss of cache values that are still valid and
    useful. Django provides a better way to target individual cache values.
  prefs: []
  type: TYPE_NORMAL
- en: Django's cache framework has a system-wide version identifier, specified using
    the `VERSION` cache setting. The value of this setting is automatically combined
    with the cache prefix and the user-provided cache key to obtain the final cache
    key.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, any key request will automatically include the site default cache
    key version. However, the primitive cache functions all include a `version` argument,
    so you can specify a particular cache key version to set or get. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The version of a specific key can be incremented and decremented using the
    `incr_version()` and `decr_version()` methods. This enables specific keys to be
    bumped to a new version, leaving other keys unaffected. Continuing our previous
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Cache key transformation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As described in the previous two sections, the cache key provided by a user
    is not used verbatim-it is combined with the cache prefix and key version to provide
    a final cache key. By default, the three parts are joined using colons to produce
    a final string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: If you want to combine the parts in different ways, or apply other processing
    to the final key (for example, taking a hash digest of the key parts), you can
    provide a custom key function. The `KEY_FUNCTION` cache setting specifies a dotted-path
    to a function matching the prototype of `make_key()` above. If provided, this
    custom key function will be used instead of the default key combining function.
  prefs: []
  type: TYPE_NORMAL
- en: Cache key warnings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Memcached, the most commonly-used production cache backend, does not allow cache
    keys longer than 250 characters or containing whitespace or control characters,
    and using such keys will cause an exception. To encourage cache-portable code
    and minimize unpleasant surprises, the other built-in cache backends issue a warning
    (`django.core.cache.backends.base.CacheKeyWarning`) if a key is used that would
    cause an error on memcached.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are using a production backend that can accept a wider range of keys
    (a custom backend, or one of the non-memcached built-in backends), and want to
    use this wider range without warnings, you can silence `CacheKeyWarning` with
    this code in the `management` module of one of your `INSTALLED_APPS`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: If you want to instead provide custom key validation logic for one of the built-in
    backends, you can subclass it, override just the `validate_key` method, and follow
    the instructions for using a custom cache backend.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, to do this for the `locmem` backend, put this code in a module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '... and use the dotted Python path to this class in the `BACKEND` portion of
    your `CACHES` setting.'
  prefs: []
  type: TYPE_NORMAL
- en: Downstream caches
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, this chapter has focused on caching your own data. But another type
    of caching is relevant to web development, too: caching performed by downstream
    caches. These are systems that cache pages for users even before the request reaches
    your website. Here are a few examples of downstream caches:'
  prefs: []
  type: TYPE_NORMAL
- en: Your ISP may cache certain pages, so if you requested a page from `http://example.com/`,
    your ISP would send you the page without having to access `example.com` directly.
    The maintainers of `example.com` have no knowledge of this caching; the ISP sits
    between `example.com` and your web browser, handling all of the caching transparently.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your Django website may sit behind a *proxy cache*, such as Squid web Proxy
    Cache (for more information visit [http://www.squid-cache.org/](http://www.squid-cache.org/)),
    that caches pages for performance. In this case, each request first would be handled
    by the proxy, and it would be passed to your application only if needed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your web browser caches pages, too. If a web page sends out the appropriate
    headers, your browser will use the local cached copy for subsequent requests to
    that page, without even contacting the web page again to see whether it has changed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Downstream caching is a nice efficiency boost, but there''s a danger to it:
    Many web pages'' contents differ based on authentication and a host of other variables,
    and cache systems that blindly save pages based purely on URLs could expose incorrect
    or sensitive data to subsequent visitors to those pages.'
  prefs: []
  type: TYPE_NORMAL
- en: For example, say you operate a web email system, and the contents of the inbox
    page obviously depend on which user is logged in. If an ISP blindly cached your
    site, then the first user who logged in through that ISP would have their user-specific
    inbox page cached for subsequent visitors to the site. That's not cool.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, HTTP provides a solution to this problem. A number of HTTP headers
    exist to instruct downstream caches to differ their cache contents depending on
    designated variables, and to tell caching mechanisms not to cache particular pages.
    We'll look at some of these headers in the sections that follow.
  prefs: []
  type: TYPE_NORMAL
- en: Using vary headers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Vary` header defines which request headers a cache mechanism should take
    into account when building its cache key. For example, if the contents of a web
    page depend on a user's language preference, the page is said to vary on language.
    By default, Django's cache system creates its cache keys using the requested fully-qualified
    URL-for example, `http://www.example.com/stories/2005/?order_by=author`.
  prefs: []
  type: TYPE_NORMAL
- en: This means every request to that URL will use the same cached version, regardless
    of user-agent differences such as cookies or language preferences. However, if
    this page produces different content based on some difference in request headers-such
    as a cookie, or a language, or a user-agent-you'll need to use the `Vary` header
    to tell caching mechanisms that the page output depends on those things.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this in Django, use the convenient `django.views.decorators.vary.vary_on_headers()`
    view decorator, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, a caching mechanism (such as Django''s own cache middleware)
    will cache a separate version of the page for each unique user-agent. The advantage
    to using the `vary_on_headers` decorator rather than manually setting the `Vary`
    header (using something like `response[''Vary''] = ''user-agent''`) is that the
    decorator adds to the `Vary` header (which may already exist), rather than setting
    it from scratch and potentially overriding anything that was already in there.
    You can pass multiple headers to `vary_on_headers()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'This tells downstream caches to vary on both, which means each combination
    of user-agent and cookie will get its own cache value. For example, a request
    with the user-agent `Mozilla` and the cookie value `foo=bar` will be considered
    different from a request with the user-agent `Mozilla` and the cookie value `foo=ham`.
    Because varying on cookie is so common, there''s a `django.views.decorators.vary.vary_on_cookie()`
    decorator. These two views are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The headers you pass to `vary_on_headers` are not case sensitive; `User-Agent`
    is the same thing as `user-agent`. You can also use a helper function, `django.utils.cache.patch_vary_headers()`,
    directly. This function sets, or adds to, the `Vary` header. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '`patch_vary_headers` takes an `HttpResponse` instance as its first argument
    and a list/tuple of case-insensitive header names as its second argument. For
    more on `Vary` headers, see the official Vary specification (for more information
    visit [http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.44](http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.44)).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Controlling cache: using other headers'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Other problems with caching are the privacy of data and the question of where
    data should be stored in a cascade of caches. A user usually faces two kinds of
    caches: their own browser cache (a private cache) and their provider''s cache
    (a public cache).'
  prefs: []
  type: TYPE_NORMAL
- en: A public cache is used by multiple users and controlled by someone else. This
    poses problems with sensitive data-you don't want, say, your bank account number
    stored in a public cache. So web applications need a way to tell caches which
    data is private and which is public.
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution is to indicate a page''s cache should be private. To do this in
    Django, use the `cache_control` view decorator. Example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: This decorator takes care of sending out the appropriate HTTP header behind
    the scenes. Note that the cache control settings `private` and `public` are mutually
    exclusive. The decorator ensures that the public directive is removed if private
    should be set (and vice versa).
  prefs: []
  type: TYPE_NORMAL
- en: 'An example use of the two directives would be a blog site that offers both
    private and public entries. Public entries may be cached on any shared cache.
    The following code uses `django.utils.cache.patch_cache_control()`, the manual
    way to modify the cache control header (it is internally called by the `cache_control`
    decorator):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'There are a few other ways to control cache parameters. For example, HTTP allows
    applications to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Define the maximum time a page should be cached.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specify whether a cache should always check for newer versions, only delivering
    the cached content when there are no changes. (Some caches might deliver cached
    content even if the server page changed, simply because the cache copy isn't yet
    expired.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In Django, use the `cache_control` view decorator to specify these cache parameters.
    In this example, `cache_control` tells caches to revalidate the cache on every
    access and to store cached versions for, at most, 3,600 seconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Any valid `Cache-Control` HTTP directive is valid in `cache_control()`. Here''s
    a full list:'
  prefs: []
  type: TYPE_NORMAL
- en: '`public=True`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`private=True`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`no_cache=True`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`no_transform=True`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`must_revalidate=True`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`proxy_revalidate=True`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`max_age=num_seconds`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`s_maxage=num_seconds`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For explanation of Cache-Control HTTP directives, see the Cache-Control specification
    (for more information visit [http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9](http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9)).
    (Note that the caching middleware already sets the cache header's `max-age` with
    the value of the `CACHE_MIDDLEWARE_SECONDS` setting. If you use a custom `max_age`
    in a `cache_control` decorator, the decorator will take precedence, and the header
    values will be merged correctly.)
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to use headers to disable caching altogether, `django.views.decorators.cache.never_cache`
    is a view decorator that adds headers to ensure the response won''t be cached
    by browsers or other caches. Example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: What's next?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the next chapter, we will be looking at Django's middleware.
  prefs: []
  type: TYPE_NORMAL
