- en: Chapter 3. Reverse Engineering the Domain Layer with JPA
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The domain layer represents the real-world entities that model the heart of
    your application. At the highest level, the domain layer represents the application's
    business domain and fully describes the entities, their attributes, and their
    relationships with one another. At its most basic level, the domain layer is a
    set of **Plain Old Java Objects** (**POJOs**) that define the Java representation
    of the database tables being mapped onto your application. This mapping is achieved
    through JPA.
  prefs: []
  type: TYPE_NORMAL
- en: The **Java Persistence API** (**JPA**) is one of the most significant advances
    in the Java EE 5 platform, replacing the complex and cumbersome entity beans with
    the far simpler POJO-based programming model. JPA provides a standard set of rules
    for **Object Relational Mapping** (**ORM**), which are simple, intuitive, and
    easy to learn. Database relationships, attributes, and constraints are mapped
    onto POJOs using JPA annotations.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Reverse engineer the 3T database using the NetBeans IDE
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explore and define JPA annotations for our domain layer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduce the **Java Persistence Query Language** (**JPQL**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the reasons for using JPA
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JPA is a productivity tool that allows developers to focus on business rather
    than write low-level SQL and JDBC codes. It completely eliminates the need to
    map a Java `ResultSet` to Java domain objects and greatly reduces the amount of
    effort required to produce a usable and functional application. A JPA-based application
    will be easier to maintain, test, and enhance. More importantly, the quality of
    your application code will significantly increase and the domain entities will
    become self-documenting.
  prefs: []
  type: TYPE_NORMAL
- en: From personal experience, I estimate the time taken to write a traditional SQL
    application (without JPA, coding the CRUD SQL statements directly) to be in the
    order of 10-15 times longer than with the JPA approach. This translates into an
    enormous saving of time and effort for enterprise applications where cost saving
    can amount to many man-months of work. During the lifecycle of an application,
    when maintenance, bug fixes, and enhancements are taken into account, cost savings
    alone may be the difference between success and failure.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding JPA implementations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The JPA specification initially evolved from the combined experiences of key
    ORM implementations including TopLink (from Oracle), Hibernate, and Kodo to name
    a few. These products revolutionized Java database interactions by abstracting
    the underlying SQL from the domain layer and simplifying the development effort
    required to implement the core CRUD operations (Create, Read, Update, and Delete).
    Each implementation supports the JPA standards in addition to their own proprietary
    APIs. TopLink, for example, provides caching enhancements that are outside of
    the JPA specification as well as sophisticated query optimizations for Oracle
    databases. The implementation that you select may depend on the requirements of
    your application (for example, distributed caching) and also on the underlying
    database itself.
  prefs: []
  type: TYPE_NORMAL
- en: The GlassFish 4 server comes bundled with the open source **EclipseLink** JPA
    implementation, and this is what we will be using in our book. More information
    about the EclipseLink project can be found at [http://www.eclipse.org/eclipselink/](http://www.eclipse.org/eclipselink/).
    You don't need to download any files as the EclipseLink dependencies will be automatically
    added to your `pom.xml` file during the reverse engineering process.
  prefs: []
  type: TYPE_NORMAL
- en: Reverse engineering with NetBeans
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The **New Entity Classes from Database** wizard is one of the most helpful
    and time-saving wizards in NetBeans. It generates a set of entity classes from
    an existing database connection, extracting and annotating all the fields and
    defining relationships between the classes. To access the wizard, navigate to
    **File** | **New File**. This will open the **New File** window, where you can
    then select the **Persistence** category followed by the **Entity Classes From
    Database** file type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Reverse engineering with NetBeans](img/5457OS_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on **Next** to display the **Database Tables** screen where you can create
    a **New Data Source**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Reverse engineering with NetBeans](img/5457OS_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This will allow you to enter the **JNDI Name** and to select the **Database
    Connection** that was created in the previous chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Reverse engineering with NetBeans](img/5457OS_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The wizard will now read all the tables and display them in the **Available
    Tables** list. Select all the tables and add them to the **Selected Tables** list
    as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Reverse engineering with NetBeans](img/5457OS_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Click on the **Next** button. This will display the following screen with entity
    class generation properties. Change the **Class Name** for each entity to remove
    the **Ttt** prefix by double-clicking on each **Class Name** row to edit this
    property as shown (the screenshot shows the `User` entity prior to editing). Why
    do we remove this **Ttt**? Simply because the reverse engineering process automatically
    creates a class name based on the table name and the **Ttt** prefix does not add
    anything to our design. The next change has to be done in the package name. Add
    **domain** to the package name as shown. This will generate new entity classes
    in the **com.gieman.tttracker.domain** package that will represent our business
    domain objects and the associated helper classes. Keeping our classes in well-defined,
    separate packages according to usage or purpose enhances our ability to maintain
    the application easily. For large enterprise applications, a well-defined Java
    package structure is crucial.
  prefs: []
  type: TYPE_NORMAL
- en: The final step is to uncheck the **Generate JAXB Annotations** checkbox. We
    don't need to generate XML via JAXB, so we will not need the additional annotations.
  prefs: []
  type: TYPE_NORMAL
- en: '![Reverse engineering with NetBeans](img/5457OS_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now click on the **Next** button, which will show the following screen. The
    final step involves selecting the appropriate **Collection** **Type**. There are
    three different types of collections that can be used and all can be used with
    equal success. We will change the default **Collection Type** to **java.util.List**
    as the sort order is often important in an application's business logic and the
    other types do not allow sorting. On a more personal level, we prefer using the
    `java.util.List` API over the `java.util.Set` and `java.util.Collection` APIs.
  prefs: []
  type: TYPE_NORMAL
- en: '![Reverse engineering with NetBeans](img/5457OS_03_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on the **Finish** button to start the reverse engineering process. When
    the process is complete, you can open the `src/java` nodes to view the generated
    files, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Reverse engineering with NetBeans](img/5457OS_03_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Introducing the persistence.xml file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `persistence.xml` file is generated during the reverse engineering process
    and defines the JPA configuration for a set of entity classes. This file is always
    located in the `META-INF` directory at the root of the classpath. Maven projects
    have a special directory named `resources` located in the `src/main` directory,
    which contains additional resources applicable for building the Java project.
    The `resources` directory is automatically copied by Maven to the root of the
    classpath when building the project. Open the file by double-clicking on it to
    display the **Design** view of the file in the editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introducing the persistence.xml file](img/5457OS_03_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The **Design** view contains several properties that are used to configure the
    persistence unit behavior. We will stick to the simplest settings, but we encourage
    you to explore the different strategies that may be useful for your own application's
    needs. For example, projects that require tables to be automatically created will
    appreciate the **Table Generation Strategy** of **Create** or **Drop and Create**.
    Selecting the different options and switching to the **Source** view will help
    us to quickly identify the appropriate properties in the `persistence.xml` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the **Source** button at the top to view the default file contents
    in the text format:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introducing the persistence.xml file](img/5457OS_03_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Change the default `persistence-unit` node `name` attribute value to `tttPU`
    instead of the long autogenerated name. This value will be used in your Java code
    to refer to this persistence unit and is easy to remember. The `provider` node
    value is automatically set to the appropriate EclipseLink class, and the `jta-data-source`
    node value is automatically set to the data source used during the reverse engineering
    wizard. The `exclude-unlisted-classes` setting will define whether the classpath
    is scanned for annotated entity classes. Change this to `false`. For large projects,
    this is the safest way of ensuring that classes are not omitted accidentally.
    It is also possible to specify each class explicitly in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introducing the persistence.xml file](img/5457OS_03_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is fine for small projects but not very practical if you have hundreds
    of entity classes. In the previous example, the `exclude-unlisted-classes` property
    is set to `true`, meaning that only the specified classes will be loaded without
    the need for classpath scanning. We prefer the first method for defining our JPA
    classes, where the classpath is scanned for all the annotated entity classes by
    setting `exclude-unlisted-classes` to `false`.
  prefs: []
  type: TYPE_NORMAL
- en: The final configuration item of interest is the `transaction-type` attribute.
    There are two different types of transactions supported by this item, of which
    we have `JTA` set by default. **JTA** (**Java Transaction API**) denotes that
    transactions will be managed by a Java EE transaction manager provided by the
    GlassFish server in our application. We will explore the `RESOURCE_LOCAL` alternative
    to JTA when we build our test cases in [Chapter 5](ch05.html "Chapter 5. Testing
    the DAO Layer with Spring and JUnit"), *Testing the DAO Layer with Spring and
    JUnit*. In this situation, the transactions will be managed locally without a
    Java EE container.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring the Java classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The classes generated by the reverse engineering process can be improved upon
    with a little refactoring to make the code more readable and easier to understand.
    Some of the autogenerated properties and fields have `id` in their name when we
    are actually referring to classes, while the collection of `java.util.List` objects
    have `list` in their name. Let's start with the `Company.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: The Company.java file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This file represents the `Company` entity. Double-click on the file to open
    it in the editor and browse through the contents. This class is a simple POJO
    with set and get methods for each property in addition to the standard `hashCode`,
    `equals`, and `toString` methods. The class has a no-arg constructor (required
    by the JPA specification as domain objects must be created dynamically without
    any properties), a second constructor that takes only the primary key, and a full
    (all arguments) constructor. We will make the code more readable by making a few
    minor changes to the `Company.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first change is to rename the field `projectList` to `projects` everywhere
    in the file. This can be easily achieved by selecting the `projectList` field,
    and then selecting **Refactor** | **Rename** from the menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Company.java file](img/5457OS_03_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can now change the field name to **projects**. Make sure that you also select
    the **Rename Getters and Setters** option before clicking on the **Refactor**
    button.
  prefs: []
  type: TYPE_NORMAL
- en: '![The Company.java file](img/5457OS_03_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Making these changes will change the field name and generate new get and set
    methods for the `projects` field.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final change for the `Company.java` file is renaming the `mappedBy` property
    from `idCompany` to `company`. The appropriate lines should now look like the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The final refactored `Company.java` file should now look like the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: JPA uses the convention-over-configuration concept to simplify the configuration
    of entities. This is achieved by using annotations with sensible defaults to keep
    the entity definitions lean. Now, let's look at the key JPA annotations in this
    file.
  prefs: []
  type: TYPE_NORMAL
- en: The @Entity annotation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is a marker annotation that indicates to the JPA persistence provider that
    the `Company` class is an entity. JPA scans for the `@Entity` annotations when
    `exclude-unlisted-classes` is set to `false` in the `persistence.xml` file. Without
    the `@Entity` annotation, the persistence engine will ignore the class.
  prefs: []
  type: TYPE_NORMAL
- en: The @Table annotation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `@Table` annotation defines the underlying database table that is represented
    by this entity class. The `@Table(name = "ttt_company")` line tells the persistence
    provider that the `Company` class represents the `ttt_company` table. Only one
    table annotation can be defined in any entity class.
  prefs: []
  type: TYPE_NORMAL
- en: The @Id annotation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `@Id` annotation defines the primary key field in the class and is required
    for each entity. The persistence provider will throw an exception if the `@Id`
    annotation is not present. The `Company` class property representing the primary
    key in the `ttt_company` table is the `Integer idCompany` field. There are three
    additional annotations attached to this field, of which the following annotation
    is specific to primary keys.
  prefs: []
  type: TYPE_NORMAL
- en: The @GeneratedValue annotation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This annotation identifies how the persistence engine should generate new primary
    key values for the insertion of records into the table. The `strategy=GenerationType.IDENTITY`
    line will use the MySQL autoincrement strategy in the background to insert records
    into the `ttt_company` table. Different databases may require different strategies.
    For example, an Oracle database table could use a sequence as the basis for primary
    key generation by defining the following generator annotations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The primary key generation is independent of the class itself. The persistence
    engine will handle the generation of the primary key for you as defined by the
    generation strategy.
  prefs: []
  type: TYPE_NORMAL
- en: The @Basic annotation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is an optional annotation that is used to identify the nullability of the
    field. The `@Basic(optional = false)` line is used to specify that the field is
    not optional (may not be null). Likewise, the `@Basic(optional = true)` line could
    be used for other fields that may be nullable.
  prefs: []
  type: TYPE_NORMAL
- en: The @Column annotation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This annotation specifies the column to which the field is mapped. The `@Column(name
    = "id_company")` line will, hence, map the `id_company` column in the `ttt_company`
    table to the `idCompany` field in the class.
  prefs: []
  type: TYPE_NORMAL
- en: The @NotNull and @Size annotations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These annotations are part of the `javax.validation.constraints` package (the
    Bean Validation package was introduced in Java EE 6) and define that the field
    cannot be null as well as the minimum and maximum sizes for the field. The `company_name`
    column in the `ttt_company` table was defined as `varchar(200) not null`, which
    is the reason why these annotations were created during the reverse engineering
    process.
  prefs: []
  type: TYPE_NORMAL
- en: The @OneToMany annotation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A `Company` class may have zero or more `Projects` entities. This relationship
    is defined by the `@OneToMany` annotation. In words, we can describe this relationship
    as *One Company can have Many Projects*. In JPA, an entity is associated with
    a collection of other entities by defining this annotation with a `mappedBy` property.
    We have refactored the original `mappedBy` value to `company`. This will be the
    name of the field in the `Project.java` file after we have refactored the `Project`
    file in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: The @NamedQueries annotation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `@NamedQueries` annotations deserve an explanation in their own right. We
    will look at these in detail later.
  prefs: []
  type: TYPE_NORMAL
- en: The Projects.java file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As you may have guessed by now, this file represents the `Project` entity and
    maps to the `ttt_project` table. Double-click on the file to open it in the editor
    and browse the contents. We will once again do a bit of refactoring to clarify
    the autogenerated fields:'
  prefs: []
  type: TYPE_NORMAL
- en: Rename the autogenerated `idCompany` field to `company` using the refactoring
    process. Don't forget to rename the get and set methods.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rename the autogenerated `taskList` field to `tasks`. Don't forget the get and
    set methods again!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rename the `mappedBy` value from `idProject` to `project`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The final refactored file should now look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The @ManyToOne annotation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This annotation represents a relationship between entities; it is the reverse
    of the `@OneToMany` annotation. For the `Project` entity, we can say that *Many
    Projects have One Company*. In other words, a `Project` entity belongs to a single
    `Company` class, and (inversely) a `Company` class can have any number of `Projects`
    entities. This relationship is defined at the database level (that is, the foreign
    key relationship in the underlying tables) and is achieved in the `@JoinColumn`
    annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `name` property defines the name of the column in the `ttt_project` table
    that is the foreign key to the `referencedColumnName` column in the `ttt_company`
    table.
  prefs: []
  type: TYPE_NORMAL
- en: Bidirectional mapping and owning entities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is essential to grasp the very important concept of how one entity is related
    to another through the `@ManyToOne` and `@OneToMany` annotations. The `Company`
    class has a list of mapped `Projects` entities defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Whereas, the `Project` class has exactly one mapped `Company` entity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This is known as bidirectional mapping, one mapping on each class for each
    direction. A many-to-one mapping back to the source, as in the `Project` entity
    back to the `Company` entity, implies a corresponding one-to-many mapping on the
    source (`Company`) back to the target (`Project`). The terms **source** and **target**
    can be defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Source**: This is an entity that can exist in a relationship in its own right.
    The source entity does not require the target entity to exist and the `@OneToMany`
    collection can be empty. In our example, a `Company` entity can exist without
    a `Project` entity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Target**: This is an entity that cannot exist on its own without a reference
    to a valid source. The `@ManyToOne` entity defined on the target cannot be null.
    A `Project` entity cannot exist in our design without a valid `Company` entity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The **owning entity** is an entity that understands the other entity from a
    database perspective. In simple terms, the owning entity has the `@JoinColumn`
    definition describing the underlying columns that form the relationship. In the
    `Company`-`Project` relationship, `Project` is the owning entity. Note that an
    entity can be both a target as well as a source as shown in the following `Project.java`
    file snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Here, `Project` is the source for the `Task` entity relationship and we would
    expect a reverse `@ManyToOne` annotation on the `Task` class. This is exactly
    what we will find.
  prefs: []
  type: TYPE_NORMAL
- en: The Task.java file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This file defines the `Task` entity that represents the `ttt_task` table. Open
    the file and perform the following refactoring:'
  prefs: []
  type: TYPE_NORMAL
- en: Delete the autogenerated `taskLogList` field and also delete the associated
    get and set methods. Why do we do this? There may be many millions of task logs
    in the system for each `Task` instance and it is not advisable to hold a reference
    to such a large set of `TaskLog` instances within the `Task` object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rename the autogenerated `idProject` field to `project`. Don't forget to delete
    the get and set methods again.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After making the preceding changes, you will see that some of the imports are
    no longer required and are highlighted by the NetBeans IDE:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Task.java file](img/5457OS_03_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The keyboard combination of *Ctrl* + *Shift* + *I* will remove all the unused
    imports. Another alternative is to click on the icon, shown in the following screenshot,
    to open the menu and select a **Remove** option:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Task.java file](img/5457OS_03_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It is good practice to have clean code and removing the unused imports is a
    simple process.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final refactored file should now look like the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note the `@ManyToOne` annotation referencing the `Project` class using the `@JoinColumn`
    definition. The `Task` object owns this relationship.
  prefs: []
  type: TYPE_NORMAL
- en: The User.java file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `User` entity represents the underlying `ttt_user` table. The generated
    class has a `@OneToMany` definition for the relationship to the `TaskLog` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Refactoring in this file will once again **delete** this relationship completely.
    As noted in the `Tasks.java` section, a `User` entity may also have many thousands
    of task logs. By understanding the application's requirements and data structure,
    it is often far cleaner to remove unnecessary relationships completely.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will also note that the `@Pattern` annotation is commented out by default
    during the reverse engineering process. The `email` field name indicated to NetBeans
    that this might be an e-mail field and NetBeans added the annotation for use if
    required. We will uncomment this annotation to enable e-mail pattern checking
    for the field and add the required import:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The refactored `User.java` file will now look like the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The TaskLog.java file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The final entity in our application represents the `ttt_task_log` table. The
    refactoring required here is to rename the `idTask` field to `task` (remember
    to also rename the get and set methods) and then rename the `username` field to
    `user`. The file should now look like the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Introducing the Java Persistence Query Language
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Everyone reading this book should be familiar with SQL queries and how they
    work. Constructing a simple query against the `ttt_company` table to retrieve
    all records would look something like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Restricting the result set to companies starting with `G` would look like the
    following code line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In JPA, we are dealing with entities and relationships between entities. The
    **Java Persistence Query Language** (**JPQL**) is used to formulate queries in
    a similar way to SQL. The previously mentioned statement will be written in JPQL
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'And the statement that follows is written as such:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are the major differences between SQL and JPQL:'
  prefs: []
  type: TYPE_NORMAL
- en: 'JPQL class and field names are case sensitive. When we are dealing with classes,
    the class name must start with an uppercase letter. All the fields must have the
    exact case as defined in the class. The following statement will not compile as
    the company entity starts with a lowercase `c`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'JPQL keywords are case insensitive. The preceding statement could just as well
    have been written as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: JPQL uses aliases to define instances and relationships between the instances.
    In the previous examples, the lowercase `c` is used as the alias in the `SELECT`
    and `WHERE` clauses.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JPQL queries may be static (defined in an annotation) or dynamic (built and
    executed at runtime). Static queries are compiled once and looked up whenever
    required. This makes static queries faster to use and more performant.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JPQL queries are translated into SQL; they are then executed against the underlying
    database. This translation allows for database-specific query optimization in
    the persistence engine.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JPQL has a rich set of functions to define conditional expressions. These expressions
    are translated into the correct SQL for the underlying database. This means that
    developers no longer need to write database-specific SQL statements. Switching
    between databases will not require any coding as the JPQL statements abstract
    the underlying SQL required to execute the statement.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We strongly recommend you spend time learning about JPQL. There are many excellent
    books available that are dedicated to JPA and JPQL; they explain advanced usage.
    There are also many online tutorials and JPQL examples on the Internet. It is
    beyond the scope of this book to go beyond the basics, and we leave it to you
    to delve into this rich language further.
  prefs: []
  type: TYPE_NORMAL
- en: Defining named queries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The reverse engineering process generated a set of `@NamedQuery` annotations
    in each class, one for each persistent field. The `Company` class, for example,
    had the following named queries defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Each `@NamedQuery` name must be unique within the persistence engine; hence,
    it is prefixed with the name of the class. The first query name, `Company.findAll`,
    represents the full list of the `Company` objects. The second query uses a named
    parameter, `idCompany`, as a placeholder for a value provided at runtime. Named
    parameters are always prefixed with the colon symbol. You should spend some time
    browsing the queries generated in the Java classes to become familiar with the
    basic JPQL syntax. We will learn more about named queries and how they are used
    in the following chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring Java equals() and hashCode()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our domain layer entity classes have autogenerated `equals` and `hashCode`
    methods defined. The `Company` class, for example, defines these methods as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Refactoring Java equals() and hashCode()](img/5457OS_03_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'It is best practice to always provide correctly implemented `equals` and `hashCode`
    methods that use the entity ID to calculate the value that is returned. These
    methods are used by JPA to determine the equality between entities. Our autogenerated
    `equals` method will work correctly with JPA as the ID entity is used in the comparison
    for each method. However, the `//TODO: Warning` message on line 83 (see the previous
    screenshot) indicates an issue that can be avoided if we regenerate the `equals`
    method with the NetBeans IDE.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Delete the `equals` method and right-click on the `Company.java` file in the
    editor using the mouse to display the context menu. Select the **Insert Code…**
    option:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Refactoring Java equals() and hashCode()](img/5457OS_03_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'From the pop-up menu, select the **equals()…** option and ensure that the **idCompany
    : Integer** field is selected in the **Generate equals()** pop up:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Refactoring Java equals() and hashCode()](img/5457OS_03_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on **Generate** to create the new `equals` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Refactoring Java equals() and hashCode()](img/5457OS_03_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on the information icon (circled) over line 92 to display the context
    information:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Refactoring Java equals() and hashCode()](img/5457OS_03_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on **The if statement is redundant** to clean your code further and replace
    the `if` statement with the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Objects` class was introduced in Java 1.7 and consists of static utility
    methods for operating on objects. The `Objects.equals` method takes into account
    `null` values and solves the potential `//TODO: Warning` issue with the autogenerated
    `equals` method. From the Java 1.7 JavaDoc for the `Objects.equals` method:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Returns `true` if the arguments are equal to each other and `false` otherwise.
    Consequently, if both the arguments are null, `true` is returned, and if exactly
    one argument is null, `false` is returned. Otherwise, the equality is determined
    using the `equals` method of the first argument.
  prefs: []
  type: TYPE_NORMAL
- en: You can now replace the autogenerated `equals` method of the `Project`, `Task`,
    `User`, and `TaskLog` entity classes in a similar way.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we have reverse engineered the 3T database into a set of Java
    classes. Each Java class represents a JPA entity with annotations defining the
    relationship between entities as well as the mapping of database columns to Java
    fields. We have had a brief introduction to JPQL through named query definitions
    and introduced key JPA annotations.
  prefs: []
  type: TYPE_NORMAL
- en: Although this chapter has introduced many key concepts, the scope of JPA and
    JPQL leaves much for you to learn. JPA is a key tool in enterprise application
    development, allowing for easy enhancements and database-agnostic programming.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will introduce the **Data Access Object** (**DAO**) design
    pattern and implement a robust data access layer using the domain classes we have
    just defined. Our JPA journey has just started!
  prefs: []
  type: TYPE_NORMAL
