- en: Network Automation with Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Years ago, the standard practice was to configure every single network device
    by hand. This was possible mainly because the routers and switches were routing
    the traffic of physical servers, so not much configuration was needed on each
    networking device, and changes were slow-paced. In addition, humans were the only
    ones to have enough information on machines to set up networking. Everything was
    very manual in terms of both planning and execution.
  prefs: []
  type: TYPE_NORMAL
- en: Virtualization changed this paradigm, as it has resulted in thousands of machines
    being connected to the same switch or router, each with potentially different
    networking requirements. Changes are fast-paced and expected frequently, and with
    virtual infrastructures defined in code, it becomes a full-time job for a human
    administrator to just keep up with the changes to the infrastructure. Virtualization
    orchestration platforms have far better knowledge of the machine's location, and
    can even generate an inventory for us, as we saw in earlier chapters. Practically
    speaking, there is no way a human being can memorize or manage a modern, large-scale,
    virtualized infrastructure. As a result, it becomes clear that automation is a
    requirement when it comes to configuring the network infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will learn more about this, and what we can do to automate our network,
    in this chapter by covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Why automate network management?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How Ansible manages networking devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to enable network automation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The available Ansible networking modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting to network devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Environment variables for network devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom conditional statements for networking devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter assumes that you have set up your control host with Ansible, as
    detailed in [Chapter 1](0efc8364-b8a4-4866-9ff4-1e2d09f6724b.xhtml), *Getting
    Started with Ansible*, and are using the most recent version available – the examples
    in this chapter were tested with Ansible 2.9\. This chapter also assumes that
    you have at least one additional host to test against, and ideally, this should
    be Linux-based. Since this chapter is network device-centric, we understand that
    not everyone will have access to specific networking equipment to test on (for
    example, Cisco switches). Where examples are given and you have access to such
    devices, please feel free to explore the examples. However, if you do not have
    access to any network hardware, we will give an example using the freely available
    Cumulus VX, which offers a fully-featured demo of Cumulus Networks' switching
    environment. Although we will give specific examples of hostnames in this chapter,
    you are free to substitute them with your own hostname and/or IP addresses. Details
    of how to do this will be provided in the appropriate places.
  prefs: []
  type: TYPE_NORMAL
- en: The code bundle for this chapter is available here: [https://github.com/PacktPublishing/Practical-Ansible-2/tree/master/Chapter%209](https://github.com/PacktPublishing/Practical-Ansible-2/tree/master/Chapter%209).
  prefs: []
  type: TYPE_NORMAL
- en: Why automate network management?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The way that we design data centers has radically changed in the last 30 years.
    In the 90s, a typical data center was full of physical machines, each with a very
    specific purpose. In many companies, the servers were bought by different vendors
    based on the purpose of the machine. This meant that there was a need for machines,
    network devices, and storage devices and that those devices were bought, provisioned,
    configured, and delivered.
  prefs: []
  type: TYPE_NORMAL
- en: The big drawback here was the significant lag between identifying the need for
    the machine and its delivery. In that period, this was acceptable, since the majority
    of companies had very few systems and they tended to change very rarely. Also,
    this approach was very expensive as a lot of devices were under-utilized.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the progress of society and companies in the world of technology, we know
    that today, it has become important for companies to cut their infrastructure
    deployment time and costs. This opened the road for a new idea: virtualization.
    By creating a virtualization cluster, you do not need to have physical hosts that
    are of the correct size, so you can provision a number of them up front, add them
    to a resource pool, and then create the right-sized machines in your virtualization
    platform. This means that when a new machine is needed, you can create it with
    a few clicks and it will be ready in seconds.'
  prefs: []
  type: TYPE_NORMAL
- en: This shift also allowed enterprises to move from a per-project infrastructure,
    with each project being deployed with its own unique data center requirements,
    to one large central infrastructure that can have its behavior defined by software
    and configuration. This means that one single network infrastructure can support
    all projects, regardless of their scale. We call this a virtual data center infrastructure,
    and in this infrastructure, we try to make use of generic design patters as much
    as possible. This allows enterprises to deploy, switch, and serve infrastructure
    at a large scale to enable a multitude of projects so that they can be successfully
    implemented by simply subdividing them (for example, by creating virtual servers).
  prefs: []
  type: TYPE_NORMAL
- en: Another big advantage that virtualization brought is the decoupling of workloads
    and physical hosts. Historically, since a workload was tied to a physical host,
    if the host died, the workload itself died, if not properly replicated on different
    hardware. Virtualization solved this problem since the workload is now tied to
    one or more virtual hosts, but those can be moved freely from a physical host
    to another one.
  prefs: []
  type: TYPE_NORMAL
- en: This ability to provision machines quickly and the ability of such machines
    to move from one host to another created an issue with networking configuration
    management. Before, it was acceptable for a human to tweak the configuration details
    while installing the new machine, but now, machines move from one host to another
    (and therefore from one physical switch port to another) without any human intervention.
    This means that the system needed to update network configurations as well.
  prefs: []
  type: TYPE_NORMAL
- en: In the same time period, VLANs affirmed their presence in networking, which
    allowed the utilization of network devices to be dramatically improved, and therefore
    optimize their costs.
  prefs: []
  type: TYPE_NORMAL
- en: Today, we work at an even larger scale, where virtual objects (machines, containers,
    functions, and so on) move in our data centers, fully managed by software systems,
    and where humans are less and less involved in the process.
  prefs: []
  type: TYPE_NORMAL
- en: In this kind of environment, automating networking is a key part of their success.
  prefs: []
  type: TYPE_NORMAL
- en: Today, there are some companies (the famous "cloud providers") that work at
    a scale where manual network management is not only impracticable but impossible,
    even when employing huge teams of network engineers. On the other hand, there
    are many environments where it would be technically possible to manage network
    configurations (at least partially) manually, but it's still impractical.
  prefs: []
  type: TYPE_NORMAL
- en: Aside from the time required to configure a network device, the biggest advantage
    – from my perspective – of network automation is the opportunity to drastically
    reduce human errors. If a human has to configure a VLAN on 100 devices, chances
    are, they are going to make a few errors in the process. This is absolutely normal,
    but still problematic since those configurations will need to be fully tested
    and amended. Often, the problem doesn't stop here, because when a device breaks
    and therefore needs to be replaced, a human has to configure the new device in
    the same way the old one was configured. Often – over time – the configurations
    change and – very often – there is no clear way to trace this, so while replacing a
    faulty network device, there might be problems for some rules that were present
    in the previous device but are not present in the new one.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have discussed the need to automate network management, let's look
    at how to manage networking devices with Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: Learning how Ansible manages networking devices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ansible allows you to manage many different networking devices, including Arista
    EOS, Cisco ASA, Cisco IOS, Cisco IOS XR, Cisco NX-OS, Dell OS 6, Dell OS 9, Dell
    OS 10, Extreme EXOS, Extreme IronWare, Extreme NOS, Extreme SLX-OS, Extreme VOSS,
    F5 BIG-IP, F5 BIG-IQ, Junos OS, Lenovo CNOS, Lenovo ENOS, MikroTik RouterOS, Nokia
    SR OS, Pluribus Netvisor, VyOS, and OS, which supports NETCONF. As you can imagine,
    there are various ways we can make Ansible communicate with them.
  prefs: []
  type: TYPE_NORMAL
- en: Also, we have to remember that Ansible networking modules run on the controller
    host (the one where you issued the `ansible` command), while usually, the Ansible
    modules run on the target host. This difference is important because it allows
    Ansible to use different connection mechanisms based on the target device type.
    Remember that even when you have a host that has SSH management capabilities (which
    many switches have), Ansible, by very virtue of running its modules on the target
    host, needs the target host to have Python installed. Most switches (and embedded
    hardware) lack Python environments, and so we must make use of other connection
    protocols. The key ones supported by Ansible for network device management are
    given here.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five main connection types that Ansible uses for connecting to those
    network devices, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`network_cli`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`netconf`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`httpapi`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`local`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ssh`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When you create a connection with your networking device, you need to choose
    the connection mechanism based on the ones supported by your devices and your
    needs:'
  prefs: []
  type: TYPE_NORMAL
- en: '`network_cli` is supported by the majority of modules and it is the most similar
    to the way Ansible usually works with the non-networking modules. This mode uses
    a CLI via SSH. This protocol creates a persistent connection at the beginning
    of the configuration and keeps it alive for the whole duration of the task so
    that you don''t have to provide credentials for every subsequent task.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`netconf` is supported by very few modules (at the time of writing, these modules
    are just OSes that support NETCONF and Junos OS). This mode uses XML via SSH,
    so basically, it applies XML-based configurations to the device. This protocol
    creates a persistent connection at the beginning of the configuration and keeps
    it alive for the whole duration of the task so that you don''t have to provide
    credentials for every subsequent task.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`httpapi` is supported by a few modules (at the time of writing, these are
    Arista EOS, Cisco NX-OS, and Extreme EXOS). This mode uses the HTTP API that the
    device publishes. This protocol creates a persistent connection at the beginning
    of the configuration and keeps it alive for the whole duration of the task so
    that you don''t have to provide credentials for every subsequent task.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Local` is supported by the majority of devices but is a deprecated mode. This
    is basically a vendor-dependent connection mode that may require some vendor packages
    to be used. This mode does not create a persistent connection, so at the start
    of every task, you will need to pass the credentials. When possible, avoid this
    mode.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ssh` must not be forgotten in this section. Although a large number of devices
    depend upon the connection modes listed here, a new breed of devices is being
    created that run Linux natively on white box switch hardware. One such example
    is Cumulus Networks, and as the software is Linux-based, all configuration can
    be performed over SSH, as if the switch was actually just another Linux server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Knowing how Ansible connects to and communicates with your networking hardware
    is important as it gives you the understanding you need to build your Ansible
    playbooks and debug issues when things go wrong. In this section, we covered the
    communication protocols you will come across when working with networking hardware.
    We will build on this in the next section by looking at the fundamentals of starting
    out on our network automation journey with Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling network automation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before you can use Ansible for network automation, you need to make sure you
    have everything you need.
  prefs: []
  type: TYPE_NORMAL
- en: Based on the kind of connection method we are going to use, we need different
    dependencies. As an example, we are going to use a Cisco IOS device with `network_cli`
    connectivity.
  prefs: []
  type: TYPE_NORMAL
- en: 'The only requirements for Ansible network automation to work are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Ansible 2.5+
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Proper connectivity with the network device
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'First, we need to check the Ansible version:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To ensure that you have a recent Ansible version, you can run the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This will tell you the version of your Ansible installation.
  prefs: []
  type: TYPE_NORMAL
- en: 'If it''s 2.5 or better, you can issue the following command (with the appropriate
    options) to check the connectivity of your network device:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This should return your device's facts, which proves that we are able to connect. As
    for any other target, Ansible is able to retrieve facts, and this is usually the
    first thing Ansible does when interacting with a target.
  prefs: []
  type: TYPE_NORMAL
- en: This is a key step since this allows Ansible to know the current state of the
    device and therefore act appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: By running the `ios_facts` module on our target device, we are just executing
    this first standard step (so no changes will be performed on the device itself
    or its configurations), but this will confirm that Ansible is able to connect
    all the way to the device and perform commands on it.
  prefs: []
  type: TYPE_NORMAL
- en: Now, obviously, you could only actually run the preceding command and explore
    its behavior if you have access to a network device running Cisco IOS. We understand
    that not everyone will have the same networking equipment available to them for
    testing purposes (or indeed any!). Fortunately for us, a new breed of switches
    is becoming available – "white box" switches. These switches are made by a variety
    of manufacturers and are based on standardized hardware where you can install
    your own network operating system. One such operating system is Cumulus Linux,
    and a freely available test version of this, called Cumulus VX, is available for
    you to download.
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing, the download link for Cumulus VX is [https://cumulusnetworks.com/products/cumulus-vx/](https://cumulusnetworks.com/products/cumulus-vx/).
    You will need to register to download it, but doing so gives you free access to
    the world of open networking.
  prefs: []
  type: TYPE_NORMAL
- en: 'Simply download the image appropriate to your hypervisor (for example, VirtualBox)
    and then run it just as you would run any other Linux virtual machine. Once you''ve
    done this, you can connect to the Cumulus VX switch, just like you would any other
    SSH device. For example, to run an ad hoc command to gather facts about all the
    switch port interfaces (which are enumerated as `swp1`, `swp2`, and `swpX` on
    Cumulus VX), you would run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If successful, this should result in pages of information about the switch
    port interface for your Cumulus VX-powered virtual switch. On my test system,
    the first part of this output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, working with white box switches using an operating system such
    as Cumulus Linux has the advantage that you can connect using the standard SSH
    protocol, and you can even use the built-in `setup` module to gather facts about
    it. Working with other proprietary hardware is not much more difficult, but simply
    requires more parameters to be specified, as we showed earlier in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know the fundamentals of enabling network automation, let's learn
    how to discover the appropriate networking modules for our desired automation
    task in Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing the available Ansible networking modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At the moment, there are thousands of modules on a total of more than 20 different
    networking platforms. Let''s learn how to find the ones more relevant to you:'
  prefs: []
  type: TYPE_NORMAL
- en: First of all, you need to know which device type you have and how Ansible calls
    it. On the [https://docs.ansible.com/ansible/latest/network/user_guide/platform_index.html](https://docs.ansible.com/ansible/latest/network/user_guide/platform_index.html)
    page, you can find the different device types that Ansible supports and how they
    are designated. In our example, we will use Cisco IOS as an example.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the [https://docs.ansible.com/ansible/latest/modules/list_of_network_modules.html](https://docs.ansible.com/ansible/latest/modules/list_of_network_modules.html)
    page, you can search for the category dedicated to the family of switches you
    need, and you'll be able to see all the modules you can use.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The list of modules is way too big and family-specific for us to talk about
    them in depth. This list is getting larger every release, with often hundreds
    of new additions in every release.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are familiar with how to configure the device in a manual fashion, you
    will quickly find the name of the modules fairly natural, so it will be easy for
    you to understand what they do. However, let''s go through a handful of examples
    from the collection of Cisco IOS modules – specifically, with reference to [https://docs.ansible.com/ansible/latest/modules/list_of_network_modules.html#ios](https://docs.ansible.com/ansible/latest/modules/list_of_network_modules.html#ios):'
  prefs: []
  type: TYPE_NORMAL
- en: '`ios_banner`: As the name suggests, this module will allow you to tweak and
    modify the login banner (what in many systems is called `motd`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ios_bgp`: This module allows you to configure BGP routes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ios_command`: This is the IOS equivalent of the Ansible `command` module,
    and it allows you to perform many different commands. As for the `command` module,
    this is a very powerful module, but it''s better to use specific modules for the
    operation we are going to perform, if they are available.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ios_config`: This module allows us to make pretty much any changes to the
    configuration file of the device. As for the `ios_command` module, this is a very
    powerful module, but it''s better to use specific modules for the operation we
    are going to perform, if they are available. The idempotency for this module is
    only guaranteed if no abbreviated commands are used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ios_vlan`: This module allows the configuration of VLANs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are just a few examples, but there are many more modules for Cisco IOS
    (27, at the time of writing), and if you cannot find a specific module to perform
    the operation you want, you can always fall back to `ios_command` and `ios_config`,
    which, thanks to their flexibility, will allow you to perform any operation you
    can think of.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast, if you are working with a Cumulus Linux switch, you'll find there
    is just one module – `nclu` (see [https://docs.ansible.com/ansible/latest/modules/list_of_network_modules.html#cumulus](https://docs.ansible.com/ansible/latest/modules/list_of_network_modules.html#cumulus)).
    This reflects the fact that all configuration work in Cumulus Linux is handled
    with this command. If you need to customize the message of the day or other aspects
    of the Linux operating system, you can do this in the normal manner (for example,
    using the `template` or `copy` modules, which we have demonstrated previously
    in this book).
  prefs: []
  type: TYPE_NORMAL
- en: As ever, the Ansible documentation is your friend, and it should be your first
    port of call when you are learning how to automate commands on a new class of
    device. In this section, we have demonstrated a simple process for finding out
    which Ansible modules are available for your class of network device, using Cisco
    as a specific example (though you could apply these principles to any other device).
    Now, let's look at how Ansible connects to network devices.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to network devices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have seen, there are some peculiarities in Ansible networking, so specific
    configurations are required.
  prefs: []
  type: TYPE_NORMAL
- en: In order to manage network devices with Ansible, you need to have at least one
    to test on. Let's assume we have a Cisco IOS system available to us. It is accepted
    that not everyone will have such a device to test on, so the following is offered
    as a hypothetical example only.
  prefs: []
  type: TYPE_NORMAL
- en: 'Going by the [https://docs.ansible.com/ansible/latest/network/user_guide/platform_index.html](https://docs.ansible.com/ansible/latest/network/user_guide/platform_index.html)
    page, we can see that the correct `ansible_network_os` for this device is `ios`
    and that we can connect to it using both `network_cli` and `local`. Since `local`
    is deprecated, we are going to use `network_cli`. Follow these steps to configure
    Ansible so that you can manage IOS devices:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s create the inventory file with our devices in the `routers` group:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'To know which connection parameters to use, we will set Ansible''s special
    connection variables so that they define the connection parameters. We''ll do
    this in a group variables subdirectory of our playbook, so we will need to create
    the `group_vars/routers.yml` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'By virtue of these special Ansible variables, it will know how to connect to
    your devices. We covered some of these examples earlier in this book, but as a
    recap, Ansible uses the values of those variables to determine its behavior in
    the following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ansible_connection`: This variable is used by Ansible to decide how to connect
    to the device. By choosing `network_cli`, we are instructing Ansible to connect
    to the CLI over SSH mode, as we discussed in the previous paragraph.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ansible_network_os`: This variable is used by Ansible to understand the device
    family of the device we are going to use. By choosing `ios`, we are instructing
    Ansible to expect a Cisco IOS device.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ansible_become`: This variable is used by Ansible so that we decide whether
    to perform privilege escalation on the device or not. By specifying `True`, we
    are telling Ansible to perform privilege escalation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ansible_become_method`: There are many different ways to perform privilege
    escalation on the various devices (normally `sudo` on a Linux server – this is
    the default setting), and for Cisco IOS , we must set this to `enable`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With that, you have learned the necessary steps to connect to network devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'To validate that the connection is working as expected (assuming you have access
    to a router running Cisco IOS), you can run this simple playbook, called `ios_facts.yaml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You can run this using a command such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: If it returns successfully, this means that your configuration is correct and
    you've been able to give Ansible the necessary authorization to manage your IOS
    device.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, if you wanted to connect to a Cumulus VX device, you could add another
    group variables file called `group_vars/cumulusvx.yml` containing the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'An analogous playbook that returns all the facts about our Cumulus VX switches
    could look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'You can run this in a normal manner by using a command such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'If successful, you should see the following output from your playbook run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This demonstrates the techniques for connecting to two different types of network
    devices in Ansible, including one you can test by yourself without access to any
    special hardware. Now, let's build on this by looking at how to set environment
    variables for network devices in Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: Environment variables for network devices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Very often, the complexity of networks is high and the network systems are very
    varied. For those reasons, Ansible has a huge amount of variables that can help
    you tweak it so that you can make Ansible fit your environment.
  prefs: []
  type: TYPE_NORMAL
- en: Let's suppose you have two different networks (that is, one for computing and
    one for network devices) that can't communicate directly, but have to pass through
    a bastion host to reach one from the other. Since we have Ansible in the computing
    network, we will need to jump networks using the bastion host to configure an
    IOS router in the management network. Also, our target switch needs a proxy to
    reach the internet.
  prefs: []
  type: TYPE_NORMAL
- en: 'To connect to the IOS router in the database network, we will need to create
    a new group for our network devices, which are on a separate network. For this
    example, this might be specified as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Following the creation of our updated inventory, we can create a new group
    variables file, such as `group_vars/bastion_routers.yaml`, with the following
    content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also do the same for our Cumulus VX switches if they are behind a bastion
    server by creating a `group_vars/bastion_cumulusvx.yml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition to the options we discussed in the previous section, we now have
    two additional options:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ansible_ssh_common_args`: This is a very powerful option that allows us to
    add additional options to the SSH connections so that we can tweak their behavior.
    These options should be fairly straightforward to identify since you are already
    using them in your SSH configurations to simply SSH to the target machine. In
    this specific case, we are adding a `ProxyCommand`, which is the SSH directive
    to perform a jump to a host (usually a bastion host) so that we can enter the
    target host securely.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`http_proxy`: This option, which is below the `proxy_env` option, is key in
    environments where network isolation is strong, and therefore your machines can''t
    interact with the internet unless they use a proxy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Assuming you have set up passwordless (for example, SSH key-based) access to
    your bastion host, you should be able to run an ad hoc Ansible `ping` command
    against your Cumulus VX host, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Note that the use of the bastion server becomes transparent – you can carry
    on automating with Ansible as if you were on the same flat network. If you have
    access to a Cisco IOS-based device, you should be able to run a similar command
    against the `bastion_routers` group as well and achieve similarly positive results.
    Now that you have learned the necessary steps to set environment variables for
    network devices, and indeed access them with Ansible, even when they are on isolated
    networks, let's learn how to set conditional statements for networking devices.
  prefs: []
  type: TYPE_NORMAL
- en: Conditional statements for networking devices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although there are no networking-specific Ansible conditionals, conditionals
    are fairly common in networking-related Ansible usage.
  prefs: []
  type: TYPE_NORMAL
- en: In networking, it's common to enable and disable ports. To have data pass through
    the cable, both ports at the ends of the cable should be enabled and result in
    a "connected" state (some vendors will use different names for this, but the idea
    is the same).
  prefs: []
  type: TYPE_NORMAL
- en: Let's suppose we have two Arista Networks EOS devices and we issued the ON status
    on the ports and need to wait for the connection to be up before proceeding.
  prefs: []
  type: TYPE_NORMAL
- en: 'To wait for the `Ethernet4` interface to be enabled, we will need to add the
    following task in our playbook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '`eos_command` is the module that allows us to issue free-formed commands to
    an Arista Networks EOS device. The command itself needs to be specified in an
    array in the `commands` option. With the `wait_for` option, we can specify a condition,
    and Ansible will reiterate on the specified task until the condition is satisfied.
    Since the command''s output is redirected to the `json` utility, the output will
    be a JSON, so we can traverse its structure using Ansible''s ability to manipulate
    JSON data.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can achieve similar results on Cumulus VX – for example, we can query the
    facts gathered from the switch to see if port `swp2` is enabled. If it is not,
    then we will enable it; however, if it is enabled, we will skip the command. We
    can do this with a simple playbook, follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice the use of the `when` clause in our task, meaning we should only issue
    the configuration directive if `swp2` is not active. If we were to run this playbook
    for the first time on an unconfigured Cumulus Linux switch, we should see an output
    similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, the `nclu` module committed our change to the switch configuration.
    However, if we were to run the playbook a second time, the output should be more
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This time, the task was skipped as the Ansible facts show that port `swp2` is
    already enabled. This is obviously an incredibly simple example, but it shows
    how you can work with conditionals on a network device very much in the same way
    that you have already seen conditionals being used on Linux servers, earlier in
    this book.
  prefs: []
  type: TYPE_NORMAL
- en: That concludes our brief look at network device automation with Ansible – more
    in-depth work would require a look at network configurations and necessitate more
    hardware, so this is beyond the scope of this book. However, I hope that this
    information demonstrates to you that Ansible can be used effectively to automate
    and configure a wide array of network devices.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Modern large-scale infrastructures that change rapidly necessitate automation
    of network tasks. Fortunately, Ansible supports a wide array of network devices,
    from proprietary hardware such as Cisco IOS-based devices, through to open standards
    such as white box switches that run operating systems such as Cumulus Linux. Ansible
    is a powerful and supportive tool when it comes to managing your network configuration
    and allows you to implement changes quickly and safely. You can even replace entire
    devices in your network and be confident in your ability to put the correct configuration
    on the new device in place by virtue of your Ansible playbooks.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you learned about the reasons for automating network management.
    You then looked at how Ansible manages network devices, how to enable network
    automation in Ansible, and how to locate the Ansible modules necessary to perform
    the automation tasks you wish to complete. Then, through practical examples, you
    learned how to connect to network devices, how to set environment variables (and
    connect to isolated networks via bastion hosts), and how to apply conditional
    statements to Ansible tasks for network device configuration.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to manage Linux containers and cloud
    infrastructures using Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Which of these is NOT one of the four major connection types that Ansible uses
    for connecting to those network devices?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A) `netconf`
  prefs: []
  type: TYPE_NORMAL
- en: B) `network_cli`
  prefs: []
  type: TYPE_NORMAL
- en: C) `local`
  prefs: []
  type: TYPE_NORMAL
- en: D) `netstat`
  prefs: []
  type: TYPE_NORMAL
- en: E) `httpapi`
  prefs: []
  type: TYPE_NORMAL
- en: 'True or False: The `ansible_network_os` variable is used by Ansible to understand
    the device family of the device we are going to use.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A) True
  prefs: []
  type: TYPE_NORMAL
- en: B) False
  prefs: []
  type: TYPE_NORMAL
- en: 'True or False: In order to connect to an IOS router in a separate network,
    you need to specify the special connection variables for the host, possibly as
    inventory group variables.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A) True
  prefs: []
  type: TYPE_NORMAL
- en: B) False
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The official documentation about Ansible networking: [https://docs.ansible.com/ansible/latest/network/index.html](https://docs.ansible.com/ansible/latest/network/index.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
