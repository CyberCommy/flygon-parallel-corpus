- en: Chapter 15. Packaging – Creating Your Own Libraries or Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The chapters thus far have covered how to write, test and, debug the Python
    code. With all of that, there is only one thing that remains, that is packaging
    and distributing your Python libraries /and applications. To create installable
    packages we will use the `setuptools` package which is bundled with Python these
    days. If you have created packages before, you might remember `distribute` and
    `distutils2`, but it is very important to remember that these have all been replaced
    by `setuptools` and `distutils` and you shouldn't use them anymore!
  prefs: []
  type: TYPE_NORMAL
- en: 'What types of program can we package with `setuptools`? We will show you several
    cases:'
  prefs: []
  type: TYPE_NORMAL
- en: Regular packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Packages with data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing executables and custom `setuptools` commands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running tests on the package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Packages containing C/C++ extensions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we actually get started, it is important to know how to install a package
    properly. There are at least four different options for installing a package.
    The first and most obvious is by using the plain `pip` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This can also be achieved by using `setup.py` directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This installs the package within your Python environment which would be the
    likely `virtualenv`/`venv` if you are using it or the global environment otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: For development however, this is not recommended. To test your code, you would
    need to either reinstall the package for every test or modify the files within
    the Python's `site-packages` directory, which would mean it would be outside of
    your revision control system as well. That's where the development installs come
    in; instead of copying the package files to the Python package directory, they
    simply install a link within the `site-packages` directory to the path where the
    package is actually located. This allows you to modify the code and immediately
    see the results in the scripts and applications you run without the need to reinstall
    your code after each change.
  prefs: []
  type: TYPE_NORMAL
- en: 'As is the case with a regular install, both `pip` and `setup.py` versions are
    available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'And the `setup.py` version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Setup parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous chapters have actually already shown us a couple of examples, but
    let's reiterate and review what the most important parts actually do. The core
    function you will be using in this entire chapter is `setuptools.setup`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For the most simple packages, the `distutils` package bundled with Python will
    be sufficient as well, but I recommend `setuptools` regardless. The `setuptools`
    package has many great features that `distutils` lacks and nearly all Python environments
    will have `setuptools` available anyhow.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we continue, make sure you have the latest version of both `pip` and
    `setuptools`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `setuptools` and `distutils` packages have changed significantly over the
    last few years and the documentation/examples written before 2014 are most likely
    out of date. Be careful not to implement deprecated examples and skip any documentation/examples
    using `distutils`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have all the prerequisites, let''s create an example containing
    the most important fields with inline documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: That was quite a lot of code and comments, but it covers most of the options
    you will ever encounter in real-life packages. The most interesting and versatile
    parameters discussed here will be covered in the following sections separately.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additional documentation can be found in the `pip` and `setuptools` documentation,
    as well as in the Python Packaging User Guide:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://pythonhosted.org/setuptools/](http://pythonhosted.org/setuptools/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://pip.pypa.io/en/stable/](https://pip.pypa.io/en/stable/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://python-packaging-user-guide.readthedocs.org/en/latest/](http://python-packaging-user-guide.readthedocs.org/en/latest/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In our example, we simply use `packages=setuptools.find_packages()`. In most
    cases this will work just fine, but it''s important to understand what it does.
    The `find_packages` function looks through all the directories within the given
    directory and adds it to the list if it has an `__init__.py` file inside. So instead
    of `find_packages()` you can generally use `[''your_package'']` instead. If you
    have several packages however, that tends to get tedious. That''s where `find_packages()`
    is useful; simply specify some inclusion parameters (second parameter) or some
    exclusion parameters (third parameter) and you''ll have all the relevant packages
    within your project. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Entry points
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `entry_points` parameter is arguably the most useful feature of `setuptools`.
    It allows you to add hooks to many things within `setuptools` but the most useful
    two are the possibility to add both the command line and GUI commands and to extend
    the `setuptools` commands. The command line and GUI commands will even be converted
    to executables on Windows. The example in the first section already demonstrated
    both the features:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This demonstration only shows how to call the functions but it doesn't show
    the actual functions.
  prefs: []
  type: TYPE_NORMAL
- en: Creating global commands
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first, a simple example, is nothing special at all; just a function that
    gets called as a regular `main` function where you need to specify `sys.argv`
    yourself (or better, use `argparse`). This is the `setup.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'And, of course, here''s the `spam/main.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Be sure not to forget to create a `spam/__init__.py` file. It can be empty but
    it needs to exist for Python to know that it's a package.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s give it a try by installing the package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: See how easy it was to create a `spam` command that installs in your regular
    command line shell! On Windows it will actually give you an executable which will
    be added to your path but regardless of the platform it will be as a separate
    executable that's callable.
  prefs: []
  type: TYPE_NORMAL
- en: Custom setup.py commands
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Writing custom `setup.py` commands can be very useful. One example is `sphinx-pypi-upload-2`
    which I use in all my packages and is my fork of the unmaintained `sphinx-pypi-upload`
    package. It''s a package that makes it trivial to build and upload Sphinx documentation
    to the Python package index, which is very useful when distributing your packages.
    With the `sphinx-pypi-upload-2` package you can do the following (which I do when
    distributing any of the packages I maintain):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This command builds your package and uploads it to PyPI, and builds the Sphinx
    documentation and uploads it to PyPI as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'But you want to see how this works, of course. First, here''s `setup.py` for
    our `spam` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Second, the `SpamCommand` class. The basic essentials are inheriting `setuptools.Command`
    and making sure to implement all the needed methods. Note that all of these need
    to be implemented but can be left empty if desired. Here is the `spam/command.py`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Executing it is simple enough:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: There are very few cases where you will actually need the custom `setup.py`
    commands, but the example is still useful since it is currently an undocumented
    part of `setuptools`.
  prefs: []
  type: TYPE_NORMAL
- en: Package data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In most cases you probably won''t have to include the package data, but in
    the cases where you do need data to go with your package, there are a few different
    options. First, it is important to know which files are included in your package
    by default:'
  prefs: []
  type: TYPE_NORMAL
- en: Python source files in the package directories recursively
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `setup.py` and `setup.cfg` files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Tests: `test/test*.py`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All `*.txt` and `*.py` files in the `examples` directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All `*.txt` files in the root directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So after the defaults, we have the first solution: the `package_data` argument
    to the setup function. The syntax for that is simple enough, a dictionary where
    the keys are the packages and the values are the patterns to include:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The second solution is using a `MANIFEST.in` file. This file contains patterns
    to include, exclude, and more. The `include` and `exclude` commands use patterns
    to match. These patterns are glob-style patterns (see the `glob` module for documentation:
    [https://docs.python.org/3/library/glob.html](https://docs.python.org/3/library/glob.html))
    and have three variants for both the include and exclude commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '`include`/`exclude`: These commands only work for the given path and nothing
    else'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`recursive-include`/`recursive-exclude`: These commands are similar to the
    `include`/`exclude` commands but process the given paths recursively'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`global-include`/`global-exclude`: Be very careful with these, they will include
    or exclude these files anywhere within the source tree'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Besides the `include`/`exclude` commands, there are also two others; the `graft`
    and `prune` commands which include or exclude directories including all the files
    under a given directory. This can be useful for tests and documentation since
    they can include non-standard files. Beyond those examples, it''s almost always
    better to explicitly include the files you need and ignore all the others. Here''s
    an example `MANIFEST.in`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Testing packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 10](ch10.html "Chapter 10. Testing and Logging – Preparing for Bugs"),
    *Testing and Logging – Preparing for Bugs*, the testing chapter, we saw a few
    of the many testing systems for Python. As you might suspect, at least some of
    these have `setup.py` integration.
  prefs: []
  type: TYPE_NORMAL
- en: Unittest
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we start, we should create a test script for our package. For actual
    tests, look at [Chapter 10](ch10.html "Chapter 10. Testing and Logging – Preparing
    for Bugs"), *Testing and Logging – Preparing for Bugs*, the testing chapter. In
    this case, we will just use a no-op test, `test.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The standard `python setup.py test` command will run the regular `unittest`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: It is possible to tell `setup.py` to use different tests using the `--test-module`,
    `--test-suite`, or `--test-runner` arguments. While these are easy enough to use,
    I recommend skipping the regular `test` command and trying `nose` or `py.test`
    instead.
  prefs: []
  type: TYPE_NORMAL
- en: py.test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `py.test` package has several methods of integration: `pytest-runner`,
    your own test command, and the deprecated method of generating a `runtests.py`
    script to test. If one of your packages is still using `runtests.py`, I strongly
    recommend switching to one of the other options.'
  prefs: []
  type: TYPE_NORMAL
- en: 'But before we discuss the other options, let''s make sure we have some tests.
    So let''s create a test in our package. We will store it in `test_pytest.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the other test options. Since the custom command doesn''t really add much
    and actually makes things more complicated, we will skip that. If you want to
    customize how the tests are being run, use the `pytest.ini` and `setup.cfg` files
    instead. The best option is `pytest-runner` which makes running tests a trivial
    task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'To properly integrate this method, we should make a few changes to the `setup.py`
    script. They are not strictly needed but it makes things more convenient for others
    using your package, others that may not be aware that you are using `py.test,`
    for example. First, we make sure that the standard `python setup.py test` command
    actually runs the `pytest` command instead by modifying `setup.cfg`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Second, we want to make sure that the `setup.py` command installs the packages
    we need to run the `py.test` tests. To do that, we need to modify `setup.py` as
    well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The beauty of this approach is that the regular `python setup.py test` command
    works and all needed requirements are automatically installed before running the
    tests. Because the `pytest` requirement is only in the `tests_require` section
    however, they will not be installed if the test command isn't run. The only package
    that will always be installed is the `pytest-runner` package and that's a really
    light package so it will be very light to install and run.
  prefs: []
  type: TYPE_NORMAL
- en: Nosetests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `nose` package handles the installation only and is slightly different
    from `py.test`. The only difference is that `py.test` has a separate `pytest-runner`
    package for the test runner and nose package has a built-in `nosetests` command.
    So without further ado, here is the nose version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: C/C++ extensions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous chapter already covered this somewhat, as it's a requirement to
    compile the C/C++ files. But that chapter didn't explain what and how the `setup.py`
    was doing in this case.
  prefs: []
  type: TYPE_NORMAL
- en: 'For convenience, we will repeat the `setup.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Before you start with these extensions, you should learn the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '`build`: This is actually not a C/C++ specific build function (try `build_clib`
    for that) but a combined build function to build everything within `setup.py`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`clean`: This cleans the results from the `build` command. This is generally
    not needed but sometimes the detection of files that need to be recompiled to
    work is incorrect. So if you encounter strange or unexpected issues, try cleaning
    the project first.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regular extensions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `setuptools.Extension` class tells `setuptools` that a module named `spam`
    uses the source file `spam.c`. This is just the simplest version of an extension,
    a name, and a list of sources, but in many cases you are going to need more than
    the simple case.
  prefs: []
  type: TYPE_NORMAL
- en: 'One example is the `pillow` library which detects the libraries available on
    the system and adds extensions based on that. But because these extensions include
    libraries, some extra compilation flags are required. The basic PIL module itself
    doesn''t appear too involved but the libs are actually filled with all auto-detected
    libraries with the matching macro definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The `freetype` extension has something similar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Cython extensions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `setuptools` library is actually a bit smarter than the regular `distutils`
    library when it comes to extensions. It actually adds a little trick to the `Extension`
    class. Remember the brief introduction to `Cython` in [Chapter 12](ch12.html "Chapter 12. Performance
    – Tracking and Reducing Your Memory and CPU Usage"), *Performance – Tracking and
    Reducing Your Memory and CPU Usage* about performance? The `setuptools` library
    makes it a bit more convenient to compile those. The `Cython` manual recommends
    you to use something similar to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Here `eggs.pyx` contains:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The problem with this approach is that `setup.py` will break unless you have
    `Cython` installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'To prevent that issue, we are just going to let `setuptools` handle this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now `Cython` will be automatically installed if needed and the code will work
    just fine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'For development purposes however, `Cython` also offers a simpler method which
    doesn''t require manual building. First, to make sure we are actually using this
    method, let''s install `Cython` and uninstall and clean `eggs` completely:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s try and run our `eggs.pyx` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: That's how easy it is to run the `pyx` files without explicit compiling.
  prefs: []
  type: TYPE_NORMAL
- en: Wheels – the new eggs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For pure Python packages, the `sdist` (source distribution) command has always
    been enough. For C/C++ packages however, it is usually not that convenient. The
    problem with C/C++ packages is that compilation is needed unless you use a binary
    package. Traditionally those were generally the `.egg` files but they never really
    solved the issue quite right. That is why the `wheel` format has been introduced
    (PEP 0427), a binary package format that contains both source and binaries and
    can install on both Windows and OS X without requiring a compiler. As an added
    bonus, it installs faster for pure Python packages as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Implementation is luckily simple. First, install the `wheel` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you''ll be able to use the `bdist_wheel` command to build your packages.
    The only small gotcha is that by default the packages created by Python 3 will
    only work on Python 3, so Python 2 installations will fall back to the `sdist`
    file. To fix that, you can add the following to your `setup.cfg` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The only important thing to note here is that in the case of C extensions, this
    can go wrong. The binary C extensions for Python 3 are not compatible with those
    from Python 2\. So if you have a pure Python package and are targeting both Python
    2 and 3, enable the flag. Otherwise just leave it as the default.
  prefs: []
  type: TYPE_NORMAL
- en: Distributing to the Python Package Index
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once you have everything up and running, tested, and documented, it is time
    to actually push the project to the **Python Package Index** (**PyPI**). Before
    pushing the package to PyPI, we need to make sure everything is in order.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s check the `setup.py` file for issues:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'It seems that we forgot to specify a `url` and the `author` or `maintainer`
    information. Let''s fill those:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s check again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Perfect! No errors and everything looks good.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that our `setup.py` is in order, let''s try testing. Since our little test
    project has virtually no tests, this will come up close to empty. But if you''re
    starting a new project, then I recommend trying to maintain 100 percent test coverage
    from the beginning. Implementing all the tests later is usually more difficult,
    and testing while you work generally makes you think more about the design decisions
    of the code. Running the test is easy enough:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have all in check, the next step is building the documentation.
    As mentioned earlier, the `sphinx` and `sphinx-pypi-upload-2` packages can help
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we are certain that everything is correct, we can build the package and
    upload it to PyPI. For pure Python releases, you can use the `sdist` (source distribution)
    command. For a package that uses a native installer, there are a few options,
    such as `bdist_wininst` and `bdist_rpm`, available. I personally use the following
    for nearly all my packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This automatically builds the Sphinx documentation, uploads the documentation
    to PyPI, builds the package with the source, and uploads the package with the
    source.
  prefs: []
  type: TYPE_NORMAL
- en: This will obviously only succeed if you are the owner of that specific package
    and are authorized with PyPI.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before you can upload the packages, you need to register the package on PyPI.
    This can be done using the `register` command, but since that immediately registers
    the package at the PyPI servers, it should not be used while testing.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After reading this chapter, you should be able to create Python packages containing
    not only pure-Python files but also extra data, compiled C/C++ extensions, documentation,
    and tests. With all these tools at your disposal, you are now able to make high
    quality Python packages that can easily be reused in other projects and packages.
  prefs: []
  type: TYPE_NORMAL
- en: The Python infrastructure makes it really quite easy to create new packages
    and split your project into multiple subprojects. This allows you to create simple
    and reusable packages with fewer bugs because everything is easily testable. While
    you shouldn't go overboard with splitting up the packages, if a script or module
    has a purpose of its own then it's a candidate for packaging separately.
  prefs: []
  type: TYPE_NORMAL
- en: With this chapter we have come to the end of the book. I sincerely hope you
    enjoyed reading it and have learned about new and interesting topics. Any and
    all feedback is greatly appreciated, so feel free to contact me through my website
    at [https://wol.ph/](https://wol.ph/).
  prefs: []
  type: TYPE_NORMAL
