- en: Implementing Complex User Interfaces - Part I
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will implement complex user interfaces. We will learn more
    about using flexbox to create components that work on different screen sizes,
    how to detect orientation changes, and more.
  prefs: []
  type: TYPE_NORMAL
- en: 'The chapter will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a reusable button with theme support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a complex layout for tablets using flexbox
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Including custom fonts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using font icons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a reusable button with theme support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reusability is very important when developing software. We should avoid repeating
    the same thing over and over again, and instead we should create small components
    that we can reuse as many times as possible.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will create a `Button` component, and we are also going to
    define several properties to change its look and feel. While going through this
    recipe, we will learn how to dynamically apply different styles to a component.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We need to create an empty app. Let's name it `reusable-button`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the root of our new app, we'll need to create a new `Button` folder for our
    reusable button-related code. Let's also create `index.js` and `styles.js` in
    our new `Button` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will start by importing the dependencies for our new component. In the `Button/index.js`
    file, we will be creating a `Button` component. This means we''ll need to import
    the `Text` and `TouchableOpacity` components. You''ll notice we''re also importing
    styles that do not exist yet. We will define these styles in a different file
    later in this recipe. In the `Button/index.js` file, we should have these imports:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our dependencies imported, let''s define the class for this
    component. We are going to need some properties and two methods. It''s also required
    that we export this component so we can use it elsewhere:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to select the styles to apply to our component based on the given `properties`.
    For this purpose, we will define the `getTheme` method. This method will check
    whether any of the `properties` are `true` and will return the appropriate styles. If
    none are `true`, it will return the `Default` style:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: It's required that all components have a `render` method. Here, we need to return
    the JSX elements for this component. In this case, we will get the styles for
    the given `properties` and apply them to the `TouchableOpacity` component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We are also defining a label for the button. Inside this label, we will render
    the `children` property. If a callback function is received, then it will be executed
    when the user presses this component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We are almost done with our `Button` component. We still need to define our
    styles, but first let's move over to the `App.js` file in the root of the project.
    We need to import the dependencies, including the `Button` component we have created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We are going to display an alert message when the user clicks the button, therefore,
    we also need to import the `Alert` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have all the dependencies, let''s define a stateless component that
    renders a few buttons. The first button will use the default style, and the second
    button will use the success style, which will add a nice green color to the button''s
    background. The last button will display an alert when it gets pressed. For that,
    we need to define the callback function that will use the `Alert` component, just
    setting the title and message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We are going to add some styles for how the main layout should align and justify
    each button, along with some margins:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If we try to run the app now, we will get some errors. This is because we haven''t
    declared the styles for our button. Let''s work on that now. Inside the `Button/styles.js` file,
    we need to define the base styles. These styles will be applied to every instance
    of the button. Here, we will define a radius, padding, font color, and all the
    common styles that we need for this component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Once we have the common styles for our button, we need to define the styles
    for the `Danger`, `Info`, `Success`, and `Default` themes. For this, we are going
    to define different objects for each theme. Inside each theme, we will use the
    same object but with specific styles for that theme.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To keep things simple, we are only going to change the `backgroundColor`, but
    we do have the option to use as many style properties as we want:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let''s export the styles. This step is necessary so that the `Button`
    component can import all the styles for each theme:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If we open the app, we should be able to see our completed layout:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/fb784d29-16db-4a64-a1c9-bba06dcfaf0a.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this example, we made use of the `TouchableOpacity` component. This component
    allows us to define a nice animation that changes the opacity when the user presses
    the button.
  prefs: []
  type: TYPE_NORMAL
- en: We can use the `activeOpacity` property to set the opacity value when the button
    gets pressed. The value can be any number between `0` and `1`, where `0` is completely
    transparent.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we press the rounded button, we will see a native Alert message, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/4b6b4ca1-7313-4570-9e82-17758d2b4711.png)'
  prefs: []
  type: TYPE_IMG
- en: Building a complex layout for tablets using flexbox
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Flexbox is really convenient when it comes to creating responsive layouts. React
    Native uses flexbox as a layout system, and if you are already familiar with these
    concepts, it will be really easy for you to start creating layouts of any kind.
  prefs: []
  type: TYPE_NORMAL
- en: As discussed in the previous chapter, there are some differences between the
    way flexbox works in React Native as compared to how it works in CSS. For more
    information on the differences between React Native and CSS flexbox, please refer
    to the *How it works... *section of the *Using flexbox to create a layout *recipe
    in [Chapter 2](42da7816-9fd6-4736-ab11-088cb4dbc1c1.xhtml), *Creating a Simple
    React Native App*.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will create a layout to display a list of blog posts. Each
    post will be a small card with an image, an excerpt, and a button to read more.
    We will use flexbox to arrange the posts on the main container based on screen
    size. This will allow us to handle the screen rotation by properly aligning the
    cards in both landscape and portrait.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are going to need a new app for this recipe. Let's name it `tablet-flexbox`.
  prefs: []
  type: TYPE_NORMAL
- en: When we create a new app with Expo, there is an `app.json` that gets created
    at the base of the project that provides some basic configuration. In this recipe,
    we are building an app that we want to be sure looks good on a tablet, particularly
    in landscape mode. When we open `app.json`, we should see an `orientation` property
    set to `'portrait'`. This property determines which orientations should be allowed
    within our app. The `orientation` property accepts `'portrait'` (lock app to portrait
    mode), `'landscape'` (lock app to landscape mode), and `'default'` (allow app
    to adjust screen orientation based on the device's orientation). For our app,
    we will set the `orientation` to `'landscape'` so that we can support both landscape
    and portrait layouts.
  prefs: []
  type: TYPE_NORMAL
- en: We'll also be using some images, which need to be hosted remotely for this recipe
    to properly simulate loading remote data and displaying images with the `Image`
    component. I have uploaded these images to the [www.imgur.com](http://www.imgur.com) image
    hosting service, and referenced these remote images in the `data.json` file that
    the recipe uses for its consumable data. If, for any reason these remote images
    don't load properly for you, they are also in included in the repository for this
    recipe under the `/assets` folder. Feel free to upload them to any server or hosting
    service, and update the image URLs in `data.json` accordingly. The repository
    can be found on GitHub at [https://github.com/warlyware/react-native-cookbook/tree/master/chapter-3/tablet-flexbox](https://github.com/warlyware/react-native-cookbook/tree/master/chapter-3/tablet-flexbox).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, we need to create a `Post` folder in the root of the project. We need
    to also create an `index.js` and a `styles.js` file in the new `Post` folder.
    We will use this `Post` component to display each post for our app. Finally, we
    need to add a `data.json` file to the root of the project, which we will use to
    define a list of posts.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now we can move on to building the `App.js` component. First, we need to import
    the dependencies for this class. We are going to use a `ListView` component to
    render the list of posts. We''ll also need `Text` and `View` components for content
    containers. We are going to create a custom `Post` component to render each post
    on the list, and we will also need to import the `data.json` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Let's create the class for the `App` component. Here, we will use the data from
    the `.json` file to create the `dataSource` for the list. We will add some actual
    data to our `data.json` file in the next step. In the `render` method, we are
    going to define a simple top toolbar and the `List` component. We are going to
    use the `Post` component for every record and get the `dataSource` from the `state`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you have any questions regarding the `ListView` component, you should take
    a look at the recipe in [Chapter 2](42da7816-9fd6-4736-ab11-088cb4dbc1c1.xhtml), *Creating
    a Simple React Native App*, where we created a list of orders:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Two files are still missing: the `.json` file with the data and the `Post`
    component. In this step, we will create the data that we are going to use for
    each post. To make things simple, there is only one record of data in the following
    code snippet, but the rest of the `POST` object I used in this recipe can be found
    in the `data.json` file of the code repository for this recipe, located at [https://github.com/warlyware/react-native-cookbook/blob/master/chapter-3/tablet-flexbox/data.json](https://github.com/warlyware/react-native-cookbook/blob/master/chapter-3/tablet-flexbox/data.json):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have some data, we are ready to work on the `Post` component. In
    this component, we need to display the image, title, and button. Since this component
    does not need to know about state, we will use a stateless component. The following
    code uses all the components we learned about in [Chapter 2](42da7816-9fd6-4736-ab11-088cb4dbc1c1.xhtml), *Creating
    a Simple React Native App*. If something is unclear, please review that chapter
    again. This component receives the data as a parameter, which we then use for
    displaying the content in the component. The `Image` component will use the `img`
    property defined on each object in the `data.json` file to display the remote
    image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have defined the component, we also need to define the styles for each
    post. Let''s create an empty `StyleSheet` export so that the `Post` component
    relying on `styles.js` will properly function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: If we try to run the app, we should be able to see the data from the `.json`
    file on the screen. It won't be very pretty though, since, we haven't applied
    any styles yet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We have everything we need on the screen. Now we are ready to start working
    on the layout. First, let''s add styles for our `Post` container. We''ll be setting `width`,
    `height`, `borderRadius`, and a few others. Let''s add them to the `/Post/styles.js`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'By now, we should see small boxes vertically aligned. That''s some progress,
    but we need to add more styles to the image so we can see it onscreen. Let''s
    add an `image` property to the same `styles` const from the last step. The `resizeMode`
    property will allow us to set how we want to resize the image. In this case, by
    selecting `cover`, the image will keep the aspect ratio of the original:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'For the `content` of the post, we want to take up all of the available height
    on the card, therefore we need to make it flexible and add some padding. We''ll
    also add `overflow: hidden` to the content to avoid overflowing the `View` element.
    For the `title`, we only need to change the `fontSize` and add a `margin` to the
    bottom:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, for the button, we will set the `backgroundColor` to green and the
    text to white. We also need to add some `padding` and `margin` for spacing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'If we refresh the simulator, we should see our posts in small cards. Currently,
    the cards are arranged vertically, but we want to render all of them horizontally.
    We are going to fix that in the following steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/9b2adc12-a3f8-4fe4-9a57-1a67d26382d0.png)Primary styles have been
    added for all post elements'
  prefs: []
  type: TYPE_NORMAL
- en: 'Currently, we can only see the first three items on the list in a column instead
    of in a row across the screen. Let''s return to the `App.js` file and start adding
    our styles. We add `flex: 1` to the `container` so that our layout will always
    fill the screen. We also want to show a toolbar at the top. For that, we just
    need to define some `padding` and `color` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s add some basic styles to the `list` as well. Just a nice background
    color and some padding. We''ll also add the `flex` property, which will ensure
    the list takes all the available height on the screen. We only have two components
    here: the toolbar and the list. The toolbar is taking about 50 px. If we make
    the list flexible, it will take all of the remaining available space, which is
    exactly what we want when rotating the device or when running the app in different
    screen resolutions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'If we check the app in the simulator once more, we should be able to see the
    toolbar and list being laid out as expected:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/7136ddc4-acb9-4d77-a451-d8b6fa2e90b8.png)Styles have been applied
    to each post to give them a card like appearance'
  prefs: []
  type: TYPE_NORMAL
- en: 'We are almost done with this app. All we have left to do is to arrange the
    cards horizontally. This can be achieved with flexbox in three simple steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The first step is applying these `content` styles via the `contentContainerStyle`
    property in the `ListView` component. Internally, the `ListView` component will
    apply these styles to the content container, which wraps all of the child views.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then set the `flexDirection` to `row`. This will horizontally align the
    cards on the list; however, this presents a new problem: we can only see one single
    row of posts. To fix the problem, we need to wrap the items. We do this by setting
    the `flexWrap` property to `wrap`, which will automatically move the items that
    don''t fit in the view to the next row. Lastly, we use the `justifyContent` property
    and set it to `center`, which will center our `ListView` in the middle of our
    app.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We now have a responsive app that looks good on a tablet in landscape mode:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/cbd691f2-e7a5-484e-8381-4db14dd7ad36.png)'
  prefs: []
  type: TYPE_IMG
- en: Side-by-side comparison of iPad and Android tablet screenshots in landscape
    mode
  prefs: []
  type: TYPE_NORMAL
- en: 'And looks just as good in portrait mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/07bd3013-a9eb-4d81-9bd5-240d3731943b.png)Side-by-side comparison
    of iPad and Android tablet screenshots in portrait mode'
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Expo also provides a `ScreenOrientation` helper for changing the orientation
    configuration of the app. This helper also allows for more granular orientation
    settings (such as `ALL_BUT_UPSIDE_DOWN` or `LANDSCAPE_RIGHT`). If your app needs
    dynamic, granular control over screen orientation, see the `ScreenOrientation`
    Expo documentation for information: [https://docs.expo.io/versions/v24.0.0/sdk/screen-orientation.html](https://docs.expo.io/versions/v24.0.0/sdk/screen-orientation.html).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Official documentation on static image resources and the `<Image>` component
    can be found at[ https://facebook.github.io/react-native/docs/images.html](https://facebook.github.io/react-native/docs/images.html).
  prefs: []
  type: TYPE_NORMAL
- en: Including custom fonts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At some point, we are probably going to want to display text with a custom font
    family. Until now, we've been using the default font, but we can use any other
    that we like.
  prefs: []
  type: TYPE_NORMAL
- en: Before Expo, the process of adding custom fonts was more difficult, required
    working with native code, and needed to be implemented differently in iOS and
    Android. Luckily, through the use of Expo's font helper library, this has become
    streamlined and simplified.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will import a few fonts and then display text using each
    of the imported font families. We will also use different font styles, such as
    **bold** and *italic*.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to work on this example we need some fonts. You can use whatever fonts
    you want. I recommend going to Google Fonts ([https://fonts.google.com/](https://fonts.google.com/))
    and downloading your favorites. For this recipe, we will be using theJosefin Sans and Raleway
    fonts.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the fonts downloaded, let's create an empty app and name it `custom-fonts`. 
    When we create a blank app with Expo, it creates an `assets` folder in the root
    of the project for placing all of your assets (images, fonts, and so on), so we'll
    follow the standard and add our fonts to this folder. Let's create the `/assets/fonts`
    folder and add our custom font files downloaded from Google Fonts.
  prefs: []
  type: TYPE_NORMAL
- en: When downloading fonts from Google Fonts, you'll get a `.zip` file containing
    a `.ttf` file for each of the font family variants.  We will be using the regular, **bold**,
    and *italic*variations, so copy the corresponding `.ttf` files for each variant
    in each family to our `/assets/fonts` folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With our font files in place, the first step is to open `App.js` and add the
    imports we''ll need:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''ll add a simple component for displaying some text that we want to
    style with our custom fonts. We''ll start with just one `Text` element to display
    the regular variant of the Roboto font:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s also add some starter styles for the component we''ve just created.
    For now, we''ll just increase the font size for our `josefinSans` class styles:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'If we open the app now in our simulator, we will see the Hello, Josefin Sans!
    text displayed in the middle of the screen using the default font:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/29a14fb0-a5c0-4208-acb2-eb0a0221f62a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s load our `JosefinSans-Regular.ttf` font file so that we can style our
    text with it. We''ll use the `componentDidMount` life cycle hook provided by React
    Native to tell our app when to start loading the font:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''ll add the font we''re loading to the styles being applied to our
    `Text` element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We now have styles, right? Well, not quite. If we look back at our simulators,
    we''ll see that we''re getting an error instead:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'But we did just load fonts via `Expo.Font.loadAsync`! What gives? It turns
    out we have a race condition on our hands. The `josefinSans` styles we defined
    for our `Text` element are being applied before the Josefin Sans font has been
    loaded. To handle this problem, will need to use the component''s `state` to keep
    track of the load status of the font:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that our component has a `state`, we can update the state''s `fontLoaded`
    property to `true` once the font is loaded. Using the ES6 feature `async`/`await`
    makes this succinct and straightforward. Let''s do this in our `componentDidMount`
    code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we are now awaiting the `Font.loadAsync()` call, we can set the state
    of `fontLoaded` to `true` once the call is complete:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'All that''s left to do is to update our `render` method to only render the
    `Text` element that depends on the custom font when the `fontLoaded` state property
    is `true`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when we check out our app in the simulators, we should see our custom
    font being applied:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/2702c3c8-c45a-4a87-8f45-0d1e93006668.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s load the rest of our fonts so that we can use them in our app as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll also need `Text` elements for displaying text in each of our new font
    families/variants. Note that we''ll also need to wrap all our `Text` elements
    in another `View` element, since JSX expressions require that there be only one
    parent node. We''re also now passing the `style` property an array of styles to
    apply in order to consolidate the `fontSize` and `padding` styles we''ll be applying
    in the next step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'All that''s left to apply our custom fonts is to add the new styles to the
    `StyleSheet`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in our app, we''ll see six different text elements, each styled with its
    own custom font:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/ea1e48cb-17e9-490d-bd1a-2eca8180b23c.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *step 5* and *step 6*, we used the `componentDidMount` React life cycle hook 
    to tell when our app finishes loading. While it may seem tempting to use `componentWillMount`,
    this too will throw an error, since `componentWillMount` is not guaranteed to
    wait for our `Font.loadAsync` to finish. By using `componentDidMount`, we can
    also assure we are not blocking the initial rendering of the app.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 9*, we used the ES6 feature `async`/`await`. You're likely familiar
    with this pattern if you're a web developer, but if you'd like more information,
    I've included an awesome article from [ponyfoo.com](http://ponyfoo.com) in the
    *See also* section at the end of this recipe, which does a great job of explaining
    how `async`/`await` works.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 11*, we used a ternary statement to render either our custom font styled
    `Text` element if loaded, or to render nothing if it's not loaded by returning
    `null`.
  prefs: []
  type: TYPE_NORMAL
- en: Fonts loaded through Expo don’t currently support the `fontWeight` or `fontStyle`
    properties—you will need to load those variations of the font and specify them
    by name, as we have done here with bold and italic.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A great article on `async`/`await` can be found at [https://ponyfoo.com/articles/understanding-javascript-async-await](https://ponyfoo.com/articles/understanding-javascript-async-await).
  prefs: []
  type: TYPE_NORMAL
- en: Using font icons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Icons are an indispensable part of almost any app, particularly in navigation
    and buttons. Similar to Expo's font helper, covered in the previous chapter, Expo
    also has an icon helper that makes adding icon fonts much less of a hassle than
    using vanilla React Native. In this recipe, we'll see how to use the icon helper
    module with the popular `FontAwesome` and `Ionicons` icon font libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll need to make a new project for this recipe. Let's name this project `font-icons`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll begin by opening `App.js` and importing the dependencies that we need
    to build the app:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we can add the shell of the application, where we will display the icons:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside of the `View` element, let''s add two more `View` elements for holding
    icons from each icon set:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s add the styles for each of our declared elements. As we''ve seen
    in previous recipes, the `container` styles fill the screen with `flex: 1` and
    center the items with `alignItems` and `justifyContent` set to `center`. The `iconRow`
    property sets the `flexDirection` to `row` so that our icons will be lined up
    in a row:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that the basic structure of our app is in place, let''s add our icons.
    In the first row of icons, we''ll use four `FontAwesome` components to display
    four icons from the `FontAwesome` font library. The `name` property determines
    which icon should be used, the `size` property sets the size of the icon in pixels,
    and the `color` sets what color the icon should be:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Just as in CSS, the `color` property can be a color keyword defined in the CSS
    specification (you can check out the full list in the MDN docs at [https://developer.mozilla.org/en-US/docs/Web/CSS/color_value](https://developer.mozilla.org/en-US/docs/Web/CSS/color_value)),
    or a hex code for a given color.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next `View` element, we''ll add icons from the `Ionicons` font library.
    As you can see, the `Ionicons` element takes the same properties as the `FontAwesome`
    elements used in the previous step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The last step in this recipe is to add the remaining style, `iconPadding`,
    which just adds some padding to evenly space out each of our icons:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s all it takes! When we check out our app, there will be two rows of
    icons, each row showcasing icons from `FontAwesome` and `Ionicons` respectively:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/f7371449-caec-4c4a-9993-256cecd34e81.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `vector-icons` package that comes with Expo provides access to 11 full icon
    sets. All you have to do is import the associated component (for example, the
    `FontAwesome` component for Font Awesome icons) and provide it with the name that
    corresponds to the icon in the set that you'd like to use. You can find a full,
    searchable list of all the icons you can use with the `vector-icons` helper library
    in the `vector-icons` directory, hosted at [https://expo.github.io/vector-icons/](https://expo.github.io/vector-icons/).
    Simply set the element's `name` property to the icon name listed in the directory,
    add `size` and `color` properties, and you're done!
  prefs: []
  type: TYPE_NORMAL
- en: As the GitHub README for `vector-icons` states, this library is a compatibility
    layer created for using the icons provided by the `react-native-vector-icons`
    package in Expo. You can find this package at [https://github.com/oblador/react-native-vector-icons](https://github.com/oblador/react-native-vector-icons).
    If you are building a React Native app without Expo, you can get the same functionality
    by using the `react-native-vector-icons` library instead.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A catalog of all of the icons available in the `vector-icons` library can be
    found at [https://expo.github.io/vector-icons/](https://expo.github.io/vector-icons/).
  prefs: []
  type: TYPE_NORMAL
