- en: Sprite Animations in WebAssembly with SDL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the time of writing, **S****imple DirectMedia Layer** (**SDL**) is the only
    2D rendering library integrated into Emscripten for use in WebAssembly. But, even
    as more rendering libraries become available, SDL is a highly supported rendering
    library that has been ported to a large number of platforms and will remain both
    relevant and useful for WebAssembly and C++ development into the foreseeable future.
    Using SDL to render to WebGL saves us a tremendous amount of time, because we
    do not have to write the code to interface between our WebAssembly C++ code and
    WebGL ourselves. The large community also offers support and documentation. You
    can find more SDL resources online at [libsdl.org](http://libsdl.org).
  prefs: []
  type: TYPE_NORMAL
- en: 'You will need to include several images in your build to make this project
    work. Make sure you include the `/Chapter04/sprites/` and `/Chapter04/font/` folders
    from the project''s GitHub. If you haven''t yet downloaded the GitHub project,
    you can get it online from: [https://github.com/PacktPublishing/Hands-On-Game-Development-with-WebAssembly](https://github.com/PacktPublishing/Hands-On-Game-Development-with-WebAssembly).'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Using SDL in WebAssembly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rendering a sprite to the canvas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Animating a sprite
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moving the sprite
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using SDL in WebAssembly
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At this point, I could roll my own system for interaction between the WebAssembly
    module and the JavaScript WebGL library. That would involve using a function table
    to call the JavaScript WebGL functions from within C++. Luckily for us, the Emscripten
    team has done most of this work. They have created a port of a popular 2D C++
    graphics library that does this for us. SDL is a 2D graphics **Application Programming**
    **Interface** (**API**) built on top of OpenGL in most implementations. There
    is an Emscripten port that is used to help us render our 2D graphics on top of
    WebGL. If you would like to know what other libraries have been integrated into
    Emscripten, use the following `emcc` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If you run this command, you will notice that several different SDL libraries
    are displayed. These include SDL2, SDL2_image, SDL2_gfx, SDL2_ttf, and SDL2_net.
    SDL was created with a modular design to allow the user to include only the parts
    of SDL that they need, allowing the core SDL library to remain small. This is
    very helpful if your goal is to create a web game where download size is limited.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we will do is get familiar with SDL by creating a simple "Hello
    World" application that writes some text to the HTML5 canvas element. To do this,
    we will need to include two of the Emscripten libraries listed when we ran the
    `emcc --show-ports` command. We will need to add the core SDL library to our Emscripten
    compiled with the `USE_SDL=2,` flag, and we will need to add the SDL TrueType
    font library by adding the `USE_SDL_TTF=2` flag.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `.c` source code that will display a message such as `"HELLO SDL!"` inside
    an HTML canvas is relatively simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Let me walk you through exactly what is going on here. The first four lines
    of code are the SDL header files, as well as the Emscripten header file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Following this, there are three preprocessor defines. If we wanted to change
    the message or font size quickly, we would modify these first two lines. The third
    define is a little less clear. We have something called `FONT_FILE`, which is
    a string that appears to be a filesystem location. That is a little bit weird,
    because WebAssembly does not have access to the local filesystem. To give the
    WebAssembly module access to the TrueType font file in the fonts directory, we
    will use the `--preload-file` flag when we compile the `WASM` file. This will
    generate a `.data` file from the contents of the font directory. The web browser
    loads this data file into the virtual filesystem, which is accessed by the WebAssembly
    module. That means that the C code that we are writing will have access to this
    file as if it were accessing it inside a local filesystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Initializing SDL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Like in other targets for C/C++, the code begins execution from within the
    `main` function. We are going to start our `main` function by declaring some variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The first two variables are the `SDL_Window` and `SDL_Renderer` objects. The
    `window` object would define the application window that we would be rendering
    into if we were writing code for a Windows, Mac, or Linux system. When we build
    for WebAssembly, there is a canvas in our HTML, but SDL still requires a `window`
    object pointer for initialization and cleanup. All calls to SDL use the `renderer`
    object to render images to the canvas.
  prefs: []
  type: TYPE_NORMAL
- en: The `SDL_Rect dest` variable is a rectangle that represents the destination
    where we will be rendering onto the canvas. We will render to the center of the
    320x200 canvas, so we will start with an `x` and `y` value of `160` and `100`.
    We do not yet know the width and height of the text we will render, so, at this
    point, we are going to set `w` and `h` to `0`. We will reset this value later,
    so, in theory, we could set it to anything.
  prefs: []
  type: TYPE_NORMAL
- en: The `TTF_Font *font` variable is a pointer to the `SDL_TTF` library's `font`
    object. Later, we will use that object to load up a font from the virtual filesystem
    and render that font to the `SDL_Texture *texture` pointer variable. The `SDL_Texture`
    variables are used by SDL to render sprites to the canvas.
  prefs: []
  type: TYPE_NORMAL
- en: 'These next few lines are used to do some initialization work in SDL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `SDL_Init` function is called with a single flag initializing only the
    video subsystem. As a side note, I am not aware of any use case for SDL that does
    not require the video subsystem to be initialized. Many developers use SDL as
    an OpenGL/WebGL graphics rendering system; so, unless you have designed a game
    that is audio only, you should always pass in the `SDL_INIT_VIDEO` flag. If you
    would like to initialize additional SDL subsystems, you would pass in the flags
    for those subsystems using a Boolean or `|` operator, as shown in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: If we use the preceding line, SDL would have also initialized the audio and
    haptic subsystems, but we do not need them right now, so we will not be making
    that change.
  prefs: []
  type: TYPE_NORMAL
- en: The `TTF_Init();` function initializes our TrueType fonts, and `SDL_CreateWindowAndRenderer`
    returns a `window` and `renderer` object to us. We are passing `320` for the width
    of the canvas and `200` for the height. The third variable is the `window` flags.
    We pass `0` in for that parameter to indicate that we do not need any `window`
    flags. Because we are working with the SDL Emscripten port, we do not have control
    of the window, so these flags do not apply.
  prefs: []
  type: TYPE_NORMAL
- en: Clearing the SDL renderer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After the initialization is complete, we will need to clear out the renderer.
    We can clear our renderer with any color we choose. To do this, we will make a
    call to the `SDL_RenderDrawColor` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'That sets the drawing color for the renderer to black with full opacity. `0,
    0, 0` are the RGB color values, and `255` is the alpha opacity. These numbers
    all range from 0 to 255, where 255 is the full color on the color spectrum. We
    set this up so that when we call the `SDL_RenderClear` function in the next line,
    it will clear the renderer with the color black. If we wanted the color to clear
    red instead of black, we would have to modify the call in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: That is not what we want, so we will not make that change. I just wanted to
    point out that we could clear the renderer with any color we like.
  prefs: []
  type: TYPE_NORMAL
- en: Using the WebAssembly virtual filesystem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next few lines will open up the TrueType font file in the virtual filesystem,
    and render it to `SDL_Texture`, which can be used to render to the canvas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the first line of the preceding code, we open the TrueType font by passing
    in the location of the file in the WebAssembly virtual filesystem, defined at
    the top of the program. We also need to specify the font's point size, which was
    defined as 16 at the top of the program as well. The next thing we do is create
    an `SDL_Color` variable that we will use for the font. This is a RGBA color, and
    we have all values set to 255 so that it is a fully opaque white color. After
    we have done this, we will need to render the text to a surface using the `TTF_RenderText_Blended`
    function. We pass the TrueType font we opened a few lines earlier, the `MESSAGE`,
    which was defined as `"HELLO SDL!"`, near the top of the program, and the font
    color, defined as white. Then, we will create a texture from our surface and free
    the surface memory we have just allocated. You should always free the memory from
    your surface pointers immediately after using them to create a texture, as once
    you have your textures the surfaces are no longer needed.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering a texture to the HTML5 canvas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After we load a font from the virtual filesystem and then render that font to
    the texture, we need to take that texture and copy it to a location in our renderer
    object. After we have done that, we will need to take that renderer and present
    its contents to the HTML5 canvas element.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the source code that renders the texture to the canvas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The call to the `SDL_QueryTexture` function is used to retrieve the width and
    height of the texture. We need to use these values in the destination rectangle
    so that we render our texture to the canvas without changing its dimensions. After
    that call, the program knows the width and height of the texture, so it can use
    those values to modify the *x* and *y* variables of the destination rectangle
    so that it can center our text on the canvas. Because the *x* and *y* values of
    the `dest` (destination) rectangle specify the top-left corner of that rectangle,
    we need to subtract half the width and half the height of the rectangle to make
    sure that it is centered. The `SDL_RenderCopy` function then renders this texture
    to our rendering buffer and `SDL_RenderPresent` moves that entire buffer to the
    HTML5 canvas.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, all that is left to do in the code is `return`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Returning with a value of `EXIT_SUCCESS` tells our JavaScript glue code that
    everything went well when running this module.
  prefs: []
  type: TYPE_NORMAL
- en: Cleaning up SDL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Something that you may notice is missing from this code, that would be in a
    Windows or Linux version of an SDL application, is code that does some SDL clean
    up at the end of the program. If we exited an application in Windows, for instance,
    and did not do our cleanup work, we would be exiting without clearing out some
    of the memory allocated by SDL. If this were not a WebAssembly module, the following
    lines would be included at the end of the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Because we have not spent the time to make a game loop, we would want to delay
    the cleanup and exiting of the program by five seconds using a call to `SDL_Delay(5000)`,
    `5000` being the number of milliseconds to wait before doing the cleanup. We want
    to reiterate that, because we are compiling to WebAssembly, we do not want to
    clean up our SDL. Doing so has different effects on different browsers.
  prefs: []
  type: TYPE_NORMAL
- en: When testing this code in Firefox, using the delay is unnecessary, because the
    web browser tab will stay open even after the WebAssembly module stops executing.
    However, the Chrome browser tab will display an error page as soon as SDL destroys
    the `window` object.
  prefs: []
  type: TYPE_NORMAL
- en: The `SDL_DestroyWindow` function would destroy the `window` object if this were
    a Windows environment. The `SDL_Quit` function terminates the SDL engine, and,
    finally, `return EXIT_SUCCESS;` exits successfully from the `main` function.
  prefs: []
  type: TYPE_NORMAL
- en: Compiling hello_sdl.html
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Finally, we will compile and test our WebAssembly module using the Emscripten
    `emcc` compiler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: It is important to remember that you must run WebAssembly apps using a web server,
    or with `emrun`. If you would like to run your WebAssembly app using `emrun`,
    you must compile it with the `--emrun` flag. The web browser requires a web server
    to stream the WebAssembly module. If you attempt to open an HTML page that uses
    WebAssembly in a browser directly from your hard drive, that WebAssembly module
    will not load.
  prefs: []
  type: TYPE_NORMAL
- en: There are a few new flags we are using in this call to `emcc`, and we have temporarily
    left out the `--shell-file new_shell.html` flag that is used to generate a customized
    version of the template. If you would like to continue using `emrun` to test the
    app, you must include the `--emrun` flag, to run with the `emrun` command. If
    you are using a WebServer, such as Node.js, to serve the app, you may omit the
    `--emrun` flag from this point forward. If you like using `emrun`, continue to
    compile with that flag.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have added the `--preload-file` font flag to allow us to create a virtual
    filesystem contained in the `hello_sdl.data` file. This file holds our TrueType
    font. The application uses the core SDL library and the additional SDL TrueType
    font module, so we have included the following flag, `-s USE_SDL=2 -s USE_SDL_TTF=2`,
    to allow calls to `SDL` and `SDL_ttf`. If everything went well in your compile,
    this is what the new `hello_sdl.html` file will look like when you bring it up
    in a browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/261996ad-2fb3-49af-9505-dead70bfb861.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.1: Hello SDL! app screenshot'
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will learn how to use SDL to render a sprite to the
    HTML5 canvas.
  prefs: []
  type: TYPE_NORMAL
- en: Render a sprite to the canvas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have learned how to render text to our HTML canvas element using
    SDL and Emscripten, we can take the next step and learn how to render sprites.
    The code used to render a sprite to the canvas is quite similar to the code that
    we used to render a TrueType font. We will still be using the virtual filesystem
    to generate a data file that contains the sprites we are using, but we will need
    a new SDL library to do this. We no longer need `SDL2_ttf` to load a TrueType
    font and render it to a texture. Instead, we need `SDL2_image`. We will show you
    how to change our call to `emcc` to include this new library a little later.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s take a look at the new version of the SDL code that renders an
    image to our HTML canvas element instead of the text we rendered in the previous
    section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This code is similar to the code we wrote in the last section, *HTML5 and WebAssembly*,
    for the *HELLO SDL!* application. Instead of using the `SDL2_ttf` module, we are
    using the `SDL2_image` module. Because of this, we will need to include the `SDL2/SDL_image.h`
    header file. We will also need to load a sprite file from the `sprites` directory,
    which we will add to the WebAssembly virtual filesystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Below the call to `IMG_Load`, we add an error check that will let us know what
    went wrong if the file fails to load. Aside from that, the code is mostly the
    same. If we are successful, the canvas will display our 16x16 pixel image of the
    Starship Franchise:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e3515281-4ae7-471c-ba8c-b98e64540058.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.2: Franchise1.png'
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will learn how to use SDL to animate a sprite on our
    canvas.
  prefs: []
  type: TYPE_NORMAL
- en: Animating a sprite
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will learn how to make a quick and dirty little animation
    in our SDL application. That will not be the way we do animations in our final
    game, but it will give you an idea of how we could create animations from within
    SDL by swapping out textures over time. I am going to present the code to animate
    a sprite broken into two parts. The first part includes our preprocessor macros,
    global variables, and the `show_animation` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'After we define our `show_animation` function, we will need to define our module''s
    `main` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'There is a lot to unpack here. There are much more efficient ways to do this
    animation, but what we are doing here takes what we have already done and adds
    to it. In earlier versions of the code, we rendered a single frame to the canvas,
    then exited the WebAssembly module. That works well enough if your goal is to
    render something static to the canvas and never change it. If you are writing
    a game, however, you need to be able to animate your sprites and move them around
    the canvas. Here, we run into a problem that we do not have if we are compiling
    our C++ code for any target other than WebAssembly. Games typically run in a loop
    and are directly responsible for rendering to the screen. WebAssembly runs inside
    of the JavaScript engine in your web browser. The WebAssembly module itself cannot
    update our canvas. Emscripten uses the JavaScript glue code to update the HTML
    canvas indirectly from the SDL API. However, if the WebAssembly runs in a loop,
    and uses that loop to animate our sprite through SDL, the WebAssembly module never
    lets go of the thread it is in, and the JavaScript never has an opportunity to
    update the canvas. Because of this, we can not put the game loop inside the `main`
    function. Instead, we must create a different function, and use Emscripten to
    set up the JavaScript glue code to call that function every time the browser renders
    a frame. The function we will use to do that is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The first parameter we will pass to `emscripten_set_main_loop` is `show_animation`.
    This is the name of a function we defined near the top of the code. I will talk
    about the specifics of the `show_animation` function a little later. For now,
    it is enough to know that this is the function called every time the browser renders
    a new frame on the canvas.
  prefs: []
  type: TYPE_NORMAL
- en: The second parameter of `emscripten_set_main_loop` is **frames per second**
    (**FPS**). If you want to set the FPS of your game to a fixed rate, you can do
    so by passing the target frame rate into the function here. If you pass in `0`,
    this tells `emscripten_set_main_loop` to run with the highest frame rate it can.
    As a general rule, you want your game to run with the highest frame rate possible,
    so passing in `0` is usually the best thing to do. If you pass in a value higher
    than what the computer is capable of rendering, it will merely render as fast
    as it is able anyway, so this value only puts a cap on your FPS.
  prefs: []
  type: TYPE_NORMAL
- en: The third parameter we pass in is `simulate_infinite_loop`. Passing in `0` is
    equivalent to passing a `false` value. If the value of this parameter is `true`,
    it forces the module to re-enter through the `main` function for every frame.
    I am not sure what the use case for this is. I would recommend keeping it at `0`
    and separating your game loop into another function as we have done here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before calling `emscripten_set_main_loop`, we will set up an array of SDL texture
    surface pointers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This loop loads `FranchiseExplosion1.png` through `FranchiseExplosion7.png`
    into an array of SDL textures and stores them into a different array, called `anim`.
    That is the array we will loop through later in the `show_animation` function.
    There are more efficient ways to do this using sprite sheets, and by modifying
    the destination rectangle. We will discuss those techniques for rendering animated
    sprites in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Near the top of the code, we defined the `show_animation` function, called
    every rendered frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This function is designed to wait a certain number of milliseconds, then update
    the texture we are rendering. I have created a seven frame animation that blows
    up the Starship Franchise in a little pixelated explosion. The reason we need
    a short wait in this loop is that our refresh rate is probably 60+ FPS, and if
    we render a new frame of our animation every time `show_animation` is called,
    the entire animation would run in about 1/10 of a second. Classic arcade games
    frequently flipped through their animation sequences at a much slower rate than
    the games frame rate. Many classic **Nintendo Entertainment System** (**NES**)
    games used two-stage animations where the animation would alternate sprites every
    few hundred milliseconds, even though the NES ran with a frame rate of 60 FPS.
  prefs: []
  type: TYPE_NORMAL
- en: The core of this function is similar to the single texture render we created
    earlier. The primary difference is that we wait a fixed number of milliseconds
    before changing the frame of our animation by incrementing the `current_frame`
    variable. That takes us through all seven stages of our animation in a little
    less than a second.
  prefs: []
  type: TYPE_NORMAL
- en: Moving the sprite
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have learned how to animate our sprite in a frame-by-frame animation,
    we will learn how to move a sprite around on our canvas. I want to keep our spaceship
    animated, but I would prefer it not run in an `explosion` loop. In our `sprites`
    folder, I have included a simple four-stage animation that causes our ship''s
    engines to flicker. The source code is quite lengthy, so I will introduce it in
    three parts: a preprocessor and global variable section, the `show_animation`
    function, and the `main` function.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code that defines the preprocessor directives and the global variables
    at the beginning of our `cpp` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Following the preprocessor directives and global variables, our `cpp` file
    contains a `show_animation` function that defines our game loop. Here is the code
    for our `show_animation` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The final part of our `cpp` file defines the `main` function. That is the initialization
    code in our WebAssembly module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This code is similar to our `sprite_animation` code. There are only a few modifications,
    and most of them are within the `show_animation` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We advance our frame whenever the value in `ms`, which tracks the milliseconds
    since the last frame change, exceeds `ms_per_frame`, which we set to a value of
    `100`. Because the spaceship is moving, we still need to update our canvas every
    frame with the new spaceship position. We do this by modifying the `dest.y` value,
    which tells SDL where to render our spaceship on the y-axis. We subtract one from
    the `dest.y` variable every frame to move the spaceship up. We also perform a
    check to see whether this value has become smaller than `-16`. Because the sprite
    is 16-pixels high, this will happen when the sprite has moved entirely off the
    screen at the top. If this is the case, we need to move the sprite back down to
    the bottom of the game screen by setting the `y` value back to `200`. In an actual
    game, to tie our movement directly to the frame rate like this would be a bad
    idea, but for this demonstration, it will be fine.
  prefs: []
  type: TYPE_NORMAL
- en: Compiling sprite.html
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can now compile our sprite WebAssembly app by using the `emcc` command.
    You will need the `sprites` folder from the `Chapter02` folder on GitHub. After
    you have downloaded the `sprites` folder and placed it in your project''s folder,
    you can compile the app with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: It is important to remember that the app must be run from a web server, or using
    `emrun`. If you do not run the app from a web server, or use `emrun`, you will
    receive a variety of errors when the JavaScript glue code attempts to download
    the WASM and data files. You should also know that IIS requires additional configuration
    in order to set the proper MIME types for the `.wasm` and `.data` file extensions.
  prefs: []
  type: TYPE_NORMAL
- en: We are still using the `--preload-file` flag, however, this time we are passing
    in the `sprites` folder instead of the `fonts` folder. We will continue to use
    the `-s USE_SDL=2` flag and will be adding the `-s USE_SDL_IMAGE=2` flag, which
    will allow us to use images with SDL that are an alternative to the `.bmp` file
    format.
  prefs: []
  type: TYPE_NORMAL
- en: 'To tell `SDL_IMAGE` which file format to use, we pass in the `png` format using
    the following `-s SDL2_IMAGE_FORMATS=["png"]` flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3bd87aeb-0bf2-46f2-95ba-58180ce3f054.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.3: Screenshot of sprite_move.html'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, I have introduced you to SDL and its library of modules that
    are available for use within WebAssembly. We have learned about the WebAssembly
    virtual filesystem, and how Emscripten creates the `.data` files for access within
    the WebAssembly virtual filesystem. I have taught you how to use SDL to render
    images and fonts to the HTML canvas. Finally, we have learned how to use SDL to
    create a simple animation in our game.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to use keyboard input to move game objects
    on the canvas.
  prefs: []
  type: TYPE_NORMAL
