- en: Chapter 2. General Considerations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building secure Node.js applications will require an understanding of the many
    different layers that it is built upon. Starting from the bottom, we have the
    language specification that defines what JavaScript consists of. Next, the virtual
    machine executes your code and may have differences from the specification. Following
    that, the Node.js platform and its API have details in their operation that affect
    your applications. Lastly, third-party modules interact with our own code and
    need to be audited for secure programming practices.
  prefs: []
  type: TYPE_NORMAL
- en: First, JavaScript's official name is ECMAScript. The international **European
    Computer Manufacturers Association** (**ECMA)** first standardized the language
    as **ECMAScript** in 1997\. This ECMA-262 specification defines what comprises
    JavaScript as a language, including its features, and even some of its bugs. Even
    some of its general quirkiness has remained unchanged in the specification to
    maintain backward compatibility. While I won't say the specification itself is
    required reading, I will say that it is worth considering.
  prefs: []
  type: TYPE_NORMAL
- en: Second, Node.js uses Google's **V8** virtual machine to interpret and execute
    your source code. While developing for the browser, you have to consider all the
    other virtual machines (not to mention versions), when it comes to available features.
    In a Node.js application, your code only runs on the server, so you have much
    more freedom, and you can use all the features available to you in V8\. Additionally,
    you can also optimize for the V8 engine exclusively.
  prefs: []
  type: TYPE_NORMAL
- en: Next, Node.js handles setting up the event loop, and it takes your code to register
    callbacks for events and executes them accordingly. There are some important details
    regarding how Node.js responds to exceptions and other errors that you will need
    to be aware of while developing your applications.
  prefs: []
  type: TYPE_NORMAL
- en: Atop Node.js is the developer API. This API is written mostly in JavaScript
    which allows you, as a JavaScript developer, to read it for yourself, and understand
    how it works. There are many provided modules that you will likely end up using,
    and it's important for you to know how they work, so you can code defensively.
  prefs: []
  type: TYPE_NORMAL
- en: Last, but not least, the third-party modules that npm gives you access to, are
    in great abundance, which can be a double-edged sword. On one hand, you have many
    options to pick from that suit your needs. On the other hand, having a third-party
    code is a potential security liability, as you will be expected to support and
    audit each of these modules (in addition to their own dependencies) for security
    vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the biggest security risks in JavaScript itself, both on the client
    and now on the server, is the use of the `eval()` function. This function, and
    others like it, takes a string argument, which can represent an expression, statement,
    or a series of statements, and it is executed as any other JavaScript source code.
    This is demonstrated in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This code has full access to the current scope, and can even affect the global
    object, giving it an alarming amount of control. Let''s look at the same code,
    but imagine if someone malicious sent arbitrary JavaScript code instead of a simple
    number. The result is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Due to how `eval()` is exploited here, we are witnessing a "remote code execution"
    attack! When executed directly on the server, an attacker could gain access to
    server files and databases. There are a few cases where `eval()` can be useful,
    but if the user input is involved in any step of the process, it should likely
    be avoided at all costs!
  prefs: []
  type: TYPE_NORMAL
- en: 'There are other features of JavaScript that are functional equivalents to `eval()`,
    and should likewise be avoided unless absolutely necessary. First is the `Function`
    constructor that allows you to create a callable function from strings, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: While very similar to the `eval()` function, it is not exactly the same. This
    is because it does not have access to the current scope. However, it does still
    have access to the global object, and should be avoided whenever a user input
    is involved.
  prefs: []
  type: TYPE_NORMAL
- en: If you find yourself in a situation where there is an absolute need to execute
    an arbitrary code that involves user input, you do have one secure option. Node.js
    platform's API includes a **vm** module that is meant to give you the ability
    to compile and run code in a sandbox, preventing manipulation of the global object
    and even the current scope.
  prefs: []
  type: TYPE_NORMAL
- en: It should be noted that the vm module has many known issues and edge cases.
    You should read the documentation, and understand all the implications of what
    you are doing to make sure you don't get caught off-guard.
  prefs: []
  type: TYPE_NORMAL
- en: ES5 features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'ECMAScript5 included an extensive batch of changes to JavaScript, including
    the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: Strict mode for removing unsafe features from the language.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Property descriptors that give you control over object and property access.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Functions for changing object mutability.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Strict mode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Strict mode changes the way JavaScript code runs in select cases. First, it
    causes errors to be thrown in cases that were silent before. Second, it removes
    and/or change features that made optimizations for JavaScript engines either difficult
    or impossible. Lastly, it prohibits some syntax that is likely to show up in future
    versions of JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, strict mode is opt-in only, and can be applied either globally
    or for an individual function scope. For Node.js applications, to enable strict
    mode globally, add the `–use_strict` command line flag, while executing your program.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While dealing with third-party modules that may or may not be using strict mode,
    this can potentially have negative side effects on your overall application. With
    that said, you could potentially make strict mode compliance a requirement for
    any audits on third-party modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'Strict mode can be enabled by adding the `"use strict"` pragma at the beginning
    of a function, before any other expressions as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In Node.js, all the required files are wrapped with a function expression that
    handles the `CommonJS` module API. As a result, you can enable strict mode for
    an entire file, by simply putting the directive at the top of the file. This will
    not enable strict mode globally, as it would in an environment like the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Strict mode makes many changes to the syntax and runtime behavior, but for the
    sake of brevity we will only discuss changes relevant to application security.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, scripts run via `eval()` in strict mode cannot introduce new variables
    to the enclosing scope. This prevents leaking new and possibly conflicting variables
    into your code, when you run `eval()` as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In addition, the code run via `eval()` is not given access to the global object
    through its context. This is similar, if not related, to other changes for function
    scope, which will be explained shortly, but this is specifically important for
    `eval()`, as it can no longer use the global object to perform additional black
    magic.
  prefs: []
  type: TYPE_NORMAL
- en: 'It turns out that the `eval()` function is able to be overridden in JavaScript.
    It can be accomplished by creating a new global variable called `eval`, and assigning
    something else to it, which could be malicious. Strict mode prohibits this type
    of operation. It is treated more like a language keyword than a variable, and
    attempting to modify it will result in a syntax error as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, the function objects are more tightly secured. Some common extensions
    to ECMAScript add the `function.caller` and `function.arguments` references to
    each function, after it is invoked. Effectively, you can "walk" the call stack
    for a specific function by traversing these special references. This potentially
    exposes information that would normally appear to be out of scope. Strict mode
    simply makes these properties throw a `TypeError` remark, while attempting to
    read or write them, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, `arguments.callee` is removed in strict mode (such as `function.caller`
    and `function.arguments` shown previously). Normally, `arguments.callee` refers
    to the current function, but this magic reference also exposes a way to "walk"
    the call stack, and possibly reveal information that previously would have been
    hidden or out of scope. In addition, this object makes certain optimizations difficult
    or impossible for JavaScript engines. Thus, it also throws a `TypeError` exception,
    when an access is attempted, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, functions executed with `null` or `undefined` as the context no longer
    coerce the global object as the context. This applies to `eval()` as we saw earlier,
    but goes further to prevent arbitrary access to the global object in other function
    invocations, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Strict mode can help make the code far more secure than before, but ECMAScript
    5 also includes access control through the property descriptor APIs. A JavaScript
    engine has always had the capability to define property access, but ES5 includes
    these APIs to give that same power to application developers.
  prefs: []
  type: TYPE_NORMAL
- en: Object property descriptors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Object properties have the following three hidden attributes that determine
    what mutations can occur to them:'
  prefs: []
  type: TYPE_NORMAL
- en: '`writable`: If this is `false` means the property value cannot be changed (in
    other words, read only)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`enumerable`: If this is `false` means the property will not come up during
    for in loops'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`configurable`: If this is `false` means the property cannot be deleted'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While defining an object property with an object literal or through assignment,
    which is the most common method, each of these three hidden properties defaults
    to `true`. This makes the property completely open to modification in every respect.
    However, there are a few new functions that allow application developers to set
    these property attributes on their own, restricting access to certain object properties.
    The property descriptor API is completely opt-in, and the default behavior of
    object properties does not change, even in ES5.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, the `Object.defineProperty()` function allows you to specify a single
    property and its accessor descriptor on a specified object. It takes three arguments:
    the target object, the name of the new property, and the descriptor object mentioned
    earlier. An accessor descriptor is just an object that contains specified properties
    corresponding to the attributes listed earlier.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The accessor descriptor tells JavaScript engine, the access level to give to
    our new property. While using `Object.defineProperty()` and its related functions,
    it is important to note that all the descriptor attributes value are by default
    set to `false`. This is the opposite effect when compared to basic assignment.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Both of these statements have the same result, and the latter is much more
    verbose. However, traditional assignment cannot affect any of the descriptors,
    unlike the latter. Let''s see what it takes to create a "locked down" property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: What we have just done is created a property that cannot be written, deleted,
    or enumerated, making it immutable. This allows application developers to control
    data access, even while sharing objects across various code boundaries.
  prefs: []
  type: TYPE_NORMAL
- en: 'One last capability afforded by accessor descriptors is to allow developers
    to create getter and setter functions for specific properties. A getter is a function
    that returns the data when a property is accessed, and a setter stores the data
    that is sent via an assignment. This is illustrated in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This code creates a property that contains data from two other properties on
    the same object, and it is computed dynamically. The same could be accomplished
    with a function in many cases, but this enables more separation between the two
    operations, without needing two separate functions on the object itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next function, `Object.defineProperties()`, is similar. This one, however,
    only takes two arguments, the host object and another object that is a hash of
    multiple properties, where the property values are all accessor descriptors. This
    is seen in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This allows us to condense multiple property definitions into a single function
    call, which is more about convenience than anything else. Next up is the most
    powerful of them all: the `Object.create()` function. This function creates a
    completely new object from scratch, and also assigns it a prototype. This is reflective
    of the prototypal nature of JavaScript, and we will not take time to discuss that
    further, as it is not particularly relevant to this discussion.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This function only takes two arguments, the prototype for the new object (or
    `null` to assign no inheritance at all), and a properties object just like we
    use in `Object.defineProperties()`, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: By setting the prototype as `null`, instead of some other object, we have created
    a completely plain object that inherits nothing, not even from the `Object.prototype`
    object. This is desirable as even modifications to `Object.prototype` (which is
    a bad idea anyway) will not adversely affect objects created with this method.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few other special functions for changing an object''s accessibility.
    First is the `Object.preventExtensions()` function, which prevents new properties
    from being added to the object specified, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this allows you to configure an object so that nobody else can
    create additional properties on your object. If you include strict mode in the
    mix, the last assignment will throw an error rather than failing silently. Also,
    it should be noted that this operation cannot be reversed once it has occurred.
  prefs: []
  type: TYPE_NORMAL
- en: Next is the `Object.seal()` function which takes an object, and prevents properties
    from being deleted, in addition to the effects of the `Object.preventExtensions()`
    function. In other words, this takes all the existing properties and sets their
    configurable property attributes to `false`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This is powerful because we can preserve the structure of an object, but still
    allow property values to change. Like before, this operation cannot be reversed.
    In addition, adding the strict mode causes an exception to be thrown, rather than
    allowing the operation to fail silently.
  prefs: []
  type: TYPE_NORMAL
- en: 'Last up is the most powerful of them all, the `Object.freeze()` function. This
    function applies all the same effects as `Object.seal()`, and also completely
    locks down all the properties. No values can be changed (that is, all writable
    attributes are set to `false`), and the property descriptors are all unmodifiable.
    This makes the object effectively immutable, and prevents all other attempts to
    change anything about the object, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Freezing an object is, like the other operations, irreversible. In strict mode,
    errors will be thrown during any attempt to write or change the object.
  prefs: []
  type: TYPE_NORMAL
- en: Static program analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Keeping a track of all the things we have discussed here can be overwhelming.
    The problem is compounded, when a team of people are working on the same project.
    Tools that perform static analysis take your source code (without executing it),
    and check for specific code patterns that you can configure.
  prefs: []
  type: TYPE_NORMAL
- en: For example, you can configure **JSHint** to forbid the use of `eval()` and
    require strict mode for all your functions. By letting it examine your source
    code, it will alert you when these rules are violated. This can be used in conjunction
    with version control to prevent insecure code from being added to your project's
    repository. In addition, it can also be used prior to releases to ensure that
    all the code is secured before heading out to production.
  prefs: []
  type: TYPE_NORMAL
- en: JSHint is a community-driven fork of the **JSLint** project. JSLint is opinionated
    and it is not as configurable as many desired, so JSHint was created to fill that
    gap. Both are great tools, and I highly recommend you adopt either one for your
    JS projects. While static analysis will not catch everything, it will help ensure
    a higher quality of code through automation.
  prefs: []
  type: TYPE_NORMAL
- en: Considerations for Node.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JavaScript has exceptions built into the language as an error-handling construct.
    When an exception is thrown, there needs to be some code to detect that error
    and handle it appropriately. However, if an exception remains uncaught, it will
    trigger a show-stopping error.
  prefs: []
  type: TYPE_NORMAL
- en: In the browser, an uncaught exception immediately halts any execution that takes
    place. This will not cause your web page to crash, but it has the potential to
    leave your application in an unstable place.
  prefs: []
  type: TYPE_NORMAL
- en: In Node.js, an uncaught exception will terminate the application thread. This
    is very different from other server-side programming languages like PHP, where
    a similar error only causes a single request to fail. Now, you must contend with
    your entire server and application being abruptly halted.
  prefs: []
  type: TYPE_NORMAL
- en: Callback errors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first step you can take is to make sure you throw errors in an expected
    and predicable way, so they can be effectively caught later. In Node.js, the convention
    for asynchronous actions that use a callback is to send an `Error` object, to
    that callback function, as the first argument. This is the standard convention
    used in Node.js core, and it has been widely adopted by the community.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code simply reads a file into a string. This operation has a callback
    that takes two arguments. The first is an `Error` object, but only if an error
    occurred during this I/O operation, such as the file not existing. By simply passing
    the error object as a function argument, this does not technically "throw" an
    exception. Your application should still handle these errors, by correcting them,
    if possible. If an unexpected error occurs, or if it cannot be corrected directly,
    you should throw that error yourself, rather than swallowing errors quietly, and
    creating hard-to-debug scenarios for yourself later.
  prefs: []
  type: TYPE_NORMAL
- en: EventEmitter error handling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Node.js core has a widely used utility object called the `EventEmitter`.
    This is an object that can be instantiated or inherited from that allows for binding
    to and emitting events for asynchronous actions. When an error is encountered
    by an `EventEmitter` object, the convention is to emit an error event with an
    `Error` object as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code simply makes an HTTP request to [http://nodejs.org/](http://nodejs.org/).
    The resulting object is an `EventEmitter` object that represents the HTTP response.
    It emits multiple data events, as it receives data from the server, and if an
    error occurs during transmission (similar to a network disconnection) then an
    `error` event is emitted.
  prefs: []
  type: TYPE_NORMAL
- en: It should be noted that the `EventEmitter` object has a very specific behavior
    regarding the `error` event. If you have an `EventEmitter` object that emits an
    `error` event, but has no attached listeners to respond to the event, then the
    corresponding `Error` object is thrown, and will likely become an uncaught exception.
    This means that any unhandled error events will crash your application, so always
    bind an `error` event handler, while using the `EventEmitter` object.
  prefs: []
  type: TYPE_NORMAL
- en: Uncaught exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When an uncaught exception does occur, Node.js will print the current stack
    trace, and then terminate the thread. There is a global object available to all
    Node.js applications called `process`. It is an `EventEmitter` object with a special
    event called `"uncaughtException"` that gets emitted, when an uncaught exception
    is brought up to the main event loop. By binding to this event you can set up
    custom behavior, such as sending an email, or writing to a special log file. This
    can be seen in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, I've simply done what Node.js does by default. As I mentioned
    before, you can implement your own error-logging procedures. You need to make
    sure to terminate the process yourself via the `process.exit()` function, if you
    are using a custom handler.
  prefs: []
  type: TYPE_NORMAL
- en: While it is possible to continue the application after an uncaught exception,
    it is not recommended! By definition, an uncaught exception has interrupted the
    normal flow of your application, leaving it in an unstable and unreliable state.
    If you simply swallow the error, and continue processing, then you are wandering
    into a dangerous territory. The Node.js documentation equates this with unplugging
    a computer to shut it down. You can get away with it a few times, but if it keeps
    happening repeatedly, the system will become increasingly unstable and unpredictable.
  prefs: []
  type: TYPE_NORMAL
- en: Domains
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While the `uncaughtException` event allows us to handle errors, it is still
    rather crude. You lose much of the original context from where the error originates,
    which makes it a bit more difficult to debug later. As of Node.js v0.8, there
    is a new error-handling mechanism available, called **Domains**. They are a way
    to group different I/O operations together so that in the event of an error, the
    domain object is notified instead of the process object via the `uncaughtException`
    event. This allows you to preserve the context of the error itself, and helps
    you to prepare for and correct the error in future.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to preserving context, domains also allows you to gracefully shut
    down related services in the event of an error. If you have an HTTP server running,
    and an error occurs for one of your users, simply shutting down the server will
    immediately interrupt any other users that are currently using the server at the
    same time. This isn't fair to those users, so we need to be able to shut down
    our server more gracefully. We should stop the server from accepting new connections,
    and let the current requests be fulfilled before shutting down the server.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code sets up a simple HTTP server that will respond four times
    before an error occurs. For each request, a domain is created, which can be passed
    around to all the various pieces of our request handler, and any asynchronous
    operations can be run in the domain's context. On request number `4`, we will
    throw an `Error` object. The domain has an error event handler that outputs the
    error information, a stack trace, and then proceeds to shut down the server. First,
    it sends the current request an error message, then it stops accepting new requests,
    and finishes serving all the current requests it has in its queue. Once this is
    completed, the process itself is terminated.
  prefs: []
  type: TYPE_NORMAL
- en: We could technically implement what I demonstrated here with the `uncaughtException`
    event. However, if you are running multiple servers (for example, an HTTP server
    and a WebSocket server) side by side in your application (or even running multiple
    processes with the cluster module), that event handler won't necessarily give
    you the context you need to handle those errors specific to the server that encountered
    the error. In fact, you won't even be able to distinguish between different requests
    with the `uncaughtException` event, as that context is lost as well. With domains,
    you can handle errors more gracefully, without losing context.
  prefs: []
  type: TYPE_NORMAL
- en: Node.js has a module called **cluster**, which allows you to take advantage
    of multiple core environments. It does this by spawning multiple worker processes
    that share the same server port, and the `cluster` module handles message passing
    between those processes for you. If an error happens in one of those workers,
    a domain would allow you to easily shut down only that single server and worker
    process, while letting the others continue operating normally. Once that process
    finishes cleaning up and exiting, you can spawn a brand new one to take its place,
    and your application will experience zero downtime as a result.
  prefs: []
  type: TYPE_NORMAL
- en: Process monitoring
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With that said, stuff is going to go wrong. You shouldn't ignore uncaught exceptions
    as your application will be unstable, and will leak references and memory. The
    only safe way to deal with uncaught exceptions is to stop that process. The implication
    here is that your server will be unavailable to other users. This means that if
    a malicious user can figure out a way to trigger an uncaught exception on your
    server, they are effectively executing a denial of service attack against your
    other users.
  prefs: []
  type: TYPE_NORMAL
- en: The solution is to have a process monitor that can watch your application process
    and automatically restart it whenever it is stopped. There are many options out
    there, including ones that are platform-specific. Some available process monitors
    include forever, mon, and upstart. The point is you should implement some sort
    of process monitoring, so you do not have to manually restart your applications,
    if something goes wrong.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have a process monitor in place, be sure to configure it to log errors
    somewhere so that you can keep a track, in order to correct harmful and fatal
    errors in your application. It is also wise to monitor how often your application
    crashes, and correct errors as fast as possible.
  prefs: []
  type: TYPE_NORMAL
- en: npm modules (third-party code)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned before, one of the biggest features of Node.js is its vibrant community
    and fast-growing registry of modules. Because the Node.js core API is intentionally
    small and focused, you are likely to incorporate other modules, so you don't have
    to write a lot from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: Just as you will take efforts to audit your code for security practices, you
    should also take an active role in monitoring the npm modules; you end up including
    in your project. Many projects out there on npm are completely open source, and
    often available on GitHub or other similar online resources. This makes it easy
    to look through the source manually for things that stand out. As a last resort,
    you can inspect the local packages that npm downloads while installing dependencies,
    although you are not guaranteed to get everything that is part of the package's
    development environment.
  prefs: []
  type: TYPE_NORMAL
- en: While picking out modules to adopt, look for the ones that include a test suite
    of some sort. If they have running tests, it will be easier for you to know for
    certain that functionality is working as designed. Second, look for projects that
    incorporate some static analysis, which will usually come in the form of JSHint
    or JSLint. Look at their style guide or static analysis configuration to understand
    what rules they abide by. Many projects of this type have some sort of build process,
    which likely will include a way to run automated tests, static analysis, and other
    related tools.
  prefs: []
  type: TYPE_NORMAL
- en: One of the focuses that Node.js developers place into their modules is to make
    them small, highly-focused, and composable (that is, they are easily interoperable
    with other modules). As such, they usually are very small in terms of lines of
    code and complexity, making it much easier to write securely and in a testable
    fashion. This works greatly to Node.js platform's advantage when it comes to application
    security.
  prefs: []
  type: TYPE_NORMAL
- en: There is an up-and-coming undertaking called the **Node Security Project**,
    which can be found at [http://nodesecurity.io/](http://nodesecurity.io/). Their
    goal is to audit every single npm module for security vulnerabilities. They are
    in need of Node.js developers and security researchers to assist them, as they
    have a monumental task ahead of them. If you are interested in securing your own
    applications already, you can likely contribute the time you spend auditing modules
    that you end up using to this team for their own registry. This is a great way
    to accomplish your own goals, as well as contributing to the Node.js community
    as a whole.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we examined the security features that applied generally to
    the language of JavaScript itself, including how to use static code analysis to
    check for many of the aforementioned pitfalls. Also, we looked at some of the
    inner workings of a Node.js application, and how it differs from typical browser
    development, when it comes to security. Lastly, we briefly discussed the npm module
    ecosystem, and the Node Security Project, which aims to audit each and every module
    for security purposes. In the next chapter, we will look at security considerations
    for applications in general.
  prefs: []
  type: TYPE_NORMAL
