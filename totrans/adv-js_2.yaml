- en: '*Chapter 2*'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Asynchronous JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Learning Objectives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you will be able to:'
  prefs: []
  type: TYPE_NORMAL
- en: Define asynchronous programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Characterize the JavaScript event loop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utilize callbacks and promises to write asynchronous code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simplify asynchronous code with async/await syntax
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we shall learn Asynchronous JavaScript and its uses.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous chapter, we covered many of the new and powerful features released
    in ES6\. We discussed the evolution of JavaScript and highlighted the key additions
    in ES6\. We discussed scope rules, variable declaration, arrow functions, template
    literals, enhanced object properties, destructuring assignment, classes and modules,
    transpiling, and iterators and generators.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will learn what an asynchronous programming language is
    and how to write and understand asynchronous code. In the first topic, we will
    define asynchronous programming and show how JavaScript is an asynchronous, event
    driven programming language. Then, we will outline callbacks and show how to use
    callbacks to write asynchronous JavaScript. We will then define promises and demonstrate
    how to use promises to write asynchronous JavaScript. In the final topic, we will
    present the async/await syntax and simplify our asynchronous code using promises
    and this syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous Programming
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JavaScript is a single threaded, event driven, asynchronous programming language.
    What does this mean? This means that JavaScript runs on a single thread and delays/handles
    certain events or function calls through an event queue. We will break down the
    basics of how JavaScript does this through the following topic.
  prefs: []
  type: TYPE_NORMAL
- en: Sync Versus Async
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What does it mean for code to be synchronous or asynchronous? These two buzzwords
    get thrown around a lot in JavaScript. **Synchronous** is derived from the Greek
    root **syn**, meaning "with", and **chronos**, which means "time". Synchronous
    literally means "with time", or rather, code that is coordinated with time. Lines
    of code are run one at a time and are not started until the previous line has
    been handled. **Asynchronous**, or **async**, is derived from the Greek root *async*,
    meaning "not with", and chronos, hence asynchronous literally means "not with
    time" or rather, code that is not coordinated with time. The order code that is
    run is not coordinated with the time at which the interpreter first encounters
    the line of code.
  prefs: []
  type: TYPE_NORMAL
- en: Synchronous versus Asynchronous Timing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are two types of code — **synchronous** and **asynchronous**. We shall
    cover them in this section.
  prefs: []
  type: TYPE_NORMAL
- en: In asynchronous JavaScript, the JavaScript engine handles slow and fast code
    differently. We know what the words "fast" and "slow" mean, but how does this
    practically apply to our code? Asynchronous JavaScript allows the thread to execute
    new lines of code while waiting for the response from a slow time-dependent operation,
    such as file system I/O. To understand this, we must understand a little bit about
    computer operation speeds.
  prefs: []
  type: TYPE_NORMAL
- en: CPUs are very, very fast and can handle millions to billions of operations per
    second. Other parts of a computer or network run much slower than the CPU. For
    example, a hard drive can only perform hundreds to thousands of operations per
    second, and a computer network may only be able to perform one operation per second.
    A call to memory is many orders of magnitude slower than a CPU cycle.
  prefs: []
  type: TYPE_NORMAL
- en: Hard disk operations are several orders of magnitude slower than memory operations.
    Network calls are several orders of magnitude slower than hard-disk calls.
  prefs: []
  type: TYPE_NORMAL
- en: In **synchronous code**, we execute one line of code at a time. The next line
    of code does not execute until the previous line of code has finished running.
    Since synchronous code handles only execute one line of code at a time and wait
    for the operation to finish before starting a new line, if our code makes a request
    to a slower medium, such as memory, a hard disk, or a network, our program will
    not continue to the next line of code until the request to the slow medium (HDD, network,
    etc) is completed. The CPU will idle, wasting precious time, waiting for the operation
    to complete. In the case of a network call, this could be several seconds. When
    writing complex synchronous code, programmers generally write code that is multithreaded.
    The operating system then switches between threads while one is waiting for a
    slow operation. This helps reduce the CPU idle time.
  prefs: []
  type: TYPE_NORMAL
- en: In **asynchronous code**, we can execute lines of code out of chronological
    order. This means that we can start working on a new line of code before the previous
    line of code has finished its operation. JavaScript does this with the event loop,
    which will be covered later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In asynchronous code, when the JavaScript engine encounters a line of code
    that uses a slow, non-CPU-dependent operation, the operation is started, and instead
    of waiting for completion, the program moves on to the next line of code and continues
    running. When the slow operation has completed, the CPU jumps back to the operation,
    handles the response from the operation, and continues running the preceding code.
    This allows the CPU to not waste precious resources waiting for an operation that
    could potentially take several seconds. An example of a synchronous and asynchronous
    timing diagram is shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1: Sync versus async timing diagram'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_2.1.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.1: Sync versus async timing diagram'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'In the preceding diagram, we have four operations: A, B, C, and D. Operation
    C makes a call to the network and has a delay before completion, expressed by
    Network Delay. In the synchronous example, we run each operation sequentially.
    When we reach operation C, we must wait for the network delay before we can finish
    operation C. After operation C completes, we run operation D. During this wait,
    the CPU is idle and unable to do any other work.'
  prefs: []
  type: TYPE_NORMAL
- en: In the asynchronous example, we run the first three operations in sequence.
    When we reach operation C, instead of waiting for the network delay, we run operation
    D. When the network delay ends, we finish operation C. In the asynchronous example,
    we can clearly see that the overall completion time for all the operations and
    the CPU idle time are shorter.
  prefs: []
  type: TYPE_NORMAL
- en: If this concept is still a little confusing, we can use a real-life situation
    to help explain it. Imagine synchronous code as a line of people waiting to buy
    tickets in a train station. Only one person cause use the ticket vending machine
    at a time. I cannot get a ticket from the machine until all the people in front
    of me have finished getting their tickets. Similarly, the person behind me cannot
    begin getting their ticket until I have finished getting mine. Even if the person
    in front of me decides to take five minutes to get their ticket, I am stuck waiting
    until my turn. Much like with the ticket line, synchronous code runes one step
    at a time, in order. No new code line is run until the previous has finished,
    no matter how long a single step might take.
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous code is more like eating at a restaurant. Each customer orders
    one at a time, and must wait while the kitchen cooks the orders. The orders are
    served as they finish cooking, but not the order that they were given the kitchen.
    Orders that take less time to cook may come out before orders that take a long
    time. This parallels asynchronous code quite neatly. Each asynchronous code operation,
    or food order in our example, is started in sequential order. While the operation
    is waiting for a response, the next operations can be started. The CPU can handle
    other operations while waiting for responses from previous operations. This clearly
    differs from synchronous code. If the kitchen ran in a synchronous format, you
    would not be able to order your food until the kitchen had finished cooking the
    previous order. Imagine how inefficient this would be!
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Event Loops
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: JavaScript is an event-driven, asynchronous, single-threaded language because
    of its asynchronous event loop feature. Asynchronous operations are handled in
    JavaScript in the form of events. When we make an asynchronous call, an event
    is fired as soon as the call is finished. The JavaScript Engine then handles that
    event by calling a callback function, and then moves on to whatever was next in
    the code.
  prefs: []
  type: TYPE_NORMAL
- en: '**Event Loop** is the name we use for a four-part system that manages all operations
    in JavaScript. The parts of this system are the Stack, the Heap, the Event Queue,
    and the (main) Event Loop. The Stack, Heap, and Event Queue are all data structures
    that the JavaScript engine maintains. The main event loop is a process that runs
    behind the scenes and manages the three data structures. In its simplest form,
    this system is easy to understand. The stack tracks function calls. When a function
    makes an asynchronous operation, it puts an event handler into the heap. When
    the async operation completes, the event is pushed to the event queue. The event
    loop polls the queue for events, gets the associated handler off the heap, then
    calls the function and adds it to the stack. This is the absolute most basic form
    of the Event Loop. A visual representation of the event loop data structure is
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.2: Event loop data structure visual model'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_2.2-01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.2: Event loop data structure visual model'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'This is the Event Loop in its simplest form—three data structures: one to track
    function calls, one to track event handlers, one to track event completions, and
    a loop to tie them all together. The individual parts will be discussed in more
    detail in the following subsections.'
  prefs: []
  type: TYPE_NORMAL
- en: Stack
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The JavaScript engine has a single call stack, the event loop stack. The **event
    loop stack** is a traditional call stack—it keeps track of the currently executing
    function and what function is to be executed after that. The functions held in
    the stack are called frames. The event loop takes a first in last out approach.
    It is essentially an array-like data structure with special limitations. Function
    frames are added and removed only from the top of the stack, like a stack of plates
    in a kitchen. The first item placed onto the stack will always be at the bottom,
    and this will be the last one taken off.
  prefs: []
  type: TYPE_NORMAL
- en: The stack keeps track of the current executing function at the top of the stack
    and the chain of the function calls at the lower levels. When a function is executed,
    a frame gets created and added to the top of the stack. When a function finishes
    executing, its frame is removed from the top of the stack. These frames contain
    the function, the arguments, and the local variables.
  prefs: []
  type: TYPE_NORMAL
- en: If a function, function A, calls another function, function B, a new frame gets
    created for the newly executed function B. The new frame for function B gets put
    on the top of the stack, on top of the frame for function A, the function that
    called it. When function B finishes executing, its frame is removed from the stack
    and the frame for function A is now at the top. Function A resumes executing until
    it completes and when it completes, its frame is removed. An example of this is
    shown in the following code snippet and figure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 2.1: Call stack example code'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'When the program starts, the first frame is created. This frame contains the
    global state. Then, a second frame is called when `console.log` is called. This
    frame is placed on top of the global frame. When the `bar` function is called,
    a third frame is created and added to the stack. The frame contains `bar''s` arguments
    and local variables. When bar calls `foo`, a fourth frame is added to the stack,
    on top of the bar frame. The full call stack is shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.3: Call stack'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_2.3.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.3: Call stack'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: When `foo` returns, its frame is removed from the stack. The stack now only
    contains a frame containing bar's arguments and variables, the `console.log` call,
    and the global frame.. When **bar** returns, its frame is removed from the stack
    and the stack contains only the last 2 frames..
  prefs: []
  type: TYPE_NORMAL
- en: Heap and Event Queue
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Heap**'
  prefs: []
  type: TYPE_NORMAL
- en: The **heap** is a large, mostly unstructured, block of memory that is used to
    track what functions should be called when an event completes. When an asynchronous
    operation is started, it gets added to the heap. Items are removed from the heap
    once the asynchronous operation is complete. When the asynchronous operation completes,
    the heap pushes the necessary data to the event queue.
  prefs: []
  type: TYPE_NORMAL
- en: '**Queue**'
  prefs: []
  type: TYPE_NORMAL
- en: The **queue** is a message queue used to track asynchronous event completions.
    It is a traditional first in, first out queue. This means that it is an array-like
    data structure where items are pushed to the back of the queue and removed from
    the front of the queue. The oldest items are removed and handled first.
  prefs: []
  type: TYPE_NORMAL
- en: Each message in the message queue has an associated function which gets called
    when the message is handled. To handle a message, it is removed from the queue
    and its corresponding function is called with the message's data as its input
    parameters. As expected, a new stack frame is created when the function is called.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider an example of two buttons in our web page, `button1` and `button2`,
    set up to handle click events with the `clickHandler` handler function. The user
    clicks `button1` and `button2` in quick succession. The event queue will contain
    the following simplified information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 2.2: Call stack example code'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Event Loops
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The **event loop** is responsible for handling messages in the event queue.
    It does this through a constant polling cycle. At every "tick" of the event loop,
    the event queue does up to three things: check the stack, check the queue, and
    wait.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: An event queue "tick" is the synchronous calling of zero or more callback functions
    associated with a JavaScript event. It is the time it takes to handle an event
    and run the associated callback.
  prefs: []
  type: TYPE_NORMAL
- en: During every tick, the event loop first checks the call stack to see if it is
    empty and if we can do other work. If the call stack is not empty, the event queue
    will wait a bit, then check again. If the call stack is empty, the event loop
    will check the event queue for an event to handle. If the event queue is empty,
    then we have no work to do and the event loop will wait until the next tick and
    start the process over again. If there is an event to handle, the event loop will
    unqueue the event message from the event queue and call the function associated
    with the message. The called function has a frame created on the stack and the
    JavaScript Engine starts doing the work specified by the function. The event loop
    continues its polling cycle.
  prefs: []
  type: TYPE_NORMAL
- en: Looking at the event loop polling, we can notice that only one event can be processed
    at a time. If there is anything in the call stack, the event loop will not dequeue
    a message from the event queue. This functionality is called **run-to-completion**.
    Each message is processed completely before any other message starts processing.
  prefs: []
  type: TYPE_NORMAL
- en: '**Run-to-completion** offers some benefits when writing applications. One such
    benefit is that functions cannot be pre-empted and will run before any other code
    runs, potentially modifying the data the function was manipulating.'
  prefs: []
  type: TYPE_NORMAL
- en: The downside of this model, however, is that if an event callback or loop in
    the code takes a long time to complete, the application can delay other pending
    events. In a browser, a user interaction event like click or scroll could hang
    because another event callback was taking a long time to run. In server-side code,
    the result of a database query or HTTP request could hang because another event
    callback was taking a long time to complete.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is good practice to make sure that the callback functions called by events
    are short. Long callback functions can be broken into several message with the
    `setTimeout` function. An example of the delay issue is shown in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 2.3: Blocking loop example'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the preceding example, we created two asynchronous calls with `setTimeout`.
    The first one counts to two billion and then logs `done delaying`, the second
    just logs `done!`. When the first message is pulled off the event queue, the callback
    is put onto the call stack. Counting to two billion will cause a noticeable delay
    in most computers.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If your computer is old, then this delay may be substantial. If you run this
    code, start with smaller numbers, such as 2,000,000.
  prefs: []
  type: TYPE_NORMAL
- en: While the computer is counting, the event loop will not pull the next message
    off of the event queue. The async call to log `done!` will not get handled until
    after the counting is finished. Be cautious, as making callback functions may
    take a long time. If the blocked `console.log( 'done! ')` callback were a user
    input event in a website, the website would be blocking user input and could lead
    to an upset user and potentially the loss of a valuable user.
  prefs: []
  type: TYPE_NORMAL
- en: Things to Consider
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When working with the event loop, we have three important things consider when
    writing our asynchronous code. The first thing to consider is that events may
    come out of sync. The second is that synchronous code is blocking. The third is
    that zero delay functions do not execute after 0 milliseconds. These three concepts
    are explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Events can occur out of order**'
  prefs: []
  type: TYPE_NORMAL
- en: Events are added to the event queue in the order that they occur or are resolved.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This may not be the order that asynchronous calls are started.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If an asynchronous operation is slow, events that fire before it completes will be
    addressed first.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We must account for program timing with callbacks and promises.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We must make sure that we are careful about accessing data that is being filled
    in by an asynchronous call before the data is available.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Synchronous code is blocking**'
  prefs: []
  type: TYPE_NORMAL
- en: It is very bad practice to avoid asynchronous code by using synchronous modules
    that do the same or similar tasks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaScript is single threaded.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Event message may not be handled in a prompt manner if a large amount of synchronous
    code is used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Events such as mouse clicks or scrolling could hang.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Zero delay functions will not actually execute after 0 milliseconds**'
  prefs: []
  type: TYPE_NORMAL
- en: A `setTimeout` adds an event to the event queue after the timeout has expired.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the event queue has a lot of messages to process, the timeout message may
    not be addressed for several milliseconds.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The delay argument indicates a minimum time, not a guaranteed time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The concepts of zero delay functions and the event loop states can be demonstrated
    in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 2.4: Handling Asynchronous code'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the preceding snippet, we saw that there is work to be done in the main code
    file. The main program body is run, and a frame is added to the call stack. The
    first line of code is then interpreted and the `setTimeout` function adds its
    callback to the heap and schedules an event to fire after 0 milliseconds. The
    event then fires, and a message is added to the event queue. The JavaScript engine
    interprets the next line of code, the second `setTimeout` call. The callback is
    added to the heap, and the event is registered to fire after 0 ms. The second
    timeout event immediately fires, and a second message is added to the event queue.
    The JavaScript engine handles the `console.log` call and `step0` is logged to
    the console. The main program body has no more synchronous work to do and the
    call stack is empty. The event loop now begins to handle the events in the event
    queue. The event queue contains two messages, one for the first timeout event
    and one for the second timeout event. The event loop then takes the first message
    and adds the associated `callback` function to the call stack. The JavaScript
    engine handles that call stack frame and logs `step1`. The JavaScript engine then
    handles the second message that was in the event queue. The event queue message
    is removed from the queue and a frame is added to the call stack. The JS engine
    handles the frame in the stack and logs `done!`. No more work can be done. All
    events have fired, and the stack and queue are both empty.
  prefs: []
  type: TYPE_NORMAL
- en: '**Conclusion**'
  prefs: []
  type: TYPE_NORMAL
- en: Unlike most programming languages, JavaScript is an asynchronous programming
    language. More specifically, it is a single threaded, event driven, asynchronous
    programming language. This means that JavaScript does not idle when waiting for
    the results of a long-running operation. It runs other code blocks while waiting.
    JavaScript manages this with the Event Loop. The event loop is composed of four
    parts, a function stack, a memory heap, an event queue, and the event loop. These
    four parts work together to handle events fired from operation completion.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 16: Handling the Stack with an Event Loop'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To better understand why events in your program are being fired and handled
    in the expected order, look at the program provided next, and without running
    the program, write out the expected output of the program.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the first 10 steps of the program, write the expected stack, queue, and
    heap at each step. A step is any time an event fires, the event loop dequeues
    an event, or the JS Engine handles a function call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 2.5: Call stack example code (starting step)'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The program is displayed in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 2.6: Call stack example code (program)'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'To demonstrate a simplified form of how the Event Loop handles the stack, queue,
    and heap while handling JavaScript events, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Add an event loop stack frame to the stack if a function is called and being
    handled.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Process the function and add the necessary event and handler info to the heap.
    Remove the event and handler in the next step.
  prefs: []
  type: TYPE_NORMAL
- en: Push to the event queue if an event completes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pull from the event queue and call the handler function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat this for the rest of the steps (first 10 only).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Code**'
  prefs: []
  type: TYPE_NORMAL
- en: https://bit.ly/2R5YGPA
  prefs: []
  type: TYPE_NORMAL
- en: '**Outcome**'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.4: Scope outputs'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_2.4.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.4: Scope outputs'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '![Figure 2.5: Scope outputs'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_2.5.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.5: Scope outputs'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '![Figure 2.6: Scope outputs'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_2.6.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.6: Scope outputs'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You have successfully demonstrated a simplified form of how the Event Loop handles
    the stack.
  prefs: []
  type: TYPE_NORMAL
- en: Callbacks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Callbacks** are the most basic form of JavaScript asynchronous programming.
    In the simplest terms, a callback is a function that gets called after another
    function completes. Callbacks are used to handle the response of an asynchronous
    function call.'
  prefs: []
  type: TYPE_NORMAL
- en: In JavaScript, functions are treated like objects. They can be passed around
    as arguments, returned by functions, and saved into variables. A callback is a
    function object that is passed as an argument into a higher order function. A
    higher order function is simply a mathematics and computer science term for a
    function that takes one or more functions as arguments (callbacks) or returns
    a function. In JavaScript, a higher order function will take a callback as a parameter.
    Once the higher order finishes doing some form of work, such as an HTTP request
    or database call, it calls the callback function with the error or return values.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned in the Event Loop section in *Asynchronous Programming*, JavaScript
    is an event driven language. Since JavaScript is single threaded, any long-running
    operations are blocking. JavaScript handles this blocking effect by using events.
    When an operation completes and event fires, the event has an attached handler
    function that gets called to handle the result. These functions are **callbacks**.
    Callbacks are the key that allow JavaScript events to perform work when handling
    asynchronous events.
  prefs: []
  type: TYPE_NORMAL
- en: Building Callbacks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Callbacks in JavaScript follow a simple unofficial convention. A callback function
    should take in at least two arguments: **error** and **result**. When building
    callback APIs or writing callback functions, we recommend that you follow this
    convention so that your code can seamlessly integrate with other libraries. An
    example of a callback function is shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 2.7: Basic callback example'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the preceding example, we used a fake Twitter API. Our fake API has a higher
    order function, `listFollowers`, that accepts an object and a callback function
    as parameters. Once `listFollowers` completes its internal work, in this case
    an HTTP request to the Twitter API, our callback function will be called.
  prefs: []
  type: TYPE_NORMAL
- en: A callback may take in as many arguments as needed or specified by the higher
    order function, but the first argument must be the `error` object. This convention
    is followed by nearly every API in existence. Breaking from this convention when
    writing APIs will make your code much more difficult to integrate with any third-party
    APIs or applications.
  prefs: []
  type: TYPE_NORMAL
- en: A callback's error argument will only be set if the higher order function encounters
    an error while running. The contents of the error argument may be any legal JavaScript
    value. In most cases, it is an instance of the `Error` class; however, there is no
    convention for the contents of the error object. Some APIs may return an object,
    string, or number instead of an Error instance. Be sure to read the documentation
    of any third-party API to ensure that your code can handle the error format being
    returned.
  prefs: []
  type: TYPE_NORMAL
- en: If the higher order function does NOT encounter an error, the error parameter
    should be set to null. When building your own APIs, it is recommended that you
    also follow this convention. Some third-party APIs may return a falsy value that
    is not null, but this is discouraged because it can make error handling logic
    more complicated.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**Falsy** is a term used in JavaScript type comparison and conversion. Falsy values
    in JavaScript translate to the Boolean false when used in type comparisons. Examples
    of falsy values are null, undefined, 0, and the Boolean false.'
  prefs: []
  type: TYPE_NORMAL
- en: The result argument of a callback function contains the evaluated result of
    the higher order function. This may be the result of an HTTP request, database
    query, or any other asynchronous operation. Some APIs also may provide more detailed
    error information in the result field when an error is returned. It is important
    to not assume a function completed successfully if the result object is present.
    You must check the error field.
  prefs: []
  type: TYPE_NORMAL
- en: 'When handling errors in callback functions, we must check the error argument.
    If the error argument is not null or undefined, then we must handle the error
    in some way. An example error handler is shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 2.8: Basic callback error handling'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Most developers check to see if the error value is a truthy value. If `err`
    is truthy then error handling code is executed. This is a general practice; however,
    it is the lazy way of coding. In some cases, the error object could be the Boolean
    false, the number 0, the empty string, and so on. These all evaluate to falsy,
    even though the value is not null or undefined. If you are using an API, be sure
    to check that it will not return an error that evaluates to falsy. If you are
    building an API, we do not recommend ever returning an error that could evaluate
    to falsy.
  prefs: []
  type: TYPE_NORMAL
- en: Callback Pitfalls
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Callbacks are easy to use and serve their purpose very well, but there are a
    few pitfalls to consider when using callbacks. The two most common pitfalls are
    callback hell and callback existence assumption. Both of these pitfalls are easily
    avoided if the code is written with foresight.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most common callback pitfall is **callback hell**. After asynchronous work
    completes and a callback is called, the callback function can call another asynchronous
    function to do more asynchronous work. When it calls the new asynchronous function,
    another callback will be provided. The new callback will be nested inside of the
    old callback. An example of callback nesting is shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 2.9: Callback nesting'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'In the preceding snippet, we have nested callbacks. The callback of the first
    asynchronous operation, `listFollowers` calls a second asynchronous operation.
    The unfollow operation also has a callback that simply handles an error or logs
    text. Since callbacks can be nested, after several nesting layers the code can
    become quite hard to read. This is callback hell. An example of callback hell
    is shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 2.10: Callback hell'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the preceding snippet, we listed our followers, then unfollow and block the
    first three followers. It is very simple code, but because the callbacks are nested,
    the code becomes messier. This is callback hell.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Callback hell is about untidy code presentation, not the logic behind it. Callback
    nesting can lead to code that runs without errors but is very hard to read. Code
    that is very difficult to read can be very difficult to explain to new developers
    or debug when an error occurs.
  prefs: []
  type: TYPE_NORMAL
- en: Fixing Callback Hell
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Callback hell can easily be avoided with two tricks: **named functions** and
    **modules**. A named function is very simple; define the callback and assign it
    to an identifier (variable). The defined callback functions can be kept in the
    same file or put into a module and imported. Using named functions in callbacks
    will help prevent callback nesting from cluttering your code. This is shown in
    the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 2.11: Fixing callback hell'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As we can see from the preceding snippet, the code without nesting is much cleaner.
    If we had a callback nesting depth of 30, the only way to make the code readable
    would be to break the callbacks into named functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another potential pitfall is the non-existence of a callback function. If we
    are writing an API, we must consider the possibility that the user of the API
    might not pass a valid callback function into the API. If the intended callback
    is not a function or does not exist, then trying to call it will cause a runtime
    error. It is a good practice to validate that a callback exists and that it is
    a function before attempting to call it. If the user passes in an invalid callback,
    then we can fail gracefully. An example of this is shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 2.12: Checking callback existence'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the preceding code snippet, we checked to make sure that the `callback` argument
    exists and is truthy, and that it is of type function. If the callback does not
    exist or is not a function, we throw an error to let the user know exactly what
    went wrong. If the `callback` is a function, we proceed.
  prefs: []
  type: TYPE_NORMAL
- en: '**Conclusion**'
  prefs: []
  type: TYPE_NORMAL
- en: A callback is simply a function passed as an argument into another function,
    called a **higher order** function. JavaScript uses callbacks to handle events.
    Callbacks are defined with an error argument and a result argument. If there is
    an error in the higher order function, the callback error field will be set. If
    the higher order function completes with results, the result field will contain
    the result of the completed operation.
  prefs: []
  type: TYPE_NORMAL
- en: When using callbacks, we should be cautious of two pitfalls. We must be careful
    of nesting too many callbacks together and creating callback hell. We must make
    sure that we validate the arguments passed into our higher order functions to
    ensure that the callback is a function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 17: Working with Callbacks'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Your team is building an API that is based around callbacks. To prevent runtime
    errors, you need to validate that the callback arguments passed into the callbackAPI
    functions are valid callable functions. Create a function for your API. In the
    body of that function, validate that the callback argument is a function. If it
    is not a function, throw an error. After a delay, log the data passed into the
    API function and call the callback.
  prefs: []
  type: TYPE_NORMAL
- en: 'To build a callback API with callbacks function, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Write a function called `higherOrder` that takes in two arguments; an object
    called `data` and a callback function called `cb`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the function, check that the callback is a function argument (`cb`) is a
    function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If `cb` does not exist or it is not of type `function`, then throw an error.
  prefs: []
  type: TYPE_NORMAL
- en: In the function, log the `data` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the function, call the `callback` function after a timeout of 10 ms.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Outside the function, create a `try-catch` block.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the try section, call the `higherOrder` function with a data object and
    no callback function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the catch section, catch the error and log the error message we got.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After the `try-catch` block, call the `higherOrder` function with a data object
    and a `callback` function. The callback function should log the string `Callback
    Called!`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Code**'
  prefs: []
  type: TYPE_NORMAL
- en: Index.js
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 2.13: Implementing callbacks'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: https://bit.ly/2VTGG9L
  prefs: []
  type: TYPE_NORMAL
- en: '**Outcome**'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.7: Callback output'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_2.7.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.7: Callback output'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You have successfully built a callback API with callback functions.
  prefs: []
  type: TYPE_NORMAL
- en: Promises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In JavaScript, a **promise** is an object that wraps an asynchronous operation
    and notifies the program when the asynchronous operation completes. The promise
    object represents the eventual completion or failure of the wrapped operation.
    A promise is a proxy for a value not necessarily known. Instead of providing the
    value immediately, like a synchronous program, it promises to provide a value
    at some point in the future. Promises allow you to associate success and error
    handlers with an asynchronous action. These handlers are called at the completion
    or failure of the wrapped asynchronous process.
  prefs: []
  type: TYPE_NORMAL
- en: Promises States
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Every promise has a state. A promise can only succeed with a value or fail with
    an error once. The state of a promise defines where the promise is in its work
    towards the resolution of a value.
  prefs: []
  type: TYPE_NORMAL
- en: 'A promise comes in three states: **pending**, **fulfilled**, or **rejected**.
    A promise starts in the pending state. This means that the async operation being
    done inside the promise is not complete. Once the asynchronous operation completes,
    the promise is considered settled and will enter either the fulfilled or rejected
    state.'
  prefs: []
  type: TYPE_NORMAL
- en: When a promise enters the fulfilled state, it means that the async operation
    has completed without an error. The promise is fulfilled and a value is available.
    The value generated by the async operation has been returned and can be used.
  prefs: []
  type: TYPE_NORMAL
- en: When a promise enters the rejected state, it means that the async operation
    has completed with an error. When a promise is rejected, no future work will be
    done and no value will be provided. The error from the asynchronous operation
    has been returned and can be referenced from the promise object.
  prefs: []
  type: TYPE_NORMAL
- en: Resolving or Rejecting a Promise
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A promise is created by instantiating a new object of the `Promise` class.
    The promise constructor accepts a single argument, a function. This function must
    have two arguments: **resolve** and **reject**. An example of promise creation
    is shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 2.14: Promise creation syntax'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The main asynchronous work of the promise will be done in the body of the function
    passed into the constructor. The two arguments, `resolve` and `reject`, are functions
    that can be used to complete the promise.. To complete the promise with an error,
    call the reject function with the error as its argument. To mark the promise as
    successful, call the `resolve` function and pass in the result in to resolve as
    a parameter. Examples of promise rejection and resolution are shown in the following two
    snippets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 2.15: Rejecting a promise'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 2.16: Resolving a promise'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'An example of resolving a promise that performs asynchronous work, is shown
    in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 2.17: Resolving a promise'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Using Promises
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The promise class has three member functions that can be used to handle promise
    fulfillment and rejection. These functions are called promise handlers. These
    functions are `then()`, `catch()`, and `finally()`. When a promise completes,
    one of the handler functions is called. If the promise fulfills, the `then()`
    function is called. If the promise is rejected, either the `catch()` function
    is called, or the `then()` function with a rejection handler is called.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `then()` member function is designed to handle and get the promise fulfillment
    or rejection result. The `then` function takes in two function arguments, a fulfillment
    callback and a rejection callback. This is shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 2.18: Promise.then() syntax'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The first argument in the `then()` function is the promise fulfillment handler.
    If the promise is fulfilled with a value, the promise fulfillment handler callback
    is called. The promise fulfillment handler takes one argument. The value of this
    argument will be the value passed in to the fulfilled callback in the promise
    function body. An example of this is shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 2.19: Promise.then() with resolved promise'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The second argument in the `then()` function is the promise rejection handler.
    If the promise is rejected with an error, the promise rejection handler callback
    is called. The promise rejection handler takes one argument. The value of this
    argument is the value passed in to the reject callback in the promise function
    body. An example of this is shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 2.20: Promise rejection with Promise.then()'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Exercise 18: Creating and Resolving Your First Promise'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To build our first asynchronous promise, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a promise and save it into a variable called `myPromise`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the body of the promise, log `Starting asynchronous work!`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the body of the promise, do asynchronous work with a timeout.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Have the `timeout` callback fire after 1000 ms. Inside the `timeout` callback
    function, call the promise resolution function and pass in the value `Done!`
  prefs: []
  type: TYPE_NORMAL
- en: Attach a then handler to the promise saved in `myPromise`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pass a function into the then handler that takes in one parameter and logs the
    value of the parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Code**'
  prefs: []
  type: TYPE_NORMAL
- en: Index.js
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 2.21: Promise rejection with Promise.then()'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: https://bit.ly/2TVQNcz
  prefs: []
  type: TYPE_NORMAL
- en: '**Outcome**'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.8: Scope outputs'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_2.8.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.8: Scope outputs'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You have successfully utilized the syntax you just learned to build our first
    asynchronous promise.
  prefs: []
  type: TYPE_NORMAL
- en: Handling Promises
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When `Promise.then()` is called, it returns a new promise in the pending state.
    After the promise handler for fulfilled or rejected has been called, the handlers
    in `Promise.then()` get called asynchronously. When the handler called from `Promise.then()`
    returns a value, that value is used to resolve or reject the promise returned
    by `promise.then()`. The following table provides the action taken if the handler
    function returns a value, an error, or a promise at any stage:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.9: Returning a promise](image/Figure_2.9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.9: Returning a promise'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`Promise.catch` takes in one argument, a handler function, to handle the promise
    rejection value. When `Promise.catch` is called, internally it calls `Promise.then(
    undefined, rejectHandler )`. This means that internally, the `Promise.then()`
    handler is called with only the promise rejection callback, `rejectHandler`, and
    no promise fulfillment callback. `Promise.catch()` returns the value of the internal
    `Promise.then()` call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 2.22: Promise rejection with Promise.then()'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The promise member function, `Promise.finally()`, is a promise handler that
    is used to catch all promise completion cases. A `Promise.finally()` handler will
    be called for both promise rejections and resolutions. It takes in a single function
    argument that is called when the promise is rejected or fulfilled. `Promise.finally()`
    will catch both rejected and resolved promises, and run the specified function.
    It provides us with a catch all handler to handle either fulfillment case. `Promise.finally()`
    should be used to prevent duplication of code between the then and catch handlers.
    The function passed in to `Promise.finally()` does not take in any arguments,
    so any value passed in to a promise''s resolution or rejection will be ignored.
    Because there is no way to reliably distinguish between a rejection and a fulfillment
    when using `Promise.finally()`, `Promise.finally()` should only be used when we
    do not care if the promise has been rejected or fulfilled. An example of this
    is shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 2.23: Promise.then()'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'When using promises, there are times when we may want to create a promise that
    is already in the fulfilled state. The Promise class has two static member functions
    that allow us to do this. These functions are `Promise.reject()` and `Promise.resolve()`.
    `Promise.reject()` takes a single argument and returns a promise that has been
    rejected with the value passed in to the reject function. `Promise.resolve()`
    takes in a single argument and returns a promise that has been resolved with the
    value passed in to resolve:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 2.24: Promise.then()'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Promise Chaining
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When using promises, we can run into **promise hell**. This is very similar
    to callback hell. When a promise body needs to do more async work after the value
    is obtained, another promise can be nested. The nested promise calls can get difficult
    to follow when the nesting chain gets very deep. To avoid promise hell, we can
    chain promises together. `Promise.then()`, `Promise.catch()`, and `Promise.finally()`
    all return promises that get fulfilled or rejected with the result of the handler
    functions. This means we can tack on another then handler to this promise and
    make a promise chain to handle the newly returned promise. This is shown in the
    following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 2.25: Promise chaining example'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the preceding example, we created two functions, `apiCall1()` and `apiCall2()`.
    These functions returned a promise that does more asynchronous work. The async
    work has been omitted from this example for brevity. When the original promise,
    `myPromise`, completes, the `Promise.then()` handler calls `apiCall1()`, which
    returns another promise. The second `Promise.then()` handler is applied to this
    newly returned promise. When the promise returned by `apiCall1()` is resolved,
    the handler function calls `apiCall2()`, which also returns a promise. When the
    promise returned by `apiCall2()` is returned, the final `Promise.then()` handler
    is called. If these handler functions with asynchronous work were nested, it could
    get very difficult to follow the program. With callback chaining, it becomes very
    easy to follow the program flow.
  prefs: []
  type: TYPE_NORMAL
- en: When chaining promises, it is possible for the promise handler to return a value
    instead of a new promise. If a value is returned, the value gets passed as an
    input to the next `Promise.then()` handler in the chain.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the first promise completes and calls the `Promise.then()` handler.
    This handler does synchronous work and returns the number 10\. The next `promise.then()`
    handler will have the input parameter set to 10 and can continue doing the asynchronous
    work. This allows you to embed synchronous steps into the promise chain.
  prefs: []
  type: TYPE_NORMAL
- en: 'When chaining promises, we must be careful with catch handlers. When a promise
    is rejected, it jumps to the next promise rejection handler. This can be the second
    argument in a `then` handler or a `catch` handler. All fulfillment handlers between
    where the promise is rejected, and the next rejection handlers, will be ignored.
    When the catch handler completes, the promise returned by `catch()` will be fulfilled
    with the returned value of the rejection handler. This means that the following
    promise fulfillment handler will be given a value to run with. If the `catch`
    handler is not the last handler in the promise chain, the promise chain will continue
    to run with the returned value of the `catch` handler. This can be a tricky error
    to debug; however, it allows us to catch a promise rejection, handle the error
    in a specific way, and continue with the promise chain. It allows the promise
    chain to handle a reject or accept in different ways, then continue with the async
    work. This is shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 2.26: Handle error and continue'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the preceding snippet, we have a promise chain with three asynchronous API
    calls in a row, after the resolution of `myPromise`. The first API call will reject
    the promise with an error. The rejected promise is handled by the second then
    handler. Since the promise is rejected, it ignores `apiCall2()` and routes to
    the `errorHandler1()` function. `errorHandler1()` will do some work and return
    a value or promise. That value or promise is passed to the next handler, which
    calls `apiCall3()`, which returns a resolved promise. Since the promise is resolved
    and there are no more `then` handlers, the promise chain ends. The final catch
    is ignored.
  prefs: []
  type: TYPE_NORMAL
- en: To skip from one rejection handler to the next rejection handler, we need to
    throw an error inside the rejection `handler` function. This will cause the returned
    promise to be rejected with the error thrown and skip to the next `catch` handler.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we wish to exit the promise chain early and not continue when a promise
    is rejected, you should only include a single catch handler at the end of the
    chain. When a promise is rejected, the rejection is handled by the first handler
    found. If this handler is the last handler in the promise chain, the chain ends.
    This is shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 2.27: Handle error at end of chain to abort'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the promise chain shown in the preceding snippet, when myPromise is resolved
    with a value, and the first `then` handler is called. `apiCall1()` is called and
    it returns a rejected promise. Since the next two `then` handlers do not have
    an argument to handle promise rejection, the rejection is passed to the `catch`
    handler. The catch handler calls `errorHandler1` and then the promise chain ends.
  prefs: []
  type: TYPE_NORMAL
- en: 'Chaining promises is used to ensure that all promises complete in the order
    of the chain. If promises need not be completed in order, we can use the `Promise.all()`
    static member function. The `Promise.all()` function is not created on instances
    of the promise class. It is a static class function. `Promise.all()` takes in
    an array of promises and when all of the promises have been resolved, the `then`
    handler will be called. The `then` handler function''s parameter will be an array
    with the resolve value of each promise in the original `Promise.all()` call. The
    array of the resolution values will match the order of the array of the input
    to `Promise.all()`. This is shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 2.28: Promise.all() example'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the preceding example, we created three promises that resolve after 100ms,
    200ms, and 10ms respectively. We then pass these promises into the `Promise.all()`
    function. Once all of the promises have resolved, the then handler attached to
    the function `Promise.all()` is called. This handler logs the results of the promises.
    Notice that the order of the result array matches the order of the promise array,
    not the completion order of the promises.
  prefs: []
  type: TYPE_NORMAL
- en: 'If one or many of the promises in the `Promise.all()` call are rejected, the
    `reject` handler will be called with the rejection value of the first promise.
    All of the other promises will run to completion but rejections or resolutions
    of these promises will not call any of the `then` or `catch` handlers of the `P``romise.all()`
    promise chain. This is shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 2.29: Promise.all() rejection'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In this example, we create three promises that log the promise number and then
    are all rejected with various errors. We pass these promises into a `Promise.all`
    call. `Promise3` has the shortest timeout and therefore is the first promise to
    be rejected. When `Promise3` is rejected, the promise rejection is passed to the
    nearest error handler (`.catch()`) which logs the promise rejection. Promises
    1 and 2 complete running shortly thereafter and are both rejected. The rejection
    handler is not called again for these promises.
  prefs: []
  type: TYPE_NORMAL
- en: A last function that exists to handle multiple promises is the `Promise.race()`
    function. The `Promise.race()` function is designed to handle only the first promise
    fulfilled or rejected.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If for some reason, your program has an intentional race condition or multiple
    code paths that should only cause a successful response handler to be called once,
    `Promise.race()` is the perfect solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like `Promise.all()`, `Promise.race()` is passed an array of promises; however,
    `Promise.race()` only calls the promise fulfillment handler for the first promise
    completed. It then proceeds with the promise chain as normal. The results from
    the other promises are discarded, whether they are rejected or resolved. Promise
    rejection handling with `Promise.race()` works the same way as `Promise.all()`.
    Only the first rejected promise is handled. The other promises are ignored, regardless
    of the fulfillment state. An example of `Promise.race()` is shown in the following
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 2.30: Promise.race() example'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the preceding example, we created three promises. These promises all resolve
    after various timeouts. `Promise3` resolves first because it has the shortest
    timeout. When `promise3` resolves, the then handler is called and the result of
    `promise3` is logged. When `promise1` and `promise2` resolve, their results are
    ignored.
  prefs: []
  type: TYPE_NORMAL
- en: Promises and Callbacks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Promises and callbacks should never be mixed together. Writing code that utilizes
    both callbacks and promises to do asynchronous work can get very complicated and
    lead to errors that are extremely difficult to debug. To prevent mixing callback
    logic and promise logic, we must add shims in our code to handle callbacks as
    promises and promises as callbacks. There are two ways to do this: promises can
    be wrapped in callbacks or callbacks can be wrapped in promises.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A shim is a code file used to add missing functionality to a code base. Shims
    are usually used to ensure cross-browser compatibility for web applications.
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping Promises in Callbacks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To wrap a promise function in a callback, we simply create a wrapper function
    that takes the `promise` function, the arguments, and a `callback`. Inside the
    `wrapper` function, we call the `promise` function and pass in the provided arguments.
    We attach `then` and `catch` handlers. When these handlers resolve, we call the
    `callback` function with the result or the error returned by the promise. This
    is shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 2.31: Wrap promise in a callback'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the preceding example, we called the callback with the result of the promise.
    If the promise is resolved with a value, we pass that value into the callback
    with the error field set to null. If the promise is rejected, we pass the error
    into the callback with a null result field.
  prefs: []
  type: TYPE_NORMAL
- en: 'To wrap a callback-based function in a promise, we simply create a wrapper
    function that takes the function to wrap and the function arguments. Inside the
    wrapper function, we call the function being wrapped inside a new promise. When
    the callback returns a result or error, we reject the promise if there is an error,
    or we resolve the promise if there is no error. This is shown in the following
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 2.32: Wrap callback in a promise'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the preceding example, we created a wrapper function that takes in a function
    and that function's arguments. We return a promise that calls this function and
    depending on the result, rejects or resolves the promise. Since this function
    returns a promise, it can be embedded in a promise chain or can have a then or
    catch handler attached to it.
  prefs: []
  type: TYPE_NORMAL
- en: '**Conclusion**'
  prefs: []
  type: TYPE_NORMAL
- en: Promises are another way to handle asynchronous programming in JavaScript. When
    created, a promise starts in the pending state and enters the fulfilled or the
    rejected state depending on the result of the asynchronous work. To handle the
    result of a promise, we use the `.then()`, `.catch()`, and `.finally()` member
    functions. The `.then()` function takes in two handler functions, one for promise
    fulfillment and one for promise rejection. The `.catch()` function takes in only
    one function and handles promise rejection. `Promise.finally()` takes in one function
    and is called for either a promise fulfillment or rejection.
  prefs: []
  type: TYPE_NORMAL
- en: When multiple promises need to be run but order does not matter, we can use
    the `Promise.all()` and `Promise.race()` static functions. The `Promise.all()`
    resolution handler is called when all of the promises have finished running. The
    `Promise.race()` resolution handler is called when the first promise has finished
    running.
  prefs: []
  type: TYPE_NORMAL
- en: Promises and callback are not compatible and should never be mixed in the body
    of a program. To allow for compatibility between functions and modules using promises
    or callback functions, we can write a wrapper function. We can wrap a callback
    in a promise or a promise in a callback. This allows us to shim third-party modules
    to be compatible with our code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 19: Working with Promises'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You are building a promise-based API. In your API, you must validate user input
    to ensure data passed into your database models is of the right type. Write a
    function that returns a promise. This promise should validate that the data value
    passed into the API function is not a number. If the user passes a number into
    the function, reject the promise with an error. If the user passes a non-number
    into the API function, resolve the promise with the word `Success!`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To build a function that uses promises for real scenarios, perform the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Write a function called `promiseFunction` that takes in one data argument and
    returns a promise.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pass a function that takes in two arguments, resolve and reject, into the constructor
    of the promise.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the promise, start doing asynchronous work by creating a timeout that runs
    after 10ms.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `timeout` callback function, log the input data that was provided to
    `promiseFunction`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `timeout` callback, check that the type of data is a number. If it is,
    reject the promise with an error, otherwise resolve the promise with the string
    `Success!`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run `promiseFunction` and provide a number as the parameter. Attach a `then()`
    handler and a `catch()` handler to the promise returned by the function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `then` handler should log the promise resolution value. The `catch` handler
    should log the error's message property.
  prefs: []
  type: TYPE_NORMAL
- en: '**Code**'
  prefs: []
  type: TYPE_NORMAL
- en: Index.js
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 2.33: Implementing promises'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: https://bit.ly/2SRZapq
  prefs: []
  type: TYPE_NORMAL
- en: '**Outcome**'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.10: Scope outputs](image/Figure_2.10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.10: Scope outputs'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Async/Await
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Async/await** is a new syntax form added to simplify code that uses promises.
    Async/await introduces two new keywords: `async` and `await`. Async is added to
    function declarations and await is used inside an `async` function. It is surprisingly
    easy to understand and use. In its simplest form, async/await allows us to write
    promise-based asynchronous code that looks almost identical to the synchronous
    code that does the same task. We will use async/await to simplify code using promises
    and make it even easier to read and understand.'
  prefs: []
  type: TYPE_NORMAL
- en: Async/Await Syntax
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `async` keyword is added to function declarations; it must precede the
    function keyword. An `async` function declaration defines an asynchronous function.
    An example declaration of an `async` function is shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 2.34: Implementing promises'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'An `async` function implicitly returns a promise, no matter what the return
    value is specified to be. If the return value is specified as a non-promise type,
    JavaScript automatically creates a promise and resolves that promise with the
    returned value. This means that all async functions can have the `Promise.then()`
    and `Promise.catch()` handlers applied to the return value. This allows for very
    easy integration with existing promise-based code. This is shown in the following
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 2.35: Async function output'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The `await` keyword can only be used inside of an `async` function. Await tells
    JavaScript to wait until the associated promise settles and returns its result.
    This means that JavaScript pauses execution of that block of code, waits for the
    promise to be resolved while doing other async work, then resumes that block of
    code once the promise settles. This makes the awaited block of code run like a
    synchronous function, but it does not cost any resources because the JavaScript
    engine can still do other work, such as run scripts or handle events, while the
    asynchronous code is being awaited. An example of the await keyword is shown in
    the following snippet.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Even though async/await functionality makes JavaScript code look and act as
    if it were synchronous, JavaScript is still running the code asynchronously with
    the event loop.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 2.36: Await keyword'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the preceding example, we defined an `async` function, `awaitExample()`.
    Since it is an `async` function, we can use the await keyword. Inside the function,
    we create a promise that does asynchronous work. In this case, it simply waits
    100 milliseconds and then resolves the promise with the string `done!`. We then
    await the created promise. When the promise is resolved with a value, the await
    takes that value and returns it, and the value is saved in the variable result.
    We then log the value of result to the console. Instead of using a then handler
    on the promise to get the resolution value, we simply await the value. The await
    block of this code looks similar to a synchronous code block.
  prefs: []
  type: TYPE_NORMAL
- en: Asnyc/Await Promise Rejection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that we know how to handle promise fulfillment with async/await, how can
    we handle promise rejection? Error rejection with async/await is very simple and
    works fantastically with the standard JavaScript error handling. If a promise
    is rejected, the await statement waiting for that promise resolution throws an
    error. When an error is thrown inside an `async` function, it is caught automatically
    by the JavaScript engine and the promise returned by the `async` function is rejected
    with that error. This sounds slightly complicated, but it is very simple. These
    relations are shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 2.37: Async/await promise rejection'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the preceding snippet, we created three async functions. In the first function,
    `errorExample1()`, we return a promise that is rejected with the string `Rejected!`.
    In the second function, `errorExample2()`, we throw the string `Rejected!`. Since
    this is an error thrown inside an `async` function, the `async` function wraps
    it in a promise and returns a promise rejected with the thrown value. In this
    case, it returns a promise rejected with the string `Rejected!`. In the third
    function, `errorExmaple3`, we await a rejected promise. Awaiting rejected promises
    causes JavaScript to throw the promise rejection value, which is `Rejected!`.
    The `async` function then catches the error thrown with this value,, wraps it
    in a promise, rejects the promise with that value, and returns the rejected promise.
    All three example functions return a promise rejected with the same value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since await throws an error if the awaited promise is rejected, we can simply
    use the standard try/catch error handling mechanism in JavaScript to handle the
    async errors. This is very useful because it allows us to handle all errors in
    the same manner, whether asynchronous or synchronous. This is shown in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 2.38: Error handling'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the preceding example, we created an async function that tries to do asynchronous
    work. The function tries to await three promises in a row. The final one is rejected,
    which causes an error to be thrown. This error is caught and handled by the `catch`
    block.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since errors are wrapped in promises and rejected by async functions, and await
    throws errors when a promise is rejected, async/await function error propagate
    upwards to the highest level await call. This means that unless an error needs
    to be handled in a special manner at various nesting levels, we can simply use
    a single try catch block for the outermost error. The error will propagate up
    the async/await function stack through rejected promises, and only needs to be
    caught by the top-level await block. This is shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 2.39: Nested error handling'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the preceding example, we created several async functions that await the
    result of another async function. They are called in the order `nextedErrorExample()
    -> nested3() -> nested2() -> nested1()`. The body of `nested1()` awaits a rejected
    promise, which throws an error. `Nested1()` catches this error and returns a promise
    rejected with that error. The body of `nested2()` awaits the promise returned
    by `nested1()`. The promise returned by `nested1()` was rejected with the original
    error, so the await in `nested2()` throws an error, which is wrapped in a promise
    by `nested2()`. This propagates down until the `await` in `nestedErrorExample()`.
    The `await` in the nested error example throws an error, which is caught and handled.
    Since we only need to handle the error at the highest level, we put the try/catch
    block at the outermost await call and allow the error to propagate upward until
    it hits that try/catch block.
  prefs: []
  type: TYPE_NORMAL
- en: Using Async Await
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we know how to use async/await, we need to integrate it into our promise
    code. To convert our promise code to use async/await, we simply need to break
    the promise chains into async functions and await each step. The chain of promise
    handlers is separated at each handler function (`then()`, `catch()`, and so on).
    The value returned by the promise is caught with an `await` statement and saved
    into a variable. This value is then passed into the `callback` function of the
    first promise `then()` promise handler, and the result of the function should
    be caught with an `await` statement and saved into a new variable. This is done
    for each `then()` handler in the promise chain.
  prefs: []
  type: TYPE_NORMAL
- en: 'To handle the errors and promise rejections, we surround the entire block with
    a try catch block. An example of this is shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 2.40: Integrating async/await'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As we can see in the promise chain, we chain three API calls and an error handler
    on to the resolution of `myPromise`. At each promise chain step, a promise is
    returned and a new `Promise.then()` handler is attached. If one of the promise
    chain steps is rejected, the catch handler is called.
  prefs: []
  type: TYPE_NORMAL
- en: In the async/await example, we break the promise chain at each `Promise.then()`
    handler. We then convert the `then` handlers into functions that return promises.
    In this case, `apiCall1()`, `apiCall2()`, and `apiCall3()` already return promises.
    We then await each API call step. To handle a promise rejection, we must surround
    the entire block with a try catch statement.
  prefs: []
  type: TYPE_NORMAL
- en: Much like with promise chains with multiple chained then handlers, an `async`
    function with multiple await calls will run each await call one at a time, not
    starting the next await call until the previous await call has received a value
    from the associated promise. This can slow down asynchronous work if we are trying
    to complete several asynchronous tasks at the same time. We must wait for each
    step to complete before starting the next step. To avoid this, we can use `Promise.all`
    with `await`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we learned earlier, `Promise.all` runs all the child promises at the same
    time and returns a pending promise that is not fulfilled until all of the child
    promises have been resolved with a value. We can await a `Promise.all` much like
    we would attach a then handler to a `Promise.all`. The value returned by an await
    `Promise.all` call will only be available when all the child promises have completed.
    This is shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 2.41: Parallel await promises'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As we can see from the preceding example, we created several promises, pass
    those promises into a `Promise.all` call, then await the resolution of the promise
    returned by `Promise.all`. This follows the rules of async/await just as we would
    expect it to. This same logic can be applied to `Promise.race` as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of a promise race is shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 2.42: Promise race example'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '**Conclusion**'
  prefs: []
  type: TYPE_NORMAL
- en: Async/await is an amazing new syntax format that helps us simplify promise-based
    code. It allows us to write code that looks like synchronous code. Async/await
    introduces two keywords, **async** and **await**. Async is used to denote an `async`
    function. It prepends the function keyword when declaring functions. Async functions
    always return a promise. The await keyword can only be used inside async functions
    on promises. It tells the JavaScript engine to wait on a promise resolution, and
    on rejection or fulfillment, throws an error or returns the value. Async/await
    error handling is done through thrown errors and rejected promises. An `async`
    function automatically catches thrown errors and returns a promise rejected with
    that error. Awaited promises throw errors on rejection. This allows error handling
    to be coupled easily with the standard JavaScript try/catch error handling. Async/await
    is very easy to integrate into your promise-based code and can make it very easy
    to read.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 2: Using Async/Await'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You have been tasked to build a server that interfaces with a database. You
    must write code to create and look up basic user objects in the database. Import
    the `simple_db.js` file. Using the `get` and `insert` commands, write the following
    program using async/await syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: Look up the `john` key and if it exists, log the age field of the result object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Look up the `sam` key and if it exists, log the age of the result object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Look up your name. If it does not exist, insert your name. If you must add an
    object, look up the new object and log the age.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For any `db.get` operation that fails, save the key into an array. At the end
    of the program, print the keys that failed.
  prefs: []
  type: TYPE_NORMAL
- en: 'DB API:'
  prefs: []
  type: TYPE_NORMAL
- en: '`db.get( index ):`'
  prefs: []
  type: TYPE_NORMAL
- en: This takes in an index and returns a promise. A promise is fulfilled with the
    `db` entry associated with that index. If the index does not exist, the lookup
    fails, or the key is not specified, the promise is rejected with an error.
  prefs: []
  type: TYPE_NORMAL
- en: '`db.insert( index, insertData ):`'
  prefs: []
  type: TYPE_NORMAL
- en: This takes in an index and data, and returns a promise. The promise is fulfilled
    with the key inserted if the operation completes. If the operation fails, or there
    is no key or insert data specified, the promise is rejected with an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'To utilize promises and async/await syntax to build a program, perform the
    following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Write an `async` function called `main`. All operations will go in here.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an array to keep track of keys that cause db errors.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Catch all errors and log them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Outside all of the try-catch blocks, at the end of the `main` function, return
    the array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call the main function and attach a `then()` and `catch()` handler to the returned promise.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Outcome**'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.11: Scope outputs'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_2.11.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 2.11: Scope outputs'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You successfully used promises and async/await syntax to build a program that
    accesses a database.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 282.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JavaScript is an asynchronous, event-driven, single-threaded language. Instead
    of hanging during a long-running operation to another resource, JavaScript does
    work on other operations if any work is pending. JavaScript accomplishes this
    with the event loop. The event loop is composed of the call stack, heap, event
    queue, and main event loop. These four components work together to schedule when
    JavaScript runs different parts of the code. To leverage JavaScript's asynchronous
    nature, we use callbacks or promises. Callbacks are simply functions passed as
    arguments into other functions. Promises are special classes with event handler
    functions. When an asynchronous operation finishes, the JavaScript engine runs
    the callback or calls the promise handler attached to that operation's complete
    event. This is asynchronous JavaScript in its simplest form.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about the **Document Object Model** (DOM),
    the **JavaScript event object**, and the **jQuery library**.
  prefs: []
  type: TYPE_NORMAL
