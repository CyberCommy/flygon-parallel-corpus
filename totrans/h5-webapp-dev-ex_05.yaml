- en: Chapter 5. Not So Blank Canvas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"This world is but a canvas to our imagination."'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '>'
  prefs: []
  type: TYPE_NORMAL
- en: – Henry David Thoreau
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*In the previous chapter we learned the basics of using the HTML5 canvas. We
    created a drawing application called Canvas Pad with tools to draw lines and shapes
    in all different colors and sizes. In this chapter we will continue our exploration
    of the Canvas API by extending Canvas Pad to add more tools. Then we will create
    a new application called Photo Pad where we will take a look at how to load images
    using the File API and perform image processing by accessing and modifying the
    individual pixels of the canvas.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we will learn:'
  prefs: []
  type: TYPE_NORMAL
- en: How to get text input and draw it to the canvas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use the Canvas API transformation functions to change how items are drawn
    on the canvas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to export the canvas image to save it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to load images using the HTML5 File API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to draw bitmap images to the canvas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to get the data for each pixel in a canvas, manipulate it, and put it back
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drawing text
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two methods available to draw text on the canvas: `strokeText()`
    and `fillText()`. `strokeText()` draws outlined text using the current `lineWidth`
    and `strokeStyle`, while `fillText()` draws with the current `fillStyle`. Both
    take the same parameters; the text to draw, and the x and y coordinates. The context
    object has a global font property to define which `font` to use. You set its value
    the same you would when defining a font in CSS. Continuing where we left off in
    the previous chapter with our Canvas Pad application, we will add a new text drawing
    tool. You can find the source code for this section in `Chapter 5/example5.1`.'
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – adding a text tool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start by adding a new item to the Tool drop-down menu for the text tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''ll add a `drawText()` method to the `Canvas2D` object. It will take
    the text to draw, a point from where to draw the text, and a Boolean value indicating
    whether to fill the text or just outline it. If `fill` is `true`, it uses `fillText()`
    to draw the text, otherwise it uses `strokeText()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now we need a way to allow the user to enter the text that he/she wants to draw.
    We will need a text input field that we will keep hidden until the user wants
    to add some text. When the user selects the text tool and clicks on the canvas,
    we will position the text field where he/she clicked on and wait for him/her to
    enter the text. When the user presses the *Enter* key, we will hide the text field
    and draw the text to the canvas.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make it seem like the user is typing on the canvas, we need to set a couple
    more properties in the canvas context for the font. We will set the `font` and
    `textBaseline` properties in the constructor. The baseline tells the context where
    to draw the text relative to the position. We will set it to `"top"` so it will
    draw the top of the text at the y position, which is the same place our text field
    will be. Other common baseline values are `"bottom"` and `"middle"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need a text field for the user to enter text. Let''s add it to the bottom
    of our HTML file, after the footer element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let''s go into our CSS and define the style for the `text-input` element.
    We will set `display` to `none`, so that it is hidden, and set `position` to `absolute`,
    so that we can position it wherever we want to on the page. We will also change
    the size of the font to 24 pixels because that''s what we set for our font size
    in the context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s add some JavaScript code to the `penDown()` method in `CanvasPadApp`
    so that when the user clicks the mouse it shows the text input field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: First it checks the current tool. If it is the text tool, it checks to see if
    the text field is already visible and if so, there's no need to continue. Otherwise
    it calls `showTextInput()` passing in the mouse coordinates. Notice that we don't
    set `drawing` to `true` in this case because we don't need to track the mouse.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `showTextInput()` method takes the mouse coordinates and moves the `text-input`
    element to the point where the user clicked the mouse on the canvas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: First we set the `top` and `left` CSS properties to move the element over to
    where the user clicked on and then fade it in. Then it resets the value of the
    text field and sets the focus on it so the user can start typing. This will make
    it appear that the user is typing on the canvas.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the user is done typing, he/she can press the *Enter* key to finish the
    text. We need to add a `keydown` event handler to the text field to check for
    this. We will add that in the `start()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The handler calls `checkTextInput()`, passing in the key code of the key that
    was pressed. The key code is found in the `which` field of the event object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `checkTextInput()` method looks at the key code to see what to do. If the
    user pressed the *Enter* key, which is key code 13, it will set the text into
    the current action object, hide the text input, and then call `redraw()`. If the
    key code is 27, which is the *Escape* key,it will cancel the text by removing
    the action and then hiding the text input.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final piece to implement is the change to `redraw()`. We need to add the
    text action to our `switch` statement. It passes in the text, the position to
    draw it, and whether to fill it or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We added a Text tool to our application that allows the user to type text on
    the canvas and draw it filled or outlined.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Try adding a toolbar menu for the user to select different font sizes. You will
    need to change the font size in the canvas context as well as the text input field's
    style.
  prefs: []
  type: TYPE_NORMAL
- en: Transformations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Canvas API contains four methods for transforming how things are drawn on
    the canvas. They change the coordinate system of the canvas so that when you draw
    something, it draws at a different place than it normally would. Think of it as
    taking a piece of paper and moving it or rotating it before drawing on it.
  prefs: []
  type: TYPE_NORMAL
- en: '`translate(x, y)`: This translates anything drawn on the canvas by the values
    specified. The values can be any decimal number. Negative numbers translate up
    and to the left. Often you will use `translate()` to translate to the center of
    a shape before applying other transformations to it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scale(x, y)`: This scales anything drawn to the canvas by the values specified.
    The parameters can be any positive decimal number. If you wanted everything to
    be drawn half size, you would use scale (0.5, 0.5). If you wanted to double the
    size, scale (2, 2).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rotate(angle)`: This rotates the canvas by an angle. The angle is specified
    in radians from 0 to 2π. Negative numbers will rotate counterclockwise.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`transform(a, b, c, d, e, f)`: If none of the other transformation methods
    work for you, you can use `transform()` to create your own. I wouldn''t recommend
    it unless you know how to use transformation matrices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Time for action – adding an Ellipse tool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s use some transformations to draw an ellipse in Canvas Pad. An ellipse
    is basically a squashed circle. We can use the `scale()` method to change the
    scale of either the x or y axis before drawing a circle to squash it into an ellipse.
    Let''s add a `drawEllipse()` method to the `Canvas2D` object. It takes a center
    point, an end point, and a Boolean to determine if it should be filled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'There''s a lot going on in here, so let''s break it down:'
  prefs: []
  type: TYPE_NORMAL
- en: First we find the horizontal and vertical radii (rx and ry) by calculating the
    distance between the end point and the center point coordinates. Whichever one
    is the largest will be the radius of the ellipse.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next we find the horizontal and vertical scales by dividing the radii by the
    max radius. Since one of the radii is the max radius, that scale will be 1\. The
    other will be scaled less than 1.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next we call `save()` to save the state of the context before we start transforming
    it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we do our transformations. First we translate to the center of the ellipse,
    so it will transform around the center of the shape. Then we scale by the amounts
    we calculated previously.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then we draw the circle with `beginPath()`, `arc()`, and `closePath()`. Since
    the canvas is scaled on one axis, the circle will be squashed into an ellipse.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then we call either `fill()` or `stroke()` depending on the `fill` parameter
    to draw the circle to the canvas.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally we call `restore()` to restore the context to the way it was before
    we applied the transformations, and we're done.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now that we have a method to draw an ellipse, we can go add an Ellipse menu
    item to the Tool menu in our HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The only thing left to do is add an option for the Ellipse tool in the `switch`
    statement in `redraw()` and we''re done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We added an Ellipse tool to our application and implemented a method to draw
    an ellipse on the canvas using transformations to squash a circle on one axis.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – exporting an image
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can draw pictures with our Canvas Pad application, but what's the point if
    we can't save them? HTML5 doesn't have the capability to save files directly to
    the user's file system because of the security risks. So our options on the client
    side are pretty limited. We can save the data to `localStorage` or we can open
    the image in a new browser window, where the user can save the image using the
    browser's **Save** option. We will do the latter because it allows the user to
    get a real image file they can use.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can get the image data as a URL from a canvas by calling the `toDataURL()`
    method on the canvas element itself (not the context). Then you can open the image
    URL in another window using `window.open()`. Let''s add a **Save** button to our
    toolbar and set the `data-action` attribute to `"save"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Next let''s add a check for the action in the `switch` statement of the `toolbarButtonClicked()`
    method. When the **Save** button is clicked, it will get the data URL and then
    open it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now we can export images from the canvas using the context's `toDataUrl()` method
    and open them in another browser window so they can be saved by the user.
  prefs: []
  type: TYPE_NORMAL
- en: '![What just happened?](img/5947OT_05_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Handling touch events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the great things about HTML5 is that you can write one application and
    it will work on many different devices. Canvas Pad works great as a desktop application
    where mouse events are available. But it would work just as well on a touch screen
    device. So let's add support for touch events to the application.
  prefs: []
  type: TYPE_NORMAL
- en: Touch events are similar to mouse events. One difference is that the user can
    touch the screen with more than one finger, so touch events may contain multiple
    points. So we will have to take that into consideration when handling them.
  prefs: []
  type: TYPE_NORMAL
- en: There are three basic touch events that browsers support.
  prefs: []
  type: TYPE_NORMAL
- en: '`touchstart`: We get this event when the user touches the screen. This is equivalent
    to the `mousedown` event.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`touchmove`: We get these events after `touchstart` when the user moves his/her
    finger on the screen. This is equivalent to the `mousemove` event.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`touchend`: We get this event when the user lifts his/her finger off the screen.
    This is equivalent to the `mouseup` event.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The touch event object that is passed to the event handler contains an array
    called `touches`. This array contains all of the points that were touched. Each
    object in the `touches` array has a `pageX` and a `pageY` field, just like mouse
    events.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can test whether touch events are supported by checking if the document
    element has an `ontouchstart` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: jQuery doesn't include support for touch events, but it would be nice if we
    could use the same jQuery mechanism to add touch event handlers to elements. So
    let's write a jQuery extension to add it. We will create a new file called `touchEvents.js`
    to put our extension in, so that we can reuse it in other applications.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – adding touch event handlers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Extending the jQuery library is actually pretty easy. First we wrap our extensions
    in an immediately invoked function expression and pass the jQuery object into
    it. This is a best practice to make sure the dollar sign is really mapped to jQuery
    and not being used by something else. Then we define our extension methods by
    adding them to jQuery''s internal `$.fn` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that in an extension method's context, the `this` pointer refers to the
    jQuery object that wraps the selected elements. So `this.each()` iterates over
    each of the elements that were selected.
  prefs: []
  type: TYPE_NORMAL
- en: The `touchstart`, `touchmove`, and `touchend` methods all work the same way.
    They iterate over the elements and call `addEventListener()` for each one.
  prefs: []
  type: TYPE_NORMAL
- en: We also defined a global `isTouchSupported` variable directly on the jQuery
    object. It checks for touch support using the method described previously. We
    will use that to determine if we should use touch or mouse events in our application.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can learn more about writing jQuery extensions on the jQuery website ([http://jquery.com](http://jquery.com)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Our extension is done, so let''s go back to `CanvasPadApp` and add the code
    to our application to handle touch events. First in the `start()` method we need
    to check if touch is supported and wire up the correct events:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The `onTouchStart()` event handler method must call both `stopPropagation()`
    and `preventDefault()` on the event object to keep it from performing the default
    behavior. Otherwise it might try to drag the screen rather than draw on the canvas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Next we extract the point that the user touched. There could be multiple points,
    but we are only interested in the first point in the `touches` array. We extract
    the `pageX` and `pageY` fields from it and pass them into the `penDown()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `onTouchMove()` handler works the same way except it calls `penMoved()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `onTouchEnd()` handler simply calls `penUp()`, the same as `onMouseUp():`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We created a reusable jQuery extension to add touch events to any element and
    added touch support to our application. We now have a drawing application that
    can be used to draw on both desktop and mobile devices.
  prefs: []
  type: TYPE_NORMAL
- en: With that our Canvas Pad application is complete, but we are not done with learning
    about the canvas. Now we'll move on to our next application, Photo Pad, where
    we will learn about some more advanced canvas features and the File API.
  prefs: []
  type: TYPE_NORMAL
- en: Photo Pad
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next application we are going to write is called Photo Pad. It will look
    a lot like Canvas Pad, and reuse the same code for the toolbar and menus. But
    instead of being a drawing application, it will be a photo manipulation application.
    The user will be able to load images and select from a few different effects,
    such as invert, black and white, or sepia, to apply to the image.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – creating Photo Pad
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start off, as usual, by copying the application template we created
    in [Chapter 1](ch01.html "Chapter 1. The Task at Hand"), *The Task at Hand*, and
    renaming the filenames to `photoPad.html`, `photoPad.css`, and `photoPad.js`.
    In the HTML file, we will add a toolbar with buttons for Load, Save, and Effects.
    You can find the code for this section in `Chapter 5/example5.2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The Load toolbar item has a drop-down menu, but instead of menu items it has
    a file input control in it where the user can select a file to load. The Effects
    item has a drop-down menu of effects. For now we just have one in there, Invert,
    but we will add more later.
  prefs: []
  type: TYPE_NORMAL
- en: For our CSS we will copy everything we had in `canvasPad.css` to `photoPad.css`,
    so that we get all of the same styling for the toolbar and menus. We will also
    use the `Toolbar` object in `toolbar.js`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our JavaScript file we will change the application object name to `PhotoPadApp`.
    We also need a couple of variables in `PhotoPadApp`. We will set the `canvas`
    variable to the `<canvas>` element, the `context` variable to the canvas''s context,
    and define an `$img` variable to hold the image we will be showing. Here we initialize
    it to a new `<img>` element using jQuery:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The first toolbar action we will implement is the **Save** button, since we
    already have that code from Canvas Pad. We check the action in `toolbarButtonClicked()`
    to see if it''s `"save"`, and if so we get the data URL and open it in a new browser
    window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We created the scaffolding for the Photo Pad application with toolbar items
    for Load, Save, and Effects. We implemented the save function the same as we did
    for Canvas Pad.
  prefs: []
  type: TYPE_NORMAL
- en: The next thing we'll implement is the Load drop-down menu since we need an image
    to manipulate. When the **Load** toolbar button is clicked, it will show the drop-down
    menu with a file input control in it that we defined previously. All of that we
    get for free because it's just another drop-down menu in our toolbar.
  prefs: []
  type: TYPE_NORMAL
- en: But before we can do that we need to learn about the HTML5 File API.
  prefs: []
  type: TYPE_NORMAL
- en: The File API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We may not be able to save files directly to the user''s filesystem, but we
    can access files using HTML5''s File API. The File API allows you to get information
    about, and load the contents of, files that the user selects. The user can select
    files using an input element with a type of `file`. The process for loading a
    file works in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: The user selects one or more files using a `<input type="file">` element.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We get the list of files from the input element's `files` property. The list
    is a `FileList` object containing File objects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can enumerate over the file list and access the files just like you would
    an array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `File` object contains three fields.
  prefs: []
  type: TYPE_NORMAL
- en: '`name`: This is the filename. It doesn''t include path information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`size`: This is the size of the file in bytes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`type`: This is the MIME type, if it can be determined.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a `FileReader` object to read the file's data. The file is loaded asynchronously.
    After the file has been read, it will call the `onload` event handler. `FileReader`
    has a number of methods for reading files that take a `File` object and return
    the file contents.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`readAsArrayBuffer()`: This method reads the file contents into an `ArrayBuffer`
    object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`readAsBinaryString()`: This method reads the file contents into a string as
    binary data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`readAsText()`: This method reads the file contents into a string as text.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`readAsDataURL()`: This method reads the file contents into a data URL string.
    You can use this as the URL for loading an image.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Time for action – loading an image file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s add some code to the `start()` method of our application to check if
    the File API is available. You can determine if a browser supports the File API
    by checking if the `File` and `FileReader` objects exist:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: First we check if the `File` and `FileReader` objects are available in the `window`
    object. If so, we hook up a change event handler for the file input control to
    call the `onLoadFile()` method passing in the `<input>` element wrapped in a jQuery
    object. If the File API is not available we will just load a default image by
    calling `loadImage()`, which we will write later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s implement the `onLoadFile()` event handler method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Here we get the file that was selected by looking at the file input's `files`
    array and taking the first one. Next we check the file type, which is a MIME type,
    to make sure it is an image. We are using the `String` object's regular expression
    `match()` method to check that it starts with `"image"`.
  prefs: []
  type: TYPE_NORMAL
- en: If it is an image, we create a new instance of the `FileReader` object. Then
    we set the `onload` event handler to call the `loadImage()` method, passing in
    the `FileReader` object's `result` field, which contains the file's contents.
    Lastly, we call the `FileReader` object's `readAsDataURL()` method, passing in
    the `File` object to start loading the file asynchronously.
  prefs: []
  type: TYPE_NORMAL
- en: If it isn't an image file, we show an alert dialog box with an error message
    and show an error message in the footer by calling `setStatus()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the file has been read, the `loadImage()` method will be called. Here
    we will use the data URL we got from the `FileReader` object''s `result` field
    to draw the image into the canvas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: First we set the `src` attribute for the image element to the data URL we got
    after the file was loaded. This will cause the image element to load that new
    image.
  prefs: []
  type: TYPE_NORMAL
- en: Next we define the `onload` event handler for the image, so that we are notified
    when the image is loaded. Note that when we are inside the `onload` event handler,
    `this` points to the `<image>` element. First we change the canvas' width and
    height to the image's width and height. Then we draw the image on the canvas using
    the context's `drawImage()` method. It takes the image to draw and the x and y
    coordinates of where to draw it. In this case we draw it at the top-left corner
    of the canvas (0, 0).
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we set an `onerror` event handler for the image. If an error occurs
    loading the image, we show an error message in the footer.
  prefs: []
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We learned how to use the File API to load an image file from the user's filesystem.
    After the image was loaded we resized the canvas to the size of the image and
    drew the image onto the canvas.
  prefs: []
  type: TYPE_NORMAL
- en: Adding effects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now let's add some effects to the effects menu. The first one we will implement
    is a color inverter. It will take the image in the canvas and invert the colors
    so the image looks like an old film negative (remember those?). We can do this
    by iterating over every pixel in the image and inverting their colors.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can get the pixels from the canvas using the context''s `getImageData()`
    method. It gets the pixels for a rectangular area of the canvas. You pass it the
    position and size of the area:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The `getImageData()` method returns an array of bytes, four for each pixel,
    that represent each pixel's color. The first byte is the red amount, second is
    the green amount, third is the blue amount, and fourth is the alpha amount. All
    values are from 0 to 255\. The total number of bytes in the array is *4 * width
    * height*.
  prefs: []
  type: TYPE_NORMAL
- en: After you get the image data, you can access and change any value in the array
    that you want. Note that this will only change the image in memory. After changing
    image data, you can write it back to the canvas using the `putImageData()` method.
    This method takes parameters for the image data to draw and the position to draw
    it at.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Time for action – the imageEffects object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will now create a new object called `imageEffects` to encapsulate all of
    the code for our image effects and put it in a new file, `imageEffects.js`. The
    `imageEffects` object will be a global static object defined using the revealing
    module pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With the revealing module pattern, you define a set of functions in a private
    scope and then return an anonymous object that reveals which of those methods
    you want to be public. This works well for defining static objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by defining the `imageEffects` object and adding two helper functions
    which will remain private. They are used to get and set the image data for the
    entire canvas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The `getImageData()` method takes a canvas and returns the image data for the
    entire canvas. The `putImageData()` method takes a canvas and image data as parameters
    and puts the image data back into the canvas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s implement our first effect; inverting the colors of an image. The `invert()`
    method takes the canvas as a parameter. Inverting colors is very simple. We just
    take each color channel for each pixel and subtract its value from the maximum
    color value of 255:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: First we get the image data for the canvas and then loop over the bytes, incrementing
    by four every time because there are four bytes for each pixel. Each color channel
    value is inverted and set back into the byte. The alpha amount is unchanged. Then
    we put the image data back onto the canvas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s finish the `imageEffects` object off. We need to return an anonymous
    object that defines all of the methods that we want to be public. The only one
    we have so far is the `invert()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we have open and close parenthesis at the end of the function declaration.
    That immediately executes the function and assigns the anonymous object returned
    to the `imageEffects` variable. So now we have an `imageEffects` object with an
    `invert()` public method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need to hook up our Effects menu items to the `imageEffects` object.
    We can do this in the `menuItemClicked()` method of `PhotoPadApp`. Previously
    we gave our menu element a `data-option` custom attribute of `"applyEffect"`.
    So we will check for that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We have given our Invert menu item element a `data-value` custom attribute set
    to `"invert"`. We will use this to dynamically access the `invert()` method in
    the `imageEffects` object, just like we did for data binding in [Chapter 3](ch03.html
    "Chapter 3. The Devil is in the Details"), *The Devil is in the Details*. We pass
    in the `canvas` object as a parameter. For `"invert"`, this is equivalent to calling
    `imageEffects.invert(canvas)`. We will implement all of our menu items in this
    way so that they automatically bind to a method in the `imageEffects` object.
  prefs: []
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We created an `imageEffects` object to hold all of our image effects algorithms.
    We implemented an effect to invert the colors of an image. We hooked up the Effects
    menu using custom data attributes to bind the menu items to methods in the `imageEffects`
    object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s open up our application in the browser and give it a try. After
    loading an image, choose **Invert** from the **Effects** menu and you should see
    the inverted image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What just happened?](img/5947OT_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Time for action – black and white
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Ok, the `invert()` method was pretty simple. Let''s try something a little
    more challenging, but not much more. We will implement an effect that changes
    a color image to black and white. Let''s implement a `toBlackAnWhite()` method
    in the `imageEffects` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: For each pixel, we compute the gray scale value by taking a percentage of each
    color channel and adding them together; 30 percent red, 59 percent green, and
    11 percent blue. Then we set each color channel to that gray scale value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s add a menu item for black and white to the Effects menu. The `data-value`
    attribute is set to the method we created previously, `toBlackAndWhite`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We created a filter to change each pixel to its gray scale value and set it
    back into the image data. Now we can convert a color image to black and white:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What just happened?](img/5947OT_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Time for action – sepia
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s implement another simple effect. This time we will convert the image
    to sepia, which gives it an old-timey picture look. Sepia is very similar to black
    and white except a little warmer. First let''s add the menu item for it and set
    the `data-value` attribute to `toSepia`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s add a `toSepia()` method to the `imageEffects` object.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Although `toSepia()` has three parameters, we will only pass in one parameter,
    the canvas, so we can use our default Effects menu handling code, and set the
    rest to default values. The first two lines of the method set default values for
    the `depth` and `intensity` parameters. `depth` is used to adjust the red and
    green channels and `intensity` is used to adjust the blue channel to give more
    fine-tuning over the final result.
  prefs: []
  type: TYPE_NORMAL
- en: To convert a pixel to its sepia tone, we first get the gray scale value the
    same way as we did for black and white. Then instead of just setting the gray
    scale for all color channels, we adjust those values based on the channel. Red
    is boosted the most, which accounts for sepia's reddish tone. Green is also boosted,
    half as much as red. Blue is reduced by the intensity amount. We use the `Math.max()`
    and `min()` function to make sure we don't set the value out of range.
  prefs: []
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We created a filter to convert color images to sepia by finding the gray scale
    and then adjusting the color channels independently by a fixed amount that can
    be passed in as parameters or defaulted:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What just happened?](img/5947OT_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Have a go hero
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Try using different percentages of red, green, and blue when computing the gray
    scale value to see what effect it has on the image. Try passing in different values
    for depth and intensity to see what effect it has on the sepia tone.
  prefs: []
  type: TYPE_NORMAL
- en: Image distortion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Next we will add a more advanced effect. We will take the image and distort
    it with waves to make it look like a reflection in the water. We can do this using
    the `Math.sin()` method to offset the pixel positions from their original positions
    in a wavy pattern. So instead of changing color channels, this time we will be
    moving pixels around.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – making waves
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s add the menu item for our wave effect. We give it a `data-value` custom
    attribute set to `makeWaves`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we will code the `makeWaves()` method. It will take four parameters; `canvas`,
    `amplitude`, `frequency`, and `phase`. `amplitude` determines how big the waves
    will be, `frequency` determines how many waves there are, and `phase` determines
    where the waves begin. Like the `toSepia()` method we will only pass in the `canvas`
    parameter, but you can try different parameters to see what effect they have:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: First thing we do is set the default values for the parameters. Then we set
    up some variables. This time we will need two sets of image data. One is our original
    image and the other, `newImageData`, is our working set that we will be changing
    and eventually write back to the canvas.
  prefs: []
  type: TYPE_NORMAL
- en: Next we adjust the frequency value so it is relative to the height of the image.
    That way if we want a frequency of four, there will be four waves from top to
    bottom of the image.
  prefs: []
  type: TYPE_NORMAL
- en: Now it's time to iterate over the pixels. In the outer loop we iterate over
    the rows of the image. For each row we calculate the x offset by computing the
    sine value for that row and multiplying it by 4, the number of color channels
    per pixel. This gives us the offset, in bytes, into the image data array. We also
    compute the y offset, which is the byte offset into the array for the current
    row.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next we iterate over each pixel in the row. Inside this loop we copy the pixel
    data from the original image data to the working image data array offsetting the
    positions. Applying the sine wave to get the pixel offsets gives us a wavy pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for action – making waves](img/5947OT_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We created a distortion effect that uses a sine wave to make an image look wavy.
    It does this by computing the offset from the original image and copying the pixels
    to the new image using the offset.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Try coming up with your own effect and adding it to the Photo Pad application.
    For example, you could darken or lighten an image. For a more advanced effect
    try to blur the image by computing the average color of a pixel and its neighboring
    pixels (if you want to see how it's done, I've implemented it in the example code
    for this section).
  prefs: []
  type: TYPE_NORMAL
- en: Pop quiz
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Q1\. How are touch events different from mouse events?
  prefs: []
  type: TYPE_NORMAL
- en: Touch events can have any number of points
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Touch events don't have any points
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Touch events don't have a `preventDefault()` method
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There is no difference
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Q2\. How many bytes per pixel are there in the canvas image data?
  prefs: []
  type: TYPE_NORMAL
- en: One
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Three
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Four
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Eight
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we continued working with the Canvas Pad application. We learned
    about drawing text on the canvas and transformations by drawing an ellipse. We
    made Canvas Pad touch enabled by adding support for touch events. Then we created
    a new application called Photo Pad where we learned about loading files from the
    user's filesystem using the HTML5 File API. We did some image processing to learn
    how to directly access and manipulate pixels on the canvas.
  prefs: []
  type: TYPE_NORMAL
- en: 'We covered the following concepts in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: How to draw text on the canvas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use the Canvas API transformations to translate, rotate, scale and so
    on, to change the way things are drawn to the canvas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create a jQuery plugin to check for touch devices and add touch events
    to elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use the File API to access files on the user's filesystem and read them
    into memory using the `FileReader` object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to load an image file and draw it into the canvas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to access the pixels of the canvas and manipulate their colors to implement
    some image processing filters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next chapter we head off in a whole new direction again. We will learn
    about the HTML5 `<audio>` element and Audio API by building a virtual piano.
  prefs: []
  type: TYPE_NORMAL
