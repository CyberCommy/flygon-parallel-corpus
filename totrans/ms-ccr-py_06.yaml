- en: Working with Processes in Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is the first of three chapters on using concurrency through multiprocessing
    programming in Python. We have seen various examples of processes being used in
    concurrent and parallel programming. In this chapter, you will be introduced to
    the formal definition of a process, as well as the `multiprocessing` module in
    Python. This chapter will go through some of the most common ways of working with
    processes using the API of the `multiprocessing` module, such as the `Process` class,
    the `Pool` class, and interprocess communication tools such as the `Queue` class.
    This chapter will also look at the key differences between multithreading and
    multiprocessing in concurrent programming.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: The concept of a process in the context of concurrent programming in computer
    science
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The basic API of the `multiprocessing` module in Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to interact with processes and the advanced functionalities that the `multiprocessing`
    module provides
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How the `multiprocessing` module supports interprocess communication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The key differences between multiprocessing and multithreading in concurrent
    programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following is a list of prerequisites for this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Install Python 3 on your computer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Download the GitHub repository at [https://github.com/PacktPublishing/Mastering-Concurrency-in-Python](https://github.com/PacktPublishing/Mastering-Concurrency-in-Python)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensure that you can access the subfolder named `Chapter06`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check out the following video to see the Code in Action: [http://bit.ly/2BtwlJw](http://bit.ly/2BtwlJw)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The concept of a process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the field of computer science, a **process of execution** is an instance
    of a specific computer program or software that is being executed by the operating
    system. A process contains both the program code and its current activities and
    interactions with other entities. Depending on the operating system, the implementation
    of a process can be made up of multiple threads of execution that can execute
    instructions concurrently or in parallel.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that a process is not equivalent to a computer program.
    While a program is simply a static collection of instructions (program code),
    a process is instead the actual execution of those instructions. This also means
    that the same program could be run concurrently by spawning multiple processes.
    These processes execute the same code from the parent program.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the internet browser Google Chrome usually manages a process called
    **Google Chrome Helper** for its main program in order to facilitate web browsing
    and other processes, to assist with various purposes. An easy way to see what
    different processes your system is running and managing involves using Task Manager
    for Windows, Activity Monitor for iOS, and System Monitor for Linux operating
    systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a screenshot of my Activity Monitor. Multiple processes with
    the name Google Chrome Helper can be seen in the list. The PID column (which stands
    for **process ID**) reports the unique ID that each process has:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/3acd51e5-d3a6-475d-bd2d-ea66d49e35d8.png)'
  prefs: []
  type: TYPE_IMG
- en: Sample list of processes
  prefs: []
  type: TYPE_NORMAL
- en: Processes versus threads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the most common mistakes that programmers make when developing concurrent
    and parallel applications is to confuse the structure and functionalities of processes
    and threads. As we have seen from [Chapter 3](eed3a259-04e1-4778-809e-570f7e0b20ce.xhtml),
    *Working with Threads in Python*, a thread is the smallest unit of programming
    code, and is typically a component of a process. Furthermore, more than one thread
    can be implemented within the same process to access and share memory or other
    resources, while different processes do not interact in this way. This relationship
    is shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/8da2ba25-b5b5-4225-beb9-e94d2eb3beec.png)'
  prefs: []
  type: TYPE_IMG
- en: Diagram of two threads executing in one process
  prefs: []
  type: TYPE_NORMAL
- en: 'Since a process is a larger programming unit than a thread, it is also more
    complicated and consists of more programming components. A process, therefore,
    also requires more resources, while a thread does not and is sometimes called
    a lightweight process. In a typical computer system process, there are a number
    of main resources, as shown in the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: An image (or copy) of the code being executed from the parent program.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory associated with an instance of a program. This might include executable
    code, input and output for that specific process, a call stack to manage program-specific
    events, or a heap that contains generated computation data and is currently being
    used by the process during runtime.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Descriptors for the resources allocated to that specific process by the operating
    system. We have seen an example of these—file descriptors—in [Chapter 4](451dc46f-ca5b-4c05-a743-04a826653e11.xhtml), *Using
    the with Statement in Threads*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security components of a specific process, namely the owner of the process and
    its permissions and allowed operations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The processor state, also known as the process context. The context data of
    a process is often located in processor registers, the memory used by the process,
    or in control registers used by the operating system to manage the process.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because each process has a state dedicated to it, processes hold more state
    information than threads; multiple threads within a process in turn share process
    states, memory, and other various resources. For similar reasons, processes only
    interact with each other through system-facilitated interprocess communication
    methods, while threads can communicate with one another easily through shared
    resources.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, context-switching—the act of saving the state data of a process
    or a thread to interrupt the execution of a task and resume it at a later time—takes
    more time between different processes than between different threads within the
    same process. However, while we have seen that communication between threads requires
    careful memory synchronization to ensure correct data handling, since there is
    less communication between separate processes, little or no memory synchronization
    is needed for processes.
  prefs: []
  type: TYPE_NORMAL
- en: Multiprocessing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A common concept in computer science is multitasking. When multitasking, an
    operating system simply switches between different processes at high speed to
    give the appearance that these processes are being executed simultaneously, even
    though it is usually the case that only one process is executing on one single
    **central processing unit** (**CPU**) at any given time. In contrast, multiprocessing
    is the method of using more than one CPU to execute a task.
  prefs: []
  type: TYPE_NORMAL
- en: While there are a number of different uses of the term multiprocessing, in the
    context of concurrency and parallelism multiprocessing refers to the execution
    of multiple concurrent processes in an operating system, in which each process
    is executed on a separate CPU, as opposed to a single process being executed at
    any given time. By the nature of processes, an operating system needs to have
    two or more CPUs in order to be able to implement multiprocessing tasks, as it
    needs to support many processors at the same time and allocate tasks between them
    appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: 'This relationship is shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/269f5c8c-8758-47e1-86b2-b9838cf3a8b5.png)'
  prefs: []
  type: TYPE_IMG
- en: Example diagram of multiprocessing using two CPU cores
  prefs: []
  type: TYPE_NORMAL
- en: We have seen in [Chapter 3](b2db614b-1859-4a86-91d8-f9383c12f4e9.xhtml), *Working
    with Threads in Python*, that multithreading shares a somewhat similar definition
    to multiprocessing. Multithreading means that only one processor is utilized,
    and the system switches between tasks within that processor (also known as **time
    slicing**), while multiprocessing generally denotes the actual concurrent/parallel
    execution of multiple processes using multiple processors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Multiprocessing applications have enjoyed significant popularity in the field
    of concurrent and parallel programming. Some reasons for this are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Faster execution time**: As we know, when done correctly concurrency always
    provides additional speedups for your programs, provided that some parts of them
    can be executed independently.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Synchronization free**: Given the fact that separate processes do not share
    resources among themselves in a multiprocessing application, developers rarely
    need to spend their time coordinating the sharing and synchronization of these
    resources, unlike multithreaded applications, where efforts need to be made to
    make sure that data is being manipulated correctly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Safety from crashes**: As processes are independent from each other in terms
    of both computing procedures and input/output, the failure of one process will
    not affect the execution of another in a multiprocessing program, if handled correctly.
    This implies that programmers could afford to spawn a larger number of processes
    (that their system can still handle) and the chance of crashing the entire application
    would not increase.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With that being said, there are also noteworthy disadvantages to using multiprocessing
    that we should consider, as shown in the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Multiple processors are needed**: Again, multiprocessing requires the operating
    system to have more than one CPU. Even though multiple processors are fairly common
    for computer systems nowadays, if yours does not have more than one, then the
    implementation of multiprocessing will not be possible.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Processing time and space**: As mentioned before, there are many complex
    components involved in implementing a process and its resources. It therefore
    takes significant computing time and power to spawn and manage processes in comparison
    to doing the same with threads.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introductory example in Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To illustrate the concept of running multiple processes on one operating system,
    let''s look at a quick example in Python. Let''s take a look at the `Chapter06/example1.py` file,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In this file, we are going back to the counting-down example that we saw in [Chapter
    3](b2db614b-1859-4a86-91d8-f9383c12f4e9.xhtml), *Working with Threads in Python*,
    while we look at the concept of a thread. Our `count_down()` function takes in
    a string as a process identifier and a delay time range. It will then count down
    from 5 to 1 while sleeping between iterations for a number of seconds specified
    by the `delay` parameter. The function also prints out a message with the process
    identifier at each iteration.
  prefs: []
  type: TYPE_NORMAL
- en: As we saw in [Chapter 3](b2db614b-1859-4a86-91d8-f9383c12f4e9.xhtml), *Working
    with Threads in Python*, the point of this counting-down example is to show the
    concurrent nature of running separate tasks at the same time, this time through
    different processes by using the `Process` class from the `multiprocessing` module.
    In our main program, we initialize two processes at the same time to implement
    two separate time-based countdowns simultaneously. Similar to how two separate
    threads would do this, our two processes will carry out their own countdowns concurrently.
  prefs: []
  type: TYPE_NORMAL
- en: 'After running the Python script, your output should be similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Just as we expected, the output tells us that the two countdowns from the separate
    processes were executed concurrently; instead of finishing the first process'
    countdown and then starting the second's, the program ran the two countdowns at
    almost the same time. Even though processes are more expensive and contain more
    overhead than threads, multiprocessing also allows double the improvement in terms
    of speed for programs such as the preceding one.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that in multithreading we saw a phenomenon in which the order of the
    printed output changed between different runs of the program. Specifically, sometimes
    process B would get ahead of process A during the countdown and finish before
    process A, even though it was initialized later. This is, again, a direct result
    of implementing and starting two processes that execute the same function at almost
    the same time. By executing the script many times, you will see that it is quite
    likely for you to obtain changing output in terms of the order of the counting
    and the completion of the countdowns.
  prefs: []
  type: TYPE_NORMAL
- en: An overview of the multiprocessing module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `multiprocessing` module is one of the most commonly used implementations
    of multiprocessing programming in Python. It offers methods to spawn and interact
    with processes using an API similar to the `threading` module (as we saw with
    the `start()` and `join()` methods in the preceding example). According to its
    documentation website, the module allows both local and remote concurrency and
    effectively avoids the **global interpreter lock** (**GIL**) in Python (which
    we will discuss in more detail later in [Chapter 15](0e30892f-4bb1-4196-93c5-5df1d57428b8.xhtml),
    *The Global Interpreter Lock*) by using subprocesses instead of threads.
  prefs: []
  type: TYPE_NORMAL
- en: The process class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the `multiprocessing` module, processes are typically spawned and managed
    through the `Process` class. Each `Process` object represents an activity that
    executes in a separate process. Conveniently, the `Process` class has equivalent
    methods and APIs that can be found in the `threading.Thread` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, utilizing an object-oriented programming approach, the `Process`
    class from `multiprocessing` provides the following resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '`run()`: This method is executed when a new process is initialized and started'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`start()`: This method starts the initialized calling `Process` object by calling
    the `run()` method'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`join()`: This method waits for the calling `Process` object to terminate before
    continuing with the execution of the rest of the program'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isAlive()`: This method returns a Boolean value indicating whether the calling `Process`
    object is currently executing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`name`: This attribute contains the name of the calling `Process` object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pid`: This attribute contains the process ID of the calling `Process` object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`terminate()`: This method terminates the calling `Process` object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see from our previous example, while initializing a `Process` object,
    we can pass parameters to a function and execute it in a separate process by specifying
    the `target` (for the target function) and `args` (for target function arguments)
    parameters. Note that one could also override the default `Process()` constructor
    and implement one's own `run()` function.
  prefs: []
  type: TYPE_NORMAL
- en: As it is a major player in the `multiprocessing` module and in concurrency in
    Python in general, we will look at the `Process` class again in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: The Pool class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the `multiprocessing` module, the `Pool` class is mainly used to implement
    a pool of processes, each of which will carry out tasks submitted to a `Pool`
    object. Generally, the `Pool` class is more convenient than the `Process` class,
    especially if the results returned from your concurrent application should be
    ordered.
  prefs: []
  type: TYPE_NORMAL
- en: Specifically, we have seen that the order of completion for different items
    in a list is considerably likely to change when put through a function concurrently as
    the program runs over and over again. This leads to difficulty when reordering
    the outputs of the program with respect to the order of the inputs that produced
    them. One possible solution to this is to create tuples of processes and their
    outputs, and to sort them by process ID.
  prefs: []
  type: TYPE_NORMAL
- en: 'This problem is addressed by the `Pool` class: the `Pool.map()` and `Pool.apply()`
    methods follow the convention of Python''s traditional `map()` and `apply()` methods,
    ensuring that the returned values are ordered in the same way that the input is.
    These methods, however, block the main program until a process has finished processing.
    The `Pool` class, therefore, also has the `map_async()` and `apply_async()` functions
    to better assist concurrency and parallelism.'
  prefs: []
  type: TYPE_NORMAL
- en: Determining the current process, waiting, and terminating processes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Process` class provides a number of ways to easily interact with processes
    in a concurrent program. In this section, we will explore the options of managing
    different processes by determining the current process, waiting, and terminating
    processes.
  prefs: []
  type: TYPE_NORMAL
- en: Determining the current process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Working with processes is at times considerably difficult, and significant debugging
    is therefore required. One of the methods of debugging a multiprocessing program
    is to identify the processes that encounter errors. As a refresher, in the previous
    countdown example we passed a `name` parameter to the `count_down()` function
    to determine where each process is during the countdown.
  prefs: []
  type: TYPE_NORMAL
- en: This is, however, unnecessary as each `Process` object has a `name` parameter
    (with a default value) that can be changed. Naming processes is a better way to
    keep track of running processes than passing an identifier to the target function
    itself (as we did earlier), especially in applications with different types of
    processes running at the same time. One powerful functionality that the `multiprocessing`
    module provides is the `current_process()` method, which will return the `Process`
    object that is currently running at any point of a program. This is another way
    to keep track of running processes effectively and effortlessly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at this in more detail using an example. Navigate to the `Chapter06/example2.py`
    file, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we have two dummy functions, `f1()` and `f2()`, each of which
    prints out the name of the process that executes the function before and after
    sleeping for a specified period of time. In our main program, we initialize three
    separate processes. The first two we name `Worker 1` and `Worker 2` respectively,
    and the last we purposefully leave blank to give it the default value of its name
    (that is, `''Process-3''`). After running the script, you should have an output
    similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that the `current_process()` successfully helped us access the correct
    process that ran each function, and the third process was assigned the name `Process-3`
    by default. Another way to keep track of the running processes in your program
    is to look at the individual process IDs using the `os` module. Let''s take a
    look at a modified example in the `Chapter06/example3.py` file, as shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Our main focus for this example is the `print_info()` function, which uses
    the `os.getpid()` and `os.getppid()` functions to identify the current process
    using its process ID. Specifically, `os.getpid()` returns the process ID of the
    current process, and `os.getppid()` (which is only available on Unix systems)
    returns the ID of the parent process. The following is my input after running
    the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The process IDs might vary from system to system, but their relative relationship
    should be the same. Specifically for my output, we can see that, while the ID
    for the main Python program was `29010`, the ID of its parent process was `14806`.
    Using **Activity Monitor**, I crosschecked this ID and connected it to my Terminal
    and Bash profile, which makes sense since I ran this Python script from my Terminal.
    You can see the displayed results from Activity Monitor in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/392bb757-d08e-43ad-9287-211bd4750295.png)'
  prefs: []
  type: TYPE_IMG
- en: Screenshot of Activity Monitor being used to crosscheck PIDs
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the main Python program, we also called `print_info()` inside
    the `f()` function, whose process ID was `29012`. We can also see that the parent
    process of the process running the `f()` function is actually our main process,
    whose ID was `29010`.
  prefs: []
  type: TYPE_NORMAL
- en: Waiting for processes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Oftentimes, we'd like to wait for all of our concurrent processes to finish
    executing before moving to a new section of the program. As mentioned before,
    the `Process` class from the `multiprocessing` module provides the `join()` method
    in order to implement a way to wait until a process has completed its task and
    exits.
  prefs: []
  type: TYPE_NORMAL
- en: However, sometimes developers want to implement processes that run in the background
    and do not block the main program from exiting. This specification is commonly
    used when there is no easy way for the main program to tell whether it is appropriate
    to interrupt the process at any given time, or when exiting the main program without
    completing the worker does not affect the end result.
  prefs: []
  type: TYPE_NORMAL
- en: 'These processes are called **daemon processes**. The `Process` class also provides
    an easy option to specify whether a process is a daemon through the `daemon` attribute,
    which takes a Boolean value. The default value for the `daemon` attribute is `False`,
    so setting it to `True` will turn a given process into a daemon. Let''s look at
    this in more detail using an example in the `Chapter06/example4.py` file, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we have a long-running function (represented by `f1()`, which
    has a sleep period of `4` seconds) and a faster function (represented by `f2()`, which
    has a sleep period of only `2` seconds). We also have two separate processes,
    as shown in the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: The `p1 `process, which is a daemon process assigned to run `f1()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `p2 `process, which is a regular process assigned to run `f2()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In our main program, we start both processes without calling the `join()` method
    on either of them at the end of the program. Since `p1` is a long-running process,
    it will most likely not finish executing before `p2 `(which is the faster process
    of the two) finishes. We also know that `p1` is a daemon process, so our program
    should exit before it finishes executing. After running the Python script, your
    output should be similar to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, even though the process IDs might be different when you yourself run
    the script, the general format of the output should be the same. As we can see,
    the output is consistent with what we discussed: both `p1` and `p2` processes were
    initialized and started by our main program, and the program terminated after
    the nondaemon process exited without waiting for the daemon process to finish.'
  prefs: []
  type: TYPE_NORMAL
- en: The ability to terminate the main program without having to wait for specific
    tasks that the daemon is processing is indeed extremely useful. However, sometimes
    we might want to wait for daemon processes for a specified amount of time before
    exiting; this way, if the specifications of the program allow some waiting time
    for the process' execution, we could complete some potential daemon processes
    instead of terminating all of them prematurely.
  prefs: []
  type: TYPE_NORMAL
- en: 'The combination of daemon processes and the `join()` method from the `multiprocessing`
    module can help us implement this architecture, especially given that, while the
    `join()` method blocks the program execution indefinitely (or at least until the
    task finishes), it is also possible to pass a timeout argument to specify the
    number of seconds to wait for the process before exiting. Let''s consider a modified
    version of the previous example in `Chapter06/example5.py`. With the same `f1()`
    and `f2()` functions, in the following script, we are changing the way we handle
    the daemon process in the main program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of terminating without waiting for the daemon process, in this example,
    we are calling the `join()` method on both processes: we allow one second for `p1` to
    finish while we block the main program until `p2` finishes. If `p1` has not finished
    executing after that one second, the main program simply continues executing the
    rest of the program and exits, at which time we will see that `p1`—or `Worker
    1`—is still alive. After running the Python script, your output should be similar
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We see that `p1` was indeed still alive by the time the program moved on after
    waiting for it for one second.
  prefs: []
  type: TYPE_NORMAL
- en: Terminating processes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `terminate()` method from the `multiprocessing.Process` class offers a way
    to quickly terminate a process. When the method is called, exit handlers, finally
    causes, or similar resources that are specified in the `Process` class or an overridden
    class will not be executed. However, descendant processes of the terminated process
    will not be terminated. These processes are known as **orphaned processes**.
  prefs: []
  type: TYPE_NORMAL
- en: Although terminating processes is sometimes frowned upon, it is sometimes necessary
    because some processes interact with interprocess-communication resources, such
    as locks, semaphores, pipes, or queues, and forcibly stopping those processes
    is likely to cause those resources to become corrupted or unavailable to other
    processes. If, however, the processes in your program never interact with the
    aforementioned resources, the `terminate()` method is considerably useful, especially
    if a process appears to be unresponsive or deadlocked.
  prefs: []
  type: TYPE_NORMAL
- en: One thing to note when using the `terminate()` method is that, even though the
    `Process` object is effectively killed after calling the method, it is important
    that you call `join()` on the object as well. Since the `alive` status of `Process`
    objects is sometimes not immediately updated after the `terminate()` method, this
    practice gives the background system an opportunity to implement the update itself
    to reflect the termination of the processes.
  prefs: []
  type: TYPE_NORMAL
- en: Interprocess communication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While locks are one of the most common synchronization primitives that are used
    for communication among threads, pipes and queues are the main way of communicating
    between different processes. Specifically, they provide message-passing options
    to facilitate communication between processes—pipes for connections between two
    processes and queues for multiple producers and consumers.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will be exploring the usage of queues, specifically the
    `Queue` class from the `multiprocessing` module. The implementation of the `Queue`
    class is, in fact, both thread-and process-safe, and we have already seen the
    use of queues in [Chapter 3](b2db614b-1859-4a86-91d8-f9383c12f4e9.xhtml), *Working
    with Threads in Python*. All pickleable objects in Python can be passed through
    a `Queue` object; in this section, we will be using queues to pass messages back
    and forth between processes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using a message queue for interprocess communication is preferred over having
    shared resources since, if certain processes mishandle and corrupt shared memory
    and resources while those resources are being shared, then there will be numerous
    undesirable and unpredictable consequences. If, however, a process failed to handle
    its message correctly, other items in the queue will remain intact. The following
    diagram represents the differences in architecture between using a message queue
    and shared resources (specifically memory) for interprocess communication:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/3b772c12-bf68-40c0-8b74-7c116d85794a.png)'
  prefs: []
  type: TYPE_IMG
- en: The architecture involved in using a message queue and shared resources for
    interprocess communication
  prefs: []
  type: TYPE_NORMAL
- en: Message passing for a single worker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we dive into the example code in Python, first we need to discuss specifically
    how we use a `Queue` object in our multiprocessing application. Let's say that
    we have a `worker` class that performs heavy computations and does not require
    significant resource sharing and communication. Yet these worker instances still
    need to be able to receive information from time to time during their execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is where the use of a queue comes in: when we put all the workers in a
    queue. At the same time, we will also have a number of initialized processes,
    each of which will go through that queue and process one worker. If a process
    has finished executing a worker and there are still other workers in the queue,
    it will move on to another worker and execute it. Looking back at the earlier
    diagram, we can see that there are two separate processes that keep picking up
    and executing messages from a queue.'
  prefs: []
  type: TYPE_NORMAL
- en: 'From a `Queue` object, we will be using two main methods, as shown in the following
    list:'
  prefs: []
  type: TYPE_NORMAL
- en: '`get()`: This method returns the next item in the calling `Queue` object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`put()`: This method adds the parameter passed to it as an additional item
    to the calling `Queue` object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s look at an example script showing the use of a queue in Python. Navigate
    to and open the `Chapter06/example6.py` file, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In this script, we have a `MyWorker` class that takes in a number `x` parameter and
    performs a computation from it (for now, it will only print out the number). In
    our main function, we initialize a `Queue` object from the `multiprocessing` module
    and add a `MyWorker` object with the number `10` in it. We also have the `work()` function,
    which upon being called will get the first item from the queue and process it.
    Finally, we have a process whose task is to call the `work()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The structure is designed to pass a message—in this case, a `MyWorker` object—to
    one single process. The main program then waits for the process to finish executing.
    After running the script, your output should be similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Message passing between several workers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As mentioned earlier, our goal is to have a structure where there are several
    processes constantly executing workers from a queue, and if a process finishes
    executing one worker, then it will pick up another. To do this, we will be utilizing
    a subclass of `Queue` called `JoinableQueue`, which will provide the additional
    `task_done()` and `join()` methods, as described in the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: '`task_done()`: This method tells the program that the calling `JoinableQueue`
    object is complete'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`join()`: This method blocks until all items in the calling `JoinableQueue`
    object have been processed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now the goal here, again, is to have a `JoinableQueue` object holding all the
    tasks that are to be executed—we will call this the task queue—and a number of
    processes. As long as there are items (messages) in the task queue, the processes
    will take their turn to execute those items. We will also have a `Queue` object
    to store all the results returned from the processes—we will call this the result
    queue.
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to the `Chapter06/example7.py` file and take a look at the `Consumer`
    class and the `Task` class, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `Consumer` class, which is an overridden subclass of the `multiprocessing.Process`
    class, is our processor logic, which takes in a task queue and a result queue.
    When started, each `Consumer` object will get the next item in its task queue,
    execute it, and finally call `task_done()` and put the returned result to its
    result queue. Each item in the task queue is in turn represented by the `Task`
    class, whose main functionality is to prime-check its `x `parameter. As one instance
    of the `Consumer` class interacts with one instance of the `Task` class, it will
    also print out a help message for us to easily keep track of which consumer is
    executing which task.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s move on and consider our main program, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As we said earlier, we create a task queue and a result queue in our main program.
    We also create a list of `Consumer` objects and start all of them; the number
    of processes created corresponds to the number of CPUs available in our system.
    Next, from a list of inputs that requires heavy computation from the `Task` class,
    we initialize a `Task` object with each input and put them all in the task queue.
    At this point our processes—our `Consumer` objects—will start executing these
    tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, at the end of our main program, we call `join()` on our task queue
    to ensure that all items have been executed and print out the result by looping
    through our result queue. After running the script, your output should be similar
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Everything seems to be working, but if we look closely at the messages our processes
    have printed out, we will notice that most of the tasks were executed by either
    `Consumer-2` or `Consumer-3`, and that `Consumer-4` executed only one task while
    `Consumer-1` failed to execute any. What happened here?
  prefs: []
  type: TYPE_NORMAL
- en: Essentially, when one of our consumers—let's say `Consumer-3`—finished executing
    a task, it tried to look for another task to execute immediately after. Most of
    the time, it would get priority over other consumers, since it was already being
    run by the main program. So while `Consumer-2` and `Consumer-3` were constantly
    finishing their tasks' executions and picking up other tasks to execute, `Consumer-4`
    was only able to "squeeze" itself in once, and `Consumer-1` failed to do this
    altogether.
  prefs: []
  type: TYPE_NORMAL
- en: 'When running the script over and over again, you will notice a similar trend:
    only one or two consumers executed most of the tasks, while others failed to do
    this. This situation is undesirable for us, since the program is not utilizing
    all of the available processes that were created at the beginning of the program.'
  prefs: []
  type: TYPE_NORMAL
- en: To address this issue, a technique has been developed, to stop consumers from
    immediately taking the next item from the task queue, called **poison pill**.
    The idea is that, after setting up the real tasks in the task queue, we also add
    in dummy tasks that contain "stop" values and that will have the current consumer
    hold and allow other consumers to get the next item in the task queue first; hence
    the name "poison pill."
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement this technique, we need to add in our `tasks` value in the main
    program''s special objects, one per consumer. Additionally, in our `Consumer`
    class, the implementation of the logic to handle these special objects is also
    required. Let''s take a look at the `example8.py` file (a modified version of
    the previous example, containing the implementation of the poison pill technique),
    specifically in the `Consumer` class and the main program, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Task` class remains the same as our previous example. We can see that
    our poison pill is the `None` value: in the main program, we add in `None` values
    of a number equal to the number of consumers we have spawned to the task queue;
    in the `Consumer` class, if the current task to be executed holds the value `None`,
    then the class object will print out a message indicating the poison pill, call
    `task_done()`, and exit.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the script; your output should be similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This time, as well as seeing the poison pill messages being printed out, the
    output also shows a significantly better distribution in terms of which consumer
    executed which task.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the field of computer science, a process is an instance of a specific computer
    program or software that is being executed by the operating system. A process
    contains both the program code and its current activities and interactions with
    other entities. More than one thread can be implemented within the same process
    to access and share memory or other resources, while different processes do not
    interact in this way.
  prefs: []
  type: TYPE_NORMAL
- en: In the context of concurrency and parallelism, multiprocessing refers to the
    execution of multiple concurrent processes from an operating system, in which
    each process is executed on a separate CPU, as opposed to a single process being
    executed at any given time. The `multiprocessing` module in Python provides a
    powerful and flexible API to spawn and manage processes for a multiprocessing
    application. It also allows complex techniques for interprocess communication
    via the `Queue` class.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be discussing a more advanced function of Python—reduction
    operations—and how it is supported in multiprocessing programming.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is a process? What are the core differences between a process and a thread?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is multiprocessing? What are the core differences between multiprocessing
    and multithreading?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are the API options provided by the `multiprocessing` module?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are the core differences between the `Process` class and the `Pool` class
    from the `multiprocessing` module?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are the options to determine the current process in a Python program?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are daemon processes? What are their purposes in terms of waiting for processes
    in a multiprocessing program?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do you terminate a process? Why is it sometimes acceptable to terminate
    processes?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is one of the ways to facilitate interprocess communication in Python?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For more information, you can refer to the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Python Parallel Programming Cookbook*, by Giancarlo Zaccone, Packt Publishing
    Ltd (2015).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '"Learning Concurrency in Python: Build highly efficient, robust, and concurrent
    applications", Elliot Forbes (2017).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python Module of The Week. "Communication Between Processes" ([pymotw.com/2/multiprocessing/communication.html](https://pymotw.com/2/multiprocessing/communication.html)).
    This contains functions that you can use to identify the current process.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
