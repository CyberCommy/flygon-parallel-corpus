- en: '*Chapter 12*: The Stack, the Heap, and the Garbage Collector'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By the end of this chapter, the missing link between Java and our XML layouts
    will be fully revealed, leaving us with the power to add all kinds of widgets
    to our apps as we have done before, but this time, we will be able to control
    them through our Java code.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will get to take control of some simple UI elements such
    as `Button` and `TextView` and in the next chapter, we will take things further
    and manipulate a whole range of UI elements.
  prefs: []
  type: TYPE_NORMAL
- en: To enable us to understand what is happening, we need to find out a bit more
    about the memory in an Android device and two areas of it – the **Stack** and
    the **Heap**.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn about the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Android UI elements are classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Garbage collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our UI is on the heap?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Special types of classes, including inner and anonymous
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Back to that news flash.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find the code files present in this chapter on GitHub at [https://github.com/PacktPublishing/Android-Programming-for-Beginners-Third-Edition/tree/main/chapter%2012](https://github.com/PacktPublishing/Android-Programming-for-Beginners-Third-Edition/tree/main/chapter%2012).
  prefs: []
  type: TYPE_NORMAL
- en: All the Android UI elements are classes too
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When our app is run and the `setContentView` method is called from the `onCreate`
    method, the layout is `inflated` from the XML and instances of the UI classes
    are loaded into memory as usable objects. They are stored in a part of the memory
    called the heap. The heap is managed by the **Android Runtime** (**ART**) system.
  prefs: []
  type: TYPE_NORMAL
- en: Re-introducing references
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: But where are all these UI objects/classes? We certainly can't see them in our
    code. And how on earth do we get our hands on them?
  prefs: []
  type: TYPE_NORMAL
- en: The ART inside every Android device takes care of memory allocation to our apps.
    In addition, it stores different types of variables in different places.
  prefs: []
  type: TYPE_NORMAL
- en: Variables that we declare and initialize in methods are stored on the area of
    memory known as the **Stack**. We can stick to our existing warehouse analogy
    when talking about the Stack. We already know how we can manipulate variables
    on the Stack with straightforward expressions. So, let's talk about the heap and
    what is stored there.
  prefs: []
  type: TYPE_NORMAL
- en: Important fact
  prefs: []
  type: TYPE_NORMAL
- en: All objects of classes are reference type variables and are just references
    to the actual objects that are stored on the heap – they are not the actual objects.
  prefs: []
  type: TYPE_NORMAL
- en: Think of the heap as a separate area of the same warehouse. The heap has lots
    of floor space for odd-shaped objects, racks for smaller objects, lots of long
    rows with smaller-sized cubby holes, and so on. This is where objects are stored.
    The problem is we have no direct access to the heap. Think of it as a restricted
    access part of the warehouse. You can't actually go there but you can *refer*
    to what is stored there. Let's look at what exactly a reference variable is.
  prefs: []
  type: TYPE_NORMAL
- en: It is a variable that we refer to and use via a reference. A reference can be
    loosely but usefully defined as an address or location. The reference (address
    or location) of the object is on the Stack.
  prefs: []
  type: TYPE_NORMAL
- en: So, when we use the dot operator, we are asking Android to perform a task *at*
    a specific location, a location that is stored in the reference.
  prefs: []
  type: TYPE_NORMAL
- en: Why would we ever want a system like this? Just give me my objects on the Stack
    already. Here is why.
  prefs: []
  type: TYPE_NORMAL
- en: A quick break to throw out the trash
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is what the whole stack and heap thing does for us.
  prefs: []
  type: TYPE_NORMAL
- en: As we know, the ART system keeps track of all our objects for us and stores
    them in a devoted area of our warehouse called the heap. Regularly, while our
    app is running, ART will scan the stack, the regular racks of our warehouse, and
    match up references to objects that are on the heap. And any objects it finds
    without a matching reference, it destroys. Or in Java terminology, it **garbage
    collects**.
  prefs: []
  type: TYPE_NORMAL
- en: Think of a very discerning refuse vehicle driving through the middle of our
    heap, scanning objects to match up to references (on the stack). No reference?
    You're garbage now.
  prefs: []
  type: TYPE_NORMAL
- en: If an object has no reference variable, we can't possibly do anything with it
    anyway because we have no way to access it/refer to it. This system of garbage
    collection helps our apps run more efficiently by freeing up unused memory.
  prefs: []
  type: TYPE_NORMAL
- en: If this task was left to us, our apps would be much more complicated to code.
  prefs: []
  type: TYPE_NORMAL
- en: So, variables declared in a method are local, on the stack, and only visible
    within the method they were declared in. A member variable (in an object) is on
    the heap and can be referenced from anywhere there is a reference to it and the
    access specification (encapsulation) allows.
  prefs: []
  type: TYPE_NORMAL
- en: Seven facts about the stack and the heap
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s take a quick look at what we learned about the stack and the heap:'
  prefs: []
  type: TYPE_NORMAL
- en: Local variables and methods are on the stack and local variables are local to
    the specific method within which they were declared.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Instance/class variables are on the heap (with their objects) but the reference
    *to* the object (its address), is a local variable on the stack.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We control what goes on the stack. We can use the objects on the heap but only
    by referencing them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The heap is kept clear and up to date by the garbage collector.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You don't delete objects but the ART system sends the garbage collector when
    it thinks it is appropriate. An object is garbage collected when there is no longer
    a valid reference to it. So, when a reference variable, either local or instance,
    is removed from the stack, then its related object becomes viable for garbage
    collection. And when the ART system decides the time is right (usually very promptly),
    it will free up the RAM memory to avoid running out.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If we try to reference an object that doesn't exist, we will get a **NullPointerException**
    and the app will crash.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's move on and see exactly what this information buys us in terms of taking
    control of our UI.
  prefs: []
  type: TYPE_NORMAL
- en: So how does this heap thing help me?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Any UI element that has its `id` attribute set in the XML layout can have its
    reference retrieved from the heap using the `findViewById` method, which is part
    of the Activity/ `AppCompatActivity` class. As it is part of the class that we
    extend in all our apps, we have access to it, as this code shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code assumes that within the XML layout there is a `Button` widget
    with its `id` attribute set to `myButton`. The `myButton` object now directly
    refers to the widget in the XML layout with the `id` attribute set to `myButton`.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the `findViewById` method is also polymorphic and any class that extends
    the `View` class can be retrieved from the UI and it just so happened that *everything*
    in the UI palette extends `View`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The sharp-minded reader might notice that we don''t use a cast to make sure
    we are getting a `Button` object (as opposed to a `TextView` or some other `View`
    descendant) as we did when retrieving an `Elephant` instance descended from an
    abstract `Animal`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The reason for this is that the `View` class uses Java''s **generics automatic
    type inference**. This is an advanced topic that we won''t be covering in this
    book, but it means that the cast is automatic, and we don''t need to write more
    lengthy code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This ability to grab a reference to anything in the UI is exciting because
    it means we can start using all the methods that these objects have. Here are
    some examples of the methods we can use for `Button` objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The `Button` class alone has around 50 methods!
  prefs: []
  type: TYPE_NORMAL
- en: If you think, after 11 chapters, we are finally going to start doing some neat
    stuff with Android, you are right!
  prefs: []
  type: TYPE_NORMAL
- en: Using buttons and TextView widgets from our layout
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To follow along with this project, create a new Android Studio project, call
    it `Java Meet UI`, choose the Empty Activity template, and leave all the other
    options at their defaults. As usual, you can find the Java code and the XML layout
    code in the [*Chapter 12*](B16773_12_ePub_RK.xhtml#_idTextAnchor218)`/Java Meet
    UI` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s build a simple UI by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the editor window of Android Studio, switch to `activity_main.xml` and make
    sure you are on the **Design** tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete the autogenerated **TextView**, the one that reads "Hello world!".
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a **TextView** widget at the top center of the layout.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its `0`, its `40sp`. Pay careful attention to the case of the `id` property's
    value. It has an uppercase `V`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now drag and drop six buttons on the layout so it looks as close as possible
    to this next screenshot. The exact layout isn't important:![Figure 12.1 – Layout
    setup
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_12.1_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.1 – Layout setup
  prefs: []
  type: TYPE_NORMAL
- en: When the layout is how you want it, click the **Infer Constraints** button to
    constrain all the UI items.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Edit the properties of each button in turn (left to right, then top to bottom)
    and set the `text` and `id` properties as shown in the next table. The image that
    follows the table should make it clear which button has which values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'When you''re done, your layout should look like the next screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.2 – Final layout'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.2_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.2 – Final layout
  prefs: []
  type: TYPE_NORMAL
- en: The precise position and text on the buttons are not very important but the
    values given to the `id` properties must be the same as those in the table. The
    reason for this is we will be using these IDs to get a reference to the buttons
    and the `TextView` in this layout, from our Java code.
  prefs: []
  type: TYPE_NORMAL
- en: Switch to the **MainActivity.java** tab in the editor and we will write the
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Amend this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: You will need to import the `View` class. Be sure to do this before continuing
    with the next step or you will get confusing results.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the entire line we just amended is underlined in red showing an
    error. Now, because we have made `MainActivity` into an `OnClickListener` by adding
    it as an interface, we must implement the abstract method required by `OnClickListener`.
    The method is called `onClick`. When we add the `onClick` method, the error will
    be gone.
  prefs: []
  type: TYPE_NORMAL
- en: We can get Android Studio to add it for us by left-clicking anywhere on the
    line with an error and then using the keyboard combination *Alt* + *Enter*. Left-click
    the **Implement methods** option as shown in the next screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.3 – Implement methods'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.3_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.3 – Implement methods
  prefs: []
  type: TYPE_NORMAL
- en: Now, left-click `onClick` method. The error is gone, and we can carry on adding
    code. We also have an empty `onClick` method and we will soon see what we will
    do with that.
  prefs: []
  type: TYPE_NORMAL
- en: Now we will declare an `int` type variable called `value` and initialize it
    to `0`. We will also declare six `Button` objects and a `TextView` object. We
    will give them the exact same Java variable names we gave the `id` property values
    in our UI layout. This name association is not needed but it is useful to keep
    track of which `Button` in our Java code will be holding a reference to which
    `Button` from our XML UI layout.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, we are declaring them all with the `private` access specification
    because we know they will not be needed outside of this class.
  prefs: []
  type: TYPE_NORMAL
- en: Before you go ahead and type the code, note that all these variables are members
    of the `MainActivity` class. This means we enter all the code shown next, immediately
    after the class declaration (which we amended in the previous step).
  prefs: []
  type: TYPE_NORMAL
- en: Making all these variables into members/fields means they have a class scope
    and we can access them from anywhere within the `MainActivity` class. This will
    be essential for this project because we will need to use them in the `onCreate`
    method and in our new `onClick` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter this next code that we have just discussed, after the opening curly brace
    `{` of the `MainActivity` class and before the `onCreate` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Remember to use the *ALT* + *Enter* keyboard combination to import new classes.
  prefs: []
  type: TYPE_NORMAL
- en: '`import android.widget.Button;`'
  prefs: []
  type: TYPE_NORMAL
- en: '`import android.widget.TextView;`'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we want to prepare all our variables ready for action. The best place
    for this to happen is in the `onCreate` method because we know that will be called
    by Android just before the app is shown to the user. This code uses the `findViewById`
    method to associate each of our Java objects with an item from our UI layout.
  prefs: []
  type: TYPE_NORMAL
- en: It does so by returning a reference to the object associated with the UI widget
    on the heap. It "knows" which one we are after because we use the `id` attribute
    value as an argument. For example, `...(R.id.btnAdd)` will return the `Button`
    widget with the text **ADD** that we created in our layout.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the following code, just after the call to `setContentView` in the `onCreate`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now we have a reference to all our `Button` widgets and our `TextView` widget
    so now we can start using their methods. In the code that follows, we use the
    `setOnClickListener` method on each of the `Button` references to make Android
    pass any clicks from the user onto our `onClick` method.
  prefs: []
  type: TYPE_NORMAL
- en: This works because when we implemented the `View.OnClickListener` interface,
    our `MainActivity` class effectively *became* an `OnClickListener`.
  prefs: []
  type: TYPE_NORMAL
- en: So, all we have to do is call `setOnClickListener` on each button in turn. As
    a reminder, the `this` argument is a reference to `MainActivity`. So, the method
    call says, "Hey Android, I want an `OnClickListener` and I want it to be the `MainActivity`
    class."
  prefs: []
  type: TYPE_NORMAL
- en: Android now knows which class to call `onClick` on. This next code wouldn't
    work if we hadn't implemented the interface first. Also, we must set up these
    listeners before the Activity starts, which is why we do it in `onCreate.`
  prefs: []
  type: TYPE_NORMAL
- en: Soon, we will add code to the `onClick` method to handle what happens when a
    button is clicked and we will see how we differentiate between all the different
    buttons.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this code after the previous code, inside the `onCreate` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now scroll down to the `onClick` method that Android Studio added for us after
    we implemented the `OnClickListener` interface. Add the `float size;` variable
    declaration and an empty `switch` block inside it so it looks like this next code.
    The new code to add is highlighted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Remember that `switch` will check for a `case` to match the condition inside
    the `switch` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous code, the `switch` condition is `view.getId()`. Let''s step
    through and explain this. The `view` variable is a reference to an object of type
    `View`, which was passed into the `onClick` method by Android:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '`View` is the parent class for `Button`, `TextView`, and more. So, perhaps
    as we might expect, calling `view.getId()` will return the `id` attribute of the
    UI widget that has been clicked and triggered the call to `onClick` in the first
    place.'
  prefs: []
  type: TYPE_NORMAL
- en: All we need to do then is provide a `case` statement (and appropriate action)
    for each of the `Button` references we want to respond to.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next code we will see is the first three `case` statements. They handle
    `R.id.btnAdd`, `R.id.btnTake`, and `R.id.btnReset` cases:'
  prefs: []
  type: TYPE_NORMAL
- en: The code in the `R.id.btnAdd` case simply increments the `value` variable, then
    it does something new.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It calls the `setText` method on the `txtValue` object. Here is the argument:
    `(""+ value)`. This argument uses an empty string and adds (concatenates) whatever
    value is stored in `value` to it. This has the effect of causing our `TextView
    txtValue` to display whatever value is stored in `value`.'
  prefs: []
  type: TYPE_NORMAL
- en: The `R.id.btnTake`) does exactly the same, only subtracts one from `value` instead
    of adding one.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third case statement handles the `value` to zero and again updates the `text`
    attribute of `txtValue`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, at the end of each `case`, there is a `break` statement. At this point,
    the `switch` block is exited, the `onClick` method returns, and life goes back
    to normal – until the user's next click.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter this code that we have just discussed inside the `switch` block after
    the opening curly brace `{`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The next two `case` statements handle the `R.id.btnGrow` and `R.id.btnShrink`.
    What is new and more interesting are the two new methods that are used.
  prefs: []
  type: TYPE_NORMAL
- en: The `getTextScaleX` method returns the horizontal scale of the text within the
    object it is used on. We can see that the object it is used on is our `TextView
    txtValue`. The `size =` at the start of the line of code assigns that returned
    value to our `float` variable `size`.
  prefs: []
  type: TYPE_NORMAL
- en: The next line of code in each `case` statement changes the horizontal scale
    of the text using `setTextScaleX`. When the `size + 1`, and when the `size - 1`.
  prefs: []
  type: TYPE_NORMAL
- en: The overall effect is to allow these two buttons to grow and shrink the text
    in the `txtValue` widget by a scale of 1 on each click.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the next two `case` statements that we have just discussed below the
    previous code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In our final `case` statement, which we will code next, we have an `if-else`
    block. The condition takes a little bit of explaining so let''s have sight of
    it in advance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The condition to be evaluated is `txtValue.getVisibility() == View.VISIBLE`.
    The first part of that condition before the `==` operator returns the `visibility`
    attribute of our `txtValue TextView`. The return value will be one of three possible
    constant values as defined in the `View` class. They are `View.VISIBLE`, `View.INVISIBLE`,
    and `View.GONE`.
  prefs: []
  type: TYPE_NORMAL
- en: If `TextView` is visible to the user on the UI, the method returns `View.VISIBLE`,
    the condition is evaluated as `true`, and the `if` block is executed.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `if` block, we use the `setVisibility` method on the `txtValue` object
    and make it invisible to the user with the `View.INVISIBLE` argument.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to this, we change the text on the `btnHide` widget to `setText`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: After the `if` block has executed, `txtValue` is invisible and we have a button
    on our UI that says `if` statement will be false and the `else` block will execute.
    In the `else` block, we reverse the situation. We set `txtValue` back to `View.VISIBLE`
    and the `text` property on `btnHide` back to **HIDE**.
  prefs: []
  type: TYPE_NORMAL
- en: 'If this is in any way unclear, just enter the code, run the app, and revisit
    this last code and explanation once you have seen it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We have the UI and the code in place, so it is time to run the app and try out
    all the buttons.
  prefs: []
  type: TYPE_NORMAL
- en: Running the app
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Run the app in the usual way. Notice that the `value` by one in either direction
    and then display the result in the `TextView` widget. In this next screenshot,
    I have clicked the **ADD** button three times.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.4  –  Add button example'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.4_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.4 – Add button example
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the `value` variable to 0 and displays it on the `TextView` widget.
    In this next screenshot, I have clicked the **GROW** button eight times.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.5 – Grow button example'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.5_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.5 – Grow button example
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `TextView` but changes its own text to `TextView` if tapped again.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: I will not bother you by showing you an image of something that is hidden. Be
    sure to try the app.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that there was no need for the `Log` or `Toast` classes in this app as
    we are finally manipulating the UI using our Java code. Let's dig even deeper
    into manipulating the UI with our code by exploring inner and anonymous classes.
  prefs: []
  type: TYPE_NORMAL
- en: Inner and anonymous classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we go ahead to the next chapter and build apps with loads of different
    widgets that will put into practice and reinforce everything we have learned in
    this chapter, we will have a very brief introduction to **Anonymous** and **Inner**
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: When we implemented our basic classes demo app in [*Chapter 10*](B16773_10_ePub_RK.xhtml#_idTextAnchor187)*,
    Object-Oriented Programming*, we declared and implemented the class in a separate
    file to our `MainActivity` class. That file had to have the same name as the class.
    This is the way to create a regular class.
  prefs: []
  type: TYPE_NORMAL
- en: We can also declare and implement classes within a class. Other than *how* we
    do this, the only question remaining, of course, is why would we do this?
  prefs: []
  type: TYPE_NORMAL
- en: When we implement an inner class, the inner class can access the member variables
    of the enclosing class and the enclosing class can access the members of the inner
    class.
  prefs: []
  type: TYPE_NORMAL
- en: This often makes the structure of our code more straightforward. So inner classes
    are sometimes the way to go.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, we can also declare and implement an entire class within a method
    of one of our classes. When we do so, we use a slightly different syntax and do
    not use a name with the class. This is an **anonymous** class.
  prefs: []
  type: TYPE_NORMAL
- en: We will see both inner and anonymous classes in action throughout the rest of
    the book and we will thoroughly discuss them when we use them.
  prefs: []
  type: TYPE_NORMAL
- en: Frequently asked questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I don't get it all and actually I have more questions now than I had at the
    start of the chapter. What should I do?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You know enough about OOP to make considerable progress with Android and any
    other type of Java programming. If you are desperate to know more about OOP right
    now, there are plenty of books that discuss nothing but OOP. However, practice
    and familiarity with the syntax will go a long way to achieving the same thing
    and will be more fun. This is exactly what we will do for the rest of the book.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we finally had some real interaction between our code and our
    UI. It turns out that every time we add a widget to our UI, we are adding an instance
    of a class that we can access with a reference in our Java code. All these objects
    are stored in a separate area of memory called the heap – along with any classes
    of our own.
  prefs: []
  type: TYPE_NORMAL
- en: We are now in a position where we can learn about and do cool things with some
    of the more interesting widgets. We will look at loads of them in the next chapter,
    and then keep introducing further new widgets throughout the rest of the book
    as well.
  prefs: []
  type: TYPE_NORMAL
