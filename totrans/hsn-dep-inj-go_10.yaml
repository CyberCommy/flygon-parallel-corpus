- en: Off-the-Shelf Injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For our final chapter in this section, we are looking at **dependency injection**
    (**DI**) using a framework. Choosing a DI framework that matches your preferred
    style can make your life significantly easier. Even if you prefer not to use a
    framework, examining how it is implemented and the approach it takes can be informative
    and help you find improvements for your preferred implementation.
  prefs: []
  type: TYPE_NORMAL
- en: While there are many frameworks available to us, including Facebook's Inject
    ([https://github.com/facebookgo/inject](https://github.com/facebookgo/inject))
    and Uber's Dig ([https://godoc.org/go.uber.org/dig](https://godoc.org/go.uber.org/dig)),
    for our sample service we are going to use Google's Go Cloud Wire ([https://github.com/google/go-cloud/tree/master/wire](https://github.com/google/go-cloud/tree/master/wire)).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Off-the-shelf injection with Wire
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advantages of off-the-shelf injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying off-the-shelf injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disadvantages of off-the-shelf injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It would be beneficial to be familiar with the code for our service, which we
    introduced in [Chapter 4](9b5a6d56-9d43-4a12-a580-6ca8b13b9201.xhtml), *Introduction
    to the ACME Registration Service*. This chapter also assumes that you have read
    [Chapter 6](89c75571-2952-40fc-ba19-221b3114461b.xhtml), *Dependency Injection
    with Constructor Injection*.
  prefs: []
  type: TYPE_NORMAL
- en: You might also find it useful to read and run the full versions of the code
    for this chapter, which is available at [https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/tree/master/ch10](https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/tree/master/ch10).
  prefs: []
  type: TYPE_NORMAL
- en: Instructions to obtain the code and configure the sample service are available
    in the README here: [https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/](https://github.com/PacktPublishing/Hands-On-Dependency-Injection-in-Go/).
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code for our service, with the changes from this chapter already
    applied, in `ch10/acme`.
  prefs: []
  type: TYPE_NORMAL
- en: Off-the-shelf injection with Wire
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Go Cloud project is an initiative that intends to make it easier for application
    developers to deploy cloud applications on any combination of cloud providers
    seamlessly. The integral part of this project is a code generation-based dependency
    injection tool called **Wire**.
  prefs: []
  type: TYPE_NORMAL
- en: Wire is a good fit for our example service as it promotes the use of explicit
    instantiation and discourages the use of global variables; just as we attempted
    to achieve in our refactoring in previous chapters. Additionally, Wire uses code
    generation to avoid any performance penalties or code complexity that can result
    from the use of runtime reflection.
  prefs: []
  type: TYPE_NORMAL
- en: Perhaps the most useful aspect of Wire for us is its simplicity. After we understand
    a few simple concepts, the code we have to write and the code that is generated
    is reasonably straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing providers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The documentation defines a provider as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '"*A function that can produce a value*."'
  prefs: []
  type: TYPE_NORMAL
- en: For our purposes, we can put it a different way—a provider returns an instance
    of a dependency.
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest form a provider can take is a *simple no argument function*, as
    shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Providers can also indicate that they require dependencies to be injected by
    having parameters like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The dependencies (parameters) of this provider must be provided by other providers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Providers can also indicate that they may fail to initialize by returning an
    error, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: It is important to note that when a provider returns an error, any injector
    that uses the dependency provided must also return an error.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding injectors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The second concept integral to Wire is injectors. Injectors are where the magic
    happens. They are functions that we (developers) define that Wire uses as a base
    for its code generation.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if we want to have a function that can create an instance of our
    service''s REST server, including initializing and injecting all the required
    dependencies, we can achieve this with the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'That probably feels like a big sell for such a simple function, especially
    as it does not seem to do anything (that is, `returns nil, nil`). But that is
    all we need to write; the code generator will turn it into the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We will go into this in more detail in the *Applying* section, but for now there
    are three features of the aforementioned function to remember. Firstly, the generator
    does not care about the implementation of the function, except that the function
    must include a `wire.Build(wireSet)` call. Secondly, the function must return
    the concrete type that we are planning to use. And lastly, if we rely on any providers
    that return an error, then the injector must also return an error.
  prefs: []
  type: TYPE_NORMAL
- en: Adopting provider sets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The last concept that we need to know when using Wire is provider sets. Provider
    sets offer a way to group providers, and this can be helpful when writing injectors.
    Their use is optional; for example, earlier we used a provider set called `wireSet`,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'However, we could have passed in all the providers individually, as shown in
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Sadly, the previous example is not contrived. It's taken from our small example
    service.
  prefs: []
  type: TYPE_NORMAL
- en: As you might expect, there are plenty more features in Wire, but at this point
    we have covered enough to get us started.
  prefs: []
  type: TYPE_NORMAL
- en: Advantages of off-the-shelf injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While we have been talking specifically about Wire so far in this chapter, I
    would like to take a moment to discuss the advantages of off-the-shelf injection
    in a more general sense. When evaluating a tool or framework, it's essential to
    cast a critical eye over the advantages, disadvantages, and effects on your code
    that it may have.
  prefs: []
  type: TYPE_NORMAL
- en: Some of the possible advantages of off-the-shelf injection include the following.
  prefs: []
  type: TYPE_NORMAL
- en: '**A reduction in boilerplate code**—After applying constructor injection to
    a program, it''s common that the `main()` function becomes bloated with the instantiation
    of objects. As the project grows, so does `main()`. While this does not impact
    the performance of the program, it does become inconvenient to maintain.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Many dependency injection frameworks aim to either remove this code or move
    it elsewhere. As we will see, this is `main()` for our sample service before adopting
    Google Wire:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'And this is `main()` after adopting Google Wire:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'And all of the related objection creation is reduced to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Because Wire is a code generator, we actually end up with more code, but less
    of it was written or maintained by us. Similarly, if we were to use another popular
    DI framework called **Dig**, `main()` would become this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we gain a similar reduction in code.
  prefs: []
  type: TYPE_NORMAL
- en: '**Automatic instantiation order**—Similar to the previous point, as the project
    grows, so does the complexity of the ordering in which dependencies must be created.
    As such, much of the *magic* provided by off-the-shelf injection frameworks is
    focused on removing this complexity. In both the cases of Wire and Dig, providers
    explicitly define their direct dependencies and ignore any requirements of their
    dependencies.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example. Let''s say we have an HTTP handler like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the handler depends on a model, which looks as shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This model depends on `*sql.DB`. However, when we define the provider for our
    handler, it defines only that it requires `*GetPersonModel` and has no knowledge
    of `*sql.DB`, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Compared to the alternative of creating the database, injecting it into a model,
    and then injecting the model into the handler, this is much simpler both to write
    and maintain.
  prefs: []
  type: TYPE_NORMAL
- en: '**Someone has already done the thinking for you**—Perhaps the least obvious
    but most important advantage a good DI framework can offer is the knowledge of
    its creators. The act of creating and maintaining a framework is definitely a
    non-trivial exercise, and it teaches its authors far more about DI than most programmers
    need to know. This knowledge often results in subtle but useful features appearing
    in the framework. For example, in the Dig framework, by default, all dependencies
    are singletons. This design choice results in performance and resource usage improvements
    as well as a more predictable dependency life cycle.'
  prefs: []
  type: TYPE_NORMAL
- en: Applying off-the-shelf injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As I mentioned in the previous section, by adopting Wire we are hoping to see
    a significant reduction in the code and complexity in `main()`. We are also hoping
    to be able to essentially forget about the instantiation order of the dependencies
    by leaving the framework to handle it for us.
  prefs: []
  type: TYPE_NORMAL
- en: Adopting Google Wire
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first thing we need to do, however, is to get our house in order. Most,
    if not all, of the objects we are going to let Wire handle use our `*config.Config`
    object, and currently it exists as a global singleton, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: To change this to a form that Wire can use, we need to delete the global instance
    and change the config loading to a function instead of being triggered by `init()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'After a quick look at the uses of our global singleton, it shows that only
    `main()` and a few tests in the `config` package refer to the singleton. Thanks
    to all our previous work, this change is going to be rather straightforward. Here
    is the config loader after refactoring:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'And here is our updated `main()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have removed the config global, we are ready to start adopting Google
    Wire.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to start by adding a new file; we are naming it `wire.go`. It can
    be called anything, but we need a separate file because we are going to use Go
    build tags to separate the code we write in this file from the version generated
    by Wire.
  prefs: []
  type: TYPE_NORMAL
- en: 'In case you are not familiar with build tags, in Go they are comments at the
    top of the file, before the `package` statement, in this form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'These tags tell the compiler when or when not to include the file during compilation.
    For example, the aforementioned tag tells the compiler to include this file only
    when the build is triggered, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also use build tags to do the reverse and make a file that is only included
    when the tag is not specified, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Back to `wire.go`, inside this file we are going to define an injector for
    the config that uses our config loader as a provider, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Let's break down the injector a little more. The function signature defines
    a function that returns an instance of `*config.Config` or an error, which is
    the same as `config.Load()` from earlier.
  prefs: []
  type: TYPE_NORMAL
- en: The first line of the function calls `wire.Build()` and supplies our provider,
    and the second line returns `nil, nil`. In truth, it does not matter what it returns
    as long as it is valid Go code. The code generator in Wire will read the function
    signature and the `wire.Build()` call only.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we open a Terminal and run `wire` in the directory that contains our `wire.go` file.
    Wire will create a new file for us called `wire_gen.go`, which looks as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: You will notice that this file also has a build tag, but it is the opposite
    of the one that we wrote earlier. Wire has copied our `initializeConfig()` method
    and *filled in all the details* for us.
  prefs: []
  type: TYPE_NORMAL
- en: So far, the code is pretty simple and likely to be very similar to what we could
    have written ourselves. You might be tempted to feel like we have not really gained
    much so far. I agree. By the time we convert the rest of our objects over, the
    amount of code and complexity Wire will take care of for us will be significantly
    more.
  prefs: []
  type: TYPE_NORMAL
- en: 'To complete this set of changes, we update `main()` to use our `initializeConfig()`
    function like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'With config handled, we can move on to the next object, `*exchange.Converter`.
    In the previous examples, we did not use a provider set but instead passed our
    provider directly into the `wire.Build()` call. We are about to add another provider
    so now it''s time to get a little more organized. We will, therefore, add a private
    global variable to `main.go` and add our `Config` and `Converter` providers to
    it, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, I have also added a `wire.Bind()` call. Wire requires us to
    define or map the concrete types that satisfy an interface so that it is able
    to satisfy them during injection. The constructor for `*exchange.Converter` looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: As you might remember, this constructor uses config injection and a locally
    defined `Config` interface. However, the actual config object that we inject is
    `*config.Config`. Our `wire.Bind()` call tells Wire that where the `exchange.Config` interface is
    needed use `*config.Config`.
  prefs: []
  type: TYPE_NORMAL
- en: 'With our provider set in place, we can now update our config injector and add
    an injector for the `Converter` as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: It is important to note that while `exchange.NewConverter()` does not return
    an error, our injector must. This is because of our dependence on the config provider,
    which returns an error. This may sound like a pain to remember but don't worry,
    Wire helps us get it right.
  prefs: []
  type: TYPE_NORMAL
- en: Moving on down our list of objects, we will need to do the same for our model
    layer. The injectors are entirely predictable and almost identical to `*exchange.Converter`,
    as are the changes to our provider set.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that `main()` and the provider set after the changes look as shown in
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: There are a couple of things of importance. Firstly, our provider set is getting
    rather long. This is probably OK, as the only changes we are making are to add
    more provider and bind statements.
  prefs: []
  type: TYPE_NORMAL
- en: Secondly, we no longer call `initializeExchanger(),` and we have actually deleted
    that injector. The reason we don't need this anymore is Wire is handling the injection
    into the model layer for us.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, for brevity, I have ignored the errors that could be returned from the
    model layer injectors. This is a bad practice, but don't worry, we will be deleting
    these lines soon after our next set of changes.
  prefs: []
  type: TYPE_NORMAL
- en: After a quick run of Wire and our tests to make sure everything is still working
    as expected, we are ready to move on to our final object, the REST server.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we make the following, perhaps predictable, additions to the provider
    set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we define the injector for our REST server in `wire.go` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can update `main()` to call only the REST server injector like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: With that done, we can delete all of the injectors except `initializeServer()`,
    then run Wire, and we are done!
  prefs: []
  type: TYPE_NORMAL
- en: 'Now might be a good time to examine the code that Wire generated for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Does it look familiar? It's incredibly similar to `main()` before we adopted
    wire.
  prefs: []
  type: TYPE_NORMAL
- en: Given that our code was already using constructor injection and our service
    is rather small, it's easy to feel like we did a lot of work for minimal gain.
    If we were adopting Wire from the start, this would definitely not feel this way.
    In our particular case, the benefits are more long term. Now that Wire is handling
    the constructor injection and all the complexity related to instantiation and
    instantiation ordering, all extensions to our service will be a whole lot simpler
    and less prone to human error.
  prefs: []
  type: TYPE_NORMAL
- en: API regression tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With our conversion to Wire complete, how do we make sure our service still
    works as we expect?
  prefs: []
  type: TYPE_NORMAL
- en: Our only immediate option is to just run the app and try it. This option might
    be OK for right now, but I don't like it as a long-term option, so let's see if
    we can add some automated tests.
  prefs: []
  type: TYPE_NORMAL
- en: The first question we should be asking ourselves is *what are we testing?* We
    should not need to test Wire itself, we can trust the tool authors to do that.
    In what other ways can things go wrong?
  prefs: []
  type: TYPE_NORMAL
- en: A typical answer would be our use of Wire. If we had misconfigured Wire, it
    would have failed to generate, so that is covered. That leaves us with the app
    itself.
  prefs: []
  type: TYPE_NORMAL
- en: To test the app, we need to run it and then make an HTTP call into it, and then
    validate the response is as we expected.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we need to consider is how to start the app, and, perhaps more
    importantly, how to do it in a way that we can have multiple tests running at
    the same time.
  prefs: []
  type: TYPE_NORMAL
- en: At the moment, our config (database connection, HTTP port, and so on) are hardcoded
    in a file on the disk. We could use that, but it includes a fixed HTTP server
    port. On the other hand, hardcoding database credentials in our tests is way worse.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use a middle ground. First, let''s load the standard `config` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s find a free TCP port to which we can bind our server. We can use
    port `0` and allow the system to assign one automatically, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now use that free port and replace the address in the `config` file
    with one that uses the free port like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'And now we are stuck. Currently, to create an instance of the server, the code
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The config is automatically injected, no chance for us to use our custom config.
    Thankfully, Wire can help with this too.
  prefs: []
  type: TYPE_NORMAL
- en: 'To be able to inject the config in our tests manually, but not modify `main()`,
    we need to split our provider set into two parts. The first part is all the dependencies
    except config:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'And the second includes the first and then adds the config and all the related
    bindings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to create an injector that takes config as a parameter. In
    our case, it''s a little bit weird as this is caused by our config injection,
    but it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'After running Wire, we can now start our test server, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Putting all of it together, we now have a function that creates a server on
    a random port and returns the address of the server, so that our test knows where
    to call. Here is the completed function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s look at a test. Again, we are going to use the register endpoint
    as an example. Firstly, our test needs to start a test server. In the following
    example, you will also notice that we are defining a context with a timeout. When
    the context is done, via timeout or being canceled, the test server will shut
    down; therefore, this timeout becomes the *maximum execution time* of our test.
    Here is the code to start the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Next, we need to build and send the request. In this case, we've chosen to hardcode
    the payload and the URL. This might seem strange, but it's actually somewhat helpful.
    If the payload or the URL, both of which constitute the API of our service, were
    to change accidentally, these tests would break. Consider, on the other hand,
    if for the URL we used a constant that was also used to configure the server.
    If that constant was changed, the API would change and would break our users.
    Same goes for the payload, we could use the same Go object that is used internally,
    but changes there would also not cause the test to break.
  prefs: []
  type: TYPE_NORMAL
- en: Yes, this duplication is more work and does make the tests more brittle, both
    of which are not good, but it's better for our tests to break than for us to break
    our users.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code to build and send the request is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Now all that is left is to validate the results. After putting it all together,
    we have this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: That's it. We now have an automated test that ensures our app starts, can be
    called, and responds as we expect. If you are interested, there are tests for
    the other two endpoints in the code for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Disadvantages of off-the-shelf injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As much as framework authors would love for their work to be a silver bullet,
    solving all the world's DI problems, this is sadly not the case; there are some
    costs associated with adopting a framework and reasons that you may choose not
    to use one. These include the following.
  prefs: []
  type: TYPE_NORMAL
- en: '**Only supports constructor injection**—You may have noticed in this chapter
    that all of the examples used constructor injection. This is not by accident.
    Wire, like many frameworks, only supports constructor injection. We did not have
    to remove our use of other DI methods, but the framework is unable to assist us
    with it.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Adoption can be costly**—As you saw in the previous section, the end result
    of adopting a framework can be rather good, but our service is small and we were
    already using DI. If either of these things were not true, we would have been
    in for a lot more refactoring work. And as we have discussed before, the more
    changes we make, the more risk we incur.'
  prefs: []
  type: TYPE_NORMAL
- en: These costs and this risk can be mitigated with prior experience with the framework
    and by adopting the framework from early in the project.
  prefs: []
  type: TYPE_NORMAL
- en: '**Ideological issues**—This is not a disadvantage per se but more a reason
    you might not want to adopt a framework. In the Go community, you will come across
    a sentiment that frameworks are *not idiomatic* or *in-line with Go''s philosophy*.
    While there has been no official statement or documentation that I could find
    to support this, I believe this is based on the fact that Go''s creators were
    fans and authors of the Unix philosophy, which states *do trivial things in isolation
    and then compose to make things useful*.'
  prefs: []
  type: TYPE_NORMAL
- en: Frameworks can be seen to violate this ideology, especially if they become a
    pervasive part of the system as a whole. The frameworks we have mentioned in this
    chapter have a relatively small scope; so as with everything else, I will leave
    you to make your own call.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed using a DI framework in an attempt to lighten
    the burden of managing and injecting dependencies. We have discussed the advantages
    and disadvantages commonly found in DI frameworks and applied Google's Wire framework
    to our sample service.
  prefs: []
  type: TYPE_NORMAL
- en: This was the last DI method we will be discussing, and, in the next chapter,
    we will be taking a completely different tact and looking at reasons not to use
    DI. We will also be looking at situations where applying DI actually makes the
    code worse.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When adopting a DI framework, what can you expect to gain?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When evaluating a DI framework, what kinds of issues should you being looking
    out for?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the ideal use cases for adopting off-the-shelf injection?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is it important to protect your service from accidental API changes?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
