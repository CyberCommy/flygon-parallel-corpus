- en: Chapter 2. Message Ingestion
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As mentioned in the *Preface*, Spring Integration is an implementation of *Enterprise
    Integration Patterns: Designing, Building, and Deploying Messaging Solutions (Addison
    Wesley Signature Series)*, *Gregor Hohpe* and *Bobby Woolf*, *Addison-Wesley Professional*.
    **EIP** (short for **Enterprise Integration Patterns**) defines patterns for many
    integration challenges, and one of them is the exchange of messages between heterogeneous
    systems. In this chapter, we will explore patterns and concepts around message
    exchange.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'Heterogeneous endpoints use messaging to communicate. There are primarily three
    aspects of messaging: messages being exchanged, the endpoints that participate
    in the communication, and the medium through which messages are delivered. In
    an EIP paradigm, we define them as messages, message endpoints, and message channels.
    Let''s discuss each one at a time and then we will discuss the pattern.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'What is a message? In simplest terms, messages can be understood as a piece
    of information that can be used as an enabler for intercommunication and collaboration
    between heterogeneous components. It is composed of primarily two parts: header
    and payload. Headers contain metadata and commonly require values such as ID,
    timestamp, and so on, but a header''s use can be extended for passing other values
    as well, for example, a channel name for a router, file components for a filename,
    and so on. Payload can be of any type: standard Java object, XML, or any custom
    or user-defined value. It can be a simple information-sharing payload too (for
    example, a registration module can notify an audit module when a new user is registered),
    or it can be a command (for example, an administration module can instruct the
    mail service to notify all the users who''ve registered for the course), or it
    can be an event (for example, a mail service that, after sending all the mails,
    dispatches an event back to the admin module specifying that all the mails have
    been sent and it''s good to go with the next step).'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'We noticed a pattern here; there is a communication between two components
    via these messages—in formal terms, we call these components message endpoints.
    Similarly, we can observe that message endpoints are of two types: producer endpoint
    and consumer endpoint. As their names suggest, a producer, such as `registration
    module`, generates a message in the given example, while a consumer consumes it—for
    example the `audit module` in the given example. An endpoint can be a producer
    as well as a consumer, for example, a mail service. Endpoints are typically smart
    components that can validate messages before passing them on to the next subsystem
    or can route, filter, aggregate, transform, or do a lot more so that the message
    can be in a format expected by the next in the chain.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Working with message channels
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We defined messages and we discussed how message endpoints act on the messages,
    so where does a message channel fit in? A message channel is an implementation
    of the EAI design pattern that decouples the endpoint. Endpoints do not need to
    be aware of each other''s type; they register with channels and it''s the responsibility
    of the channel to deliver the messages safely between endpoints. Each channel
    has a logical identity—it may be a unique name or ID through which it can be referred
    and registered to. Depending on how channels handle the messages, they can be
    classified in two broad categories:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: Point-to-point channel
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Publish-subscribe channel
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Channel types
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before starting with their implementation, let''s first look at the following
    types of channels:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '**Point-to-point channel**: A one-to-one relationship is maintained between
    producer and consumer. These channels deliver message to one and only one recipient.
    Even if more than one recipient is registered, messages will only be delivered
    to one of them. This channel type can be used in a parallel processing scenario,
    allowing multiple consumers to listen to the availability of messages in parallel,
    but the delivery of messages will be done to a single consumer only!'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Publish-subscribe channel**: These channels deliver messages to all of the
    subscribers who have registered on the channel, thus implementing a one-to-many
    relationship between producer and consumer. An analogy can be drawn as each subscriber
    has its own private channel, on which a copy of the message is delivered. As soon
    as it''s consumed, it is discarded.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get out of idioms and have a sneak peek at how Spring Integration provides
    support for all of these components—after all, this is a book on Spring Integration,
    isn't it!
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Spring implementation of channels
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spring Integration defines a top-level interface for the message channel that
    should be implemented by any of the concrete channel implementations, as shown
    here:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `MessageChannel` interface defines two versions of the `send` method—one
    which accepts only `Message` as an argument while the other one accepts an additional
    parameter (`timeout`). The `send` method returns true if the message is sent out
    successfully; otherwise, if it times out or the sending fails for some reason,
    it returns false.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: 'Further, Spring Integration provides a sub type of the `MessageChannel` interface
    to support two types of channels: `PollableChannel` and `SubscribableChannel`.
    This is explained in more detail in the following points:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '**Pollable channel**: This channel provides the interface that has two versions
    of receive, one which does not take any argument and the other which provides
    an option to specify the `timeout` parameter. The following code snippet is the
    interface declaration:'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '**Subscribeable channel**: This interface exposes methods to subscribe and
    unsubscribe from the channel. The following code snippet is the interface declaration
    for a subscribe-able channel:'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'An instance of the `MessageHandler` interface is passed as an argument to the
    `subscribe` and `unsubscribe` methods. The `MessageHandler` interface exposes
    only one method, `handleMessage`, to handle the message:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Whenever a message arrives on a channel, an implementation of the message handler
    is looked upon by the framework, and the message is passed to the implementer's
    `handleMessage` method.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Although Spring Integration defines message channel interfaces and allows users
    to provide their implementation, it's hardly ever needed. Spring Integration has
    provided many implementations of channels that can be used *off the shelf*.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: Selecting a channel
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's discuss what default implementations have been provided by Spring Integration
    and how they can be leveraged.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: Publish-subscribe channel
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is the only implementation of the publish-subscribe model of channel.
    The primary purpose of this channel is to send messages to registered endpoints;
    this cannot be polled. It can be declared as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let''s discuss each of the elements in this line; this will be used throughout
    the examples of this chapter:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '`int`: This is a namespace that declares all Spring Integration components.
    As discussed in [Chapter 1](part0018_split_000.html#page "Chapter 1. Getting Started"),
    *Getting Started*, the STS visual editor can be used to add different namespaces
    from Spring Integration.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`publish-subscribe-channel`: This is the type exposed by Spring.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Id`: This is the unique name through which the channel can be referred.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To refer to these elements from the code, we can use:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Queue channel
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Remember queue concepts from good old data structures? `QueueChannel` employs
    the same concept—it enforces **First in First out** (**FIFO**) ordering and a
    message can be consumed by one and only one endpoint. It''s a strictly one-to-one
    relationship, even if the channel has multiple consumers; one message will be
    delivered to only one of them. In Spring Integration, it can be defined as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As soon as a message is available on the channel, it will try to send the message
    to the subscribed consumer. The element `capacity` indicates the maximum number
    of undelivered messages to be held in the queue. If the queue is full, which is
    determined by the `capacity` parameter, the sender will be blocked until messages
    are consumed and further room is available in the queue. Alternatively, if a timeout
    parameter has been specified for the sender, the sender will wait for the specified
    timeout interval—if space is created in the queue within the timeout interval,
    the sender will put the message there, else it will discard that message and start
    with an other one.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although capacity parameter is optional, it should never be left out; otherwise,
    the queue will become unbounded and may result in OutOfMemoryErrors.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: Priority channel
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Queue enforces FIFO, but what if a message needs urgent attention and needs
    to be processed out of the queue? For example, a server health monitoring service
    might send health audits to an *audit service*, but if it sends a server down
    event, it needs urgent processing. This is where `PriorityChannel` is handy; it
    can pick messages based on their priority rather than arrival order. Messages
    can be prioritized as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: By adding a `priority` header within each message
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By providing a comparator of type `Comparator<Message<?>>` to the priority channel's
    constructor
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Default is the `priority` header in the message.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take the following example of a priority channel and inject a comparator
    there, which will be used to decide the priority of the message:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'A comparator can be injected as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Rendezvous channel
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Often, it is desirable to have an acknowledgement that the message has indeed
    reached the endpoint. The `rendezvousChannel` interface, which is a subclass of
    the queue channel, serves this purpose. Producer and consumer work in a blocking
    mode. As soon as the producer sends a message on the channel, it is blocked until
    that message has been consumed. Similarly, a consumer is blocked until a message
    arrives in the queue. It can be configured as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `RendezvousChannel` interface implements a zero capacity queue, which means
    that at any given point, there can exist only one message on the queue. No wonder
    there is no capacity element.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: Direct channel
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Direct channel is the default channel type used by Spring Integration.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When using the `<channel/>` element without any subelements, it will create
    a `DirectChannel` instance (a `SubscribableChannel`) handler.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: 'Multiple endpoints can subscribe message handlers with the direct channel;
    whenever a producer puts a message on the channel, it is delivered to one and
    only one of the message handlers of subscribed endpoints. The introduction of
    multiple subscribers with a restriction to deliver a message to one and only one
    of the handlers introduces new challenges—how and which handler will be selected
    and what will happen if the handler is not able to process the message? This is
    where a load balancer and failover come into the picture. A load balancer can
    be defined on this channel with a round-robin delivery strategy:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This will deliver messages to subscribers on a round-robin basis. This is the
    only strategy defined out-of-the-box by Spring, but a custom strategy can be defined
    using `interface`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here is an example of introducing a custom load balancer:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Tip
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Downloading the example code**'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you. The code can also be
    pulled from [https://github.com/cpandey05/siessentials](https://github.com/cpandey05/siessentials).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: Failover, on other hand, is a Boolean value. If this is set to true, then if
    the first handler fails to process the message, then all subsequent handlers will
    be tried. Even if one of the handlers successfully processes the message, Spring
    Integration will not report an error. Only if all of the handlers fail, will it
    throw an exception.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Failover capability can be very handy while implementing a transaction propagation
    or for a fallback mechanism. For example, if a DB server fails, try another backend
    server in the next handler.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: Executor channel
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `ExecutorChannel` interface is a point-to-point message channel. This is
    very similar to the direct channel, except that custom executors can be used to
    dispatch the messages. Let''s have a look at the configuration:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `com.example.ResultExecutor` interface is an implementation of `java.uti.concurrent.Executor`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: A transaction link cannot be established between producer and consumer because
    a producer thread hands off the message to an executor instance and backs off—the
    consumption of the message is processed in the executor thread.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: 'As in direct channels, a load-balancing strategy and failover can be set. The
    default values are a round-robin strategy with failover enabled:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Scoped channel
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'A custom scope can also be defined, as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This is an example of a thread scoped channel. If we observe the entries, a
    key-value pair has been defined for the scope. For the thread, the key-value pair
    is `org.springframework.context.support.SimpleThreadScope`. It can be any Spring-defined
    or a user-defined scope.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Some of the other Spring implemented scopes are as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '`org.springframework.web.context.request.SessionScope`'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`org.springframework.web.context.support.ServletContextScope`'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`org.springframework.web.context.request.RequestScope`'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`org.springframework.web.portlet.context.PortletContextScope`'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Datatype channel
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A channel can be restricted to accept messages having only a certain type of
    payload, for example, numbers, string, or any other custom type. The code is as
    follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Multiple types can also be provided, as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'What will happen if a message arrives in a format other than the one given
    in the preceding code? By default, an exception will be thrown. However, if the
    use case warrants, we can define converters, which will try to convert incoming
    messages into an acceptable format. A typical use case is the conversion of a
    string to an integer. For this to happen, a bean named `integrationConversionService`
    that is an instance of Spring''s Conversion Service must be defined as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: When the `converter` element is parsed, it will create the `integrationConversionService`
    bean on-demand, if one is not already defined. With that converter in place, if
    a string message arrives on a channel defined as an integer, an attempt would
    be made to convert it to an integer.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: Error handling on channels
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spring Integration supports synchronous as well as asynchronous message processing.
    In the case of synchronous processing, it is comparatively easy to handle error
    scenarios based on return values or by catching thrown exceptions; for asynchronous
    processing, things are more complicated. There are components provided by Spring,
    such as filters and routers, that can be used to validate message sanity and take
    action based on that. If it''s invalid, the message can be routed to an invalid
    channel or a retry channel as the case may be. Apart from this, Spring provides
    a global error channel and capability to define custom error channels. The following
    points cover an appropriate error channel:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: 'An error channel needs to be defined. This can be done as follows:'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: A header named `errorChannel` needs to be added to the message. This is the
    name of the channel where `ErrorMessage` should be routed when processing fails.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If message processing fails, `ErrorMessage` will be sent to the channel specified
    by the header `errorChannel`.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If the message does not contain a `errorChanel` header, `ErrorMessage` will
    be routed to a global error channel defined by Spring Integration, which is `errorChannel`.
    This channel is a publish-subscribe channel:'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Persisting and recovering channels
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We talked about all kind of channels, but if you have noticed, these are all
    in memory. What if the system crashes? No one wants to lose data. This is where
    persistent `QueueChannel` comes into the picture—messages will be backed up in
    the database defined by the data source. If the system crashes, then on recovery,
    it will pull all the messages in the database and queue them for processing. This
    is achieved in Spring using `MessageGroupStore`. Let''s have a quick look at the
    configuration:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Here, the message store is mapped to the database defined by `someDataSource`.
    When a message arrives, it will now be added to `MessageStore` first. On successful
    processing, it will be removed from there.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: The moment we talk of databases, transaction comes into the picture. So what
    if the poller has a transaction configured? In that case, if message processing
    fails, the transaction will be rolled backed and the message will not be deleted
    from the queue.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If transactional behavior is supported, messages will not be removed from the
    queue until they have been successfully processed. If some messages fail repeatedly,
    this may build up stale messages in the queue over time. A clean-up strategy for
    such messages must be thought through.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Channel interceptors
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Interceptor patterns can be used to apply business rules and validations on
    messages that are either sent from the channel or received on it. The following
    four interceptors are available:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Here are the methods exposed by the `ChannelInterceptor` interface:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '`preSend`: This is invoked before a message is sent. A null value should be
    returned if the message is blocked from sending.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`postSend`: This is invoked after an attempt to send a message. It indicates
    whether the message was sent successfully or not. This can be used for audit purposes.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`preReceive`: This applies only if the channel is pollable and is invoked when
    a component calls `receive()` on the channel, but before a message is actually
    read from that channel. It allows implementers to decide whether the channel can
    return a message to the caller.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`postReceive`: This is similar to `preReceive` and it applies only to pollable
    channels. It''s invoked after a message is read from a channel but before it''s
    returned to the component that called `receive()`. If it returns a null value,
    then no message is received. This allows the implementer to control what, if anything,
    is actually received by the poller.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is a comparatively long chapter in which we discussed message channel patterns,
    different types of channels, and the default implementations of channels provided
    by Spring. We also covered load balancing, failover, error handling on message
    channels, persisting messages, and adding interceptors. All these concepts are
    at the core of building a reliable and scalable solution, and we will see its
    hands-on implementation in the upcoming chapters where we will discuss Spring
    Integration components such as service activators, gateway, delayers, and so on
    that are used to process messages.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相对较长的章节，我们在其中讨论了消息通道模式、不同类型的通道，以及Spring提供的通道的默认实现。我们还涵盖了消息通道上的负载平衡、故障转移、错误处理、持久化消息和添加拦截器。所有这些概念都是构建可靠和可扩展解决方案的核心，我们将在接下来的章节中看到它们的实际实现，我们将讨论Spring集成组件，如服务激活器、网关、延迟器等，这些组件用于处理消息。
