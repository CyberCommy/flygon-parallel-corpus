- en: Getting Started with System Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will be introduced to the foundations on which the entire
    book is framed. You will learn (or refresh your knowledge of) how Linux is designed,
    and you will also learn about the shell, users and groups, process IDs, and thread
    IDs to be able to use a Linux system proficiently and get prepared for the next
    chapters. Furthermore, you will also learn how to develop a simple `hello world` program,
    and find out about its makefile, and also how to execute and debug it. Another
    important aspect of this chapter is to learn how Linux deals with errors, from
    both a shell and a source code point of view. This foundational knowledge is important
    to understand other advanced topics in the following chapters. You can safely
    skip this and the next chapters if this refresher is not needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Learning the Linux fundamentals – architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning the Linux fundamentals – shell
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning the Linux fundamentals – users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a makefile to compile and link a program
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the **GNU Project Debugger **(**GDB**) to debug a program
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning the Linux fundamentals – processes and threads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling a Linux bash error
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling Linux code error
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to let you try the programs immediately, we've set up a Docker image that
    has all the tools and libraries we'll need throughout the book. This is based
    on Ubuntu 19.04.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to set this up, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Download and install the Docker Engine from [www.docker.com](https://www.docker.com/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pull the image from Docker Hub: `docker pull kasperondocker/system_programming_cookbook:latest`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The image should now be available. Type in the following command to view the
    image: `docker images`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You should have at least this image now: `kasperondocker/system_programming_cookbook`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the Docker image with an interactive shell, with the help of the following
    command: `docker run -it --cap-add sys_ptrace kasperondocker/system_programming_cookbook:latest /bin/bash`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The shell on the running container is now available. Run `root@39a5a8934370/#
    cd /BOOK/` to get all the programs developed, by chapters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `--cap-add sys_ptrace` argument is needed to allow GDB in the Docker container
    to set breakpoints, which, by default, Docker does not allow.
  prefs: []
  type: TYPE_NORMAL
- en: Learning the Linux fundamentals - architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Linux** is a clone of the Unix operating system, developed by Linus Torvalds in
    the early ''90s. It is a multiuser, multitasking operating system that runs on
    a wide variety of platforms. The Linux kernel has a monolithic architecture for
    performance reasons. This means that it is self-contained in one binary, and all
    its **services** run in kernel space. This was one of the most controversial topics
    at the beginning. Andy Tanenbaum (professor at the Vrije Universiteit, Amsterdam)
    argued against its monolithic system, saying: *This is a giant step back into
    the 1970s.* He also argued against its portability, saying: *LINUX is tied fairly
    closely to the 80 x 86\. Not the way to go*. In the *minix* user group, there
    still is the thread of full chat involving Torvalds, Tanenbaum, and others.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the main Linux building blocks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9a7b4405-e9e4-431b-b068-0883d1189150.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s describe the layers we see in the diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: On the top layer, there are user applications, processes, compilers, and tools.
    This layer (which runs in a user space) communicates with the Linux kernel (which
    runs in kernel space) through system calls.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**System libraries**: These are a set of functions through which an application
    can interact with the kernel.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Kernel**: This component contains the core of the Linux system. Among other
    things, it has the scheduler, networking, memory management, and filesystems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Kernel modules**: These contain pieces of kernel code that still run in kernel
    space but are fully dynamic (in the sense that they can be loaded and unloaded
    with the running system). They typically contain device drivers, kernel code that
    is specific to a particular hardware module implementing a protocol, and so on.
    One huge advantage of the kernel modules is that users can load them without rebuilding
    the kernel.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GNU** is a recursive acronym that stands for **GNU is Not Unix**. GNU is
    an operating system that is free software. Note the term *operating system* here.
    Indeed, GNU used alone is meant to represent a full set of tools, software, and
    kernel parts that an operating system needs. The GNU operating system kernel is
    called the** Hurd**. As the Hurdwas not production-ready, GNU typically uses the
    Linux kernel, and this combination is called the **GNU/Linux operating system**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, what are the GNU components on a GNU/Linux operating system? Packages* such
    as the **GNU Compiler Collection** (**GCC**), the **GNU C library**, GDB, the
    GNU Bash shell, and the **GNU Network Object Model Environment** (**GNOME**) desktop
    environment, to mention just a few. Richard Stallman and the **Free Software Foundation**
    (**FSF**)—of which Stallman is the founder—authored the **free software definition** to
    help respect users'' freedom. *Free software* is considered any package that grants
    users the following four types of freedoms (so-called **essential freedoms**: [https://isocpp.org/std/the-standard](https://isocpp.org/std/the-standard)):'
  prefs: []
  type: TYPE_NORMAL
- en: The freedom to run the program as you wish, for any purpose (Freedom *0*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The freedom to study how the program works and to change it, so it does your
    computing as you wish (Freedom *1*). Access to the source code is a precondition
    for this.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The freedom to redistribute copies so that you can help others (Freedom *2*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The freedom to distribute copies of your modified versions to others (Freedom
    *3*). By doing this, you can give the whole community a chance to benefit from
    your changes. Access to the source code is a precondition for this.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The concrete instantiation of these principles is in the GNU/GPL license, which
    FSF authored. All of the GNU packages are released under the GNU/GPL license.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Linux has a pretty standard folder structure across the distributions, so knowing
    this would allow you to easily find programs and install them in the correct place.
    Let''s have a look at it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Open a Terminal on the Docker image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type the command `ls -l /`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The output of the command will contain the following folders:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4a845486-dd7f-40b4-a271-fc851692fe1e.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see this folder structure is pretty organized and consistent across
    all the distributions. Under the hood, the Linux filesystem is quite modular and
    flexible. A user application can interact with the GNU C library(which provides
    interfaces such as open, read, write, and close) or the Linux system call directly.
    The system call interface, in this case, talks to the **Virtual** **Filesystem**
    *(*often referred to as the **VFS***)*. The VFS is the abstraction on top of the
    concrete filesystem implementations (for example, ext3, **Journaled File System**
    (**JFS**), and more). This architecture, as we can imagine, gives a high level
    of flexibility.
  prefs: []
  type: TYPE_NORMAL
- en: Learning the Linux fundamentals - shell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A shell is a command interpreter that receives commands in an input, redirects
    them to GNU/Linux, and returns back the output. It is the most common interface
    between a user and GNU/Linux. There are different shell programs available. The
    most used ones are Bash shell (part of the GNU Project), tcsh shell, ksh shell,
    and zsh shell (this is basically an extended Bash shell).
  prefs: []
  type: TYPE_NORMAL
- en: Why would you need a shell? A user needs a shell if they need to interact with
    the operating system through the **command line**. In this recipe, we'll show
    some of the most common shell commands. Quite often, the terms *shell* and *Terminal*
    are used interchangeably, even though, strictly speaking, they are not exactly
    the same thing.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will learn the basic commands to run on the shell—for example,
    to find a file, `grep` a text into a file, copy, and delete:'
  prefs: []
  type: TYPE_NORMAL
- en: Opening a shell: Depending on the GNU/Linux distribution, opening a new shell
    command has different shortcuts. On Ubuntu, press *Ctrl *+ *Alt* + *T*, or press
    *Alt *+ *F2,* then type `gnome-terminal`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Closing a shell: To close Terminal, just type `exit` and press *Enter*.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `find` command: This is used to search files in a directory hierarchy.
    In its simplest form, it appears like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'It supports wildcards, too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `grep` command prints the lines by matching a pattern:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '`grep` also supports recursive search:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Pipe commands: Commands running on the shell can be concatenated, to make the
    output of one command the input for another. The concatenation is done with the
    `|` (pipe) operator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Editing a file: The most two common tools to edit a file on Linux are `vi`
    and `emacs` (if you''re not interested in editing the file, `cat filename` will
    print the file to the standard output). While the first is inherited by the Unix
    operating system, the latter is part of the GNU Project. This book will extensively
    use `vi`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Next, we will look at shell commands related to file manipulation.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the command to remove files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the command to remove directories:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the command to clone a file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the command to clone a folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the command to clone a folder using a relative and absolute path:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The next section will describe these commands.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s have a look at the commands discussed in the *How to do it...* section,
    in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: The first command searches (`.`) from the current folder and can contain absolute
    paths (for example, `/usr/local`) or relative paths (for example, `tmp/binaries`). For
    example, here, `-name` is the file to search.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The second command searches from the `/usr/local` folder any file or folder
    that starts with `python`. The `find` command offers huge flexibility and a wide
    variety of options. For more information, refer to `man page` through the `man
    find` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `grep` command searches and prints any line that contains the word `text` in
    the `filename` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `grep` recursive search command searches and prints any line that contains
    the word `text` in any file recursively from the `/usr/share` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Pipe command (`|`): The output of the first command is shown in the following
    screenshot. A list of all the files and directories is passed as input to the
    second command (`grep`), which will be used to `grep` the filename:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/11e480e2-e934-4db1-8d69-fe05a480546d.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, let's look at the commands that perform actions such as editing a file,
    and adding/removing files and directories.
  prefs: []
  type: TYPE_NORMAL
- en: '**Editing a file**:'
  prefs: []
  type: TYPE_NORMAL
- en: The `vi` command will open the filename in edit mode, assuming the current user
    has writing permissions on it (we will discuss permissions in more detail later).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is a short summary of the most used commands in `vi`:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Shift **+ :* (that is, the *Shift* key + colon) to switch in edit mode.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Shift + :i* to insert.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Shift + :a* to append.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Shift + :q!* to quit the current session without saving.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Shift + :wq* to save and quit the current session.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Shift + :set nu* to show the line numbers on the file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Shift + :23* (*Enter*) goes at line 23.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Press the (*Esc*)key to switch to command mode.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*.* to repeat the last command.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*cw* to change the word, or do this by pointing the cursor at the beginning
    of the word.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*dd to *remove the current line.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*yy* to copy the current line. If a number *N* is selected before the *yy*
    command, the *N* line will be copied.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*p* to paste the copied line with the *yy *command.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*u* to undo.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Adding and removing files and directories**:'
  prefs: []
  type: TYPE_NORMAL
- en: The first command removes the file named `filename`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The second command removes `directoryName` and its content, recursively.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The third command creates `file2`, which is an exact copy of `file1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The fourth command creates `folder2` as a clone of `folder1`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/1d86e0fb-6dda-477a-b460-51fc4ae8f88a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'There is a common pattern in the execution of the commands shown in this recipe.
    They are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The user types a command and hits *Enter*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The command is interpreted by Linux.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Linux interacts with its different parts (memory management, networking, filesystem,
    and more) to execute the command. This happens in kernel space**.**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The results are returned to the user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe showed some of the most recurrent commands. Mastering all the options,
    even just for the most common shell commands, is tricky, and that is why `man
    pages` were created. They contain a solid and clear reference for the Linux user.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Chapter 8](9fd0a0ac-d520-4227-866a-24583b98c69d.xhtml), *Dealing with Console
    I/O and Files*, will go deeper into console I/O and file management.'
  prefs: []
  type: TYPE_NORMAL
- en: Learning the Linux fundamentals - users
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Linux is a multiuser and multitasking operating system, so basic user administration
    skills are a must. This recipe will show you how permissions for files and directories
    are structured, how to add and remove a user, how to change a user's password,
    and how to assign a user to a group.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following series of steps shows useful commands for basic user administration
    activities:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating a user**: Having one user configured for each individual using Linux
    is not just a best practice, it is also recommended. Creating a user is quite
    simple:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The `spacex` user has been created and assigned to the existing `developers`
    group. To switch to the newly created user, log in using the new user''s credentials:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '**Updating a user''s password**: Periodically, the password must be changed.
    Here is the command to do this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '**Assigning a user to a group**: As shown, a user can be assigned to a group
    when created. Alternatively, a user can be assigned to a group at any time, by
    running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '**Removing a user**: Likewise, removing a user is pretty simple:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `-r` option indicates to remove the `spacex` home directory and `mail spool`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s have a look at the final command, which shows a list of the groups
    to which the current user (`spacex`) belongs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `spacex` user belongs to the `developers` and `testers`
    groups.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *step 1*, we used the `adduser` command to add the `spacex` user and, contextually,
    added the user to the `developers` group.
  prefs: []
  type: TYPE_NORMAL
- en: S*tep 2* shows how to change the password of the current user. To change the
    password, the previous password must be provided. It is a good practice to change
    the password periodically.
  prefs: []
  type: TYPE_NORMAL
- en: If we want to assign a user to a group, it can be done with the `usermod` command.
    In *step 3*, we have added the `spacex` user to the `testers` group. The `-a` and `-G` parameters
    just indicate that the new groups (`-G`) will be appended to the current groups (`-a`) of
    the user. That is, the `spacex` user will be assigned to the `testers` group,
    which will be contextually created. The `groups` command, in the same step, shows
    which groups the current user belongs to. If you only want to create a group,
    then `groupadd group-name` is the command you need.
  prefs: []
  type: TYPE_NORMAL
- en: '*Step 4* shows how to remove a user with the `userdel` command, passing the
    `-r` parameter. This parameter ensures that all the files of the user we''re removing
    will be deleted.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'On a Linux filesystem, each file and directory has a set of information defining
    who can do what. The mechanism is simple, as well as powerful. The operations
    allowed on a file (or directory) are read, write, and execute (`r`, `w`, and `x`,
    respectively). These operations can be done by the owner of the file or directory,
    by a group of users, or by all users. Linux represents this information with Owner: `rwx`;
    Group: `rwx`; All Users: `rwx`; or, more simply: `rwx-rwx-rwx` (9 in total). Actually,
    Linux has one more flag on top of these ones that represents the type of file.
    It can be a folder (`d`), a symbolic link to another file (`l`), a regular file
    (`-`), a named pipe (`p`), a socket (`s`), a character device file (`c`), and
    a block device (`b`). Typical permissions for a file look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see this in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: Reading from the left-hand side, the first character, `-`, informs us that `conf.json` is
    a regular file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next three characters are about the current user, `rwx`. The user has full **read** (**r**), **write** (**w**),
    and **execution** (**x**) permissions over the file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next three chars are about the group to which the user belongs, `r-x`. All
    the users belonging to the group can read and execute the file, but cannot modify
    it (`w` is not selected, marked as `-`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last three characters are about all the other users, `r-x`. All other users
    can just read and execute the file (`r` and `x` are marked, but `w` is not).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The owner (or the root user) can change the permissions of the file. The easiest
    way to achieve this is through the `chmod` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we''re asking the Linux kernel to add the write permission (`w`) to the
    group user type (`g`). The types of users are as follows: `u` (for user), `o`
    (for others), `a` (for all), and `g` (for group), and the permissions flag can
    be `x`, `w`, and `r`, as explained previously. `chmod` can also accept an integer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'There is a binary-to-decimal conversion on permission flags for each group
    type, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`wxr`: 111 = 7'
  prefs: []
  type: TYPE_NORMAL
- en: '`w-r`: 101 = 5'
  prefs: []
  type: TYPE_NORMAL
- en: '`--r`: 001 = 1'
  prefs: []
  type: TYPE_NORMAL
- en: It could be a little cryptic at the beginning, but it is very practical and
    handy for everyday use.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `man pages` are an infinite resource of information and should be the first
    thing you look at. Commands such as `man groups`, `man userdel`, or `man adduser` will
    help with this.
  prefs: []
  type: TYPE_NORMAL
- en: Using a makefile to compile and link a program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A makefile is a file that describes the relationship among the sources of a
    program used by the `make` utility to build (compile and link) the target goal
    (executable, shared object, and more). Makefiles are really important as they
    help to keep sources organized and easy to maintain. A program, to become executable,
    must be compiled and linked with other libraries. GCC is the most widely used
    collection of compilers. The two compilers used in the C and C++ world are GCC
    and g++ (for the C and C++ programs, respectively). This book will use g++.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This section will show how a makefile is written, to compile and run a simple
    C++ program. We''ll develop a simple program, and create its makefile to learn
    its rules:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by developing the program by opening the `hello.cpp` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Type in the following code (refer to the *Learning the Linux fundamentals -
    shell* recipe to review the `vi` commands):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Save and exit: in `vi`, from the command mode, type `:wq`, which means write
    and quit. The `:x` command has the same effect.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From the shell, create a new file called `Makefile`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Type in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Although this is a typical `Hello World!`program, it is useful to show how a makefile
    is structured.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Simply, a makefile consists of a set of rules. A rule consists of a target,
    a list of prerequisites, and a command.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the first step, we opened the file (`hello.cpp`) and typed the program listed
    in *step 2*. Likewise, we opened another file, `Makefile`, in the same folder
    of the `hello.cpp` program, and typed the specific makefile commands. Let''s now
    dive into the makefile internals. A typical makefile has the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: The first rule consists of a target called `all`, and a prerequisite called
    `hello`. There is no command for this rule.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The second rule consists of a target called `hello`. It has a prerequisite
    on `hello.o` and a command to link: `g++`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The third rule has a target called `hello.o`, a prerequisite on `hello.cpp`,
    and a command to compile: `g++ -c hello.cpp`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The last rule has a `clean` target with a command to remove all the `hello` and `hello.o` executables.
    This forces the recompilation of the files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For any rule, if any of the source files change, then the command defined is
    executed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We''re now able to compile the program using the makefile we created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re also able to execute the program, whose output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2ffd955d-5371-4d04-a52b-13cf17e6eeaf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The process of generating a binary executable from a source file includes the
    phase of compilation and linking, which here is compressed inside a single command;
    it''ll be like this in most cases. In general, a large system code base relies
    on more sophisticated mechanisms but the steps are still the same: source file
    editing, compilation, and linking.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This simple example just showed us the very basic concepts of a makefile and
    its `make` command. There is much more to it than that. Here are a few examples:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use of macros: A makefile allows the use of macros, which can be seen as **variables**.
    These can be used to organize the makefile to be more modular, for example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A macro for all the dynamic libraries used in the program: `LIBS = -lxyz -labc`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A macro for the compiler itself (in case you want to change to another compiler): `COMPILER
    = GCC`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Reference these macros over all the makefile: `$(CC)`. This gives us the freedom
    to make changes in just one place.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By just typing `make` on a shell, the first rule defined in the makefile will
    run. In our case, the first rule is `all`. If we changed the makefile by putting
    **`clean` **as a first rule, running `make` without parameters would execute the
    `clean` rule. In general, you'll always pass some parameters—for example, `make
    clean`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using GDB to debug a program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Debugging is the process of identifying and removing errors from software systems.
    The GNU/Linux operating system has a **standard** *de facto* tool (that is, not
    part of any standard, but used by almost anybody in the Linux world) called GDB. The
    GDB version installed on this book's Docker is version 8.2.91\. Of course, there
    are graphical tools that can use GDB under the hood, but GDB on Linux is the way
    to go for its reliability, simplicity, and speed. In this recipe, we will debug
    the software we've written in the previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to use some of the GDB commands, we need to modify the previous program
    and add some variables in it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a shell and modify the `hello.cpp` file by typing in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a very simple program: take a variable, add `2` to it, and print the
    result.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s make sure that the program is compiled by typing the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have the executable, we will debug it. From the command line, type `gdb
    hello`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the last line says (`No debugging symbols found in hello`).
    GDB doesn''t have to debug symbols to debug the program, so we have to communicate
    to the compiler that the debug symbols are to be included during the compilation.
    We have to quit the current session; to do this, type `q` (*Enter*]. Then, edit
    the makefile, and add the `-g` option to the `g++` compiler section (the `hello.o`
    target):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s run it again, but, first, we have to rebuild the application with the
    `make` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We're ready to debug it. A debug session typically includes setting breakpoints,
    watching the content of variables, setting watchpoints, and many others. The next
    section will show the most common debug commands.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we have seen the steps necessary to create a program
    and a makefile. In this section, we'll learn how to debug the `Hello World!` program
    we developed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by visualizing the code we''re going to debug. We do this by running
    the `l` command (short for list):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We have to set a breakpoint. To set a breakpoint, we run the `b 5` command.
    This sets a breakpoint to the code line number `5` in the current module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s time to run the program now. To run a program, we type the `r` command.
    This runs the `hello` program we started with GDB:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Once started, GDB will automatically stop at any breakpoint hit by the process
    flow. In this case, the process runs, and then stops at line `5` of the `hello.cpp` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'To proceed step by step, we run the `n` command (that is, step over) on GDB.
    This executes the current visualized line of code. A similar command is `s` (step
    into). If the current command is a function, it steps into the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'If we need to know the content of a variable, we run the `p` command (short
    for print), which prints the content of a variable. In this case, as expected, `x
    = 12` gets printed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s run the program until the end (or until the next breakpoint, if
    set). This is done with the `c` command (short for continue):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: GDB really acts as an interpreter by letting the programmer step the program line
    by line. This helps the developer to troubleshoot problems, see the content of
    variables at runtime, change the status of variables, and more.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'GDB has a lot of very useful commands. In the following chapters, GDB will
    be explored more. There are four more commands to show here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`s`: Short for step. If called on a method, it steps into it.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`bt`: Short for backtrace. Prints the call stack.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`q`: Short for quit. Use to exit GDB.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`d`: Short for delete. It removes a breakpoint. For example, `d 1` removes
    the first breakpoint set.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The main page of the GNU GDB Project can be found here: [https://www.gnu.org/software/gdb](https://www.gnu.org/software/gdb). More
    detailed information can be found on the `man dbg` `man pages` and online. You
    can also refer to *Using GDB: A Guide to the GNU Source-Level Debugger,* by Richard
    M. Stallman and Roland H. Pesch*.*'
  prefs: []
  type: TYPE_NORMAL
- en: Learning the Linux fundamentals - processes and threads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Processes and threads are the execution units of any operating system. In this
    recipe, you'll learn how to deal with processes and threads on GNU/Linux on the
    command line. A process is a running instance of a program with a well-defined
    set of resources such as files, processor state, and threads of execution allocated
    to it.
  prefs: []
  type: TYPE_NORMAL
- en: A process in Linux is defined by the `task_struct` structure defined in the
    `sched.h` header file. On the other hand, a thread is defined by the `thread_info`
    structure in the `thread_info.h` header file. A thread is one possible flow of
    execution of the main process. A process has at least one thread (the main thread).
    All the threads of a process run concurrently on a system.
  prefs: []
  type: TYPE_NORMAL
- en: One aspect to keep in mind on Linux is that it doesn't differentiate between
    processes and threads. A thread is just like a process that shares some resources
    with some other processes. For this reason, in Linux, threads are often referred
    to as a **lightweight process** (**LWP**).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we''ll learn, step by step, all the most common commands to
    control processes and threads on a GNU/Linux distribution:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ps` command shows the processes, attributes, and other parameters in the
    current system:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Another way to get info on a process (and its threads) is to look in the `/process/PID`
    folder. This folder contains all the process info, threads of the process (in
    the form of subfolders with **process identifiers** (**PIDs**)), memory, and much
    more:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'A process can be killed, too. Technically, killing a process means stopping
    its execution:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This command sends the `kill` signal (`9`) to the process identified with the
    PID. Other signals can be sent to processes—for example, `HUP` (hangup) and `INT`
    (interrupt).
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In *s**tep 1* for each process, we can see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The user to whom the process belongs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The PID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The percentage of CPU and memory in a specific moment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the process started, and its running time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The command used to run the process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Through the `ps aux` command, we can grab the PID of the `hello` process, which
    is `172`. We can now look into the `/proc/172` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Processes and threads are building blocks of an operating system. In this recipe,
    we've seen how to interact with the kernel on the command line to get info on
    processes through a command (for example, `ps`), and by looking into a specific
    folder that Linux updates as the process runs. Again, every time we invoke a command
    (to get info on a process, in this case), the command must enter in kernel space
    to get valid and updated info on it.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `ps` command has many more parameters than the basic one seen in this recipe.
    A complete list is available on its Linux man page, `man ps`.
  prefs: []
  type: TYPE_NORMAL
- en: A more advanced and interactive command to consider as an alternative to `ps` is
    the `top` command, `man top`.
  prefs: []
  type: TYPE_NORMAL
- en: Handling a Linux bash error
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've seen that one way to interact with the Linux kernel is through the shell,
    by invoking commands. A command can fail, as we can imagine, and a way to communicate
    a failure is to return a non-negative integer value. 0, in most cases, means success.
    This recipe will show you how to deal with error handling on the shell.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This section will show you how to get errors directly from the shell and via
    a script, which is a fundamental aspect of script development:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new file called `first_script.sh` and type in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Save the file, and exit (`:wq` or `:x`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Give execution permission (the `x` flag) to the current user for the `first_script.sh`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: These steps are detailed in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In *step 1*, the `cp` command failed, as `file` and `file2` don't exist. By
    querying `echo $?`, we get the error code; in this case, it is `1`. This is particularly
    useful when writing bash scripts where we might need to check for a particular
    condition.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 2*, the script just lists the `does_not_exist.txt` file and reads the
    error code returned. If all goes fine, it prints an acknowledgment message and
    returns `0`. Otherwise, it returns the error code `11`.
  prefs: []
  type: TYPE_NORMAL
- en: 'By running the script, we get the output as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5d809462-bb33-4827-9f73-a2cbe6881bbc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, we notice a couple of things:'
  prefs: []
  type: TYPE_NORMAL
- en: We logged our error string.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The error code is the one we had set in the script.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Under the hood, every time a command is invoked, it enters into kernel space.
    The command is executed, and a return status is sent back to the user in the form
    of an integer. It's really important to consider this return status, as we might
    have a command that apparently succeeded (no output) but eventually failed (returns
    code different from `0`).
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One important aspect of the return status of the commands is that it can be
    used to (conditionally) run the next command. Two important operators are used
    for this purpose: `&&` (AND) and `||` (OR).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the two commands here, the second is run if—and only if—the first succeeds
    (the `&&` operator). `file.txt` is removed if it is copied to the project folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s have a look at a second example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the second command is run only if the first fails
    (the `||` operator). `copy failed!` is printed if the copy fails.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we just showed that commands can be combined on a shell script
    to create a more complex command, and by controlling the error code, we can control
    the flow of execution. Man pages are a great resource as they contain all the
    commands and error codes (for example, `man cp` and `man cat`).
  prefs: []
  type: TYPE_NORMAL
- en: Handling Linux code error
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This recipe represents the second side of the coin in the topic of error handling:
    error handling at a source-code level. Linux *exposes* its kernel features through
    commands, as well as through a programming API. In this recipe, we''ll see how
    to deal with error codes and `errno` through a C program, to open a file.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we''ll see how to get the error from a system call in a C
    program. To do this, we''ll create a program to open a non-existent file and show
    the details of the error returned by Linux:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file: `open_file.c`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Edit the following code in the newly created file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Save the file and exit (`:x`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compile the code: `gcc open_file.c`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The preceding compilation (without parameters) will produce a binary file called `a.out`
    (which is the default name on the Linux and Unix operating systems).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The program listed tries to open a file in reading mode. Errors are printed
    on standard error, through the `fprintf` command. By running it, the output will
    be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ec4464be-3ce9-4b95-b6fe-e888f82b52dd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'There are a couple of considerations to highlight. The program is developed
    by strictly following the man page of the open system call (`man 2 open`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The developer (us, in this case) checked that the file descriptor was `-1` (confirmed
    by `fprintf`) to print `errno` too (with code `2`). What does `errno 2` mean? `strerror` is
    useful exactly for this scope, to translate from `errno` (which is cryptic) to
    something the programmer (or the user) would understand.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 2](1bf083f4-9d12-4b2e-bf5c-35a2e3d99c36.xhtml), *Revisiting C++*,
    we'll see how C++ helps programmers by providing higher-level mechanisms, and
    easy-to-write and more concise code. Even if we try to minimize the interaction
    with the kernel API directly, in favor of the use of the C++11-14-17 higher-level
    mechanism, there will be cases where we'll need to check the error status. In
    those cases, you are invited to pay attention to error management.
  prefs: []
  type: TYPE_NORMAL
