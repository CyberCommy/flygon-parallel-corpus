- en: Chapter 2. New Features in PHP 7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PHP 7 has introduced new features that can help programmers write high-performing
    and effective code. Also, some old-fashioned features are completely removed,
    and PHP 7 will throw an error if used. Most of the fatal errors are now exceptions,
    so PHP won't show an ugly fatal error message any more; instead, it will go through
    an exception with the available details.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Type hints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Namespaces and group use declarations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The anonymous classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Old-style constructor deprecation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Spaceship operator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The null coalesce operator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uniform variable syntax
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Miscellaneous changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OOP features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PHP 7 introduced a few new OOP features that will enable developers to write
    clean and effective code. In this section, we will discuss these features.
  prefs: []
  type: TYPE_NORMAL
- en: Type hints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Prior to PHP 7, there was no need to declare the data type of the arguments
    passed to a function or class method. Also, there was no need to mention the return
    data type. Any data type can be passed to and returned from a function or method.
    This is one of the huge problems in PHP, in which it is not always clear which
    data types should be passed or received from a function or method. To fix this
    problem, PHP 7 introduced type hints. As of now, two type hints are introduced:
    scalar and return type hints. These are discussed in the following sections.'
  prefs: []
  type: TYPE_NORMAL
- en: Type hints is a feature in both OOP and procedural PHP because it can be used
    for both procedural functions and object methods.
  prefs: []
  type: TYPE_NORMAL
- en: Scalar type hints
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'PHP 7 made it possible to use scalar type hints for integers, floats, strings,
    and Booleans for both functions and methods. Let''s have a look at the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we created a `Person` class. We have three methods, and
    each method receives different arguments whose data types are defined with them,
    as is highlighted in the preceding code. If you run the preceding code, it will
    work fine as we will pass the desired data types for each method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Age can be a float, such as `30.5` years; so, if we pass a float number to
    the `age` method, it will still work, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Why is that? It is because, by default, *scalar type hints are nonrestrictive*.
    This means that we can pass float numbers to a method that expects an integer
    number.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make it more restrictive, the following single-line code can be placed at
    the top of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we pass a float number to the `age` function, we will get an **Uncaught
    Type Error**, which is a fatal error that tells us that `Person::age` must be
    of the int type given the float. Similar errors will be generated if we pass a
    string to a method that is not of the string type. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code will generate the fatal error as the string is passed to
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Return type hints
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Another important feature of PHP 7 is the ability to define the return data
    type for a function or method. It behaves the same way scalar type hints behave.
    Let''s modify our `Person` class a little to understand return type hints, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The changes in the class are highlighted. The return type is defined using
    the`: data-type` syntax. It does not matter if the return type is the same as
    the scalar type. These can be different as long as they match their respective
    data types.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s try an example with the object return type. Consider the previous
    `Person` class and add a `getAddress` method to it. Also, we will add a new class,
    `Address`, to the same file, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The additional code added to the `Person` class and the new `Address` class
    is highlighted. Now, if we call the `getAddress` method of the `Person` class,
    it will work perfectly and won''t throw an error. However, let''s suppose that
    we change the return statement, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, the preceding method will throw an *uncaught* exception similar
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This is because we return an array instead of an `Address` object. Now, the
    question is: why use type hints? The big advantage of using type hints is that
    it will always avoid accidentally passing or returning wrong and unexpected data
    to methods or functions.'
  prefs: []
  type: TYPE_NORMAL
- en: As can be seen in the preceding examples, this makes the code clear, and by
    looking at the declarations of the methods, one can exactly know which data types
    should be passed to each of the methods and what kind of data is returned by looking
    into the code of each method or comment, if any.
  prefs: []
  type: TYPE_NORMAL
- en: Namespaces and group use declaration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In a very large codebase, classes are divided into namespaces, which makes them
    easy to manage and work with. However, if there are too many classes in a namespace
    and we need to use 10 of them, then we have to type the complete use statement
    for all these classes.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In PHP, it is not required to divide classes in subfolders according to their
    namespace, as is the case with other programming languages. Namespaces just provide
    a logical separation of classes. However, we are not limited to placing our classes
    in subfolders according to our namespaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we have a `Publishers/Packt` namespace and the classes `Book`,
    `Ebook`, `Video`, and `Presentation`. Also, we have a `functions.php` file, which
    has our normal functions and is in the same `Publishers/Packt` namespace. Another
    file, `constants.php`, has the constant values required for the application and
    is in the same namespace. The code for each class and the `functions.php` and
    `constants.php` files is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the code for the `Ebook` class is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The code for the `Video` class is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, the code for the `presentation` class is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: All the four classes have the same methods, which return the classes' names
    using the PHP built-in `get_class()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add the following two functions to the `functions.php` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s add the following code to the `constants.php` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The code in both `functions.php` and `constants.php` is self-explanatory. Note
    that each file has a `namespace Publishers/Packt` line at the top, which makes
    these classes, functions, and constants belong to this namespace.
  prefs: []
  type: TYPE_NORMAL
- en: Now, there are three ways to use the classes, functions, and constants. Let's
    consider each one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we used namespace names directly while creating objects
    or using functions and constants. The code looks fine, but it is cluttered. Namespace
    is everywhere, and if we have lots of namespaces, it will look very ugly, and
    the readability will be affected.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We did not include class files in the previous code. Either the `include` statements
    or PHP's `__autoload` function can be used to include all the files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s rewrite the preceding code to make it more readable, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, at the top, we used PHP statements for specific classes,
    functions, and constants in a namespace. However, we still wrote duplicate lines
    of code for each class, function, and/or constant. This may lead to us have lots
    of use statements at the top of the file, and the overall verbosity would not
    be good.
  prefs: []
  type: TYPE_NORMAL
- en: 'To fix this problem, PHP 7 introduced group use declaration. There are three
    types of group use declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: Non mixed use declarations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mixed use declarations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compound use declarations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Non mixed group use declarations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Consider that we have different types of features in a namespace, as we have
    classes, functions, and contacts in a namespace. In non mixed group use declarations,
    we declare them separately using a `use` statement. To better understand it, take
    a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We have three types of features in a namespace: class, functions, and constants.
    So, we have used separate group `use` declaration statements to use them. The
    code is now looking more cleaner, organized, and readable and doesn''t require
    too much duplicate typing.'
  prefs: []
  type: TYPE_NORMAL
- en: Mixed group use declarations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this declaration, we combine all types into a single `use` statement. Take
    a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The compound namespace declaration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To understand the compound namespace declaration, we will consider the following
    criteria.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say we have a `Book` class in the `Publishers\Packt\Paper` namespace.
    Also, we have an `Ebook` class in the `Publishers\Packt\Electronic` namespace.
    The `Video` and `Presentation` classes are in the `Publishers\Packt\Media` namespace.
    So, to use these classes, we will use the code, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In the compound namespace declaration, we can use the preceding namespaces
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: It is more elegant and clear, and it doesn't require extra typing if the namespace
    names are long.
  prefs: []
  type: TYPE_NORMAL
- en: The anonymous classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An anonymous class is a class that is declared and instantiated at the same
    time. It does not have a name and can have the full features of a normal class.
    These classes are useful when a single one-time small task is required to be performed
    and there is no need to write a full-blown class for it.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While creating an anonymous class, it is not named, but it is named internally
    in PHP with a unique reference based on its address in the memory block. For example,
    the internal name of an anonymous class may be `class@0x4f6a8d124`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax of this class is the same as that of the named classes, but only
    the name of the class is missing, as shown in the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look at a basic and very simple example of an anonymous class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code will just display the output as `Altaf Hussain`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Arguments can also be passed to the *anonymous class constructor*, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This will give us the same output as the first example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Anonymous classes can extend other classes and have the same parent-child classes
    functioning as normal named classes. Let''s have another example; take a look
    at the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code will display `I am parent constructor` and `5`. As can be
    seen, we extended the `Packt` class the way we extend named classes. Also, we
    can access the `public` and `protected` properties and methods within the anonymous
    class and public properties and methods using anonymous class objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Anonymous classes can implement interfaces too, the same as named classes.
    Let''s create an interface first. Run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s modify our `Packt` class as follows. We added the highlighted code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The rest of the code is same as the first `Packt` class. Now, let''s create
    our anonymous class, which will implement the `Publishers` interface created in
    the previous code and extend the new `Packt` class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is self-explanatory and will output `Altaf Hussain` along
    with the address.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is possible to use anonymous classes within another class, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will return `60`. How does this happen? The `Math` class
    has a `multiply_sum` method that returns the object of an anonymous class. This
    anonymous class is extended from the `Math` class and has a `multiply` method.
    So, our `echo` statement can be divided into two parts: the first is `$math->multiply_sum()`,
    which returns the object of the anonymous class, and the second is `->multiply(2)`,
    in which we chained this object to call the anonymous class''s `multiply` method
    along with an argument of the value `2`.'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding case, the `Math` class can be called the outer class, and the
    anonymous class can be called the inner class. However, remember that it is not
    required for the inner class to extend the outer class. In the preceding example,
    we extended it just to ensure that the inner classes could have access to the
    outer classes' properties and methods by extending the outer classes.
  prefs: []
  type: TYPE_NORMAL
- en: Old-style constructor deprecation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Back in PHP 4, the constructor of a class has the same name method as that
    of the class. It is still used and is valid until PHP''s 5.6 version. However,
    now, in PHP 7, it is deprecated. Let''s have an example, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will display the output `I am an old style constructor`
    with a deprecated message, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'However, the old style constructor is still called. Now, let''s add the PHP
    `__construct` method to our class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, when we instantiated the object of the class, the normal
    `__construct` constructor was called. The `packt()`method isn't considered a normal
    class method.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Old-style constructors are deprecated, which means that they will still work
    in PHP 7 and a deprecated message will be displayed, but it will be removed in
    the upcoming versions. It is best practice to not use them.
  prefs: []
  type: TYPE_NORMAL
- en: The throwable interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: PHP 7 introduced a base interface that can be base for every object that can
    use the `throw` statement. In PHP, exceptions and errors can occur. Previously,
    exceptions could be handled, but it was not possible to handle errors, and thus,
    any fatal error caused the complete application or a part of the application to
    halt. To make errors (the most fatal errors) catchable as well, PHP 7 introduced
    the *throwable* interface, which is implemented by both the exception and error.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The PHP classes we created can't implement the throwable interface. If required,
    these classes must extend an exception.
  prefs: []
  type: TYPE_NORMAL
- en: We all know exceptions, so in this topic, we will only discuss errors, which
    can handle the ugly, fatal errors.
  prefs: []
  type: TYPE_NORMAL
- en: Error
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Almost all fatal errors can now throw an error instance, and similarly to exceptions,
    error instances can be caught using the `try/catch` block. Let''s have a simple
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: If the preceding code is executed, a fatal error will be displayed, the application
    will be halted, and the `echo` statement won't be executed in the end.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s place the function call in the `try/catch` block, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Now, if the preceding code is executed, the `catch` body will be executed, and
    after this, the rest of the application will continue running. In the preceding
    case, the `echo` statement will be executed.
  prefs: []
  type: TYPE_NORMAL
- en: In most cases, the error instance will be thrown for the most fatal errors,
    but for some errors, a subinstance of error will be thrown, such as `TypeError`,
    `DivisionByZeroError`, `ParseError`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s take a look at a `DivisionByZeroError` exception in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Before PHP 7, the preceding code would have issued a warning about the division
    by zero. However, now in PHP 7, it will throw a `DivisionByZeroError`, which can
    be handled.
  prefs: []
  type: TYPE_NORMAL
- en: New operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PHP 7 introduced two interested operators. These operators can help write less
    and cleaner code, so the final code will be more readable as compared to the traditional
    operators in use. Let's have a look at them.
  prefs: []
  type: TYPE_NORMAL
- en: The Spaceship operator (<=>)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Spaceship or Combined Comparison operator is useful to compare values (strings,
    integers, floats, and so on), arrays, and objects. This operator is just a wrapper
    and performs the same tasks as the three comparison operators `==`, `<`, and `>`.
    This operator can also be used to write clean and less code for callback functions
    for `usort`, `uasort`, and `uksort`. This operator works as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: It returns 0 if both the operands on left- and right-hand sides are equal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It returns -1 if the right operand is greater than the left operand
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It returns 1 if the left operand is greater than the right one
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s take a look at a few examples by comparing integers, strings, objects,
    and arrays and note the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the preceding code, and you will have an output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: In the first comparison, in which we compare `$int1` and `$int3`, both are equal,
    so it will return `0`. In the second comparison, in which `$int1` and `$int2`
    are compared, it will return `-1` because the right operand (`$int2`) in greater
    than the left operand (`$int1`). Finally, the third comparison will return `1`
    as the left operand (`$int2`) is greater than the right operand (`$int3`).
  prefs: []
  type: TYPE_NORMAL
- en: The preceding is a simple example in which we compared integers. We can check
    strings, objects, and arrays in the same way, and they are compared the same standard
    PHP way.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some examples for the `<=>` operator can be found at [https://wiki.php.net/rfc/combined-comparison-operator](https://wiki.php.net/rfc/combined-comparison-operator).
    This is an RFC publication that has more useful details about its usage.
  prefs: []
  type: TYPE_NORMAL
- en: 'This operator can be more useful in sorting arrays. Take a look at the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we used two functions to sort the two different arrays
    with the same values. The `$normalArray` array is sorted by the `normal_sort`
    function, in which the `normal_sort` function uses `if` statements to compare
    the values. The second array `$spaceArray` has the same values as `$normalArray`,
    but this array is sorted by the `space_sort` function, which uses the Spaceship
    operator. The final result for both array sorts is the same, but the code in the
    callback functions is different. The `normal_sort` function has `if` statements
    and multiple lines of code, while the `space_sort` function has a single line
    of code—that's it! The `space_sort` function code is clearer and does not require
    multiple if statements.
  prefs: []
  type: TYPE_NORMAL
- en: The null coalesce operator(??)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We all know ternary operators, and we use them most of the time. Ternary operators
    are just a single-line replacement for *if-else* statements. For example, consider
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'If `$_POST[''title'']` exists, then the `$post` variable will be assigned its
    value; otherwise, `NULL` will be assigned. However, if `$_POST` or `$_POST[''title'']`
    does not exist or is null, then PHP will issue a notice of *Undefined index*.
    To fix this notice, we need to use the `isset` function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Mostly, it will seem fine, but it becomes very nasty when we have to check for
    values in multiple places, especially when using PHP as a templating language.
  prefs: []
  type: TYPE_NORMAL
- en: 'In PHP 7, the coalescence operator is introduced, which is simple and returns
    the value of its first operand (left operand) if it exists and is not null. Otherwise,
    it returns its second operand (right operand). Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This example is exactly similar to the preceding code. The coalesce operator
    checks whether `$_POST['title']` exists. If it does, the operator returns it;
    otherwise, it returns `NULL`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another great feature of this operator is that it can be chained. Here''s an
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: According to the definition, it will first check whether the first operand exists
    and return it; if it does not exist, it will return the second operand. Now, if
    there is another coalesce operator used on the second operand, the same rule will
    be applied, and the value on the left operand will be returned if it exists. Otherwise,
    the value of the right operand will be returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the preceding code is the same as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: As can be noted in the preceding examples, the coalesce operator can help write
    clean, concise, and less code.
  prefs: []
  type: TYPE_NORMAL
- en: Uniform variable syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Most of the time, we may face a situation in which the method, variable, or
    classes names are stored in other variables. Take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, first, `$objects['class']` will be interpreted, and after
    this, the property name will be interpreted. As shown in the preceding example,
    variables are normally evaluated from left to right.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, consider the following scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'In PHP 5.x, this code would be executed, and the output would be `Howdy`. However,
    this is not inconsistent with the left-to-right expression evaluation. This is
    because `$$first` should be evaluated first and then the index name, but in the
    preceding case, it is evaluated as `${$first[''name'']}`. It is clear that the
    variable syntax is not consistent and may create confusion. To avoid this inconsistency,
    PHP 7 introduced a new syntax called uniform variable syntax. Without using this
    syntax, the preceding example will bring it into notice, and the desired results
    won''t be produced. To make it work in PHP 7, the curly brackets should be added,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s have another example, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: If the preceding code is executed in PHP 5.x, it will work fine and output our
    desired result. However, if we execute this code in PHP 7, it will give a fatal
    error. The error will be at the last line of the code, which is highlighted. PHP
    7 will first try to evaluate `$object->$method.` After this, it will try to evaluate
    `['title']`; and so on; this is not correct.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make it work in PHP 7, the curly brackets should be added, as in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: After making the changes mentioned before, we will get our desired output.
  prefs: []
  type: TYPE_NORMAL
- en: Miscellaneous features and changes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PHP 7 also introduced some other new features with small changes, such as new
    syntax for array constants, multiple default cases in `switch` statement, options
    array in `session_start`, and so on. Let's have a look at these too.
  prefs: []
  type: TYPE_NORMAL
- en: Constant arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Starting with PHP 5.6, constant arrays can be initialized using the `const`
    keyword, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, starting with PHP 7, constant arrays can be initialized using the `define`
    function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Multiple default cases in the switch statement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Prior to PHP 7, multiple default cases in a switch statement were allowed.
    Check out the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Before PHP 7, the preceding code was allowed, but in PHP 7, this will result
    in a fatal error similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The options array for session_start function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before PHP 7, whenever we needed to start a session, we just used the `session_start()`
    function. This function did not take any arguments, and all the settings defined
    in `php.ini` were used. Now, starting with PHP 7, an optional array for options
    can be passed, which will override the session settings in the `php.ini` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple example is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: As can be seen in the preceding example, it is possible to override the `php.ini`
    settings for a session easily.
  prefs: []
  type: TYPE_NORMAL
- en: Filtered unserialize function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is common practice to serialize and unserialize objects. However, the PHP
    `unserialize()` function was not secure because it did not have any filtering
    options and could unserialize objects of any type. PHP 7 introduced filtering
    in this function. The default filtering option is to unserialize objects of all
    classes or types. Its basic working is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed new OOP features, such as type hints, anonymous
    classes, the throwable interface, group use declaration for namespaces, and two
    important new operators, the Spaceship or Combined Comparison operator and the
    null Coalesce operator. Also, we discussed the uniform variable syntax and a few
    other new features, such as new syntax for the contact array definition, options
    array for the `session_start()` function, and removal of multiple default cases
    in the switch statement.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss how to improve the application's performance.
    We will discuss Apache and NGINX and different settings for them to improve performance.
  prefs: []
  type: TYPE_NORMAL
- en: We will discuss different settings for PHP to improve its performance. The Google
    page speed module, CSS/JavaScript combining and compression, CDN, and so on will
    also be discussed.
  prefs: []
  type: TYPE_NORMAL
