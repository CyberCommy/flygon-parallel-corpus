- en: Applying Recursive Algorithms - Recursion
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Solving complex problems is always hard. Even for programmers, solving complex
    problems can prove tougher, and sometimes, a special solution is required. Recursion
    is one such special approach that computer programmers follow to solve complex
    problems. In this chapter, we will go through the definition of recursion, properties,
    different types of recursions, and lots of examples. Recursion is not a new concept;
    in nature, we see lots of recursive elements. Fractals show recursive behavior.
    The following image shows natural recursion:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00032.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
- en: Understanding recursion
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Recursion is a way to solve larger problems by dividing them into smaller problems.
    In other words, recursion is breaking the big problem into smaller similar problems
    to solve them and get the actual results. Often, recursion is termed as a function
    calling itself. It might sound strange, but the fact is the function must call
    itself when it is in recursion. What does this look like? Let's look at an example,
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: 'In mathematics, the term "factorial" is very popular. A factorial of a number
    *N* is defined as multiplication of all positive integers less than and equal
    to *N* . It is always denoted with *!* (an exclamation mark). So, a factorial
    of *5* can be written as follows:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: '*5! = 5 X 4 X 3 X 2 X 1*'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, we can write the following factorials of the given number::'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: '*4! = 4 X 3 X 2 X 1*'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: '*3! = 3 X 2 X 1*'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: '*2! = 2 X 1*'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '*1! = 1*'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: 'If we look closely at our example, we can see that we can write factorial of
    *5* in terms of factorials of *4* like this:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '*5! = 5 X 4!*'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, we can write:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '*4! = 4 X 3!*'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '*3! = 3 X 2!*'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '*2! = 2 X 1!*'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '*1! = 1 X 0!*'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '*0! = 1*'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, we can simply say in general terms that:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '*n! = n * (n-1)!*'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: 'This represents recursion. We are breaking each of the steps into smaller ones
    and solving the actual big problem. Here is an image to show how a factorial of
    3 is calculated:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00033.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
- en: 'So, the steps are as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '*3! = 3 X 2!*'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*2! = 2 X 1!*'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*1! = 1 X 0!*'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*0! = 1*'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*1! = 1 X 1 = 1*'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*2! = 2 X 1 = 2*'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*3! = 3 X 2 = 6*'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Properties of recursive algorithms
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, the question can be, "If a function calls itself, then how does it stop
    or know when to finish the recursive call?" When we are writing a recursive solution,
    we have to make sure it has the following properties:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Each recursive call should be on a smaller subproblem. Like the factorial example,
    a factorial of 6 is solved with 6 and multiplication of a factorial of 5 and so
    it goes on.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It must have a base case. When the base case is reached, there will be no further
    recursion, and the base case must be able to solve the problem without any further
    recursive call. In our factorial example, we did not go any further down from
    0\. So, in this case, 0 is our base case.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There should not be any cycle. If each recursive call makes a call to the same
    problem, then there will be a never-ending cycle. After some repetitions, the
    computer will show a stack overflow error.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'So, if we now write our factorial program using PHP 7, then it will look like
    this:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the preceding example code, we can see that we have a base condition where
    we are returning `1` when the value of `$n` is `0` . If this condition is not
    met, then we are returning a multiplication of `$n` and a factorial of `$n-1`
    . So, it satisfies property to both numbers, 1 and 3\. We are avoiding cycles
    and also making sure each recursive call is creating a subproblem of the bigger
    one. We will write the recursive behavior like this algorithm:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00034.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
- en: Recursion versus iterative algorithms
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If we analyze our factorial function, we can see that it could be written using
    a simple iterative approach with a `for` or `while` loop, as shown here:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If this can be written as a simple iterative one, then why should we use recursion?
    Recursion is used to solve more complex problems. Not all problems can be solved
    iteratively so easily. For example, we need to show all the files in a certain
    directory. We can simply do this by running a loop to list all the files. However,
    what if there is another directory inside it? Then, we have to run another loop
    to get all those files inside that directory. What if there is another directory
    inside that directory and it goes on and on? In such a situation, an iterative
    approach might not help at all or might create a complex solution. It is better
    to choose a recursive approach here.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: Recursion manages a call stack for managing function calls. As a result, recursion
    will take more memory and time to complete compared to iteration. Also, in iteration,
    in each step, we can have a result, but for recursion, we have to wait until the
    base case to execute to get any result. If we consider both iterative and recursive
    examples for a factorial, we can see that there is a local variable called `$result`
    to store the calculation of each step. However, in recursion, there is no need
    for local variables or assignment.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Implementing Fibonacci numbers using recursion
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In mathematics, Fibonacci numbers are special integer sequences where a number
    is composed from summation of the past two numbers, as shown in the following
    the expression:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00035.gif)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
- en: 'If we implement this using PHP 7, it will look like this:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If we consider the preceding implementation, we can see it is a bit different
    from the previous examples. Now, we are calling two functions from one function
    call. We will discuss different types of recursions shortly.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Implementing GCD calculation using recursion
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another common use of recursion is implementing **Greatest Common Division**
    (**GCD** ) of two numbers. In GCD calculation, we will continue until a remainder
    becomes 0\. It can be expressed as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00036.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
- en: 'Now, if we implement recursively using PHP 7, it will look like this:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Another interesting part of this implementation is that unlike a factorial,
    we are not returning from a base case to other steps in the call stack. The base
    case will return the calculated value. This is one of the optimized ways to do
    recursion.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: Different types of recursions
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have seen some example cases of recursion and how it is being used.
    Though the term says recursion, there are different types of recursions. We will
    explore them one by one.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: Linear recursion
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most commonly used recursions in the programming world is linear
    recursion. When a function calls itself once in each run, we will call it a linear
    recursion. Just like our factorial example, when we are breaking the big calculation
    to smaller ones until the base condition is reached, we call it winding. When
    we are returning from the base condition to the first recursive call, we call
    it unwinding. We will work on different linear recursions in the upcoming section
    in this chapter.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: Binary recursion
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In binary recursion, the function calls itself twice in each run. As a result,
    the calculation depends on two results from two different recursive calls to itself.
    If we look at our Fibonacci sequence generation recursive function, we can easily
    find that it is a binary recursion. Other than this, we have many commonly used
    binary recursions in the programming world, such as binary search, divide and
    conquer, merge sort, and so on. The following image shows a binary recursion:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00037.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
- en: Tail recursion
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A recursive method is tail recursive when there is no pending operation to be
    performed on return. For example, in our factorial code, the returned value is
    used to multiply with the previous value to calculate the factorial. So, this
    is not tail recursive. The same goes for the Fibonacci series recursion. If we
    look at our GCD recursion, we can find that there is no operation to do after
    the return. So, the final return or base case return is actually the answer. So,
    GCD is an example of tail recursion. Tail recursion is also a form of linear recursion.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: Mutual recursion
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It might be the case that we may require to call two different methods recursively
    from two different methods in an alternate fashion. For example, function `A()`
    calls function `B()` and function `B()` calls function `A()` in each call. This
    is known as mutual recursion.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: Nested recursion
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When a recursive function call has itself as the parameter, then it is called
    nested recursion. One of the common examples of nested recursion is the Ackermann
    function. Look at the following equation:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00038.gif)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
- en: If we look at the last line, we can see that function `A ()` is called recursively,
    but the second parameter itself is another recursive call. So, this is one of
    the examples of nested recursions.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: Though there are different types of recursions available, we will only use those
    that are required based on our needs. Now, we will see some real-life usage of
    recursion in our projects.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: Building an N-level category tree using recursion
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Building a multilevel nested category tree or menu is always a problem. Many
    CMS and sites only allow a certain level of nesting. In order to save performance
    issues due to multiple joins, some only allow 3-4 levels of nesting at maximum.
    Now, we will explore how we can create an N-level nested category tree or menu
    with the help of recursion, without compromising on performance. Here is our approach
    for the solution:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: We will define the table structure for the category in the database.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will get all categories in the table without the use of any join or multiple
    queries. It will be a single database query with a simple select statement.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will build an array of categories such that we can utilize the recursion
    with that to display the nested categories or menu.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s assume that we have a simple table structure in our database to store
    our categories and it looks like this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'For simplicity, we are assuming that there is no other field required in the
    table. Also, we have some data in the table like this:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '| **Id** | **categoryName** | **parentCategory** | **sortInd** |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
- en: '| 1 | First | 0 | 0 |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
- en: '| 2 | Second | 1 | 0 |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
- en: '| 3 | Third | 1 | 1 |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
- en: '| 4 | Fourth | 3 | 0 |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
- en: '| 5 | Fifth | 4 | 0 |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
- en: '| 6 | Sixth | 5 | 0 |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
- en: '| 7 | Seventh | 6 | 0 |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
- en: '| 8 | Eight | 7 | 0 |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
- en: '| 9 | Ninth | 1 | 0 |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
- en: '| 10 | Tenth | 2 | 1 |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
- en: 'Now, we have created a table structured for our database, and we have assumingly
    also entered some sample data. Let''s build a query to retrieve this data so that
    we can move to our recursive solution:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The core part of the preceding code is how we are storing our categories in
    an array. We are storing the results based on their parent category. This will
    help us show child categories of a category recursively. This looks pretty simple.
    Now, based on the categories array, let''s write the recursive function to show
    the categories hierarchically:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The preceding code actually shows all the categories and their child categories
    recursively. We take a level and first print the category on that level. Immediately,
    we will check whether it has any child level categories or not with the code `showCategoryTree($categories,
    $category->id)` . Now, if we call the recursive function with a root level (level
    0), then we will have the following output:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The output for this will be as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As we can see, without thinking about the depth of the category level or multiple
    queries, we can build nested categories or menus with just a simple query and
    recursive function. We can use `<ul>` and `<li>` to create a nested menu if we
    want it with dynamic show and hide functionality. This can be vital for having
    an efficient solution to the problem without getting into implementation blocks,
    such as having a fixed level of joins or fixed level of categories. The preceding
    example is a perfect display of tail recursion where we are not waiting for the
    recursion to return anything, and as we move forward, the results are already
    displayed.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: Building a nested comment reply system
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Quite often, we face the challenge to display comment replies in a proper way.
    Showing them chronologically does not fit our need sometimes. We may require showing
    them in such a way that the reply for each comment is below the actual comment
    itself. In other words, we can say we need a nested comment reply system or threaded
    comments. We want to build something similar to the following screenshot:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00039.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
- en: 'We can follow the same steps we did in the nested category section. However,
    this time, we will have some UI elements to give it a more realistic look. Let''s
    assume that we have a table named `comments` with the following data and columns.
    For simplicity, we are not going into multiple table relationships. We are assuming
    that the usernames are stored in the same table with the comments:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '| **Id** | **comments** | **username** | **Datetime** | **parentID** | **postID**
    |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
- en: '| 1 | First comment | Mizan | 2016-10-01 15:10:20 | 0 | 1 |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
- en: '| 2 | First reply | Adiyan | 2016-10-02 04:09:10 | 1 | 1 |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
- en: '| 3 | Reply of first reply | Mikhael | 2016-10-03 11:10:47 | 2 | 1 |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
- en: '| 4 | Reply of reply of first reply | Arshad | 2016-10-04 21:22:45 | 3 | 1
    |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
- en: '| 5 | Reply of reply of reply of first reply | Anam | 2016-10-05 12:01:29 |
    4 | 1 |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
- en: '| 6 | Second comment | Keith | 2016-10-01 15:10:20 | 0 | 1 |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
- en: '| 7 | First comment of second post | Milon | 2016-10-02 04:09:10 | 0 | 2 |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
- en: '| 8 | Third comment | Ikrum | 2016-10-03 11:10:47 | 0 | 1 |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
- en: '| 9 | Second comment of second post | Ahmed | 2016-10-04 21:22:45 | 0 | 2 |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
- en: '| 10 | Reply of second comment of second post | Afsar | 2016-10-18 05:18:24
    | 9 | 2 |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
- en: 'Let''s now write a prepared statement to fetch all the comments from a post.
    Then, we can construct an array similar to the nested category one:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, we have the array and all required data in it; we can now write a function
    that will call recursively to display the comment with proper indentations:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Since we have added some HTML elements in the PHP code, we need some basic
    CSS to make it work. Here is the CSS code we have written to make it a clean design.
    Nothing fancy, but pure CSS to create the cascading effects and some basic styling
    for each section of the comment:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As mentioned earlier, we are not trying to make something complex here, just
    responsive, device friendly, and so on. We are assuming that you can integrate
    the logic in different parts of your application without any problem.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the output from the data and the preceding code:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00040.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
- en: From the preceding two examples, we can see that it is very easy to create nested
    contents without having multiple queries or having a limitation of join statements
    for nesting. We do not even require a self-join to generate the nested data.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Finding files and directories using recursion
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Quite often, we need to find all the files inside a directory. This includes
    all subdirectories inside it and also directories inside those subdirectories.
    As a result, we need a recursive solution to find the list of files from the given
    directory. The following example will show a simple recursive function to list
    all the files in a directory:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `showFiles` function actually takes a directory and first scans the directory
    to list all the files and directories under it. Then, with a `foreach` loop, it
    iterates through each file and directory. If it is a directory, we recall the
    `.` function again to list the files and directories under it. This continues
    until we traverse all the files and directories. Now, we have all the files under
    the `$files` array. Now, let''s show the files using a `foreach` loop sequentially:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This will have the following output in the command line:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: These were solutions for some common challenges we face during development.
    However, there are other places where we will use recursion heavily, such as binary
    search, trees, divide and conquer algorithm, and so on. We will discuss them in
    the upcoming chapters.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing recursive algorithms
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Analysis of recursive algorithms depends on the type of recursion we are using.
    If it is linear, the complexity will be different; if it is binary, it will have
    a different complexity. So, we do not have a generic complexity for the recursive
    algorithms. We have to analyze it on a case-by-case basis. Here, we will analyze
    factorial series. First, let''s focus on the factorial part. If we recall from
    this section, we had something like this for factorial recursion:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let''s assume that it will take `T(n)` to compute factorial (`$n` ). We will
    focus on how to use this `T(n)` in terms of the Big O notation. Each time we call
    the factorial function, there are certain steps involved:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: Every time, we are checking the base case.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we call factorial (`$n-1` ) on each loop.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We do a multiplication with `$n` on each loop.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we return the result.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, if we represent this using `T(n)` , then we can say:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '*T(n) = a when n = 0*'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '*T(n) = T(n-1) + b when n > 0*'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, both *a* and *b* are some constants. Now, let''s generate a relationship
    between *a* and *b* with *n* . We can easily write the equation as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '*T(0) = a*'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '*T(1) = T(0) + b = a + b*'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '*T(2) = T(1) + b = a + b + b = a + 2b*'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '*T(3) = T(2) + b = a + 2b + b = a + 3b*'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '*T(4) = T(3) + b = a + 3b + b = a + 4b*'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see that a pattern is emerging here. So, we can establish that:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '*T(n) = a + (n) b*'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, we can also say in simple terms that `T(n) = O(n)` .
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: So, the factorial recursion has a linear complexity of `O(n)` .
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: A fibonacci sequence with recursion has approximately `O(2^n )` complexity.
    The calculation is very elaborative as we have to consider both the lower bound
    and upper bound for the Big O notation. In the upcoming chapters, we will also
    analyze binary recursion such as binary search and merge sorts. We will focus
    more on recursive analysis in those chapters.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Maximum recursion depth in PHP
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since recursion is the process when a function calls itself, we can have a
    valid question in mind such as "how deep can we go with this recursion?". Let''s
    do a small program for this:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Can we guess the max depth level? The depth reached 917,056 levels before exhausting
    the memory limit. If **XDebug** is enabled, then the limit will be much less compared
    to this. It also depends on your memory, OS, and PHP settings such as memory limit
    and max execution time.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Though we have the option to go very deep with our recursion, it is always important
    to remember that we must have control with our recursive function. We should know
    the base conditions and where the recursion must end. Otherwise, it might create
    some wrong results or end abruptly.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: Using SPL recursive iterators
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Standard PHP Library SPL has many built-in iterators for recursion purposes.
    We can use them as per our need, without taking the pain of implementing them
    from scratch. Here is the list of iterators and their functionality:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '**RecursiveArrayIterator** : This recursive iterator allows iterating over
    any type of array or objects and modifying the key or values or unsetting them.
    It also allows iterating over the current iterator entry.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**RecursiveCallbackFilterIterator** :If we are looking forward to applying
    a callback recursively to any array or objects, this iterator can be very helpful.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递归回调过滤迭代器：如果我们希望递归地将回调应用于任何数组或对象，这个迭代器可以非常有帮助。
- en: '**RecursiveDirectoryIterator** : This iterator allows iterating any directory
    or filing systems. It makes the directory listing very easy. For example, we can
    rewrite the directory listing program we wrote in this chapter easily using this
    iterator:'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递归目录迭代器：这个迭代器允许迭代任何目录或文件系统。它使得目录列表非常容易。例如，我们可以很容易地使用这个迭代器重新编写本章中编写的目录列表程序：
- en: '[PRE17]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '**RecursiveFilterIterator:** If we are looking for a filter option in our iteration
    recursively, we can use this abstract iterator to implement the filtering part.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递归过滤迭代器：如果我们在迭代过程中递归地寻找过滤选项，我们可以使用这个抽象迭代器来实现过滤部分。
- en: '**RecursiveIteratorIterator:** If we want to iterate over any recursive iterator,
    we can use this one. It is already built-in, and we can easily apply it. An example
    of how it is used is shown in the directory iterator section in the `RecursiveDirectoryIterator`
    section.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递归迭代迭代器：如果我们想要迭代任何递归迭代器，我们可以使用这个。它已经内置，我们可以很容易地应用它。在“RecursiveDirectoryIterator”部分中显示了它的使用示例。
- en: '**RecursiveRegexIterator:** If you want to apply a regular expression to filter
    an iterator, we can use this iterator along with other iterators.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递归正则表达式迭代器：如果您想要应用正则表达式来过滤迭代器，我们可以使用这个迭代器以及其他迭代器。
- en: '**RecursiveTreeIterator:** The recursive tree iterator allows us to create
    a graphical representation like a tree for any directory or multidimensional array.
    For example, the following football team list array will produce a tree structure:'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递归树迭代器：递归树迭代器允许我们为任何目录或多维数组创建类似树的图形表示。例如，以下足球队列表数组将产生树结构：
- en: '[PRE18]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The output will look like this:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE19]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Using the PHP built-in function array_walk_recursive
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用PHP内置函数array_walk_recursive
- en: The `array_walk_recursive` can be a very handy built-in function for PHP as
    it can traverse any size of array recursively and apply a callback function. Whether
    we want to find whether an element is in a multidimensional array or not, or get
    the total sum of the array of the multidimensional array, we can use this function
    without any problem.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`array_walk_recursive`可以是PHP中非常方便的内置函数，因为它可以递归地遍历任何大小的数组并应用回调函数。无论我们想要找出多维数组中是否存在元素，还是获取多维数组的总和，我们都可以毫无问题地使用这个函数。'
- en: 'The following code sample will produce an output of **136** when executed:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下代码示例将产生输出**136**：
- en: '[PRE20]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The other two built-in recursive array functions in PHP are `array_merge_recursive`
    and `array_replace_recursive` . We can use them to merge multiple arrays to one
    or replace from multiple arrays, respectively.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: PHP中的另外两个内置递归数组函数是`array_merge_recursive`和`array_replace_recursive`。我们可以使用它们来合并多个数组到一个数组中，或者从多个数组中替换，分别。
- en: Summary
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: So far, we discussed different properties and practical usage of recursion.
    We have seen how to do the analysis of recursive algorithms. Computer programming
    and recursion are two inseparable parts. The usage of recursion is almost everywhere
    in the programming world. In the upcoming chapters, we will explore it more and
    apply wherever it's applicable. In the next chapter, we will discuss another special
    data structure called "tree".
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们讨论了递归的不同属性和实际用途。我们已经看到了如何分析递归算法。计算机编程和递归是两个不可分割的部分。递归的使用几乎无处不在于编程世界中。在接下来的章节中，我们将更深入地探讨它，并在适用的地方应用它。在下一章中，我们将讨论另一个特殊的数据结构，称为“树”。
