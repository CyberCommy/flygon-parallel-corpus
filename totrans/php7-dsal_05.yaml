- en: Applying Recursive Algorithms - Recursion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Solving complex problems is always hard. Even for programmers, solving complex
    problems can prove tougher, and sometimes, a special solution is required. Recursion
    is one such special approach that computer programmers follow to solve complex
    problems. In this chapter, we will go through the definition of recursion, properties,
    different types of recursions, and lots of examples. Recursion is not a new concept;
    in nature, we see lots of recursive elements. Fractals show recursive behavior.
    The following image shows natural recursion:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00032.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Understanding recursion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Recursion is a way to solve larger problems by dividing them into smaller problems.
    In other words, recursion is breaking the big problem into smaller similar problems
    to solve them and get the actual results. Often, recursion is termed as a function
    calling itself. It might sound strange, but the fact is the function must call
    itself when it is in recursion. What does this look like? Let's look at an example,
  prefs: []
  type: TYPE_NORMAL
- en: 'In mathematics, the term "factorial" is very popular. A factorial of a number
    *N* is defined as multiplication of all positive integers less than and equal
    to *N* . It is always denoted with *!* (an exclamation mark). So, a factorial
    of *5* can be written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*5! = 5 X 4 X 3 X 2 X 1*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, we can write the following factorials of the given number::'
  prefs: []
  type: TYPE_NORMAL
- en: '*4! = 4 X 3 X 2 X 1*'
  prefs: []
  type: TYPE_NORMAL
- en: '*3! = 3 X 2 X 1*'
  prefs: []
  type: TYPE_NORMAL
- en: '*2! = 2 X 1*'
  prefs: []
  type: TYPE_NORMAL
- en: '*1! = 1*'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we look closely at our example, we can see that we can write factorial of
    *5* in terms of factorials of *4* like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*5! = 5 X 4!*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, we can write:'
  prefs: []
  type: TYPE_NORMAL
- en: '*4! = 4 X 3!*'
  prefs: []
  type: TYPE_NORMAL
- en: '*3! = 3 X 2!*'
  prefs: []
  type: TYPE_NORMAL
- en: '*2! = 2 X 1!*'
  prefs: []
  type: TYPE_NORMAL
- en: '*1! = 1 X 0!*'
  prefs: []
  type: TYPE_NORMAL
- en: '*0! = 1*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, we can simply say in general terms that:'
  prefs: []
  type: TYPE_NORMAL
- en: '*n! = n * (n-1)!*'
  prefs: []
  type: TYPE_NORMAL
- en: 'This represents recursion. We are breaking each of the steps into smaller ones
    and solving the actual big problem. Here is an image to show how a factorial of
    3 is calculated:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00033.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'So, the steps are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*3! = 3 X 2!*'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*2! = 2 X 1!*'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*1! = 1 X 0!*'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*0! = 1*'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*1! = 1 X 1 = 1*'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*2! = 2 X 1 = 2*'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*3! = 3 X 2 = 6*'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Properties of recursive algorithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, the question can be, "If a function calls itself, then how does it stop
    or know when to finish the recursive call?" When we are writing a recursive solution,
    we have to make sure it has the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: Each recursive call should be on a smaller subproblem. Like the factorial example,
    a factorial of 6 is solved with 6 and multiplication of a factorial of 5 and so
    it goes on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It must have a base case. When the base case is reached, there will be no further
    recursion, and the base case must be able to solve the problem without any further
    recursive call. In our factorial example, we did not go any further down from
    0\. So, in this case, 0 is our base case.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There should not be any cycle. If each recursive call makes a call to the same
    problem, then there will be a never-ending cycle. After some repetitions, the
    computer will show a stack overflow error.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'So, if we now write our factorial program using PHP 7, then it will look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example code, we can see that we have a base condition where
    we are returning `1` when the value of `$n` is `0` . If this condition is not
    met, then we are returning a multiplication of `$n` and a factorial of `$n-1`
    . So, it satisfies property to both numbers, 1 and 3\. We are avoiding cycles
    and also making sure each recursive call is creating a subproblem of the bigger
    one. We will write the recursive behavior like this algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00034.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Recursion versus iterative algorithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If we analyze our factorial function, we can see that it could be written using
    a simple iterative approach with a `for` or `while` loop, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: If this can be written as a simple iterative one, then why should we use recursion?
    Recursion is used to solve more complex problems. Not all problems can be solved
    iteratively so easily. For example, we need to show all the files in a certain
    directory. We can simply do this by running a loop to list all the files. However,
    what if there is another directory inside it? Then, we have to run another loop
    to get all those files inside that directory. What if there is another directory
    inside that directory and it goes on and on? In such a situation, an iterative
    approach might not help at all or might create a complex solution. It is better
    to choose a recursive approach here.
  prefs: []
  type: TYPE_NORMAL
- en: Recursion manages a call stack for managing function calls. As a result, recursion
    will take more memory and time to complete compared to iteration. Also, in iteration,
    in each step, we can have a result, but for recursion, we have to wait until the
    base case to execute to get any result. If we consider both iterative and recursive
    examples for a factorial, we can see that there is a local variable called `$result`
    to store the calculation of each step. However, in recursion, there is no need
    for local variables or assignment.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing Fibonacci numbers using recursion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In mathematics, Fibonacci numbers are special integer sequences where a number
    is composed from summation of the past two numbers, as shown in the following
    the expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00035.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'If we implement this using PHP 7, it will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: If we consider the preceding implementation, we can see it is a bit different
    from the previous examples. Now, we are calling two functions from one function
    call. We will discuss different types of recursions shortly.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing GCD calculation using recursion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another common use of recursion is implementing **Greatest Common Division**
    (**GCD** ) of two numbers. In GCD calculation, we will continue until a remainder
    becomes 0\. It can be expressed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00036.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, if we implement recursively using PHP 7, it will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Another interesting part of this implementation is that unlike a factorial,
    we are not returning from a base case to other steps in the call stack. The base
    case will return the calculated value. This is one of the optimized ways to do
    recursion.
  prefs: []
  type: TYPE_NORMAL
- en: Different types of recursions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have seen some example cases of recursion and how it is being used.
    Though the term says recursion, there are different types of recursions. We will
    explore them one by one.
  prefs: []
  type: TYPE_NORMAL
- en: Linear recursion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most commonly used recursions in the programming world is linear
    recursion. When a function calls itself once in each run, we will call it a linear
    recursion. Just like our factorial example, when we are breaking the big calculation
    to smaller ones until the base condition is reached, we call it winding. When
    we are returning from the base condition to the first recursive call, we call
    it unwinding. We will work on different linear recursions in the upcoming section
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Binary recursion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In binary recursion, the function calls itself twice in each run. As a result,
    the calculation depends on two results from two different recursive calls to itself.
    If we look at our Fibonacci sequence generation recursive function, we can easily
    find that it is a binary recursion. Other than this, we have many commonly used
    binary recursions in the programming world, such as binary search, divide and
    conquer, merge sort, and so on. The following image shows a binary recursion:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00037.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tail recursion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A recursive method is tail recursive when there is no pending operation to be
    performed on return. For example, in our factorial code, the returned value is
    used to multiply with the previous value to calculate the factorial. So, this
    is not tail recursive. The same goes for the Fibonacci series recursion. If we
    look at our GCD recursion, we can find that there is no operation to do after
    the return. So, the final return or base case return is actually the answer. So,
    GCD is an example of tail recursion. Tail recursion is also a form of linear recursion.
  prefs: []
  type: TYPE_NORMAL
- en: Mutual recursion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It might be the case that we may require to call two different methods recursively
    from two different methods in an alternate fashion. For example, function `A()`
    calls function `B()` and function `B()` calls function `A()` in each call. This
    is known as mutual recursion.
  prefs: []
  type: TYPE_NORMAL
- en: Nested recursion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When a recursive function call has itself as the parameter, then it is called
    nested recursion. One of the common examples of nested recursion is the Ackermann
    function. Look at the following equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00038.gif)'
  prefs: []
  type: TYPE_IMG
- en: If we look at the last line, we can see that function `A ()` is called recursively,
    but the second parameter itself is another recursive call. So, this is one of
    the examples of nested recursions.
  prefs: []
  type: TYPE_NORMAL
- en: Though there are different types of recursions available, we will only use those
    that are required based on our needs. Now, we will see some real-life usage of
    recursion in our projects.
  prefs: []
  type: TYPE_NORMAL
- en: Building an N-level category tree using recursion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Building a multilevel nested category tree or menu is always a problem. Many
    CMS and sites only allow a certain level of nesting. In order to save performance
    issues due to multiple joins, some only allow 3-4 levels of nesting at maximum.
    Now, we will explore how we can create an N-level nested category tree or menu
    with the help of recursion, without compromising on performance. Here is our approach
    for the solution:'
  prefs: []
  type: TYPE_NORMAL
- en: We will define the table structure for the category in the database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will get all categories in the table without the use of any join or multiple
    queries. It will be a single database query with a simple select statement.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will build an array of categories such that we can utilize the recursion
    with that to display the nested categories or menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s assume that we have a simple table structure in our database to store
    our categories and it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'For simplicity, we are assuming that there is no other field required in the
    table. Also, we have some data in the table like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Id** | **categoryName** | **parentCategory** | **sortInd** |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | First | 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | Second | 1 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | Third | 1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | Fourth | 3 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | Fifth | 4 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | Sixth | 5 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 7 | Seventh | 6 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 8 | Eight | 7 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 9 | Ninth | 1 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 10 | Tenth | 2 | 1 |'
  prefs: []
  type: TYPE_TB
- en: 'Now, we have created a table structured for our database, and we have assumingly
    also entered some sample data. Let''s build a query to retrieve this data so that
    we can move to our recursive solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The core part of the preceding code is how we are storing our categories in
    an array. We are storing the results based on their parent category. This will
    help us show child categories of a category recursively. This looks pretty simple.
    Now, based on the categories array, let''s write the recursive function to show
    the categories hierarchically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code actually shows all the categories and their child categories
    recursively. We take a level and first print the category on that level. Immediately,
    we will check whether it has any child level categories or not with the code `showCategoryTree($categories,
    $category->id)` . Now, if we call the recursive function with a root level (level
    0), then we will have the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The output for this will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, without thinking about the depth of the category level or multiple
    queries, we can build nested categories or menus with just a simple query and
    recursive function. We can use `<ul>` and `<li>` to create a nested menu if we
    want it with dynamic show and hide functionality. This can be vital for having
    an efficient solution to the problem without getting into implementation blocks,
    such as having a fixed level of joins or fixed level of categories. The preceding
    example is a perfect display of tail recursion where we are not waiting for the
    recursion to return anything, and as we move forward, the results are already
    displayed.
  prefs: []
  type: TYPE_NORMAL
- en: Building a nested comment reply system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Quite often, we face the challenge to display comment replies in a proper way.
    Showing them chronologically does not fit our need sometimes. We may require showing
    them in such a way that the reply for each comment is below the actual comment
    itself. In other words, we can say we need a nested comment reply system or threaded
    comments. We want to build something similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00039.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can follow the same steps we did in the nested category section. However,
    this time, we will have some UI elements to give it a more realistic look. Let''s
    assume that we have a table named `comments` with the following data and columns.
    For simplicity, we are not going into multiple table relationships. We are assuming
    that the usernames are stored in the same table with the comments:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Id** | **comments** | **username** | **Datetime** | **parentID** | **postID**
    |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | First comment | Mizan | 2016-10-01 15:10:20 | 0 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | First reply | Adiyan | 2016-10-02 04:09:10 | 1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | Reply of first reply | Mikhael | 2016-10-03 11:10:47 | 2 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | Reply of reply of first reply | Arshad | 2016-10-04 21:22:45 | 3 | 1
    |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | Reply of reply of reply of first reply | Anam | 2016-10-05 12:01:29 |
    4 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | Second comment | Keith | 2016-10-01 15:10:20 | 0 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 7 | First comment of second post | Milon | 2016-10-02 04:09:10 | 0 | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| 8 | Third comment | Ikrum | 2016-10-03 11:10:47 | 0 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 9 | Second comment of second post | Ahmed | 2016-10-04 21:22:45 | 0 | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| 10 | Reply of second comment of second post | Afsar | 2016-10-18 05:18:24
    | 9 | 2 |'
  prefs: []
  type: TYPE_TB
- en: 'Let''s now write a prepared statement to fetch all the comments from a post.
    Then, we can construct an array similar to the nested category one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have the array and all required data in it; we can now write a function
    that will call recursively to display the comment with proper indentations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we have added some HTML elements in the PHP code, we need some basic
    CSS to make it work. Here is the CSS code we have written to make it a clean design.
    Nothing fancy, but pure CSS to create the cascading effects and some basic styling
    for each section of the comment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As mentioned earlier, we are not trying to make something complex here, just
    responsive, device friendly, and so on. We are assuming that you can integrate
    the logic in different parts of your application without any problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the output from the data and the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00040.jpg)'
  prefs: []
  type: TYPE_IMG
- en: From the preceding two examples, we can see that it is very easy to create nested
    contents without having multiple queries or having a limitation of join statements
    for nesting. We do not even require a self-join to generate the nested data.
  prefs: []
  type: TYPE_NORMAL
- en: Finding files and directories using recursion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Quite often, we need to find all the files inside a directory. This includes
    all subdirectories inside it and also directories inside those subdirectories.
    As a result, we need a recursive solution to find the list of files from the given
    directory. The following example will show a simple recursive function to list
    all the files in a directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The `showFiles` function actually takes a directory and first scans the directory
    to list all the files and directories under it. Then, with a `foreach` loop, it
    iterates through each file and directory. If it is a directory, we recall the
    `.` function again to list the files and directories under it. This continues
    until we traverse all the files and directories. Now, we have all the files under
    the `$files` array. Now, let''s show the files using a `foreach` loop sequentially:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This will have the following output in the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: These were solutions for some common challenges we face during development.
    However, there are other places where we will use recursion heavily, such as binary
    search, trees, divide and conquer algorithm, and so on. We will discuss them in
    the upcoming chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing recursive algorithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Analysis of recursive algorithms depends on the type of recursion we are using.
    If it is linear, the complexity will be different; if it is binary, it will have
    a different complexity. So, we do not have a generic complexity for the recursive
    algorithms. We have to analyze it on a case-by-case basis. Here, we will analyze
    factorial series. First, let''s focus on the factorial part. If we recall from
    this section, we had something like this for factorial recursion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s assume that it will take `T(n)` to compute factorial (`$n` ). We will
    focus on how to use this `T(n)` in terms of the Big O notation. Each time we call
    the factorial function, there are certain steps involved:'
  prefs: []
  type: TYPE_NORMAL
- en: Every time, we are checking the base case.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we call factorial (`$n-1` ) on each loop.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We do a multiplication with `$n` on each loop.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we return the result.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, if we represent this using `T(n)` , then we can say:'
  prefs: []
  type: TYPE_NORMAL
- en: '*T(n) = a when n = 0*'
  prefs: []
  type: TYPE_NORMAL
- en: '*T(n) = T(n-1) + b when n > 0*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, both *a* and *b* are some constants. Now, let''s generate a relationship
    between *a* and *b* with *n* . We can easily write the equation as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*T(0) = a*'
  prefs: []
  type: TYPE_NORMAL
- en: '*T(1) = T(0) + b = a + b*'
  prefs: []
  type: TYPE_NORMAL
- en: '*T(2) = T(1) + b = a + b + b = a + 2b*'
  prefs: []
  type: TYPE_NORMAL
- en: '*T(3) = T(2) + b = a + 2b + b = a + 3b*'
  prefs: []
  type: TYPE_NORMAL
- en: '*T(4) = T(3) + b = a + 3b + b = a + 4b*'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see that a pattern is emerging here. So, we can establish that:'
  prefs: []
  type: TYPE_NORMAL
- en: '*T(n) = a + (n) b*'
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, we can also say in simple terms that `T(n) = O(n)` .
  prefs: []
  type: TYPE_NORMAL
- en: So, the factorial recursion has a linear complexity of `O(n)` .
  prefs: []
  type: TYPE_NORMAL
- en: A fibonacci sequence with recursion has approximately `O(2^n )` complexity.
    The calculation is very elaborative as we have to consider both the lower bound
    and upper bound for the Big O notation. In the upcoming chapters, we will also
    analyze binary recursion such as binary search and merge sorts. We will focus
    more on recursive analysis in those chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Maximum recursion depth in PHP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since recursion is the process when a function calls itself, we can have a
    valid question in mind such as "how deep can we go with this recursion?". Let''s
    do a small program for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Can we guess the max depth level? The depth reached 917,056 levels before exhausting
    the memory limit. If **XDebug** is enabled, then the limit will be much less compared
    to this. It also depends on your memory, OS, and PHP settings such as memory limit
    and max execution time.
  prefs: []
  type: TYPE_NORMAL
- en: Though we have the option to go very deep with our recursion, it is always important
    to remember that we must have control with our recursive function. We should know
    the base conditions and where the recursion must end. Otherwise, it might create
    some wrong results or end abruptly.
  prefs: []
  type: TYPE_NORMAL
- en: Using SPL recursive iterators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Standard PHP Library SPL has many built-in iterators for recursion purposes.
    We can use them as per our need, without taking the pain of implementing them
    from scratch. Here is the list of iterators and their functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '**RecursiveArrayIterator** : This recursive iterator allows iterating over
    any type of array or objects and modifying the key or values or unsetting them.
    It also allows iterating over the current iterator entry.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**RecursiveCallbackFilterIterator** :If we are looking forward to applying
    a callback recursively to any array or objects, this iterator can be very helpful.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**RecursiveDirectoryIterator** : This iterator allows iterating any directory
    or filing systems. It makes the directory listing very easy. For example, we can
    rewrite the directory listing program we wrote in this chapter easily using this
    iterator:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '**RecursiveFilterIterator:** If we are looking for a filter option in our iteration
    recursively, we can use this abstract iterator to implement the filtering part.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**RecursiveIteratorIterator:** If we want to iterate over any recursive iterator,
    we can use this one. It is already built-in, and we can easily apply it. An example
    of how it is used is shown in the directory iterator section in the `RecursiveDirectoryIterator`
    section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**RecursiveRegexIterator:** If you want to apply a regular expression to filter
    an iterator, we can use this iterator along with other iterators.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**RecursiveTreeIterator:** The recursive tree iterator allows us to create
    a graphical representation like a tree for any directory or multidimensional array.
    For example, the following football team list array will produce a tree structure:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Using the PHP built-in function array_walk_recursive
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `array_walk_recursive` can be a very handy built-in function for PHP as
    it can traverse any size of array recursively and apply a callback function. Whether
    we want to find whether an element is in a multidimensional array or not, or get
    the total sum of the array of the multidimensional array, we can use this function
    without any problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code sample will produce an output of **136** when executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The other two built-in recursive array functions in PHP are `array_merge_recursive`
    and `array_replace_recursive` . We can use them to merge multiple arrays to one
    or replace from multiple arrays, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we discussed different properties and practical usage of recursion.
    We have seen how to do the analysis of recursive algorithms. Computer programming
    and recursion are two inseparable parts. The usage of recursion is almost everywhere
    in the programming world. In the upcoming chapters, we will explore it more and
    apply wherever it's applicable. In the next chapter, we will discuss another special
    data structure called "tree".
  prefs: []
  type: TYPE_NORMAL
