- en: Chapter 6. Accelerating Development with Express
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Generating Express scaffolding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining and applying environments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamic routing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Templating in Express
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CSS engines with Express
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initializing and using a session
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making an Express web app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As excellent as Node's HTTP module is, Express repackages and streamlines its
    functionality to provide us with a fluid interface that makes for almost frictionless
    rapid web development.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will progress from generating a vanilla Express project
    base to a fully-fledged Express web-application foundation with MongoDB providing
    backend data support.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Express 2 to Express 3**'
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this chapter there are helpful boxes, like this one, that demonstrate
    how to migrate code from Express 2 to Express 3\. The supporting code files contain
    both Express 2 and 3 code (with 3 commented out). Code files can be downloaded
    from [http://www.packtpub.com/support](http://www.packtpub.com/support).
  prefs: []
  type: TYPE_NORMAL
- en: Generating Express scaffolding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Express works both as a Node module and as a command-line executable. When we
    run `express` from the command line it generates a project skeleton for us, accelerating
    the preparation process.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need to install `express` using the `-g` flag (install globally) in order
    to run the `express` executable from any directory.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We use `sudo` to ensure we get permission to install globally. This doesn't
    apply under Windows.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we decide upon the name of our app. Let''s call it `nca` (Node Cookbook
    App) and simply do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This will generate all of our project files under a new directory called `nca`.
    Before we can run our app, we must ensure that all dependencies are installed.
    We can find app dependencies in `nca/package.json:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'For portability, it''s important to have relevant modules installed within
    the `project` folder. To achieve this, we simply use the command line to `cd`
    into the `nca` directory and say:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This will make a new `node_modules` directory in our `project` folder, holding
    all dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we run the `express` executable, it creates a folder structure that's suited
    to Express development. In the project root, we have `app.js` and `package.json`
    files.
  prefs: []
  type: TYPE_NORMAL
- en: '`package.json` is a convention established by the CommonJS group (a Javascript
    standards community), and has become the established method for describing modules
    and applications in Node.'
  prefs: []
  type: TYPE_NORMAL
- en: The `npm install` command parses the dependencies from `package.json`, installing
    them locally in the `node_modules` folder.
  prefs: []
  type: TYPE_NORMAL
- en: This is significant because it ensures stability. Node's `require` function
    looks for a `node_modules` folder in the current working directory before searching
    parent directories. If we upgrade any modules in a parent directory, our project
    will continue to use the same version it was built upon. Installing modules locally
    allows us to distribute our project along with its dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `app.js` file is our project boilerplate. We run our app with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The `express` executable adds three subdirectories to the project folder: `public,
    routes` and `views`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`public` is the default folder that `app.js` passes to the `express.static`
    method, all our static files go here. It contains `images, javascripts`, and `stylesheets`
    folders each for their own self-evident purpose.'
  prefs: []
  type: TYPE_NORMAL
- en: The `routes` folder holds `index.js` which is required by `app.js`. To define
    our routes, we push them onto Node's `exports` object (which we'll learn more
    about In [Chapter 9](ch09.html "Chapter 9. Writing Your Own Node Modules"), *Writing
    Your Own Node Modules)*. Using `routes/index.js` helps to avoid clutter in `app.js`,
    and separates server code from route code. This way we can focus purely on our
    server, or purely on our routes.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, `views` hold template files, which can really help with development
    acceleration. We'll be finding out how to work with views in the *Templating in
    Express* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's take a few moments to go deeper into our generated project.
  prefs: []
  type: TYPE_NORMAL
- en: Picking apart app.js
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s take a look at our generated `app.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `app` variable holds the result of `express.createServer`, which is essentially
    an enhanced `http.createServer`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `configure` method is invoked three times: once for global settings, once
    for production, and once for development. We''ll be looking at production and
    development in greater detail in the next recipe.'
  prefs: []
  type: TYPE_NORMAL
- en: Within the global `configure` callback, the default view directory (`views`)
    and engine (`jade`) are `set`, and the `app` is told to `use express.bodyParser,
    express.methodOverride, app.router`, and `express.static` middleware.
  prefs: []
  type: TYPE_NORMAL
- en: '`bodyParser` made a brief appearance In [Chapter 2](ch02.html "Chapter 2. Exploring
    the HTTP Object"), *Exploring the HTTP Object*, in the first recipe''s *There''s
    more..*. section, in the form of `connect.bodyParser`.'
  prefs: []
  type: TYPE_NORMAL
- en: Express includes all the standard Connect middleware, and is compatible with
    add-on Connect middleware. Therefore, in an Express project, `bodyParser` is loaded
    with `express.bodyParser. bodyParser` gives us access to any data sent from the
    client (like in a POST request).
  prefs: []
  type: TYPE_NORMAL
- en: '`methodOverride` allows us to make pseudo `DELETE` and `PUT` requests from
    browser forms using a hidden input element called `_method`. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: There are many HTTP methods defined in the Hypertext Transfer Protocol documents
    (see [http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html)](http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html)).
    However, browsers have typically only supported GET and POST, leaving other methods
    up to purpose built clients. Express works around lack of browser support using
    this hidden input to emulate a `DELETE` request while also supporting real DELETE
    requests from clients that do support the method.
  prefs: []
  type: TYPE_NORMAL
- en: '`app.router` contains all the defined routes (anything passed to `app.get,
    app.post`, and so on). Routes are, in themselves, middleware. If `app.router`
    is not passed to `app.use`, the routes are automatically appended to the middleware
    stack. However, with manual inclusion we have the ability to place additional
    middleware after the `app.router` middleware.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Middleware is generally constructed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `next` parameter is a sort of callback mechanism which loads any ensuing
    middleware. So when `app.router` is positioned above `express.static`, any dynamic
    routes accessed by a client will not unnecessarily trigger the static server to
    look for the non-existent file, unless those routes call `next` (alternatively,
    `next` can be called as a method of `req: req.next())`. For more information on
    middleware, see [http://www.expressjs.com/guide.html#middleware](http://www.expressjs.com/guide.html#middleware).'
  prefs: []
  type: TYPE_NORMAL
- en: Looking into routes/index.js
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In `app.js, routes/index.js` is loaded with a `require:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that `index` isn''t specified, but if a directory is passed to `require`,
    Node will automatically look for `index.js`. Let''s take a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Pushing `index` onto the `exports` object makes it available in `app.js` as
    `routes.index`, which is passed to `app.get` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `routes.index` function should look familiar. It follows the pattern of
    an `http.createServer` callback, but is specific to the route. The request (`req`)
    and response (`res`) parameters are enhanced by Express. We'll be looking into
    these in coming recipes. The function itself simply calls the `res.render` method,
    which loads a template from `views/index.jade`, passing `title` as a variable
    which then outputs the generated content to the client.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Defining and applying environments* discussed in this chapter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Dynamic routing* discussed in this chapter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Templating in Express* discussed in this chapter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining and applying environments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Development and production code have different requirements. For instance, during
    development we will most likely want a detailed error output to the client, for
    debugging purposes. In production, we protect ourselves from opportunistic exploitation
    by revealing as little internal information as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Express caters to these differences with `app.configure` which allows us to
    define environments with specific settings.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll need our project folder (`nca`) from the previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s take a look at the preconfigured environments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The generated file defines customized error-reporting levels for each environment.
    Let's add caching to our production server, which can be a hindrance in development.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use `express.staticCache` to achieve this. However, it has to be called
    prior to `express.static`, so we move `express.static` from the global `configure`
    into both development and production environments, along with `staticCache` in
    production as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We also set `dumpExceptions` to true for the production `errorHandler`. This
    would allow us to quickly identify any problems that might occur once we've launched
    our app.
  prefs: []
  type: TYPE_NORMAL
- en: To use an environment, we set the special `NODE_ENV` variable on the command
    line as we are executing `node:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Or on Windows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The development environment is default, so there's no need to use `NODE_ENV`
    to set it.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Express provides a very convenient way for us to separate our work flow process.
    All we have to do is pass in the name of our environment with specific settings.
  prefs: []
  type: TYPE_NORMAL
- en: Under the hood, Express will be using `process.env` to determine the `NODE_ENV`
    variable, checking for a match against any defined environments. If `NODE_ENV`
    isn't set, Express defaults to loading the development environment.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's look into some of the ways we can manage our environments.
  prefs: []
  type: TYPE_NORMAL
- en: Setting other environments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We could have other phases in our work flow that would benefit from specific
    settings. For instance, we may have a staging phase where we emulate as much of
    the production environment as possible on the development machine for testing
    purposes.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if our production server requires us to run the process on a specific
    port (say port 80), that we cannot achieve on our development server (if we do
    not have root privileges for instance), we could add a staging environment and
    set a `port` variable that is only set to `80` in a production environment.
  prefs: []
  type: TYPE_NORMAL
- en: See[Chapter 10](ch10.html "Chapter 10. Taking It Live"), *Taking It Live*, for
    information on how to safely run Node on Port 80.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add the staging environment underneath development as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we''ll add the port logic as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: So our `port` is set based upon the environment, if `port` is empty we default
    to `3000`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could initialize our production server with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Or for Windows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'When attempting to run the server with `NODE_ENV` set to `production`, if we
    receive `TypeError: Cannot read property ''port'' of null`, it''s likely that
    a service is already running on port 80\. We would need to stop this service in
    order to test our code. For instance, if Apache is running on our system, it''s
    probably hosting through port `80`. We can stop Apache with `sudo apachectl -k
    stop` (or `net stop apache2.2` on Windows).'
  prefs: []
  type: TYPE_NORMAL
- en: Changing NODE_ENV permanently
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If we are in a staging process, we may not wish to type `NODE_ENV=staging` every
    time we load our app. The same applies to production. While the server would be
    started a lot less, we would have to remember to set `NODE_ENV` when restarting.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can make things easier on Unix-type systems (Linux or Max OS X), with the
    `export` shell command as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This only sets `NODE_ENV` while our terminal is open. To make it permanent,
    we add this line to our home directory's `rc` file. The `rc` file is named depending
    upon the shell. For bash, it's located in `~/.bashrc` (where `~` is the home folder).
    Other shells, such as `sh` and `ksh`, would be `~/.shrc, ~/.kshrc`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'To permanently set `NODE_ENV`, we can use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Where staging is our desired environment and bash is our shell.
  prefs: []
  type: TYPE_NORMAL
- en: In Windows, we use `set` and `setx:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '`set` takes immediate effect, but is lost once the command prompt is closed.
    `setx` applies permanently but not until we open a new command prompt, so we use
    both.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Generating Express scaffolding* discussed in this chapter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Deploying to a server environment* discussed In [Chapter 10](ch10.html "Chapter 10. Taking
    It Live"),Taking It Live'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Making an Express web app* discussed in this chapter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Initializing and using a session* discussed in this chapter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamic routing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the very first recipe of this cookbook, *Setting up a router*, we explored
    various ways to set up routing in Node. Express provides a far superior and very
    powerful routing interface which we'll explore in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll be working with our `nca` folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s say we want to add a page for a fictional character by the name of Mr
    Page. We''ll name the route `page`, so in the `routes` section of `app.js` we
    add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also define flexible routes, and grab the requested route using `req.params`,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s okay to throw our callbacks directly into `app.get` while developing,
    but in the interest of a clutter-free `app.js` let''s take our callbacks and load
    them from `routes/index.js` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'And back in our `app.js` file our routes become:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We create the `/page` route using `app.get`. Then outline how we wish to respond
    to that route in the callback of `app.get`. In our example, we use `res.send`
    (an enhanced `res.write)` to output simple text. This is our inflexible dynamic
    route.
  prefs: []
  type: TYPE_NORMAL
- en: Express also provides flexible route capabilities using placeholders. In the
    main recipe, we defined a `:page` placeholder. When the placeholder is filled
    in by a request (for example, `/anyPageYouLike)`, the fulfillment of the placeholder
    is added to `req.params` according to its name. So in this case `req.params.page`
    would hold `/anyPageYouLike`.
  prefs: []
  type: TYPE_NORMAL
- en: When a user loads `localhost:3000/page` they see **Hello I am Mr Page**, when
    they access `localhost:3000/absolutelyAnythingElse` they get **Welcome to the
    absolutelyAnythingElse page**.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What other things can we do with Express routes?
  prefs: []
  type: TYPE_NORMAL
- en: Route validation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can restrict flexible routes to specific character ranges using pieces of
    Regular Expression syntax, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We pass a character match, `[a-zA-Z]` along with a plus (+). This will match
    the characters one or more times. As a result, we limit our `:page` parameter
    to letters only.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, `http://localhost:3000/moo` will give **Welcome to the moo page**,
    whereas `http://localhost:3000/moo1` will return a `404` error.
  prefs: []
  type: TYPE_NORMAL
- en: Optional routes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can also define optional routes using the question mark (?):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We would place this in our `app.js` file, underneath our other defined routes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `anypageAdmin` function in `routes/index.js` could go like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We check for the existence of the `:admin` placeholder. If a route fulfills
    it, we verify that it is allowed (either add or delete) and send a tailored response.
    If the route is not allowed, we send a `404` error.
  prefs: []
  type: TYPE_NORMAL
- en: While the query wildcard (`?`) can be appropriate for lots of similar routes,
    if we only had our `add` and `delete` routes and there was no possibility of adding
    more routes later, we could implement this functionality in a much cleaner way.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `app.js` we could put:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: And in `index/routes.js:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Asterisks wildcards
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can use the asterisks (*) as a wildcard for general matching requirements.
    For instance, let''s add the following route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'And change `routes.anypage` to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Now if we access `localhost:3000/foo/bar` we get **Welcome to the bar page of
    the foo page**, but if we just access `localhost:3000/foo` we see **Welcome to
    the foo page**.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could also get a little wild and apply this to Mr Page''s route as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Now any route containing the word `page` will get a message from **Mr Page**.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Setting up a router* discussed In [Chapter 1](ch01.html "Chapter 1. Making
    a Web Server"),Making a Web Server'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Making an Express web app* discussed in this chapter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Templating in Express* discussed in this chapter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Templating in Express
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A fundamental part of the Express framework is its use of views. A view is simply
    a file that holds template code. Express helps us to separate our code into operationally
    distinct concerns. We have server code in `app.js`, route-specific functionality
    in `routes/index.js`, and then we have our output generating logic in the `views`
    folder. A template language provides a basis for defining dynamic logic-driven
    content, and the template (or view) engine converts our logic into the final HTML
    which is served to the user. In this recipe, we'll use Express' default view engine,
    Jade, to process and present some data.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the *There's more..*. section, we'll find out how to change the view engine.
  prefs: []
  type: TYPE_NORMAL
- en: A list of supported template engines can be found at [https://www.github.com/visionmedia/express/wiki](https://www.github.com/visionmedia/express/wiki).
    Comparisons of various template engines can be found at [http://paularmstrong.github.com/node-templates/](http://paularmstrong.github.com/node-templates/).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For our data, we'll be using the `profiles.js` object we created back in the
    first recipe of[Chapter 3](ch03.html "Chapter 3. Working with Data Serialization"),
    *Working with Data Serialization*. We'll need to copy it into the root of our
    `nca` folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's keep it simple and strip any routes we've added to `app.js`. We just want
    our top-level route.
  prefs: []
  type: TYPE_NORMAL
- en: Since Jade is set as the default view engine in `app.configure`, there's nothing
    else we need to do with `app.js` in this example.
  prefs: []
  type: TYPE_NORMAL
- en: In `routes/index.js`, we'll strip all routes except for `index`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The `res.render` method loads the Jade template in `views/index.jade`. We're
    going to use `index.jade` as a view for our `profiles.js` object data, so we need
    to make it available to our `index` view.
  prefs: []
  type: TYPE_NORMAL
- en: We do this by passing it through the `options` object of `res.render:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Notice we also changed the `title` property to`'Profiles'`.
  prefs: []
  type: TYPE_NORMAL
- en: 'All we do now is edit `views/index.jade`. The generated `index.jade` contains
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re going to add a table to the page that outputs the details of each person
    in the `profiles.js` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'To test we start our app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'And then navigate to `http://localhost:3000` to see something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/7188-06-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`res.render` pulls `index.jade` from the `views` folder, even though the first
    parameter is simply `index`. Express knows that a Jade file inside the `views`
    directory is intended because `app.configure` of `app.js` contains the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The second parameter is an object, holding two properties: `title` and `profiles`.
    These object properties become local variables within the Jade view. We output
    the variables either by return value buffering with a preceding equals (=) sign,
    or by using Jade''s interpolation, wrapping it like so: `#{title}`.'
  prefs: []
  type: TYPE_NORMAL
- en: Jade is a lean templating language. It uses bracket-stripped markup tags and
    has an indentation-based syntax with an alternative block expansion option (where
    we use the colon instead of an indent to signify nesting). It also has a minimal
    syntax set for defining `id` and `class` attributes using the hash (#) and dot
    (.) respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, the following Jade:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Would create the following HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To learn more about the Jade language, check out its GitHub page: [https://www.github.com/visionmedia/jade](https://www.github.com/visionmedia/jade).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Jade also processes iteration logic. We used two `each` Jade iterators to pull
    the values from our `profiles` object as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: This code traverses the `profiles` object, loading each ID (ryan, `isaac, bert`,
    and so on) into a new `id` variable, and each object containing profile information
    into a `profile` object variable.
  prefs: []
  type: TYPE_NORMAL
- en: Underneath our first `each`, we indent `tr(id=id)`. Unlike JavaScript, indentation
    in Jade is part of the logic, so getting it right is essential.
  prefs: []
  type: TYPE_NORMAL
- en: This tells Jade that for each profile we want to output a`<tr>` tag with the
    `id` attribute set to the ID of the `profile`. We don't use the hash (#) shorthand
    to set the `id` attribute in this case since we need Jade to evaluate our `id`
    variable. `tr#id` would generate`<tr id=id>` for each profile, whereas `tr(id=id)`
    generates`<tr id=ryan>` or `isaac`, or `bert` and so forth.
  prefs: []
  type: TYPE_NORMAL
- en: Underneath `tr` we indent again, indicating that whatever comes next should
    be nested within the`<tr>` tags. Again we use `each` to traverse the values of
    each sub-object, indenting beneath with a `td` that holds each value of the profile.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's take a look at some of the other templating capabilities and features
    Express has to offer.
  prefs: []
  type: TYPE_NORMAL
- en: Using other template engines
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Express supports a variety of alternative template engines, unsupported engines
    can be adapted to Express without excessive hassle.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `express` executable will only generate Jade or EJS-based project scaffolding.
    To generate EJS we simply pass `ejs` to the `-t` flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Instead of generating an Express project with EJS as the default view engine,
    let's convert our existing project (we'll start by copying it to `nca_ejs)`.
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to edit dependencies in `package.json:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve simply removed `jade` and put `ejs` in its place. Now we do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: So `npm` will put the EJS module into the `node_modules` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we change our view engine in `app.configure` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: This technique will work for any Express-supported template engine. There's
    no need to `require` the EJS module, Express takes care of that behind the scenes.
  prefs: []
  type: TYPE_NORMAL
- en: EJS templates
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since we've set up `nca_ejs`, we may as well go ahead and rewrite our index
    view in Embedded JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `nca_ejs/views` we add a new file, `index.ejs`, and put:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '`<%` and `%>` denote embedded JavaScript. If JavaScript happens to wrap any
    HTML code, the HTML is processed as if it''s part of the JavaScript. For instance,
    in our `forEach` callbacks we have`<tr>` and`<td>`, these are included as output
    from each loop.'
  prefs: []
  type: TYPE_NORMAL
- en: When the opening tag is accompanied by an equals sign (`<%=`), it evaluates
    any given JavaScript variable and pulls it into the generated output. For example,
    in our first`<h1>` we output the `title` variable.
  prefs: []
  type: TYPE_NORMAL
- en: Literal JavaScript in Jade
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Jade can also process plain JavaScript. Let''s use that to our advantage to
    output our table headers in a more concise, dry fashion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: A dash (—) at the beginning of a line informs Jade that we're using plain JavaScript.
    Here we simply create a new array called `headers` and then use Jade's `each`
    iterator to output our headers, using the equals (=) sign to evaluate the `header`
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could alternatively create our array in Jade as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Jade then compiles this to the embedded JavaScript in the preceding example,
    including the `var` declarative.
  prefs: []
  type: TYPE_NORMAL
- en: Jade partials
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Partials** are described as mini-views or document-fragments. They are mainly
    intended for automatic templated iteration over an array (a collection), although
    they''ll also work with objects.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, instead of saying:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'We can create a view file, which we''ll call `row.jade`, in which we write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Back in `index.jade`, we replace our `each` iterator with `partial` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '`!=` tells Jade to not only buffer what `partial` returns, but also to refrain
    from escaping the returned HTML. If we don''t include the exclamation mark Jade
    replaces HTML characters with their special entity codes, (for example,`<` becomes`&lt;)`.'
  prefs: []
  type: TYPE_NORMAL
- en: We pass`'row'` into `partial` which tells Jade to use the `row.jade` view as
    the partial. We pass an object with a `collection` property as the next parameter.
    If our profile was a simple array, we could simply pass the array and Jade would
    generate a `td` tag for each value in the array. However, the `profile` variables
    are objects, so passing it to `collection` causes Jade to traverse the values
    as if they were a simple array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each value in our `collection` (Ryan `Dahl, ryah, Creator` of `Node.js`, and
    so on), is referenced by the name of the view. So in our `row.jade` view, we use
    the `row` variable to grab each value. We can customize it by using the `as` property
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Then in `row.jade` we would change `row` to `line:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Express 2 to Express 3**'
  prefs: []
  type: TYPE_NORMAL
- en: 'In an effort to simplify viewing system internals and make it easier for template
    engines to integrate with Express, version 3 will no longer support partials.
    In Express 3, instead of a `row.jade` file, and using the call to `partial`, we
    could instead say:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Express partials
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the excellent things about partials is we can use them in our Express
    routes on the response (`res`) object. This is particularly remarkable because
    it allows us to seamlessly send fragments of HTML to AJAX or WebSocket requests,
    all while generating content from the same fragments (inside our views) for whole-page
    requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end of `index.jade` (the partials version), we''ll insert a small proof
    of concept script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: This will wait for one and a half seconds and then make an AJAX request to our
    `index` route. So let's modify our `index` route in `routes/index.js:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: If the request is an `XmlHttpRequest` (AJAX), we generate a new table row out
    of the `ryan` profile.
  prefs: []
  type: TYPE_NORMAL
- en: Now when we load `http://localhost:3000`, after a short delay Ryan's profile
    appears at the bottom of the table.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Express 2 to Express 3**'
  prefs: []
  type: TYPE_NORMAL
- en: Express 3 doesn't support partials, (neither in template logic nor in app code),
    so we would have to approach this a different way. For instance, we could send
    a JSON representation of the profiles and have the browser loop through it to
    populate the table.
  prefs: []
  type: TYPE_NORMAL
- en: As of this time of writing, there is no replacement middleware for partials,
    but there may well be in the near future.
  prefs: []
  type: TYPE_NORMAL
- en: Jade includes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Includes help us to separate and re-use pieces of template code. Let's put our
    `profiles` table into its own view. We'll call it `profiles.jade`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To include `profiles.jade` from the `index.jade` file we simply do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: layout.jade
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Express 2 to Express 3**'
  prefs: []
  type: TYPE_NORMAL
- en: Layouts are also being axed from Express 3 in favor of block inheritance. So
    instead of any rendered views being implicitly wrapped up into the `body` variable
    and rendered within `layout.jade`, we now have to explicitly declare a block and
    then insert that block into our body.
  prefs: []
  type: TYPE_NORMAL
- en: Also included in a generated project is the `layout.jade` view. This is a special
    view that is intertwined with Express logic. Any rendered views are packaged into
    a `body` variable, which is then passed into `layout.jade`. So in our case, we
    tell `res.render` to assemble `index.jade`. Express converts `index.jade` to HTML,
    and then internally renders `layout.jade`, passing the generated HTML in a body
    variable. `layout.jade` allows us to head and foot our views. To disable this
    feature for the entire app, we use `app.set('view options', {layout:false})`.
    To prevent it from applying to a particular render, we simply pass `layout:false`
    to the options object of `res.render`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Express 2 to Express 3**'
  prefs: []
  type: TYPE_NORMAL
- en: 'So in `layout.jade`, instead of `body!=body` we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: And at the top of `index.jade` we would inherit from `layout.jade` using `extend`
    and then define the `content` block, which would be loaded into the body of `layout.jade:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All Jade Express code examples have an additional folder named `views-Express3`
    containing equivalent templates, which follow the explicit block inheritance pattern
    instead of implicit layout wrapping.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*CSS Engines with Express* discussed in this chapter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Making an Express web app* discussed in this chapter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Generating Express scaffolding* discussed in this chapter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CSS engines with Express
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once we have our HTML, we'll want to style it. We could of course use raw CSS,
    but Express integrates nicely with some select CSS engines.
  prefs: []
  type: TYPE_NORMAL
- en: Stylus is one such engine. It's written with Express in mind, and as a syntax
    it follows many of the design principles found in Jade.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we're going to put Stylus in the spotlight, learning how we
    can use it to apply styles to our `profiles` table from the previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll need our `nca` folder as it was left in the previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, we need to set up our app to use Stylus.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we were starting a new project, we could use the `express` executable to
    generate a Stylus-based Express project, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: This would generate a project where `stylus` is a dependency in `package.json`,
    with an extra line in `app.js` within `app.configure:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: However, since we've already got a project on the hotplate, let's modify our
    existing app to use Stylus.
  prefs: []
  type: TYPE_NORMAL
- en: In `package.json:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Then on the command line run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally in `app.js`, inside `app.configure` we insert the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Notice we've set a different `src` and added a `dest` property to the generated
    code.
  prefs: []
  type: TYPE_NORMAL
- en: We're going to put our Stylus files in `views/stylesheets`. So let's make that
    directory and place a new file in it, which we'll call `style.styl`. Express will
    find this file, placing generated CSS in the corresponding folder (`stylesheets`)
    of the `public` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start our Stylus file, we''ll copy the current CSS from `/stylesheets/style.css`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Stylus is fully compatible with plain CSS, but for learning purposes let''s
    convert it into the minimal indentation-based format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Now we'll style our `#profiles` table from the previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can apply consistent padding to our `td` and `th` tags as well as our `#profile`
    table utilizing Stylus'' `@extend` directive as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: As new CSS properties are introduced into browsers, they often come with vendor-specific
    prefixes until the implementation is considered mature and stable. One such property
    is `border-radius`, on Mozilla browsers it's `-moz-border-radius`, on WebKit types
    it's referenced as `-webkit-border-radius`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Writing and maintaining this sort of CSS can be quite involved, so let''s use
    a Stylus mixin to make our lives easier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we''ll apply our mixin to the `#profiles` table and all the `td` elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'So our `#profiles` table now looks as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/7188-06-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As a module, `stylus` can operate independent of Express. However, it also has
    a convenient `middleware` method which can be passed into `app.use`.
  prefs: []
  type: TYPE_NORMAL
- en: When the `express` executable generates a Stylus-powered project, only the `src`
    property is set, which means Stylus pulls files with a `.styl` extension and converts
    them to `.css` files in the same folder. When we set `dest`, we load our Stylus
    code from one place and save it in another.
  prefs: []
  type: TYPE_NORMAL
- en: Our `src` is `views` and `dest` is `public`, but even though we put our `styles.styl`
    in a subdirectory of `views`, Stylus still finds it and places it in the corresponding
    subdirectory of the `dest` folder.
  prefs: []
  type: TYPE_NORMAL
- en: The `layout.jade` file includes a `link` tag to `/stylesheets/style.css`. So
    when we created `style.styl` in `views/stylesheets`, the generated CSS was written
    to `public/stylesheets`. Since our static server directory is set to `public`,
    requests for `/stylesheets/style.css` are served from `public/stylesheets/style.css`.
  prefs: []
  type: TYPE_NORMAL
- en: We used several Stylus features to create our stylesheet.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `@extend` directive is based upon the concept of inheritance. We make a
    class and then use `@extend` to apply all the qualities of that class to another
    element. Our use of `@extend` in the recipe creates the following CSS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: The larger our styles base becomes the more the `@extend` directive tends to
    ease maintenance and readability.
  prefs: []
  type: TYPE_NORMAL
- en: We make it easier to define a border, with rounded corners if desired, by using
    a mixin. Stylus mixins allow us to define default values as we set the parameters.
    If we mixed in `borderIt` with no arguments, it would generate a 1 pixel-wide,
    right-angled solid black border according to its defaults.
  prefs: []
  type: TYPE_NORMAL
- en: We first use `borderIt` on the `#profiles` table, passing in `20px` and `2px`.
    There's no need to use parentheses — Stylus understands it's a mixin. The first
    parameter (20px) in our mixin is named `rad`. Since `rad` has specified the `borderIt`,
    mixin goes ahead and outputs the various vendor prefixes along with the desired
    radius. The second parameter overwrites our `border-width` default.
  prefs: []
  type: TYPE_NORMAL
- en: We do need parentheses when we apply `borderIt` to the td elements, because
    we define our options using a `kwarg` (a keyword argument). All we want to do
    is set the color, so instead of supplying all preceding parameters, we simply
    reference the desired parameter as a property. The color we pass is `#000 + 80%`.
    This is not valid CSS but Stylus understands.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's explore some more Stylus features, and also find out how to use the alternative
    CSS engine, LESS, as Express middleware.
  prefs: []
  type: TYPE_NORMAL
- en: Nested mixins and rest parameters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's take a look at reusing mixins in other mixins, and Stylus' rest parameter
    syntax (essentially a single parameter that consumes any following parameters,
    compiling them into an array).
  prefs: []
  type: TYPE_NORMAL
- en: We could soften the edges of our table further by rounding the relevant angles
    of the corner`<td>` elements, such that they match the rounded nature of the outer
    border.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to be able to set a radius for an individual corner. Vendor implementations
    differ on their approach to this. In Mozilla-based browsers, the corner is defined
    after radius with no dash, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Whereas WebKit conforms to the specification (except the prefix) with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Let's create another mixin dedicated to creating the rounded corners CSS, whether
    corners are equal or not.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '`sides` is a rest parameter. It swallows up all remaining arguments. We need
    two sides for a corner, for example, top left. So we use a conditional statement
    to check if length of the remaining arguments is 2 (instead of `is` we could have
    used `==)`.'
  prefs: []
  type: TYPE_NORMAL
- en: If we have our sides, we integrate them into the various browser-specific CSS.
    Notice when including variables in a property we escape them with curly brackets
    ({}). If sides aren't specified we set the radius to all sides, as in our recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can call this mixin from our `borderIt` mixin as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'We didn''t have to wrap the conditional statement with braces. This just allows
    us to keep our `if` statement and mixin call on the same line. It''s the equivalent
    to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we apply our single corners to the relevant `td` elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Our first `borderIt` now calls the `rndCorner` mixin inferentially because it
    sets a radius. The second `borderIt` won't call `rndCorner`, which is great because
    we want to call it ourselves on specific elements.
  prefs: []
  type: TYPE_NORMAL
- en: We use the special ampersand (`&`) referencer to cite the parent `tr` element.
    We use CSS's `:nth-child(2)` to select the second row of our table. The first
    row consists of `th` elements. The same applies for `first-child` and `last-child`,
    which we use to apply the appropriate corners to our `td` elements.
  prefs: []
  type: TYPE_NORMAL
- en: While this `:nth-child` and `:last-child` pseudo-selectors won't work in Internet
    Explorer 8 and below, neither will `border-radius`, so this is one of the few
    cases we can use it and still be cross-browser compatible, progressively enhancing
    in more modern browsers.
  prefs: []
  type: TYPE_NORMAL
- en: Playing with colors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Stylus does some amazing things with color. It has functions that allow us to
    lighten/darken, (de)saturate, hue adjust, and even mix colors together.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s color our table in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: We can reference values of any properties already set for an element, We use
    the `@background` property lookup variable consistently throughout this piece
    of code, but in many cases it holds a different value.
  prefs: []
  type: TYPE_NORMAL
- en: To start off, we invert our `#profile` table, setting `color` to white, and
    `background` to black. We next apply color to our `td` elements, obtaining a lighter
    shade of blue by adding `35%` to it. We match our `td` borders to their `background`
    colors with the `@background` property lookup.
  prefs: []
  type: TYPE_NORMAL
- en: Then we just go wild with color mixing, eventually setting the text color of
    our `td` to a color not far from the original pink. We then pass `@color` to desaturate
    while also lightening it using `+`. Next, we set the hover text color by adding
    180 degrees to our `@background` color, obtaining the complimentary hue. We also
    `desaturate` our `background` and match `border-color` (`@background` now matches
    the `desaturated` background, whereas when we set the color on hover it matched
    the pre-hover background color).
  prefs: []
  type: TYPE_NORMAL
- en: 'So now our table looks as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Playing with colors](img/7188-06-03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Using the LESS engine
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'LESS may be suitable as a more familiar and verbose alternative to Stylus.
    We can use LESS with Express by replacing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'With:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'To ensure this works, we should also change our `package.json` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'And run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: To test it out, we'll rewrite our recipe in LESS.
  prefs: []
  type: TYPE_NORMAL
- en: Some Stylus features have no equivalent in LESS. Instead of using `@extend`
    to inherit our `pad` class, we'll convert it into a mixin. There are no `if` conditionals
    in LESS either, so we'll declare the `.borderIt` mixin twice, the second time
    using the `when` statement.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: We save this to `views/styles.less`. Express compiles it to `public/styles.css`
    and once again our `#profiles` table has rounded corners.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Templating in Express* discussed in this chapter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Generating Express scaffolding* discussed in this chapter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initializing and using a session
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we want to maintain state between page requests, we use sessions. Express
    supplies middleware that takes much of the complexity out of managing sessions.
    In this recipe, we're going to use Express to make a session between a browser
    and server to facilitate a user login process.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s create a fresh project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: This will create a new Express skeleton named `login`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In our `app.js file`, we make the following changes to `app.configure:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Sessions are dependent on cookies, so we need both `cookieParser` and `session`
    middleware.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Express 2 to Express 3**'
  prefs: []
  type: TYPE_NORMAL
- en: In Express 3, we set the secret string through `cookieParser` instead of `session:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll finish `app.js` with some route handling as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: The `GET` requests will serve pages as normal, the `POST` requests will be interpreted
    as login attempts. These will first be passed to a validating route which checks
    for valid user data. The `DELETE` request will clear the session with `routes.logout`
    and then pass over to `routes.index`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now to edit the `routes/index.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let''s put a login form together in a file. We''ll call `login.jade`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**_method**'
  prefs: []
  type: TYPE_NORMAL
- en: Notice how our logout form uses a hidden input named `_method`. Setting this
    value to `DELETE` overrides the `POST` method that the form is set to. This is
    made possible by the `methodOverride` middleware inside `app.configure` within
    the `app.js` file.
  prefs: []
  type: TYPE_NORMAL
- en: We'll include this form within `index.jade:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: Now if we run our app, and navigate to `http://localhost:3000`, we'll see a
    login form. We enter username `dave`, password `expressrocks` and now we see a
    greeting with the option to logout.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to use sessions we have to include some additional middleware. We do
    this within `app.configure. express.parseCookie` comes first because `express.session`
    is dependent on it.
  prefs: []
  type: TYPE_NORMAL
- en: '`express.session` takes a mandatory object containing the `secret` property
    (or in Express 3 the secret is set by passing a string argument to `express.cookieParser).
    secret` is used to generate the session hash, so it needs to be unique and unknown
    to outsiders.'
  prefs: []
  type: TYPE_NORMAL
- en: When we set up our routes, we assume that `POST` requests to the `/` path are
    login attempts, and thus pass them first to the `login` route, and `DELETE` requests
    to `/` are to be processed primarily by the `logout` route.
  prefs: []
  type: TYPE_NORMAL
- en: Our `login` route checks the posted login details (using `req.body`, which is
    supplied to us by the `bodyParser` middleware) against our placeholder `users`
    object. In a real-world scenario, `login` would rather be validating against a
    database of users.
  prefs: []
  type: TYPE_NORMAL
- en: If everything checks out, we add a `user` object to the session, and place the
    `name` and password (pwd) into it.
  prefs: []
  type: TYPE_NORMAL
- en: 'When pushing user details to the session, we could have taken a shortcut and
    said:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: However, doing so could leave us open for an attacker to fill the `req.session.user`
    object with anything they desire, in potentially large amounts. While any data
    being entered into session would be entered by a trusted user (one with login
    details), and although `bodyParser` has built-in safety limits for POST data,
    it is always better to err on the side of conservatism over convenience.
  prefs: []
  type: TYPE_NORMAL
- en: The `index` route remains the same, except that we set a `user` property, to
    which we pass `req.session.user`.
  prefs: []
  type: TYPE_NORMAL
- en: This enables `login.jade` to check the `user` variable. If it is set, `login.jade`
    shows a greeting along with a small form containing a link that sends a POST request
    with a `DELETE` override to the server, thus triggering the `logout` route via
    `app.del`.
  prefs: []
  type: TYPE_NORMAL
- en: The `logout` route simply deletes the `user` object from `req.session`, passes
    control to the `index.route` (using `next)`, which pushes a non-existent `req.session.user`
    back to Jade via `res.render`.
  prefs: []
  type: TYPE_NORMAL
- en: When Jade finds that there is no `user` it displays the login form, which is
    of course also output to a pre-login request.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can improve the way we interact with sessions.
  prefs: []
  type: TYPE_NORMAL
- en: Custom middleware for site-wide session management
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This recipe is fine if we want to pass our login and logout requests to just
    one route. However, as our routes and views increase, managing the complexities
    with sessions could become burdensome. We can mitigate this somewhat by creating
    our own custom middleware for session-handling purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In preparation to test from different URLs, we''ll modify our routes as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: We're not using routes to control our session logic, so we've removed the middle
    routes, sending them straight to `routes.index. :page` would probably point to
    another route, but we'll leave it as `routes.index` for brevity.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `routes/index.js`, we can now simply have the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s create a file and call it `login.js`, writing the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we''re no longer using routes, we don''t have the opportunity to pass
    `req.session.user` through `res.render`. However, we can use a dynamic helper
    instead. Dynamic helpers have access to the `req` and `res` objects, they''re
    called just before a view is rendered. Any properties we pass to the dynamic helper
    object are pushed to the Jade view as local variables. In `app.js`, just above
    our routes we put:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Express 2 to Express 3**'
  prefs: []
  type: TYPE_NORMAL
- en: In Express 3, dynamic helpers are set with `app.locals.use:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: Rather than sending an object containing desired locals, local variables are
    explicitly set by adding them to the `res.locals` object.
  prefs: []
  type: TYPE_NORMAL
- en: Now we simply include `login.js` as middleware inside the `app.configure` callback
    of `app.js:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we''ll modify `login.jade` so instead of:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'We have:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: This makes the form POST to whatever address it is submitted from.
  prefs: []
  type: TYPE_NORMAL
- en: Now all the muscle work is performed by `login.js`. The bottom half of the exported
    function performs the same actions as our recipe. We have to check the methods
    manually since we're not using the Express router.
  prefs: []
  type: TYPE_NORMAL
- en: In the top half we access `req.app`. In `app.js`, the `app` variable is the
    result of the `express.createServer`. Express allows us to access our server within
    middleware and routes with a reference to the server instance under `req.app`.
  prefs: []
  type: TYPE_NORMAL
- en: In our interaction with `req.app`, we work with `req.app.routes.routes` which
    we store in the `routes` variable. This property holds any routes we defined using
    `app.get, app.post`, and so on. The routes are stored by request method type,
    for example, `req.app.routes.routes.post` holds an array of all the `app.post`
    routes. If a route method hasn't been defined, we simply call `next` and `return`.
    This lets Express handle the problem of an undefined method. Each item in the
    array is an object, containing `path, method, callbacks, keys`, and `regexp` properties.
    We loop through all routes for the `request` method, and use the `regexp` property
    to determine if there is a `match` for the requested URL. If there isn't, we reset
    the method to `GET`. We do this to transparently ensure that the `POST` and `DELETE`
    requests can be served through any URL and not return a `404 error` if a `post`
    or `del` route hasn't been defined for them.
  prefs: []
  type: TYPE_NORMAL
- en: If this piece of code was missing, the login or logout mechanism would still
    occur, but the user would be left with a `not found` message. For instance, if
    we navigate to `http://localhost:3000/anypage`, and attempt to log in, our middleware
    will catch the request first. It will determine if login conditions are met (a
    POST request with `user` in the body) and processes it accordingly. If no POST
    route has been defined for `/anypage`, we reset the method to GET. The middleware
    later calls `next`, passing control over to `app.router`, which never sees the
    POST method and thus reloads the `/:page` GET route.
  prefs: []
  type: TYPE_NORMAL
- en: Back in `app.js` we have Express' `dynamicHelpers` method. The `dynamicHelpers`
    method registers the helper, but it isn't called until just before a view is rendered
    (which means the dynamic helper is executed after all our route callbacks). This
    is convenient because it allows our routes to interact with `req.session.user`
    further if required. We pass an object to `dynamicHelpers` containing a `user`
    property. The ultimate value of the `user` property is loaded directly into our
    view as a variable. In the same way we can pass variables to views via the `res.render`
    options object within a route. The `user` property holds a callback which is evaluated
    by Express. It works much like a route or middleware callback except a `return`
    value is expected. We `return req.session.user`, so as in the main recipe, `req.session.user`
    is now available in `login.jade` as `user`. If there is no session, we make sure
    to reset the URL to `/` so that other routes cannot be used to bypass our authorization
    process.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we call `next` which passes control to the next middleware, which in
    our case is `app.router`.
  prefs: []
  type: TYPE_NORMAL
- en: Flash messages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Express provides a simple interface for session-based flash messages. A flash
    message is held in a session object for one request, and then disappears. It's
    an easy way to generate request associated information or error messages.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Express 2 to Express 3**'
  prefs: []
  type: TYPE_NORMAL
- en: Express 3 doesn't support session flash messages out of the box. However, connect-flash
    provides this functionality as middleware.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the dependencies section of our `package.json` file we would add:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'And then do a:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we would require `connect-flash` and call it inside the `app.configure`
    callback, after the cookie and session middleware:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s modify our `login.js` file from the previous extension to our recipe
    (*Custom middleware for site wide session management)*. We''re going to modify
    it to flash an error message for invalid login details. First, we''ll need to
    alter the code located at the bottom of our exported function, inside the `if
    (login)` conditional:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'This works fine, but we can do better. Let''s tidy it up by extracting our
    validation code into a separate function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: Although everything happening in `validate` is synchronous, we've written it
    in asynchronous style (that is, passing values through a callback instead of returning
    values). This is because, in reality, we wouldn't use an object to store user
    details. We would use a remote database, which would have to be accessed asynchronously.
    In the next recipe, we'll be storing our user details in a MongoDB database and
    asynchronously reading it to validate login requests. The `validate` function
    is structured with this in mind.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we replace our middleware user validation code with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: Our `validate` function uses the same Boolean method. However, it's tucked out
    of the way. Also notice the various strategic calls to `next` — either when exiting
    early from an error, adding a user session, or at the very end. Placing these
    `next` calls within the callback context future proofs our validation function
    for asynchronous operations, which is important for database interactions.
  prefs: []
  type: TYPE_NORMAL
- en: We use the `callback(err)` style from the `validate` function to let our middleware
    know whether the login was successful. `err` is simply an object containing the
    error message (msg), it's only passed if `valid` is not true.
  prefs: []
  type: TYPE_NORMAL
- en: If `err` is present, we call `req.flash`, which is the built-in Express method
    that pushes an object called `flash` onto `req.session`. Once the request is fulfilled,
    the object is emptied of all properties.
  prefs: []
  type: TYPE_NORMAL
- en: We need to make this object available to `login.jade`, so we'll add another
    dynamic helper over in `app.js`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Express 2 to Express 3**'
  prefs: []
  type: TYPE_NORMAL
- en: 'To add flash messages in Express 3, we''d simply add it to the `res.locals`
    object in our preexisting `app.locals.use` callback:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: We could use `req.session.flash`, but `req.flash()` will do the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, at the top of `login.jade` we write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: If login details are incorrect, the user receives a bold error notification
    between horizontal lines.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Making an Express web app* discussed in this chapter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Templating in Express* discussed in this chapter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Dynamic routing* discussed in this chapter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making an Express web app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we're going to combine a lot of previous recipes together, also
    throwing in a few extra Express features (such as app mounting) in order to create
    the foundations of an Express-based web app with integrated administration features.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start fresh, from the command line we say:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: Profiler is the name of our new app, it will be a profile manager for members
    of the Node community.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to edit `package.json` to say:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: We've set the name to `Profiler` adding `stylus` and `mongoskin`, setting stricter
    version requirements for `mongoskin`. Jade and Stylus are built to work with Express,
    so they're likely to remain compatible with new releases (although we've restricted
    Stylus to minor version updates). Mongoskin has its own development processes.
    To ensure our project isn't broken by future versions with possible API changes
    we've locked the version 0.3.6 (though this doesn't mean we can't upgrade at a
    later date).
  prefs: []
  type: TYPE_NORMAL
- en: 'So we get our dependencies with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: We also need to ensure MongoDB is installed and running on our system, see the
    *Storing and retrieving data with MongoDB* recipe of [Chapter 4](ch04.html "Chapter 4. Interfacing
    with Databases"), *Interfacing with Databases*, for details.
  prefs: []
  type: TYPE_NORMAL
- en: 'In short, we start Mongo with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll also push some data into MongoDB to get us started. Let''s create a
    new folder in the `profiler` directory, and call it `tools`. Then pull our `profiles.js`
    module from[Chapter 1](ch01.html "Chapter 1. Making a Web Server"), *Making a
    Web Server*, into it, creating a new file called `prepopulate.js`. Inside it we
    write the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: When executed, this gives us a database named `profiler` with a `profiles` and
    `users` collection.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we'll be using the entire login app of the previous recipe. However,
    we'll want it with the site-wide session management and flash messages (in the
    code examples, this folder is called `login_flash_messages)`. So let's copy the
    `login` folder to our new profile directory as `profiler/login`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Creating a database bridge
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s begin with some backend coding. We''ll create a new folder called `models`,
    and create a file inside it called `profiles.js`. This is going to be used to
    manage all our interactions with the MongoDB profiles collection. In `models/profiles.js`
    we put:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve defined three methods: `pull, del`, and `add`. Each one operates on
    the database asynchronously, and executes a user callback once data is returned,
    or operation is complete. We''ve set a low rows-per-page limit (`rowsPer`) to
    allow us to test our pagination work (the dividing of content into pages) with
    the few records we have.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We must also modify `login/login.js`, which we created in the previous recipe,
    to hook up our login app to the MongoDB user collection. The main module can remain
    untouched. We only have to change the way we validate a user, everything above
    `module.exports` changes to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: Configuring app.js files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now let's modify `app.js`.
  prefs: []
  type: TYPE_NORMAL
- en: '`app.configure` should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: We've fired up the Stylus engine and thrown in a favicon server for good measure.
    The last line `app.use` actually mounts our login app at the `/admin` route (we
    copied `login` into our profiler directory in *Getting ready)*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s add our one and only route to our main `app.j` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: We've specified an optional placeholder called `:pagenum`, which must consist
    of one or more digits. So `/, /1, /12`, and `/125452` would all be valid routes,
    but `/alphaCharsPage` would not.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we''ll set up some extra configuration details in the `app.js` of our `login`
    app in `login/app.js` as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Express 2 to Express 3**'
  prefs: []
  type: TYPE_NORMAL
- en: Remember in Express 3, the secret goes in the `express.cookieParser` as a string
    instead of inside an object passed into `express.session`.
  prefs: []
  type: TYPE_NORMAL
- en: The `login` app will be pulling in our profiles table from the `profiler` app.
    We've configured it to use Stylus as we'll be applying extra admin-specific Stylus-generated
    CSS. We've also added a helper variable called `masterviews`. This will later
    be used to locate the absolute path of our app's main views directory. The `login`
    app will need to know this in order to load views from its parent `profiler` app.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we''ll modify the routes in our `login/app.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: Adding the optional `:pagenum` to the `get` method route enables navigation
    of the profiles table as in the main app. Adding `:pagenum` to the `post` method
    route allows users to log in from pages they may have previously navigated to,
    (for example, this allows a login form to be served from `http://localhost:/admin/2`
    if a user's session is expired). Likewise, the `del` method route will allow us
    to log out from any valid page.
  prefs: []
  type: TYPE_NORMAL
- en: We've also added a `/del` and `/add` route for processing admin tasks.
  prefs: []
  type: TYPE_NORMAL
- en: When one Express app is mounted inside another, calling the `listen` method
    on the sub-app causes a port conflict. Sub-apps do not have to listen, their parent
    app does the listening for them.
  prefs: []
  type: TYPE_NORMAL
- en: 'So we modify the `listen` invocation of `login/app.js` to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: '`module` is a built-in Node global. The parent property tells us whether or
    not our app is being loaded by another app. Since our login app is being loaded
    by the profiler app, `app.listen` won''t trigger.'
  prefs: []
  type: TYPE_NORMAL
- en: The login app is the gatekeeper of our administration section within which we
    will be able to add and remove profiles.
  prefs: []
  type: TYPE_NORMAL
- en: Now that our main app and mounted app are suitably prepared, we can move onto
    editing our views, styles, and routes.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying the profiler app
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's start with the `profiler` apps `index.jade` view.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we''re including `profiles.jade`, let''s write it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Express 2 to Express 3**'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re using a `partial` (see *Jade Partials* discussed in *Templating in Express)*
    in `profiles.jade`. Express 3 no longer supports partials so we would need to
    iterate through the rows manually instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: '`profiles.jade` should be saved to the `profiler/views` directory, it is based
    on our `profiles` table in the previous recipes. However, we''ve added code to
    support seamless integration with the login app and some additional HTML structure
    for pagination.'
  prefs: []
  type: TYPE_NORMAL
- en: At the top of `profiles.jade`, we've included a safety net to ensure our view
    doesn't choke if `masterviews` is undefined. For pagination, we've added a `tfoot`
    element to hold the back and forward links with a complimentary `thead` to hold
    wrap the `th` elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re using a partial to load each row, this will be loaded from `row.jade`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: We've also included some Jade mixin invocations. We'll be defining these mixins
    when we come to edit the `login` apps views.
  prefs: []
  type: TYPE_NORMAL
- en: Let's create a new `stylesheets` directory under `views` and place a file in
    it called `style.styl`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `views/stylesheets/style.styl` we write the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: This is the same Stylus sheet from the *Playing with color* section under *There's
    more..*. in the *CSS engines with Express* recipe, but with some modifications.
  prefs: []
  type: TYPE_NORMAL
- en: Since we've placed our `th` elements under a `thead`, we can simply select our
    `tbody tr` elements by `:first-child` instead of `:nth-child(2)`. We also add
    some styling for the new `tfoot` element.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we'll write the `routes/index.js` file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: Our `index` route makes a call via our `models/profiles.js` module to MongoDB,
    passing it the desired page number, and retrieves some profiles to display.
  prefs: []
  type: TYPE_NORMAL
- en: It also calls our `patchMixins` function, included prior to our route, with
    an array of mixin names found in `profiles.jade`. These mixins don't exist yet.
    Furthermore, the mixins will only be available when we're logged in to `http://localhost:8080/admin`.
    This is intentional, the mixins will provide administrative controls which lie
    on top of our `profiles` table, we only want them to appear when a user is logged
    in.
  prefs: []
  type: TYPE_NORMAL
- en: However, if we don't include dummy mixins in the place of the admin mixins,
    Node will throw an error.
  prefs: []
  type: TYPE_NORMAL
- en: Internally, Jade mixins are compiled into JavaScript functions before they are
    executed within our view templates. So we create dummy `no-op` (no operation)
    functions to prevent a server error. Then when we do log in, they are replaced
    with the administration mixins.
  prefs: []
  type: TYPE_NORMAL
- en: If we navigate to `localhost:3000` we should now have a functioning `profiler`
    app.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying the mounted login App
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In `login/views`, we currently have `index.jade, login.jade`, and `layout.jade`.
    In `login.jade`, we want to add two `includes` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: Rather than repeating code, we reuse our `profiles.jade` view from the main
    app using a relative path. This means any changes we make to our frontend site
    are also made to our administration section! `admin.jade` is going to contain
    Jade mixins (which are conceptually similar to Stylus mixins). These mixins are
    conditionally included in `profiles.jade` (see the previous *Modifying the profiler
    app* section).
  prefs: []
  type: TYPE_NORMAL
- en: So in `admin.jade:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: We have two includes in `admin.jade`, one as part of a mixin, and the other
    as a straight include.
  prefs: []
  type: TYPE_NORMAL
- en: '`addfrm.jade` should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'And `adminScript.jade` should contain the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: Admin is positioned above profiles in `login.jade`, so `#addfrm` will sit above
    the `#profiles` table. However, our `adminScript` mixin hides the table, showing
    it when the **Add** button is clicked.
  prefs: []
  type: TYPE_NORMAL
- en: 'We create a `stylesheets` folder under `login/views`, creating `admin.styl`
    in it and write the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: Now we're also reusing the Stylus sheet from our main app. The `@import` declarative
    is handled by Stylus on the server side (unless the extension is `.css)`. As a
    result, our main app's `styles.styl` sheet is combined with `admin.styl` and compiled
    as one CSS file in `login/public/stylesheets/admin.css`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To load our `admin.css` file, we must alter the login app''s `layout.jade`
    view as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: We've altered the `link href` attribute from `/stylesheet/style.css` to `/admin/stylesheets/admin.css`,
    ensuring that CSS is loaded from the static server on our sub-apps route.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we complete our admin routes, in `login/routes/index.js` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: We should now be able to log in to `http://localhost:3000/admin` to delete and
    add profiles as `Dave`, with password `expressrocks`, or as `Mr.Page`, with password
    `hellomynamesmrpage`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Login security**'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to hash our passwords and log in over
    SSL.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our app contains a lot of pieces working together. So let's look at it from
    various angles.
  prefs: []
  type: TYPE_NORMAL
- en: App mounting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this recipe, we have two apps working with the same database, sharing views
    and Stylus sheets. We imported the login app to our new `profiler` folder and
    mounted it with `app.use` setting `/admin` as its route.
  prefs: []
  type: TYPE_NORMAL
- en: This works because Express apps are an assemblage of middleware, so when we
    mount the login app it simply integrates with our app as a middleware plugin.
    Middleware works on the request and response objects. By passing the `/admin`
    route into `app.use`, we limit the login app to work only with requests made under
    that route.
  prefs: []
  type: TYPE_NORMAL
- en: Data Flow
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Our app is supported by a MongoDB database that we set up with our `prepopulate.js`
    tool. Data flows to and from the database as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Data Flow](img/7188_06_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '`models/profiles.js` pulls and pushes data to the profiles collection, providing
    an interface for the `routes/index.js` files in both master and sub-apps. Our
    routes integrate within their respective `app.js` files, and work to interact
    with models/profiles.js to carry out the desired tasks.'
  prefs: []
  type: TYPE_NORMAL
- en: '`login.js` simply verifies the user''s credentials, performing a search with
    user-supplied input. `login.js` sits as a piece of middleware within `login/app.js`,
    waiting to respond to POST requests containing a username and password.'
  prefs: []
  type: TYPE_NORMAL
- en: Route handling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In both apps, the `index` route provides a foundation for displaying and navigating
    the profiles table. In both we call `profiles.pull`, passing in `req.params.pagenum`.
    The `pagenum` parameter is loaded onto `req.params`. It will never by anything
    but a number — thanks to our restrictions placed on it, though it is optional
    so may not be present.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `profiles.pull` takes two parameters: the page number and a callback. If
    the page number isn''t present, it sets the `page` to `1`. We determine which
    rows to extract by multiplying our internal `rowsPer` variable by `page —1` (we
    want to start at the beginning with page 1, therefore, for the first page we skip
    0 rows). The result is passed through as the `skip` modifier to MongoDB, as well
    as `rowsPer` being passed as the `limit` property. `skip` will pass over a predetermined
    number of rows before outputting and `limit` restricts the amount to output; thus
    we achieve pagination.'
  prefs: []
  type: TYPE_NORMAL
- en: The `profiles.pull` callback is initiated either with an error, or with an object
    containing profiles. In both our `index` routes, we perform minimal error handling.
    Express tends to capture the errors and output them to the browser for debugging
    purposes. `profiles` is passed to `res.render` where it is later utilized by the
    `profiles.jade` view.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `login/app.js`, two inflexible routes are defined: `/add` and `/del`. The
    `/del` route is a basic GET request pointing to `routes.delprof`, it expects two
    query parameters: `id` and `p. id` is passed to `profiles.del`, which calls the
    Mongoskin `removeByID` method, effectively deleting a profile from the collection.
    We pass the `cb` parameter directly to the `removeById` callback, making the `profiles.del`
    callback a direct result of `removeById`.'
  prefs: []
  type: TYPE_NORMAL
- en: Back in `login/routes/index.js`, as long as no error has occurred, we invoke
    `profiles.pull`, with the `p` query parameter, updating the `profiles` object
    to the views using `app.helpers`. This ensures that changes to the database are
    reflected to the user. Finally, we redirect the user back to where they came from.
  prefs: []
  type: TYPE_NORMAL
- en: The `/add` route works in much the same way, except as a POST request. The `req.body`
    is returned as an object, we can simply insert this object straight into MongoDB
    (since it is JSON-like).
  prefs: []
  type: TYPE_NORMAL
- en: Views
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We use a lot of `includes` in our views, and sometimes between apps, the relationships
    look as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Views](img/7188_06_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In our main app, the index view loads the profiles view, and profiles utilizes
    the rows view in a `partial` statement.
  prefs: []
  type: TYPE_NORMAL
- en: In the login app, the index view includes the login view. The login view loads
    the profiles view and, under the right conditions, also includes the admin view
    (before profiles) to provide the administration layer. Admin includes the `addfrm`
    and `adminScript` views. The mixins defined in admin become available to profiles.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `profiles.jade` view is very central to the entire web app, it outputs
    our data, delivers the optional administration overlay, and provides navigational
    capabilities. Let''s take a look at the navigational portion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: The `page` variable is passed through from the `index` route, and is determined
    from `req.params.pagenum`. If page is `0` (or false), we set it to `1`, which
    in the user's mind is the first page. We then create a variable named `s`. In
    Jade, we don't have to use `var`, Jade takes care of the complications. If we
    are on the first page, a link to the previous pages is unnecessary, so add a style
    attribute containing `display:none` (if we wanted to be neater, we could have
    a CSS class set `display` and add a class attribute instead). By passing `null`,
    if the `page` is greater than one, we're telling Jade that we don't want to set
    the style attribute at all.
  prefs: []
  type: TYPE_NORMAL
- en: Mixins
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The only place we use Jade mixins is in the `login/views/admin.jade` view, but
    they are essential to the synergy between the admin section and the top-level
    site. Unless a user is logged in and under the `/admin` route, the mixins are
    not present in `profiles.jade`. They are only intended for privileged users.
  prefs: []
  type: TYPE_NORMAL
- en: We use mixins to supplement the `profiles` table with an administration layer.
    The only part of `admin.jade` that isn't a mixin is the final `include` of `addfrm.jade`.
    As admin is included before profiles, `#addfrm` sits above the `profiles` table.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `adminScript` mixin is, as the name suggests, a `script` block that quickly
    applies an `id` of `js` to the `body` tag. We use this in `admin.styl` to hide
    our `#addfrm` (the generated CSS would be `#js #addfrm {display:none})`. This
    is quicker than directly hiding the element with JavaScript and minimizes the
    undesirable flash of content effect that can occur when hiding page elements on
    page load. Therefore, `#addfrm` is not initially visible. In the following screenshot,
    we can see the visible mixins displayed on the `#profiles` table within the admin
    section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Mixins](img/7188-06-04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Clicking on the **Add** button causes the `#profiles` table to fade out and
    `#addfrm` to fade in. The `del` mixin takes an `id` argument, which it then uses
    to generate a link for each profile, such as `/del?id=4f3336f369cca0310e000003&p=1`.
    The `p` variable is determined from the `page` property passed in at `res.render`
    time in the `index` route.
  prefs: []
  type: TYPE_NORMAL
- en: Helpers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We use both static and dynamic helpers in the login app. Dynamic helpers sit
    between the final piece of route middleware and rendering of the view. So they
    have the last call on what is sent out. The dynamic helpers in our app stay the
    same.
  prefs: []
  type: TYPE_NORMAL
- en: Static helpers are set when the app spins up and can be overwritten at any time.
    These helpers are stored within `app._locals`, along with other Express presets
    (such as the `settings` object we use for our `base` variable in the `profiles`
    view). We use `app.mounted` within our login app to access the parent app object
    to discover our parent app's view directory from `parent._locals.settings.views`.
    Then we pass that back as the `masterviews` helper to our login apps views.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `profiles.jade` we do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: If, in our sub-app, we include a view from the parent app' and that view includes
    another parent view, or loads a partial with a parent view, we can use `masterviews`
    to ensure that the partial is loaded from the parent directory. `masterviews`
    enables `profiles.jade` to operate in both realms.
  prefs: []
  type: TYPE_NORMAL
- en: Styles
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Our Stylus files also share a degree of interconnectivity, as shown in the
    following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Styles](img/7188_06_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: User flow
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All of these things work together to provide a website with an admin section.
  prefs: []
  type: TYPE_NORMAL
- en: A user can browse the profiles table, using the back and forward links, and
    they can link to a particular page on the table.
  prefs: []
  type: TYPE_NORMAL
- en: A privileged user can navigate to `/admin`, enter their login details, and proceed
    to add and delete records. The `/add` and `/delete` routes are protected by the
    middleware. Unless the user is logged in, the only route that gets delivered to
    them is the login app's `index` route asking for login details.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's look at ways to monitor and analyze our web app.
  prefs: []
  type: TYPE_NORMAL
- en: Benchmarking
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Benchmarking a Node website can be very satisfying, but there's always going
    to be room for improvement.
  prefs: []
  type: TYPE_NORMAL
- en: Apache Bench (ab) comes bundled with Apache servers, and while Apache have no
    part in NodeJS, their HTTP benchmarking utility is an excellent tool for stress
    testing our app's ability to respond to a large amount of simultaneous requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use it to test the performance benefits or hindrances of any changes
    to our app. Let''s quickly throw 1,000 requests, 50 at a time, at both the site
    and the admin section as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: Mileage will vary depending on system capabilities. However, since tests are
    run on the same machine, conclusions can be drawn from differences between tests.
  prefs: []
  type: TYPE_NORMAL
- en: With our test on the two sections, `/` delivers at 120 requests per second,
    whereas `/admin` serves at just under 160 request per second. This makes sense
    because the `/admin` page will only be serving a login form, whereas the `/` route
    is pulling data from MongoDB, performing iteration logic on the `profiles` object,
    and using a partial to display the rows.
  prefs: []
  type: TYPE_NORMAL
- en: Using logger
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Express comes with Connects logger middleware, which outputs useful custom-defined
    information from our app. In a production scenario, this information can be an
    essential part of site maintenance.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use logger, we include it before all other middleware as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, logger outputs something as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: It contains useful information about the request, the IP address of the client,
    the user agent string, and the content length (908 and 1395 respectively in the
    example output). We can use this information to determine a host of facts (for
    example, browser stats, geo-locational stats, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: 'During development, we may want to set `logger` as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: This outputs color-formatted request information to the console, containing
    the request method (GET, for instance), the requested route, status number (such
    as 200), and time for the request to complete.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also pass in tokens. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: 'We can even define our own tokens as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: If the referrer is the same as our host, we mask it with `#local#`. Later, we
    could filter all lines containing `#local#`.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, `logger` outputs to the console. However, we can pass it a stream
    to output to. Logger would allow us to stream logs over TCP, HTTP, or simply to
    a file. Let''s make our logs go to a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: This time we give `logger` an object instead of a string. In order to set the
    formatting through the object we set the `format` property. To redirect the stream
    of output, we create a `writeStream` to our desired log file.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more logger options, see [http://www.senchalabs.org/connect/middleware-logger.html.](http://www.senchalabs.org/connect/middleware-logger.html.)
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Dynamic routing* discussed in this chapter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Templating in Express* discussed in this chapter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*CSS engines with Express* discussed in this chapter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Initializing and using a session* discussed in this chapter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
