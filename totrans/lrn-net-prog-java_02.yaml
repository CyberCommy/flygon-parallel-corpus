- en: Chapter 2. Network Addressing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For a program to communicate with another program, it must have an address.
    In this chapter, the use of addresses, including Internet addresses, will be examined.
    We will introduce many of the basic concepts in the first part of this chapter.
    This includes the architecture of networks and the protocols that are used to
    communicate between the nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will address several topics, including:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Network basics**: This is where essential concepts and terms are introduced'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Using the NetworkInterface class**: This provides access to system devices'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**URL/UII/URN**: We will discuss how these terms relate to each other'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The Inet4Address and Inet6Address classes**: We will discuss how these are
    used'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Network properties**: We will consider the properties that are configurable
    in Java'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This will provide you with the foundation to pursue networking in more depth.
  prefs: []
  type: TYPE_NORMAL
- en: Networking basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Networking is a broad and complex topic. In particular, a subtopic, such as
    addressing, is quite involved. We will introduce the terms and concepts that are
    commonly encountered and useful from a Java perspective.
  prefs: []
  type: TYPE_NORMAL
- en: Most of this discussion will focus on Java support for the Internet. A **Uniform
    Resource Locator** (**URL**) is recognized by most Internet users. However, the
    terms **Uniform Resource Identifier** (**URI**) and **Uniform Resource Name**
    (**URN**) are not recognized or understood as well as URL. We will differentiate
    between these terms and examine the Java supporting classes.
  prefs: []
  type: TYPE_NORMAL
- en: A browser user would normally enter a URL for the site that they would like
    to visit. This URL needs to be mapped to an IP address. The IP address is a unique
    number identifying the site. The URL is mapped to an IP address using a **Domain
    Name System** (**DNS**) server. This avoids a user having to remember a number
    for each site. Java uses the `InetAddress` class to access IP addresses and resources.
  prefs: []
  type: TYPE_NORMAL
- en: UDP and TCP are used by many applications. IP supports both of these protocols.
    The IP protocol transfers packets of information between nodes on a network. Java
    supports both the IPv4 and IPv6 protocol versions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Both UDP and TCP are layered on top of IP. Several other protocols are layered
    on top of TCP, such as HTTP. These relationships are shown in this following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Networking basics](img/B04915_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When communications occur between different networks using different machines
    and operating systems, problems can occur due to differences at the hardware or
    software level. One of these issues is the characters used in URLs. The `URLEncoder`
    and `URLDecoder` classes can help address this problem, and they are discussed
    in [Chapter 9](ch09.html "Chapter 9. Network Interoperability"), *Network Interoperability*.
  prefs: []
  type: TYPE_NORMAL
- en: The IP address assigned to a device may be either **static** or **dynamic**.
    If it is static, it will not change each time the device is rebooted. With dynamic
    addresses, the address may change each time the device is rebooted or when a network
    connection is reset.
  prefs: []
  type: TYPE_NORMAL
- en: Static addresses are normally manually assigned by an administrator. Dynamic
    addresses are frequently assigned using the **Dynamic Host Configuration Protocol**
    (**DHCP**) running from a DHCP server. With IPv6, DHCP is not as useful due to
    the large IPv6 address space. However, DHCP is useful for tasks, such as supporting
    the generation of random addresses, which introduce more privacy within a network
    when viewed from outside of the network.
  prefs: []
  type: TYPE_NORMAL
- en: The **Internet Assigned Numbers** **Authority** (**IANA**) is responsible for
    the allocation of IP address space allocations. Five **Regional Internet Registries**
    (**RIRs**) allocate IP address blocks to local Internet entities that are commonly
    referred to as **Internet Service Providers** (**ISP**).
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several publications that detail the IP protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '**RFC 790—assigned numbers**: This specification addresses the format of network
    numbers. For example, the IPv4 A, B, and C classes are defined in this specification
    ([https://tools.ietf.org/html/rfc790](https://tools.ietf.org/html/rfc790)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**RFC 1918—address allocation for private internets**: This specification is
    concerned with how private addresses are assigned. This allows multiple private
    addresses to be associated with a single public address ([https://tools.ietf.org/html/rfc1918](https://tools.ietf.org/html/rfc1918)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**RFC 2365—administratively scoped IP multicast**: This specification defines
    the multicast address space and how it can be implemented. The mapping between
    IPv4 and IPv6 multicast address spaces is defined ([https://tools.ietf.org/html/rfc2365](https://tools.ietf.org/html/rfc2365)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**RFC 2373—IPv6 addressing architecture**: This specification examines the
    IPv6 protocol, its format, and the various address types that are supported by
    IPv6 ([http://www.ietf.org/rfc/rfc2373.txt](http://www.ietf.org/rfc/rfc2373.txt)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many of the concepts introduced here will be illustrated with Java code whenever
    possible. So let's start with understanding networks.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding network basics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A network consists of nodes and links that are combined to create network architecture.
    A device connected to the Internet is called a **node**. A computer node is called
    a **host**. Communication between nodes is conducted along these links using protocols,
    such as HTTP, or UDP.
  prefs: []
  type: TYPE_NORMAL
- en: Links can either be wired, such as coaxial cable, twisted pairs, and fiber optics,
    or wireless, such as microwave, cellular, Wi-Fi, or satellite communications.
    These various links support different bandwidth and throughput to address particular
    communication needs.
  prefs: []
  type: TYPE_NORMAL
- en: Nodes include devices, such as **Network Interface Controllers** (**NIC**),
    bridges, switches, hubs, and routers. They are all involved with transmitting
    various forms of data between computers.
  prefs: []
  type: TYPE_NORMAL
- en: The NIC has an IP address and is part of a computer. Bridges connect two network
    segments allowing a larger network to be broken down into smaller ones. Repeaters
    and hubs are used primarily to retransmit a signal boosting its strength.
  prefs: []
  type: TYPE_NORMAL
- en: Hubs, switches, and routers are similar to each other but differ in their complexity.
    A hub handles multiple ports and simply forwards the data to all connected ports.
    A switch will learn where to send data based on its traffic. A router can be programmed
    to manipulate and route messages. Routers are more useful in many networks, and
    most home networks use a router.
  prefs: []
  type: TYPE_NORMAL
- en: When a message is sent across the Internet from a home computer, there are several
    things going on. The computer's address is not globally unique. This requires
    that any messages sent to and from the computer be handled by a **Network Address
    Translation** (**NAT**) device that changes the address to one that can be used
    on the Internet. It allows a single IP address to be used for multiple devices
    on a network, such as a home LAN.
  prefs: []
  type: TYPE_NORMAL
- en: The computer may also use a proxy server, which acts as a gateway to other networks.
    Java provides support for proxies using the `Proxy` and `ProxySelector` classes.
    We will examine their use in [Chapter 9](ch09.html "Chapter 9. Network Interoperability"),
    *Network Interoperability*.
  prefs: []
  type: TYPE_NORMAL
- en: Messages are often routed through a firewall. The firewall protects the computer
    from malicious intent.
  prefs: []
  type: TYPE_NORMAL
- en: Network architectures and protocols
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Common network architectures include bus, star, and tree-type networks. These
    physical networks are often used to support an overlay network, which is a virtual
    network. Such a network abstracts the underlying network to create a network architecture
    supporting applications, such as peer-to-peer applications.
  prefs: []
  type: TYPE_NORMAL
- en: When two computers communicate, they use a protocol. There are many different
    protocols used at various layers of a network. We will mainly focus on HTTP, TCP,
    UDP, and IP.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several models depicting how networks can be layered to support different
    tasks and protocols. One common model is the **Open Systems Interconnection**
    (**OSI**) model, which defines seven layers. Each layer of a network model can
    support one or more protocols. The relationships of various protocols are depicted
    in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Layer | Example protocols | Purpose |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Application | HTTP, FTP, SNMP | High-level protocols supporting specialized
    operations |'
  prefs: []
  type: TYPE_TB
- en: '| Presentation | Transport layer security | Support delivery and processing
    of data for the application layer |'
  prefs: []
  type: TYPE_TB
- en: '| Session | Network file system | Managing sessions |'
  prefs: []
  type: TYPE_TB
- en: '| Transport | TCP, UDP | Manages packets of data |'
  prefs: []
  type: TYPE_TB
- en: '| Network | IP | Transfer packets |'
  prefs: []
  type: TYPE_TB
- en: '| Data link | Ethernet, frame relay | Transfers data between network segments
    |'
  prefs: []
  type: TYPE_TB
- en: '| Physical | DSL, Bluetooth | Handles raw data |'
  prefs: []
  type: TYPE_TB
- en: A more complete list of protocols for the OSI layers can be found at [https://en.wikipedia.org/wiki/List_of_network_protocols_(OSI_model)](https://en.wikipedia.org/wiki/List_of_network_protocols_(OSI_model)).
    We are not able address all of these protocols and will focus on the more important
    ones that are supported by the Java SDK.
  prefs: []
  type: TYPE_NORMAL
- en: Consider the transfer of a web page from a server to a client. As it is sent
    to a client, the data will be encapsulated in an HTTP message, which is further
    encapsulated in TCP, IP, and link-level protocol messages, each frequently containing
    a header and footer. This encapsulated set of headers is sent across the Internet
    to the destination client, where the data is extracted for each encapsulating
    header until the original HTML file is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, we do not need to be familiar with the details of this process.
    Many of the classes hide how this occurs, allowing us to focus on the data.
  prefs: []
  type: TYPE_NORMAL
- en: The protocols of the transport layer that we are interested in are TCP and UDP.
    TCP provides a more reliable communication protocol than UDP. However, UDP is
    better suited for short messages when delivery does not need to be robust. Streaming
    data often uses UDP.
  prefs: []
  type: TYPE_NORMAL
- en: 'The differences between UDP and TCP are outlined in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Characteristic | TCP | UDP |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Connection | Connection-oriented | Connectionless |'
  prefs: []
  type: TYPE_TB
- en: '| Reliability | Higher | Lower |'
  prefs: []
  type: TYPE_TB
- en: '| Order of packets | Order restored | Order potentially lost |'
  prefs: []
  type: TYPE_TB
- en: '| Data boundaries | Packets are merged | Packets are distinct |'
  prefs: []
  type: TYPE_TB
- en: '| Transmission time | Slower than UDP | Faster than TCP |'
  prefs: []
  type: TYPE_TB
- en: '| Error checking | Yes | Yes, but no recovery options |'
  prefs: []
  type: TYPE_TB
- en: '| Acknowledgement | Yes | No |'
  prefs: []
  type: TYPE_TB
- en: '| Weight | Heavy weight requiring more support | Light weight requiring less
    support |'
  prefs: []
  type: TYPE_TB
- en: TCP is used for a number of protocols, such as HTTP, **Simple Mail Transfer**
    **Protocol** (**SMTP**), and **File Transfer Protocol** (**FTP**). UDP is used
    by DNS to stream media, such as movies, and for **Voice Over** **IP** (**VOIP**).
  prefs: []
  type: TYPE_NORMAL
- en: Using the NetworkInterface class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `NetworkInterface` class provides a means of accessing the devices that
    act as nodes on a network. This class also provides a means to get low-level device
    addresses. Many systems are connected to multiple networks at the same time. These
    may be wired, such as a network card, or wireless, such as for a wireless LAN
    or Bluetooth connection.
  prefs: []
  type: TYPE_NORMAL
- en: The `NetworkInterface` class represents an IP address and provides information
    about this IP address. A **network interface** is the point of connection between
    a computer and a network. This frequently uses an NIC of some type. It does not
    have to have a physical manifestation, but it can be performed in software as
    done with the loopback connection (`127.0.0.1` for IPv4 and `::1` for IPv6).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `NetworkInterface` class does not have any public constructors. Three static
    methods are provided to return an instance of the `NetworkInterface` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '`getByInetAddress`: This is used if the IP address is known'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getByName`: This is used if the interface name is known'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getNetworkInterfaces`: This provides an enumeration of available interfaces'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code illustrates how to use the `getNetworkInterfaces` method
    to obtain and display an enumeration of the network interfaces for the current
    computer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'One possible output is as follows, but it has been truncated to save space:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Name Display name**'
  prefs: []
  type: TYPE_NORMAL
- en: '**lo Software Loopback Interface 1**'
  prefs: []
  type: TYPE_NORMAL
- en: '**eth0 Microsoft Kernel Debug Network Adapter**'
  prefs: []
  type: TYPE_NORMAL
- en: '**eth1 Realtek PCIe FE Family Controller**'
  prefs: []
  type: TYPE_NORMAL
- en: '**wlan0 Realtek RTL8188EE 802.11 b/g/n Wi-Fi Adapter**'
  prefs: []
  type: TYPE_NORMAL
- en: '**wlan1 Microsoft Wi-Fi Direct Virtual Adapter**'
  prefs: []
  type: TYPE_NORMAL
- en: '**net0 Microsoft 6to4 Adapter**'
  prefs: []
  type: TYPE_NORMAL
- en: '**net1 Teredo Tunneling Pseudo-Interface**'
  prefs: []
  type: TYPE_NORMAL
- en: '**...**'
  prefs: []
  type: TYPE_NORMAL
- en: 'A `getSubInterfaces` method will return an enumeration of subinterfaces if
    any exist, as shown next. A subinterface occurs when a single physical network
    interface is divided into logical interfaces for routing purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Each network interface will have one or more IP addresses associated with it.
    The `getInetAddresses` method will return an `Enumeration` of these addresses.
    As shown next, the initial list of network interfaces has been augmented to display
    the IP addresses associated with them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'One possible output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Name Display name**'
  prefs: []
  type: TYPE_NORMAL
- en: '**lo Software Loopback Interface 1**'
  prefs: []
  type: TYPE_NORMAL
- en: '**InetAddress: /127.0.0.1**'
  prefs: []
  type: TYPE_NORMAL
- en: '**InetAddress: /0:0:0:0:0:0:0:1**'
  prefs: []
  type: TYPE_NORMAL
- en: '**eth0 Microsoft Kernel Debug Network Adapter**'
  prefs: []
  type: TYPE_NORMAL
- en: '**eth1 Realtek PCIe FE Family Controller**'
  prefs: []
  type: TYPE_NORMAL
- en: '**InetAddress: /fe80:0:0:0:91d0:8e19:31f1:cb2d%eth1**'
  prefs: []
  type: TYPE_NORMAL
- en: '**wlan0 Realtek RTL8188EE 802.11 b/g/n Wi-Fi Adapter**'
  prefs: []
  type: TYPE_NORMAL
- en: '**InetAddress: /192.168.1.5**'
  prefs: []
  type: TYPE_NORMAL
- en: '**InetAddress: /2002:6028:2252:0:0:0:0:1000**'
  prefs: []
  type: TYPE_NORMAL
- en: '**InetAddress: /fe80:0:0:0:9cdb:371f:d3e9:4e2e%wlan0**'
  prefs: []
  type: TYPE_NORMAL
- en: '**wlan1 Microsoft Wi-Fi Direct Virtual Adapter**'
  prefs: []
  type: TYPE_NORMAL
- en: '**InetAddress: /fe80:0:0:0:f8f6:9c75:d86d:8a22%wlan1**'
  prefs: []
  type: TYPE_NORMAL
- en: '**net0 Microsoft 6to4 Adapter**'
  prefs: []
  type: TYPE_NORMAL
- en: '**net1 Teredo Tunneling Pseudo-Interface**'
  prefs: []
  type: TYPE_NORMAL
- en: '**InetAddress: /2001:0:9d38:6abd:6a:37:3f57:fefa**'
  prefs: []
  type: TYPE_NORMAL
- en: '**...**'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also use the following Java 8 technique. A stream and a lambda expression
    are used to display the IP addresses to generate the same output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: There are numerous `InetworkAddress` methods, which reveal more details about
    the network connection. They will be discussed as we encounter them.
  prefs: []
  type: TYPE_NORMAL
- en: Getting a MAC address
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **Media Access Control** (**MAC**) address is used to identify an NIC. MAC
    addresses are usually assigned by the manufacturer of an NIC and are a part of
    its hardware. Each NIC on a node must have a unique MAC address. Theoretically,
    all NICs, regardless of their location, will have a unique MAC address. A MAC
    address consists of 48 bits that are usually written in groups of six pairs of
    hexadecimal digits. These groups are separated by either a dash or a colon.
  prefs: []
  type: TYPE_NORMAL
- en: Getting a specific MAC address
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Normally, MAC addresses are not needed by the average Java programmer. However,
    they can be retrieved whenever needed. The following method returns a string containing
    the IP address and its MAC address for a `NetworkInterface` instance. The `getHardwareAddress`
    method returns an array of bytes holding the number. This array is then displayed
    as a MAC address. Most of this code-segment logic is devoted to formatting the
    output, where the tertiary operator determines whether a dash should be displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The method is demonstrated in the following example where we use the localhost:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will vary depending on the computer used. One possible output is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**IP address: 192.168.1.5**'
  prefs: []
  type: TYPE_NORMAL
- en: '**MAC address: EC-0E-C4-37-BB-72**'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `getHardwareAddress` method will only allow you to access a localhost MAC
    address. You cannot use it to access a remote MAC address.
  prefs: []
  type: TYPE_NORMAL
- en: Getting multiple MAC addresses
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Not all network interfaces will have MAC addresses. This is demonstrated here,
    where an enumeration is created using the `getNetworkInterfaces` method, and then
    each network interface is displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'One possible output is as follows. The output is truncated to save space:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Name MAC Address**'
  prefs: []
  type: TYPE_NORMAL
- en: '**lo ---**'
  prefs: []
  type: TYPE_NORMAL
- en: '**eth0 ---**'
  prefs: []
  type: TYPE_NORMAL
- en: '**eth1 8C-DC-D4-86-B1-05**'
  prefs: []
  type: TYPE_NORMAL
- en: '**wlan0 EC-0E-C4-37-BB-72**'
  prefs: []
  type: TYPE_NORMAL
- en: '**wlan1 EC-0E-C4-37-BB-72**'
  prefs: []
  type: TYPE_NORMAL
- en: '**net0 ---**'
  prefs: []
  type: TYPE_NORMAL
- en: '**net1 00-00-00-00-00-00-00-E0**'
  prefs: []
  type: TYPE_NORMAL
- en: '**net2 00-00-00-00-00-00-00-E0**'
  prefs: []
  type: TYPE_NORMAL
- en: '**...**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, we can use the following Java implementation. It converts the
    enumeration into a stream and then processes each element in the stream:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The power of streams comes when we need to perform additional processing, such
    as filtering out certain interfaces, or converting the interface into a different
    data type.
  prefs: []
  type: TYPE_NORMAL
- en: Network addressing concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are different types of network addresses. An address serves to identify
    a node in a network. For example, the **Internetwork Packet Exchange** (**IPX**)
    protocol was an earlier protocol that was used to access nodes on a network. The
    X.25 is a protocol suite for **Wide Area Network** (**WAN**) packet switching.
    A MAC address provides a unique identifier for network interfaces at the physical
    network level. However, our primary interests are IP addresses.
  prefs: []
  type: TYPE_NORMAL
- en: URL/URI/URN
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: These terms are used to refer to the name and location of an Internet resource.
    A URI identifies the name of a resource, such as a website, or a file on the Internet.
    It may contain the name of a resource and its location.
  prefs: []
  type: TYPE_NORMAL
- en: 'A URL specifies where a resource is located, and how to retrieve it. A protocol
    forms the first part of the URL, and specifies how data is retrieved. URLs always
    contain protocol, such as HTTP, or FTP. For example, the following two URLs use
    different protocols. The first one uses the HTTPS protocol, and the second one
    uses the FTP protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '**https://www.packtpub.com/**'
  prefs: []
  type: TYPE_NORMAL
- en: '**ftp://speedtest.tele2.net/**'
  prefs: []
  type: TYPE_NORMAL
- en: Java provides classes to support URIs and URLs. The discussion of these classes
    begins in the next section. Here, we will discuss URNs in more depth.
  prefs: []
  type: TYPE_NORMAL
- en: A URN identifies the resource but not its location. A URN is like a city's name,
    while a URL is similar to a city's latitude and longitude. When a resource, such
    as web page, or file, is moved, the URL for the resource is no longer correct.
    The URL will need to be updated wherever it is used. A URN specifies the name
    of a resource but not its location. Some other entity, when supplied with a URN,
    will return its location. URNs are not used that extensively.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax of a URN is shown next. The `<NID>` element is a namespace identifier
    and `<NSS>` is a namespace-specific string:'
  prefs: []
  type: TYPE_NORMAL
- en: '**<URN> ::= "urn:" <NID> ":" <NSS>**'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following is a URN specifying as part of a SOAP message to
    qualify its namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'It is used in other places, such as to identify books using their ISBN. Entering
    the following URL in a browser will bring up a reference to an EJB book:'
  prefs: []
  type: TYPE_NORMAL
- en: '**https://books.google.com/books?isbn=9781849682381**'
  prefs: []
  type: TYPE_NORMAL
- en: '![URL/URI/URN](img/B04915_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The syntax of a URN depends on the namespace. The IANA is responsible for the
    allocation of many Internet resources, including URN namespaces. URNs are still
    an active area of research. URLs and URNs are both URIs.
  prefs: []
  type: TYPE_NORMAL
- en: Using the URI class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The general syntax of a URI consists of a scheme and a scheme-specific-part:'
  prefs: []
  type: TYPE_NORMAL
- en: '**[scheme:] scheme-specific-part**'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many schemes that are used with a URI, including:'
  prefs: []
  type: TYPE_NORMAL
- en: '**file**: This is used for files systems'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**FTP**: This is File Transfer Protocol'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**HTTP**: This is commonly used for websites'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**mailto**: This is used as part of a mail service'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**urn**: This is used to identify a resource by name'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The scheme-specific-part varies by the scheme that is used. URIs can be categorized
    as absolute or relative, or as opaque or hierarchical. These distinctions are
    not of immediate interest to us here, though Java provides methods to determine
    whether a URI falls into one of these categories.
  prefs: []
  type: TYPE_NORMAL
- en: Creating URI instances
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A URI can be created for different schemes using several constructor variations.
    The simplest way of creating a URI is to use a string argument specifying the
    URI, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The next URI uses a fragment to access a subsection of the Wikipedia article
    dealing with the normalization of a URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also use the following version of the constructor to specify the scheme,
    host, path, and fragment of the URI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: These latter two URIs are identical.
  prefs: []
  type: TYPE_NORMAL
- en: Splitting apart a URI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Java uses the `URI` class to represent a URI, and it possesses several methods
    to extract parts of a URI. The more useful methods are listed in the following
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Purpose |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `getAuthority` | This is the entity responsible for resolving the URI |'
  prefs: []
  type: TYPE_TB
- en: '| `getScheme` | The scheme used |'
  prefs: []
  type: TYPE_TB
- en: '| `getSchemeSpecificPart` | The scheme specific part of the URI |'
  prefs: []
  type: TYPE_TB
- en: '| `getHost` | The host |'
  prefs: []
  type: TYPE_TB
- en: '| `getPath` | The URI path |'
  prefs: []
  type: TYPE_TB
- en: '| `getQuery` | The query, if any |'
  prefs: []
  type: TYPE_TB
- en: '| `getFragment` | The sub-element being accessed, if used |'
  prefs: []
  type: TYPE_TB
- en: '| `getUserInfo` | User information, if available |'
  prefs: []
  type: TYPE_TB
- en: '| `normalize` | Removes unnecessary "." and ".." from the path |'
  prefs: []
  type: TYPE_TB
- en: There are also several "raw" methods, such as `getRawPath`, or `getRawFragment`,
    which return versions of a path or fragment, respectively. This includes special
    characters, such as the question mark, or character sequences beginning with an
    asterisk. There are several character categories defining these characters and
    their use, as documented at [http://docs.oracle.com/javase/8/docs/api/java/net/URI.html](http://docs.oracle.com/javase/8/docs/api/java/net/URI.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'We have developed the following helper method that is used to display URI characteristics:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The next code sequence creates a `URI` instance for the Packtpub website and
    then calls the `displayURI` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this sequence is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**getAuthority: www.packtpub.com**'
  prefs: []
  type: TYPE_NORMAL
- en: '**getScheme: https**'
  prefs: []
  type: TYPE_NORMAL
- en: '**getSchemeSpecificPart: //www.packtpub.com/books/content/support**'
  prefs: []
  type: TYPE_NORMAL
- en: '**getHost: www.packtpub.com**'
  prefs: []
  type: TYPE_NORMAL
- en: '**getPath: /books/content/support**'
  prefs: []
  type: TYPE_NORMAL
- en: '**getQuery: null**'
  prefs: []
  type: TYPE_NORMAL
- en: '**getFragment: null**'
  prefs: []
  type: TYPE_NORMAL
- en: '**getUserInfo: null**'
  prefs: []
  type: TYPE_NORMAL
- en: '**normalize: https://www.packtpub.com/books/content/support**'
  prefs: []
  type: TYPE_NORMAL
- en: '**http://www.packtpub.com**'
  prefs: []
  type: TYPE_NORMAL
- en: More often, these methods are used to extract relevant information for additional
    processing.
  prefs: []
  type: TYPE_NORMAL
- en: Using the URL class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the easiest ways to connect to a site and retrieve data is through the
    `URL` class. All that you need to provide is the URL for the site and the details
    of the protocol. An instance of the `InetAddress` class will hold an IP address
    and possibly the hostname for the address.
  prefs: []
  type: TYPE_NORMAL
- en: The `URLConnection` class was introduced in [Chapter 1](ch01.html "Chapter 1. Getting
    Started with Network Programming"), *Getting Started with Network Programming*.
    It can also be used to provide access to an Internet resource represented by a
    URL. We will discuss this class and its use in [Chapter 4](ch04.html "Chapter 4. Client/Server
    Development"), *Client/Server Development*.
  prefs: []
  type: TYPE_NORMAL
- en: Creating URL instances
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are several ways of creating a URL instance. The easiest is to simply
    provide the URL of the site as the argument of the class'' constructor. This is
    illustrated here where a `URL` instance for the Packtpub website is created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'A URL requires a protocol to be specified. For example, the following attempt
    to create a URL will result in a **java.net.MalformedURLException: no protocol:
    www.packtpub.com** error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'There are several constructor variations. The following two variations will
    create the same URL. The second one uses parameters for the protocol, host, port
    number, and file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Splitting apart a URL
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It can be useful to know more about a URL. We may not even know what URL we
    are using if the user entered one that we need to process. There are several methods
    that support splitting a URL into its components, as summarized in the following
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Purpose |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `getProtocol` | This is the name of the protocol. |'
  prefs: []
  type: TYPE_TB
- en: '| `getHost` | This is the host name. |'
  prefs: []
  type: TYPE_TB
- en: '| `getPort` | This is the port number. |'
  prefs: []
  type: TYPE_TB
- en: '| `getDefaultPort` | This is the default port number for the protocol. |'
  prefs: []
  type: TYPE_TB
- en: '| `getFile` | This returns the result of `getPath` concatenated with the results
    of `getQuery`. |'
  prefs: []
  type: TYPE_TB
- en: '| `getPath` | This retrieves the path, if any, for the URL. |'
  prefs: []
  type: TYPE_TB
- en: '| `getRef` | This is the return name of the URL''s reference. |'
  prefs: []
  type: TYPE_TB
- en: '| `getQuery` | This returns the query part of the URL if present. |'
  prefs: []
  type: TYPE_TB
- en: '| `getUserInfo` | This returns any user information associated with the URL.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `getAuthority` | The authority usually consists of the server host name or
    IP address. It may include the port number. |'
  prefs: []
  type: TYPE_TB
- en: 'We will use the following method to illustrate the methods in the preceding
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The following output demonstrates the output when several URL are used as arguments
    to this method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The URL class also supports opening connections and IO streams. We demonstrated
    the `openConnection` method in [Chapter 1](ch01.html "Chapter 1. Getting Started
    with Network Programming"), *Getting Started with Network Programming*. The `getContent`
    method returns the data referenced by the URL. For example, the following applies
    the method against the Packtpub URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**sun.net.www.protocol.http.HttpURLConnection$HttpInputStream@5c647e05**'
  prefs: []
  type: TYPE_NORMAL
- en: This suggests that we need to use an input stream to process the resource. The
    type of data depends on the URL. This topic is explored with the `URLConnection`
    class that is discussed in [Chapter 4](ch04.html "Chapter 4. Client/Server Development"),
    *Client/Server Development*.
  prefs: []
  type: TYPE_NORMAL
- en: IP addresses and the InetAddress class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An IP address is a numerical value that is used to identify a node, such as
    a computer, printer, scanner, or a similar device. It is used for network interface
    addressing, and location addressing. The address, unique in its context, identifies
    the device. At the same time it constitutes a location in the network. A name
    designates an entity, such as [www.packtpub.com](http://www.packtpub.com). Its
    address, `83.166.169.231`, tells us where it is located. If we want to send or
    receive a message from a site, the message is unusually routed though one or more
    nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Obtaining information about an address
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `InetAddress` class represents an IP address. The IP protocol is a low-level
    protocol used by the UDP and TCP protocols. An IP address is either a 32-bit or
    a 128-bit unsigned number that is assigned to a device.
  prefs: []
  type: TYPE_NORMAL
- en: 'IP addresses have a long history and use two major versions: IPv4 and IPv6\.
    The number 5 was assigned to the **Internet Stream Protocol**. This was an experimental
    protocol, but it was never actually referred to as version IPv5 and was not intended
    for general use.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `InetAddress` class'' `getAllByName` method will return the IP address
    for a given URL. In the following example, the addresses associated with [www.google.com](http://www.google.com)
    are displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'One possible output is as follows. The output will vary depending on the location
    and time because many web sites have multiple IP addresses assigned to them. In
    this case, it uses both IPv4 and IPv6 addresses:'
  prefs: []
  type: TYPE_NORMAL
- en: '**www.google.com/74.125.21.105**'
  prefs: []
  type: TYPE_NORMAL
- en: '**www.google.com/74.125.21.103**'
  prefs: []
  type: TYPE_NORMAL
- en: '**www.google.com/74.125.21.147**'
  prefs: []
  type: TYPE_NORMAL
- en: '**www.google.com/74.125.21.104**'
  prefs: []
  type: TYPE_NORMAL
- en: '**www.google.com/74.125.21.99**'
  prefs: []
  type: TYPE_NORMAL
- en: '**www.google.com/74.125.21.106**'
  prefs: []
  type: TYPE_NORMAL
- en: '**www.google.com/2607:f8b0:4002:c06:0:0:0:69**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `InetAddress` class possesses several methods to provide access to an IP
    address. We will introduce them as they become relevant. We start with methods
    to return its canonical hostname, hostname, and host address. They are used in
    the following helper method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The canonical hostname is a **Fully Qualified Domain Name** (**FQDN**). As the
    term implies, it is the full name of the host, including the top-level domain.
    The values returned by these methods depend on several factors, including the
    DNS server. The system provides information regarding entities on the network.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following sequence uses the display method for the Packtpub website:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'You will get an output that is similar to the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '**www.packtpub.com/83.166.169.231**'
  prefs: []
  type: TYPE_NORMAL
- en: '**CanonicalHostName: 83.166.169.231**'
  prefs: []
  type: TYPE_NORMAL
- en: '**HostAddress: 83.166.169.231**'
  prefs: []
  type: TYPE_NORMAL
- en: '**HostName: www.packtpub.com**'
  prefs: []
  type: TYPE_NORMAL
- en: The `InetAddress` class' `toString` method returned the hostname, followed by
    the forward slash and then the host address. The `getCanonicalHostName` method,
    in this case, returned the host address, which is not the FQDN. The method will
    do its best to return the name but may not be able to depending on the machine's
    configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Address scoping issues
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The scope of an IP address refers to the uniqueness of an IP address. Within
    a local network, such as those used in many homes and offices, the address may
    be local to that network. There are three types of scopes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Link-local**: This is used within a single local subnet that is not connected
    to the Internet. No routers are present. Allocation of link-local addresses is
    done automatically when the computer does not have a static IP-address and cannot
    find a DHCP server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Site-local**: This is used when the address does not require a global prefix
    and is unique within a site. It cannot be reached directly from the Internet and
    requires a mapping service such as NAT.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Global**: As its name implies, the address is unique throughout the Internet.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are also private addresses that are discussed in the *Private addresses
    in IPv4* and *Private addresses in IPv6* sections. The `InetAddress` class supports
    several methods to identify the type of address being used. Most of these methods
    are self-explanatory, as found in the following table where MC is an abbreviation
    for multicast:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Scope | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `isAnyLocalAddress` | Any | This is an address that matches any local address.
    It is a wildcard address. |'
  prefs: []
  type: TYPE_TB
- en: '| `isLoopbackAddress` | Loopback | This is a loopback address. For IPv4, it
    is `127.0.0.1`, and for IPv6, it is `0:0:0:0:0:0:0:1`. |'
  prefs: []
  type: TYPE_TB
- en: '| `isLinkLocalAddress` | Link-local | This is a link-local address. |'
  prefs: []
  type: TYPE_TB
- en: '| `isSiteLocalAddress` | Site-local | This is local to a site. They can be
    reached by other nodes on different networks but within the same site. |'
  prefs: []
  type: TYPE_TB
- en: '| `isMulticastAddress` | MC | This is a multicast address. |'
  prefs: []
  type: TYPE_TB
- en: '| `isMCLinkLocal` | MC link-local | This is a link-local multicast address.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `isMCNodeLocal` | MC node local | This is a node-local multicast address.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `isMCSiteLocal` | MC site-local | This is a site-local multicast address.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `isMCOrgLocal` | MC org local | This is an organization-local multicast address.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `isMCGlobal` | MC global | This is a global multicast address. |'
  prefs: []
  type: TYPE_TB
- en: 'The addresses types and ranges used are summarized in the following table for
    IPv4 and IPv6:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Address type | IPv4 | IPv6 |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Multicast | `224.0.0.0` to `239.255.255.25` | Begins with byte `FF` |'
  prefs: []
  type: TYPE_TB
- en: '| MC global | `224.0.1.0` to `238.255.255.255` | `FF0E` or `FF1E` |'
  prefs: []
  type: TYPE_TB
- en: '| Org MC | `239.192.0.0/14` | `FF08` or `FF18` |'
  prefs: []
  type: TYPE_TB
- en: '| MC site-local | N/A | `FF05` or `FF15` |'
  prefs: []
  type: TYPE_TB
- en: '| MC link-local | `224.0.0.0` | `FF02` or `FF12` |'
  prefs: []
  type: TYPE_TB
- en: '| MC node local | `127.0.0.0` | `FF01` or `FF11` |'
  prefs: []
  type: TYPE_TB
- en: '| Private | `10.0.0.0` to `10.255.255.255``172.16.0.0` to `172.31.255.255``192.168.0.0`
    to `192.168.255.255` | `fd00::/8` |'
  prefs: []
  type: TYPE_TB
- en: Testing reachability
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `InetAddress` class'' `isReachable` method will attempt to determine whether
    an address can be found. If it can, the method returns `true`. The following example
    demonstrates this method. The `getAllByName` method returns an array of an `InetAddress`
    instance available for the URL. The `isReachable` method uses an integer argument
    to specify how long to wait in milliseconds at a maximum before deciding that
    the address is not reachable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The URL [www.packtpub.com](http://www.packtpub.com) was reachable, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**www.packtpub.com/83.166.169.231 is reachable**'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, [www.google.com](http://www.google.com) was not:'
  prefs: []
  type: TYPE_NORMAL
- en: '**www.google.com/173.194.121.52 is not reachable**'
  prefs: []
  type: TYPE_NORMAL
- en: '**www.google.com/173.194.121.51 is not reachable**'
  prefs: []
  type: TYPE_NORMAL
- en: '**www.google.com/2607:f8b0:4004:809:0:0:0:1014 is not reachable**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Your results may vary. The `isReachable` method will do its best to determine
    whether an address is reachable or not. However, its success depends on more than
    simply whether the address exists. Reasons for failure can include: the server
    may be down, network response time was too long, or a firewall may be blocking
    a site. The operating system and JVM settings can also impact how well the method
    works.'
  prefs: []
  type: TYPE_NORMAL
- en: An alternative to this method is to use the `RunTime` class' `exec` method to
    execute a `ping` command against the URL. However, this is not portable and may
    still suffer from some of the same factors that impact the success of the `isReachable`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the Inet4Address
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This address consists of 32 bits, permitting up to 4,294,967,296 (232) addresses.
    The human readable form of the address consists of four decimal numbers (8 bits),
    each ranging from 0 to 255\. Some of the addresses have been reserved for private
    networks and multicast addresses.
  prefs: []
  type: TYPE_NORMAL
- en: 'Early on in the use of IPv4, the first **octet** (8 bit unit) represented a
    network number (also called the network prefix or network block), and the remaining
    bits represented a **rest** field (host identifier). Later, three classes were
    used to partition the addresses: A, B, and C. These system have largely fallen
    into disuse and have been replaced by the **Classless Inter-Domain Routing** (**CIDR**).
    This routing approach allocates addresses on bit boundaries, providing more flexibility.
    This scheme is called classless in contrast to the earlier class-full systems.
    In IPv6, 64-bit network identifiers are used.'
  prefs: []
  type: TYPE_NORMAL
- en: Private addresses in IPv4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Private networks do not necessarily need global access to the Internet. This
    results in a series of addresses being allocated for these private networks.
  prefs: []
  type: TYPE_NORMAL
- en: '| Range | Number of bits | Number of addresses |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `10.0.0.0` to `10.255.255.255` | 24-bit | 16,777,216 |'
  prefs: []
  type: TYPE_TB
- en: '| `172.16.0.0` to `172.31.255.255` | 20-bit | 1,048,576 |'
  prefs: []
  type: TYPE_TB
- en: '| `192.168.0.0` to `192.168.255.255` | 16-bit | 65,536 |'
  prefs: []
  type: TYPE_TB
- en: You may recognize that the last set of addresses is used by the home network.
    A private network often interfaces with the Internet using NAT. This technique
    maps a local IP address to one accessible on the Internet. It was originally introduced
    to ease the IPv4 address shortage.
  prefs: []
  type: TYPE_NORMAL
- en: IPv4 address types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are three address types that are supported in IPv4:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Unicast**: This address is used to identify a single node in a network'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Multicast**: This address corresponds to a group of network interfaces. Members
    will join a group and a message is sent to all members of the group'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Broadcast**: This will send a message to all network interfaces on a subnet'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Inet4Address` class supports the IPv4 protocol. We will examine this class
    in more depth next.
  prefs: []
  type: TYPE_NORMAL
- en: The Inet4Address class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `Inet4Address` class is derived from the `InetAddress` class. As a derived
    class, it does not override many of the `InetAddress` class'' methods. For example,
    to obtain an `InetAddress` instance, we can use the `getByName` method of either
    class, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In either case, the address needs to be cast because the base class method is
    used in either case. The `Inet4Address` class does not add any new methods above
    and beyond that of the `InetAddress` class.
  prefs: []
  type: TYPE_NORMAL
- en: Special IPv4 addresses
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are several special IPv4 addresses, including these two:'
  prefs: []
  type: TYPE_NORMAL
- en: '**0.0.0.0**: This is called an unspecified IPv4 address (wildcard address)
    and is normally used when a network interface does not have a IP address and is
    attempting to obtain one using DHCP.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**127.0.0.1**: This is known as the loopback address. It provides a convenient
    way to send oneself a message, often for testing purposes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `isAnyLocalAddress` method will return `true` if the address is a wildcard
    address. This method is demonstrated here, where it returns `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The `isLoopbackAddress` method is shown next and will return `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We will use this frequently to test servers in subsequent chapters.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to these, other special addresses include those used for protocol
    assignments, IPv6 to IPv4 relay, and testing purposes. More details about these
    and other special addresses can be found at [https://en.wikipedia.org/wiki/IPv4#Special-use_addresses](https://en.wikipedia.org/wiki/IPv4#Special-use_addresses).
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the Inet6Address class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'IPv6 addresses use 128 bits (16 octets). This permits up to 2128 addresses.
    An IPv6 address is written as a series of eight groups, with 4 hexadecimal numbers
    each, separated by colons. The digits are case insensitive. For example, the IPv6
    address for [www.google.com](http://www.google.com) is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**2607:f8b0:4002:0c08:0000:0000:0000:0067**'
  prefs: []
  type: TYPE_NORMAL
- en: 'An IPv6 address can be simplified in several ways. Leading zeroes in a group
    can be removed. The previous example can be rewritten as:'
  prefs: []
  type: TYPE_NORMAL
- en: '**2607:f8b0:4002:c08:0:0:0:67**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consecutive groups of zeroes can be replaced with `::`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**2607:f8b0:4002:c08::67**'
  prefs: []
  type: TYPE_NORMAL
- en: 'IPv6 supports three addressing types:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Unicast**: This specifies a single network interface.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Anycast**: This type of address is assigned to a group of interfaces. When
    a packet is sent to this group, only one member of the group receives the packet,
    often the one that is closest.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Multicast**: This sends a packet to all members of a group.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This protocol does not support broadcast addressing. There is much more to IPv6
    than an increase in network size. It includes several improvements, such as easier
    administration, more efficient routing capabilities, simple header formats, and
    the elimination of the need for NAT.
  prefs: []
  type: TYPE_NORMAL
- en: Private addresses in IPv6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Private address space is available in IPv6\. Originally, it used site-local
    addresses using a block with a prefix of fec0::/10\. However, this has been dropped
    due to problems with its definition, and it was replaced with **Unique Local**
    (**UL**) addresses using the address block `fc00::/7`.
  prefs: []
  type: TYPE_NORMAL
- en: These addresses can be generated by anyone and do not need to be coordinated.
    However, they are not necessarily globally unique. Other private networks can
    use the same addresses. They cannot be assigned using a global DNS server and
    are only routable in the local address space.
  prefs: []
  type: TYPE_NORMAL
- en: The Inet6Address class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In general, using the `Inet6Address` class is not necessary unless you are
    developing an IPv6-only application. Most networking operations are handled transparently.
    The `Inet6Address` class is derived from the `InetAddress` class. The `Inet6Address`
    class''s `getByName` method uses its base class, the `InetAddrress` class''s `getAllByName`
    method, to return the first address that it finds, as shown next. This might not
    be an IPv6 address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For some of these examples to work correctly, your router may need to be configured
    to support an IPv6 Internet connection.
  prefs: []
  type: TYPE_NORMAL
- en: The `Inet6Address` class added only one method above and beyond that of the
    `InetAddress` class. This is the `isIPv4CompatibleAddress` method that is discussed
    in the *Using IPv4-compatible IPv6 addresses* section.
  prefs: []
  type: TYPE_NORMAL
- en: Special IPv6 addresses
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There is a block of addresses consisting of 64 network prefixes: `2001:0000::/29`
    through `2001:01f8::/29`. These are used for special needs. Three have been assigned
    by IANA:'
  prefs: []
  type: TYPE_NORMAL
- en: '`2001::/32`: This is the teredo tunneling, which is a transition technology
    from IPv4'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`2001:2::/48`: This is used for benchmarking purposes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`2001:20::/28`: This is used for cryptographic hash identifiers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most developers will not need to work with these addresses.
  prefs: []
  type: TYPE_NORMAL
- en: Testing for the IP address type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Normally, we are not concerned with whether the IP address is IPv4 or IPv6\.
    The differences between the two are hidden beneath the various protocol levels.
    When you do need to know the difference, then you can use either of the two approaches.
    The `getAddress` method returns a byte array. You check the size of the byte array
    to determine if it is IPv4 or IPv6\. Or you can use the `instanceOf` method. These
    two approaches are shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Using IPv4-compatible IPv6 addresses
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The dotted quad notation is a way of expressing an IPv4 address using IPv6\.
    The `::ffff:` prefix is placed in front of either the IPv4 address or its equivalent
    in hexadecimal. For example, the hexadecimal equivalent of the IPv4 address `74.125.21.105`
    is `4a7d1569`. Both represent a 32 bit quantity. Thus, any of the following three
    addresses represent the same website:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'If we used these addresses with the `displayInetAddressInformation` method,
    the output will be identical, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**/74.125.21.105**'
  prefs: []
  type: TYPE_NORMAL
- en: '**CanonicalHostName: yv-in-f105.1e100.net**'
  prefs: []
  type: TYPE_NORMAL
- en: '**HostName: yv-in-f105.1e100.net**'
  prefs: []
  type: TYPE_NORMAL
- en: '**HostAddress: 74.125.21.105**'
  prefs: []
  type: TYPE_NORMAL
- en: '**CanonicalHostName: 83.166.169.231**'
  prefs: []
  type: TYPE_NORMAL
- en: These are referred to as IPv4-compatible IPv6 addresses.
  prefs: []
  type: TYPE_NORMAL
- en: The `Inet6Address` class possesses an `isIPv4CompatibleAddress` method. The
    method returns `true` if the address is merely an IPv4 address that is placed
    inside of an IPv6 address. When this happens, all but the last four bytes are
    zero.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example illustrates how this method can be used. Each address
    associated with [www.google.com](http://www.google.com) is tested to determine
    whether it is an IPv4 or IPv6 address. If it is an IPv6 address, then the method
    is applied to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The output depends on the servers available. The following is one possible
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '**www.google.com/173.194.46.48 is not a IPv4 Compatible Address**'
  prefs: []
  type: TYPE_NORMAL
- en: '**www.google.com/173.194.46.51 is not a IPv4 Compatible Address**'
  prefs: []
  type: TYPE_NORMAL
- en: '**www.google.com/173.194.46.49 is not a IPv4 Compatible Address**'
  prefs: []
  type: TYPE_NORMAL
- en: '**www.google.com/173.194.46.52 is not a IPv4 Compatible Address**'
  prefs: []
  type: TYPE_NORMAL
- en: '**www.google.com/173.194.46.50 is not a IPv4 Compatible Address**'
  prefs: []
  type: TYPE_NORMAL
- en: '**www.google.com/2607:f8b0:4009:80b:0:0:0:2004 is not a IPv4 Compatible Address**'
  prefs: []
  type: TYPE_NORMAL
- en: 'An alternative Java 8 solution is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Controlling network properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'On many operating systems, the default behavior is to use IPv4 instead of IPv6\.
    The following JVM options can be used when executing a Java application to control
    this behavior. The first setting is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This is the default setting. If IPv6 is available, then the application can
    use either IPv4 or IPv6 hosts. If set to `true`, it will use IPv4 hosts. IPv6
    hosts will not be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second setting deals with the type of addresses used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This is the default setting. If IPv6 is available, it will prefer IPv4 addresses
    over IPv6 addresses. This is preferred because it allows backward compatibility
    for IPv4 services. If set to `true`, it will use IPv6 addresses whenever possible.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter provided an overview of the basic network terms and concepts. Networking
    is a large and complicated subject. In this chapter, we focused on those concepts
    that are relevant to networking in Java.
  prefs: []
  type: TYPE_NORMAL
- en: The `NetworkInterface` class was introduced. This class provides low-level access
    to the devices connected to a computer that support networking. We also learned
    how to obtain the MAC address for a device.
  prefs: []
  type: TYPE_NORMAL
- en: We focused on the support that Java provides to access the Internet. The foundation
    IP protocol was detailed. This protocol is supported by the `InetAddress` class.
    Java uses the `Inet4Address` and `Inet6Address` classes to support IPv4 and IPv6
    addresses, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: We also illustrated the use of the `URI` and `URL` classes. These classes possess
    several methods that allow us to obtain more information about specific instances.
    We can use these methods to split the URI or URL into parts for further processing.
  prefs: []
  type: TYPE_NORMAL
- en: We also discussed how to control some network connection properties. We will
    cover this topic in more detail in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: With this foundation in place, we can now move forward and address the use of
    the NIO packages to support networking. NIO is buffer oriented and supports nonblocking
    IO. In addition, it provides better performance for many IO operations.
  prefs: []
  type: TYPE_NORMAL
