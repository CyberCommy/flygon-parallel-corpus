- en: Chapter 5. Creating Custom Actors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using the CryENGINE actor system, we can create players or AI-controlled entities
    with custom behaviors to populate our game world.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Learning the purpose of actors and the core idea behind implementing them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a custom actor in C++ and C#
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating our first player camera handler
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing basic player movement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing the actor system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We learned what game object extensions were, and how to use them, in [Chapter
    3](ch03.html "Chapter 3. Creating and Utilizing Custom Entities"), *Creating and
    Utilizing Custom Entities*. We'll be building upon this knowledge to create a
    custom actor in C++ and C#.
  prefs: []
  type: TYPE_NORMAL
- en: Actors are represented by the `IActor` struct, and they are the game object
    extensions in the core. This means that each actor has a backing entity, and a
    game object to handle networking and the `IActor` extension.
  prefs: []
  type: TYPE_NORMAL
- en: Actors are handled by the `IActorSystem` interface, which manages the creation,
    removal, and registration of each actor.
  prefs: []
  type: TYPE_NORMAL
- en: Channel identifiers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In networked contexts, each player is assigned a channel ID and an index for
    the Net Nub, which we'll cover further in [Chapter 8](ch08.html "Chapter 8. Multiplayer
    and Networking"), *Multiplayer and Networking*.
  prefs: []
  type: TYPE_NORMAL
- en: Actor spawning
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Player actors should be spawned when a client connects to the game, inside
    `IGameRules::OnClientConnect`. To spawn an actor, use `IActorSystem::CreateActor`
    as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that the previous code only applies to player-controlled actors. Non-player
    actors can be created at any time.
  prefs: []
  type: TYPE_NORMAL
- en: Removing actors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To make sure that the player actor is properly removed when the client disconnects,
    we''ll need to manually remove it via the `IGameRules::OnClientDisconnect` callback:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Forgetting to remove the players actor after they have disconnected is likely
    to result in crashes or severe artifacts.
  prefs: []
  type: TYPE_NORMAL
- en: The view system
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to facilitate the need for a way to handle views for players and other
    camera sources, CryENGINE provides the view system, accessible via the `IViewSystem`
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: The view system is based around having any number of views, represented by the
    `IView` interface, each with the ability to update the position, orientation,
    and configuration (such as the field of view) of the view camera.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Keep in mind that only one view can be active at any one point in time.
  prefs: []
  type: TYPE_NORMAL
- en: 'New views can be created using the `IViewSystem::CreateView` method as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then set the active view using the `IViewSystem::SetActiveView` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Once activated, the view will update the system camera for each frame. To modify
    the parameters of your view, we can call `IView::SetCurrentParams`. For example,
    to change the position, use the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The current position of the view will now be (0, 0, 10).
  prefs: []
  type: TYPE_NORMAL
- en: Linking views to game objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Each view can also link itself to a game object, allowing its game object extensions
    to subscribe to `UpdateView` and `PostUpdateView` functions.
  prefs: []
  type: TYPE_NORMAL
- en: These functions allow the position, orientation, and configuration of the assigned
    view of each frame, to be easily updated. For example, this is used for actors
    in order to provide an accessible way of creating custom camera handling for each
    player.
  prefs: []
  type: TYPE_NORMAL
- en: For more information on camera handling, see the *Camera handling* section later
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Creating custom actors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we know how the actor system works, we can move on to creating our
    first actor in C# and C++.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By default, it is not possible to create actors purely using the Lua scripts.
    Typically, the actor is created in C++ and handles custom callbacks to a Lua script
    contained in the `Game/Scripts/Entities/Actors` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Creating actors in C#
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using CryMono, we can create custom actors entirely in C#. To do so, we can
    derive from the `Actor` class as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The previous code is the bare minimum for creating an actor in CryMono. You
    can then navigate to your game rules implementation and spawn the actor once the
    client connects via the `Actor.Create` static method.
  prefs: []
  type: TYPE_NORMAL
- en: The CryMono class hierarchy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you find yourself confused by the various CryMono/C# classes, see the following
    inheritance graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The CryMono class hierarchy](img/5909_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that while querying entities using `Entity.Get` (or actors via `Actor.Get`),
    you'll get an object of type `EntityBase` or `ActorBase`. This is because the
    native entities and actors exist outside the managed systems, and a limited representation
    is returned when queried for.
  prefs: []
  type: TYPE_NORMAL
- en: Using native and CryMono actors alongside each other
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you prefer creating your actor on your own in C++, you can still refer to
    it in CryMono code by using the `NativeActor` class. To do this, simply create
    a new class in C# with the name you registered your `IActor` implementation with,
    and derive from `NativeActor` as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: C++ actor registration
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Actor registration is done using a registration factory. This process can be
    automated using the `REGISTER_FACTORY` macro as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: C# declaration
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Declaring a native-based actor in C# is very easy, and only requires deriving
    from the `CryEngine.NativeActor` class as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This allows C# code to still be used, but keeps the majority of your code in
    your C++ `IActor` implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`CryEngine.NativeActor` derives directly from `CryEngine.ActorBase`, and, therefore,
    does not contain common `CryEngine.Actor` callbacks such as OnEditorReset. To
    get this additional functionality, you''ll need to create it in your `IActor`
    implementation.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating actors in C++
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create an actor in C++, we rely on the `IActor` interface. As actors are
    game object extensions in the core, we can''t simply derive from `IActor`, but
    have to use the `CGameObjectExtensionHelper` template as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The third `CGameObjectExtensionHelper` parameter defines the maximum number
    of RMI's (remote machine invocations) this game object supports. We'll cover it
    further in [Chapter 8](ch08.html "Chapter 8. Multiplayer and Networking"), *Multiplayer
    and Networking*.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the class, we'll need to implement the pure virtual methods
    defined in the `IActor` struct.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that `IActor` derives from `IGameObjectExtension`, which means that we'll
    also need to implement its pure virtual methods. For information on this, please
    see the *Implementing the game rules interface* section of [Chapter 4](ch04.html
    "Chapter 4. Game Rules"), *Game Rules*.
  prefs: []
  type: TYPE_NORMAL
- en: 'For most of the `IActor` methods, we can implement dummies that either return
    nothing, or a dummy value such as nullptr, zero, or an empty string. The exceptions
    are listed in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Function name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `IGameObjectExtension::Init` | Called to initialize the game object extension.
    Should call `IGameObjectExtension::SetGameObject` and `IActorSystem::AddActor`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Class destructor | Should always invoke `IActorSystem::RemoveActor`. |'
  prefs: []
  type: TYPE_TB
- en: '| `IActor::IsPlayer` | Used to determine whether the actor is controlled by
    a human player. We can simply return `GetChannelId() != 0` here, as the channel
    identifier is only non-zero for players. |'
  prefs: []
  type: TYPE_TB
- en: '| `IActor::GetActorClassName` | Called to get the name of the actor class,
    for example, in our case `CMyCppActor`. |'
  prefs: []
  type: TYPE_TB
- en: '| `IActor::GetEntityClassName` | Helper function to get the name of the entity
    class. We can simply return `GetEntity()->GetClass()->GetName()`. |'
  prefs: []
  type: TYPE_TB
- en: When you've resolved the pure virtual functions, move on to the next section
    to register your actor. After having done so, you can create your actor for connecting
    players in `IGameRules::OnClientConnect`.
  prefs: []
  type: TYPE_NORMAL
- en: Registering actors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To register an actor with the game framework (contained in `CryAction.dll`),
    we can use the same setup as we used while registering our C++ game rules implementation
    in `GameFactory.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: After the previous code has been executed, you'll be able to spawn your actor
    via the `IActorSystem::CreateActor` function.
  prefs: []
  type: TYPE_NORMAL
- en: Camera handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Player-controlled actors manage the viewport camera within the `IActor::UpdateView(SViewParams
    &viewParams)` and `IActor::PostUpdateView(SViewParams &viewParams)` functions.
  prefs: []
  type: TYPE_NORMAL
- en: The `SViewParams` struct is used to define camera properties such as position,
    rotation, and field of view. By modifying the `viewParams` reference inside the
    `UpdateView` method, we can move our camera to the position we require for our
    game.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: CryMono actors receive and handle the `UpdateView(ref ViewParams viewParams)`
    and `PostUpdateView(ref ViewParams viewParams)` events in the same way C++ actors
    do.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing IGameObjectView
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to get view events, we''ll need to implement and register a game object
    view. To do so, start by deriving from `IGameObjectView`, and implement the following
    two pure virtuals it includes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`UpdateView`: This is called to update the view position, rotation, and field
    of view'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PostUpdateView`: This is called after having updated the view'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After implementing the game object view, we''ll need to make sure we capture
    it when our actor extension is initialized (in Init):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Your actor should now receive view update callbacks, which can be utilized
    to move the viewport camera. Don''t forget to release the view in your destructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Creating a top-down camera
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To show how create a custom camera, we'll be expanding the sample we created
    in the previous chapter to add a custom top-down view camera. The idea is simply
    to view the character from the top, and follow its movements from a distance.
  prefs: []
  type: TYPE_NORMAL
- en: To start, open your C# actor's `UpdateView` method, or implement it in your
    `.cs` source file.
  prefs: []
  type: TYPE_NORMAL
- en: View rotation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To make the view face the top of the player, we'll be using the second column
    of the player's rotation in order to get the up direction.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Quaternions represent the player''s rotation in a manner that allows for easy
    interpolation and avoiding gimbal locks. You can obtain three columns representing
    directions of each quaternion: 0 (right), 1 (forward), and 2 (up). This is very
    useful, for example, to get a vector facing the player''s forward direction.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Unless you''ve made any changes to your actors `UpdateView` function since
    the last function, it should look similar to the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This simply puts the view camera in the exactly same position as the player,
    with the same orientation. The first change we'll have to do is move the camera
    up a bit.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, we''ll simply append the second column of the player''s rotation
    to its position, and placing the camera at the same x and y position as the player,
    but slightly above it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Feel free to go in-game and check it out. When you''re ready, we also have
    to change the view rotation to look straight down:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Done! Our camera should now be facing straight down.
  prefs: []
  type: TYPE_NORMAL
- en: '![View rotation](img/5909_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is roughly what you should be seeing with the new camera.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note the lack of a player character in view. This is because we haven''t loaded
    an object into the player entity. We can quickly resolve this by calling `EntityBase.LoadObject`
    in the `OnSpawn` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: You should now be able to see a cube representing the player character in the
    scene. Note that it is also physicalized, allowing it to push or get pushed by
    other physicalized objects.
  prefs: []
  type: TYPE_NORMAL
- en: '![View rotation](img/5909_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You should now have a basic understanding of how the player views function.
    To learn more, why not try and create your own camera, that is, an RPG-style isometric
    camera?
  prefs: []
  type: TYPE_NORMAL
- en: We can now move on to the next section, *Player input*.
  prefs: []
  type: TYPE_NORMAL
- en: Player inputs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Actors tend to be pretty boring when you can''t control them. To aid in mapping
    events to inputs, we can make use of the following three systems:'
  prefs: []
  type: TYPE_NORMAL
- en: '| System name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| IHardwareMouse | Used when there is a need for getting mouse events directly,
    such as x/y screen position and mousewheel delta. |'
  prefs: []
  type: TYPE_TB
- en: '| IActionMapManager | Allows the registration of callbacks linked to key bindings.
    This is the preferred approach for keyboard and mouse button input due to it allowing
    each player to customize their preferred inputs via their action map profile.Action
    maps are commonly exposed via an in-game interface to simplify key mapping for
    the end user. |'
  prefs: []
  type: TYPE_TB
- en: '| IInput | Used to listen to raw input events, for example, to detect when
    the Space bar was pressed or released.It is not recommended to use raw input except
    for rare edge cases such as chat and text input, instead action maps are preferable.
    |'
  prefs: []
  type: TYPE_TB
- en: The hardware mouse
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The hardware mouse implementation provides the `IHardwareMouseEventListener`
    struct to allow receiving mouse event callbacks. After deriving from and implementing
    its pure virtuals, use `IHardwareMouse::AddListener` to utilize it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Listeners are most commonly called from constructors or initialization functions.
    Make sure you don't register listeners twice, and always remove them in your class
    destructor to prevent dangling pointers.
  prefs: []
  type: TYPE_NORMAL
- en: Action maps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Briefly mentioned in the table earlier, action maps allow binding keys to a
    named action. This is used to allow simple re-mapping of inputs from different
    game states. For example, if you have a game with two types of vehicles, you might
    not want the same keys to be used for both.
  prefs: []
  type: TYPE_NORMAL
- en: Action maps also allow changing the key an action is mapped to in real time.
    This allows the player to customize their preferred input methods.
  prefs: []
  type: TYPE_NORMAL
- en: Listening for action map events
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The default action map profile is contained in `Game/Libs/Config/defaultProfile.xml`.
    When a game is released, the default profile is copied to the user's personal
    folder (typically in `My Games/Game_Title`) and can be modified by the user to
    remap keys, for example, to change which key triggers the **screenshot** action.
  prefs: []
  type: TYPE_NORMAL
- en: '![Listening for action map events](img/5909_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To listen to action map events, we'll first have to either create a new action
    in the profile xml, or choose an existing one and modify it. For this example,
    we'll utilize the existing screenshot action.
  prefs: []
  type: TYPE_NORMAL
- en: IActionListener
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The action map system provides the `IActionListener` struct to support providing
    callbacks for classes that require action map events.
  prefs: []
  type: TYPE_NORMAL
- en: 'Utilizing the listener is relatively easy:'
  prefs: []
  type: TYPE_NORMAL
- en: Derive from the `IActorListener` struct.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement the `OnAction` event.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Register your listener:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Listeners should only be registered once, which is why registration is preferred
    to take place in a constructor or initialization function.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure to remove your listener when the class instance is destroyed.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling action map sections
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The action map system allows for creating several action map sections in the
    same profile, giving the game code the ability to toggle different action map
    sections in real time. This is very useful for games with multiple player states,
    such as walking and using vehicles. In that case, the vehicle and walking action
    maps would be contained in different sections that are then enabled/disabled while
    exiting or entering vehicles.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'To enable your custom action map, call `IActionMapManager::EnableActionMap`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This should be done at the precise moment the player should be able to receive
    these new actions. In the case of the previous example, enable the "walk" action
    when the player exits a vehicle.
  prefs: []
  type: TYPE_NORMAL
- en: Animated characters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`IAnimatedCharacter` is a game object extension which allows for locomotion
    and physics integration for objects. By using it, characters can request physical
    move requests, utilize animation graph functionality, and more.'
  prefs: []
  type: TYPE_NORMAL
- en: As the extension is optional, it can be activated by any game object by simply
    acquiring it as explained in the [Chapter 3](ch03.html "Chapter 3. Creating and
    Utilizing Custom Entities"), *Creating and Utilizing Custom Entities*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Once acquired, the animated character can be used right away.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Animated character functionality such as movement requests require eEPE_OnPostStepImmediate
    physics events, which can be enabled via `IGameObject::EnablePhysicsEvent`.
  prefs: []
  type: TYPE_NORMAL
- en: Movement requests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When an animated character is physicalized as a living entity, it can request
    movement. This is essentially a wrapper for the pe_action_move physics request
    (see [Chapter 9](ch09.html "Chapter 9. Physics Programming"), *Physics Programming*,
    for more information) to allow simpler usage.
  prefs: []
  type: TYPE_NORMAL
- en: Character movement requests are very useful when dealing with advanced mechanics
    such as player movement.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note the difference between requesting movement, and simply setting the player
    position directly. By requesting velocity changes, we are able to have our entity
    react to collisions naturally.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a movement request
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To add movement requests, utilize `IAnimatedCharacter::AddMovement`, which
    requires a `SCharacterMoveRequest` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Seen in the previous code is a very basic example of a movement request, which
    will set the target on a course forward (world-space) indefinitely (if submitted
    continuously).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Movement requests have to be added via the physics loop, see ENTITY_EVENT_PREPHYSICSUPDATE
    sent via `IGameObjectExtension::ProcessEvent`.
  prefs: []
  type: TYPE_NORMAL
- en: The Mannequin animation system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Introduced with CryENGINE 3.5 is the high-level Mannequin animation system.
    The system was designed with the goal of decoupling animation and game logic,
    effectively sitting as an additional layer between the CryAnimation module and
    the game code.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Keep in mind that Mannequin can be applied to any entity, not just actors. However,
    Mannequin is integrated by default into the `IAnimatedCharacter` extension, making
    it easier for actors to utilize the new animation system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Mannequin relies on a set of types that should be clearly understood before
    starting to use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Fragment | A fragment refers to a state, for example, "Landing". Each fragment
    can specify multiple animations on several layers, as well as a selection of effects.This
    allows for much smoother animations when dealing with, for example, first- and
    third-person views simultaneously. For that issue, each fragment would contain
    one full-body animation, one first-person, and then additional sounds, particles,
    and gameplay events. |'
  prefs: []
  type: TYPE_TB
- en: '| Fragment ID | In order to avoid passing fragments directly, we can identify
    them by their Fragment ID. |'
  prefs: []
  type: TYPE_TB
- en: '| Scope | Scopes allows the decoupling parts of characters in order to keep
    handle, for example, upper and lower body animations separately.While creating
    a new scope, each fragment will be able to add additional animations and effects
    to that scope to extend its behavior.For Crysis 3, the first- and third-person
    modes were declared as separate scopes in order to allow for the same fragments
    to handle both the states simultaneously. |'
  prefs: []
  type: TYPE_TB
- en: '| Tag | Tags refer to a selection criteria, allowing subfragments to be selected
    based on the tags active.For example, if we have two fragments named "Idle" but
    one assigned to the "Injured" tag, we could dynamically switch between the two
    fragment variations based on if the player is injured or not. |'
  prefs: []
  type: TYPE_TB
- en: '| Options | If we end up with multiple fragments that share the same identifier
    and tag, we have multiple options. The default behavior is to randomly select
    one of these options when the fragment is queried, effectively creating variation
    in the entity''s animations. |'
  prefs: []
  type: TYPE_TB
- en: The Mannequin Editor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Mannequin Editor** is used to tweak character animations and mannequin
    configuration in real-time via the Sandbox Editor.
  prefs: []
  type: TYPE_NORMAL
- en: Preview setup
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **Mannequin Editor** uses the preview files stored in `Animations/Mannequin/Preview`
    in order to load a default model and animation database. When starting the **Mannequin
    Editor**, we need to load our preview setup by selecting **File** | **Load Preview
    Setup**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once loaded, we''ll be given a visual representation of the preview setup,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Preview setup](img/5909_05_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The contents of our preview file are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We'll be going through the details such as controller definitions, context data,
    and more, further into the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Creating contexts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As mentioned earlier in the chapter, contexts can be used to apply different
    animations and effects based on the character state.
  prefs: []
  type: TYPE_NORMAL
- en: We can create and modify contexts via the **Context Editor**, accessible by
    selecting **File** | **Context Editor** in the **Mannequin Editor**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating contexts](img/5909_05_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To create a new context, simply click on **New** in the upper-left corner,
    resulting in the **New Context** dialog being opened, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating contexts](img/5909_05_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This allows us to tweak the context before creating it, including selecting
    which animation database and model to use.
  prefs: []
  type: TYPE_NORMAL
- en: When you're done, simply click on **OK** to see your context created.
  prefs: []
  type: TYPE_NORMAL
- en: Creating fragments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By default, we can see the fragments toolbox in the upper-left section of the
    **Mannequin Editor**. This tool is what we'll be using to create and edit fragments,
    in addition to adding or editing options.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating fragments](img/5909_05_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Seen in the previous screenshot is the fragments toolbox with the **BackFlip**
    fragment opened up, exposing two options.
  prefs: []
  type: TYPE_NORMAL
- en: To create a new fragment, click on the **New Id…** button, type in the desired
    name into the newly-opened message box, and then click on **OK**.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should now see the **Mannequin FragmentID Editor** dialog as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating fragments](img/5909_05_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We'll now be able to select which scopes this fragment should run in. In our
    case, we simply need to check **Char3P** and click on **OK**.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should now be able to see your fragment in the fragment toolbox:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating fragments](img/5909_05_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Adding options
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There are two methods to adding new options to your fragment:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the Character Editor, select your animation and then drag it onto your
    Mannequin Fragment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Click the New button in the Fragment toolbox, and manually modify the option.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating and using tags
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As mentioned earlier, the Mannequin system allows the creation of **Tags** that
    allow for selecting specific options for each Fragment based on if the tag is
    currently active or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a new Tag, open the Mannequin Editor and select **File -> Tag Definition
    Editor**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating and using tags](img/5909_05_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once opened, you''ll be presented with the **Mannequin Tag Definitions Editor**.
    The editor provides you with two sections: **Tag Definitions** and **Tags**.'
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we'll need to do is create a **Tag Definition**. This is a file
    that keeps track of a set of tags. To do so, press the plus (*+*) symbol in the
    **Tag Definitions** section and then specify the name of your definition.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating and using tags](img/5909_05_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Great! You should now see your tag definition in the **Mannequin Tag Definitions
    Editor**. To create a new tag, select **MyTags.xml** and click on the tag creation
    icon (third from the right in the **Tags** section).
  prefs: []
  type: TYPE_NORMAL
- en: 'This presents you with a **Tag Creation** dialog in which you only need to
    specify the name of your tag. When you''re done, click on **OK** and you should
    see the tag in the **Tags** section immediately (as shown in the following screenshot):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating and using tags](img/5909_05_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Appending tags to Options
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that you have created your custom tag(s), we can select any fragment option
    in the Fragment Editor and then look a bit further down to find the Tag Toolbox:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Appending tags to Options](img/5909_05_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: By simply selecting the checkbox next to each tag when a fragment option is
    selected, we tell the animation system that the option should be prioritized when
    the specified tag is active.
  prefs: []
  type: TYPE_NORMAL
- en: Saving
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To save your **Mannequin Editor** changes, simply click on **File** | **Save
    Changes** and verify your changes in the **Mannequin File Manager** dialog that
    appears (as shown in the following screenshot):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Saving](img/5909_05_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you're ready to save, simply click on **Save** to have the system update
    the files.
  prefs: []
  type: TYPE_NORMAL
- en: Starting fragments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In C++, fragments are represented by the `IAction` interface that can be implemented
    or extended freely by each game if it is desired.
  prefs: []
  type: TYPE_NORMAL
- en: Queuing a fragment is done by calling the `IActionController::Queue` function,
    but before we do that we'll have to obtain our fragment's `FragmentId`.
  prefs: []
  type: TYPE_NORMAL
- en: Acquiring the fragment identifier
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To acquire the fragment identifier, we''ll have to get our current animation
    context in order to obtain the current controller definition, from which we can
    get the fragment ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Note how we call `IAnimatedCharacter::GetAnimationContext`. As mentioned earlier
    in the chapter, the animated character extension implements Mannequin functionality
    for us.
  prefs: []
  type: TYPE_NORMAL
- en: Queuing the fragment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that we have the fragment identifier, we can simply create a new instance
    of the action we choose to use. In our case, we''ll use the default Mannequin
    action exposed via the `TAction` template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We now have our action, with priority 0\. The animation system will compare
    the priority of queued actions in order to determine which should be used. For
    example, if two actions are queued simultaneously, with one having priority 0
    and the other priority 1, the second action with priority 1 will be selected first.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now to queue the action, simply call `IActionController::Queue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Setting tags
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To enable tags at runtime, we first have to obtain our tag''s identifier as
    shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we simply have to call `CTagState::Set`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Done! Our tag is now activated, and will show as active in the animation system.
    If your action is set to update dynamically, it will select the appropriate option
    right away.
  prefs: []
  type: TYPE_NORMAL
- en: Forcing actions into requerying options
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The default `IAction` implementation does not automatically select the relevant
    option when a tag is changed. To change this, we''ll need to create a new class
    that derives from it and override its `Update` function with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: What the previous code does is check when a better option is available, and
    select that instead.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging Mannequin
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To enable Mannequin debug, we''ll need to append the `AC_DebugDraw` flag to
    the action controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: You are now presented with visual fragment and tag selection debug information.
    This is very useful when working with Mannequin.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Mannequin for a custom entity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned earlier in the chapter, the animated character game object extension
    integrates Mannequin by default. This is very handy when using actors, but in
    some cases it might be relevant to use the functionality Mannequin provides on
    custom entities.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, we''ll need to store pointers to our action controllers and animation
    contexts in our entity extension as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We'll then need to initialize Mannequin; this is commonly done in the game object
    extension's `PostInit` function.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing Mannequin
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first thing to do is get the Mannequin interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Loading the controller definition
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next, we have to load the controller definition we created for our entity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Great! Now that we have the controller definition, we can create our animation
    context with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now create our action controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Setting the active context
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have initialized our action controller, we'll need to set our default
    context.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, get the context identifier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Then load the animation database we''ll be using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Once loaded, simply call `IActionController::SetScopeContext`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Once the context has been set, Mannequin is initialized and ready to process
    the queued fragments for your entity.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that you can change scope context at any time using the `IActionController::SetScopeContext`
    function we used previously.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how the actor system functions and created custom
    actors in C# and C++. By looking at the input and camera systems, we'll be able
    to handle basic player input and view setups.
  prefs: []
  type: TYPE_NORMAL
- en: You should also have a good understanding of the use cases of Mannequin, and
    how to set up custom entities to utilize them.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now have all the core functionalities required for a game: flow nodes, entities,
    game rules, and actors. In the following chapters, we''ll build upon existing
    knowledge and go into detail on how these systems can be used together.'
  prefs: []
  type: TYPE_NORMAL
- en: If you want to continue working on actors before moving on, feel free to try
    and implement your own actor customized for a new scenario; for example, an isometric
    camera paired with basic RPG player elements.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll be using the knowledge learned on actors to create
    **Artificial Intelligence** (**AI**).
  prefs: []
  type: TYPE_NORMAL
