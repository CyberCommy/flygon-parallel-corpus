- en: Plugins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, we explored one of the most important features of
    pytest: fixtures. We learned how we can use fixtures to manage resources and make
    our lives easier when writing tests.'
  prefs: []
  type: TYPE_NORMAL
- en: pytest is constructed with customization and flexibility in mind, and allows
    developers to write powerful extensions called **plugins**. Plugins in pytest
    can do all sorts of things, from simply providing a new fixture, all the way to
    adding command line options, changing how tests are executed, and even running
    tests written in other languages.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Learn how to find and install plugins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Have a taste of what plugins the ecosystem has to offer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding and installing plugins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned at the beginning of the chapter, pytest is written from the ground
    up with customization and flexibility in mind. The plugin mechanism is at the
    core of the pytest architecture, so much so that many of pytest's built-in features
    are implemented in terms of internal plugins, such as marks, parametrization,
    fixtures—nearly everything, even command-line options.
  prefs: []
  type: TYPE_NORMAL
- en: This flexibility has led to an enormous and rich plugin ecosystem. At the time
    of writing, the number of plugins available is over 500, and that number keeps
    increasing at an astonishing rate.
  prefs: []
  type: TYPE_NORMAL
- en: Finding plugins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Given the large number of plugins, it would be nice if there was a site that
    showed all pytest plugins along with their descriptions. It would also be nice
    if this place also showed information about compatibility with different Python
    and pytest versions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, the good news is that such a site exists, and it is maintained by the
    core development team: pytest plugin compatibility ([http://plugincompat.herokuapp.com/](http://plugincompat.herokuapp.com/)).
    On it, you will find a list of all the pytest plugins available in PyPI, along
    with Python- and pytest-version compatibility information. The site is fed daily
    with new plugins and updates directly from PyPI, making it a great place to browse
    for new plugins.'
  prefs: []
  type: TYPE_NORMAL
- en: Installing plugins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Plugins are usually installed with `pip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, to install `pytest-mock`, we execute the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: No registration of any kind is necessary; pytest automatically detects the installed
    plugins in your virtual environment or Python installation.
  prefs: []
  type: TYPE_NORMAL
- en: This simplicity makes it dead easy to try out new plugins.
  prefs: []
  type: TYPE_NORMAL
- en: An overview of assorted plugins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we will take a look at some useful and/or interesting plugins. Of course,
    it is not possible to cover all plugins here, so we will try to cover the ones
    that cover popular frameworks and general capabilities, with a few obscure plugins
    thrown in. Of course, this barely scratches the surface, but let's get to it.
  prefs: []
  type: TYPE_NORMAL
- en: pytest-xdist
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is a very popular plugin and is maintained by the core developers; it allows
    you to run tests under multiple CPUs, to speed up the test run.
  prefs: []
  type: TYPE_NORMAL
- en: 'After installing it, simply use the `-n` command-line flag to use the given
    number of CPUs to run the tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: And that's it! Now, your tests will run across four cores and hopefully speed
    up the test suite quite a bit, if it is CPU intensive, thought I/O-bound tests
    won't see much improvement, though. You can also use `-n auto` to let `pytest-xdist`
    automatically figure out the number of CPUs you have available.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that when your tests are running concurrently, and in random order,
    they must be careful to avoid stepping on each other's toes, for example, reading/writing
    to the same directory. While they should be idempotent anyway, running the tests
    in a random order often brings attention to problems that were lying dormant until
    then.
  prefs: []
  type: TYPE_NORMAL
- en: pytest-cov
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `pytest-cov` plugin provides integration with the popular coverage module,
    which provides detailed coverage reports for your code when running tests. This
    lets you detect sections of code that are not covered by any test code, which
    is an opportunity to write more tests to cover those cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'After installation, you can use the `--cov` option to provide a coverage report
    at the end of the test run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `--cov` option accepts a path to source files that should have reports generated,
    so you should pass your `src` or package directory depending on your project's
    layout.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use the `--cov-report` option to generate reports in various formats:
    XML, annotate, and HTML. The latter is especially useful to use locally because
    it generates HTML files showing your code, with missed lines highlighted in red,
    making it very easy to find those uncovered spots.'
  prefs: []
  type: TYPE_NORMAL
- en: This plugin also works with `pytest-xdist` out of the box.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `.coverage` file generated by this plugin is compatible with many
    online services that provide coverage tracking and reporting, such as `coveralls.io`
    ([https://coveralls.io/](https://coveralls.io/)[) and `codecov.io` (](https://coveralls.io/)[https://codecov.io/](https://codecov.io/)[).](https://coveralls.io/)
  prefs: []
  type: TYPE_NORMAL
- en: pytest-faulthandler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This plugin automatically enables the built-in `faulthandler` ([https://docs.python.org/3/library/faulthandler.html](https://docs.python.org/3/library/faulthandler.html))
    module when running your tests, which outputs Python tracebacks in catastrophic
    cases such as a segmentation fault. After installed, no other setup or flag is
    required; the `faulthandler` module will be enabled automatically.
  prefs: []
  type: TYPE_NORMAL
- en: This plugin is strongly recommended if you regularly use extension modules written
    in C/C++, as those are more susceptible to crashes.
  prefs: []
  type: TYPE_NORMAL
- en: pytest-mock
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `pytest-mock` plugin provides a fixture that allows a smoother integration
    between pytest and the `unittest.mock` ([https://docs.python.org/3/library/unittest.mock.html](https://docs.python.org/3/library/unittest.mock.html))
    module of the standard library. It provides functionality similar to the built-in
    `monkeypatch` fixture, but the mock objects produced by `unittest.mock` also record
    information on how they are accessed. This makes many common testing tasks easier,
    such as verifying that a mocked function has been called, and with which arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'The plugin provides a `mocker` fixture that can be used for patching classes
    and methods. Using the `getpass` example from the last chapter, here is how you
    could write it using this plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note that besides replacing `getpass.getpass()` and always returning the same
    value, we can also ensure that the `getpass` function has been called with the
    correct arguments.
  prefs: []
  type: TYPE_NORMAL
- en: The same advice on how and where to patch the `monkeypatch` fixture from the
    previous chapter also applies when using this plugin.
  prefs: []
  type: TYPE_NORMAL
- en: pytest-django
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the name suggests, this plugin allows you to test your `Django` ([https://www.djangoproject.com/](https://www.djangoproject.com/))
    applications using pytest. `Django` is one of the most famous web frameworks in
    use today.
  prefs: []
  type: TYPE_NORMAL
- en: 'The plugin provides a ton of features:'
  prefs: []
  type: TYPE_NORMAL
- en: A very nice Quick Start tutorial
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Command-line and `pytest.ini` options to configure Django
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compatibility with `pytest-xdist`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Database access using the `django_db` mark, with automatic transaction rollback
    between tests, as well as a bunch of fixtures that let you control how the database
    is managed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Fixtures to make requests to your application: `client`, `admin_client`, and
    `admin_user`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `live_server` fixture that runs a `Django` server in a background thread
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All in all, this is one of the most complete plugins available in the ecosystem,
    with too many features to cover here. It is a must-have for `Django` applications,
    so make sure to check out its extensive documentation.
  prefs: []
  type: TYPE_NORMAL
- en: pytest-flakes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This plugin allows you to check your code using `pyflakes` ([https://pypi.org/project/pyflakes/](https://pypi.org/project/pyflakes/)),
    which is a static checker of source files for common errors, such as missing imports
    and unknown variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'After installed, use the `--flakes` option to activate it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This will run the flake checks alongside your normal tests, making it an easy
    and cheap way to keep your code tidy and prevent some errors. The plugin also
    keeps a local cache of files that have not changed since the last check, so it
    is fast and convenient to use locally.
  prefs: []
  type: TYPE_NORMAL
- en: pytest-asyncio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `asyncio` ([https://docs.python.org/3/library/asyncio.html](https://docs.python.org/3/library/asyncio.html))
    module is one of the hot new additions to Python 3, providing a new framework
    for asynchronous applications. The `pytest-asyncio` plugin lets you write asynchronous
    test functions, making it a snap to test your asynchronous code.
  prefs: []
  type: TYPE_NORMAL
- en: 'All you need to do is make your test function `async def` and mark it with
    the `asyncio` mark:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The plugin also manages the event loop behind the scenes, providing a few options
    on how to change it if you need to use a custom event loop.
  prefs: []
  type: TYPE_NORMAL
- en: You are, of course, free to have normal synchronous test functions along with
    the asynchronous ones.
  prefs: []
  type: TYPE_NORMAL
- en: pytest-trio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Trio's motto is Pythonic async I/O for humans ([https://trio.readthedocs.io/en/latest/](https://trio.readthedocs.io/en/latest/)).
    It uses the same `async def`/`await` keywords of the `asyncio` standard module,
    but it is considered simpler and more friendly to use, containing some novel ideas
    about how to deal with timeouts and groups of parallel tasks in a way to avoid
    common errors in parallel programming. It is definitely worth checking out if
    you are into asynchronous development.
  prefs: []
  type: TYPE_NORMAL
- en: '`pytest-trio` works similarly to `pytest-asyncio`: you write asynchronous test
    functions and mark them using the `trio` mark. It also provides other functionality
    that makes testing easier and more reliable, such as controllable clocks for testing
    timeouts, special functions to deal with tasks, mocking network sockets and streams,
    and a lot more.'
  prefs: []
  type: TYPE_NORMAL
- en: pytest-tornado
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tornado ([http://www.tornadoweb.org/en/stable/](http://www.tornadoweb.org/en/stable/))
    is a web framework and asynchronous network library. It is very mature, works
    in Python 2 and 3, and the standard `asyncio` module borrowed many ideas and concepts
    from it.
  prefs: []
  type: TYPE_NORMAL
- en: '`pytest-asyncio` was heavily inspired by `pytest-tornado`, so it works with
    the same idea of using a `gen_test` to mark your test as a coroutine. It uses
    the `yield` keyword instead of `await`, as it supports Python 2, but otherwise
    it looks very similar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: pytest-postgresql
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This plugin allows you to test code that needs a running PostgreSQL database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a quick example of it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'It provides two fixtures:'
  prefs: []
  type: TYPE_NORMAL
- en: '`postgresql`: a client fixture that starts and closes connections to the running
    test database. At the end of the test, it drops the test database to ensure tests
    don''t interfere with one another.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`postgresql_proc`: a session-scoped fixture that starts the PostgreSQL process
    once per session and ensures that it stops at the end.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It also provides several configuration options on how to connect and configure
    the testing database.
  prefs: []
  type: TYPE_NORMAL
- en: docker-services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This plugin starts and manages Docker services you need in order to test your
    code. This makes it simple to run the tests because you don't need to manually
    start the services yourself; the plugin will start and stop them during the test
    session, as needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'You configure the services using a `.services.yaml` file; here is a simple
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This will start two services: `postgres` and `redis`.
  prefs: []
  type: TYPE_NORMAL
- en: 'With that, all that''s left to do is to run your suite with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The plugin takes care of the rest.
  prefs: []
  type: TYPE_NORMAL
- en: pytest-selenium
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Selenium is a framework targeted to automating browsers, to test web applications
    ([https://www.seleniumhq.org/](https://www.seleniumhq.org/)). It lets you do things
    such as opening a web page, clicking on a button, and then ensuring that a certain
    page loads, all programmatically. It supports all the major browsers out there
    and has a thriving community.
  prefs: []
  type: TYPE_NORMAL
- en: '`pytest-selenium` provides you with a fixture that lets you write tests that
    do all of those things, taking care of setting up `Selenium` for you.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a basic example of how to visit a page, click on a link, and check
    the title of the loaded page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '`Selenium` and `pytest-selenium` are sophisticated enough to test a wide range
    of applications, from static pages to full single-page frontend applications.'
  prefs: []
  type: TYPE_NORMAL
- en: pytest-html
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`pytest-html` generates beautiful HTML reports of your test results. After
    installing the plugin, simply run this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This will generate a `report.html` file at the end of the test session.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because pictures speak louder than words, here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/f71502c4-fb19-427a-8299-7d04fbb01c59.png)'
  prefs: []
  type: TYPE_IMG
- en: The reports can be served in a web server for easier viewing, plus they contain
    nice functionality such as checkboxes to show/hide different types of test results,
    and other plugins such as `pytest-selenium` are even able to attach screenshots
    to failed tests, as in the previous image.
  prefs: []
  type: TYPE_NORMAL
- en: It's definitely worth checking out.
  prefs: []
  type: TYPE_NORMAL
- en: pytest-cpp
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To prove the point that pytest's framework is very flexible, the `pytest-cpp`
    plugin allows you to run tests written in Google Test ([https://github.com/google/googletest](https://github.com/google/googletest))
    or Boost.Test ([https://www.boost.org](https://www.boost.org)[)](https://www.boost.org),
    which are frameworks for writing and running tests in the C++ language.
  prefs: []
  type: TYPE_NORMAL
- en: 'After they are installed, you just need to run pytest as normal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Pytest will find executable files containing test cases, detecting  automatically
    whether they are written in `Google Test` or `Boost.Python`. It will run the tests
    and report results normally, with neat formatting that is familiar to pytest users.
  prefs: []
  type: TYPE_NORMAL
- en: Running those tests with pytest means that they now can make use of several
    features, such as parallel running with `pytest-xdist`, test selection with `-k`,
    JUnitXML reports, and so on. This plugin is particularly useful for code bases
    that use Python and C++ because it allows you to run all tests with a single command,
    and you can obtain a unique report.
  prefs: []
  type: TYPE_NORMAL
- en: pytest-timeout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `pytest-timeout` plugin terminates tests automatically after they reach
    a certain timeout.
  prefs: []
  type: TYPE_NORMAL
- en: 'You use it by setting a global timeout in the command-line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Or you can mark individual tests with the `@pytest.mark.timeout` mark:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'It works by using one of the two following methods to implement its timeout
    mechanism:'
  prefs: []
  type: TYPE_NORMAL
- en: '`thread`: during test setup, the plugin starts a thread that sleeps for the
    desired timeout period. If the thread wakes up, it will dump the tracebacks of
    all the threads to `stderr` and kill the current process. If the test finishes
    before the thread wakes up, then the thread is cancelled and the test run continues.
    This is the method that works on all platforms.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`signal`: a `SIGALRM` is scheduled during test setup and canceled when the
    test finishes. If the alarm is triggered, it will dump the tracebacks of all threads
    to `stderr` and fail the test, but it will allow the test run to continue. The
    advantage over the thread method is that it won''t cancel the entire run when
    a timeout occurs, but it is not supported on all platforms.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The method is chosen automatically based on platform, but it can be changed
    in the command line or per-test by passing the `method=` parameter to `@pytest.mark.timeout`.
  prefs: []
  type: TYPE_NORMAL
- en: This plugin is indispensable in large test suites to avoid having tests hanging
    the CI.
  prefs: []
  type: TYPE_NORMAL
- en: pytest-annotate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pyannotate ([https://github.com/dropbox/pyannotate](https://github.com/dropbox/pyannotate)) is
    a project that observes runtime type information and can use that information
    to insert type annotations into the source code, and `pytest-annotate` makes it
    easy to use with pytest.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s get back to this simple test case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'After installing `pytest-annotate`, we can generate an annotations file passing
    the `--annotations-output` flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This will run the test suite as usual, but it will collect type information
    for later use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Afterward, you can call `PyAnnotate` to apply the type information directly
    to the source code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: It is very neat to quickly and efficiently annotate a large code base, especially
    if that code base is well covered by tests.
  prefs: []
  type: TYPE_NORMAL
- en: pytest-qt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `pytest-qt` plugin allows you to write tests for GUI applications written
    in the `Qt` framework ([https://www.qt.io/](https://www.qt.io/)), supporting the
    more popular sets of Python bindings for `Qt`: `PyQt4`/`PyQt5`, and `PySide`/`PySide2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'It provides a `qtbot` fixture that has methods to interact with a GUI application,
    such as clicking on buttons, entering text in fields, waiting for windows to pop
    up, and others. Here''s a quick example showing it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Here, we create a window, click on the about button, wait for the about box
    to show up, and then ensure it shows the text we expect.
  prefs: []
  type: TYPE_NORMAL
- en: 'It also contains other goodies:'
  prefs: []
  type: TYPE_NORMAL
- en: Utilities to wait for specific `Qt` signals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automatic capturing of errors in virtual methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automatic capturing of `Qt` logging messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: pytest-randomly
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tests ideally should be independent from each other, making sure to clean up
    after themselves so they can be run in any order and don't affect one another
    in any way.
  prefs: []
  type: TYPE_NORMAL
- en: '`pytest-randomly` helps you keep your test suite true to that point, by randomly
    ordering tests, changing their order every time you run your test suite. This
    helps detect whether the tests have hidden inter-dependencies that you would not
    find otherwise.'
  prefs: []
  type: TYPE_NORMAL
- en: It shuffles the order of the test items at module level, then at class level,
    and finally at the order of functions. It also resets `random.seed()` before each
    test to a fixed number, which is shown at the beginning of the test section. The
    random seed can be used at a later time to reproduce the same order with the `--randomly-seed`
    command line to reproduce a failure.
  prefs: []
  type: TYPE_NORMAL
- en: As an extra bonus, it also has special support for `factory boy` ([https://factoryboy.readthedocs.io/en/latest/reference.html](https://factoryboy.readthedocs.io/en/latest/reference.html)),
    `faker` ([https://pypi.python.org/pypi/faker](https://pypi.python.org/pypi/faker)),
    and `numpy` ([http://www.numpy.org/](http://www.numpy.org/)) libraries, resetting
    their random state before each test.
  prefs: []
  type: TYPE_NORMAL
- en: pytest-datadir
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Often, tests need a supporting file, for example a CSV file containing data
    about comedy series, as we saw in the last chapter. `pytest-datadir` allows you
    to save files alongside your tests and easily access them from the tests in a
    safe manner.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose you have a file structure such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In addition to this, you have a `series.csv` file that you need to access from
    tests defined in `test_series.py`.
  prefs: []
  type: TYPE_NORMAL
- en: 'With `pytest-datadir` installed, all you need to do is to create a directory
    with the name of the test file in the same directory and put the file there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `test_series` directory and `series.csv` should be saved to your version-control
    system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, tests in `test_series.py` can use the `datadir` fixture to access the
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '`datadir` is a Path instance pointing to the data directory ([https://docs.python.org/3/library/pathlib.html](https://docs.python.org/3/library/pathlib.html)).'
  prefs: []
  type: TYPE_NORMAL
- en: One important thing to note is that when we use the `datadir` fixture in a test,
    we are not accessing the path to the original file, but a temporary copy. This
    ensures that tests can modify the files inside the data directory without affecting
    other tests because each test has its own copy.
  prefs: []
  type: TYPE_NORMAL
- en: pytest-regressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is normally the case that your application or library contains functionality
    that produces a data set as the result.
  prefs: []
  type: TYPE_NORMAL
- en: 'Testing these results is often tedious and error-prone, producing tests such
    as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This gets old very quickly. Also, if any of the assertion fails, then the test
    stops at that point, and you won't know whether any other asserts after that point
    would also have failed. In other words, you don't get a clear picture of the overall
    failures. Most of all, this is also heavily unmaintainable because if the data
    returned by `obtain_series()` ever changes, you are in for a tedious and error-prone
    task of updating all the code.
  prefs: []
  type: TYPE_NORMAL
- en: '`pytest-regressions` provides fixtures to solve this kind of problem. General
    data such as the previous example is a job for the `data_regression` fixture:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The first time you execute this test, it will fail with a message such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'It will dump the data passed to `data_regression.check()` in a nicely formatted
    YAML file into the data directory of the `test_series.py` file (courtesy of the
    `pytest-datadir` fixture we saw earlier):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The next time you run this test, `data_regression` now compares the data passed
    to `data_regressions.check()` with the data found in `test_obtain_series.yml`
    inside the data directory. If they match, the test passes.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the data is changed, however, the test fails with a nicely formatted text
    differential  between the new data and the recorded one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In some cases, this might be a regression, in which case you can hunt down the
    bug in the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'But in this case, the new data is *correct;* you just need to run pytest with
    the `--force-regen` flag and `pytest-regressions` will update the data file with
    the new content for you:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Now, the test passes if we run it again, as the file contains the new data.
  prefs: []
  type: TYPE_NORMAL
- en: This is an immense time saver when you have dozens of tests that suddenly produce
    different but correct results. You can bring them all up to date with a single
    pytest execution.
  prefs: []
  type: TYPE_NORMAL
- en: I use this plugin myself, and I can't count the hours it has saved me.
  prefs: []
  type: TYPE_NORMAL
- en: Honorable mentions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are just too many good plugins to fit into this chapter. The previous
    sample is really just a small taste, where I tried to strike a balance between
    useful, interesting, and showing the flexibility of the plugin architecture.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few other plugins that are worth mentioning:'
  prefs: []
  type: TYPE_NORMAL
- en: '`pytest-bdd`: a behavior-driven development for pytest'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pytest-benchmark`: a fixture to benchmark code. It outputs benchmark results
    with color output'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pytest-csv`: outputs test status as CSV files'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pytest-docker-compose`: this manages Docker containers, using Docker compose
    during test runs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pytest-excel`: outputs test status reports in Excel'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pytest-git`: provides a git fixture for tests that need to deal with git repositories'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pytest-json`: outputs test statuses as json files'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pytest-leaks`: detects memory leaks, by running tests repeatedly and comparing
    reference counts'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pytest-menu`: lets the user select tests to run from a menu in the console'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pytest-mongo`: process and client fixtures for MongoDB'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pytest-mpl`: plugin that tests figures output from Matplotlib'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pytest-mysql`: process and client fixtures for MySQL'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pytest-poo`: replaces the `F` character for failing tests with the "pile of
    poo" emoji'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pytest-rabbitmq`: process and client fixtures for RabbitMQ'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pytest-redis`: process and client fixtures for Redis'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pytest-repeat`: repeats all tests or specific tests a number of times to find intermittent
    failures'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pytest-replay`: saves test runs and allows the user to execute them later,
    so as to reproduce crashes and flaky tests'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pytest-rerunfailures`: this marks tests that can be run more than once to
    eliminate flaky tests'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pytest-sugar`: changes the look and feel of the pytest console, by adding
    progress bars, emojis, instant failures, and so on'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pytest-tap`: toutputs test reports in TAP format'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pytest-travis-fold`: folds captured output and coverage reports in the Travis
    CI build log'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pytest-vagrant`: pytest fixture that works with vagrant boxes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pytest-vcr`: automatically manages `VCR.py` cassettes ([https://vcrpy.readthedocs.io/en/latest/](https://vcrpy.readthedocs.io/en/latest/)),
    using a simple mark'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pytest-virtualenv`: this provides a virtualenv fixture to manage virtual environments
    in tests'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pytest-watch`: this continuously watches for changes in the source code and
    reruns pytest'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pytest-xvfb`: this runs `Xvfb` (a virtual frame buffer) for your UI tests'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tavern`: is tan automated test for APIs using a YAML-based syntax'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`xdoctest`: rewrite of the built-in doctests module, to make doctests easier
    to write and simpler to configure'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remember, at the time of writing, the number of pytest plugins available is
    over 500, so make sure to browse the list of plugins so that you can find something
    to your liking.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at how easy it is to find and install plugins. We
    also have been shown some plugins that I use daily and find interesting. I hope
    this has given you a taste of what's possible in pytest, but please explore the
    vast number of plugins to see whether you can find any that are useful.
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating your own plugins is not a topic that is covered in this book, but
    if you are interested, here are some resources to get you started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The pytest documentation: writing plugins ([https://docs.pytest.org/en/latest/writing_plugins.html](https://docs.pytest.org/en/latest/writing_plugins.html)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Brian Okken's wonderful book about pytest Python testing with pytest, which
    delves deeper than this book does, has an excellent chapter on how to write your
    own plugins.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to use pytest with existing `unittest`-based
    test suites, including tips and suggestions on how to migrate them and incrementally
    use more of pytest's features.
  prefs: []
  type: TYPE_NORMAL
