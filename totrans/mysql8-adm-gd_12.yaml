- en: Optimizing MySQL 8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned about security, which is an important aspect
    of any production-grade application. The chapter started with an introduction
    to security and identifying common security issues. Moving on, the chapter covered
    access control mechanisms, account management, and encryption in MySQL 8\. We
    learned various MySQL 8 security plugins in the later part of the chapter. Security
    is an important benchmark for every production-grade application. That's why the
    previous chapter is an important one.
  prefs: []
  type: TYPE_NORMAL
- en: Moving along a similar line, with the objective of developing highly optimized
    databases, this chapter focuses on optimization methods. It starts with an overview
    of what optimization means in MySQL 8\. It takes the reader through MySQL 8 server
    and client optimization, optimizing database structure, and optimizing common
    queries and database tables. Later in the chapter, emphasis is given to buffering
    and caching techniques.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a list of topics to be covered:'
  prefs: []
  type: TYPE_NORMAL
- en: Overview of MySQL 8 optimization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimizing MySQL 8 servers and clients
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimizing database structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimizing queries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimizing tables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leveraging buffering and caching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overview of MySQL 8 optimization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start with understanding MySQL 8 optimization. Optimization is the process
    of identifying performance bottlenecks and implementing optimized solutions to
    overcome these issues. Optimization in MySQL 8 involves performance measurement,
    configuration, and tuning at several different levels. It is an important task
    for an administrator to optimize the performance at different levels, like individual
    SQL queries, entire database applications, database servers, or distributed database
    servers. Performance optimization at the CPU and memory levels improves scalability.
    It also allows the database to handle more complex queries without slowing down
    the database server.
  prefs: []
  type: TYPE_NORMAL
- en: 'The performance of a database depends on multiple factors. At the database
    level, these factors can be tables, queries, and configurations. Database server
    startups and database query executions are a couple of the events when these constructs
    impact the CPU or perform I/O (Input/Output) operations at the hardware level.
    This is a responsibility of the MySQL 8 database administrator: to make sure that
    the hardware performance stands at an optimum level. It is required that the hardware
    is used with the maximum efficiency possible. At the software level, performance
    optimization starts by learning generic rules and guidelines and measuring performance
    with clock time. Gradually, we understand the internals of various database operations.
    We can measure the performance in terms of CPU cycles and I/O operations. To attain
    the best database performance, we can optimize the software and hardware configurations
    at a basic level. At an advanced level, we can improve MySQL itself by developing
    custom storage engines and hardware appliances, which expand the MySQL ecosystem.'
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing the database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What is the most important factor in making the database perform at the optimum
    speed? The answer is, basic database design. The following is a checklist to keep
    an eye on for database design:'
  prefs: []
  type: TYPE_NORMAL
- en: The database columns have to be of the right data types. Tables must have appropriate
    columns for the purposes to be served. Applications that have frequent operations
    to be performed on the database have many tables with fewer columns, whereas applications
    that analyze large amounts of data have limited tables with many columns.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we learned in one of the previous chapters, database indexing plays an important
    role in enhancing query performance. So, it is important to have correct indexes
    in place for query execution efficiency.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We discussed database storage engines, such as `MyISAM` or `InnoDB`, in earlier
    chapters. Use of an appropriate storage engine for each individual table is important.
    `InnoDB` is preferable for transactional database tables, whereas `MyISAM` is
    preferable for defining non-trasactional database tables. The choice of storage
    engine plays a vital role in defining the performance and scalability of the database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the chapter on MySQL 8 data types, we learned about row formats in detail.
    It is again important for each to have an appropriate row format. The choice of
    row format depends on the storage engine chosen. Compressed tables occupy less
    disk space and require fewer disk I/O operations. For `InnoDB` tables, compression
    is available for all read and write operations. On the contrary, compression is
    available for read-only `MyISAM` tables.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The MySQL database supports multiple locking strategies. The locking can be
    at a table-level or a row-level. The application must use an appropriate locking
    strategy. By granting shared access wherever appropriate, it becomes possible
    to run database operations concurrently. Also, it should be possible to request
    exclusive access, so that critical database operations can be executed with data
    integrity issues and priority can be maintained. In this case, the choice of storage
    engine is again significant. The `InnoDB` storage engine handles most locking
    issues without user involvement. It allows for better concurrency and reduces
    the amount of experimentation and tuning for the code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The memory areas must use the correct caching size. It should be large enough
    to hold frequently accessed data, and at the same time, not so large that they
    overload physical memory and cause paging. The `InnoDB` buffer pool and `MyISAM`
    key cache are the main memory areas to be configured.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For newly created tables, `MyISAM` is the default storage engine. In practical
    use, `InnoDB` advanced performance features mean that tables with `InnoDB` storage
    engines outperform the `MyISAM` tables for an operations-heavy database.
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing the hardware
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Growth is the nature of every software application. As the application grows,
    so does the database. The database becomes more and more busy in performing operations.
    At a certain point, the database application eventually hits the hardware limits.
    An administrator must evaluate the possibility of tuning the application or re-configuring
    the server to avoid these issues. It should also be evaluated whether deploying
    more hardware resources would help. System bottlenecks usually arise from the
    following sources:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Disk seeks**: As part of the disk read operation, finding a piece of data
    takes time for the disk. The mean time for finding a piece of data is usually
    lower than 10 milliseconds with modern disks. So, in theory, it should be 100
    seeks per second. With technological evolution, the new disks have improvements
    on the disk time, but it is very hard to optimize for single tables. To optimize
    the seek time, it is necessary to distribute data across more than one disk.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Disk reading and writing**: To read or write data from a disk, it is required
    for the disk to be at the correct position. One disk delivers at least 10 to 20
    MB of throughput per second (throughput is the amount of data read or written
    per second). So, the read and write throughput is more easily optimized than the
    seek time, as we can read in parallel from multiple disks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CPU cycles**: We must process the data when it is in the main memory to get
    the desired result. With large tables, the amount of memory is the most common
    limiting factor. With small tables, however, speed is usually not an issue.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Memory bandwidth**: In an uncommon scenario, the main memory bandwidth becomes
    a bottleneck when the CPU needs more data than can be fit in the CPU cache memory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimizing MySQL 8 servers and clients
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section focuses on optimization for MySQL 8 database servers and clients,
    starting with optimizing the server and followed by optimizing MySQL 8 client-side
    entities. This section is more relevant to database administrators, to ensure
    performance and scalability across multiple servers. It would also help developers
    preparing scripts (which includes setting up the database) and users running MySQL
    for development and testing to maximize the productivity.
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing disk I/O
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will learn ways to configure storage devices to devote more
    and faster storage hardware to the database server. A major performance bottleneck
    is disk seeking (finding the correct place on the disk to read or write content).
    When the amount of data grows large enough to make caching impossible, the problem
    with disk seeds becomes apparent. We need at least one disk seek operation to
    read, and several disk seek operations to write things in large databases where
    the data access is done more or less randomly. We should regulate or minimize
    the disk seek times using appropriate disks.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to resolve the disk seek performance issue, increasing the number
    of available disk spindles, symlinking the files to different disks, or stripping
    disks can be done. The following are the details:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Using symbolic links**: When using symbolic links, we can create a Unix symbolic
    links for index and data files. The symlink points from default locations in the
    data directory to another disk in the case of `MyISAM` tables. These links may
    also be striped. This improves the seek and read times. The assumption is that
    the disk is not used concurrently for other purposes. Symbolic links are not supported
    for `InnoDB` tables. However, we can place `InnoDB` data and log files on different
    physical disks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Striping**: In striping, we have many disks. We put the first block on the
    first disk, the second block on the second disk, and so on. The *N* block on the
    (N % number-of-disks) disk. If the stripe size is perfectly aligned, the normal
    data size will be less than the stripe size. This will help to improve the performance.
    Striping is dependent on the stripe size and the operating system. In an ideal
    case, we would benchmark the application with different stripe sizes. The speed
    difference while striping depends on the parameters we have used, like stripe
    size. The difference in performance also depends on the number of disks. We have
    to choose if we want to optimize for random access or sequential access. To gain
    reliability, we may decide to set up with striping and mirroring (RAID 0+1). **RAID**
    stands for **Redundant Array of Independent Drives**. This approach needs 2 x
    *N* drives to hold *N* drives of data. With a good volume management software,
    we can manage this setup efficiently.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is another approach to it, as well. Depending on how critical the type
    of data is, we may vary the RAID level. For example, we can store really important
    data, such as host information and logs, on a RAID 0+1 or RAID N disk, whereas
    we can store semi-important data on a RAID 0 disk. In the case of RAID, parity
    bits are used to ensure the integrity of the data stored on each drive. So, RAID
    N becomes a problem if we have too many write operations to be performed. The
    time required to update the parity bits in this case is high.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If it is not important to maintain when the file was last accessed, we can mount
    the file system with the `-o noatime` option. This option skips the updates on
    the file system, which reduces the disk seek time. We can also make the file system
    update asynchronously. Depending upon whether the file system supports it, we
    can set the `-o async` option.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using NFS with MySQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While using a **Network File System** (**NFS**), varying issues may occur,
    depending on the operating system and the NFS version. The following are the details:'
  prefs: []
  type: TYPE_NORMAL
- en: Data inconsistency is one issue with an NFS system. It may occur because of
    messages received out of order or lost network traffic. We can use TCP with `hard`
    and `intr` mount options to avoid these issues.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MySQL data and log files may get locked and become unavailable for use if placed
    on NFS drives. If multiple instances of MySQL access the same data directory,
    it may result in locking issues. Improper shut down of MySQL or power outage are
    other reasons for filesystem locking issues. The latest version of NFS supports
    advisory and lease-based locking, which helps in addressing the locking issues.
    Still, it is not recommended to share a data directory among multiple MySQL instances.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maximum file size limitations must be understood to avoid any issues. With NFS
    2, only the lower 2 GB of a file is accessible by clients. NFS 3 clients support
    larger files. The maximum file size depends on the local file system of the NFS
    server.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimizing the use of memory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to improve the performance of database operations, MySQL allocates
    buffers and caches memory. As a default, the MySQL server starts on a **virtual
    machine** (**VM**) with 512 MB of RAM. We can modify the default configuration
    for MySQL to run on limited memory systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following list describes the ways to optimize MySQL memory:'
  prefs: []
  type: TYPE_NORMAL
- en: The memory area which holds cached `InnoDB` data for tables, indexes, and other
    auxiliary buffers is known as the `InnoDB` buffer pool. The buffer pool is divided
    into pages. The pages hold multiple rows. The buffer pool is implemented as a
    linked list of pages for efficient cache management. Rarely used data is removed
    from the cache using an algorithm. Buffer pool size is an important factor for
    system performance. The `innodb__buffer_pool_size` system variable defines the
    buffer pool size. `InnoDB` allocates the entire buffer pool size at server startup.
    50 to 75 percent of system memory is recommended for the buffer pool size.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With `MyISAM`, all threads share the key buffer. The `key_buffer_size` system
    variable defines the size of the key buffer. The index file is opened once for
    each `MyISAM` table opened by the server. For each concurrent thread that accesses
    the table, the data file is opened once. A table structure, column structures
    for each column, and a 3 x *N* sized buffer are allocated for each concurrent
    thread. The `MyISAM` storage engine maintains an extra row buffer for internal
    use.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The optimizer estimates the reading of multiple rows by scanning. The storage
    engine interface enables the optimizer to provide information about the recorded
    buffer size. The size of the buffer can vary depending on the size of the estimate.
    In order to take advantage of row pre-fetching, `InnoDB` uses a variable size
    buffering capability. It reduces the overhead of latching and B-tree navigation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory mapping can be enabled for all `MyISAM` tables by setting the `myisam_use_mmap`
    system variable to 1.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The size of an in-memory temporary table can be defined by the `tmp_table_size`
    system variable. The maximum size of the heap table can be defined using the `max_heap_table_size`
    system variable. If the in-memory table becomes too large, MySQL automatically
    converts the table from in-memory to on-disk. The storage engine for an on-disk
    temporary table is defined by the `internal_tmp_disk_storage_engine` system variable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MySQL comes with the MySQL performance schema. It is a feature to monitor MySQL
    execution at low levels. The performance schema dynamically allocates memory by
    scaling its memory use to the actual server load, instead of allocating memory
    upon server startup. The memory, once allocated, is not freed until the server
    is restarted.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thread specific space is required for each thread that the server uses to manage
    client connections. The stack size is governed by the `thread_stack` system variable.
    The connection buffer is governed by the `net_buffer_length` system variable.
    A result buffer is governed by `net_buffer_length`. The connection buffer and
    result buffer starts with `net_buffer_length` bytes, but enlarges up to `max_allowed_packets`
    bytes, as needed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All threads share the same base memory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All join clauses are executed in a single pass. Most of the joins can be executed
    without a temporary table. Temporary tables are memory-based hash tables. Temporary
    tables that contain `BLOB` data and tables with large row lengths are stored on
    disk.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A read buffer is allocated for each request, which performs a sequential scan
    on a table. The size of the read buffer is determined by the `read_buffer_size`
    system variable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A random read buffer is allocated when reading rows in an arbitrary manner to
    avoid disk seeks. The buffer size is determined by the `read_rnd_buffer_size`
    system variable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The memory allocated to a thread is released as soon as the thread is no longer
    needed. The released memory is returned to the system unless the thread is put
    into the thread cache.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MySQL closes all tables that are not in use at once when `FLUSH TABLES` or `mysqladmin`
    flush-table commands are executed. It marks all in-use tables to be closed when
    the current thread execution finishes. This frees in-use memory. `FLUSH TABLES`
    returns only after all tables have been closed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It is possible to monitor the MySQL performance schema and sys schema for memory
    usage. Before we can execute commands for this, we have to enable memory instruments
    on the MySQL performance schema. It can be done by updating the `ENABLED` column
    of the performance schema `setup_instruments` table. The following is the query
    to view available memory instruments in MySQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If memory instruments are enabled on startup, it ensures memory allocations
    on startup are counted.
  prefs: []
  type: TYPE_NORMAL
- en: 'This query will return hundreds of memory instruments. We can narrow it down
    by specifying a code area. The following is an example to limit results to `InnoDB`
    memory instruments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the configuration to enable memory instruments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is an example to query memory instrument data in the `memory_summary_global_by_event_name`
    table in the performance schema:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: It summarizes data by `EVENT_NAME`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of querying the sys schema to aggregate currently
    allocated memory by code area:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Optimizing use of the network
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The MySQL database server opens up network interfaces to connect with the clients
    and starts listening to these interfaces. The connection manager threads are responsible
    for handling client connection requests. The connection manager threads additionally
    handle socket files on the Unix platform. The connection manager thread takes
    care of shared-memory connection requests, and one other thread handles named-pipe
    connection requests on the Windows system. Threads are not created for the interfaces
    that the server does not listen to.
  prefs: []
  type: TYPE_NORMAL
- en: The connection manager thread allocates a thread to each client connection.
    The thread authenticates and takes care of request processing for that client
    connection. The manager threads check within the thread cache for a thread first,
    which can be used for the client connection. If no thread is available in the
    cache, it creates a new thread. Once the client request is processed and the connection
    ends, the thread which was created to serve the client connection is returned
    to the thread cache unless the cache is full.
  prefs: []
  type: TYPE_NORMAL
- en: There are as many threads as the number of clients currently connected in this
    thread connection model. It has disadvantages, as well. When the server is required
    to be scaled to handle a higher number of connections than it is handling right
    now, thread creation and disposal becomes expensive. In this thread connection
    model, server and kernel resources are required for each thread.
  prefs: []
  type: TYPE_NORMAL
- en: Few server variables can be used to set up the server for optimized network
    usage. The `thread_cache_size` is the system variable which defines the size of
    the thread cache. The default value for thread cache size is 0\. This means that
    for each new connection, a thread is to be set up and disposed when the connection
    terminates. If we set `thread_cache_size` to 10, it enables 10 inactive connection
    threads to be cached. The thread connection becomes inactive when the connection
    with the client it was associated with terminates.
  prefs: []
  type: TYPE_NORMAL
- en: The complexity of the SQL statements a server can handle is limited by the size
    of the thread stack. The MySQL 8 server can be started with `--thread_stack=N`
    to set *N* bytes of stack size for each thread.
  prefs: []
  type: TYPE_NORMAL
- en: 'After setting the thread cache size, it becomes critical to monitor the impact. `Threads_cached`
    and `Threads_created` are the status variables to find out the number of threads
    in the thread cache, and the number of threads created because it could not be
    taken from the cache. The following is an example command to find out server status
    variable values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is an example of filtering the `status` variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Optimizing locking operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As discussed in one of the earlier chapters, MySQL 8 uses locking mechanisms
    to manage contention. Contention occurs when concurrently executing queries in
    multiple threads try to get ahold of one table at the same time. If these queries
    are performed on the table concurrently, the table data is left in an inconsistent
    state. MySQL 8 supports two types of locking: internal locking and external locking.'
  prefs: []
  type: TYPE_NORMAL
- en: Internal locking is performed by multiple threads within the MySQL server to
    manage contention for table contents. This type of locking is performed entirely
    by the MySQL server, without involving any other programs. So, why it is called
    internal locking? In the case of external locking, the MySQL server and other
    programs lock table files to decide which programs can access the table at a time.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the two methods for internal locking:'
  prefs: []
  type: TYPE_NORMAL
- en: Row-level locking.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Table-level locking.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Row-level locking in MySQL supports simultaneous write access to multiple sessions.
    This enables multi-user and highly concurrent applications. While performing multiple
    concurrent write operations on a single table, it is highly possible that a deadlock
    may occur.
  prefs: []
  type: TYPE_NORMAL
- en: In order to avoid such a deadlock situation, a locking mechanism acquires locks
    at the beginning of the transaction using the `SELECT ... FOR UPDATE` statement
    for each set of rows to be modified. MySQL applies the statements in the same
    order within each transaction if transactions lock more than one table. The `InnoDB`
    database engine automatically detects deadlock conditions and rolls back the affected
    transactions. Considering this, deadlocks affect performance.
  prefs: []
  type: TYPE_NORMAL
- en: The deadlock detection may cause slowdown if many threads wait for the same
    lock in highly concurrent systems. In such cases, it becomes more efficient to
    disable deadlock detection. We can rely on the `innodb_lock_wait_timeout` setting
    for transaction rollback when deadlock occurs. Using the `innodb_deadlock_detect`
    configuration option, we can disable the deadlock detection.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the advantages of row-level locking:'
  prefs: []
  type: TYPE_NORMAL
- en: When different sessions access different rows in a table, the number of lock
    conflicts is fewer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The number of changes to be rolled back is fewer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It becomes possible to lock a single table row for a long time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Table-level locking is used by MySQL for `MyISAM`, `MEMORY`, and `MERGE` tables.
    In the case of table-level locking, MySQL permits only one session to update these
    tables at a time. With table-level locking, these storage engines become suitable
    for read-only or single-user applications. These storage engines request all the
    required locks at once, when the query begins, to avoid any deadlocks. It always
    locks the tables in the same order. The major drawback with table-level locking
    is that it affects concurrency. If other sessions need to modify the table, they
    must wait until the concurrent data change statement finishes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the advantages of table-level locking:'
  prefs: []
  type: TYPE_NORMAL
- en: It requires less memory compared to row-level locking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When used on a large part of the table, it is fast, because only one lock is
    required
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `GROUP BY` operations are performed frequently, it is fast
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is the strategy for MySQL to grant write locks on tables:'
  prefs: []
  type: TYPE_NORMAL
- en: Put a write lock on the table if there are no write locks on the table
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Put a lock request in the write lock queue if the table already has a write
    lock
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following is the strategy for MySQL to grant read locks on tables:'
  prefs: []
  type: TYPE_NORMAL
- en: Put a read lock on the table if there are no read locks on the table
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Put a lock request in the read lock queue if the table already has a read lock
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: More priority is given to table updates than table retrievals. The lock is available
    to the write lock requests first, and then to the read lock requests when a lock
    is released.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example to analyze table lock contention:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `MyISAM` storage engine inherently supports multiple concurrent inserts
    in order to reduce contention between readers and writers for a table. It allows
    the `MyISAM` table to insert rows in the middle of a data file. If the table does
    not have any free blocks in the middle of the data file, the rows are inserted
    at the end of the file. This enables MySQL to execute `INSERT` and `SELECT` queries
    on the same table, concurrently. `concurrent_insert` is the global system variable
    which controls the behavior of the `MyISAM` storage engine to allow execution
    of concurrent `INSERT` and `SELECT` statements. If this system variable is set
    to `AUTO`, concurrent `INSERT` and `SELECT` are allowed.
  prefs: []
  type: TYPE_NORMAL
- en: 'If concurrent inserts are not possible and we want to perform multiple `INSERT`
    and `SELECT` operations on a table `tab1`, we can use the temporary table `temp_tab1`
    to hold the `tab1` table data and update the `tab1` table with the rows from the `temp_tab1`
    table. The following is an example which demonstrates this scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Performance benchmarking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We must consider the following factors when measuring performance:'
  prefs: []
  type: TYPE_NORMAL
- en: While measuring the speed of a single operation or a set of operations, it is
    important to simulate a scenario in the case of a heavy database workload for
    benchmarking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In different environments, the test results may be different
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Depending on the workload, certain MySQL features may not help with performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'MySQL 8 supports measuring the performance of individual statements. If we
    want to measure the speed of any SQL expression or function, the `BENCHMARK()`
    function is used. The following is the syntax for the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the `BENCHMARK` function is always zero. The speed can be measured
    by the line printed by MySQL in the output. The following is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: From the preceding  example , we can find that the time taken to calculate `1+1`
    for `1000000` times is `0.15 seconds`.
  prefs: []
  type: TYPE_NORMAL
- en: Examining thread information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At times, we may need to figure out what the MySQL server is doing. So, it becomes
    necessary to find out the process list. The process list is the set of threads
    currently being executed within the MySQL server.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the sources for getting process list information:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `SHOW [FULL] PROCESSLIST` statement. The following is an example of process
    list information:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `SHOW PROFILE` statement.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `INFORMATION_SCHEMA PROCESSLIST` table:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `mysqladmin processlist` command.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The performance schema threads table, stage tables, and lock tables.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We must be able to view the information of user threads. The `PROCESS` privilege
    is required to view the information about threads being executed. To access threads,
    a Mutex access is not required. It has less impact on the MySQL server performance.
    Accessing `INFORMATION_SCHEMA.PROCESSLIST` and `SHOW PROCESSLIST` requires a Mutex
    and has an impact on performance. Threads also provide details of background threads.
    `INFORMATION_SCHEMA.PROCESSLIST` and `SHOW PROCESSLIST` do not provide information
    about background threads.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table shows the information contained in each process list entry:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Information** | **Details** |'
  prefs: []
  type: TYPE_TB
- en: '| Id | Client connection identifier for the client that the thread is associated
    with. |'
  prefs: []
  type: TYPE_TB
- en: '| User, Host | Account associated with the thread. |'
  prefs: []
  type: TYPE_TB
- en: '| db | Default database for the thread or `NULL`. |'
  prefs: []
  type: TYPE_TB
- en: '| Command, State | It indicates what the thread is currently doing. |'
  prefs: []
  type: TYPE_TB
- en: '| Time | It indicates how long the thread has been in the current state. |'
  prefs: []
  type: TYPE_TB
- en: '| Info | It contains the information of the statement being executed by the
    thread. |'
  prefs: []
  type: TYPE_TB
- en: 'The following is the thread state values associated with general query processing:'
  prefs: []
  type: TYPE_NORMAL
- en: '`After create`: It occurs when the thread creates a table, including internal
    temporary tables'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Analyzing`: It occurs when the thread is calculating `MyISAM` key distribution'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Checking permissions`: It occurs when checking if the server has the required
    privileges to execute the SQL statement'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Checking table`: It occurs when the thread is performing a table check operation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Cleaning up`: It occurs when the thread has processed one command and frees
    the memory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Closing tables`: It occurs when the thread is flushing the changed table data
    to disk and closing the used tables'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Altering table`: It occurs when the server is processing the `ALTER TABLE`
    statement'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Creating index`: It occurs when the thread is processing `ALTER TABLE ...
    ENABLE KEYS` for the `MyISAM` table'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Creating table`: It occurs when the thread is creating a table'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`end`: It occurs at the end, but before the clean up of `ALTER TABLE`, `CREATE
    VIEW`, `DELETE`, `INSERT`, `SELECT`, or `UPDATE` statements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`executing`: It occurs when the thread has begun executing a statement'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`init`: It occurs before the initialization of `ALTER TABLE`, `DELETE`, `INSERT`,
    `SELECT`, and `UPDATE` statements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is the list of common states in the master''s `binlog` dump thread
    for replication master threads:'
  prefs: []
  type: TYPE_NORMAL
- en: Finished reading one `binlog`; switching to next `binlog`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Master has sent all `binlog` to slave; waiting for more updates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending `binlog` event to slave
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Waiting to finalize termination
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is a list of common states for a slave server I/O thread:'
  prefs: []
  type: TYPE_NORMAL
- en: Checking master version
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting to master
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Queueing master event to the relay log
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reconnecting after a failed `binlog` dump request
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reconnecting after a failed master event read
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Registering slave on master
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Requesting `binlog` dump
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Waiting for its turn to commit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Waiting for master to send event
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Waiting for master update
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Waiting for slave Mutex on exit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Waiting for the slave SQL thread to free enough relay log space
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Waiting to reconnect after a failed `binlog` dump request
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Waiting to reconnect after a failed master event read
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is a list of common states for a slave server SQL thread:'
  prefs: []
  type: TYPE_NORMAL
- en: Killing slave
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making temporary file (append) before replaying `LOAD DATA INFILE`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making temporary file (create) before replaying `LOAD DATA INFILE`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading event from the relay log
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Slave has read all relay log; waiting for more updates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Waiting for an event from coordinator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Waiting for slave Mutex on exit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Waiting for slave workers to free pending events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Waiting for the next event in relay log
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Waiting until `MASTER_DELAY` seconds after master executed event
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimizing database structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a database administrator, we must look for efficient ways to organize table
    schema, tables, and columns. We minimize I/O, plan ahead, and keep related items
    together to tune the application code in order to keep performance high with an
    increase in data volume. It usually starts with efficient database design, which
    makes it easier for team members to write high-performance application code. It
    also makes the database likely to sustain itself as applications evolve or are
    rewritten.
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing data size
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to minimize the space on the disk, we should start designing the database
    tables. This results in huge performance improvements, as it reduces the amount
    of data to be written to and read from the disk. Smaller tables usually need less
    main memory, while the contents are actively processed during query execution.
    Any reduction in table data space results in a need for smaller indexes that can
    be processed faster.
  prefs: []
  type: TYPE_NORMAL
- en: As discussed in the chapter on MySQL 8 data types, MySQL supports many different
    storage engines and row formats. We can decide the storage and indexing method
    to be used for each table. It is a big performance gain to choose the proper table
    format.
  prefs: []
  type: TYPE_NORMAL
- en: Table columns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We should use the smallest feasible data type for a table column. This results
    in the most efficient approach. MySQL supports specialized data types to save
    memory and disk space. For example, we should use integer types wherever possible
    to get smaller tables. Comparing `MEDIUMINT` and `INT`, `MEDIUMINT` is a better
    choice, as it uses 25% less space compared to `INT`.
  prefs: []
  type: TYPE_NORMAL
- en: We must declare columns to be `NOT NULL` wherever possible. This enables better
    use of indexes and eliminates the overhead of testing whether each value is `NULL`
    or not. It results in faster SQL operations. We can also save one bit per column
    of storage space. We should use `NULL` if we really require it. `NULL` values
    should not be allowed as a result of default settings for every column.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can attain huge performance gain for a table and minimize storage space
    requirement by using following techniques:'
  prefs: []
  type: TYPE_NORMAL
- en: Row format
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a default, the `DYNAMIC` row format is used when creating `InnoDB` tables.
    We can configure `innodb_default_row_format` to use row formats other than `DYNAMIC`.
    We can also specify the `ROW_FORMAT` option explicitly in a `CREATE TABLE` or
    `ALTER TABLE` statement.
  prefs: []
  type: TYPE_NORMAL
- en: The row formats include `COMPACT`, `DYNAMIC`, and `COMPRESSED`. They decrease
    row storage space at the cost of increased CPU use for some operations. For the
    average workload, which is limited by the cache hit rates and disk speed, it will
    be faster. If it is limited by the CPU speed, it will be slower.
  prefs: []
  type: TYPE_NORMAL
- en: The row formats also optimize the `CHAR` data type column storage when it uses
    a variable length character set. With the `REDUNDANT` row format, the `CHAR(N)`
    column value occupies *N* times the maximum byte length in the character set.
    The `InnoDB` storage engine allocates variable amounts of storage within the range
    of *N* to *N* times the maximum byte length in the character set.
  prefs: []
  type: TYPE_NORMAL
- en: A fixed-size row format is used if we do not have variable-length columns, such
    as `VARCHAR`, `TEXT`, or `BLOB`, in the case of `MyISAM` tables.
  prefs: []
  type: TYPE_NORMAL
- en: Indexes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A table's primary index must be as short as feasible. This enables easy identification
    of each row. It is efficient, too. In the case of `InnoDB` tables, the primary
    key column is duplicated in each secondary index entry. If we have a short primary
    key, it saves space in the case of many secondary indexes.
  prefs: []
  type: TYPE_NORMAL
- en: We should create only those indexes which improve query performance. The indexes
    improve information retrieval, but they slow down the insert and update operations.
    Indexes must be created with proper attention to the performance impact. If it
    is required to access a table by searching on a combination of columns, it is
    preferred to have a composite index on the combination of columns, rather than
    a separate index on each of the columns. The most used column should be the first
    part of the index. If it is a common requirement to use many columns in selected
    operations on the table, it is advisable to have the column with the most duplicates
    as the first column in the index. This gives better compression of the index.
  prefs: []
  type: TYPE_NORMAL
- en: If a long string column is supposed to have a unique prefix as the first few
    characters, it is advisable to index only the prefix, using MySQL's support for
    indexing on the leftmost part of the column. Shorter indexes are preferred, not
    only for the less space they require, but also because they provide more hits
    in the index cache and require fewer disk seeks.
  prefs: []
  type: TYPE_NORMAL
- en: Joins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If a table is scanned very often, it is beneficial to split the table into two
    tables, if feasible. This holds true especially if it is a dynamic-format table.
    It is also possible to use smaller static format tables, which can be used to
    search for relevant rows while scanning the tables.
  prefs: []
  type: TYPE_NORMAL
- en: The columns with identical information should be declared in different tables
    with identical data types. This speeds up joins based on matching columns.
  prefs: []
  type: TYPE_NORMAL
- en: Column names must be kept simple, so as to use the same name across tables.
    It simplifies join queries. For example, in a customer table, we should use the
    column name of `name`, rather than using `customer_name`. In order to make the
    names portable to other SQL servers, we should keep the column names shorter than
    18 characters.
  prefs: []
  type: TYPE_NORMAL
- en: Normalization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The data in the table columns must be kept non-redundant, considering the third
    normal form in the normalization theory. If the column holds repeating lengthy
    values, such as names or addresses, it is preferable to assign unique IDs and
    repeat these IDs across multiple smaller tables. In the event of searching, join
    queries should be used by referencing IDs in the join clauses.
  prefs: []
  type: TYPE_NORMAL
- en: In an application, if the preference is speed and not disk space or the maintenance
    costs of using multiple copies of data, it is advisable to duplicate the information
    or create summary tables to gain more speed. An example scenario could be a business
    intelligence system, where data is analyzed from large tables. In this case, normalization
    rules are not strictly followed.
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing MySQL data types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are the guidelines for optimizing numeric data types:'
  prefs: []
  type: TYPE_NORMAL
- en: Numeric columns must be preferred over string columns to store unique IDs or
    other values that can be represented as either strings or numbers. It is faster
    and occupies less memory to transfer and compare, because large numeric values
    are stored in fewer bytes compared to strings.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is faster to access information from a database than from a text file. This
    is especially true when numeric data is used. Information in the database is stored
    in a more compact format than in the text file. So, it requires fewer disk accesses.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following are the guidelines for optimizing character and string data types:'
  prefs: []
  type: TYPE_NORMAL
- en: The binary collation order (logical sequence) should be used for faster comparisons
    and sort operations. The binary operator can also be used within a query to use
    binary collation order.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With an `InnoDB` table, when we use a randomly generated value as a primary
    key, it should be prefixed with an ascending value, such as the date and time,
    if feasible. In this case, primary key values are stored nearer to each other,
    physically. `InnoDB` can insert or retrieve such values faster.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The binary `VARCHAR` data type should be used instead of `BLOB` for column values
    that are expected to hold less than 8 KB of data. If the original table does not
    have any `BLOB` columns, the `GROUP BY` and `ORDER BY` clauses generate temporary
    tables. These temporary tables can use the `MEMORY` storage engine.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In order to avoid string conversions while running a query, the columns should
    be declared with the same character set and order wherever possible when comparing
    the values from different columns.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the table holds string columns which are not frequently used in retrieval
    operations, splitting the string columns into a separate table should be considered.
    In the retrieval operations, join queries should be used with a foreign key wherever
    necessary. MySQL reads a data block containing all the columns of a row when it
    retrieves any value from a row. It allows more rows to fit within each data block
    when we keep the rows small, with only frequently used columns. These compact
    tables reduce memory usage and disk I/O.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following are the guidelines for optimizing `BLOB` data types:'
  prefs: []
  type: TYPE_NORMAL
- en: The performance requirements for a `BLOB` column may be different when retrieving
    and displaying information. So, storing the `BLOB` specific table in a different
    storage device or a separate database instance should be considered. For example,
    it is required to retrieve a `BLOB` in a large sequential disk read. So, a traditional
    hard drive or an SSD device might better suit needs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In order to reduce the memory requirements for a query which does not use a `BLOB`
    column, for a table with several columns, splitting the `BLOB` into separate tables
    and referencing with join queries should be considered, as needed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a table column is a large blob with textual data, compressing should be considered
    first. If the entire table is compressed by the storage engine, such as `InnoDB`
    or `MyISAM`, this technique should not be used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimizing for many tables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We learned the technique of splitting a table into many tables for faster execution
    of queries in certain situations. This technique cannot be applied in all of the
    scenarios, as if the number of tables runs into thousands, the overhead of managing
    all these tables becomes another performance nightmare.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will see how MySQL opens and closes tables. The following
    shows how to discover open files on the MySQL server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The MySQL 8 server is multi-threaded. It is possible that many clients issue
    queries for a table simultaneously. MySQL opens the table independently for each
    concurrent session, in order to minimize the problem of multiple client sessions
    with different states on the same table. This improves performance, though it
    requires additional memory. One extra file descriptor is required in the data
    file for each client that opens the `MyISAM` table.
  prefs: []
  type: TYPE_NORMAL
- en: The `table_open_cache` system variable determines the number of open tables
    for all the threads. The number of file descriptors `mysqld` requires can be increased
    by increasing this value. The `max_connections` system variable determines the
    maximum permitted number of simultaneous client connections. In a way, these two
    system variables affect the maximum number of files that the MySQL server can
    keep open. If we increase both values, we may run against a limit imposed by the
    operating system on the per process number of open files.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the circumstances under which MySQL closes unused tables:'
  prefs: []
  type: TYPE_NORMAL
- en: A thread tries to open a table which is not in the table cache when the table
    cache is full.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the table cache contains more entries than specified in the `table_open_cache`
    system variable and a table in the cache is no longer used by any threads.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When someone issues the `FLUSH TABLES` statement or executes a `mysqladmin flush-tables`
    or `mysqladmin refresh` command, the table flushing operation occurs. MySQL closes
    the table on this event.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The MySQL 8 server uses the following process to locate a cache entry when
    the table cache is full:'
  prefs: []
  type: TYPE_NORMAL
- en: Unused tables are released, starting with the table used the least recently.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If it is required to open a new table and the table cache is full and no tables
    can be released, the cache is temporarily extended, as needed. If a table transitions
    from a used to unused state when the table cache is in a temporarily extended
    state, the table is closed and released from the table cache.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is an example of finding the number of open tables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Use of an internal temporary table in MySQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The MySQL 8 server creates temporary internal tables while processing SQL statements,
    in some cases. The following are the conditions under which the server creates
    temporary tables:'
  prefs: []
  type: TYPE_NORMAL
- en: UNION statements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Views which uses the `TEMPTABLE` algorithm, `UNION`, or `aggregation`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Derived tables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common table expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tables created for subquery or semi join materialization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Statements that contain `ORDER BY` and `GROUP BY` clauses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Statements with `DISTINCT` combined with `ORDER BY`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Queries that use the `SQL_SMALL_RESULT` modifier
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`INSERT ... SELECT` statements that select from and insert into the same table'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiple table `UPDATE` statements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GROUP_CONCAT()` or `COUNT(DISTINCT)` expressions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `EXPLAIN` statement can be used to determine whether the statement requires
    a temporary table. The `EXPLAIN` statement has limitations. It will not indicate
    if the statement requires a temporary table for derived or materialized temporary
    tables.
  prefs: []
  type: TYPE_NORMAL
- en: The `Created_tmp_tables` status variable keeps track of the number of temporary
    tables created in internal memory. When the MySQL server creates a temporary table,
    it increments the value in the `Created_tmp_tables` status variable. `Created_tmp_disk_tables`
    is another status variable that keeps track of the number of tables created on
    the disk.
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on the query conditions, the server prevents the use of temporary tables
    in memory. In such cases, the server creates a table on the disk. The following
    are some instances:'
  prefs: []
  type: TYPE_NORMAL
- en: If the table has a `BLOB` or `TEXT` column
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the statement has a string column with a maximum length larger than 512 bytes
    in the `SELECT` list, if `UNION` or `UNION ALL` is used
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the `SHOW COLUMNS` and `DESCRIBE` statements use `BLOB` as the type of the
    column
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following are the conditions in which a `UNION` is evaluated without creating
    temporary tables:'
  prefs: []
  type: TYPE_NORMAL
- en: The union is `UNION ALL` and not `UNION` or `UNION DISTINCT`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is no global `ORDER BY` clause
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In a `SELECT` query, the union is not at the top-level query block
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimizing queries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Similar to tables, database queries are the most crucial element of any database.
    Applications interact with the databases using queries. Queries are also called
    executable SQL statements. This section focuses on techniques to improve the performance
    of query execution.
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing SQL statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SQL statements are used to perform the core logic of any database application.
    It does not matter whether the statements are issued directly through an interpreter
    or submitted behind the scenes by an API. This section outlines guidelines to
    improve the performance of SQL operations that read and write data in the database.
  prefs: []
  type: TYPE_NORMAL
- en: '`SELECT` statements perform all of the lookup operations in the database. Considering
    the frequency of `SELECT` statements, it becomes important to tune these statements
    at the top priority. The tuning techniques must be applied to constructs like
    `CREATE TABLE...AS SELECT`, `INSERT INTO...SELECT`, and `WHERE` clauses in `DELETE`
    statements.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the main considerations for optimizing queries:'
  prefs: []
  type: TYPE_NORMAL
- en: In order to optimize the `SELECT ... WHERE` query, the first thing to check
    is if an index can be added. We should add indexes on the columns used in the
    `WHERE` clause of the `SELECT` query. This will speed up the evaluation, filtering,
    and the retrieval of results. The strategy should be to construct a small set
    of indexes that can speed up many related queries used in the application. It
    also avoids the wasted disk space.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The indexes are important for queries which reference different tables using
    joins and foreign keys. The `EXPLAIN` statement can be used to determine which
    indexes are used in a `SELECT` statement execution.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next step should be to isolate and tune parts of the query; for example,
    a function call which takes excessive time. Depending upon the structure of the
    query, a function call can be done for every row in the table or for every row
    in the result set.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The number of full table scans in the query must be minimized, specifically
    for big tables.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ANALYZE TABLE` statement should be used periodically to keep the table
    statistics up-to-date. The optimizer provides the information required to build
    an efficient query execution plan.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the basic guidelines do not solve the performance issues, queries should
    be investigated for internal details by reading the `EXPLAIN` plan and adjusting
    your indexes, `WHERE` clauses, join clauses, and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transforming queries in a way that makes them hard to understand should be avoided,
    especially when the optimizer does some of the same transformations automatically.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `InnoDB` buffer pool, `MyISAM` key cache, and the MySQL query cache must
    be used efficiently for repeated queries to run faster as the results are retrieved
    from memory after the first time. The size and properties of the memory area must
    be adjusted, as MySQL uses it for caching.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the query runs faster using the cache memory area, we should still optimize
    it further, so that it requires less cache memory. It makes the application more
    scalable, which makes the application capable of handling more simultaneous users,
    larger requests, and so on, without experiencing performance drop.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Where the speed of the query is affected by other sessions accessing the table
    at the same time, we should deal with locking issues.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following are the guidelines to optimize the `WHERE` clause. These optimizations
    are applicable to `WHERE` clauses in `SELECT`, `DELETE`, or `UPDATE` queries,
    equally:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Unnecessary parentheses should be removed. The following is an example of parentheses
    removal:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Constant folding is the process of evaluating values at compile time instead
    of runtime. If we have assigned a constant value to a variable and then use that
    variable in an expression, we should use the constant value instead. The following
    is an example of constant folding:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Because of constant folding, we should remove constant conditions. The following
    is an example of constant condition removal:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Optimizing indexes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The basic use of indexes is to quickly find the rows with specific column values.
    If the index is not present, MySQL begins with the first row and reads through
    the entire table to find all the matching rows. It takes more time, depending
    on how large a table is. If the index is present for the appropriate columns,
    MySQL is able to quickly determine the position to seek to in the middle of the
    data file, without looking at the whole table data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a list of operations for which MySQL uses indexes:'
  prefs: []
  type: TYPE_NORMAL
- en: To find matching rows, based on a `WHERE` clause, quickly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MySQL uses the index with the smallest number of rows (most selective index)
    in the case of choosing from multiple indexes to eliminate rows from consideration.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The optimizer uses the leftmost prefix of the index to look up rows if the table
    has a composite index. For example, in a table with three columns indexed (on
    col1, col2, col3), the optimizer can look for rows with indexed search capabilities
    on (col1), (col1, col2), and (col1, col2, col3).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MySQL uses indexes while it fetches rows from other tables using joins. If the
    indexes are declared as the same type and size, MySQL can use them efficiently
    on the column. The `VARCHAR` and `CHAR` are considered the same when declared
    as the same size.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MySQL also uses indexes to find the `minimum(MIN())` or `maximum(MAX())` value
    for an indexed column `key_col`. The preprocessor checks whether it is using `WHERE
    key_part_N = constant` on all key parts to optimize it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is also possible to optimize the query to retrieve values without consulting
    the data rows. (A covering index is an index that provides all the results for
    a query.) If the query uses only those columns from a table which are included
    in some index, the selected values will be fetched from the index tree. This will
    have a higher speed in retrieving values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Query execution plan
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The MySQL optimizer considers optimization techniques to efficiently perform
    the lookups involved in the query, depending on the details of the tables, columns,
    and indexes, and the conditions in the `WHERE` clause. A query can also be performed
    without reading all the rows on a huge table. An SQL join can also be performed
    without comparing every combination of rows. A query execution plan is a set of
    operations that the MySQL optimizer chooses to perform the most efficient query.
    It is also known as the `EXPLAIN` plan. As an administrator, the goal is to recognize
    the aspects of the query execution plan which indicate if a query is optimized.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `EXPLAIN` statement is used to determine the query execution plan. The
    following is the set of information provided by the `EXPLAIN` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: The `EXPLAIN` statement works with `SELECT`, `DELETE`, `INSERT`, `UPDATE`, and
    `REPLACE` statements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MySQL displays information from the MySQL optimizer about the query execution
    plan when `EXPLAIN` is used with the SQL statement. This means MySQL explains
    the process with which the statement is executed. It includes information about
    how tables are joined, and in which order.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `EXPLAIN` displays the execution plan for the statement execution in the
    named connection if it is used with `FOR CONNECTION` connection_id instead of
    explainable SQL statement.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EXPLAIN` displays additional execution plan information for `SELECT` statements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EXPLAIN` is also useful in examining queries which involve partitioned tables.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EXPLAIN` supports a `FORMAT` option, which can be used to select the output
    format. The `TRADITIONAL` format displays the output in a tabular format. This
    is the default format option. The **JavaScript Object Notation** (**JSON**) format
    option produces information in the JSON format.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Based on the output from the `EXPLAIN` statement, it can be figured out where
    indexes can be added to the tables, so that the statement executes faster. It
    can also be found whether the optimizer joins the tables in the optimized order.
    Begin the statement with `SELECT STRAIGHT_JOIN`, instead of just `SELECT`, to
    give a hint to the optimizer to use the join order corresponding to the order
    the tables are named in the `SELECT` statement. As `STRAIGHT_JOIN` disables semi-join
    transformations, it may prevent the use of indexes.
  prefs: []
  type: TYPE_NORMAL
- en: The optimizer trace is another tool to find the information on the query execution.
    It is possible that the optimizer trace may provide information differing from
    that of `EXPLAIN`. The format and content of the optimizer trace are subject to
    variation, based on the versions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table shows the output format of the `EXPLAIN` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Column** | **JSON Name** | **Details** |'
  prefs: []
  type: TYPE_TB
- en: '| `id` | `select_id` | The `SELECT` identifier |'
  prefs: []
  type: TYPE_TB
- en: '| `select_type` | `None` | The `SELECT` type |'
  prefs: []
  type: TYPE_TB
- en: '| `table` | `table_name` | The table for the output row |'
  prefs: []
  type: TYPE_TB
- en: '| `partitions` | `partitions` | The matching partitions |'
  prefs: []
  type: TYPE_TB
- en: '| `type` | `access_type` | The join type |'
  prefs: []
  type: TYPE_TB
- en: '| `possible_keys` | `possible_keys` | The possible indexes to choose |'
  prefs: []
  type: TYPE_TB
- en: '| `key` | `key` | The index actually chosen |'
  prefs: []
  type: TYPE_TB
- en: '| `key_len` | `key_length` | The length of the chosen key |'
  prefs: []
  type: TYPE_TB
- en: '| `ref` | `ref` | The columns compared to the index |'
  prefs: []
  type: TYPE_TB
- en: '| `rows` | `rows` | Estimate of rows to be examined |'
  prefs: []
  type: TYPE_TB
- en: '| `filtered` | `filtered` | Percentage of rows filtered by table condition
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Extra` | `None` | Additional Information |'
  prefs: []
  type: TYPE_TB
- en: Reference: [https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain-output-column-table](https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain-output-column-table)
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing tables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Database tables are the most basic building blocks for any database. In this
    section of the chapter, we will focus on optimizing tables. The section provides
    detailed guidelines for improving performance through table optimization techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Optimization for InnoDB tables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `InnoDB` storage engine is preferred in production environments in situations
    where reliability and concurrency are important. It is the default storage engine
    for MySQL tables. This section focuses on optimizing database operations for `InnoDB`
    tables.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the guidelines to optimize `InnoDB` tables:'
  prefs: []
  type: TYPE_NORMAL
- en: Use of the `OPTIMIZE TABLE` statement should be considered to reorganize the
    table and compact the wasted space once the data reaches a stable size or the
    table has increased by tens of megabytes. It requires less disk I/O to perform
    full table scans for reorganized tables.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `OPTIMIZE TABLE` statement copies the data in the table and rebuilds the
    indexes. It is beneficial because of improved packing of the data within indexes,
    and fragmentation reduction within the table spaces on the disk. The benefits
    may vary, depending on the data in each table. It may be noticeable that the gains
    are significant in some cases, and not for others. The gains may also decrease
    over time until the next table optimization is done. The operation can be slow
    if the table is large or the indexes being rebuilt do not fit in the buffer pool.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A long primary key in a `InnoDB` table wastes a lot of disk space. It should
    be avoided.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In `InnoDB` tables, preference should be given to the `VARCHAR` data type instead
    of the `CHAR` data type to store variable length strings, or for columns which
    are expected to contain `NULL` values. A `CHAR(N)` column always occupies *N*
    characters to store data, even if the value is `NULL`. Smaller tables are more
    suitable to fit in the buffer pool and reduced disk I/O.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consider using a `COMPRESSED` row format for big tables, or tables containing
    lots of repetitive text or numeric data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimization for MyISAM tables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For read-only or read-mostly data, or for low concurrency operations, the `MyISAM`
    storage engine fits the best. This is because table locks limit the ability to
    perform simultaneous updates. In this section, the focus will be on optimizing
    queries to be executed on `MyISAM` tables.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the guidelines for speeding up queries on `MyISAM` tables:'
  prefs: []
  type: TYPE_NORMAL
- en: Avoid executing complex `SELECT` queries on frequently updated `MyISAM` tables.
    It prevents problems with table locking that occur because of contention between
    writers and readers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `MyISAM` storage engine supports concurrent inserts. If the table data file
    does not have free blocks in the middle, we can `INSERT` new rows in it at the
    same time that other threads are reading from the table. Consider using the table
    to avoid deleting rows if it is important to be able to do concurrent read-write
    operations. Another option is to execute `OPTIMIZE TABLE` to defragment the table
    after deletion of the rows. This behavior can be controlled or modified by setting
    the `concurrent_insert` system variable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid all variable-length columns for frequently changing `MyISAM` tables. The
    dynamic row format is used by the table if it includes even a single variable
    length column.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `myisamchk --sort-index --sort-records=1` command can be used to sort an
    index. It also sorts data according to the index. This makes the queries run faster
    if we have unique indexes, based on which we want to read all rows in the order
    according to the index. It takes a long time when we sort a large table this way
    for the first time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we usually retrieve rows in the order of `expression1`, `expression2`, and
    so on, use `ALTER TABLE ... ORDER BY expression1, expression2,..`, and so on.
    This will give higher performance, if this option is used after extensive changes
    to the table.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimization for MEMORY tables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MySQL `MEMORY` tables should be considered for use only for noncritical data
    that is accessed often and is read-only and rarely updated. The application should
    be benchmarked against equivalent `InnoDB` or `MyISAM` tables under realistic
    workloads to confirm that additional performance is worth the risk of losing data.
  prefs: []
  type: TYPE_NORMAL
- en: We should examine the kinds of queries against each table for best performance
    with `MEMORY` tables. We should also specify the type of use for each associated
    index. It can be a B-tree index or a hash index. Use the `USING BTREE` or `USING
    HASH` clause on the `CREATE INDEX` statement.
  prefs: []
  type: TYPE_NORMAL
- en: Leveraging buffering and caching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section focuses on using buffering and caching techniques to increase the
    performance.
  prefs: []
  type: TYPE_NORMAL
- en: InnoDB buffer pool optimization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `InnoDB` storage engine maintains a storage area known as the buffer pool.
    It is used for caching data and indexes in the memory. It is important to know
    how the `InnoDB` buffer pool works, so as to take advantage of it to keep frequently
    accessed data in memory. It is an important aspect of MySQL tuning.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the general guidelines for improving performance with the
    `InnoDB` buffer pool:'
  prefs: []
  type: TYPE_NORMAL
- en: In an ideal case, the size of the buffer pool should be set large enough, while
    leaving enough memory for other processes on the server to run without excessive
    paging. With larger buffer pools, more `InnoDB` functions, like an in-memory database.
    In this case, it reads data from the disk once, and then accesses the data from
    memory in subsequent reads.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can consider splitting the buffer pool into many parts for 64-bit systems
    with large memory sizes. This minimizes contention for memory during concurrent
    operations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The frequently accessed data should be kept in memory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is possible to control when and how `InnoDB` performs read-ahead requests
    to prefetch pages into the buffer pool asynchronously. `InnoDB` uses two read-ahead
    algorithms to improve I/O performance. Linear read ahead predicts what pages might
    be needed soon, based on the pages being accessed in the buffer pool sequentially.
    Random read ahead predicts when pages might be needed based on the pages in the
    buffer pool, regardless of the order in which pages are read. The `innodb_read_ahead_threshold`
    configuration parameter controls the sensitivity of linear read ahead. We can
    enable random read a heads by setting `innodb_random_read_ahead` to `ON`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`innodb_buffer_pool_read_ahead` determines the number of pages read into the
    `InnoDB` buffer pool. `innodb_buffer_pool_read_ahead_evicted` determines the number
    of pages read into the buffer pool by the read-ahead background thread that was
    subsequently evicted without having been accessed by queries. The `innodb_buffer_pool_read_ahead_rnd`
    determines the number of random read aheads initiated by `InnoDB`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MyISAM key cache
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `MyISAM` storage engine incorporates a strategy that is supported by many
    database management systems to minimize the disk I/O. The cache mechanism is employed
    by `MyISAM` to keep the most frequently accessed table blocks in memory as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A special structure known as a key cache is maintained for index blocks. The
    most used index blocks are placed in the structure containing a number of block
    buffers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MySQL relies on the native operating system filesystem cache for data blocks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `key_buffer_size` system variable determines the size of the key cache.
    If it is set to zero, no key cache is used. The key cache is also not used if
    the `key_buffer_size` value is too small to allocate the minimum order of block
    buffers. All the block buffers in the key cache structure are of the same size.
    This size can be equal to, greater than, or less than the size of the table index
    block. In usual cases, one of these two values is a multiple of the other.
  prefs: []
  type: TYPE_NORMAL
- en: When it is required to access data from any table index block, the server first
    checks if it is available in some block buffer of the key cache. If the data is
    available, the server accesses data from the key cache rather than on the disk.
    If the data is not available, the server selects a cache block buffer that contains
    a different table index block and replaces the data in it by copying the required
    table index block. The index data can be accessed as soon as the new index block
    is available in the cache.
  prefs: []
  type: TYPE_NORMAL
- en: The MySQL server follows the **Least Recently Used** (**LRU**) strategy. According
    to it, it selects the least recently used index block while choosing a block for
    replacement. The key cache module contains all used blocks in the LRU chain (a
    special list). The list is ordered by the time of use. It is the most recently
    used when the block is accessed. The block is placed at the end of the list. Blocks
    at the beginning of the list are the least recently used when the blocks need
    to be replaced. So, the block at the top becomes the first candidate for eviction.
  prefs: []
  type: TYPE_NORMAL
- en: The block is considered dirty if the block selected for replacement has been
    modified. The block contents are flushed to the table index from which they came
    prior to replacement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on the following conditions, the threads can access key cache buffers
    simultaneously:'
  prefs: []
  type: TYPE_NORMAL
- en: The buffer which is not being updated can be accessed by multiple sessions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The buffer which is being updated causes sessions that require waiting until
    the update is complete to use it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As long as the sessions are independent and do not interfere with each other,
    multiple sessions can initiate requests resulting in cache block replacements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this way, shared access to the key cache improves performance significantly.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned, in detail, the techniques to optimize MySQL 8 components.
    The chapter started with the basics of optimization, including hardware and software
    optimization guidelines. We also discussed optimization guidelines for the MySQL
    8 server and client, database structure, queries, and tables. We also covered
    optimization for tables belonging to different storage engines, such as `MyISAM`, `InnoDB`,
    and `MEMORY`. We learned the tools, such as `EXPLAIN` and `EXPLAIN ANALYZE`, needed
    to understand the query execution plan. In the later part of the chapter, we learned
    buffering and caching techniques to improve performance.
  prefs: []
  type: TYPE_NORMAL
- en: It's time to move on to the next chapter now. The next chapter focuses on techniques
    to extend MySQL 8\. The chapter will cover in-depth details of MySQL 8 plugins,
    which help to extend the default MySQL 8 features. It will also explain the services
    to call these plugins. The chapter will discuss adding new functions, debugging,
    and porting methods. It is going to be an important chapter for database administrators.
  prefs: []
  type: TYPE_NORMAL
