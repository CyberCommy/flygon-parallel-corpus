- en: Isomorphic Handoff
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the development of Isomorphic Go web applications, two critical techniques
    were introduced in the previous two chapters. First, you learned how to utilize
    an in-memory template set to render templates across environments. Second, you
    learned how to perform end-to-end routing on both the client and the server. Client-side
    routing is the magic that allows the client-side web application to operate in
    the single page mode.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: The aforementioned techniques now provide us with the ability to navigate to
    different sections of the website, on the client itself, and render any given
    template across environments. As the implementors of an Isomorphic Go web application
    our responsibility is to ensure that state is maintained between the client and
    the server. For example, when rendering the Products page, it wouldn't make sense
    if the list of products was rendered differently on the client side than it was
    on the server side. The client needs to work in lockstep with the server to ensure
    that the state, in this case, the list of products is maintained—and that's where
    *isomorphic handoff* comes into the picture.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: '**Isomorphic handoff** is the process by which the server hands off state to
    the client and the client uses the passed state to render the web page on the
    client side. Keep in mind that the state the server passes off to the client must
    include the exact same state that was used to render the server-side web page
    response. Isomorphic handoff essentially allows the client to seamlessly pick
    up things where they were left off on the server. In this chapter, we''ll revisit
    the product-related pages, to see exactly how the state is maintained from the
    server side to the client side. In addition to that, we will also complete the
    implementation of the product-related pages, by implementing the user interactivity
    portions, which involve adding event handlers to the Add To Cart buttons found
    in these pages.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: The shopping cart feature for the IGWEB website will be implemented in this
    chapter, and it will allow us to consider the scenario where the user can change
    the state of the shopping cart by adding and removing items to and from the shopping
    cart. We will use isomorphic handoff to ensure that the current state of the shopping
    cart is seamlessly maintained across the server and the client. By properly maintaining
    the state of the shopping cart we can guarantee that the shopping cart page rendered
    from the server side always matches the shopping cart page rendered from the client
    side.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: The isomorphic handoff procedure
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing isomorphic handoff for the product-related pages
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing isomorphic handoff for the shopping cart
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The isomorphic handoff procedure
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A recurring theme in the development of isomorphic web applications centers
    around the ability to share between the server and the client. In an isomorphic
    web application, the server and client must work in unison to seamlessly maintain
    the state of a particular workflow in the application. In order to do so, the
    server must share the current state, which was used to render the web page output
    on the server side with the client.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: The ERDA strategy
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The isomorphic handoff procedure consists of the following four steps:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Encode
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Register
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Decode
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Attach
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can use the acronym **ERDA** (**Encode-Register-Decode-Attach**) to easily
    recall each individual step of the procedure. In fact, we can collectively refer
    to the steps to implement the isomorphic handoff procedure as the **ERDA strategy**.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: 'By implementing the four steps of the isomorphic handoff procedure, as depicted
    in *Figure 6.1*, we can guarantee that state is successfully persisted between
    the server and the client:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b775dd1b-10c7-4646-88b4-5fae1ef16669.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.1: The ERDA strategy to implement isomorphic handoff'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: The first step, **Encode**, involves encoding a data object that represents
    the state we wish to retain to the client into a data exchange format (JSON, Gob,
    XML, and so on). The subsequent steps are all performed on the client side. The
    second step, **Register**, involves registering a client-side route and its respective
    handler function. The third step, **Decode**, involves decoding the encoded data
    retrieved from the server, through a Rest API endpoint, and utilizing it to render
    the template for the web page on the client side. The fourth and last step, **Attach**,
    involves attaching any needed event handlers to the rendered web page to enable
    user interactivity.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步，编码，涉及将代表我们希望保留到客户端的状态的数据对象编码为数据交换格式（JSON、Gob、XML等）。随后的步骤都在客户端上执行。第二步，注册，涉及注册客户端路由及其相应的处理程序函数。第三步，解码，涉及解码从服务器检索到的编码数据，通过Rest
    API端点，并利用它在客户端呈现网页的模板。第四步，附加，涉及将任何需要的事件处理程序附加到呈现的网页上，以实现用户交互。
- en: '*Figure 6.2* depicts the key modules involved, on both the server and the client,
    in implementing the isomorphic handoff procedure:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6.2*描述了在服务器端和客户端上涉及的关键模块，用于实现等同手off过程：'
- en: '![](img/2acedc0f-703d-4bc2-bcf3-8a6b05c716b0.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2acedc0f-703d-4bc2-bcf3-8a6b05c716b0.png)'
- en: 'Figure 6.2: The key modules involved in isomorphic handoff'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2：实现等同手off过程的关键模块
- en: The **Encode** step, is performed inside the **Rest API Endpoint** that exists
    in the server-side web application. The **Register** step is performed inside
    the **Route Handler** that exists in the client-side web application. The **Decode**
    step is performed prior to calling the client-side **Template Renderer**. The
    **Attach** Step is performed by implementing the **DOM Event Handlers** on the
    client side.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 编码步骤是在服务器端Web应用程序中存在的Rest API端点内执行的。注册步骤是在客户端Web应用程序中存在的路由处理程序内执行的。解码步骤是在调用客户端模板渲染器之前执行的。附加步骤是通过在客户端实现DOM事件处理程序来执行的。
- en: Now that we have introduced each step in the ERDA strategy, let's explore each
    step in detail.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了ERDA策略中的每个步骤，让我们详细探讨每个步骤。
- en: The Encode step
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编码步骤
- en: Our goal to regenerate the state on the client side begins by identifying the
    data object that represents the state we wish to retain in order to maintain state
    in a particular web page. To identify the object, we simply need to take a look
    at the server-side handler function that produced the rendered web page output.
    For example, in the products listing page, the slice of `Product` objects would
    be the data object that we would want to retain to the client side, so that the
    web page rendered on the client-side would render the same list of products.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是在客户端重新生成状态，首先要识别代表我们希望保留的状态的数据对象，以便在特定网页中保持状态。要识别对象，我们只需要查看生成渲染的网页输出的服务器端处理程序函数。例如，在产品列表页面中，`Product`对象的片段将是我们希望保留到客户端的数据对象，以便客户端呈现的网页呈现相同的产品列表。
- en: We can expose the slice of the `Product` objects to the client side by implementing
    a Rest API Endpoint (depicted in *Figure 6.2*). The **Encode** step (depicted
    in *Figure 6.1*), consists of encoding the slice of the `Product` objects to a
    common data exchange format. For this chapter, we will encode objects using the
    **JSON** (short for, **JavaScript Object Notation**) format. The client-side web
    application can access the encoded object by making an XHR call to the Rest API
    endpoint.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过实现Rest API端点（在*图6.2*中描述）将`Product`对象的片段暴露给客户端。编码步骤（在*图6.1*中描述）包括将`Product`对象的片段编码为通用数据交换格式。对于本章，我们将使用JSON（JavaScript对象表示）格式对对象进行编码。客户端Web应用程序可以通过向Rest
    API端点发出XHR调用来访问编码对象。
- en: Now that the encoded state object is available, the rest of the steps to implement
    the isomorphic handoff procedure happen on the client side.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在编码状态对象可用，实现等同手off过程的其余步骤发生在客户端。
- en: The Register step
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注册步骤
- en: To fulfill the register step (depicted in *Figure 6.1*), we must first register
    a client-side route and its respective handler function (depicted in the Route
    Handler box in *Figure 6.2*). For example, for the Products page, we would register
    the `/products` route and its associated handler function, `ProductsHandler`.
    When a user clicks on the Products link from the navigation bar, the click event
    will be intercepted by the isokit router and the handler function, `ProductsHandler`,
    which is associated with handling the `/products` route, will be called. The route
    handler function plays the role of executing the last two steps of the isomorphic
    handoff process—decode and attach.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成注册步骤（在*图6.1*中描述），我们必须首先注册客户端路由及其相应的处理程序函数（在*图6.2*中的路由处理程序框中描述）。例如，对于产品页面，我们将注册`/products`路由及其关联的处理程序函数`ProductsHandler`。当用户从导航栏点击产品链接时，点击事件将被isokit路由拦截，并且与处理`/products`路由的处理程序函数`ProductsHandler`相关联的处理程序函数将被调用。路由处理程序函数扮演着执行等同手off过程的最后两个步骤——解码和附加的角色。
- en: Keep in mind that if the user were to land first on the `/products` route by
    directly accessing the web page by entering the URL in the web browser, the server-side
    handler function will kick-in and the Products page will be rendered on the server
    side. This provides us the capability to render the web page instantly, providing
    a page load that is perceived to be fast to the user.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，如果用户首先通过在Web浏览器中输入URL直接访问网页而着陆在`/products`路由上，服务器端处理程序函数将启动，并且产品页面将在服务器端呈现。这使我们能够立即呈现网页，为用户提供被认为是快速的页面加载。
- en: The Decode step
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解码步骤
- en: Within the route handler function, we initiate an XHR call to the Rest API endpoint,
    that will return the encoded data that represents the state we wish to maintain
    on the client side. Once the encoded data is obtained, we will perform the third
    step, **Decode** (depicted in *Figure 6.1*), of the isomorphic handoff procedure.
    In this step, we decode the encoded data back into an object instance. The object
    instance is then utilized to populate the corresponding field of the template
    data object that is passed to the Template Renderer (depicted in *Figure 6.2*),
    so that the web page can be successfully rendered on the client side, in the same
    manner as it was rendered on the server side.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在路由处理程序函数中，我们发起一个XHR调用到Rest API端点，该端点将返回编码数据，表示我们希望在客户端保持的状态。一旦获取到编码数据，我们将执行等同交接过程的第三步**解码**（在*图6.1*中描述）。在这一步中，我们将编码数据解码回对象实例。然后利用对象实例填充模板数据对象的相应字段，传递给模板渲染器（在*图6.2*中描述），以便网页可以在客户端成功渲染，与在服务器端渲染的方式相同。
- en: The Attach step
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附加步骤
- en: The fourth and last step, Attach (depicted in *Figure 6.1*), is responsible
    for attaching event handlers (depicted in *Figure 6.2*) to DOM elements that exist
    in the rendered web page. For example, in the Products page, we would need to
    attach event handlers to all the Add To Cart buttons found on the web page. When
    an Add To Cart button is pressed, the respective product item will be added to
    the user's shopping cart.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 第四步也是最后一步，附加（在*图6.1*中描述），负责将事件处理程序（在*图6.2*中描述）附加到渲染的网页中存在的DOM元素上。例如，在产品页面中，我们需要将事件处理程序附加到网页上找到的所有“添加到购物车”按钮上。当按下“添加到购物车”按钮时，相应的产品将被添加到用户的购物车中。
- en: Up to this point, we have laid out the groundwork needed to implement the isomorphic
    handoff procedure for a given web page. To solidify our understanding of isomorphic
    handoff, let's consider two specific examples where we implement all four steps
    of the procedure. First, we will implement the isomorphic handoff procedure in
    the product-related pages, which include the products listing page (`/products`)
    and the product detail page (`/product-detail/{productTitle}`). Second, we will
    implement the isomorphic handoff procedure for the shopping cart page. The second
    example will be more dynamic, since the user will have the capability to alter
    the state, because the user can add and remove items to the shopping cart as they
    wish. This capability allows the user to exert control on the current state of
    the shopping cart.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经铺设了实现给定网页的等同交接过程所需的基础工作。为了巩固我们对等同交接的理解，让我们考虑两个具体的例子，在这两个例子中我们实现了该过程的所有四个步骤。首先，我们将在产品相关页面实现等同交接过程，包括产品列表页面(`/products`)和产品详情页面(`/product-detail/{productTitle}`)。其次，我们将为购物车页面实现等同交接过程。第二个例子将更加动态，因为用户可以改变状态，用户可以随意添加和删除购物车中的商品。这种能力允许用户对购物车的当前状态施加控制。
- en: Implementing isomorphic handoff for the product-related pages
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为产品相关页面实现等同交接
- en: As noted earlier, the product-related pages consist of the products listing
    page and the product detail page. We will follow the ERDA strategy to implement
    the isomorphic handoff procedure for these pages.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，与产品相关的页面包括产品列表页面和产品详情页面。我们将遵循ERDA策略，为这些页面实现等同交接过程。
- en: Implementing the sort interface for the product model
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为产品模型实现排序接口
- en: 'Before we get started, we will define a new type called `Products` (in the
    `shared/models/product.go` source file), which will be a slice of `Product` objects:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，我们将在`shared/models/product.go`源文件中定义一个名为`Products`的新类型，它将是`Product`对象的切片：
- en: '[PRE0]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We will have the `Products` type implement the `sort` interface by defining
    the following methods:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`Products`类型实现`sort`接口，定义以下方法：
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: By examining the `Less` method, you will be able to see that we will sort the
    products displayed on the product listing page by the product's price in ascending
    order (lowest to highest).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 通过检查`Less`方法，您将能够看到我们将按照产品价格升序（从低到高）对产品列表页面上显示的产品进行排序。
- en: At the first glance we may presume that the products obtained from the Redis
    database are already sorted in some predetermined order. However, if we want isomorphic
    handoff to succeed, we cannot operate in the realm of assumption; we must operate
    in the realm of fact. In order to do so, we need a predictable criteria for the
    sorting of products.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，我们可能会认为从Redis数据库获取的产品已经按照某种预定顺序排序。然而，如果我们希望等同交接成功，我们不能凭假设操作；我们必须凭事实操作。为了做到这一点，我们需要一个可预测的产品排序标准。
- en: This is why we perform the additional work of implementing the `sort` interface
    for the `Products` type, so that we have a predictable criteria by which the products
    are listed on the products listing page. It provides us a benchmark when verifying
    the success of isomorphic handoff, since we simply need to confirm that the products
    listing page rendered on the client side is identical to the products listing
    page rendered on the server side. It is indeed helpful, that we have a common,
    predictable criteria that the products are sorted by price in the ascending order.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么我们要为`Products`类型实现`sort`接口的额外工作，以便我们有一个可预测的标准，按照这个标准在产品列表页面上列出产品。这为我们提供了一个基准，用于验证等同交接的成功，因为我们只需要确认客户端渲染的产品列表页面与服务器端渲染的产品列表页面相同即可。确实很有帮助，我们有一个共同的、可预测的标准，产品按价格升序排序。
- en: 'We add the following line (shown in bold) in the `GetProducts` method in the
    `redis.go` source file to sort the products:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`redis.go`源文件的`GetProducts`方法中添加以下行（以粗体显示）以对产品进行排序：
- en: '[PRE2]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Implementing isomorphic handoff for the products listing page
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为产品列表页面实现等同交接
- en: 'First, we must implement the **Encode** step. To do this, we need to decide
    the data that must be persisted to the client side. We can easily identify the
    data that must be persisted to the client, by examining the server side handler
    function, `ProductsHandler`, responsible for rendering the products listing web
    page:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须实现**编码**步骤。为此，我们需要决定必须持久化到客户端的数据。通过检查负责渲染产品列表网页的服务器端处理函数`ProductsHandler`，我们可以轻松识别必须持久化到客户端的数据：
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The products listing page is responsible for displaying the list of products,
    therefore, the `products` variable (shown in bold), a slice of `Product` objects,
    must be persisted to the client side.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 产品列表页面负责显示产品列表，因此，必须将`products`变量（加粗显示）持久化到客户端，这是`Product`对象的切片。
- en: 'Now that we have identified the data that needs to be persisted to the client,
    to maintain state, we can create a Rest API Endpoint, `GetProductsEndpoint`, that
    is responsible for delivering the slice of products to the client, in the JSON-encoded
    form:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经确定了需要持久化到客户端以维护状态的数据，我们可以创建一个Rest API端点`GetProductsEndpoint`，负责以JSON编码形式将产品切片传递给客户端：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Our work to implement isomorphic handoff is complete on the server side, and
    now it's time to turn our attention to the client side.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在服务器端完成了实现同构交接的工作，现在是时候转向客户端了。
- en: 'To implement the **Register** step, we add the following line to register the
    `/products` route and its associated handler function, `ProductsHandler`, in the
    `registerRoutes` function found in the `client.go` source file:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现**注册**步骤，我们在`client.go`源文件中的`registerRoutes`函数中添加以下行，以注册`/products`路由及其关联的处理函数`ProductsHandler`：
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The **Decode** and **Attach** steps are performed within the `ProductsHandler`
    function:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**解码**和**附加**步骤在`ProductsHandler`函数内执行：'
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'First, we call the `FetchProducts` function a goroutine to fetch the list of
    products from the endpoint on the server side. The **Decode** step (shown in bold),
    is performed inside the `FetchProducts` function:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们调用`FetchProducts`函数的goroutine来从服务器端的端点获取产品列表。**解码**步骤（加粗显示）在`FetchProducts`函数内执行：
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: After fetching the encoded data from the Rest API endpoint, we use a JSON decoder
    to decode the encoded data back into a slice of `Product` objects. We then send
    the result over the `productsChannel`, where it is received inside the `ProductsHandler` function.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 从Rest API端点获取编码数据后，我们使用JSON解码器将编码数据解码回`Product`对象的切片。然后我们将结果发送到`productsChannel`，在`ProductsHandler`函数内接收。
- en: 'Now that we have the data object to populate the list of products on the products
    listing page, we can populate the `Products` field of the `templatedata.Products`
    struct. Recall that `templateData` is the data object that will be passed into
    the `Render` method of the `env.TemplateSet` object:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了用于填充产品列表页面上产品列表的数据对象，我们可以填充`templatedata.Products`结构的`Products`字段。回想一下，`templateData`是将传递到`env.TemplateSet`对象的`Render`方法中的数据对象：
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Up to this point, we have fulfilled the third step of the isomorphic handoff
    procedure, which means that we can effectively render the products listing page
    on the client side. However, we aren't done just yet, since we have to fulfill
    the last step of attaching DOM event handlers to the rendered web page.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经完成了同构交接过程的第三步，这意味着我们可以有效地在客户端上渲染产品列表页面。但是，我们还没有完成，因为我们必须完成最后一步，即将DOM事件处理程序附加到渲染的网页上。
- en: 'Inside the `ProductsHandler` function, there are two calls that are instrumental
    to performing the **Attach** step:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ProductsHandler`函数内，有两个调用对执行**附加**步骤至关重要：
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'First, we call the `InitializeProductsPage` function to add the event handlers
    necessary to enable user interactivity for the products listing page:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们调用`InitializeProductsPage`函数添加必要的事件处理程序，以启用产品列表页面的用户交互：
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We retrieve all the Add To Cart buttons that exist on the product listing page,
    by calling the `GetElementsByClassName` method on the `env.Document` object, and
    specifying the `"addToCartButton"` class name.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在`env.Document`对象上调用`GetElementsByClassName`方法，并指定`"addToCartButton"`类名，来检索产品列表页面上存在的所有加入购物车按钮。
- en: When an Add To Cart button is clicked, the `handleAddToCartButtonClickEvent`
    function will be called. We will cover this function when we implement the shopping
    cart feature.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当单击“加入购物车”按钮时，将调用`handleAddToCartButtonClickEvent`函数。在实现购物车功能时，我们将介绍这个函数。
- en: 'Let''s return to the `ProductsHandler` function. We will call the `RegisterLinks`
    method on the Isokit router object and specify the CSS query selector of `"#primaryContent
    a"`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到`ProductsHandler`函数。我们将在Isokit路由器对象上调用`RegisterLinks`方法，并指定CSS查询选择器`"#primaryContent
    a"`：
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This ensures that when the web page is rendered on the client side, all click
    events for the product item links will be intercepted by the client-side router.
    This will allow us to render the product detail page on the client side itself,
    without having to perform a full page reload.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这样可以确保在客户端渲染网页时，所有产品项链接的点击事件都将被客户端路由拦截。这将允许我们在客户端自身渲染产品详细页面，而无需执行完整的页面重新加载。
- en: 'Up to this point, we have  implemented the isomorphic handoff procedure for
    the products listing page. To render the products listing page on the client side,
    click on the Products link in the navigation bar. To render the products listing
    page on the server side, enter the following URL directly in the web browser:
    `http://localhost:8080/products`. *Figure 6.3* depicts the products listing page
    rendered on the client side:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经为产品列表页面实现了同构交接过程。要在客户端渲染产品列表页面，请在导航栏中单击产品链接。要在服务器端渲染产品列表页面，请直接在Web浏览器中输入以下URL：`http://localhost:8080/products`。*图6.3*显示了在客户端上渲染的产品列表页面：
- en: '![](img/c7a8d2c3-eaeb-4b87-8b59-f24345b695ba.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c7a8d2c3-eaeb-4b87-8b59-f24345b695ba.png)'
- en: 'Figure 6.3: The products listing page rendered on the client side'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3：在客户端上渲染的产品列表页面
- en: You may also refresh the web page to force the page to be rendered on the server
    side. We can verify that the isomorphic handoff procedure was implemented properly
    by comparing the web page loaded on the client side with the web page that was
    loaded on the server side. Since both web pages are identical, we can determine
    that the isomorphic handoff procedure has been successfully implemented.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以刷新网页以强制在服务器端呈现页面。我们可以通过比较在客户端加载的网页和在服务器端加载的网页来验证等同手交接程序是否正确实现。由于两个网页都是相同的，我们可以确定等同手交接程序已成功实现。
- en: Implementing isomorphic handoff for the product detail page
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为产品详细页面实现等同手交接
- en: Having successfully implemented the isomorphic handoff procedure on the products
    listing page using the ERDA strategy, let's focus on implementing isomorphic handoff
    for the product detail page.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 成功在产品列表页面上使用ERDA策略实现了等同手交接程序后，让我们专注于为产品详细页面实现等同手交接。
- en: 'To implement the **Encode** step, we first need to identify the data object
    that will represent the state we wish to persist to the client. We identify the
    data object by examining the `ProductDetailHandler` function found in the `handlers/productdetail.go`
    source file. This is the server-side handler function responsible for servicing
    the `/product-detail` route:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现**编码**步骤，我们首先需要确定表示我们希望保存到客户端的状态的数据对象。我们通过检查`handlers/productdetail.go`源文件中找到的`ProductDetailHandler`函数来识别数据对象。这是负责服务`/product-detail`路由的服务器端处理程序函数：
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The product object, a pointer to a `models.Product` struct, is obtained from
    the Redis datastore (shown in bold). This object contains the product data that
    will be displayed on the Product page; therefore, it is the object that we need
    to persist to the client side.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 从Redis数据存储中获取产品对象（以粗体显示）。该对象包含将显示在产品页面上的产品数据；因此，这是我们需要保存到客户端的对象。
- en: 'The `GetProductDetailEndpoint` function, found in the `endpoints/productdetail.go`
    source file, is the Rest API endpoint responsible for providing the JSON encoded
    `Product` data to the client:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`endpoints/productdetail.go`源文件中的`GetProductDetailEndpoint`函数是负责向客户端提供JSON编码的“Product”数据的Rest
    API端点：'
- en: '[PRE13]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Inside the `GetProductDetailEndpoint` function, we obtain the product object
    from the Redis datastore and encode it as JSON formatted data.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在`GetProductDetailEndpoint`函数内部，我们从Redis数据存储中获取产品对象，并将其编码为JSON格式数据。
- en: Now that we have taken care of the **Encode** step, we can implement the next
    three steps on the client side.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经处理了**编码**步骤，我们可以在客户端上实现接下来的三个步骤。
- en: 'To implement the **Register** step, we add the following line to register the
    `/product-detail` route and its associated handler function in the `client.go`
    source file:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现**注册**步骤，我们在`client.go`源文件中添加以下行，以注册`/product-detail`路由及其关联的处理程序函数：
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The **Decode** and **Attach** steps are carried out by the `ProductDetailHandler`
    function:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**解码**和**附加**步骤由`ProductDetailHandler`函数执行：'
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Inside the `ProductDetailHandler` function, we call the `FetchProductDetail`
    function as a goroutine to obtain the product object. The **Decode** step (shown
    in bold) is implemented inside the `FetchProductDetail` function:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ProductDetailHandler`函数内部，我们调用`FetchProductDetail`函数作为一个goroutine来获取产品对象。**解码**步骤（以粗体显示）是在`FetchProductDetail`函数内部实现的：
- en: '[PRE16]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We make an XHR call to the Rest API endpoint to obtain the encoded `Product`
    data. We use a JSON decoder to decode the encoded data back into a `Product` object.
    We send the `Product` object over the `productChannel`, where it is received back
    in the `ProductDetailHandler` function.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们发出XHR调用到Rest API端点，以获取编码的“Product”数据。我们使用JSON解码器将编码数据解码回“Product”对象。我们将“Product”对象发送到“productChannel”，在那里它会在“ProductDetailHandler”函数中接收到。
- en: 'Returning to the `ProductDetailHandler` function, we use the product data object
    to populate the product information on the product detail page. We do so by populating
    the Product field of the `templatedata.ProductDetail` object. Again, recall that
    the `templateData` variable is the data object that will be passed into the `Render`
    method of the `env.TemplateSet` object:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`ProductDetailHandler`函数，我们使用产品数据对象来填充产品详细页面上的产品信息。我们通过填充`templatedata.ProductDetail`对象的Product字段来实现这一点。再次回想一下，`templateData`变量是将传递到`env.TemplateSet`对象的`Render`方法中的数据对象：
- en: '[PRE17]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Up to this point, we have fulfilled the third step of the isomorphic handoff
    procedure, which means that we can now render the product detail page on the client
    side. Now, it's time to complete the last step of the procedure, **Attach**, by
    attaching DOM event handlers to their respective UI elements on the rendered web
    page.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经完成了等同手交接程序的第三步，这意味着我们现在可以在客户端上呈现产品详细页面。现在，是时候完成程序的最后一步**附加**，通过将DOM事件处理程序附加到呈现的网页上的各自UI元素上。
- en: 'We call the `InitializeProductDetailPage` function to add the event handler
    necessary to enable user interactivity for the products listing page:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用`InitializeProductDetailPage`函数来添加必要的事件处理程序，以启用产品列表页面的用户交互：
- en: '[PRE18]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Similar to the `InitializeProductsPage` function, we retrieve all the Add To
    Cart buttons on the web page and specify the event handler function, `handleAddToCartButtonClickEvent`,
    that will be called when an Add To Cart button is clicked.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 与“InitializeProductsPage”函数类似，我们检索网页上的所有“Add To Cart”按钮，并指定事件处理程序函数“handleAddToCartButtonClickEvent”，当单击“Add
    To Cart”按钮时将调用该函数。
- en: 'Up to this point, we have implemented the isomorphic handoff procedure for
    the product detail page. To render the product detail page on the client side,
    click on a product image found in the the products listing page. To render the
    product detail page on the server-side, enter the URL of a product in the web
    browser. For example, the URL to the product detail page for the swiss army knife
    is `http://localhost:8080/product-detail/swiss-army-knife`. *Figure 6.4* depicts
    the product detail page for the swiss army knife, which was rendered on the client
    side:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/64e2d5c3-b3f8-40bf-8b83-0e87a03a3e66.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.4: The product detail page rendered on the client side'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: Again, we can verify that the isomorphic handoff procedure is functioning properly
    by confirming that the web page rendered on the client side is identical to the
    web page rendered on the server side. Since both web pages are identical, we can
    conclude that we have successfully implemented the isomorphic handoff procedure
    for the product detail page.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: Implementing isomorphic handoff for the shopping cart
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have implemented isomorphic handoff for the product-related web
    pages, it's time to start implementing IGWEB's shopping cart feature. We'll start
    by designing the Shopping Cart web page.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: Designing the shopping cart page
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The design of the Shopping Cart page, as depicted in the wireframe design in
    *Figure 6.5*, is very similar to the product listings page. Each product item
    will contain a thumbnail sized image of the product, the product price, the product
    name, and a brief description of the product, just like the product listings page.
    In addition to these fields, the shopping cart page will have a field to display
    the quantity, that is, the amount of items of a particular product that are in
    the shopping cart, and a Remove From Cart button, that when clicked on, will remove
    the product from the shopping cart:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8142b3e2-4b7b-4c15-95b0-907ace76b234.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.5: The wireframe design depicting the shopping cart page with products
    in the shopping cart'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: 'Keep in mind that the first wireframe design covers the scenario, when the
    shopping cart has been populated with items. We must also consider the design
    of the page when the shopping cart is empty. The shopping cart could either be
    empty on the user''s initial visit to the IGWEB website or when the user empties
    the shopping cart entirely. *Figure 6.6* is a wireframe design of the shopping
    cart page, depicting the scenario where the shopping cart is empty:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1e37fbad-adbc-4c02-99b5-dfb451524763.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.6: The wireframe design depicting the shopping cart page when the
    shopping cart is empty'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the design of the shopping cart page locked down, it's time
    to implement the templates to realize the design.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the shopping cart templates
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will use the shopping cart page template in order to render the shopping
    cart on the server side. Here are the contents of the shopping cart page template,
    as defined in the `shared/templates/shopping_cart_page.tmpl` source file:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As you may have noticed, the shopping cart page template calls a `shopping_cart_content` subtemplate, which
    is responsible for rendering the shopping cart itself.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the contents of the shopping cart content template, as defined in
    the `shared/templates/shopping_cart_content.tmpl` source file:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Using the `if` action, we check to see whether there are any products to display
    in the shopping cart. If there are, we render each shopping cart item, using the
    `range` action. We render the name of the template, its thumbnail preview, and
    its description, along with its quantity. Finally, we render a button to remove
    the product from the shopping cart. Notice that we have embedded a data attribute
    called `data-sku` to include the product's unique `SKU` code along with the button
    element. This value come in handy later, when we make the XHR call to the Rest
    API endpoint responsible for removing a shopping cart item by clicking on this
    button.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `if` 操作，我们检查是否有任何商品要在购物车中显示。如果有，我们使用 `range` 操作来渲染每个购物车商品。我们渲染模板的名称、缩略图预览和描述，以及数量。最后，我们渲染一个按钮，以从购物车中移除产品。请注意，我们嵌入了一个名为
    `data-sku` 的数据属性，将产品的唯一 `SKU` 代码与按钮元素一起包含在内。稍后，当我们通过单击此按钮调用 Rest API 端点来移除购物车商品时，这个值会派上用场。
- en: If there are no items to display in the shopping cart, the flow of control reaches
    the `else` action. In this scenario, we will display the message that the shopping
    cart is empty.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果购物车中没有要显示的商品，控制流将到达 `else` 操作。在这种情况下，我们将显示购物车为空的消息。
- en: Finally, we will use the end template action to signal the end of the `if-else`
    conditional blocks.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将使用结束模板操作来表示 `if-else` 条件块的结束。
- en: The template data object
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板数据对象
- en: 'The template data object that will be passed to the template renderer will
    be a `templatedata.ShoppingCart` struct (defined in the `shared/templatedata/shoppingcart.go`
    source file):'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 将传递给模板渲染器的模板数据对象将是一个 `templatedata.ShoppingCart` 结构体（在 `shared/templatedata/shoppingcart.go`
    源文件中定义）：
- en: '[PRE21]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `PageTitle` field will be used to display the web page title and the `Products`
    field, a slice of `Product` objects, will be used to display the products that
    are currently in the shopping cart.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`PageTitle` 字段将用于显示网页标题，`Products` 字段是 `Product` 对象的切片，将用于显示当前在购物车中的产品。'
- en: Now that we have the templates in place, let's take a look at modeling the shopping
    cart.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了模板，让我们来看看如何对购物车进行建模。
- en: Modeling the shopping cart
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对购物车进行建模
- en: 'The `ShoppingCartItem` struct, defined in the `shared/models/shoppingcart.go`
    source file, represents an item in the shopping cart:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`ShoppingCartItem` 结构体在 `shared/models/shoppingcart.go` 源文件中定义，表示购物车中的商品：'
- en: '[PRE22]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `ProductSKU` field holds the `SKU` code of the product (the unique code
    used to distinguish a product) and the `Quantity` field holds the quantity of
    that particular product the user wishes to purchase. Each time the user hits the
    Add To Cart button on the products listing or product detail page, the quantity
    value for that particular product will be incremented in the shopping cart.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProductSKU` 字段保存产品的 `SKU` 代码（用于区分产品的唯一代码），`Quantity` 字段保存用户希望购买的特定产品的数量。每当用户在产品列表或产品详细页面上点击“添加到购物车”按钮时，该特定产品的数量值将在购物车中递增。'
- en: 'The `ShoppingCart` struct, also defined in the `shoppingcart.go` source file,
    represents the shopping cart:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`ShoppingCart` 结构体，也在 `shoppingcart.go` 源文件中定义，表示购物车：'
- en: '[PRE23]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `Items` field is a map of items having a key of the `string` type (which
    will be the product `SKU` code), and the value will be a pointer to a `ShoppingCartItem`
    struct.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`Items` 字段是一个项目的映射，其键为 `string` 类型（将是产品 `SKU` 代码），值将是指向 `ShoppingCartItem`
    结构体的指针。'
- en: 'The `NewShoppingCart` function is a constructor function to create a new instance
    of `ShoppingCart`:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`NewShoppingCart` 函数是一个构造函数，用于创建 `ShoppingCart` 的新实例：'
- en: '[PRE24]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `ItemTotal` method of the `ShoppingCart` type is responsible for returning
    the number of items that are currently in the shopping cart:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`ShoppingCart` 类型的 `ItemTotal` 方法负责返回当前购物车中的商品数量：'
- en: '[PRE25]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `IsEmpty` method of the `ShoppingCart` type is responsible for telling
    us if the shopping cart is empty or not:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`ShoppingCart` 类型的 `IsEmpty` 方法负责告诉我们购物车是否为空：'
- en: '[PRE26]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `AddItem` method of the `ShoppingCart` type is responsible for adding an
    item to the shopping cart:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`ShoppingCart` 类型的 `AddItem` 方法负责向购物车中添加商品：'
- en: '[PRE27]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: If a particular product item already exists in the shopping cart, the `Quantity`
    field will be incremented by one, upon each new request to add the product item.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果特定产品商品已经存在于购物车中，每次新请求添加产品商品时，`Quantity` 字段将递增一次。
- en: 'Similarly, the `RemoveItem` method of the `ShoppingCart` type is responsible
    for removing all items of a specific product type from the shopping cart:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，`ShoppingCart` 类型的 `RemoveItem` 方法负责从购物车中删除特定产品类型的所有商品：
- en: '[PRE28]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `UpdateItemQuantity` method of the `ShoppingCart` type is responsible for
    updating the quantity of a specific product in the shopping cart:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`ShoppingCart` 类型的 `UpdateItemQuantity` 方法负责更新购物车中特定产品的数量：'
- en: '[PRE29]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Shopping cart routes
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 购物车路由
- en: By implementing the `ShoppingCart` type, we now have the business logic in place,
    to drive the shopping cart functionality. Now it's time to register the server-side
    routes that are needed to implement the shopping cart.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实现 `ShoppingCart` 类型，我们现在已经有了业务逻辑，可以驱动购物车功能。现在是时候注册服务器端路由，以实现购物车。
- en: 'We register the `/shopping-cart` route along with its associated handler function,
    `ShoppingCartHandler`, inside the `registerRoutes` function, which is found in
    the `igweb.go` source file:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `igweb.go` 源文件中的 `registerRoutes` 函数中注册了 `/shopping-cart` 路由及其关联的处理程序函数
    `ShoppingCartHandler`：
- en: '[PRE30]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The route handler function, `ShoppingCartHandler`, is responsible for generating
    the web page for the shopping cart page on the server side.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 路由处理程序函数 `ShoppingCartHandler` 负责在服务器端生成购物车页面的网页。
- en: 'We also register the following Rest API endpoints:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还注册了以下 Rest API 端点：
- en: Fetching a list of items (`/restapi/get-cart-items`)
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取商品列表（`/restapi/get-cart-items`）
- en: Adding an item (`/restapi/add-item-to-cart`)
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加商品（`/restapi/add-item-to-cart`）
- en: Removing an item (`/restapi/remove-item-from-cart`)
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移除商品（`/restapi/remove-item-from-cart`）
- en: Fetching a list of items
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取商品列表
- en: 'For fetching a list of items in the shopping cart, we will register the `/restapi/get-cart-items`
    endpoint:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 用于获取购物车中物品列表的，我们将注册`/restapi/get-cart-items`端点：
- en: '[PRE31]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This endpoint will be handled by the `GetShoppingCartItemsEndpoint` handler
    function. This endpoint is responsible for encoding the shopping cart as JSON
    encoded data and providing it to the client-side application. Note that we use
    the HTTP `GET` method to call this endpoint.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这个端点将由`GetShoppingCartItemsEndpoint`处理函数处理。这个端点负责将购物车编码为JSON编码数据，并提供给客户端应用程序。请注意，我们使用HTTP的`GET`方法来调用这个端点。
- en: Adding an item
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加物品
- en: 'For adding an item to the shopping cart, we will register the `/restapi/add-item-to-cart`
    endpoint:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 用于将物品添加到购物车的，我们将注册`/restapi/add-item-to-cart`端点：
- en: '[PRE32]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This route will be handled by the `AddItemToShoppingCartEndpoint` handler function.
    Note that since we are performing a mutating operation on the web server (adding
    a shopping cart item), we use the HTTP `PUT` method when calling this endpoint.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这个路由将由`AddItemToShoppingCartEndpoint`处理函数处理。请注意，由于我们在web服务器上执行了一个改变操作（添加购物车物品），所以在调用这个端点时，我们使用HTTP的`PUT`方法。
- en: Removing an item
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 移除物品
- en: 'For removing an item of a specific product type, and all quantities of it,
    from the shopping cart, we will register the `/restapi/remove-item-from-cart`
    endpoint:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 用于从购物车中移除特定产品类型的物品及其所有数量的，我们将注册`/restapi/remove-item-from-cart`端点：
- en: '[PRE33]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This endpoint will be handled by the `RemoveItemFromShoppingCartEndpoint` handler
    function. Again, note that we use the HTTP `DELETE` method when calling this endpoint since
    we are performing a mutating operation on the web server (removing a shopping
    cart item).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这个端点将由`RemoveItemFromShoppingCartEndpoint`处理函数处理。再次请注意，由于我们在web服务器上执行了一个改变操作（移除购物车物品），所以在调用这个端点时，我们使用HTTP的`DELETE`方法。
- en: The session store
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 会话存储
- en: Unlike the product records, which are stored in the Redis database, the items
    a user chooses to place in their shopping cart is transitory, and it's customized
    for individual use. This being the case, it makes much more sense to store the
    state of the shopping cart in a session, rather than in the database.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 与产品记录存储在Redis数据库中不同，用户选择放入购物车的物品是瞬时的，并且是针对个人定制的。在这种情况下，将购物车的状态存储在会话中比存储在数据库中更有意义。
- en: We will use the Gorilla `sessions` package to create sessions and store data
    to the sessions. We will utilize the `session.NewFileSystemStore` type to save
    the session data to the server's file system.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Gorilla的`sessions`包来创建会话并将数据存储到会话中。我们将利用`session.NewFileSystemStore`类型将会话数据保存到服务器的文件系统中。
- en: 'First, we will add a new field (shown in bold) to the `common.Env` struct (defined
    in the `common/common.go` source file), which will hold the `FileSystemStore`
    instance so that it is accessible throughout the server-side web application:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将在`common/common.go`源文件中的`common.Env`结构体中添加一个新字段（以粗体显示），该字段将保存`FileSystemStore`实例，以便在整个服务器端web应用程序中访问：
- en: '[PRE34]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Inside the `main` function defined in the `igweb.go` source file, we will make
    a call to the `initializeSessionstore` function and pass in the `env` object:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在`igweb.go`源文件中定义的`main`函数内，我们将调用`initializeSessionstore`函数并传入`env`对象：
- en: '[PRE35]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The `initializeSessionstore` function is responsible for creating the session
    store on the server side:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`initializeSessionstore`函数负责在服务器端创建会话存储：'
- en: '[PRE36]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In the `if` conditional, we first check to see whether the designated path where
    the session data will be stored, `/tmp/igweb-sessions`, exists. If the path does
    not exist, we create the folder by calling the `Mkdir` function from the `os`
    package.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在`if`条件中，我们首先检查会话数据将被存储的指定路径`/tmp/igweb-sessions`是否存在。如果路径不存在，我们将调用`os`包中的`Mkdir`函数来创建文件夹。
- en: We will initialize a new file system session store by calling the `NewFileSystemStore`
    function in the `sessions` package, passing in the path where sessions will be
    saved and the authentication key for the session. We will populate the `Store`
    property of the `env` object with the newly created `FileSystemStore` instance.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将调用`sessions`包中的`NewFileSystemStore`函数来初始化一个新的文件系统会话存储，传入会话将被保存的路径和会话的身份验证密钥。我们将用新创建的`FileSystemStore`实例填充`env`对象的`Store`属性。
- en: Now that we have the session store in place, let's implement the server-side
    `ShoppingCartHandler` function.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了会话存储，让我们实现服务器端的`ShoppingCartHandler`函数。
- en: The server-side shopping cart handler function
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器端购物车处理函数
- en: 'The `ShoppingCartHandler` function, defined in `handlers/shoppingcart.go`,
    is responsible for servicing the `/shopping-cart` route:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在`handlers/shoppingcart.go`中定义的`ShoppingCartHandler`函数负责为`/shopping-cart`路由提供服务。
- en: '[PRE37]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The main purpose of the server-side shopping cart handler function is to produce
    the output for the shopping cart web page.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器端购物车处理函数的主要目的是为购物车网页生成输出。
- en: Recall that the handler functions for the product-related pages, tapped into
    the Redis datastore to retrieve the list of products. The shopping cart handler,
    on the other hand, taps into the server-side session to get the list of items
    that are in the shopping cart.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，与产品相关页面的处理函数是从Redis数据存储中检索产品列表的。另一方面，购物车处理函数是从服务器端会话中获取购物车中物品列表的。
- en: 'We will declare the variables for the `templateData` object and the shopping
    cart:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将声明`templateData`对象和购物车的变量：
- en: '[PRE38]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We''ve define and initialize the `igwSession` variable of the `gorilla.SessionStore` type,
    which will hold our server-side session:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经定义并初始化了`gorilla.SessionStore`类型的`igwSession`变量，它将保存我们的服务器端会话：
- en: '[PRE39]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Recall that we can access the `FileSystemStore` object by accessing the `Store`
    property of the `env` object. We call the `Get` method of the session store object
    passing in the pointer to `http.Request`, `r`, and the name of the session, `"igweb-session"`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，我们可以通过访问`env`对象的`Store`属性来访问`FileSystemStore`对象。我们调用会话存储对象的`Get`方法，传入`http.Request`的指针`r`和会话的名称`"igweb-session"`。
- en: If the session does not exist, a new session named `"igweb-session"` will automatically
    be created for us.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: To access values in the session, we use the `Values` property of the `igwSession`
    object, which is a map of keys to values. The keys are strings, and the values
    are of type empty interface, `interface{}`, so that they can hold any type (since
    all types in Go implement the empty interface).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `if` conditional block, we check to see whether a value for the `"shoppingCart"` session
    key exists in the `Values` map:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The JSON-encoded value for the shopping cart object is accessed using the `"shoppingCart"`
    key. If the shopping cart exists in the session, we decode the JSON object using
    the `Decode` method of the JSON decoder object. If the JSON object is successfully
    decoded, the decoded object is stored in the `cart` variable.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the shopping cart object from the session, we need to get
    the product information for each item in the shopping cart. We do so by calling
    the `GetProductsInShoppingCart` method of the the datastore object and supplying
    the `cart` variable as an input argument to the method:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This function will return the slice of products that are to be displayed on
    the shopping cart page. Notice that we populate the `Products` field of the `templatedata.ShoppingCart`
    object with the slice of products obtained from the datastore:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Since we will utilize this slice of products to render the server-side shopping
    cart template page, the slice of products returned from the `GetProductsInShoppingCart`
    method is the state data that we need to persist to the client-side when implementing
    isomorphic handoff.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: 'If the `"shoppingCart"` key did not exist in the session, the flow of control
    reaches the `else` block:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In this situation, we set the `Products` field of the `templatedata.ShoppingCart`
    struct to `nil`, to indicate that there are no products in the shopping cart since
    the shopping cart does not exist in the session.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we render the shopping cart page by calling the `Render` method on
    the template set object, passing in the name of the template we wish to render
    (the `shopping_cart_page` template) along with the render parameters:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Notice that we have set the `RenderParams` object's `Writer` property to `http.ResponseWriter`,
    `w`, and we have set the `Data` property to the `templateData` variable.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the `GetProductsInShoppingCart` method defined in the
    Redis datastore (found in the `common/datastore/redis.go` source file):'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The job of this method is to return a slice of `Product` objects for all the
    products that exist within a shopping cart. The `ShoppingCart` struct simply keeps
    track of a product's type (through its `SKU` code) and the `Quantity` of that
    product in the shopping cart.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: We declare a `result` variable, which is a slice of the `Product` objects. We
    loop through each shopping cart item, and we retrieve the `Product` object from
    the `productsMap`, providing the product's `SKU` code as the key. We populate
    the `Quantity` field of the `Product` object and append the `Product` object to
    the `result` slice.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: We call the `Sort` method from the sort package passing in the `result` slice.
    Since we have implemented the sort interface for the `Products` type, the `Product`
    objects in the `result` slice will be sorted by price in the ascending order.
    Finally, we return the `result` slice.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: Shopping cart endpoints
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, while we are finishing up the server-side functionality to implement
    the shopping cart feature, we are also ready to start implementing the isomorphic
    handoff procedure, following the ERDA strategy.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: The endpoint to get items in the shopping cart
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's examine the shopping cart's Rest API endpoints, which help service actions
    that the client-side web application is dependent on. Let's start with the endpoint
    function, `GetShoppingCartItemsEndpoint`, which is responsible for getting the
    items in the shopping cart. The **Encode** step, of the isomorphic handoff procedure
    is performed in this endpoint function.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the source listing of the `GetShoppingCartItemsEndpoint` function:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: In this function, we fetch the shopping cart from the session. If we are able
    to successfully fetch the shopping cart from the session, we use a JSON encoder
    to encode the `ShoppingCart` object and write it using `http.ResponseWriter`,
    `w`.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: If the shopping cart does not exist in the session, then we simply JSON encode
    the value of `nil` (which is equivalent to a JavaScript `null` on the client side)
    and write it out in the response, using `http.ResponseWriter`, `w`.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: With this code in place, we have fulfilled the Encode step in the isomorphic
    handoff procedure.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: The endpoint to add items to the shopping cart
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We declared a `m` variable (shown in bold), of the `map[string]string` type,
    in `AddItemToShoppingCartEndpoint`, which is the endpoint function that is responsible
    for adding a new item to the shopping cart:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: We use a JSON decoder to decode the request body, which will contain a JSON
    encoded map sent from the client. The map will contain the `SKU` value of the
    product to add to the shopping cart, given the `"productSKU"` key.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: 'We will check to see whether the shopping cart exists in the session. If it
    does, we will decode the shopping cart JSON data back into a `ShoppingCart` object:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'If the shopping cart doesn''t exist, flow of control reaches the `else` block,
    and we will create a new shopping cart:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We will then make a call to the `AddItem` method of the `ShoppingCart` object
    to add the product item:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: To add an item to our shopping cart, we simply have to provide the product's
    `SKU` value, which we can obtain from the `m` map variable by accessing the value
    that exists in the map for the `productSKU` key.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: 'We will encode the cart object into its JSON representation and save it into
    the session, with the session key `"shoppingCart"`:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: We then write back the response, `"OK"`, to the client, to indicate that the
    operation to add a new item to the cart was performed successfully.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: The endpoint to remove items from the shopping cart
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here''s the source listing of `RemoveItemFromShoppingCartEndpoint`, the endpoint
    that is responsible for removing all items of a specific product from the shopping
    cart:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Remember that we can have multiple quantities for a given product. In the current
    shopping cart implementation, if the user clicks on the Remove From Cart button,
    the given product (and all quantities of it) are removed from the shopping cart.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: We start out by fetching the JSON encoded shopping cart data from the session.
    If it exists, we decode the JSON object into a new `ShoppingCart` object. If the
    shopping cart does not exist in the session, we simply create a new shopping cart.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: We range through the items found in the shopping cart, and if we are able to
    find a product in the cart containing the same product `SKU` code supplied in
    the `m` map variable that was obtained from the client-side web application, we
    will remove the element from the shopping cart object's `Items` map by calling
    the built-in `delete` function (shown in bold). Finally, we will write out a JSON
    encoded response to the client that the operation was successfully completed.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our server-side endpoints in place, it's time to take a look
    at the functionality needed on the client side to implement the final pieces of
    the shopping cart feature.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the shopping cart functionality on the client side
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To fulfill the **Register** step of the ERDA strategy, we will register the
    `/shopping-cart`  route and its associated handler function, `ShoppingCartHandler`,
    inside the `registerRoutes` function found in the `client/client.go` source file:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Remember that this route will kick-in when a user access the shopping cart by
    clicking on the shopping cart icon in the navigation bar. Upon clicking the shopping
    cart icon, the `ShoppingCartHandler` function will be called.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the `ShoppingCartHandler` function:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The main purpose of this function is to call the `renderShoppingCartItems` function
    to render the shopping cart on the client side. We have consolidated the logic
    to render the shopping cart and its contents in the `renderShoppingCartItems`
    function so that the shopping cart page can be re-rendered as the user removes
    items from the shopping cart.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: Rendering the shopping cart
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `renderShoppingCartItems` function is responsible for conducting the last
    two steps of the ERDA strategy, the **Decode** and **Attach** steps. Here''s the
    source listing of the `renderShoppingCartItems` function:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: In this function, we create a new channel called `productsChannel`, which is
    a channel that we'll use to send and receive a slice of products over. We call
    the `fetchProductsInShoppingCart` function as a goroutine and provide `productsChannel`
    as an input argument to the function. This function is responsible for fetching
    the product items in the shopping cart from the server by performing an XHR call.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the source listing for the `fetchProductsInShoppingCart` function:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: In this function, we simply make an XHR call to the Rest API endpoint, `/restapi/get-cart-items`,
    which is responsible for returning the JSON-encoded data that represents the slice
    of products. We use a JSON decoder to decode the encoded slice of products into
    the `products` variable.  Finally, we send the `products` variable over `productsChannel`.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s return to the `renderShoppingCartItems` function and receive the slice
    of products from the `productsChannel`, and then, we will set the `Products` property
    of the `templateData` object with the received products:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'We will then render the shopping cart template on the client side:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: At this point, we have fulfilled the **Decode** step of the ERDA strategy.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: To fulfill the **Attach** step of the ERDA strategy, we will make a call to
    the `InitializeShoppingCartEventHandlers` function to attach any needed event
    listeners to the shopping cart web page.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the source listing of the `InitializeShoppingCartEventHandlers` function:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This function is responsible for attaching a click event on all the Remove From
    Cart buttons that are found in each product container listed on the shopping cart
    web page. The event handler function that is called when the Remove From Cart
    button is clicked, is the `handleRemoveFromCartButtonClickEvent` function.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: We have now fulfilled, the fourth and last step of the ERDA strategy, by attaching
    event listeners to the Remove From Cart buttons on the shopping cart web page.
    The implementation of isomorphic handoff for the shopping cart feature is complete.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: Removing an item from the shopping cart
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s take a look at the `handleRemoveFromCartButtonClickEvent` function,
    which gets called when the Remove From Cart button is clicked:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: In this function, we obtain the product `SKU` code from the event target element's
    `data-sku` attribute. We then call the `removeFromCart` function as a goroutine,
    passing in the `env` object and `productSKU`.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the source listing of the `removeFromCart` function:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: We create a new map, `m`, in the `removeFromCart` function, which is used to
    house `productSKU`. We can access the product's `SKU` value from the  `m` map by
    providing the `"productSKU"` key. We have intended to send this map to the web
    server through the request body. The reason that we have chosen the `map` type,
    as opposed to simply sending the product's `SKU` string value, is that we want
    to make our solution extensible. In the future, if there is any additional information
    that should be sent to the server, we can include that value as part of an additional
    key-value pair in the map.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: We encode the map into its JSON representation and make an XHR call to the web
    server, sending the map JSON data. Finally, we make a call to the `renderShoppingCartItems`
    function to render the shopping cart items. Remember that by calling this function,
    we will be performing an XHR call to get the latest products in the shopping cart
    (which represents the current state of the shopping cart). This ensures that we
    will have the most up-to-date state of the shopping cart, since again, we are
    using the server-side session (where the shopping cart state is stored) as our
    single source of truth.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: Adding an item to the shopping cart
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The functionality for the Add To Cart button is implemented in a similar manner.
    Recall that on the product-related pages, if any Add To Cart button is clicked,
    the `handleAddToCarButton` function is called. Here is the source listing of the
    function:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: In a manner similar to the `handleRemoveFromCartButtonClickEvent` function,
    inside the `handleAddToCart` function, we obtain the product's `SKU` code from
    the event target element by getting the data attribute with the `“data-sku”` key.
    We then call the `addToCart` function as a goroutine and supply `productSKU` as
    an input argument to the function.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the source listing of the `addToCart` function:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Inside the `addToCart` function, we make an XHR call to the Rest API endpoint
    on the web server that is responsible for adding an item to the cart. Prior to
    making the XHR call, we create a map containing `productSKU`, and then we encode
    the map into its JSON representation. We send the JSON data using an XHR call
    to the server endpoint.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: We can now display the shopping cart on the client side, and we can also accommodate
    the user interactions with the shopping cart, notably adding a product to the
    shopping cart and removing a product from the shopping cart.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: The shopping cart implementation that was covered in this chapter is meant for
    illustration purposes only. It is up to the reader to implement further functionality.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: Verifying the shopping cart functionality
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now it's time to verify that the state of the shopping cart is maintained from
    the server to the client, as the user adds and removes items from the shopping
    cart.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: Verifying that isomorphic handoff was successfully implemented is straightforward.
    We simply need to verify that the server-side generated shopping cart page is
    identical to the client-side generated shopping cart page. By clicking on the
    shopping cart icon, we can see the client-side generated web page. By clicking
    on the refresh button while on the shopping cart page, we can see the server-side
    generated web page.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting out, there are no items placed in the shopping cart. *Figure 6.7*
    is a screenshot depicting the shopping cart in its empty state:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ed44a1f1-4a86-4597-9bc5-0d161404ba33.png)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.7: The shopping cart page when the shopping cart is empty'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: The shopping cart page rendered on the client side matches the page rendered
    on the server side, indicating that the empty state of the shopping cart is maintained
    properly.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s visit the product listings page by clicking on the Products link
    on the navigation bar. Let''s add a few items to the shopping cart by clicking
    on the Add To Cart button. Let''s click on the shopping cart icon in the top bar
    of the website to return to the shopping cart page. *Figure 6.8* is a screenshot
    depicting the shopping cart with some products added:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/23dbfb75-e299-4ca5-8a6f-83f747859260.png)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.8: The shopping cart page with some products in the shopping cart'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: After checking that the shopping cart page rendered on the client side matches
    the page rendered on the server side, we can determine that the state of the shopping
    cart has been maintained successfully.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: Now remove all the items from the shopping cart by clicking on the Remove From
    Cart button on each product. Once the shopping cart is empty, we can perform the
    same verification step of checking the page rendered on the client side with the
    page rendered on the server side to determine that the shopping cart state is
    successfully maintained.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we can acknowledge that the isomorphic handoff procedure has
    been implemented successfully for the shopping cart feature.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that as we add items to the shopping cart, a notification
    is displayed on the lower right-hand side of the screen, as displayed in *Figure
    6.9*. Notice that the notification is displayed at the lower right-hand side of
    the web page, and it indicates that the product has been successfully added to
    the shopping cart:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2636829e-fbcb-4a38-b257-db6f8a6da20b.png)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.9: A notification appears on the page''s lower right-hand side when
    an item has been added to the shopping cart'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: Note that similar notifications also appear when items are removed from the
    shopping cart. We utilized a cog, a reusable component, to generate this notification.
    We will cover the implementation of the cog responsible for generating these notifications
    in [Chapter 9](cbb6c046-c40f-4681-a25d-9b979614b2cf.xhtml), *Cogs – Reusable Components*.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we introduced you to *isomorphic handoff*, the means by which
    the server passes off state to the client. This is a significant procedure, that
    allows the client to pick up where the server left off in an isomorphic web application.
    We demonstrated the ERDA strategy to implement isomorphic handoff for the product-related
    web pages as well as the shopping cart web page. While implementing the shopping
    cart feature, we created a server-side session store, which acted as the source
    of truth for the current state of the user's shopping cart. We implemented server-side
    endpoints to implement the functionality to get items from the shopping cart,
    add items to the shopping cart, and remove items from the shopping cart. Finally,
    we verified that isomorphic handoff was successfully implemented by confirming
    that the web page rendered on the client side was identical to the the web page
    rendered on the server side.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: We also relied on sources of truth on the server side to maintain state with
    the client. For the product-related pages, the source of truth was the Redis datastore,
    and for the shopping cart page, the single source of truth was the server-side
    session store. In [Chapter 7](a9dcc0d7-ecf7-4ad0-b879-0a596ab4594e.xhtml), *The
    Isomorphic Web Form*, we'll consider how to handle situations that go beyond basic
    user interactions. You'll learn how to accept user generated data from the client
    side, submitted through an isomorphic web form. You will learn how to validate
    and process the data submitted by the user, by implementing the contact form on
    IGWEB's Contact web page.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
