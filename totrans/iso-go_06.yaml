- en: Isomorphic Handoff
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the development of Isomorphic Go web applications, two critical techniques
    were introduced in the previous two chapters. First, you learned how to utilize
    an in-memory template set to render templates across environments. Second, you
    learned how to perform end-to-end routing on both the client and the server. Client-side
    routing is the magic that allows the client-side web application to operate in
    the single page mode.
  prefs: []
  type: TYPE_NORMAL
- en: The aforementioned techniques now provide us with the ability to navigate to
    different sections of the website, on the client itself, and render any given
    template across environments. As the implementors of an Isomorphic Go web application
    our responsibility is to ensure that state is maintained between the client and
    the server. For example, when rendering the Products page, it wouldn't make sense
    if the list of products was rendered differently on the client side than it was
    on the server side. The client needs to work in lockstep with the server to ensure
    that the state, in this case, the list of products is maintained—and that's where
    *isomorphic handoff* comes into the picture.
  prefs: []
  type: TYPE_NORMAL
- en: '**Isomorphic handoff** is the process by which the server hands off state to
    the client and the client uses the passed state to render the web page on the
    client side. Keep in mind that the state the server passes off to the client must
    include the exact same state that was used to render the server-side web page
    response. Isomorphic handoff essentially allows the client to seamlessly pick
    up things where they were left off on the server. In this chapter, we''ll revisit
    the product-related pages, to see exactly how the state is maintained from the
    server side to the client side. In addition to that, we will also complete the
    implementation of the product-related pages, by implementing the user interactivity
    portions, which involve adding event handlers to the Add To Cart buttons found
    in these pages.'
  prefs: []
  type: TYPE_NORMAL
- en: The shopping cart feature for the IGWEB website will be implemented in this
    chapter, and it will allow us to consider the scenario where the user can change
    the state of the shopping cart by adding and removing items to and from the shopping
    cart. We will use isomorphic handoff to ensure that the current state of the shopping
    cart is seamlessly maintained across the server and the client. By properly maintaining
    the state of the shopping cart we can guarantee that the shopping cart page rendered
    from the server side always matches the shopping cart page rendered from the client
    side.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The isomorphic handoff procedure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing isomorphic handoff for the product-related pages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing isomorphic handoff for the shopping cart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The isomorphic handoff procedure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A recurring theme in the development of isomorphic web applications centers
    around the ability to share between the server and the client. In an isomorphic
    web application, the server and client must work in unison to seamlessly maintain
    the state of a particular workflow in the application. In order to do so, the
    server must share the current state, which was used to render the web page output
    on the server side with the client.
  prefs: []
  type: TYPE_NORMAL
- en: The ERDA strategy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The isomorphic handoff procedure consists of the following four steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Encode
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Register
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Decode
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Attach
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can use the acronym **ERDA** (**Encode-Register-Decode-Attach**) to easily
    recall each individual step of the procedure. In fact, we can collectively refer
    to the steps to implement the isomorphic handoff procedure as the **ERDA strategy**.
  prefs: []
  type: TYPE_NORMAL
- en: 'By implementing the four steps of the isomorphic handoff procedure, as depicted
    in *Figure 6.1*, we can guarantee that state is successfully persisted between
    the server and the client:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b775dd1b-10c7-4646-88b4-5fae1ef16669.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.1: The ERDA strategy to implement isomorphic handoff'
  prefs: []
  type: TYPE_NORMAL
- en: The first step, **Encode**, involves encoding a data object that represents
    the state we wish to retain to the client into a data exchange format (JSON, Gob,
    XML, and so on). The subsequent steps are all performed on the client side. The
    second step, **Register**, involves registering a client-side route and its respective
    handler function. The third step, **Decode**, involves decoding the encoded data
    retrieved from the server, through a Rest API endpoint, and utilizing it to render
    the template for the web page on the client side. The fourth and last step, **Attach**,
    involves attaching any needed event handlers to the rendered web page to enable
    user interactivity.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 6.2* depicts the key modules involved, on both the server and the client,
    in implementing the isomorphic handoff procedure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2acedc0f-703d-4bc2-bcf3-8a6b05c716b0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.2: The key modules involved in isomorphic handoff'
  prefs: []
  type: TYPE_NORMAL
- en: The **Encode** step, is performed inside the **Rest API Endpoint** that exists
    in the server-side web application. The **Register** step is performed inside
    the **Route Handler** that exists in the client-side web application. The **Decode**
    step is performed prior to calling the client-side **Template Renderer**. The
    **Attach** Step is performed by implementing the **DOM Event Handlers** on the
    client side.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have introduced each step in the ERDA strategy, let's explore each
    step in detail.
  prefs: []
  type: TYPE_NORMAL
- en: The Encode step
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our goal to regenerate the state on the client side begins by identifying the
    data object that represents the state we wish to retain in order to maintain state
    in a particular web page. To identify the object, we simply need to take a look
    at the server-side handler function that produced the rendered web page output.
    For example, in the products listing page, the slice of `Product` objects would
    be the data object that we would want to retain to the client side, so that the
    web page rendered on the client-side would render the same list of products.
  prefs: []
  type: TYPE_NORMAL
- en: We can expose the slice of the `Product` objects to the client side by implementing
    a Rest API Endpoint (depicted in *Figure 6.2*). The **Encode** step (depicted
    in *Figure 6.1*), consists of encoding the slice of the `Product` objects to a
    common data exchange format. For this chapter, we will encode objects using the
    **JSON** (short for, **JavaScript Object Notation**) format. The client-side web
    application can access the encoded object by making an XHR call to the Rest API
    endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the encoded state object is available, the rest of the steps to implement
    the isomorphic handoff procedure happen on the client side.
  prefs: []
  type: TYPE_NORMAL
- en: The Register step
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To fulfill the register step (depicted in *Figure 6.1*), we must first register
    a client-side route and its respective handler function (depicted in the Route
    Handler box in *Figure 6.2*). For example, for the Products page, we would register
    the `/products` route and its associated handler function, `ProductsHandler`.
    When a user clicks on the Products link from the navigation bar, the click event
    will be intercepted by the isokit router and the handler function, `ProductsHandler`,
    which is associated with handling the `/products` route, will be called. The route
    handler function plays the role of executing the last two steps of the isomorphic
    handoff process—decode and attach.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that if the user were to land first on the `/products` route by
    directly accessing the web page by entering the URL in the web browser, the server-side
    handler function will kick-in and the Products page will be rendered on the server
    side. This provides us the capability to render the web page instantly, providing
    a page load that is perceived to be fast to the user.
  prefs: []
  type: TYPE_NORMAL
- en: The Decode step
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Within the route handler function, we initiate an XHR call to the Rest API endpoint,
    that will return the encoded data that represents the state we wish to maintain
    on the client side. Once the encoded data is obtained, we will perform the third
    step, **Decode** (depicted in *Figure 6.1*), of the isomorphic handoff procedure.
    In this step, we decode the encoded data back into an object instance. The object
    instance is then utilized to populate the corresponding field of the template
    data object that is passed to the Template Renderer (depicted in *Figure 6.2*),
    so that the web page can be successfully rendered on the client side, in the same
    manner as it was rendered on the server side.
  prefs: []
  type: TYPE_NORMAL
- en: The Attach step
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The fourth and last step, Attach (depicted in *Figure 6.1*), is responsible
    for attaching event handlers (depicted in *Figure 6.2*) to DOM elements that exist
    in the rendered web page. For example, in the Products page, we would need to
    attach event handlers to all the Add To Cart buttons found on the web page. When
    an Add To Cart button is pressed, the respective product item will be added to
    the user's shopping cart.
  prefs: []
  type: TYPE_NORMAL
- en: Up to this point, we have laid out the groundwork needed to implement the isomorphic
    handoff procedure for a given web page. To solidify our understanding of isomorphic
    handoff, let's consider two specific examples where we implement all four steps
    of the procedure. First, we will implement the isomorphic handoff procedure in
    the product-related pages, which include the products listing page (`/products`)
    and the product detail page (`/product-detail/{productTitle}`). Second, we will
    implement the isomorphic handoff procedure for the shopping cart page. The second
    example will be more dynamic, since the user will have the capability to alter
    the state, because the user can add and remove items to the shopping cart as they
    wish. This capability allows the user to exert control on the current state of
    the shopping cart.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing isomorphic handoff for the product-related pages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As noted earlier, the product-related pages consist of the products listing
    page and the product detail page. We will follow the ERDA strategy to implement
    the isomorphic handoff procedure for these pages.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the sort interface for the product model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we get started, we will define a new type called `Products` (in the
    `shared/models/product.go` source file), which will be a slice of `Product` objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We will have the `Products` type implement the `sort` interface by defining
    the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: By examining the `Less` method, you will be able to see that we will sort the
    products displayed on the product listing page by the product's price in ascending
    order (lowest to highest).
  prefs: []
  type: TYPE_NORMAL
- en: At the first glance we may presume that the products obtained from the Redis
    database are already sorted in some predetermined order. However, if we want isomorphic
    handoff to succeed, we cannot operate in the realm of assumption; we must operate
    in the realm of fact. In order to do so, we need a predictable criteria for the
    sorting of products.
  prefs: []
  type: TYPE_NORMAL
- en: This is why we perform the additional work of implementing the `sort` interface
    for the `Products` type, so that we have a predictable criteria by which the products
    are listed on the products listing page. It provides us a benchmark when verifying
    the success of isomorphic handoff, since we simply need to confirm that the products
    listing page rendered on the client side is identical to the products listing
    page rendered on the server side. It is indeed helpful, that we have a common,
    predictable criteria that the products are sorted by price in the ascending order.
  prefs: []
  type: TYPE_NORMAL
- en: 'We add the following line (shown in bold) in the `GetProducts` method in the
    `redis.go` source file to sort the products:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Implementing isomorphic handoff for the products listing page
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we must implement the **Encode** step. To do this, we need to decide
    the data that must be persisted to the client side. We can easily identify the
    data that must be persisted to the client, by examining the server side handler
    function, `ProductsHandler`, responsible for rendering the products listing web
    page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The products listing page is responsible for displaying the list of products,
    therefore, the `products` variable (shown in bold), a slice of `Product` objects,
    must be persisted to the client side.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have identified the data that needs to be persisted to the client,
    to maintain state, we can create a Rest API Endpoint, `GetProductsEndpoint`, that
    is responsible for delivering the slice of products to the client, in the JSON-encoded
    form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Our work to implement isomorphic handoff is complete on the server side, and
    now it's time to turn our attention to the client side.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement the **Register** step, we add the following line to register the
    `/products` route and its associated handler function, `ProductsHandler`, in the
    `registerRoutes` function found in the `client.go` source file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The **Decode** and **Attach** steps are performed within the `ProductsHandler`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we call the `FetchProducts` function a goroutine to fetch the list of
    products from the endpoint on the server side. The **Decode** step (shown in bold),
    is performed inside the `FetchProducts` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: After fetching the encoded data from the Rest API endpoint, we use a JSON decoder
    to decode the encoded data back into a slice of `Product` objects. We then send
    the result over the `productsChannel`, where it is received inside the `ProductsHandler` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the data object to populate the list of products on the products
    listing page, we can populate the `Products` field of the `templatedata.Products`
    struct. Recall that `templateData` is the data object that will be passed into
    the `Render` method of the `env.TemplateSet` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Up to this point, we have fulfilled the third step of the isomorphic handoff
    procedure, which means that we can effectively render the products listing page
    on the client side. However, we aren't done just yet, since we have to fulfill
    the last step of attaching DOM event handlers to the rendered web page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `ProductsHandler` function, there are two calls that are instrumental
    to performing the **Attach** step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we call the `InitializeProductsPage` function to add the event handlers
    necessary to enable user interactivity for the products listing page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We retrieve all the Add To Cart buttons that exist on the product listing page,
    by calling the `GetElementsByClassName` method on the `env.Document` object, and
    specifying the `"addToCartButton"` class name.
  prefs: []
  type: TYPE_NORMAL
- en: When an Add To Cart button is clicked, the `handleAddToCartButtonClickEvent`
    function will be called. We will cover this function when we implement the shopping
    cart feature.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s return to the `ProductsHandler` function. We will call the `RegisterLinks`
    method on the Isokit router object and specify the CSS query selector of `"#primaryContent
    a"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that when the web page is rendered on the client side, all click
    events for the product item links will be intercepted by the client-side router.
    This will allow us to render the product detail page on the client side itself,
    without having to perform a full page reload.
  prefs: []
  type: TYPE_NORMAL
- en: 'Up to this point, we have  implemented the isomorphic handoff procedure for
    the products listing page. To render the products listing page on the client side,
    click on the Products link in the navigation bar. To render the products listing
    page on the server side, enter the following URL directly in the web browser:
    `http://localhost:8080/products`. *Figure 6.3* depicts the products listing page
    rendered on the client side:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c7a8d2c3-eaeb-4b87-8b59-f24345b695ba.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.3: The products listing page rendered on the client side'
  prefs: []
  type: TYPE_NORMAL
- en: You may also refresh the web page to force the page to be rendered on the server
    side. We can verify that the isomorphic handoff procedure was implemented properly
    by comparing the web page loaded on the client side with the web page that was
    loaded on the server side. Since both web pages are identical, we can determine
    that the isomorphic handoff procedure has been successfully implemented.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing isomorphic handoff for the product detail page
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having successfully implemented the isomorphic handoff procedure on the products
    listing page using the ERDA strategy, let's focus on implementing isomorphic handoff
    for the product detail page.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement the **Encode** step, we first need to identify the data object
    that will represent the state we wish to persist to the client. We identify the
    data object by examining the `ProductDetailHandler` function found in the `handlers/productdetail.go`
    source file. This is the server-side handler function responsible for servicing
    the `/product-detail` route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The product object, a pointer to a `models.Product` struct, is obtained from
    the Redis datastore (shown in bold). This object contains the product data that
    will be displayed on the Product page; therefore, it is the object that we need
    to persist to the client side.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `GetProductDetailEndpoint` function, found in the `endpoints/productdetail.go`
    source file, is the Rest API endpoint responsible for providing the JSON encoded
    `Product` data to the client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Inside the `GetProductDetailEndpoint` function, we obtain the product object
    from the Redis datastore and encode it as JSON formatted data.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have taken care of the **Encode** step, we can implement the next
    three steps on the client side.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement the **Register** step, we add the following line to register the
    `/product-detail` route and its associated handler function in the `client.go`
    source file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The **Decode** and **Attach** steps are carried out by the `ProductDetailHandler`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `ProductDetailHandler` function, we call the `FetchProductDetail`
    function as a goroutine to obtain the product object. The **Decode** step (shown
    in bold) is implemented inside the `FetchProductDetail` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We make an XHR call to the Rest API endpoint to obtain the encoded `Product`
    data. We use a JSON decoder to decode the encoded data back into a `Product` object.
    We send the `Product` object over the `productChannel`, where it is received back
    in the `ProductDetailHandler` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returning to the `ProductDetailHandler` function, we use the product data object
    to populate the product information on the product detail page. We do so by populating
    the Product field of the `templatedata.ProductDetail` object. Again, recall that
    the `templateData` variable is the data object that will be passed into the `Render`
    method of the `env.TemplateSet` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Up to this point, we have fulfilled the third step of the isomorphic handoff
    procedure, which means that we can now render the product detail page on the client
    side. Now, it's time to complete the last step of the procedure, **Attach**, by
    attaching DOM event handlers to their respective UI elements on the rendered web
    page.
  prefs: []
  type: TYPE_NORMAL
- en: 'We call the `InitializeProductDetailPage` function to add the event handler
    necessary to enable user interactivity for the products listing page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Similar to the `InitializeProductsPage` function, we retrieve all the Add To
    Cart buttons on the web page and specify the event handler function, `handleAddToCartButtonClickEvent`,
    that will be called when an Add To Cart button is clicked.
  prefs: []
  type: TYPE_NORMAL
- en: 'Up to this point, we have implemented the isomorphic handoff procedure for
    the product detail page. To render the product detail page on the client side,
    click on a product image found in the the products listing page. To render the
    product detail page on the server-side, enter the URL of a product in the web
    browser. For example, the URL to the product detail page for the swiss army knife
    is `http://localhost:8080/product-detail/swiss-army-knife`. *Figure 6.4* depicts
    the product detail page for the swiss army knife, which was rendered on the client
    side:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/64e2d5c3-b3f8-40bf-8b83-0e87a03a3e66.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.4: The product detail page rendered on the client side'
  prefs: []
  type: TYPE_NORMAL
- en: Again, we can verify that the isomorphic handoff procedure is functioning properly
    by confirming that the web page rendered on the client side is identical to the
    web page rendered on the server side. Since both web pages are identical, we can
    conclude that we have successfully implemented the isomorphic handoff procedure
    for the product detail page.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing isomorphic handoff for the shopping cart
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have implemented isomorphic handoff for the product-related web
    pages, it's time to start implementing IGWEB's shopping cart feature. We'll start
    by designing the Shopping Cart web page.
  prefs: []
  type: TYPE_NORMAL
- en: Designing the shopping cart page
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The design of the Shopping Cart page, as depicted in the wireframe design in
    *Figure 6.5*, is very similar to the product listings page. Each product item
    will contain a thumbnail sized image of the product, the product price, the product
    name, and a brief description of the product, just like the product listings page.
    In addition to these fields, the shopping cart page will have a field to display
    the quantity, that is, the amount of items of a particular product that are in
    the shopping cart, and a Remove From Cart button, that when clicked on, will remove
    the product from the shopping cart:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8142b3e2-4b7b-4c15-95b0-907ace76b234.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.5: The wireframe design depicting the shopping cart page with products
    in the shopping cart'
  prefs: []
  type: TYPE_NORMAL
- en: 'Keep in mind that the first wireframe design covers the scenario, when the
    shopping cart has been populated with items. We must also consider the design
    of the page when the shopping cart is empty. The shopping cart could either be
    empty on the user''s initial visit to the IGWEB website or when the user empties
    the shopping cart entirely. *Figure 6.6* is a wireframe design of the shopping
    cart page, depicting the scenario where the shopping cart is empty:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1e37fbad-adbc-4c02-99b5-dfb451524763.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.6: The wireframe design depicting the shopping cart page when the
    shopping cart is empty'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the design of the shopping cart page locked down, it's time
    to implement the templates to realize the design.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the shopping cart templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will use the shopping cart page template in order to render the shopping
    cart on the server side. Here are the contents of the shopping cart page template,
    as defined in the `shared/templates/shopping_cart_page.tmpl` source file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: As you may have noticed, the shopping cart page template calls a `shopping_cart_content` subtemplate, which
    is responsible for rendering the shopping cart itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the contents of the shopping cart content template, as defined in
    the `shared/templates/shopping_cart_content.tmpl` source file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Using the `if` action, we check to see whether there are any products to display
    in the shopping cart. If there are, we render each shopping cart item, using the
    `range` action. We render the name of the template, its thumbnail preview, and
    its description, along with its quantity. Finally, we render a button to remove
    the product from the shopping cart. Notice that we have embedded a data attribute
    called `data-sku` to include the product's unique `SKU` code along with the button
    element. This value come in handy later, when we make the XHR call to the Rest
    API endpoint responsible for removing a shopping cart item by clicking on this
    button.
  prefs: []
  type: TYPE_NORMAL
- en: If there are no items to display in the shopping cart, the flow of control reaches
    the `else` action. In this scenario, we will display the message that the shopping
    cart is empty.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we will use the end template action to signal the end of the `if-else`
    conditional blocks.
  prefs: []
  type: TYPE_NORMAL
- en: The template data object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The template data object that will be passed to the template renderer will
    be a `templatedata.ShoppingCart` struct (defined in the `shared/templatedata/shoppingcart.go`
    source file):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `PageTitle` field will be used to display the web page title and the `Products`
    field, a slice of `Product` objects, will be used to display the products that
    are currently in the shopping cart.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the templates in place, let's take a look at modeling the shopping
    cart.
  prefs: []
  type: TYPE_NORMAL
- en: Modeling the shopping cart
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `ShoppingCartItem` struct, defined in the `shared/models/shoppingcart.go`
    source file, represents an item in the shopping cart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `ProductSKU` field holds the `SKU` code of the product (the unique code
    used to distinguish a product) and the `Quantity` field holds the quantity of
    that particular product the user wishes to purchase. Each time the user hits the
    Add To Cart button on the products listing or product detail page, the quantity
    value for that particular product will be incremented in the shopping cart.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ShoppingCart` struct, also defined in the `shoppingcart.go` source file,
    represents the shopping cart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `Items` field is a map of items having a key of the `string` type (which
    will be the product `SKU` code), and the value will be a pointer to a `ShoppingCartItem`
    struct.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `NewShoppingCart` function is a constructor function to create a new instance
    of `ShoppingCart`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ItemTotal` method of the `ShoppingCart` type is responsible for returning
    the number of items that are currently in the shopping cart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The `IsEmpty` method of the `ShoppingCart` type is responsible for telling
    us if the shopping cart is empty or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The `AddItem` method of the `ShoppingCart` type is responsible for adding an
    item to the shopping cart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: If a particular product item already exists in the shopping cart, the `Quantity`
    field will be incremented by one, upon each new request to add the product item.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, the `RemoveItem` method of the `ShoppingCart` type is responsible
    for removing all items of a specific product type from the shopping cart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The `UpdateItemQuantity` method of the `ShoppingCart` type is responsible for
    updating the quantity of a specific product in the shopping cart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Shopping cart routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By implementing the `ShoppingCart` type, we now have the business logic in place,
    to drive the shopping cart functionality. Now it's time to register the server-side
    routes that are needed to implement the shopping cart.
  prefs: []
  type: TYPE_NORMAL
- en: 'We register the `/shopping-cart` route along with its associated handler function,
    `ShoppingCartHandler`, inside the `registerRoutes` function, which is found in
    the `igweb.go` source file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The route handler function, `ShoppingCartHandler`, is responsible for generating
    the web page for the shopping cart page on the server side.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also register the following Rest API endpoints:'
  prefs: []
  type: TYPE_NORMAL
- en: Fetching a list of items (`/restapi/get-cart-items`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding an item (`/restapi/add-item-to-cart`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removing an item (`/restapi/remove-item-from-cart`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fetching a list of items
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For fetching a list of items in the shopping cart, we will register the `/restapi/get-cart-items`
    endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This endpoint will be handled by the `GetShoppingCartItemsEndpoint` handler
    function. This endpoint is responsible for encoding the shopping cart as JSON
    encoded data and providing it to the client-side application. Note that we use
    the HTTP `GET` method to call this endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: Adding an item
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For adding an item to the shopping cart, we will register the `/restapi/add-item-to-cart`
    endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This route will be handled by the `AddItemToShoppingCartEndpoint` handler function.
    Note that since we are performing a mutating operation on the web server (adding
    a shopping cart item), we use the HTTP `PUT` method when calling this endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: Removing an item
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For removing an item of a specific product type, and all quantities of it,
    from the shopping cart, we will register the `/restapi/remove-item-from-cart`
    endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This endpoint will be handled by the `RemoveItemFromShoppingCartEndpoint` handler
    function. Again, note that we use the HTTP `DELETE` method when calling this endpoint since
    we are performing a mutating operation on the web server (removing a shopping
    cart item).
  prefs: []
  type: TYPE_NORMAL
- en: The session store
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unlike the product records, which are stored in the Redis database, the items
    a user chooses to place in their shopping cart is transitory, and it's customized
    for individual use. This being the case, it makes much more sense to store the
    state of the shopping cart in a session, rather than in the database.
  prefs: []
  type: TYPE_NORMAL
- en: We will use the Gorilla `sessions` package to create sessions and store data
    to the sessions. We will utilize the `session.NewFileSystemStore` type to save
    the session data to the server's file system.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will add a new field (shown in bold) to the `common.Env` struct (defined
    in the `common/common.go` source file), which will hold the `FileSystemStore`
    instance so that it is accessible throughout the server-side web application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `main` function defined in the `igweb.go` source file, we will make
    a call to the `initializeSessionstore` function and pass in the `env` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The `initializeSessionstore` function is responsible for creating the session
    store on the server side:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: In the `if` conditional, we first check to see whether the designated path where
    the session data will be stored, `/tmp/igweb-sessions`, exists. If the path does
    not exist, we create the folder by calling the `Mkdir` function from the `os`
    package.
  prefs: []
  type: TYPE_NORMAL
- en: We will initialize a new file system session store by calling the `NewFileSystemStore`
    function in the `sessions` package, passing in the path where sessions will be
    saved and the authentication key for the session. We will populate the `Store`
    property of the `env` object with the newly created `FileSystemStore` instance.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the session store in place, let's implement the server-side
    `ShoppingCartHandler` function.
  prefs: []
  type: TYPE_NORMAL
- en: The server-side shopping cart handler function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `ShoppingCartHandler` function, defined in `handlers/shoppingcart.go`,
    is responsible for servicing the `/shopping-cart` route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The main purpose of the server-side shopping cart handler function is to produce
    the output for the shopping cart web page.
  prefs: []
  type: TYPE_NORMAL
- en: Recall that the handler functions for the product-related pages, tapped into
    the Redis datastore to retrieve the list of products. The shopping cart handler,
    on the other hand, taps into the server-side session to get the list of items
    that are in the shopping cart.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will declare the variables for the `templateData` object and the shopping
    cart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve define and initialize the `igwSession` variable of the `gorilla.SessionStore` type,
    which will hold our server-side session:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Recall that we can access the `FileSystemStore` object by accessing the `Store`
    property of the `env` object. We call the `Get` method of the session store object
    passing in the pointer to `http.Request`, `r`, and the name of the session, `"igweb-session"`.
  prefs: []
  type: TYPE_NORMAL
- en: If the session does not exist, a new session named `"igweb-session"` will automatically
    be created for us.
  prefs: []
  type: TYPE_NORMAL
- en: To access values in the session, we use the `Values` property of the `igwSession`
    object, which is a map of keys to values. The keys are strings, and the values
    are of type empty interface, `interface{}`, so that they can hold any type (since
    all types in Go implement the empty interface).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `if` conditional block, we check to see whether a value for the `"shoppingCart"` session
    key exists in the `Values` map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The JSON-encoded value for the shopping cart object is accessed using the `"shoppingCart"`
    key. If the shopping cart exists in the session, we decode the JSON object using
    the `Decode` method of the JSON decoder object. If the JSON object is successfully
    decoded, the decoded object is stored in the `cart` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the shopping cart object from the session, we need to get
    the product information for each item in the shopping cart. We do so by calling
    the `GetProductsInShoppingCart` method of the the datastore object and supplying
    the `cart` variable as an input argument to the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'This function will return the slice of products that are to be displayed on
    the shopping cart page. Notice that we populate the `Products` field of the `templatedata.ShoppingCart`
    object with the slice of products obtained from the datastore:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Since we will utilize this slice of products to render the server-side shopping
    cart template page, the slice of products returned from the `GetProductsInShoppingCart`
    method is the state data that we need to persist to the client-side when implementing
    isomorphic handoff.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the `"shoppingCart"` key did not exist in the session, the flow of control
    reaches the `else` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: In this situation, we set the `Products` field of the `templatedata.ShoppingCart`
    struct to `nil`, to indicate that there are no products in the shopping cart since
    the shopping cart does not exist in the session.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we render the shopping cart page by calling the `Render` method on
    the template set object, passing in the name of the template we wish to render
    (the `shopping_cart_page` template) along with the render parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we have set the `RenderParams` object's `Writer` property to `http.ResponseWriter`,
    `w`, and we have set the `Data` property to the `templateData` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the `GetProductsInShoppingCart` method defined in the
    Redis datastore (found in the `common/datastore/redis.go` source file):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The job of this method is to return a slice of `Product` objects for all the
    products that exist within a shopping cart. The `ShoppingCart` struct simply keeps
    track of a product's type (through its `SKU` code) and the `Quantity` of that
    product in the shopping cart.
  prefs: []
  type: TYPE_NORMAL
- en: We declare a `result` variable, which is a slice of the `Product` objects. We
    loop through each shopping cart item, and we retrieve the `Product` object from
    the `productsMap`, providing the product's `SKU` code as the key. We populate
    the `Quantity` field of the `Product` object and append the `Product` object to
    the `result` slice.
  prefs: []
  type: TYPE_NORMAL
- en: We call the `Sort` method from the sort package passing in the `result` slice.
    Since we have implemented the sort interface for the `Products` type, the `Product`
    objects in the `result` slice will be sorted by price in the ascending order.
    Finally, we return the `result` slice.
  prefs: []
  type: TYPE_NORMAL
- en: Shopping cart endpoints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, while we are finishing up the server-side functionality to implement
    the shopping cart feature, we are also ready to start implementing the isomorphic
    handoff procedure, following the ERDA strategy.
  prefs: []
  type: TYPE_NORMAL
- en: The endpoint to get items in the shopping cart
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's examine the shopping cart's Rest API endpoints, which help service actions
    that the client-side web application is dependent on. Let's start with the endpoint
    function, `GetShoppingCartItemsEndpoint`, which is responsible for getting the
    items in the shopping cart. The **Encode** step, of the isomorphic handoff procedure
    is performed in this endpoint function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the source listing of the `GetShoppingCartItemsEndpoint` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: In this function, we fetch the shopping cart from the session. If we are able
    to successfully fetch the shopping cart from the session, we use a JSON encoder
    to encode the `ShoppingCart` object and write it using `http.ResponseWriter`,
    `w`.
  prefs: []
  type: TYPE_NORMAL
- en: If the shopping cart does not exist in the session, then we simply JSON encode
    the value of `nil` (which is equivalent to a JavaScript `null` on the client side)
    and write it out in the response, using `http.ResponseWriter`, `w`.
  prefs: []
  type: TYPE_NORMAL
- en: With this code in place, we have fulfilled the Encode step in the isomorphic
    handoff procedure.
  prefs: []
  type: TYPE_NORMAL
- en: The endpoint to add items to the shopping cart
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We declared a `m` variable (shown in bold), of the `map[string]string` type,
    in `AddItemToShoppingCartEndpoint`, which is the endpoint function that is responsible
    for adding a new item to the shopping cart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: We use a JSON decoder to decode the request body, which will contain a JSON
    encoded map sent from the client. The map will contain the `SKU` value of the
    product to add to the shopping cart, given the `"productSKU"` key.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will check to see whether the shopping cart exists in the session. If it
    does, we will decode the shopping cart JSON data back into a `ShoppingCart` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'If the shopping cart doesn''t exist, flow of control reaches the `else` block,
    and we will create a new shopping cart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'We will then make a call to the `AddItem` method of the `ShoppingCart` object
    to add the product item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: To add an item to our shopping cart, we simply have to provide the product's
    `SKU` value, which we can obtain from the `m` map variable by accessing the value
    that exists in the map for the `productSKU` key.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will encode the cart object into its JSON representation and save it into
    the session, with the session key `"shoppingCart"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: We then write back the response, `"OK"`, to the client, to indicate that the
    operation to add a new item to the cart was performed successfully.
  prefs: []
  type: TYPE_NORMAL
- en: The endpoint to remove items from the shopping cart
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here''s the source listing of `RemoveItemFromShoppingCartEndpoint`, the endpoint
    that is responsible for removing all items of a specific product from the shopping
    cart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Remember that we can have multiple quantities for a given product. In the current
    shopping cart implementation, if the user clicks on the Remove From Cart button,
    the given product (and all quantities of it) are removed from the shopping cart.
  prefs: []
  type: TYPE_NORMAL
- en: We start out by fetching the JSON encoded shopping cart data from the session.
    If it exists, we decode the JSON object into a new `ShoppingCart` object. If the
    shopping cart does not exist in the session, we simply create a new shopping cart.
  prefs: []
  type: TYPE_NORMAL
- en: We range through the items found in the shopping cart, and if we are able to
    find a product in the cart containing the same product `SKU` code supplied in
    the `m` map variable that was obtained from the client-side web application, we
    will remove the element from the shopping cart object's `Items` map by calling
    the built-in `delete` function (shown in bold). Finally, we will write out a JSON
    encoded response to the client that the operation was successfully completed.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our server-side endpoints in place, it's time to take a look
    at the functionality needed on the client side to implement the final pieces of
    the shopping cart feature.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the shopping cart functionality on the client side
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To fulfill the **Register** step of the ERDA strategy, we will register the
    `/shopping-cart`  route and its associated handler function, `ShoppingCartHandler`,
    inside the `registerRoutes` function found in the `client/client.go` source file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Remember that this route will kick-in when a user access the shopping cart by
    clicking on the shopping cart icon in the navigation bar. Upon clicking the shopping
    cart icon, the `ShoppingCartHandler` function will be called.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the `ShoppingCartHandler` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The main purpose of this function is to call the `renderShoppingCartItems` function
    to render the shopping cart on the client side. We have consolidated the logic
    to render the shopping cart and its contents in the `renderShoppingCartItems`
    function so that the shopping cart page can be re-rendered as the user removes
    items from the shopping cart.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering the shopping cart
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `renderShoppingCartItems` function is responsible for conducting the last
    two steps of the ERDA strategy, the **Decode** and **Attach** steps. Here''s the
    source listing of the `renderShoppingCartItems` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: In this function, we create a new channel called `productsChannel`, which is
    a channel that we'll use to send and receive a slice of products over. We call
    the `fetchProductsInShoppingCart` function as a goroutine and provide `productsChannel`
    as an input argument to the function. This function is responsible for fetching
    the product items in the shopping cart from the server by performing an XHR call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the source listing for the `fetchProductsInShoppingCart` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: In this function, we simply make an XHR call to the Rest API endpoint, `/restapi/get-cart-items`,
    which is responsible for returning the JSON-encoded data that represents the slice
    of products. We use a JSON decoder to decode the encoded slice of products into
    the `products` variable.  Finally, we send the `products` variable over `productsChannel`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s return to the `renderShoppingCartItems` function and receive the slice
    of products from the `productsChannel`, and then, we will set the `Products` property
    of the `templateData` object with the received products:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'We will then render the shopping cart template on the client side:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: At this point, we have fulfilled the **Decode** step of the ERDA strategy.
  prefs: []
  type: TYPE_NORMAL
- en: To fulfill the **Attach** step of the ERDA strategy, we will make a call to
    the `InitializeShoppingCartEventHandlers` function to attach any needed event
    listeners to the shopping cart web page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the source listing of the `InitializeShoppingCartEventHandlers` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: This function is responsible for attaching a click event on all the Remove From
    Cart buttons that are found in each product container listed on the shopping cart
    web page. The event handler function that is called when the Remove From Cart
    button is clicked, is the `handleRemoveFromCartButtonClickEvent` function.
  prefs: []
  type: TYPE_NORMAL
- en: We have now fulfilled, the fourth and last step of the ERDA strategy, by attaching
    event listeners to the Remove From Cart buttons on the shopping cart web page.
    The implementation of isomorphic handoff for the shopping cart feature is complete.
  prefs: []
  type: TYPE_NORMAL
- en: Removing an item from the shopping cart
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s take a look at the `handleRemoveFromCartButtonClickEvent` function,
    which gets called when the Remove From Cart button is clicked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: In this function, we obtain the product `SKU` code from the event target element's
    `data-sku` attribute. We then call the `removeFromCart` function as a goroutine,
    passing in the `env` object and `productSKU`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the source listing of the `removeFromCart` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: We create a new map, `m`, in the `removeFromCart` function, which is used to
    house `productSKU`. We can access the product's `SKU` value from the  `m` map by
    providing the `"productSKU"` key. We have intended to send this map to the web
    server through the request body. The reason that we have chosen the `map` type,
    as opposed to simply sending the product's `SKU` string value, is that we want
    to make our solution extensible. In the future, if there is any additional information
    that should be sent to the server, we can include that value as part of an additional
    key-value pair in the map.
  prefs: []
  type: TYPE_NORMAL
- en: We encode the map into its JSON representation and make an XHR call to the web
    server, sending the map JSON data. Finally, we make a call to the `renderShoppingCartItems`
    function to render the shopping cart items. Remember that by calling this function,
    we will be performing an XHR call to get the latest products in the shopping cart
    (which represents the current state of the shopping cart). This ensures that we
    will have the most up-to-date state of the shopping cart, since again, we are
    using the server-side session (where the shopping cart state is stored) as our
    single source of truth.
  prefs: []
  type: TYPE_NORMAL
- en: Adding an item to the shopping cart
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The functionality for the Add To Cart button is implemented in a similar manner.
    Recall that on the product-related pages, if any Add To Cart button is clicked,
    the `handleAddToCarButton` function is called. Here is the source listing of the
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: In a manner similar to the `handleRemoveFromCartButtonClickEvent` function,
    inside the `handleAddToCart` function, we obtain the product's `SKU` code from
    the event target element by getting the data attribute with the `“data-sku”` key.
    We then call the `addToCart` function as a goroutine and supply `productSKU` as
    an input argument to the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the source listing of the `addToCart` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Inside the `addToCart` function, we make an XHR call to the Rest API endpoint
    on the web server that is responsible for adding an item to the cart. Prior to
    making the XHR call, we create a map containing `productSKU`, and then we encode
    the map into its JSON representation. We send the JSON data using an XHR call
    to the server endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: We can now display the shopping cart on the client side, and we can also accommodate
    the user interactions with the shopping cart, notably adding a product to the
    shopping cart and removing a product from the shopping cart.
  prefs: []
  type: TYPE_NORMAL
- en: The shopping cart implementation that was covered in this chapter is meant for
    illustration purposes only. It is up to the reader to implement further functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Verifying the shopping cart functionality
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now it's time to verify that the state of the shopping cart is maintained from
    the server to the client, as the user adds and removes items from the shopping
    cart.
  prefs: []
  type: TYPE_NORMAL
- en: Verifying that isomorphic handoff was successfully implemented is straightforward.
    We simply need to verify that the server-side generated shopping cart page is
    identical to the client-side generated shopping cart page. By clicking on the
    shopping cart icon, we can see the client-side generated web page. By clicking
    on the refresh button while on the shopping cart page, we can see the server-side
    generated web page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting out, there are no items placed in the shopping cart. *Figure 6.7*
    is a screenshot depicting the shopping cart in its empty state:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ed44a1f1-4a86-4597-9bc5-0d161404ba33.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.7: The shopping cart page when the shopping cart is empty'
  prefs: []
  type: TYPE_NORMAL
- en: The shopping cart page rendered on the client side matches the page rendered
    on the server side, indicating that the empty state of the shopping cart is maintained
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s visit the product listings page by clicking on the Products link
    on the navigation bar. Let''s add a few items to the shopping cart by clicking
    on the Add To Cart button. Let''s click on the shopping cart icon in the top bar
    of the website to return to the shopping cart page. *Figure 6.8* is a screenshot
    depicting the shopping cart with some products added:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/23dbfb75-e299-4ca5-8a6f-83f747859260.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.8: The shopping cart page with some products in the shopping cart'
  prefs: []
  type: TYPE_NORMAL
- en: After checking that the shopping cart page rendered on the client side matches
    the page rendered on the server side, we can determine that the state of the shopping
    cart has been maintained successfully.
  prefs: []
  type: TYPE_NORMAL
- en: Now remove all the items from the shopping cart by clicking on the Remove From
    Cart button on each product. Once the shopping cart is empty, we can perform the
    same verification step of checking the page rendered on the client side with the
    page rendered on the server side to determine that the shopping cart state is
    successfully maintained.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we can acknowledge that the isomorphic handoff procedure has
    been implemented successfully for the shopping cart feature.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that as we add items to the shopping cart, a notification
    is displayed on the lower right-hand side of the screen, as displayed in *Figure
    6.9*. Notice that the notification is displayed at the lower right-hand side of
    the web page, and it indicates that the product has been successfully added to
    the shopping cart:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2636829e-fbcb-4a38-b257-db6f8a6da20b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.9: A notification appears on the page''s lower right-hand side when
    an item has been added to the shopping cart'
  prefs: []
  type: TYPE_NORMAL
- en: Note that similar notifications also appear when items are removed from the
    shopping cart. We utilized a cog, a reusable component, to generate this notification.
    We will cover the implementation of the cog responsible for generating these notifications
    in [Chapter 9](cbb6c046-c40f-4681-a25d-9b979614b2cf.xhtml), *Cogs – Reusable Components*.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we introduced you to *isomorphic handoff*, the means by which
    the server passes off state to the client. This is a significant procedure, that
    allows the client to pick up where the server left off in an isomorphic web application.
    We demonstrated the ERDA strategy to implement isomorphic handoff for the product-related
    web pages as well as the shopping cart web page. While implementing the shopping
    cart feature, we created a server-side session store, which acted as the source
    of truth for the current state of the user's shopping cart. We implemented server-side
    endpoints to implement the functionality to get items from the shopping cart,
    add items to the shopping cart, and remove items from the shopping cart. Finally,
    we verified that isomorphic handoff was successfully implemented by confirming
    that the web page rendered on the client side was identical to the the web page
    rendered on the server side.
  prefs: []
  type: TYPE_NORMAL
- en: We also relied on sources of truth on the server side to maintain state with
    the client. For the product-related pages, the source of truth was the Redis datastore,
    and for the shopping cart page, the single source of truth was the server-side
    session store. In [Chapter 7](a9dcc0d7-ecf7-4ad0-b879-0a596ab4594e.xhtml), *The
    Isomorphic Web Form*, we'll consider how to handle situations that go beyond basic
    user interactions. You'll learn how to accept user generated data from the client
    side, submitted through an isomorphic web form. You will learn how to validate
    and process the data submitted by the user, by implementing the contact form on
    IGWEB's Contact web page.
  prefs: []
  type: TYPE_NORMAL
