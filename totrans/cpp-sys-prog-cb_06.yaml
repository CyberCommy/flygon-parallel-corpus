- en: Pipes, First-In First-Out (FIFO), Message Queues, and Shared Memory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Communication between processes is an important part of software systems, and
    choosing the appropriate communication technique is not a simple task. One important
    distinction that developers should keep in mind when making a choice is whether
    processes are going to run on the same machine or not. This chapter focuses on
    the first category, where you'll learn how to develop **interprocess communication** (**IPC**)
    solutions based on pipes, **First-In First-Out** (**FIFO**), message queues, and
    shared memory. It'll start with an overview of the four types of IPC in the first
    recipe, their characteristics, and the differences between the types. Then, a
    recipe for each type will provide hands-on information needed to apply them to
    your daily work. This chapter does not contain any C++-specific solutions, in
    order to let you familiarize yourself with the Linux native mechanisms.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Learning the different types of IPC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning how to use the oldest form of IPC—pipes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning how to use FIFO
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning how to use message queues
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning how to use shared memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to let you try the programs immediately, we've set up a Docker image that
    has all the tools and libraries we'll need throughout the book. This is based
    on Ubuntu 19.04.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to set it up, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Download and install Docker Engine from [www.docker.com](http://www.docker.com).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Pull the image from Docker Hub by running the following command: `docker pull
    kasperondocker/system_programming_cookbook:latest`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The image should now be available. Type in the following command to view the
    image: `docker images`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You should have at least this image now: `kasperondocker/system_programming_cookbook`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the Docker image with an interactive shell, with the help of the following
    command: `docker run -it --cap-add sys_ptrace kasperondocker/system_programming_cookbook:latest /bin/bash`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The shell on the running container is now available. Type in `root@39a5a8934370/#
    cd /BOOK/` to get all the programs developed, by chapters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `--cap-add sys_ptrace` argument is needed to allow the **GNU Project Debugger**
    (**GDB**) in the Docker container to set breakpoints, which, by default, Docker
    does not allow.
  prefs: []
  type: TYPE_NORMAL
- en: '**Disclaimer**: The C++20 standard has been approved (that is, technically
    finalized) by WG21 in a meeting in Prague at the end of February. This means that
    the GCC compiler version that this book uses, 8.3.0, does not include (or has
    very, very limited support for) the new and cool C++20 features. For this reason,
    the Docker image does not include the C++20 recipe code. GCC keeps the development
    of the newest features in branches (you have to use appropriate flags for that,
    for example, `-std=c++2a`); therefore, you are encouraged to experiment with them
    by yourself. So, clone and explore the GCC contracts and module branches and have
    fun.'
  prefs: []
  type: TYPE_NORMAL
- en: Learning the different types of IPC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe's goal is to provide guidance among the different IPC solutions
    typically used with processes running on the same machine. It'll provide an overview
    of the main characteristics seen from the developer's point of view (your point
    of view!), explaining how they are different from each other.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following table shows the four types of IPC always available on a Linux
    machine, where the columns represent what we believe are the distinctive factors
    that a developer should consider when making design choices:'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | ****Processes'' r******elation required?** | **Synchronization required?**
    | **Communication type** | **Scope** | **Kernel involved?** |'
  prefs: []
  type: TYPE_TB
- en: '| **Pipe** | Yes | Generally no | Half-duplex | Same machine | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| **FIFO** | No | Generally no | Half-duplex | Typically same machine | Yes
    |'
  prefs: []
  type: TYPE_TB
- en: '| **Message queue** | No | Generally no | Half-duplex | Same machine | Yes
    |'
  prefs: []
  type: TYPE_TB
- en: '| **Shared memory** | No | Yes | Half-duplex | Same machine | Yes |'
  prefs: []
  type: TYPE_TB
- en: 'The columns of the table have the following descriptions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Processes'' relation required?**: This indicates whether a relation between
    processes (for example, parent-child) is required or not to implement the specific
    IPC.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Synchronization required?**: This indicates whether you have to take into
    consideration any form of synchronization between processes (for example, mutex,
    semaphores, and so on; see [Chapter 5](5578f31b-bd1e-4cb9-9ab5-da18a155f28d.xhtml),
    *Using Mutexes, Semaphores, and Condition Variables*) or not.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Communication type**: A communication between two or more entities can be
    half-duplex (the closest analogy is the walkie-talkie, where just one individual
    can talk at any given time) or full-duplex (the telephone, for example, whereby
    two people can talk simultaneously). This can have a profound impact on the solution
    designed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scope**: This indicates if the solution can be applied to a broader scope,
    in terms of IPC among processes on different machines.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Kernel involved?**: This warns you about the kernel involvement in the communication
    process. The *How it works...* section will explain why this is important.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next section, we'll analyze row by row the single characteristics highlighted
    in the table.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first IPC mechanism in the list is a **pipe**. A pipe requires a relation
    between two processes (parent-child, for example) for it to work. This relation
    is needed in order to make the pipe **visible** by both the processes (as opposed
    to FIFO). It is like a variable that must be visible by a method in order to be
    usable. In the pipe recipe, we'll see how this works technically.
  prefs: []
  type: TYPE_NORMAL
- en: 'The communication type is half-duplex: the data flows from process *A* to process
    *B,* and for this reason, there is no need for synchronization. In order to achieve
    a full-duplex communication type between two processes, two pipes must be used.
    For the same reason that two processes must have a relationship in order to be
    able to use a pipe, a pipe cannot be used as a communication mechanism between
    processes on two different machines. The Linux kernel is involved in the communication
    as the data is copied to the kernel, which is then further copied to the receiver
    process.'
  prefs: []
  type: TYPE_NORMAL
- en: The second IPC mechanism in the table is the **FIFO** (or **named pipe**). It
    is a named pipe as it requires a pathname to be created, and indeed, it is a special
    kind of a file. This makes the FIFO usable by any processes even without a relationship
    between them. All they need is the path of the FIFO (likewise, a filename) that
    all the process will use. Synchronization is not required in this case either.
    We have to be careful, though, as there are cases where synchronization is required,
    as the `man page` specifies.
  prefs: []
  type: TYPE_NORMAL
- en: POSIX.1 says that writes ([http://man7.org/linux/man-pages/man2/write.2.html](http://man7.org/linux/man-pages/man2/write.2.html))
    of less than `pipe_BUF` bytes must be atomic (that is, the output data is written
    to the pipe as a contiguous sequence). Writes of more than `pipe_BUF` bytes may
    be nonatomic (that is, the kernel may interleave the data with data written by
    other processes). POSIX.1 requires `pipe_BUF` to be at least 512 bytes. (On Linux,
    `pipe_BUF` is 4,096 bytes.) The precise semantics depends on whether the file
    descriptor is nonblocking (`O_NONBLOCK`); whether there are multiple writers to
    the pipe; and on *n*, the number of bytes to be written.
  prefs: []
  type: TYPE_NORMAL
- en: The general rule is that, if you have any doubts about how much data exchange
    should happen between the processes, always provide a synchronization mechanism
    (for example, mutex, semaphores, and many others). A FIFO (likewise, a pipe) provides
    a half-duplex communication mechanism unless two FIFOs are provided for each process
    (one reader and one writer for each process); in that case, it would make it a
    full-duplex communication. FIFOs are typically used for IPC between processes
    on the same machine but, as it is based on files, if the file is visible by other
    machines, a FIFO could potentially be used for IPC between processes on different
    machines. Even in this case, the kernel is involved in the IPC, with data copied
    from kernel space to the user space of the processes.
  prefs: []
  type: TYPE_NORMAL
- en: A **message queue** is a linked list of messages stored in the kernel. This
    definition already contains a piece of information; this is a communication mechanism
    provided by the kernel, and again, it means that the data is copied back and forth
    from/to the kernel. Message queues do not require any relation between processes;
    they have to share a key to be able to access the same queue. The Linux kernel
    guarantees the atomicity of the operations on the queue if the message is smaller
    than or equal to `pipe_BUF`. In that case, a synchronization mechanism is required.
    A message queue cannot be used outside the scope of a machine.
  prefs: []
  type: TYPE_NORMAL
- en: The last IPC mechanism in the table is **shared memory**. This is the fastest
    form of IPC. This comes with a cost, in the sense that the processes using shared
    memory should use a form of synchronization (for example, mutexes or semaphores),
    as the `man page` suggests (`man shm_overview`).
  prefs: []
  type: TYPE_NORMAL
- en: Any time there is a critical section to protect, processes must synchronize
    the access using a mechanism we've seen in [Chapter 5](5578f31b-bd1e-4cb9-9ab5-da18a155f28d.xhtml), *Using
    Mutexes, Semaphores, and Condition Variables.*
  prefs: []
  type: TYPE_NORMAL
- en: Processes must be running on the same machine to use the same shared memory,
    and it is identified with a key, likewise for message queues. As the shared memory
    resides in the kernel space, data is copied from the kernel space to the processes
    that read and delete it.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: These four forms of IPC are the ones originally developed on the Unix System
    V and then reimplemented in the more modern POSIX standard, which Linux supports.
    There are cases where the processes are not on the same machine, and in those
    cases, we need to use other mechanisms such as sockets, which we'll see in the
    next chapter. Of course, a socket has wider applicability as it puts in communication
    processes, regardless of the position on the network.
  prefs: []
  type: TYPE_NORMAL
- en: 'This generality, so to speak, comes at a cost: they are slower than the mechanisms
    described in this recipe. So, as developers, this is a factor that must be taken
    into consideration when making a design choice.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Chapter 5](5578f31b-bd1e-4cb9-9ab5-da18a155f28d.xhtml)*, Using Mutexes, Semaphores,
    and Condition Variables*: About the synchronization mechanisms you can use.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Chapter 7](edc01b79-661b-4ecd-88f2-a6501eeaa085.xhtml)*, Network Programming*:
    To complement this chapter with the notion of sockets (connection-oriented and
    connectionless).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning how to use the oldest form of IPC – pipes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, you learned how to choose an IPC based on some key factors.
    It's now time to get hands-on with the four communication types, and this recipe
    focuses on pipes. In this recipe, you'll learn how to use pipes to make two processes
    communicating full-duplex by using two pipes. We'll not use any form of synchronization
    as generally, it is not required. In the *How it works...* section, we'll see
    why and when is it not required.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we''ll develop a program that will create two processes, with
    the unique goal of sending a message to each other. With a pipe, as we''ve seen,
    the data flows in one direction. To make a bidirectional communication, and to
    simulate the general case, we will make use of two pipes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We instantiate the two messages to send, and their size, which we''ll need
    later:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we move on to the initialization section. We need to instantiate the
    space for the message received, both the `childToParent` and `parentToChild` pipes,
    and the **process identifier** (**PID**) that we use to track the child:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s see the child section. This section has two parts: the first, where
    the child sends the `msg1` message to the parent; and the second, where the child
    receives the  `msg2` message from the parent:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, let''s see the parent code. It has two sections: one to receive
    the message from the child, and the second to reply to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We've implemented programmatically what we learned in [Chapter 1](c3cda38c-220e-4aae-89c6-c381df46daec.xhtml), *Getting
    Started with System Programming*, for the shell (see the *Learning the Linux fundamentals
    – shell* recipe). These steps are detailed in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the first step, we just defined `msg1` and `msg2` to be used by the two processes
    and defined `MSGSIZE` for the message length needed to read them.
  prefs: []
  type: TYPE_NORMAL
- en: The second step essentially defines the two pipes, `childToParent` and `parentToChild`,
    as an array of two integers each. They are used by the `pipe` system call to create
    two communication buffers, which the processes can access through the `childToParent[0]`
    and `childToParent[1]` file descriptors. The message is written to `childToParent[1]`
    and read from `childToParent[0]` with the FIFO policy. In order to avoid a situation
    where buffers are not initialized, this step sets the pointer of `inbuf1` and `inbuf2`
    to `0`.
  prefs: []
  type: TYPE_NORMAL
- en: The third step deals with the child's code. It writes to `childToParent[1]`,
    then reads from `parentToChild[0]`. Writes to `childToParentp[1]` by the child
    process can be read on `childToParent[0]` by the parent process. The `read` and
    `write` system call causes the process to step in kernel mode and save the input
    data temporarily in kernel space until the second process reads it. One rule to
    follow is that the unused end of the pipes has to be closed. In our case, we write
    to `childToParent[1]`; so, we close the `read` end of the pipe, `childToParent[0]`,
    and once read, we close the `write` end as this is not used.
  prefs: []
  type: TYPE_NORMAL
- en: The fourth step, pretty similar to the third, has the symmetric code to the
    child code. It reads on the `childToParent[0]` pipe and writes on `parentToChild[1]`,
    following the same rule of closing the end of the pipe not used.
  prefs: []
  type: TYPE_NORMAL
- en: From the code analyzed, the reason why pipes are not usable by processes that
    are not ancestors should now be clear: `childToParent` and `parentToChild` file
    descriptors must be visible to parents and children at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we compile the code with `gcc pipe.c` in the Docker container''s `/BOOK/Chapter06/`
    folder and run it, the output would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/91aaa497-4f77-4015-8784-f09f8d31dffd.png)'
  prefs: []
  type: TYPE_IMG
- en: This shows that the parent and the child send and receive the two messages correctly.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the vast majority of use cases, pipes are intended to be used with small
    amounts of data, but there might be scenarios where a larger amount is needed.
    The standard POSIX, to which we adhere in this chapter, says that a `write` of
    less than `pipe_BUF` bytes must be atomic. It furthermore dictates that `pipe_BUF`
    must be at least 512 bytes (on Linux, it is 4 KB); otherwise, you have to take
    care of the synchronization at the user level by using mechanisms such as semaphores
    and mutexes.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Chapter 1](c3cda38c-220e-4aae-89c6-c381df46daec.xhtml), *Getting Started with
    System Programming*, shows the pipe concept from the shell point of view.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Chapter 5](5578f31b-bd1e-4cb9-9ab5-da18a155f28d.xhtml), *Using Mutexes, Semaphores,
    and Condition Variables* has the tools necessary to add the synchronization, in
    case the data to send and receive is larger than `pipe_BUF`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning how to use FIFO
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The pipes we've seen in the previous recipe are temporary, in the sense that
    when no process has them open, they cease to exist. **FIFOs** (also called **named
    pipes**) are different; they are special pipes that exist as a special file on
    the filesystem. In principle, any process, assuming it has the right permissions,
    can access a FIFO. This last one is the FIFO-distinctive characteristic. Using
    files allows us to program a more general communication mechanism to put processes
    in communication, even without an ancestor relationship; or, in other words, we
    can use FIFO to get any two files to communicate. In this recipe, you'll learn
    how to program FIFO.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we''ll develop a very primitive chat program based on FIFOs,
    resulting in two different programs that at runtime will allow two users to chat:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a file called  `fifo_chat_user1.c` and add the includes that
    we need later, and the `MAX_LENGTH` define to determine the max length of messages
    the two users can exchange:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, start with `main`. Here, we need to define the `fd` file descriptor to
    open the file; the path in which we intend to store the file; the two strings
    we''ll use to store the `msgReceived` and `msgToSend` messages; and, finally, 
    the  `mkfifo` system call to create the FIFO in the defined path:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We now need an infinite loop to `write` and `read` continuously. We do this
    by creating two sections: in the `write` section, we open the `fifoChat` file
    in write mode, get the message from the user with `fgets`, and write `msgToSend`
    to the file, represented by the `fd` file descriptor. In the reader''s section,
    we open the file in reading mode and read the content of the file with the `read` method,
    print the output, and close `fd`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The second program is very similar. The only difference is the `while` loop,
    which is the other way around. Here, we have the `read` section, and then, the
    `write` section. You can copy the `fifo_chat_user1.c` file into `fifo_chat_user2.c`
    and modify it, like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Although this is not the most interactive chat you'll find around, it's definitely
    useful to experiment with FIFO. In the next section, we'll analyze the steps seen
    in this section.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s first compile and run the two programs. In this case, we want to give
    a different name to the executables, so as to distinguish them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates two executables: `chatUser1` and `chatUser2`. Let''s run them
    in two separate Terminals, and let''s chat:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7359f0c3-5c8e-4a74-95fa-74763e739dbf.png)'
  prefs: []
  type: TYPE_IMG
- en: In *step 1*, we essentially defined `MAX_LENGTH` to the `128` bytes and added
    the defines we need.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *step 2*, we created the `mkfifo` FIFO at the path specified by `fifoChat`,
    which points to the `/tmp/chat` file, with permissions `6` (read and write for
    the user), `0` (no read, no write, no execution for the group the user belongs
    to), and `0` (no read, no write, no execution for others). These settings can
    be checked once `mkfifo` is called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In *step 3*, we opened the FIFO with the `open` method. It's worth mentioning
    that `open` is the same method used to open regular files, and on the descriptor
    returned, we can call `read` and `write`, as we would do on normal files. In this
    step, we made an infinite loop to allow the user to chat as long as they want.
    The `read` and `write` sections, as you can see, are swapped in *step 4* to allow
    the second user to read if the first is writing, and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: A FIFO is managed internally by the kernel with the FIFO policy. Every time
    we `write` or `read` data from/to the FIFO, the data is passed from/to the kernel.
    You should keep this aspect in mind. The message passes from the `chat1` executable,
    then, in the kernel space, and back in the user space again when the `chat2` program
    calls the `read` method.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It should be clear so far that a FIFO is a special pipe. This means the same
    limitation we have for pipes applies to FIFO too. For example, there is no need
    for synchronization unless the amount of data sent exceeds the `pipe_BUF` limit,
    which the standard POSIX defines as 512 bytes, and Linux sets to 4 KB.
  prefs: []
  type: TYPE_NORMAL
- en: Another aspect to highlight is that a named pipe (FIFO) can be used in *N* to
    *M* communication types (that is, multiple readers and multiple writers). The
    kernel guarantees the atomicity of the operations (`read` and `write` calls) if
    the preceding conditions are met.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Chapter 3](c27d5a31-a4f2-4925-b883-fa244edeb6ae.xhtml), *Dealing with Processes
    and Threads*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Chapter 5](5578f31b-bd1e-4cb9-9ab5-da18a155f28d.xhtml), *Using Mutexes, Semaphores,
    and Condition Variables*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning how to use message queues
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another mechanism directly supported by POSIX-compliant operating systems (and
    then, the Linux kernel) is a message queue. A message queue, in its essence, is
    a linked list of messages stored in the kernel, where each queue is identified
    by an ID. In this recipe, we'll rewrite the chat program using a message queue,
    highlighting the key pros and cons.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we''ll rewrite the chat program from the *Learning how to
    use FIFO* recipe. This will allow you to see, hands-on, similarities and differences
    between FIFO and a message queue:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file called `mq_chat_user_1.c`, and add the following includes
    and defines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `main` method, let''s now define the two message queue descriptors (`user1Desc`
    and `user2Desc`) needed to store the result from the `mq_open` method later. We
    have to define and initialize the `mq_attr` struct to store the configuration
    of the message queues we''ll create:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We can open the two `/user1` and `/user2` message queues:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The central part of the program is the loop to send and receive the messages
    from the two users. To do this, we have to:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Send a message to the user 2 with the `mq_send` method, using the `user1Desc` message
    queue descriptor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Receive an eventual message that the user 2 sent us with `mq_receive`, using
    the `user2Desc` message queue descriptor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We need another program that would reply to user 1\. This program is very similar;
    the only difference is that it sends messages on `user2Desc` (which is open in
    write mode this time) and reads from `user1Desc` (which is open in read mode).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s run the program now. We need to compile the `mq_chat_user_1.c` and `mq_chat_user_2.c` programs
    by typing the following two commands in the shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We're compiling and linking the programs, and generating `user1` and `user2` executables.
    We've added `-lrt` (which is the POSIX.1b Realtime Extensions library) as we need
    to include the POSIX message queue implementation. Remember that with `-l`, you're
    asking the compiler to consider a specific library for the linker phase. In the
    next section, we'll see the output, and analyze all the steps seen previously.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By running the `./user1` and `./user2` executables, we''d have the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5838d556-e1d8-4538-a817-e7b1fcbe6004.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s have a look at the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 1**: We need `#include <stdio.h>` for the user input/output, `#include
    <string.h>` to get the length of string through `strlen`, and `#include <mqueue.h>`
    to have access to the message queue interfaces. In this step, we''ve defined the
    max number of messages in the queue (`10`) and the max size of a message in the
    queue (`256` bytes).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Step 2**: In the `main` method of the program, we''ve defined the two message
    queue descriptors (`user1Desc` and `user2Desc`) to keep a reference to message
    queues; the two message arrays (`message` and `message2`) to store the messages
    to send and receive between the two users; and finally, we''ve defined and initialized
    the `struct mq_attr` structure, used to initialize the message queues we''ll use
    in the next step.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Step 3**: In this step, we''ve opened the two message queues. These are `/user1`
    and `/user2`, and they are located in `/dev/mqueue`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '`mq_chat_user_1.c` opens the `/user1` message queue in write-only mode and
    creates it if it''s not present. It also opens `/user2` in read-only mode and
    creates it if it''s not present. It should be clear that if the current process
    doesn''t have access rights to the message queue (which we open with `660`), `mq_open`
    will fail.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 4**: This step contains the main logic of our program. It has an infinite
    loop, which sends a message from user 1 to user 2 and receives from user 2 to
    user 1\. The method used to send messages is `mq_send`. It needs the message queue
    descriptor, the message to send, its length (`+1`, as we need to include the terminator),
    and the message priority (which we didn''t use in this case). `mq_send` (see `man mq_send` for
    more info) blocks if there is no space in the queue until enough becomes available.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After the send, we call the `mq_receive` method (see `man mq_receive` for more
    info) to get an eventual message from the user 2\. It needs the message queue
    descriptor, an array that will contain the message, the max size we can receive,
    and the priority. Keep in mind that `mq_receive` blocks if there are no messages
    in the queue.
  prefs: []
  type: TYPE_NORMAL
- en: For more info, see the `man mq_receive` page.
  prefs: []
  type: TYPE_NORMAL
- en: 'As send and receive are core concepts, let''s analyze them a little deeper
    with a schema:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6f49dbd8-e83c-495b-b7b7-fb2546928205.png)'
  prefs: []
  type: TYPE_IMG
- en: '**(1)** In this case, the user 1 process calls `mq_send`. The Linux kernel
    makes a copy of the message to send from the user space to the kernel space. The
    same happens in case **(3)**.'
  prefs: []
  type: TYPE_NORMAL
- en: '**(2)** When the user 2 process calls `mq_receive` on the same message queue
    (`user1Desc`), the Linux kernel makes a copy of the message from the kernel space
    to the user space, copying the data in the `message2` buffer. The same happens
    in case **(4)**.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There might be cases where you may need to get the messages from the queue based
    on priority, which we didn't use in this case. Can you modify this recipe's program
    to include the priority? What do you have to modify?
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed that we used the `perror` method in this recipe. The `perror`
    method prints in the standard output the last error (`errno`), which occurs in
    a descriptive format. The advantage for the developer is that you don't have to
    explicitly get the `errno` value and translate it to a string; it is done automatically
    for you.
  prefs: []
  type: TYPE_NORMAL
- en: The same concept of atomicity that we described for pipes and FIFOs is valid
    for message queues. The delivery of a message is guaranteed to be atomic if the
    message is smaller than `pipe_BUF`. Otherwise, a synchronization mechanism must
    be provided by the developer.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Recipes in [Chapter 3](c27d5a31-a4f2-4925-b883-fa244edeb6ae.xhtml), *Dealing
    with Processes and Threads* (about threading) and [Chapter 5](5578f31b-bd1e-4cb9-9ab5-da18a155f28d.xhtml), *Using
    Mutexes, Semaphores, and Condition Variables* (about synchronization). As usual,
    `man pages` offer a great source of information, and a suggested starting point
    is `man  mq_overview`.
  prefs: []
  type: TYPE_NORMAL
- en: Learning how to use shared memory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In all the IPC mechanisms we've seen so far, the kernel plays an active part
    in the communication between processes, as we've learned. The information indeed
    flows through from the Linux kernel to the processes, and vice versa. In this
    recipe, we'll learn the fastest form of interprocess communication that does not
    require the kernel as the mediator between processes. As usual, although the System
    V APIs are widely available, we'll be using the newest, simpler, and better-designed
    POSIX APIs. We'll rewrite our chat application using the shared memory, digging
    into it in greater detail.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we''ll focus on developing a simple chat application by using
    the POSIX shared memory APIs. As the kernel does not take part in the communication
    process (directly), we need to provide a synchronization mechanism to protect
    the critical section—the shared memory—from the reads and the writes of the two
    processes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by adding the include and defines we need. We''ll have two shared
    memory spaces (`STORAGE_ID1` and `STORAGE_ID2`) to have bidirectional communication
    between the processes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `main` method, we need two arrays to store the sent and received messages.
    Furthermore, we need to open two shared memory spaces with the following flags:
    read and write mode, create if not existing, and flags indicating read and write
    permission for the owner of the file `(S_IRUSR` and `S_IWUSR`, respectively):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'As shared memory is based on `mmap` (we essentially map a file to a portion
    of memory), we need to expand the file pointed by the file descriptor 1 (`fd1`)
    to the size `STORAGE_SIZE` that we need. Then, we need to map the two file descriptors
    to a portion of memory in shared mode (`MAP_SHARED`) and, of course, check for
    errors:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `main` loop, as with the previous two recipes, we `read` and `write`
    in the two shared memory instances:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The second program mirrors this one. You can find both of them in the `/BOOK/Chapter06`
    folder: `shm_chat_user1.c` (the one we described) and `shm_chat_user2.c`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s compile and link the two `shm_chat_user1.c` and `shm_chat_user2.c` programs
    by typing the following two commands on the shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The outputs will be two binary files: `user1` and `user2`. We've added `-lrt` in
    this case too as we need to include the POSIX shared memory implementation (without
    it, the linking phase will throw an `undefined reference to 'shm_open'` error).
    In the next section, we'll analyze all the steps seen in this section.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Running the `./user1` and `./user2` programs would give the following interactions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4d2095df-4516-4651-bdfa-36f932343e57.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s perform the steps, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 1**: The first step just includes a few headers we need: `stdio.h` for
    the standard input/output (for example, `perror` , `printf`, and so on); `mman.h`
    for the shared memory APIs; `mmap` and `fcntl.h` for the `shm_open` flags (for
    example, `O_CREAT`, `O_RDWR`, and many others); `unistd.h` for the `ftruncate`
    method; and `string.h` for `strlen` and `memcpy` methods.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We defined `STORAGE_ID1` and `STORAGE_ID2` to identify the two shared memory
    objects, which will be available in the `/dev/shm` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '**Step 2**: In this step, we allocated the space on the stack for the two messages
    (`message1` and `message2`) that we''ll use to send and receive messages between
    processes. We then created and opened two new shared memory objects and checked
    for any errors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Step 3**: Once the two shared memory objects are available, we need to extend
    the two files (through the two file descriptors `fd1` and `fd2`, one for each
    program) and—very important—mapping `fd1` and `fd2` to a virtual address space
    of the current process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Step 4**: This step is the central part of the program. Here, there are a
    couple of interesting things to note. First, we can see that there is none of
    the movement of data between user space and kernel space that there was with FIFOs,
    pipes, and message queues. We just do memory copies between local buffers (allocated
    on the stack) and the memory we mapped, and vice versa. The second factor is that
    as we just deal with memory copy, the performance will be better than other IPC
    mechanisms.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The mechanic of this step is pretty simple: we ask the user to type a message
    and store it in the `message1` buffer, and then copy the buffer to the memory-mapped
    address with `addr1`. The read section (where we read the message from the second
    user) is simple too: we copy the message from the memory to the local buffer,
    `message2`.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you can see, there was no synchronization between the two processes in this
    recipe. That was to let you focus on one aspect only: communication with shared
    memory. The reader is again invited to improve this code to make it more interactive
    by using threads, and more secure by using a synchronization mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: Since kernel 2.6.19, Linux supports the use of **access control lists** (**ACLs**)
    to control the permissions of objects in the virtual filesystem. For more info,
    see `man acl`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Recipes about threading and synchronization:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 3](c27d5a31-a4f2-4925-b883-fa244edeb6ae.xhtml), *Dealing with Processes
    and Threads*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Chapter 5](5578f31b-bd1e-4cb9-9ab5-da18a155f28d.xhtml), *Using Mutexes, Semaphores,
    and Condition Variables*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
