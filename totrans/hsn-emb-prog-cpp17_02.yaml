- en: What Are Embedded Systems?
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是嵌入式系统？
- en: Essentially , the *embedded* part of an *embedded system* refers to the state
    of being embedded into a larger system. The system that has been embedded is a
    computer system of some description, which has one or more very specific functions
    in the overall system, rather than being a general-purpose component. This larger
    system can be digital, mechanical, or analog in nature, while the additional integrated
    digital circuitry tightly interacts with data from and to interfaces, sensors
    and memory to implement the actual system functionality.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，嵌入式系统中的“嵌入式”部分指的是被嵌入到更大系统中的状态。被嵌入的系统是某种类型的计算机系统，它在整个系统中具有一个或多个非常特定的功能，而不是一个通用组件。这个更大的系统可以是数字的、机械的或模拟的，而额外的集成数字电路与接口、传感器和存储器的数据紧密交互，以实现实际的系统功能。
- en: 'In this chapter, we will look at the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主题：
- en: Different categories of embedded platforms
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 嵌入式平台的不同类别
- en: Examples of each category
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个类别的例子
- en: Development challenges of each category
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个类别的发展挑战
- en: The many faces of embedded systems
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 嵌入式系统的多种面貌
- en: Every computerized function in today's devices is implemented using one or multiple
    microprocessors, meaning a computer processor (central processing unit, or CPU)
    usually contained in a single **integrated circuit** (**IC**). The microprocessor
    comprises at least the **arithmetic logic unit** (**ALU**) and control circuitry,
    but logically also registers, and **input/output** (**I/O**) banks, in addition
    to more advanced features commonly tailored to a specific product category (wearables,
    low power sensors, mixed signal, ...) or market (consumer, medical, automotive,
    ...).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 今天设备中的每个计算机化功能都是使用一个或多个微处理器实现的，这意味着一个计算机处理器（中央处理单元或CPU）通常包含在一个单一的集成电路（IC）中。微处理器至少包括算术逻辑单元（ALU）和控制电路，但逻辑上也包括寄存器和输入/输出（I/O）银行，以及通常针对特定产品类别（可穿戴设备、低功耗传感器、混合信号等）或市场（消费品、医疗、汽车等）定制的更高级功能。
- en: At this point in history, almost all microprocessors are found in embedded systems.
    Even though people are likely to possess a computer, laptop, and smartphone, maybe
    even a tablet, the number of embedded microprocessors in a given household far
    dwarfs the number of general-purpose microprocessors.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在历史上的这一点上，几乎所有的微处理器都可以在嵌入式系统中找到。即使人们可能拥有计算机、笔记本电脑和智能手机，甚至可能还有平板电脑，但一个家庭中嵌入式微处理器的数量远远超过通用微处理器的数量。
- en: Even within a laptop or PC, there are a number of embedded microprocessors in
    addition to its general-purpose CPU. These microprocessors have tasks like handling
    keyboard or mouse input, processing touch-screen inputs, converting streams of
    data into Ethernet packages, or creating video or audio output.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在笔记本电脑或个人电脑中，除了通用CPU之外，还有许多嵌入式微处理器。这些微处理器的任务包括处理键盘或鼠标输入，处理触摸屏输入，将数据流转换为以太网数据包，或创建视频或音频输出。
- en: In older systems, such as the Commodore 64, this same pattern can be seen, with
    a CPU IC, sound IC, video IC, and so on. Whereas the CPU runs whatever code the
    application developer has written, the other chips in the system have very specific
    purposes, down to the controller IC for the floppy or hard disk drive.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在旧系统中，比如Commodore 64，也可以看到同样的模式，有CPU IC、声音IC、视频IC等。虽然CPU运行应用程序开发人员编写的任何代码，但系统中的其他芯片具有非常具体的目的，甚至包括软盘或硬盘驱动器的控制器IC。
- en: Outside of general-purpose computers, we find embedded microprocessors everywhere,
    often in the form of even further integrated MCUs. They control kitchen devices,
    washing machines, and the engines of our cars, in addition to the higher-level
    functions and the processing of sensor information.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 除了通用计算机之外，我们在各处都可以找到嵌入式微处理器，通常以更进一步集成的MCU的形式存在。它们控制厨房设备、洗衣机和汽车发动机，除了更高级的功能和传感器信息的处理。
- en: While the first microwaves were analog devices, using mechanical timers and
    variable resistors to set power level and duration, today's microwaves contain
    at least one microcontroller, which is responsible for handling user input, driving
    a display of some type, and configuring the microwave's systems. The display itself
    can have its own microcontroller, depending on the complexity of the chosen configuration.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然最初的微波炉是模拟设备，使用机械定时器和可变电阻器来设置功率水平和持续时间，但今天的微波炉至少包含一个微控制器，负责处理用户输入，驱动某种类型的显示器，并配置微波炉的系统。显示器本身可以根据所选择的配置的复杂性具有自己的微控制器。
- en: Perhaps more excitingly, embedded systems also provide monitoring, automation
    and fail-safe features that keep airplanes flying, ensure that guided missiles
    and space rockets perform as intended, and enable ever-increasing possibilities
    in areas such as medicine and robotics. The avionics of an airplane constantly
    monitor countless parameters from a multitude of sensors, running the same code
    on its triple-redundant configuration to detect any possible glitches.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 也许更令人兴奋的是，嵌入式系统还提供监控、自动化和故障安全功能，保持飞机飞行，确保制导导弹和太空火箭按预期执行，并在医学和机器人技术等领域实现不断增加的可能性。飞机的航空电子设备不断监测来自众多传感器的无数参数，运行相同代码的三重冗余配置以检测任何可能的故障。
- en: Tiny yet powerful microprocessors enable the rapid analysis of chemicals and
    DNA or RNA strands, which would have taken racks of equipment before. With the
    progress of technology, an embedded system has become small enough that it can
    be sent through the human body to monitor its health.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 微小而强大的微处理器使得对化学物质和DNA或RNA链的快速分析成为可能，而以前需要大量设备。随着技术的进步，嵌入式系统已经变得足够小，可以被送入人体监测其健康状况。
- en: Beyond Earth, space probes and rovers on Mars, the Moon, and asteroids are performing
    a myriad of duties every day, again with the courtesy of well-tested embedded
    systems. The Moon missions themselves were made possible due to the first major
    example of an embedded system in the form of the Apollo Guidance Computer. This
    1966-era embedded system consisted of wire-wrapped boards full of triple-input
    NOR logic gates, built for the explicit purpose of handling navigation, guidance,
    and control of the Command Module and Lunar Module launched by the Saturn V rockets.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: The ubiquitous and versatile nature of embedded systems has made them an inseparable
    part of modern life.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: 'For embedded systems, they are usually distinguished between the following
    categories:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '**Microcontrollers** (**MCUs**)'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**System-on-Chip** (**SoC**), often as a **Single-Board Computer** (**SBC**)'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microcontrollers
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the driving factors of innovation in the field of embedded systems is
    cost, since they will often be high-volume, cheap consumer products. To that end,
    it helps to have the entire microprocessor, memory, storage, and input/output
    peripherals on a single chip, simplifying implementation effort, reducing PCB
    real estate, all with the added benefit of faster and simpler design and production
    with higher yield. This led to the development of **microcontrollers** (**MCUs**)
    during the 1970s: single-chip computer systems that could be added to a new design
    for a minimal cost.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: With the introduction of **Electrically Erasable Programmable Read-Only Memory**
    (**EEPROM**) to MCUs in the early 1990s, it first became possible to rewrite the
    program memory of MCUs repeatedly without having to resort to erasing memory content
    using ultraviolet light through a special quartz window in the MCU's packaging.
    This allowed for much easier prototyping and further reduced cost and - as far
    as development and lower-volume production is concerned - in-circuit programming.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: As a result of this, many systems that were previously controlled by intricate
    mechanical and analog mechanisms (like elevators and temperature controllers)
    now contain one or more MCUs, which handle the same functionality while reducing
    costs and increasing reliability. By having the features handled in software,
    developers were also free to add advanced features such as complex preset programs
    (for washing machines, microwaves, and so on) and simple to complex displays to
    provide feedback to the user.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: TMS 1000
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first commercially available MCU was Texas Instrument's TMS 1000, a general-purpose
    4-bit, single-chip system. It was first made available for sale in 1974\. The
    original model had 1 KB of ROM, 64 x 4 bits of RAM, and 23 I/O pins. They could
    be clocked at speeds from 100 to 400 KHz, with each instruction executing in six
    clock cycles.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: 'Later models would increase the ROM and RAM sizes, though the basic design
    remained largely unchanged until production ceased in 1981:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3b757a88-54d0-4f2c-a0d1-367c2523d7c2.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
- en: The size of the MCU die was roughly 5 x 5 millimeters, small enough to fit in
    a DIP package. This type of MCU used mask-programmable ROM, meaning that you could
    not get a blank TMS 1000 chip and program it. Instead, you would have to send
    the debugged program to Texas Instruments to have it physically produced using
    a photolithography mask, resulting in a metallic bridge for each bit.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: 'Being a fairly primitive design (relative to later MCUs), it lacked a stack
    and interrupts, had a set of 43 instructions and two general-purpose registers,
    making it quite similar to the Intel 4004 CPU. Some models had special peripherals
    for driving **vacuum fluorescent displays** (**VFD**) and for continuously reading
    inputs to handle user input via a keyboard without interrupting the main program.
    Its basic pinout looked as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d3dc0886-0ef2-4ab9-906d-8c68a6eeff37.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
- en: Obviously the pin functions predate the **general purpose input/output** (**GPIO**)
    pins we know today - the **K** pins can only be used for input, while output pins
    are denoted as **O** and control pins are marked with **R**. The **OSC** pins
    are to be connected to an external oscillator circuit. Much like with discrete
    logic ICs, the **Init** pin is used to initialize the chip on power-up and has
    to be kept high for at least six cycles, whereas recent MCUs have integrated Power-On
    Reset (POR) and a reset pin that needs at most a discrete resistor and capacitor.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，引脚功能早于我们今天所知的通用输入/输出（GPIO）引脚 - K引脚只能用于输入，而输出引脚标记为O，控制引脚标记为R。OSC引脚需要连接到外部振荡器电路。与离散逻辑IC类似，Init引脚用于在上电时初始化芯片，并且必须保持高电平至少六个周期，而最近的MCU则集成了上电复位（POR）和最多需要一个离散电阻和电容的复位引脚。
- en: According to the original Texas Instruments press release from 1974, these microcontrollercould
    be had for as little as $3 or less if you bought them in large quantity. They
    would be used in popular toys such as the Speak and Spell, but also just about
    everywhere else, including household appliances, automobiles, and scientific equipment.
    By the time production ceased in the early 1980s, many millions had been sold.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 根据1974年德州仪器的原始新闻稿，这些微控制器可以以低至3美元的价格购得，如果你大量购买的话甚至更便宜。它们将被用于流行的玩具，如Speak and
    Spell，但也会出现在几乎所有其他地方，包括家用电器、汽车和科学设备。到了1980年代初停产时，已经销售了数百万台。
- en: It's also interesting to note that while one-time programmable low cost microcontrollers
    have gone down in price a lot, the class of products has persevered - as an example,
    the Padauk PMS150C can now be had for $0.03 and whilst offering an 8 bit architecture,
    its 1K words of ROM and 64 bytes of RAM sound oddly familiar.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，尽管一次性可编程的低成本微控制器的价格大大降低，但这类产品仍然存在 - 例如，Padauk PMS150C现在可以以0.03美元的价格购得，虽然它采用8位架构，但其1K字的ROM和64字节的RAM听起来似曾相识。
- en: Intel MCS-48
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 英特尔MCS-48
- en: Intel's response to Texas Instrument's successful TMS 1000 MCU was the MCS-48
    series, with the 8048, 8035, and 8748 being the first models released in 1976\.
    The 8048 has 1 KB of ROM and 64 bytes of RAM. It is an 8-bit design with a Harvard
    architecture (split code/data memory), introducing a native word size of 8 bits
    and interrupt support (two single-level) and is compatible with 8080/8085 peripherals,
    making it a highly versatile MCU. The advantage of wider ALU and register word
    sizes is still perceivable today, where for example a 32 bit addition is sequentially
    executed on an 8 bit MCU as a series of 8 bit additions with carry.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 英特尔对德州仪器成功的TMS 1000 MCU的回应是MCS-48系列，其中8048、8035和8748是1976年发布的第一批型号。8048具有1KB的ROM和64字节的RAM。它是一个8位设计，采用哈佛结构（分离代码/数据存储器），引入了8位本地字长和中断支持（两个单级），并兼容8080/8085外围设备，使其成为一款非常多功能的MCU。更宽的ALU和寄存器字长的优势在今天仍然可以感知到，例如，32位加法在8位MCU上是作为一系列带进位的8位加法依次执行的。
- en: The MCS-48 features over 96 instructions, most of them a single byte in length,
    and allows for external memory to be added in addition to the internal memory.
    In a community effort, available information on the MCS-48 family has been compiled
    and released at [https://devsaurus.github.io/mcs-48/mcs-48.pdf](https://devsaurus.github.io/mcs-48/mcs-48.pdf)
    .
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: MCS-48具有超过96条指令，其中大多数指令长度为一个字节，并允许在内部存储器之外添加外部存储器。在社区的努力下，MCS-48系列的相关信息已经被整理并发布在[https://devsaurus.github.io/mcs-48/mcs-48.pdf](https://devsaurus.github.io/mcs-48/mcs-48.pdf)上。
- en: 'Here we consider the simplicity of the MCS-48 functional block diagram and
    compare it to that of its successors as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们考虑了MCS-48功能块图的简单性，并将其与后续产品进行了比较，如下所示：
- en: '![](img/b5d1ac0d-9dea-45f2-a35b-77b9c74a8ade.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b5d1ac0d-9dea-45f2-a35b-77b9c74a8ade.png)'
- en: Even for a design that was introduced just a few years after the TMS 1000, the
    rapid evolution of MCU designs is evident. Since MCU design evolved alongside
    popular CPU designs of the time, including the 6502, its 16-bit version, and what
    would eventually become the M68K processor family, there are many similarities
    to be found.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是在TMS 1000之后的几年内推出的设计，MCU设计的快速演变也是显而易见的。由于MCU设计与当时流行的CPU设计一起发展，包括6502及其16位版本，以及最终成为M68K处理器系列的设计，因此可以找到许多相似之处。
- en: Due to its flexible design, it remained popular and in production until the
    1990s, until the MCS-51 (8051) series gradually replaced it. See the next section
    for more details on the 8051.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其灵活的设计，MCS-48一直保持着流行，并一直生产到1990年代，直到MCS-51（8051）系列逐渐取代它。有关8051的更多详细信息，请参见下一节。
- en: The MCS-48 was used in the keyboard of the original IBM PC as its controller.
    It was also used with the 80286 and 80386 to perform A20 line gating and reset
    functions in the case of the former. Later PCs would integrate these features
    into Super I/O devices.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: MCS-48被用于原始IBM PC的键盘控制器。它还与80286和80386一起用于执行A20线门控和复位功能。后来的PC将这些功能集成到超级I/O设备中。
- en: Other notable uses of the MCS-48 include the Magnavox Odyssey video game console
    and a range of Korg and Roland analog synthesizers. While masked ROM (up to 2
    KB) was an option with the MCS-48 family, the 87P50 used an external ROM module
    for its programming, and the 8748 and 8749 featured up to 2 KB EPROM, which allowed
    for the MCU's internal programming to be altered repeatedly.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: MCS-48的其他显著用途包括Magnavox Odyssey视频游戏机和一系列Korg和Roland模拟合成器。虽然MCS-48系列可以选择使用掩模ROM（最多2KB），但87P50使用外部ROM模块进行编程，而8748和8749则配备了高达2KB的EPROM，这使得MCU的内部编程可以重复更改。
- en: 'Like with standalone EPROM modules, this requires the package to contain a
    fused quartz window, which allows for ultraviolet light to reach the MCU die,
    as can clearly be seen in the following photograph of an 8749 MCU with EPROM (by
    Konstantin Lanzet, CC BY-SA 3.0):'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 与独立的EPROM模块一样，这需要包含一个熔合石英窗口的封装，这样紫外线就可以到达MCU芯片，正如下面这张Konstantin Lanzet拍摄的8749
    MCU与EPROM的照片所示（CC BY-SA 3.0）：
- en: '![](img/4ad70b0c-1c97-4323-ae7e-4c79e53867d6.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4ad70b0c-1c97-4323-ae7e-4c79e53867d6.png)'
- en: 'The charge stored in the EPROM cells that defines bits as written dissipates
    within a 20-30 minute exposure to strong ultraviolet light. The same can be achieved
    in direct sunlight over the course of a few weeks. The erase cycle usually implies
    removing the package and putting it in the light tight erasing device. After this,
    the EPROM can be programmed anew. The specified data retention of an EPROM is
    about 10-20 years at 85°C, and because the degradation accelerates exponentially
    with temperature, statements of 100 years or more at room temperature are not
    uncommon (27C512A: 200 years).'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 定义写入的EPROM单元中存储的电荷在强紫外线照射20-30分钟后会消散。在几周的阳光直射下也可以实现相同效果。擦除周期通常意味着取出封装并将其放入密封的擦除设备中。之后，EPROM可以重新编程。EPROM的指定数据保留在85°C时约为10-20年，由于随温度呈指数增长，因此在室温下100年或更长时间的声明并不罕见（27C512A：200年）。
- en: Due to the expense of creating the quartz window and integrating it into the
    package, one-time programmable EPROMs were used for a while, which allow for the
    easy programming of an EPROM, but mounted the programmed die in an opaque package
    so that it could not be reprogrammed any more. Ultimately, EEPROMs became available
    in the early 1980s, which replaced EPROMs almost completely. EEPROMs can be rewritten
    about a million times before they begin to develop issues when retaining stored
    data. Their data retention performance is similar to that of EPROMs.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 由于制作石英窗口并将其集成到封装中的费用昂贵，一次性可编程EPROM曾一度被使用，这样可以轻松编程EPROM，但将编程后的芯片安装在不透明封装中，因此无法再次重新编程。最终，EEPROM在20世纪80年代初开始出现，几乎完全取代了EPROM。
    EEPROM在开始出现存储数据之前可以重写大约一百万次。它们的数据保留性能与EPROM类似。
- en: Intel MCS-51
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 英特尔MCS-51
- en: Recent chips from Cypress CY7C68013A (USB peripheral controller) to Ti CC2541
    (a Bluetooth SoC) feature commodity 8051 cores, demonstrating that the Intel MCS-51
    family design remains popular to this day. There's a plethora of derived MCUs
    by other manufacturers as well, even though Intel stopped producing this series
    of MCUs in March of 2007\. First introduced in the 1980s, it's an 8-bit MCU like
    the 8048, but expands heavily on its feature set.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 从Cypress CY7C68013A（USB外围控制器）到Ti CC2541（蓝牙SoC）的最新芯片都采用了通用的8051核心，这表明英特尔MCS-51系列设计至今仍然受欢迎。其他制造商也推出了大量衍生的MCU，尽管英特尔于2007年3月停止生产这个系列的MCU。它是在20世纪80年代首次推出的，是一种8位MCU，类似于8048，但在其功能集上有很大的扩展。
- en: 'The functional block diagram as depicted in the Intel 80xxAH datasheet is shown
    as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如英特尔80xxAH数据表中所示的功能模块图如下：
- en: '![](img/893fbdf4-9c16-48cd-8446-bc058a32f4f0.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](img/893fbdf4-9c16-48cd-8446-bc058a32f4f0.png)'
- en: It's very similar to the Atmel (now microchip) AT89S51  which is still in production
    today.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 它与Atmel（现在是微芯片）AT89S51非常相似，而且至今仍在生产中。
- en: 'Datasheets commonly address size and performance metrics in a *Features* list,
    as quoted below for the AT89S51:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 数据表通常在“特性”列表中解释尺寸和性能指标，如下所引用的AT89S51：
- en: 4K Bytes of **in-system programmable** (**ISP**) flash memory
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4K字节的**系统内可编程**（ISP）闪存存储器
- en: '- Endurance: 10,000 write/erase cycles (was 1,000,000 for EEPROM)'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '- 耐久性：10,000次写入/擦除周期（EEPROM为1,000,000次）'
- en: 4.0 V to 5.5 V operating range
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4.0V至5.5V的工作范围
- en: 'Fully static operation: 0 Hz to 33 MHz (was 12 MHz)'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完全静态操作：0赫兹至33兆赫（曾为12兆赫）
- en: Three-level program memory lock
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三级程序存储器锁
- en: 128 x 8-bit internal RAM
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 128 x 8位内部RAM
- en: 32 programmable I/O lines
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 32个可编程I/O线路
- en: 'but then the list goes on with modern core, peripheral, low power and usability
    features:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 但随后的列表中还包括现代核心、外围、低功耗和可用性功能：
- en: Two 16-bit timer/counters
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个16位定时器/计数器
- en: Six interrupt sources
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 六个中断源
- en: Full duplex UART serial channel
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全双工UART串行通道
- en: Low-power Idle and power-down modes
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 低功耗空闲和关机模式
- en: Interrupt recovery from power-down mode
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中断从掉电模式恢复
- en: Watchdog timer
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 看门狗定时器
- en: Dual data pointer
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 双数据指针
- en: Power-off flag
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关机标志
- en: Fast programming time
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快速编程时间
- en: Flexible ISP programming, byte- and page-mode
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 灵活的ISP编程，字节和页面模式
- en: The only major changes to the 8051 architecture over the past decades involved
    migrating from the original **n-type metal oxide semiconductor** (**NMOS**) transistor
    technology to **complementary MOS** (**CMOS**) – usually denoted as 80C51 – and
    more recently the addition of USB, I2C, and SPI interfaces, as well as advanced
    power management and debugging interfaces that have become ubiquitous since the
    beginning of this century. The Atmel application note 3487A doesn't give a concise
    explanation for the letter S, however the then new in-circuit serial programming
    (ISP) might thereby be highlighted.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去几十年里，8051架构的唯一重大变化涉及从原始的**n型金属氧化物半导体**（NMOS）晶体管技术迁移到**互补MOS**（CMOS）-通常表示为80C51-以及最近添加了USB、I2C和SPI接口，以及自本世纪初以来变得普遍的先进电源管理和调试接口。Atmel应用说明3487A没有对字母S给出简明的解释，然而当时新的现场串行编程（ISP）可能因此受到强调。
- en: 'The pinout diagram of the AT89S51 documents the SPI pins (MOSI, MISO, SCK):'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: AT89S51的引脚图表记录了SPI引脚（MOSI，MISO，SCK）：
- en: '![](img/a764f469-f62f-4b51-99ee-5cc20c141900.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a764f469-f62f-4b51-99ee-5cc20c141900.png)'
- en: Beyond standalone MCUs, 8051 cores are also integrated into larger systems where
    a low-power, basic MCU is dedicated to diverse, low speed, real-time or high I/O
    count tasks. A broad range of chips from the likes of Ti CC2541 (Bluetooth low
    energy SoC) to Cypress CY7C68013A (FX2LP™ USB peripheral controller) underline
    the utility and relevance of the 8051 architecture to this day.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 除了独立MCU外，8051核心还集成到更大的系统中，其中低功耗、基本MCU专用于各种低速、实时或高I/O计数任务。从Ti CC2541（蓝牙低功耗SoC）到Cypress
    CY7C68013A（FX2LP™ USB外围控制器）等各种芯片都突显了8051架构的实用性和相关性。
- en: In **field-programmable gate array** (**FPGA**) or **application specific integration
    circuit** (**ASIC**) development, 8051-type processors are also commonly deployed
    as soft cores, where they are adapted and added to VHDL and Verilog HDL projects
    to handle tasks that lend themselves better to sequential execution without the
    need for tight timing or large bandwidth. Last but not least, the charm of soft
    cores lies in the ability to use full-featured development and debugging tools
    while maintaining tight integration with the remaining hardware design. The equivalent
    of only a few hundred bytes of program code run by a soft core might well be a
    large state machine, memories, counters and ALU-like logic, all of which raises
    the question which implementation is easier to validate and maintain.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在**现场可编程门阵列**（**FPGA**）或**应用特定集成电路**（**ASIC**）开发中，8051型处理器也常常被部署为软核心，它们被改编并添加到VHDL和Verilog
    HDL项目中，以处理更适合顺序执行的任务，而无需紧密的时序或大带宽。软核心的魅力在于能够使用功能齐全的开发和调试工具，同时与其余硬件设计紧密集成。由软核心运行的几百字节程序代码的等效物可能是一个大型状态机，存储器，计数器和ALU类似的逻辑，这引发了一个问题，即哪种实现更容易验证和维护。
- en: PIC
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PIC
- en: The PIC family of MCUs was first introduced in 1976 by General Instrument, using
    their new CP1600 16-bit CPU. This CPU was nearly compatible with the PDP-11 series
    of processors with its instruction set.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: PIC MCU系列于1976年由General Instrument首次推出，使用他们的新CP1600 16位CPU。这个CPU几乎与PDP-11系列处理器兼容，具有其指令集。
- en: 'In 1987, General Instrument spun off its microelectronics division to create
    Microchip Technology, which became an independent company in 1989\. Microchip
    technology produces new PIC designs to this day.  Alongside the evolution of PIC
    cores and peripherals, on-chip memory technology development yielded the introduction
    of light tight encapsulated EPROM for on-time programmable and later EEPROM for
    in-circuit reprogramming capabilities. Like most MCUs, PIC MCUs have a Harvard
    architecture. Today, PIC designs range from 8-bit to 32-bit, with a wide range
    of features. These are the PIC families as the time of writing this book:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 1987年，General Instrument将其微电子部门剥离出来，创建了Microchip Technology，该公司于1989年成为独立公司。Microchip
    Technology至今仍在生产新的PIC设计。随着PIC核心和外设的发展，芯片内存技术的发展产生了封装紧密的EPROM，用于及时可编程，后来是EEPROM，用于电路中的重新编程能力。像大多数MCU一样，PIC
    MCU具有哈佛结构。如今，PIC设计从8位到32位不等，具有各种功能。这是本书撰写时的PIC系列：
- en: '| **Family** | **Pins** | **Memories** | **Details** |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '**系列** | **引脚** | **内存** | **详情**'
- en: '| PIC10 | 6-8 | 384-896 bytes ROM, 64-512 bytes RAM  | 8-bit, 8-16 MHz, modified
    Harvard |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: PIC10 | 6-8 | 384-896字节ROM，64-512字节RAM | 8位，8-16 MHz，修改的哈佛结构
- en: '| PIC12 | 8 | 2-16 KB ROM, 256 bytes RAM | 8-bit, 16 MHz, modified Harvard
    |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: PIC12 | 8 | 2-16 KB ROM，256字节RAM | 8位，16 MHz，修改的哈佛结构
- en: '| PIC16 | 8-64 | 3.5-56 KB ROM,  1-4 KB RAM  | 8-bit modified Harvard |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: PIC16 | 8-64 | 3.5-56 KB ROM，1-4 KB RAM | 8位修改的哈佛结构
- en: '| PIC17 | 40-68 | 4-16 KB ROM, 232-454 bytes RAM | 8-bit, 33 MHz, superseded
    by the PIC18, though third-party clones exist. |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: PIC17 | 40-68 | 4-16 KB ROM，232-454字节RAM | 8位，33 MHz，被PIC18取代，尽管存在第三方克隆产品。
- en: '| PIC18 | 28-100 | 16-128 KB ROM, 3,728-4,096 bytes RAM  | 8-bit modified Harvard
    |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: PIC18 | 28-100 | 16-128 KB ROM，3,728-4,096字节RAM | 8位修改的哈佛结构
- en: '| PIC24 (dsPIC) | 14-144 | 64-1,024KB ROM, 8-16 KB RAM | 16-bit, DsPIC (dsPIC33)
    MCUs have digital signal processing (DSP) peripherals built in. |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: PIC24（dsPIC）| 14-144 | 64-1,024KB ROM，8-16 KB RAM | 16位，DsPIC（dsPIC33）MCU内置数字信号处理（DSP）外设。
- en: '| PIC32MX | 64-100 | 32-512 KB ROM, 8-32 KB RAM | 32-bit, 200 MHz MIPS M4K
    with MIPS16e mode, released in 2007. |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: PIC32MX | 64-100 | 32-512 KB ROM，8-32 KB RAM | 32位，200 MHz MIPS M4K与MIPS16e模式，2007年发布。
- en: '| PIC32MZ ECPIC32MZ EFPIC32MZ DA | 64-288 | 512-2,048 KB ROM, 256-640 KB static
    RAM (32 MB DDR2 DRAM) | 32-bit, MIPS ISA (2013), PIC32MZ DA version (2017) having
    a graphics core. Core speeds of 200 MHz (EC, DA) and 252 MHz (EF). |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: PIC32MZ ECPIC32MZ EFPIC32MZ DA | 64-288 | 512-2,048 KB ROM，256-640 KB静态RAM（32
    MB DDR2 DRAM） | 32位，MIPS ISA（2013），PIC32MZ DA版本（2017）具有图形核心。核心速度为200 MHz（EC，DA）和252
    MHz（EF）。
- en: '| PIC32MM | 20-64 | 16-256 KB RAM, 4-32 KB RAM | 32-bit microMIPS, 25 MHz,
    variant optimized for low cost and low power. |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: PIC32MM | 20-64 | 16-256 KB RAM，4-32 KB RAM | 32位microMIPS，25 MHz，针对低成本和低功耗进行了优化的变体。
- en: '| PIC32MK | 64-100 | 512-1,024 KB ROM, 128-256 KB RAM | 32-bit, 120 MHz, MIPS
    ISA, variant introduced in 2017\. Targeted at industrial control and other forms
    of deeply integrated applications. |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: PIC32MK | 64-100 | 512-1,024 KB ROM，128-256 KB RAM | 32位，120 MHz，MIPS ISA，2017年推出的变体。针对工业控制和其他形式的深度集成应用。
- en: The PIC32 families are interesting in that they're based on an MIPS processor
    core, and use this **Instruction Set Architecture** (**ISA**) instead of the PIC
    ISA that's used by all other PIC MCUs. The processor core design they share is
    the M4K, a 32-bit MIPS32 core from MIPS Technology. Between these families, the
    differences are easy to spot when looking at the block diagrams from their respective
    datasheets.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: PIC32系列的有趣之处在于它们基于MIPS处理器核心，并使用这个**指令集架构**（**ISA**），而不是所有其他PIC MCU使用的PIC ISA。它们共享的处理器核心设计是M4K，这是来自MIPS
    Technology的32位MIPS32核心。在这些系列之间，通过查看各自数据表中的块图，这些差异很容易看出来。
- en: 'The decades of development in the PIC line of microcontrollers are perhaps
    best made tangible in the form of functional block diagrams, so we start by looking
    at the PIC10:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在PIC系列微控制器的几十年的发展中，最好以功能块图的形式来体现，因此我们首先看看PIC10：
- en: '![](img/90869401-7d48-4657-b198-ad7556ad1ca8.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](img/90869401-7d48-4657-b198-ad7556ad1ca8.png)'
- en: These are very small MCUs, with barely any peripherals around a processor core
    not more closely defined here—and the referenced table only mentions the memory
    layout. The I/O port is very minimal and the I2C and UART interfaces we know today
    are not implemented as peripheral logic. To pick an example for a controller next
    in line, the PIC16F84 datasheet is very detailed in terms of processor architecture
    and shows that more power-up and reset circuitry has been added while also expanding
    GPIO and adding EEPROM for easy integrated non-volatile storage.  Self-contained
    serial peripherals are still absent.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we''ll have a look at the PIC18:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e6ce1ab5-1c0f-4c29-b0c3-7e061f2310c5.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
- en: The PIC18 family is the latest 8-bit PIC architecture, with MCUs covering a
    wide range of applications. It has significantly more I/O options than the PIC10,
    PIC12, and PIC16 families, while also offering more options in terms of ROM and
    RAM and now providing USART in conjunction with a synchronous serial port for
    4-wire SPI. Also note that the ports now have alternate pin functions and the
    routing from peripherals to the pins and the corresponding configuration registers
    are not shown for simplicity.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s observe the focus shifting from the core to Port and Peripheral
    capabilities in the  PIC24 functional block diagram:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7c2d613d-7ecb-41b3-b888-92bc4c9eb493.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
- en: The diagram is similar to that of the PIC10, with the CPU abstracted away as
    a single block relative to the rest of the MCU. Each of the `PORT` blocks being
    a set of I/O pins, we're running out of space to display all the possible pin
    functions.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Each I/O pin can have a fixed function (linked with a peripheral module), or
    have an assignable function (hardware-level rerouting, or done in software). Generally,
    the more complex the MCU, the more likely it is that I/O pins are generic and
    not fixed-function.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally we have look at the PIC32:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/473399ca-4ada-4083-8265-cae721ce7a90.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
- en: This block diagram is for PIC32MX1XX/2XX devices in the PIC32MX family. It is
    usually clocked at 50 MHz.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: An interesting property of the PIC32 architecture is that it effectively turns
    the Harvard architecture M4K MIPS CPU into a more John von Neumann-like architecture
    by having both program instructions and data travel over the System Bus Matrix. 
    Note that the space dedicated to a single processor register in the PIC10 diagram
    now casually depicts a complex digital or mixed signal peripheral, or the powerful
    JTAG in-circuit programming and debugging interface.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: AVR
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The AVR architecture was developed by two students at the Norwegian Institute
    of Technology, with the original AVR MCU developed at Nordic VLSI (now Nordic
    Semiconductor). It was originally known as μRISC and available for licensing until
    the technology was sold to Atmel. The first Atmel AVR MCU was released in 1997.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: 'Today, we can look back on a multitude of 8-bit AVR families:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '| **Family** | **Pins** | **Memories** | **Details** |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
- en: '| ATtiny | 6-32 | 0.5-16KB ROM 0-2 KB RAM | 1.6-20 MHz. Compact, power-efficient
    MCUs, with limited peripherals. |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
- en: '| ATmega | 32-100 | 4-256 KB ROM 0.5-32 KB RAM |  |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
- en: '| ATxmega | 44-100 | 16-384 KB ROM, 1-32 KB RAM | 32 MHz, largest AVR MCUs,
    with extensive peripherals and performance-enhancing features such as DMA. |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
- en: There also used to be an 32-bit AVR32 architecture, but it was deprecated by
    Atmel as it moved to the ARM 32-bit architecture instead (SAM). See the *ARM-based
    MCU* section for more details on SAM. More detailed information is found in the
    corresponding [Product Selection Guide](http://ww1.microchip.com/downloads/en/DeviceDoc/Atmel-45154-Product-Selection-Guide_Brochure.pdf).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, Atmel used to have so-called **Field Programmable System Level
    Integrated Circuit** (**FPSLIC**) MCUs: hybrid AVR/FPGA systems. These essentially
    allowed you to add your own peripherals and functionality to the hardware of an
    AVR MCU.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the ATtiny family. This is the block diagram of the ATtiny212/412
    series of MCUs:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看ATtiny系列。这是ATtiny212/412系列MCU的块图：
- en: '![](img/05383bb6-99ec-434c-b603-09548ed2532e.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](img/05383bb6-99ec-434c-b603-09548ed2532e.png)'
- en: 'This series of ATtiny MCUs can run up to 20 MHz, with up to 4 KB of Flash ROM
    and 256 bytes of SRAM, as well as up to 128 bytes of EEPROM, all in an 8-pin package.
    Despite its small size, it has a large number of peripherals, which can be routed
    to any supported pin:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这系列的ATtiny MCU可以运行高达20 MHz，具有高达4 KB的Flash ROM和256字节的SRAM，以及高达128字节的EEPROM，全部都在一个8引脚的封装中。尽管尺寸小，但它有大量的外围设备，可以路由到任何支持的引脚：
- en: '![](img/ad999a59-ffc7-4ab8-9089-7bf6be05bb22.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ad999a59-ffc7-4ab8-9089-7bf6be05bb22.png)'
- en: 'Contrast this with the popular ATmega2560 and related MCUs, which have the
    following properties:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 与流行的ATmega2560和相关的MCU相比，ATtiny系列MCU具有以下特性：
- en: '| **Device** | **Flash (KB)** | **EEPROM (KB)** | **RAM (KB)** | **General
    purpose I/O pins** | **16-bit PWM channels** | **UART** | **ADC channels** |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| **设备** | **Flash（KB）** | **EEPROM（KB）** | **RAM（KB）** | **通用I/O引脚** | **16位PWM通道**
    | **UART** | **ADC通道** |'
- en: '| ATmega640 | 64 | 4 | 8 | 86 | 12 | 4 | 16 |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| ATmega640 | 64 | 4 | 8 | 86 | 12 | 4 | 16 |'
- en: '| ATmega1280 | 128 | 4 | 8 | 86 | 12 | 4 | 16 |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| ATmega1280 | 128 | 4 | 8 | 86 | 12 | 4 | 16 |'
- en: '| ATmega1281 | 128 | 4 | 8 | 54 | 6 | 2 | 8 |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| ATmega1281 | 128 | 4 | 8 | 54 | 6 | 2 | 8 |'
- en: '| ATmega2560 | 256 | 4 | 8 | 86 | 12 | 4 | 16 |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| ATmega2560 | 256 | 4 | 8 | 86 | 12 | 4 | 16 |'
- en: '| ATmega2561 | 256 | 4 | 8 | 54 | 6 | 2 | 8 |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| ATmega2561 | 256 | 4 | 8 | 54 | 6 | 2 | 8 |'
- en: 'With GPIO pins numbering in the dozens, the block diagram is correspondingly
    more complex, with many more port blocks for the I/O pins:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: GPIO引脚数量众多，因此块图相应地更加复杂，有更多的端口块用于I/O引脚：
- en: '![](img/ce7750cb-a33d-49af-842d-a414db0e2b60.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ce7750cb-a33d-49af-842d-a414db0e2b60.png)'
- en: Here, all the incoming and outgoing arrows indicate a single pin or block of
    pins, most of them general-purpose. Because of the large number of pins, it is
    no longer practical to use an inline package format (DIP, SOIC, and so on) for
    the physical chip.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，所有的输入和输出箭头都表示一个引脚或引脚块，其中大部分是通用的。由于引脚数量众多，对于物理芯片来说，使用行内封装格式（DIP、SOIC等）已不再实用。
- en: 'For the ATmega640, 1280 and 2560, a 100-pin TQFP package is used, here with
    the functionality of each pin indicated as found in its datasheet:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 对于ATmega640、1280和2560，使用了100引脚TQFP封装，这里显示了每个引脚的功能，如其数据表中所示：
- en: '![](img/7d0a8e35-d4cb-4e8b-825f-247338630835.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7d0a8e35-d4cb-4e8b-825f-247338630835.png)'
- en: The ATxmega family is very similar to the ATmega, with a similar pinout, mostly
    differentiating themselves using architectural changes and optimizations, more
    ROM and RAM, and peripheral options.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: ATxmega系列与ATmega非常相似，具有相似的引脚布局，主要通过架构变化和优化、更多的ROM和RAM以及外围选项来区分自己。
- en: Whether to pick an ATtiny, ATmega, or ATxmega MCU depends first and foremost
    on the requirements you have for your project, specifically the required input
    and output, types of peripherals (serial, SPI, I2C, CAN, and so on), and the size
    of both the code and the RAM required to run this code.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 选择ATtiny、ATmega或ATxmega MCU首先取决于您对项目的要求，特别是所需的输入和输出、外围设备的类型（串行、SPI、I2C、CAN等）以及运行此代码所需的代码和RAM的大小。
- en: M68k and Z80-based
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: M68k和Z80基于
- en: The Zilog Z80 8-bit processor is an Intel 8080-compatible processor, which competed
    with other microprocessors during the 1980s, powering home computers and gaming
    systems including the Nintendo Game Boy, Sega Master System, Sinclair ZX80/ZX81/Spectrum,
    MSX, and Tandy TRS-80.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Zilog Z80 8位处理器是与Intel 8080兼容的处理器，与其他微处理器在1980年代竞争，为家用计算机和游戏系统提供动力，包括任天堂Game
    Boy、世嘉Master System、Sinclair ZX80/ZX81/Spectrum、MSX和Tandy TRS-80。
- en: Zilog introduced an MCU (Z380) based around the Z80 microprocessor in 1994,
    with various updates over the years, including the Z8, eZ80, and others. Z80 clones
    are also quite common.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Zilog于1994年推出了基于Z80微处理器的MCU（Z380），并在多年后进行了各种更新，包括Z8、eZ80等。Z80克隆机也很常见。
- en: Another popular 1980s era microprocessor is the Motorola 68k (or 68000). It's
    16-bit for its ALU and external data bus, but with 32-bit registers and 32-bit
    internal data bus. After its introduction in 1979, its architecture is still in
    use today, with Freescale Semiconductor (now NXP) producing a number of 68k microprocessors.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个流行的1980年代微处理器是Motorola 68k（或68000）。它的ALU和外部数据总线为16位，但寄存器和内部数据总线为32位。在1979年推出后，其架构至今仍在使用，Freescale
    Semiconductor（现在是NXP）生产了许多68k微处理器。
- en: Motorola introduced numerous MCUs based around the 68k architecture, including
    the MC68320 communications controller in 1989\. Current 68k-based MCU designs
    include the ColdFire, which is a fully 32-bit design.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Motorola推出了许多基于68k架构的MCU，包括1989年的MC68320通信控制器。当前基于68k的MCU设计包括ColdFire，这是一个完全的32位设计。
- en: ARM Cortex-M
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ARM Cortex-M
- en: A very common type of 32-bit MCU is the ARM Cortex-M family. It includes the
    M0, M0+, M1, M3, M4, M7, M23, and M33, with a number of them having a **floating
    point unit** (**FPU**) option for increased floating point performance.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 一种非常常见的32位MCU是ARM Cortex-M系列。它包括M0、M0+、M1、M3、M4、M7、M23和M33，其中一些具有**浮点单元**（**FPU**）选项，以提高浮点性能。
- en: Not only are they used as standalone MCUs, they are also commonly integrated
    into **System-on-Chip** (**SoC**) devices to provide specific functionality, such
    as touchscreen, sensor, or power management functionality. As Arm Holdings doesn't
    manufacture any MCUs themselves, many third-party manufacturers have licensed
    the designs, sometimes making their own modifications and improvements.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 它们不仅用作独立的MCU，而且通常集成到**片上系统**（**SoC**）设备中，以提供特定功能，例如触摸屏、传感器或电源管理功能。由于Arm Holdings自己不制造任何MCU，许多第三方制造商已经获得了许可，有时会对设计进行自己的修改和改进。
- en: 'Here is a brief overview of these MCUs:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是这些MCU的简要概述：
- en: '| **Core** | **Announced** | **Architecture** | **Instruction set** |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| **核心** | **宣布** | **架构** | **指令集** |'
- en: '| M0 | 2009 | Armv6-M | Thumb-1, some of Thumb-2. |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| M0 | 2009 | Armv6-M | Thumb-1，部分Thumb-2。 |'
- en: '| M0+ | 2012 | Armv6-M | Thumb-1, some of Thumb-2. |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| M0+ | 2012 | Armv6-M | Thumb-1，部分Thumb-2。 |'
- en: '| M1 | 2007 | Armv6-M | Thumb-1, some of Thumb-2. |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| M1 | 2007 | Armv6-M | Thumb-1，部分Thumb-2。 |'
- en: '| M3 | 2004 | Armv7-M | Thumb-1, Thumb-2. |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
- en: '| M4 | 2010 | Armv7-M | Thumb1, Thumb-2, optional FPU. |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
- en: '| M7 | 2014 | Armv7E-M | Thumb-1, Thumb-2, optional FPU. |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
- en: '| M23 | 2016 | Armv8-M | Thumb-1, some of Thumb-2. |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
- en: '| M33 | 2016 | Armv8-M | Thumb 1, Thumb-2, optional FPU. |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
- en: The **Thumb** instruction sets are compact, 16-bit-length instructions, making
    them ideal for embedded, resource-restricted systems. Other ARM microprocessor
    families can also support this Thumb instruction set in addition to the 32-bit
    instruction set.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: H8 (SuperH)
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: H8 family MCUs were commonly used with 8-, 16-, and 32-bit variations. Originally
    created in the early 1990s by Hitachi, new designs were still being created by
    Renesas Technology until a few years ago, though the latter recommends new designs
    use the RX (32-bit) or RL78 (16-bit) families. A notable use of an H8 MCU is in
    the Lego Mindstorms RCX controller, which uses an H8/300 MCU.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: ESP8266/ESP32
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The ESP family are 32-bit MCUs that are produced by Espressif Systems, with
    integrated Wi-Fi (both) and Bluetooth (ESP32) functionality.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: The ESP8266 first appeared in 2014, when it was sold by a third-party manufacturer,
    Ai-Thinker, in the form of a module (ESP-01) that could be used by another MCU
    or microprocessor-based systems to provide Wi-Fi functionality. The ESP-01 module
    contained firmware for this purpose, which allowed the module to be addressed
    using Hayes-style modem commands.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: 'Its system specifications are as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Tensilica Xtensa Diamond Standard L106 microprocessor (32-bit)
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 80-160 MHz CPU speed
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Less than 50 KB of RAM available for user applications (with Wi-Fi stack loaded)
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: External SPI ROM (512 KB to 16 MB)
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wi-Fi support for 802.11 b/g/n
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As the 32-bit MCU on the ESP-01 module was found to be capable of far more than
    the simple modem task assigned to it, it soon came to be used for more general-purpose
    tasks, with a range of upgraded ESP8266 modules (with integrated EEPROM chip),
    as well as breakout boards. Of the latter, the NodeMCU-style board has become
    very popular, though a number of other third-party manufacturers have made their
    own breakout boards, which provide different form factors and functionality.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic block diagram for the ESP8266EX looks as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f0bed65c-4e5c-4765-9d54-34ed7cdd3ee6.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
- en: 'After the immense success of the ESP8266, Espressif Systems developed the ESP32,
    which used an upgraded, dual-core CPU, among other changes. Its block diagram
    looks like this:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/56fe4fde-18fb-4f1c-b82f-4f07034f5fc3.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
- en: 'Its specifications are as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: Xtensa 32-bit LX6 (dual-core) microprocessor
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 160-240 MHz CPU speed
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 520 KB of SRAM
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wi-Fi support for 802.11 b/g/n
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bluetooth v4.2 and BLE (low energy)
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Both the ESP8266 and ESP32 are generally sold as complete modules, with the
    MCU, external ROM module, and a Wi-Fi antenna either integrated into the board
    or with an external antenna option:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e66a9c6a-5202-4624-ac38-6a6d2b8273ca.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
- en: The metal shielding can covering the board helps to protect the board from electromagnetic
    interference,  benefiting its Wi-Fi (and Bluetooth, in the case of the ESP32)
    transceiver, but the whole design with a fixed antenna and geometry is required
    for FCC certification and later use as an approved module. Connecting an external
    antenna with higher gain may violate local regulations. The FCC ID it comes with
    is instrumental in getting a product containing such a module approved for commercialization.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: Others
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to the previously listed MCUs, there is a wide range of MCUs available
    from a number of manufacturers with different architectures. Some, like the Propeller
    MCU from Parallax with its multi-core architecture, are fairly unique, whereas
    most simply implement the usual single-core CPU architecture with a number of
    peripherals, RAM, and internal or external ROM.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: Beyond physical chips, Altera (now Intel), Lattice Semiconductor, and Xilinx
    provide so-called soft cores, which are MCUs that are meant to be run on a FPGA chip,
    either as standalone components or as part of a larger design on that FPGA. These
    can also be targeted by C/C++ compilers.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: Challenges
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main development challenges with MCUs lie in the relatively limited resources
    that are available. Especially with the small, low-pin-count MCUs, you have to
    have a good idea of how many resources (CPU cycles, RAM, and ROM) a particular
    piece of code takes up, and whether it's realistic to add a specific feature.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: This also means that picking the right MCU for a particular project takes both
    technical knowledge and experience. The former is required to pick an MCU that
    will suit the task; the latter is very helpful for the optimal MCU and helps to
    shorten the time that's required to make a choice.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: System-on-Chip/Single Board Computer
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Systems-on-Chips** (**SoCs**) are similar to MCUs, but distinguish themselves
    from those types of embedded systems by having some level of integration while
    still requiring a number of external components to function. They are commonly
    found as part of a single board implementation (**Single Board Computer** (**SBC**)),
    including the PC/104 standard, and more recently form factors such as the Raspberry
    Pi and derivative boards:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4dae667e-c4de-480b-9abb-3fda933f6019.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
- en: This diagram was used from [https://xdevs.com/article/rpi3_oc/](https://xdevs.com/article/rpi3_oc/).
    It clearly shows how an SBC (in this case, the Raspberry Pi 3) is laid out. The
    BCM2837 is the ARM-based SoC, providing the CPU core and basic peripherals (mostly
    broken out into the header section). All of the RAM is in an external module,
    as are the Ethernet and Wi-Fi peripherals. ROM is provided in the form of an SD
    (Flash) card, which also provides storage.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: Most SoCs are ARM-based (Cortex-A family), though MIPS is quite common as well.
    SBCs are commonly used in industrial settings.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Other instances are mass produced boards, such as those for smartphones, which
    do not form a predefined form factor, but still follow the same pattern of having
    the SoC and external RAM, ROM, and storage, as well as various peripherals. This
    is in contrast with the MCUs of the previous section, which would always be able
    to function by themselves, except for the few requiring an external ROM.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: Challenges
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Compared to MCUs, the development challenges of SoCs tend to be far less severe.
    Some of them are on the level and have an interface where you can even develop
    directly on the device, even doing compilation cycles on the device without having
    to do cross-compilation on a PC and copying over the binary. This is also helped
    by running a full OS instead of developing for the bare hardware.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: The obvious disadvantage is that with this increase in features comes an increase
    in complexity, and the resulting complications, such as having to deal with user
    accounts, setting permissions, managing device drivers, and so on.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we got an in-depth look at what constitutes an embedded system.
    We learned how to distinguish between the various types of embedded systems, as
    well as how to determine the basics of picking the right MCU or SoC for a project.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: After this chapter, the reader should feel comfortable reading through datasheets
    for MCUs and SoCs, explaining the differences between both, and determining what
    is needed for a given project.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will look at why C++ is a highly suitable choice for the programming
    of embedded systems.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
