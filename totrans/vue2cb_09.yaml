- en: Advanced Vue.js – Directives, Plugins, and Render Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will talk about the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new directive
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using WebSockets in Vue
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a plugin for Vue
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rendering a simple component manually
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rendering a component with children
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using JSX to render a component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a functional component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a responsive table with higher-order components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Directives and plugins are ways to package functionality in a reusable way and
    also make it easily shareable across apps and teams; you will build a few of them
    in this chapter. Render functions are how Vue really works under the hood to turn
    templates into the Vue language and then into HTML and JavaScript again; they become
    useful if you need to optimize the performance of your apps and work in some corner
    cases.
  prefs: []
  type: TYPE_NORMAL
- en: In general, you should avoid using these advanced functions when possible as
    they have been a little overused in the past. Usually, many problems can be solved
    by simply writing a good component and distributing the component itself; you
    should look at advanced features only when this is not true.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter is for the slightly more experienced, and you probably won't find
    the level of step-by-step detail found in other recipes, but I have strived to
    make them complete nonetheless.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new directive
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Directives are like mini functions that you can use to quickly drop in to your
    code, mainly to improve the user experience, and to add new low-level features
    to your graphic interface.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe, although found in the advanced chapter, is really easy to complete.
    The main reason directives are *advanced* is because you should usually prefer
    composition to add functionality and style to your apps. When components won't
    cut it, use directives.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will build a `v-pony` directive that will turn any element into a pony element.
    A pony element is created with a pink background and changes color when you click
    on it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The HTML code for the pony element is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Just to show the difference, I''ve included a normal `blockquote` element.
    In our JavaScript section, write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This is how you declare a new directive. The `bind` hook is called when the
    directive is bound to the element. The only thing we are doing now is setting
    the background color. We also want to make it change color after each click. To
    do this, you have to add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are creating an `onclick` listener that will generate a random color
    with a bias toward red and assign it as a new background color.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end of our JavaScript, remember to create a `Vue` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You can launch your application to see your directive in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00159.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Don't forget to click on the text to change the background color!
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The syntax to declare a new directive is as illustrated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This will register a new global directive. Inside the hooks object, you can
    define two important functions: `bind` , which you used in this recipe, and `update`
    , which is triggered every time a component contained in it is updated.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Every hook function is called with at least three arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '`el` : The HTML element'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`binding` : Directives can receive an argument; binding is an object that will
    contain the value of the argument'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`vnode` : the Vue internal representation of this element'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We used the `el`  parameter to edit the appearance of our element, manipulating
    it directly.
  prefs: []
  type: TYPE_NORMAL
- en: Using WebSockets in Vue
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: WebSockets are a new technology that enables two-way communication between the
    user and the server where the app is hosted. Before this technology, only the
    browser could initiate a request and, thus, a connection. If some update on the
    page was expected, the browser had to continuously poll the server. With WebSockets,
    this is no longer necessary; after the connection is established, the server can
    send updates only when there is a need.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You don't need any preparation for this recipe, just the basics of Vue. If you
    don't know what WebSockets are, you don't really need to, just think about them
    as a channel of continuous two-way communication between a server and browser.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this recipe, we need a server and a browser that will act a client. We will not
    build a server; instead, we'll use an already existing server that just echoes
    whatever you send to it via WebSockets. So, if we were to send the `Hello` message,
    the server would respond with `Hello` .
  prefs: []
  type: TYPE_NORMAL
- en: 'You will build a chat app that will talk to this server. Write the following
    HTML code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `<pre>` tag will help us render a chat. As we don't need the `<br/>` element
    to break a line, we can just use the `n` special character that means a new line.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our chat to work, we first have to declare our WebSocket in the JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we declare our `Vue` instance that will contain a `chat` string
    (to contain the chat so far) and a `message` string (to contain the message we
    are currently writing):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We still need to define the `send` method, which is called upon pressing *Enter*
    in the textbox:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We factored out the `appendToChat`  method because we will use it to append
    all the messages we''ll receive. To do this, we must wait for the component to
    be instantiated. The `created`  hook is a safe place for that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now launch the application to chat with your personal echo chamber:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00160.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To see the internals of what you have built, open the Chrome developer tools
    (![](img/Image00161.jpg)  |  More tools  |  Developer tools or *Opt* + *Cmd* +
    *I* ):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00162.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Go to the Network tab and reload the page; you should see the `echo.websocket.orl`
     WebSocket, as seen in the screenshot. Write something and messages will appear
    in the frame tab, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00163.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The green messages are sent from you while the white messages are the ones you
    receive. You can also examine the message length (in bytes) and the exact time
    they were sent or received.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a plugin for Vue
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A plugin is a collection of utilities or a global new behavior that we want
    in our application. Vuex and vue-router are two famous examples of Vue plugins.
    A plugin can really be anything, since writing one means acting at a very low
    level. There are different kinds of plugins you can write. For this recipe, we
    will concentrate on building a directive with global properties.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will be based on *Creating a new directive* , except that we will
    add some features for global coordination.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this recipe, we will build a website for a kangaroo appreciation club.
    The layout of the home page HTML looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: You can change the link to the images of kangaroos with the one you prefer.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the JavaScript part, we instantiate an empty `Vue` instance for now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If we open the page now, we get this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now we want to add a fun note to our website. We want the elements of the page,
    except the title, to jump at random intervals.
  prefs: []
  type: TYPE_NORMAL
- en: To do this, the strategy you will implement is to register all the elements
    that will need to jump in an array, and then, periodically take a random element
    and make it jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we need to define is the jump animation in CSS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: What this does is create a class named `kangaroo` that, when applied to an element,
    makes it jump twice by translating it along the y axis.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, write a function that adds this class to a specified element in the JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `jump` function adds the `kangaroo` class and then removes it when the animation
    is finished.
  prefs: []
  type: TYPE_NORMAL
- en: 'We want to perform this action on a random element picked from the ones registered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The `doOnRandomElement`  function takes an action and a collection and applies
    the action to a drawn element. We then need to schedule it at random intervals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `atRandomIntervals`  function takes the specified function and calls it
    at random intervals shorter than 6 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now have all the functions we need to actually build a plugin that will
    make our element jump:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The Kangaroo plugin, when installed, creates an empty array; it declares a new
    directive, `kangaroo`  which will register all the elements with it inside the
    array.
  prefs: []
  type: TYPE_NORMAL
- en: Then at random intervals, one random element is drawn from the array and the
    jump function is called on it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To activate the plugin, we need one line before declaring the `Vue` instance
    (but after declaring `Kangaroo` ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We have to choose the elements that jump, that is, everything except the title:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: If you run your app now, you will see that an image or the text jumps just like
    a kangaroo every few seconds.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In its essence, a Vue plugin is just a way to group some functionalities. There
    are not many restrictions and all you have to do to create a plugin is to declare
    an install function. The general syntax to do that is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'To use the plugin you just made, write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Here, the second parameter is the optional object that gets passed to the `install`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: Since plugins are global entities, you should use them sparsely and only for
    features that you foresee will affect your app throughout.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering a simple component manually
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Vue turns your HTML templates into render functions. Usually, you should stick
    to templates because they are much simpler. There are a couple of cases in which
    render functions become in handy. Here, we show a simple example in which render
    functions are useful.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is the first recipe on render functions. If you already understand the
    basics of Vue, you will understand everything.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first use case for render functions is whenever you just want a `Vue` instance
    that displays another component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Write an empty HTML layout, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We have a Greeter component somewhere that we want to show as the main `Vue`
    instance. In the JavaScript part, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have to imagine that we are taking the `Greeter` component from somewhere
    else and, since the component is nicely packaged, we don''t want to modify it.
    Instead, we will pass it to the `Vue` main instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: If we launch the application now, we will only see the `Greeter` component.
    The main `Vue` instance will only act as a wrapper.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The render function replaces the template in the `Vue` instance. When render
    is called, the passed argument is the so-called `createElement` function. We named
    it `h` for brevity. This function accepts three arguments, but for now, just note
    how the first argument we are passing (the only one we are passing) is the `Greeter`
    component.
  prefs: []
  type: TYPE_NORMAL
- en: In theory, you can write the component inline, inside the `h` function. In a
    real project, this is not always possible depending on the presence of the Vue
    template compiler at runtime. When you use the official Webpack template, one
    of the questions you are asked is whether you want to include the Vue template
    compiler when distributing your software.
  prefs: []
  type: TYPE_NORMAL
- en: 'The arguments for the `createElement` function are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: 'As the first argument, the only required one, you have the option to pass three
    different things:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The options of a Vue component, like in our recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A string representing an HTML tag (such as `div` , `h1` , and `p` )
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A function that returns an options object for a Vue component or a string representing
    an HTML tag
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second argument must be an object called **Data Object** . This object is
    explained in the next recipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The third argument is an array or a string:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The array represents a list of elements, text, or components to put inside the
    component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can write a string that will be rendered to text
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rendering a component with children
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will build a simple web page with a few elements and components
    completely using render functions. This will give you a close-up view of  how
    Vue compiles your templates and components. It may be useful if you want to build
    an advanced component and you want a full example to kick start.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is a complete recipe on how to build components through render functions.
    Usually, you don't need to do this in practice; it's recommended only for advanced
    readers.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You will build a page for a plumber club. The page will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00165.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Whenever we write a name inside the name textbox, it will be written in the
    greeting exactly like the `v-model` directive.
  prefs: []
  type: TYPE_NORMAL
- en: For this recipe, we are starting from the end instead of the beginning because
    usually when you have to resort to the `render` function, you have a pretty clear
    idea of what you are trying to get.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the HTML side of our app, let''s start with an empty tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'In the JavaScript, write an empty `<div>` element in the `render` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The first thing we''ll put inside is the title, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: All the other elements and components will fit inside the array we have just
    created for the title.
  prefs: []
  type: TYPE_NORMAL
- en: We need an `<input>` element that will take the value and display a greeting.
    For this, we can build a `Vue` component.
  prefs: []
  type: TYPE_NORMAL
- en: In the following code, we are using a regular JavaScript function instead of
    an arrow function; this is because we want a reference to the component itself.
    Arrow functions don't allow you to modify the scope of `this` , while `this` depends
    on how the function is called and can be optionally bound to any variable in regular
    functions. In our case, it will be bound to the instance component.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the title of the page, we add the following component in the same array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The component has three options: the `render` , `data` , and `props`  functions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The second parameter of the `createElement` function is to actually assign
    values to our props:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This will be equivalent to writing `:exclamation="true"` when declaring the
    component.
  prefs: []
  type: TYPE_NORMAL
- en: You can easily understand the `data` and `props` options of the component. Let's
    examine what we wrote in the `render` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the first line of the function, we set `self = this` as a convenient way
    to refer to the component were we to add any nested functions. Then, we return
    the result of a `createElement` function (`h` ) that, inside a div tag, places
    three things in the DOM. The first is the raw text `Your name is`  and then two
    elements: an input and a paragraph.'
  prefs: []
  type: TYPE_NORMAL
- en: We don't have a direct equivalent of the `v-model` directive when working with
    render functions. Instead, we implement it manually. We bind the value to the
    name, and then we add a listener to the input event that will set the value of
    the state variable, `name` , to whatever is inside the textbox.
  prefs: []
  type: TYPE_NORMAL
- en: We then insert a paragraph element that will compose the greeting phrase, adding
    an exclamation point based on the value of the `exclamation` prop.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the component, we can add the following, as illustrated, in the same
    array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: If you have done things right, you should be able to run the application and
    see the whole page.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this example, we've seen a glimpse of what happens behind the curtains when
    Vue compiles our templates; again, you are not advised to do this with regular
    components. Most of the time, the result will be just more verbose with little
    or no gain. On the other hand, there are a couple of cases in which writing the
    render function may actually result in better or more robust code and cover some
    functionality that is difficult to express with templates.
  prefs: []
  type: TYPE_NORMAL
- en: Using JSX to render a component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JSX is very popular in the React community. In Vue, you don't have to use JSX
    to build templates for your components; you can use the much more familiar HTML. JSX,
    however, is the next best thing you can do if you are forced to write a lot of
    render functions.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before venturing into this recipe, you better play a little with the render
    function. The previous recipes provide some exercises.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JSX needs a Babel plugin to work. For this recipe, I will assume that you are
    working within the webpack template.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install the babel plugin, you can run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `.babelrc` file, add the following in the `plugins` array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Run `npm install`  as usual to actually install all the dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, open the `main.js` and delete everything inside. Replace it with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The highlighted line is the weird bit if you have never seen JSX. Just note
    that we didn't use the arrow function in the `render` option in the preceding code.
    That's because we are using `this` inside and we want it to be bound to the component.
  prefs: []
  type: TYPE_NORMAL
- en: You can already see your page working using the `npm run dev` command.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The babel plugin will turn the JSX code into a JavaScript `render` function.
  prefs: []
  type: TYPE_NORMAL
- en: I wouldn't recommend using JSX with Vue. The only time I can see it being useful
    is whenever you need to intermix `render` functions with JavaScript and you need
    a quick and readable way of defining templates. Other than that, there are not
    many advantages to using JSX.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's complicate the code a little bit to at least have a flavor of how JSX
    plays with props.
  prefs: []
  type: TYPE_NORMAL
- en: 'Define a new component before the main `Vue` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s use this component in our `Vue` instance and pass the `msg` variable
    via props:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The syntax is slightly different from an HTML template. In particular, note
    how props are passed and how we can use camelCase and self-closing tags.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a functional component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A lighter version of a component is a functional component. The functional component
    doesn't have instance variables (so no `this` ) and has no state. In this recipe,
    we will write a simple functional component that takes some instructions via HTML
    and turns them into a drawing.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before attempting this recipe, you should at least become familiar with the
    render function in Vue. You can use the previous recipes to do that.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you are writing an `<svg>`  element, you usually have to put data in the
    attributes of elements inside it to actually draw shapes. For example, if you
    want to draw a triangle, you have to write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The text inside the `d` attribute is a series of instructions that make a virtual
    cursor move to draw: `M` moves the cursor to the (100, 30) coordinate inside the
    `<svg>` , then `L` traces a line up until (200, 30) and then again to the (150,
    120) coordinate. Finally, `z` closes the path we are drawing, and the result is
    always a triangle.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We would like to write a triangle with a component, but we don''t like attributes
    and we want to write in our own language, so we would write the following to get
    the same result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This is a perfect job for a functional component because there is no state to
    manage, only a translation from one component to one element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your HTML layout will simply look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, lay out your functional component in your JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'You have to specify that the component will be functional with `functional:
    true` ; then the render function is slightly different than usual. The first argument
    is still the `createElement` function, but the second passed is the context of
    our component.'
  prefs: []
  type: TYPE_NORMAL
- en: We can access the text written inside the HTML of our component (the commands
    to draw) through `context.children` .
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see that I already added an empty `<svg>` element. Inside this, there
    is an empty array of children; we will put only the `<path>` element there, which
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The highlighted code creates a path element and then sets some attributes, such
    as `fill` and `stroke` . The `d` attribute takes the text from inside the component,
    makes some substitutions, and then returns it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We just need to create the `Vue` instance in the JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, loading the app, we should see a triangle, which is shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00166.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Vue lets you create components that are very lightweight as they don't have
    any internal state. With this come some limitations, for example, the only place
    where we can put some logic to process user input (in the form of children of
    the element or props) is in the render function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The context we passed contains the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`props` : This is passed by the user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`children` : This is really an array of virtual nodes, children of our component
    in the template. We don''t have the actual HTML element here but only a representation
    of it by Vue.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`slots` : This is a function returning the slots (can be used instead of children
    in some cases).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`data` : This is the entire data object passed to the component.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`parent` : This is a reference to the parent component.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In our code, we extracted the text inside the component by doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'We are taking the array of virtual nodes contained in children and mapping
    each node to its text. Since we put only some text in our HTML, the array of nodes
    will be a singleton, with only one node: the text we entered. Therefore, in this
    particular case, doing `var a = children.map(c => someFunction(c))` is then equivalent
    of doing `var a = [someFunction(children[0])]` .'
  prefs: []
  type: TYPE_NORMAL
- en: We are not only extracting the text though, we are replacing some terms I invented
    to describe `svg` commands, with the real commands. The `join` function will sew
    together all the strings in the array (just one in our case) and `trim` will remove
    all the white spaces and line breaks.
  prefs: []
  type: TYPE_NORMAL
- en: Building a responsive table with higher-order components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functional components are very good wrappers when we have to decide which component
    to actually wrap. In this recipe, you'll write a responsive table that will display
    different columns depending on the browser width.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe is about functional components. If you want to warm up, you can
    try and complete the previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this recipe, we will use the excellent semantic UI CSS framework. To use
    it, you have to include the CSS library as a dependency or as a `<link>` tag.
    For example, you can put the following code in the `<head>` of your HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: If you are using JSFiddle, the link inside should be sufficient.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another tag you have to add to your page for it to look good on mobile is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: This tells the mobile browser that the width of the page is equal to the width
    of the device. If you don't put this, the mobile may assume that the page is much
    larger than the phone and, trying to display all of it, show a miniaturized version
    of your app.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will design a table of cat breeds. You can see all the data in the Vue instance
    status. Write it in your JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: We are declaring the `width` variable to change the layout of the page and since
    the width of the page is not reactive by nature, we're also installing a listener
    on `window.onresize` . For a real project, you'll probably want something a bit
    more sophisticated, but for this recipe, this will suffice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, note how we are using the `BreedTable` component, which we write like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: What our component is doing is just passing all the `context.data` and `context.children`
    to another component, which will be `DesktopTable` or `MobileTable` , depending
    on the resolution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our HTML layout is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The `breeds` props will be passed on to the selected component in the `context.data`
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'Our desktop table will look pretty regular for a table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The classes at the top are part of semantic UI and they will make our table
    look much better. The `unstackable` class, in particular, disables the automatic
    stacking performed by CSS. We will cover more on this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the mobile table, we''d like to edit not only the styling, but we''d also
    like to group the columns themselves. The breed will go along with the color and
    the affection with the shedding. Also, we want to express them in a compact style.
    The table head will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of just spelling the coat color, we draw a little circle of that color:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, instead of using numbers like in the desktop table for the affection
    and shedding level, we put a heart and star rating:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Also, don't forget to declare the `breeds` prop like in the `DesktopTable` component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now launch your application in a browser. You can see how the table groups
    the column when squished enough:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00167.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following screenshot shows that numbers are replaced by hearts and star
    rating:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00168.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A responsive page changes its layout according to the width of the browser and
    this is very important when the user is using a tablet or smartphone to browse
    the website.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the components have to be developed only once for a responsive page,
    and only the styling is done multiple times according to different sizes. This
    can save a lot of development time if compared to having a separate site optimized
    for mobile.
  prefs: []
  type: TYPE_NORMAL
- en: 'Normally, in a responsive page table, go from columnar to stacked, as shown in
    the following illustration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00169.jpg)'
  prefs: []
  type: TYPE_IMG
- en: I never liked this approach, but the objective disadvantage is that if you make
    your table look good on one side, it will look not so good on the other. This
    is because you have to style the cells in the same way and what the responsiveness
    does is that it stacks them up.
  prefs: []
  type: TYPE_NORMAL
- en: What our `BreedTable` component does is to dynamically switch between the two
    components instead of simply relying on the CSS. Since it's a functional component,
    it has the advantage of being very lightweight compared to a full-fledged component.
  prefs: []
  type: TYPE_NORMAL
- en: In a real application, using the `onresize` event is questionable, mainly because
    of the performance hit. In a production system, the solutions for responsiveness via
    JavaScript need to be more structured. For example, consider using a timer or
    using `matchMedia` .
  prefs: []
  type: TYPE_NORMAL
- en: As a last thing, note how the Vue instance never registers the two subcomponents;
    this is because they never appear in a template but are referenced directly in
    the code as objects.
  prefs: []
  type: TYPE_NORMAL
