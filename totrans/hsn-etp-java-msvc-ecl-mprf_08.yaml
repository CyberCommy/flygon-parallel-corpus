- en: MicroProfile OpenAPI and Type-Safe REST Client
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Eclipse MicroProfile has a rich set of specifications for Java microservices.
    Two of these, Eclipse MicroProfile OpenAPI and Eclipse MicroProfile REST Client,
    help with the API documentation for your microservices and provide an API for
    type-safe invocation on REST endpoints, respectively. OpenAPI simplifies the documentation
    for microservice endpoints and makes this metadata available for perusal by third-party
    developers. A type-safe REST client simplifies the marshalling and unmarshalling
    of objects to HTTP or JSON.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: The capabilities offered by each of these specifications
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simple code examples of some of these capabilities
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to obtain further information about each of these specifications
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to MicroProfile OpenAPI and its capabilities
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The mobile force that fuels the digital economy led to the need for businesses
    to establish an omni-channel approach to development in order to optimize costs,
    increase efficiencies, and improve customer experience. A facilitator of this
    approach was APIs, which led to the API economy and concepts such as API-led or
    API-first development practices. In addition, the microservices architecture has
    become the architecture of choice for modern development. API-based (that is,
    RESTful) communication among microservices has been adopted as the *de facto*
    standard because it is a good fit for the *smart endpoints and dumb pipes*, *decentralized
    governance*, and *decentralized data management* characteristics of microservices.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: However, as the number of microservices increases in a microservices architecture,
    their management can become unwieldy. However, you can manage your microservices
    via their APIs. You can apply management, security, load balancing, and throttling
    policies to the APIs that are fronting your microservices.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: 'Eclipse MicroProfile OpenAPI provides Java interfaces to developers for generating
    OpenAPI v3 documents from their Java RESTful Web Services (JAX-RS) applications.
    The specification requires that a fully processed OpenAPI document be available
    at the root URL, `/openapi`, as an HTTP `GET` operation, as follows:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The required protocol is `http`. However, implementors of the specification
    are strongly encouraged to also support the `https` protocol for secure connectivity
    to the OpenAPI endpoint.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three sources from which the OpenAPI document is created. These three
    sources (described in later sections in this chapter) are as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Generated by processing the JAX-RS annotations (and optional OpenAPI annotations)
    found in the application
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Programmatically built by an application by providing a Java class that implements
    `OasModelReader`
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A static OpenAPI document included in application deployment
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These three sources (any combination) are combined to produce a single OpenAPI
    document, which can be filtered (by providing a Java class that implements the
    `OasFilter` interface) and then served at the preceding `/openapi` endpoint.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Configuration
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The MicroProfile OpenAPI specification makes use of the MicroProfile configuration
    specification to configure its parameters and values. For example, for injecting
    configuration values, MicroProfile OpenAPI can use the default and custom ConfigSources.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: For more information on ConfigSources, you can visit [https://github.com/eclipse/microprofile-config/blob/master/spec/src/main/asciidoc/configsources.asciidoc](https://github.com/eclipse/microprofile-config/blob/master/spec/src/main/asciidoc/configsources.asciidoc).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many configurable items. The following table contains a subset of
    them:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '| **Configuration item** | **Description** |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
- en: '| `mp.openapi.scan.di sable` | Configuration property to disable annotation
    scanning. The default value is `false`. |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
- en: '| `mp.openapi.servers` | Configuration property to specify the list of global
    servers that ... |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
- en: Generating the OpenAPI document
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As already described, the MicroProfile OpenAPI specification requires that an
    OpenAPI document be generated from a combination of three sources.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: 'You then have a number of choices:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Extend the OpenAPI document generated by the JAX-RS annotations using the MicroProfile
    OpenAPI annotations.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leverage the initial output from `/openapi`, which you can use as a reference
    to start documenting your APIs. In this case, you can write static OpenAPI files
    (described in a later section in this chapter) before any code is written, which
    is a usual approach adopted by organizations to lock-in the contract of the API,
    that is, it is an API-first development practice.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bootstrap or complete the OpenAPI model tree by coding using the programming
    model, covered later in this chapter.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additionally, you can use a filter to update the OpenAPI model after it has
    been built.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: MicroProfile OpenAPI annotations
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Probably the most common source of OpenAPI information is the set of annotations
    that make up the definition of a standard JAX-RS application. These annotations,
    along with additional (optional) annotations defined by the MicroProfile OpenAPI
    specification, can be scanned and processed by the MicroProfile platform to produce
    an OpenAPI document.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: The MP OpenAPI specification requires the generation of a valid OpenAPI document
    from pure JAX-RS 2.0 applications. If you are new to OpenAPI, you can simply deploy
    your existing JAX-RS application to a MicroProfile OpenAPI runtime and check out
    the output from `/openapi`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: To fill out additional details of the generated OpenAPI document, you may further
    annotate your ...
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: Usage examples
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Some usage examples of MicroProfile OpenAPI annotations are as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 1 – Simple operation description (abbreviated):'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The following is the output for example 1:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Example 2 – Operation with different responses (abbreviated):'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The following is the output for example 2:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: For more examples, please refer to the MicroProfile OpenAPI specification wiki
    at [https://github.com/eclipse/microprofile-open-api/wiki](https://github.com/eclipse/microprofile-open-api/wiki).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Static OpenAPI files
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned earlier in the chapter, static OpenAPI files are one of the three
    sources from which the OpenAPI document can be created. In the following, we give
    you a short introductory description of how you could generate one and how to
    include it in your deployment. Many organizations use an API-first development
    practice, which entails defining static OpenAPI files even before any code is
    implemented for them.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you can create an OpenAPI document by using an open source editor such
    as Swagger Editor ([https://editor.swagger.io](https://editor.swagger.io)). The
    following is a screenshot shows this:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/db11ee83-6eab-4cfd-a4c1-089959d1e197.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
- en: Using this editor, you can start with sample ...
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Programming model
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can provide OpenAPI elements via Java POJOs (Plain Old Java Objects) by
    using the MicroProfile OpenAPI programming model. The complete set of models is
    described in the `org.eclipse.microprofile.openapi.models` package. You can read
    more about it at [https:](https://github.com/eclipse/microprofile-open-api/tree/master/api/src/main/java/org/eclipse/microprofile/openapi/models)[//github.com/eclipse/microprofile-open-api/tree/master/api/src/main/java/org/eclipse/microprofile/openapi/models](https://github.com/eclipse/microprofile-open-api/tree/master/api/src/main/java/org/eclipse/microprofile/openapi/models).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: 'You can create an OpenAPI tree by using `OASFactory`. Refer to the following
    code block by way of an example:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: To bootstrap the OpenAPI model tree, you can use the `OASModelReader` interface.
    You can then create an implementation of this interface and register it using
    the `mp.openapi.model.reader` configuration key.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is globally an example of what its definition would look like
    in `META-INF/microprofile-config.properties`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Like static files, the model reader can be used to provide either complete or
    partial model trees. To provide a complete OpenAPI model tree, you should set
    the `mp.openapi.scan.disable` configuration to `true`. Otherwise, this partial
    model will be assumed.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: Using a filter for updates
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To update or remove certain elements and fields of the OpenAPI document, you
    can use a filter. The OASFilter ([https://github.com/eclipse/microprofile-open-api/blob/master/api/src/main/java/org/eclipse/microprofile/openapi/OASFilter.java](https://github.com/eclipse/microprofile-open-api/blob/master/api/src/main/java/org/eclipse/microprofile/openapi/OASFilter.java))
    interface allows you to receive callbacks for various OpenAPI elements. It allows
    you to override the methods you care about. You can create an implementation of
    this interface and register it using the `mp.openapi.filter` configuration key.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example of what its definition would look like in `META-INF/microprofile-config.properties`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: A registered filter is called once for each model element. For example, the
    `filterPathItem` method is ...
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to the MicroProfile REST Client and its capabilities
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **MicroProfile REST Client** (**MP-RC**) provides an API for type-safe invocation
    on REST endpoints. It can be used from applications to perform remote invocations
    on other services.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: It leverages JAX-RS annotations on Java interfaces to describe the actual contract
    with remotes services. These interfaces are then used to create client proxies
    that hide much of the underlying HTTP communication.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: The MP-RC specification defines the requirements for leveraging the JAX-RS annotations
    on the Java interface, as well as MP-RC-specific annotations to augment behavior,
    including how incoming request headers should be propagated, how to augment JAX-RS
    behaviors using providers, exception mapping, CDI support, and integration with
    other MicroProfile specifications. We will look at MP-RC in more detail by starting
    with the definition of a type-safe endpoint interface.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: Defining the endpoint Interface
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To define the type-safe interface for an endpoint, we create a Java interface
    that leverages JAX-RS annotations to map interface methods to the REST endpoint
    they proxy. A basic example is illustrated in the following `WorldClockApi` interface:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: MicroProfile REST Client programmatic API usage
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'MP-RC supports both programmatic lookup and CDI injection approaches for usage.
    An example of a REST service making use of `org.eclipse.microprofile.rest.client.RestClientBuilder`
    to create a type-safe client for the `WorldClockApi` interface is listed in the
    following as `WorldClockUser.java`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `baseUri()` method is used to specify the server URI against which the
    `WorldClockApi` method paths are to be resolved. The `build()` method takes the
    Java interface of the type-safe client that is to be built. Additional `RestClientBuilder`
    methods include the following:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '`baseUrl(URL)`: Similar to `baseUri`, but takes a `java.net.URL` type.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`connectTimeout(long timeout, TimeUnit unit)`: The amount of time to wait to
    connect to the remote server. A value of 0 indicates having to wait forever.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`readTimeout(long timeout, TimeUnit unit)`: The amount of time to wait on reads
    of the remote server connection. A value of 0 indicates having to wait forever.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`executorService(ExecutorService executor)`: Used for async requests. We will
    return to this in the async section.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MicroProfile REST Client CDI usage
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'MP-RC type-safe interfaces may be injected as CDI beans. The runtime must create
    a CDI bean for each interface annotated with `@RegisterRestClient`. A CDI client
    injects bean created will include a qualifier, `@RestClient` , to differentiate
    use as an MP-RC injection point. The following update to our `WorldClockApi` interface
    illustrates the use of the `@RegisterRestClient` annotation:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: MicroProfile Config integration
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For CDI-defined interfaces, it is possible to use MicroProfile Config properties
    to define additional behaviors that are available via the `RestClientBuilder`
    API. Given our `io.pckt.restc.contract.WorldClockApi` interface, the following
    MicroProfile Config properties are available to control the generated proxy behavior:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '`io.pckt.restc.contract.WorldClockApi/mp-rest/url`: The base URL to use for
    this service, the equivalent of the `RestClientBuilder#baseUrl` method.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`io.pckt.restc.contract.WorldClockApi/mp-rest/scope`: The fully qualified class
    name to a CDI scope to use for injection; it defaults to `javax.enterprise.context.Dependent`.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`io.pckt.restc.contract.WorldClockApi/mp-rest/providers`: A comma-separated
    list of fully qualified provider class names to include in the client, the equivalent
    of the `RestClientBuilder#register` method or the `@RegisterProvider` annotation.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`io.pckt.restc.contract.WorldClockApi/mp-rest/providers/com.mycompany.MyProvider/priority`:
    This will override the priority of the `com.mycompany.MyProvider` provider for
    this interface.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`io.pckt.restc.contract.WorldClockApi/mp-rest/connectTimeout`: The timeout
    specified in milliseconds to wait to connect to the remote endpoint.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`io.pckt.restc.contract.WorldClockApi/mp-rest/readTimeout`: The timeout specified
    in milliseconds to wait for a response from the remote endpoint.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simplifying configuration keys
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since the default MP Config property names for a CDI interface can be quite
    long due to the inclusion of the interface package name, the MP-RC specification
    supports a way to simplify the property name prefix using the `configKey` attribute
    of the `@RegisterRestClient` annotation:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'With the `worldClock` configKey, the previous list of property names simplifies
    to the following:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '`worldClock/mp-rest/url`'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`worldClock/mp-rest/uri`'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`worldClock/mp-rest/scope`'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`worldClock/mp-rest/providers`'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`worldClock/mp-rest/providers/com.mycompany.MyProvider/priority ...`'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dealing with client headers
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's say you want to specify credentials in the HTTP authorization header to
    a secure remote service, but you do not want to have a string `authHeader` parameter
    in the client interface method. The MP-RC `@ClientHeaderParam` annotation can
    be used to specify HTTP headers that should be sent without altering the client
    interface method signature.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example illustrates two uses of the `@ClientHeaderParam` annotation
    to provide a `User-Agent` HTTP header in a variation of the `WorldClockApi` interface:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'It is also possible to add or propagate headers in bulk using a `ClientHeadersFactory`
    implementation:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the preceding code snippet, the `incomingHeaders` and `clientOutgoingHeaders`
    parameters are used as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '`incomingHeaders`: Represents the map of headers for the inbound request'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`clientOutgoingHeaders`: Represents the read-only map of header values specified
    on the client interface, the union of header values from `@ClientHeaderParam`,
    `@HeaderParam`, and so on'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `update` method should return a `MultivaluedMap` that contains the headers
    to merge with the `clientOutgoingHeaders` map for the complete map of headers
    to be sent to the outbound request. Providers such as filters, interceptors, and
    message body writers could still modify the final map of headers prior to sending
    the HTTP request.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: To enable a `ClientHeadersFactory`, the client interface must be annotated with
    the `@RegisterClientHeaders` annotation. If this annotation specifies a value,
    the client implementation must invoke an instance of the specified `ClientHeadersFactory`
    implementation class. If no value is specified, then the client implementation
    must invoke `DefaultClientHeadersFactoryImpl`. This default factory will propagate
    specified headers from the inbound JAX-RS request to the outbound request – these
    headers are specified with a comma-separated list using the MicroProfile Config
    property, `org.eclipse.microprofile.rest.client.propagateHeaders`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Provider registration for advanced usage
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `RestClientBuilder` interface extends the `Configurable` interface from
    JAX-RS, allowing a user to register custom providers while it is being built.
    The behavior of the providers supported is defined by the JAX-RS Client API specification.
    An MP-RC implementation will support `ClientResponseFilter`, `ClientRequestFilter`,
    `MessageBodyReader`, `MessageBodyWriter`, `ParamConverter`, `ReaderInterceptor`,
    and `WriterInterceptor` from JAX-RS.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: For the `ClientResponseFilter` and `ClientRequestFilter` interfaces that have
    a `ClientRequestContext` parameter in their `filter` method, MP-RC implementations
    add an `org.eclipse.microprofile.rest.client.invokedMethod` property, the value
    of which is the `java.lang.reflect.Method` object ...
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Provider priority
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Providers may be registered via both annotations and `RestClientBuilder`. Providers
    registered via a builder will take precedence over the `@RegisterProvider` annotation.
    The `@RegisterProvider` annotation priority value takes precedence over any `@javax.annotation.Priority`
    annotation on the class. Provider priorities can be overridden when using the
    register methods on the `RestClientBuilder` interface as it allows for priority.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Feature registration
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If the type of provider registered is a JAX-RS `Feature`, then the priority
    set by that `Feature` will be part of the builder as well. Implementations maintain
    the overall priority of registered providers, regardless of how they are registered.
    `Feature` will be used to register additional providers at runtime, and may be
    registered via `@RegisterProvider`, configuration, or via `RestClientBuilder`.
    `Feature` will be executed immediately. As a result, its priority is not taken
    into account (features are always executed).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Default providers
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'MP-RC implementations must provide a minimum set of providers, including the
    following:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '`*/json` types:'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JSON-P, `javax.json.JsonValue`
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JSON-B, `javax.json.bind`
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*` types:'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`byte[]`'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.lang.String`'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.io.InputStream`'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.io.Reader`'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`text/plain` types:'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.lang.Number and subtypes`'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int, long, float and double`'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.lang.Character and char`'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.lang.Boolean and boolean`'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exception mapping
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'MP-RC provides support for mapping an invocation response into an exception
    via the `org.eclipse.microprofile.rest.client.ext.ResponseExceptionMapper` interface:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Consider the following ...
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Default exception mapping
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Each implementation provides a default `ResponseExceptionMapper` implementation
    that will map and invoke a response to `javax.ws.rs.WebApplicationException` when
    the response status code is >= 400\. It has a priority of `Integer.MAX_VALUE`,
    and is meant to be used as a fallback whenever an error is encountered. This mapper
    will be registered by default to all client interfaces, but this can be disabled
    by setting an MP Config property, `microprofile.rest.client.disable.default.mapper`,
    to `true`. It can also be disabled on a per-client basis by using the same property
    when building the client:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Async support
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'MP-RC supports asynchronous method invocations. A client interface method is
    asynchronous when the return type of the method is of the `java.util.concurrent.CompletionStage<?>`
    type. An alternative version, called `WorldClockApiAsync.java`, of the `WorldClockApi`
    interface that declares an asynchronous method is as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Summary
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned about two Eclipse MicroProfile specifications,
    namely, Eclipse MicroProfile OpenAPI and Eclipse MicroProfile REST Client. The
    former provides a specification for generating OpenAPI-compliant documentation
    for your microservices, and the latter supplies a specification for calling REST
    endpoints in a type-safe manner. In this chapter, we covered the specific capabilities
    of these specifications, provided some example code, and supplied pointers on
    how to get further information about these specifications. You have learned the
    features and capabilities of the Eclipse MicroProfile OpenAPI and Eclipse MicroProfile
    REST Client specifications, how to use their annotations and programmatic interfaces,
    and how you could incorporate them into your applications.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了两个Eclipse MicroProfile规范，即Eclipse MicroProfile OpenAPI和Eclipse MicroProfile
    REST Client。前者提供了一个规范，用于为您的微服务生成符合OpenAPI的文档，后者以类型安全的方式提供了调用REST端点的规范。在本章中，我们介绍了这些规范的具体功能，提供了一些示例代码，并提供了关于如何获取有关这些规范的更多信息的指针。您已经了解了Eclipse
    MicroProfile OpenAPI和Eclipse MicroProfile REST Client规范的功能和能力，以及如何使用它们的注释和编程接口，以及如何将它们整合到您的应用程序中。
- en: In the next chapter, we will discuss and delve into the open source implementations
    of Eclipse MicroProfile that currently exist on the market.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论并深入研究目前市场上存在的Eclipse MicroProfile的开源实现。
- en: Questions
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Do you need to do anything to get information supplied to the `/openapi` endpoint?
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您需要做些什么才能获得提供给`/openapi`端点的信息？
- en: Can I enhance OpenAPI output with just one or two extra annotations?
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我可以用一两个额外的注释增强OpenAPI输出吗？
- en: What is the point of using static OpenAPI files?
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用静态OpenAPI文件有什么意义？
- en: Do I need the REST endpoint microservice I want to use to provide the MP-REST
    interface?
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我需要REST端点微服务来提供MP-REST接口吗？
- en: How do you externalize the base URL for a type-safe interface?
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何将基本URL外部化为类型安全接口？
- en: What if I need to propagate incoming request headers?
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我需要传播传入的请求头怎么办？
