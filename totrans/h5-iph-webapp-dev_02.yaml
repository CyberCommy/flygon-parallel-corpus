- en: Chapter 2. Integrating HTML5 Video
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Media distribution is essential for any web application; delivering rich experiences
    that alter the user's perception. Many times we are asked to put a still image
    on a site, and other times we are asked to include video galleries that allow
    the user to switch videos easily through some sort of unique navigation. Previously,
    we were able to do this with Flash and other plugin based technologies, but with
    the wide support of HTML5 video, we now have the ability to deliver video without
    the condition of downloading a plugin.
  prefs: []
  type: TYPE_NORMAL
- en: One thing to keep in mind is that HTML5 video and audio share the same specification.
    This is because they are both considered a media element ([http://www.whatwg.org/specs/web-apps/current-work/multipage/the-video-element.html#media-element](http://www.whatwg.org/specs/web-apps/current-work/multipage/the-video-element.html#media-element)).
    What this means is that both video and audio share some attributes and methods,
    making it easier to implement them within our applications.
  prefs: []
  type: TYPE_NORMAL
- en: Either way, let's get going by learning how we can configure our server to deliver
    our videos correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Configuring our server for video distribution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing HTML5 video
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Listening to HTML5 video events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a thorough JavaScript video library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customizing HTML5 video controls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring the server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before implementing our video, we need to make sure our server knows what media
    types we will be serving. Doing this now helps to avoid headaches later on when
    we don't know why we are getting network errors. So let's get to it.
  prefs: []
  type: TYPE_NORMAL
- en: Video formats
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, we need to know what file types we will be serving up. In our examples
    we will be using MP4, but it's always a good idea to allow what is supported.
    Make sure you have WebM, OGV, and MP4 formats for your videos. But first, before
    we go on, let's side step and learn a little bit about these formats.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We're not going to get too deep into explaining the different types that are
    widely supported, but keep in mind that Theora, WebM, and H.264/MPEG-4 are the
    most widely supported formats. Both Theora and WebM are free, with WebM development
    being supported by Google. The implementation for Theora in browsers has lagged
    due to worry about patents, while WebM has been widely supported by Mozilla Firefox,
    Google, and Opera due to its royalty-free and open video compression features.
  prefs: []
  type: TYPE_NORMAL
- en: Things get a bit hairy when it comes to H.264\. Although a great format for
    having high quality, good speed, and being a standard for video compression, patents
    encumber it. For this reason, it has lagged behind in support in popular browsers
    for a long time. Eventually, each browser came to support this format, but not
    without controversy.
  prefs: []
  type: TYPE_NORMAL
- en: Video format directives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, depending on the server type, we need to include specific directives
    to allow our file types. In this example, we are using an Apache server, thus
    the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The previous code would be added to either an `.htaccess` file on the server
    or to the `httpd.conf` file. Either way, the `AddType` directive informs the server
    what types it should and can serve. So when we go line by line, we can see that
    we are adding the `video/ogg` type with extension `.ogv`, and we do this for MP4
    and WebM.
  prefs: []
  type: TYPE_NORMAL
- en: Taking these initial steps helps us to avoid any network issues when we go ahead
    and implement video on our site using HTML5\. If you're curious how we use these
    types, don't worry, that's exactly what we'll be going over in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: A simple HTML5 video
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've been dying to do something cool in our web application, so let's get to
    it. Let's start out by including a video on our site in the simplest manner possible,
    and without any complicated interactions!
  prefs: []
  type: TYPE_NORMAL
- en: Single video format
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, let's open up our `index.html` file located in the `video` subdirectory
    of the `Chapter 2` project. If you skipped the first chapter, don't worry about
    it, the `Chapter 2` source files follow along and help keep you going.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have our `index.html` file, we want to include the `video` element
    within our content area, right after the `<header>` element. This is simple, we
    can do it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The previous code works similar to an image element. We define a `src` attribute
    that instructs the browser where to find the video, and then we define a `controls`
    and `preload` attribute, which directs the browser to display default native controls
    and to preload the video. Simple, eh?
  prefs: []
  type: TYPE_NORMAL
- en: Supporting multiple formats
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is all we need to put video on our site, but of course, things aren''t
    always so simple. As we discussed earlier, browsers can support one or none of
    the formats that we specify. Of course, right now we have good browser support,
    but we want to make sure that our application is solid, so we need to make sure
    that we deliver the appropriate file. To do this, we can modify the previous code
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have introduced a new attribute, `poster`. The `poster` attribute is
    an image we show at the beginning of the video or in cases where the video doesn't
    load. Things now get a bit complex when we move the source element inside of the
    `video` element. But, if we check everything out, we're basically defining multiple
    source videos and their types. The browser will then choose the appropriate one
    to display. What might confuse you is the paragraph element containing the `Fallback
    Content` text. This is here if everything else fails and/or if the browser does
    not support the HTML5 video.
  prefs: []
  type: TYPE_NORMAL
- en: 'If this is a bit confusing, don''t worry about it too much because iPhone''s
    mobile Safari supports MP4 and is honestly all you need for your applications.
    So if we want to keep it simple, we can use the following code for our iPhone
    applications, and this is exactly what we do in this book:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have a simple video playing in our application, we might want to
    pick up on the events of our video.
  prefs: []
  type: TYPE_NORMAL
- en: Listening to HTML5 video events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's very likely that you will want full control of your application, or at
    least monitor what may be going on. You will usually find yourself attaching events
    or listening to them for various reasons. From tracking to enhancing an experience,
    events are how we can drive interactivity on the page. With HTML5 video, we can
    use the native browser to monitor the status of the video from start to finish.
    You have the opportunity to listen for when a video has finished loading and when
    the user has paused a video.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s review the events that are available to us. What you will find is that
    the events we use with videos can also be transferrable for audio. This is because,
    as we''ve learned previously, both video and audio elements are categorized as
    media elements in the HTML5 specification. Here is a table of events that are
    available to us:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Event Name | Condition |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `loadedmetadata` | The duration and dimensions of the media resource have
    been determined. |'
  prefs: []
  type: TYPE_TB
- en: '| `loadeddata` | Media data can now be rendered for the first time. |'
  prefs: []
  type: TYPE_TB
- en: '| `canplay` | Playback of the media data can resume. |'
  prefs: []
  type: TYPE_TB
- en: '| `seeking` | The seeking attribute of the media resource has been set to true.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `seeked` | The seeking attribute of the media resource has been set to false.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `play` | The element is not paused. This is fired when the `play()` method
    has returned or when the `autoplay` attribute has caused the element to begin
    playback. |'
  prefs: []
  type: TYPE_TB
- en: '| `ended` | The end of the media resource was reached and playback has stopped.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `pause` | The `pause()` method has returned and the element has been paused.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `timeupdate` | The playback position of the media resource has changed in
    some way. |'
  prefs: []
  type: TYPE_TB
- en: '| `volumechange` | Fired when either the volume or muted attribute has changed.
    |'
  prefs: []
  type: TYPE_TB
- en: There are more events that are defined by the specification, however these are
    the events we will listen to from our previous simple implementation. So let's
    get started.
  prefs: []
  type: TYPE_NORMAL
- en: Video markup review
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, open your `index.html` file inside of the `video` directory. In this
    file, you have to make sure your content looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Don't pay attention to the ellipsis, these are just in there to make the code
    shorter in the text. What you want to make sure of is that you have the simple
    `<video>` element implementation from the last section.
  prefs: []
  type: TYPE_NORMAL
- en: Attaching video events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now the fun starts. Let's start extending our JavaScript to include the listeners.
    Let's open the `App.Video.js` file located in the `/js` directory under the `App`
    folder. If you haven't been following along from our architecture chapter, don't
    worry, what's important for you to understand here is that we have created a structure
    for our applications and that the `App.Video.js` file will contain all functionality
    for the video application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Find the constructor for the `App.Video` class. This should be on line 16 of
    your text editor, and should currently look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Again, as a review we are passing in an object that we call `options` into our
    constructor. From here, we create a property called `options` that is for that
    instance of `Video`, and this property will get set to an extended or merged version
    of the options and defaults using Zepto's extend method. Then, we cache the element
    that was sent via the merged options. This might be a bit confusing, but it is
    a very well recognized pattern in JavaScript applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we have verified that our constructor exists and is doing fine, we now
    want to add the previous listeners. We can easily do this using the native `addEventListener`
    method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: There are a couple of things to note here. First, we are using `this.options.element`
    instead of the cached version `this.$element`. We do this because we actually
    want the element and not a `Zepto` object. Second, we are calling `addEventListener`
    and passing it two parameters. The first parameter is a string that defines the
    event we want to listen to. The second parameter is a callback function, which
    gets called every time that the event we specified in parameter one fires.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that we are using the `console.log()` method. It is similar to `alert()`
    except without all the annoyances. It helps debug better and outputs to a console
    that lets us keep track of all our log output. Using this method is a good way
    of debugging our applications and testing out functionality before going further.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your constructor should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Initializing our video
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have a preliminary video class defined, we need to initialize it.
    So let''s go ahead and open up `main.js`, where our initialization code should
    be located. It should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We created this in the previous chapter, but let's go over it briefly. Here
    we are creating a closure, passing it the `window` and `document` objects. Inside,
    we set the interpreter to read our code strictly. We then create an instance of
    the overall `App` class and then expose it to the `window` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need to add the initialization of the `Video` class. To do this, let''s
    put the following snippet of code after we declare a new instance of `App`, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This snippet creates a new instance of the `App.Video` class or the `Video`
    class, and passes in a simple object containing the element. The way we retrieve
    an element is through the use of the `getElementsByTagName` method attached to
    the `document` object. We tell the method to look for all the video elements.
    The interesting part is `[0]`, which tells the results of the lookup to only get
    the first one in the array that is returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we load our page and test the video, we should have the log output we defined
    earlier in our console, similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Initializing our video](img/1024_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Video log output
  prefs: []
  type: TYPE_NORMAL
- en: We've got the preliminary aspects of our `Video` class going, from events to
    initialization. However, we need to tidy it up a bit if we are going to make it
    reusable for our application, and if we ever want to extend its functionality.
    So let's take some time creating a fully functional JavaScript video library that
    will work in our iPhone web applications.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a JavaScript video library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the moment, we have a very simple `Video` class that caches an element and
    then attaches multiple events that are defined by the media element specification
    for HTML5\. We have defined the essentials of a video player and now need to abstract
    it a bit further so it can be reused and managed much better. Following some conventions
    and creating a flexible framework will help us move faster and more effectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s think about some things we may want from this class:'
  prefs: []
  type: TYPE_NORMAL
- en: An events method that attaches the proper events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Callback methods that can be defined, for example, `onPlay`, `onPause`, and
    `onEnded`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Public methods that can be called from outside the instance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chainable methods similar to jQuery where you can call one method after another,
    for example, `fadeIn().fadeOut().show().hide()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Having a list of items that abstract the behavior of a class is a step in the
    right direction for establishing a solid framework or library. Now let's start
    by creating callbacks.
  prefs: []
  type: TYPE_NORMAL
- en: Centralizing our events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, let's tackle how we attach the events for our `Video` class. Previously,
    we added these events to the constructor, and although that is a fine technique,
    it can definitely be improved by specifying a function that handles the attachment
    of events onto an instance of a `Video` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s create a private method called `attachEvents` in the `Video` class
    that can only be accessed within the `App.Video` closure or IIFE. When we create
    our method `attachEvents`, we should just place all our event handlers into it.
    We then want to call the `attachEvents` method after we initialize `this.$element`.
    When you''re done doing this, your code should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the previous code, the `attachEvents()` function will contain our event handlers
    created earlier. For the sake of brevity, I'm omitting them for now.
  prefs: []
  type: TYPE_NORMAL
- en: Now, if we run this code we'll most likely run into a couple of errors. This
    is actually normal and is known as a scope issue. In order to fix the problem,
    first we'll sidestep to understand what's going on behind the scenes.
  prefs: []
  type: TYPE_NORMAL
- en: Scope in JavaScript
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you're new to JavaScript, scope will most likely confuse you sooner or later.
    If you're at an intermediate or advanced level in JavaScript, you might still
    have scope issues. This is completely normal and is something that we all come
    across. Either way, let's take our current `Video` class and analyze it to understand
    scope in context.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript has function-level scope, this means that every time a new function
    is created, we create a new scope. Scope can be quite confusing, but with practice
    it becomes easier. For now think of scopes as a reference to your current position,
    aware of itself and its environment, but unaware of newly created scopes inside
    it. If it sounds confusing, it can be when you get started. But let's go over
    some code to gain a better understanding.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s start with the global scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In this example, a stripped down version of `App.Video`, we can see that the
    global scope is around the closure. When we create a closure, a new scope is created.
    The cool thing here is that anything outside of the closure can get accessed.
    So when we do `console.log` inside the closure, we should get back `10`.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever you create a new function scope, you can pass it parameters that essentially
    namespace the value you're sending. In this case, we pass in `Zepto` and we tell
    the new function scope to define the dollar sign as an instance of `Zepto` inside
    that scope. Hopefully that explains scope a bit more clearly, if not, don't worry
    about it; it does take time and patience to understand this concept.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the problem with our event handlers is the fact that the new function scope,
    inside of `attachEvents`, does not have a reference to `this.options`. The keyword
    `this` is relative to the window object because of the new scope. The reason it
    doesn''t have a reference is because our constructor is a completely different
    scope, and the two are not speaking with each other. To fix this problem, we can
    use the `.call()` method, which will change the reference of the `this` keyword
    to reflect the `Video` function scope. It can be done by changing the call of
    `attachEvents` like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: If you run your code now, you should not get any errors. If you do, take a look
    at the finalized version of the code in order to do a comparison and figure out
    the issue.
  prefs: []
  type: TYPE_NORMAL
- en: Exposing functionality
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Later on in this chapter, we will be exploring custom user interfaces that help
    us override the default functionality of a video player. However, in order to
    do this we need to make sure some functionality is exposed. In JavaScript, in
    order to make methods public outside of the closure, we need to attach methods
    to the prototype of `class`—in this case, `Video`.
  prefs: []
  type: TYPE_NORMAL
- en: We can already see that we have two methods that are exposed within all our
    classes; these include `getDefaults` and the overriding function `toString`. Let's
    start extending the prototype by adding the `play`, `pause`, `stop`, `mute`, `unmute`,
    and `fullscreen` methods.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: I'm sure you have noticed the lack of code in these methods, and that's fine.
    What we want to understand is that we can extend the `Video` prototype, and that
    we can add chaining to our methods by returning the instance with the `return
    this` line.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start adding functionality to our methods, beginning with `play`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we are getting the element we''ve cached in the constructor of `Video`
    by calling the `play` method. You might be wondering where this `play` method
    is coming from? Well, the HTML5 specification defined a `play` method for media
    elements, including video and audio. Thus, we can tap into this method using `this.element.play()`.
    We can do the same with the `pause` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, we have a method defined by the HTML5 specification for pausing a media
    element. Things get a bit confusing when we define a `stop` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: It's the same as previous; we actually haven't made any changes. Let me explain,
    the specification does not define a `stop` method, so it's up to us to create
    one so that we can provide that functionality. But it's not too difficult because
    we've defined a `pause` method that does a similar action. So all we need to do
    is call `this.pause()`, because this is an instance of `Video` and we have a `pause`
    method defined. The neat thing here is that we don't need to return `this`, because
    the pause method already returns `this`, and so all we need to do is return the
    results of calling the `pause` method. I know it's a bit confusing but over time,
    if this is the first time you're doing this, it will become clear.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, on to our `mute` and `unmute` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The only difference in these methods is that we are setting a property on the
    video element to `false`. In this case, we are setting the muted property to either
    `true` or `false`, depending on what method you call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is where things get a bit complicated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This is a bit more complicated, and probably a bit frustrating. Trust me, many
    within the industry are feeling the pain. What we need to understand here is that
    the browser we are dealing with, Safari, runs on an engine called WebKit—an open
    source web browser engine.
  prefs: []
  type: TYPE_NORMAL
- en: WebKit is extremely popular and widely supported. The issue is that while it
    does a great job at implementing the latest and greatest features, many of these
    are experimental and thus, they have a prefix added to them. We see this a lot
    in CSS (Cascading Style Sheets) using `–webkit`. But we also face the same problem
    in JavaScript, `webkit[standardMethodName]`.
  prefs: []
  type: TYPE_NORMAL
- en: While this may be awesome, we need to make sure that we have backward compatibility
    for newer versions that strip out that prefix. This is why, in the previous method,
    we do a check on the standard method name, and if it doesn't exist, we use the
    `-webkit` prefix. Otherwise, we use the standard version.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating callbacks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Callbacks are quite useful in any library or framework, and you''ve probably
    already seen something like it using jQuery or some other popular framework. In
    essence, a callback is a method that gets called once the method has completed.
    For example, in the `Zepto` method, `fadeout` accepts two parameters, the first
    being the speed, and the second parameter is a function that gets called when
    the fading has completed. This can be seen as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The second parameter in the previous code is not only a callback function,
    but also an anonymous function. An anonymous function is just a function without
    a name. In this case, it is executed every time the `fadeOut()` effect is finished.
    We can rewrite the previous code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Since we have created a method called `someFadeOutFunc`, when `fadeOut` is complete
    we'll just call that function instead of creating a new one. This is more efficient
    and manageable from an architecture standpoint.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step in the process of creating callbacks is to define where we may
    want callbacks in our code. In this case, we may want a callback for each action
    taken in the video player, so we''ll create the following callbacks:'
  prefs: []
  type: TYPE_NORMAL
- en: '`onCanPlay`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onSeeking`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onSeeked`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onEnded`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onPlay`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onPause`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onLoadedData`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onLoadedMetaData`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onTimeUpdate`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onFullScreen`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ok, so now that we know which callbacks we want in our code, let''s implement
    them in the constructor, right before the `attachEvents` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: What we've done here is attached a property, known as `callbacks`, onto an instance
    of `Video`. This property contains an object that has key/value pairs for each
    callback we want to implement, with the value being an empty anonymous function.
  prefs: []
  type: TYPE_NORMAL
- en: Extending callbacks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Although we can have our callbacks within the class, the problem is that they
    are not extensible, meaning the developers using your `Video` class won''t be
    able to extend your callbacks. In order to make them extensible, we need to put
    them within our `_defaults` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The drawback is that now we would need to use `this.options.callbacks` in order
    to access the callback we want. This can be easily fixed by doing the following
    in our constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This will still allow us to access the callback, but only from the extended
    object.
  prefs: []
  type: TYPE_NORMAL
- en: Using callbacks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that we have our callbacks, and have made them extensible, we can go in
    and integrate them into our event handlers. But first, we need to make our event
    handlers as private methods in this `Video` class and call our custom callbacks
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, we have our callbacks fully integrated into our library. Now,
    we just need to call them by modifying the `attachEvents` handler as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: There are a couple of concepts being implemented here. First, we've replaced
    `console.logs` with the actual private methods that we have defined previously.
    Second, we used the `call` method to change the scope of the `private` method
    by passing in `that`, then we sent in `event` and `element` as parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Tying it all up
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have everything we need, such as event handlers, exposed functionality, callbacks,
    and even chainable methods. That's all good, but now we need to make it work.
    This is where the magic comes in.
  prefs: []
  type: TYPE_NORMAL
- en: 'To verify, your `Video` class should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Please note that the ellipsis in the previous code denote that there should
    be functionality. Due to page count limitations, we can only showcase a brief
    summary of the code up to this point. If you need to see what has been done, please
    review the previous sections or checkout the source code with this book.
  prefs: []
  type: TYPE_NORMAL
- en: If your file looks like this, perfect! If it doesn't look quite like this, don't
    worry about it, this is why we have the source code attached with this book. At
    this point, we're ready to initialize this library on our page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s open up our `main.js` file; the file should be located under the `js`
    directory. We need to make the following addition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s go through this quickly. First, we create a new instance of `App.Video`,
    passing in one parameter— a simple object. Second, the object we are passing in
    contains two objects: the `video` element we want on the page, and a callbacks
    object that overrides defaults. The first parameter is using the built in method
    `getElementsByTagName` to get all the instances of the `video` element, and then
    we get the first one found using `[0]`. This is because that method returns an
    array. The second parameter, `callbacks`, contains the function callbacks we want
    to be called on this instance of `App.Video`. All we want to do in these methods
    is log out the method being called.'
  prefs: []
  type: TYPE_NORMAL
- en: From here on, when the instance is initialized the `Video` library we've defined
    will merge the simple object we've passed in and take it from there. Almost like
    magic, except we've created it.
  prefs: []
  type: TYPE_NORMAL
- en: 'One last item to take care of is to make sure we only initialize a video when
    we are on the video page. If we are on a non-video page in our application, this
    code will produce an error. This is because there are no video elements and we
    have not added error detection. This is a good thing to have, but will not be
    covered in this book. So, let''s do the following in `main.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code, we are wrapping our initialization code within an `if`
    statement, checking to make sure that we are on the video page. The way we do
    a check is by using the built in method on the document object called `querySelector`.
    This method accepts a CSS type selector, in this case we are sending the `video`
    selector, telling it to get all the instances of a `video` element. If the result
    coming back is not null, then we initialize.
  prefs: []
  type: TYPE_NORMAL
- en: Now we don't need to do anything with the markup, this code will run and we
    should be good. If for some reason you come up with any errors, please take a
    look at the source code provided with this book. Next, let's consider overwriting
    the default controls of this video player to give us more control over the functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing HTML5 video controls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We probably want more input into the video controls, from styling to video
    functionality, such as adding a stop button. In order to do this we need to modify
    our markup a bit. We should do the following with the video:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'All we did here was add a class containing `div` around the `video` element
    and added a class of `video-container` to it. Now we want to add some responsive
    styling to the `video` element, so let''s open up `video.css` and add the following
    styles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The first selector will apply to all the `video` elements on the page, and we
    are telling each element to have a width of 100 percent relative to its container,
    but to only have a max width of `640px`. The margin property helps it center itself
    on the page or to the container. The next selector, `video-container`, just specifies
    the width to be 100 percent. This styling will resize the player accordingly;
    you can check it out by resizing your browser.
  prefs: []
  type: TYPE_NORMAL
- en: For this example, we'll use basic controls using the anchor element. Keep in
    mind that you can use any sort of styling or markup to style your controls, just
    remember that we have exposed our video playback in our `Video` class, so to keep
    it short and simple, we'll just demonstrate how you can do this using the anchor
    element.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our `video-container` dive, we want to append the following markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The previous markup is what we will be using for our controls. They are pretty
    straightforward, but let's review a couple of decisions that were made here. One,
    we have a surrounding `div` with a class of `video-controls` to help define where
    all our controls will exist. Two, each type of control is prefixed with `vc`,
    standing for video controls. Three, in this example we have four types of controls,
    namely a state, track, volume, and full screen control. The final point is that
    some of these controls have show/hide functionality, for example, play and pause
    should only show when the others cancel out.
  prefs: []
  type: TYPE_NORMAL
- en: 'For styling, we can add the following styles to the `video.css` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In this bit of styling, we self-contain all video control styling to the `video-controls`
    class. This helps in maintaining styles in a modular pattern. Again, following
    responsive design principles, we tell the controls to have a width of 100 percent.
    Then, each type of control is set to display as inline-blocks, similar to `float`.
    Lastly, we tell all default controls that are not supposed to appear initially
    to have a display of none. Now, we need to add interactivity to our controls.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s create an `App.VideoControls` class that follows our entire framework:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, there''s not much difference here. The only thing is that we
    now have an `init` method that gets called. This is to separate out initialization
    functionality elsewhere so that the constructor is not completely populated with
    code. Now we need to add the following defaults:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Just as a review of these defaults, the first default is a features array, allowing
    the developer tapping into this code to customize what we need initialized. The
    second default keeps the state of the controls, namely play, pause, and so on.
    The third is a state specifically for sound. The classes default allows us to
    use custom classes, thus the developer using this `videocontrols` class isn't
    limited to the classes we've defined in the markup. The last is an events default
    that defines the custom events we want to be dispatched. By including it in our
    defaults, the developer can now customize these as well.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can notice, a lot goes into building a video player that can be reused
    and implemented correctly across a web application of any kind. Putting effort
    does help out in the end, although it is very difficult at the beginning. Now
    we can add and remove functionality in a much more modular way.
  prefs: []
  type: TYPE_NORMAL
- en: Due to the fact that there's a lot of code that goes into creating custom controls
    that mimic those in native controls, we've decided to leave the rest of the functionality,
    including show/hide and triggering custom events, in the source code for your
    review. Don't worry though, everything is commented and if you do have questions,
    I encourage you to e-mail me or ask your fellow colleagues for help.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we want to implement the communication between the controls and the video
    player. But first, we need to clean the `main.js` file a bit. So, let''s remove
    the following code from `main.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: We don't want this code in `main.js` because it will be shared among all the
    applications built in this book, so what we need to do is extrapolate it. For
    this reason, we have created another JavaScript file named `App.VideoController.js`
    in our `js/App` directory. This file is also included with the source code of
    this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Please open the `App.VideoController.js` file included with this book, and
    find the `initControls` method; it should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Let's briefly review what is going on in this method to understand it better.
    First, we are telling our `video` element to hide its controls. This is done by
    removing the `controls` attribute. Then we cache our `controls` div in `controlsEle`.
    Next, we initialize our `App.VideoControls` class and pass it in the cached `controls`
    div. Finally, we add listeners to the cached video controls and listen to the
    custom events that we have defined in our defaults of `App.VideoControls`. These
    listeners then call the methods we have exposed in `App.Video` by telling the
    instance, `video`, to run the appropriate function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last issue we need to take care of is initializing this whole program.
    Since we removed the initialization in `main.js`, we need to start it elsewhere.
    The best place would be on the specific `index.html`, which would be `video/index.html`.
    So, let''s open up this file and include the following script at the bottom of
    the page, right after the inclusion of `main.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This was the last item to take care of. When we run our page, we should have
    a fully functional video player that runs off our customized controls.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Give yourself a big pat on the back, because you have accomplished quite a bit!
    Not only do you have a video player with customized controls, but you have built
    a solid video library that ties into the HTML5 specification and works on the
    iPhone. We have gone over the HTML5 specification for video integration, created
    a simple video player that used native controls, built a fully functional and
    modular video library, extended the video library with a controls class that customizes
    our experience, and finally created a controller class that hooks up both the
    video and the customized controls. On the way, we've taken some time to understand
    scopes in JavaScript, the prototype, and the usefulness of callbacks. If at any
    point you had some trouble with the concepts taught in this chapter, please review
    the source code with this book, and as always, practice makes perfect. The next
    chapter should be easier since we'll take the concepts we've learned here and
    apply them to audio.
  prefs: []
  type: TYPE_NORMAL
