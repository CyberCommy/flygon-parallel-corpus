- en: '*Chapter 1*: Creating a Game Window'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will set up a simple Win32 window and bind an OpenGL context
    to it. You will be using OpenGL 3.3 Core throughout this book. The actual OpenGL
    code is going to be very minimal.
  prefs: []
  type: TYPE_NORMAL
- en: Most OpenGL-specific code will be abstracted into helper objects and functions,
    which will allow you to focus on animation rather than any specific graphics APIs.
    You will write the abstraction layer in [*Chapter 6*](B16191_06_Final_JC_ePub.xhtml#_idTextAnchor104)*,
    Building an Abstract Renderer*, but for now, it's important to create a window
    ready to be drawn to.
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you should be able to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Open a Win32 window
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create and bind an OpenGL 3.3 Core context
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use glad to load OpenGL 3.3 Core functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enable vsynch for the created window
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand the downloadable samples for this book
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To follow along with the code in this book, you will need a computer running
    Windows 10 with a recent version of Visual Studio installed. All of the downloadable
    code samples are built using Visual Studio 2019\. You can download Visual Studio
    from [https://visualstudio.microsoft.com/](https://visualstudio.microsoft.com/).
  prefs: []
  type: TYPE_NORMAL
- en: You can find all of the sample code for the book on GitHub at [https://github.com/PacktPublishing/Game-Animation-Programming](https://github.com/PacktPublishing/Game-Animation-Programming).
  prefs: []
  type: TYPE_NORMAL
- en: Creating an empty project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Throughout this book, you will be creating code from scratch as much as possible.
    Because of this, there will be very few external dependencies. To get started,
    follow these steps to create a new blank C++ project in Visual Studio:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open Visual Studio and create a new project by going to **File**|**New**|**Project**:![Figure
    1.1: Creating a new Visual Studio project'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_1.1_B16191.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.1: Creating a new Visual Studio project'
  prefs: []
  type: TYPE_NORMAL
- en: 'You will see your project templates on the left-hand side of the window that
    pops up. Navigate to **Installed**|**Visual C++**|**Other**. Then, select **Empty
    Project**:![Figure 1.2: Creating an empty C++ project'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_1.2_B16191.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.2: Creating an empty C++ project'
  prefs: []
  type: TYPE_NORMAL
- en: Enter a project name and select a project location. Finally, click **Create**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 1.3: Specifying a new project name'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.3_B16191.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.3: Specifying a new project name'
  prefs: []
  type: TYPE_NORMAL
- en: If you have followed the preceding steps, you should have a new blank project.
    Throughout the rest of this chapter, you will add an application framework and
    an OpenGL-enabled window.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the application class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It would be difficult to maintain a cluttered window entry function. Instead,
    you need to create an abstract `Application` class. This class will contain some
    basic functions, such as `Initialize`, `Update`, `Render`, and `Shutdown`. All
    of the code samples provided for this book will be built on top of the `Application`
    base class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file, `Application.h`. The declaration of the `Application` class
    is provided in the following code sample. Add this declaration to the newly created
    `Application.h` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `Initialize`, `Update`, `Render`, and `Shutdown` functions are the life
    cycle of an application. All these functions will be called directly from the
    Win32 window code. `Update` and `Render` take arguments. To update a frame, the
    delta time between the current and last frame needs to be known. To render a frame,
    the aspect ratio of the window must be known.
  prefs: []
  type: TYPE_NORMAL
- en: The life cycle functions are virtual. Each chapter in the downloadable materials
    for this book has an example that is a subclass of the `Application` class that
    demonstrates a concept from that chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you will be adding an OpenGL loader to the project.
  prefs: []
  type: TYPE_NORMAL
- en: Adding an OpenGL loader
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is some external code that this chapter depends on, called `glad`. When
    you create a new OpenGL context on Windows, it's created with a legacy OpenGL
    context. The extension mechanism of OpenGL will let you use this legacy context
    to create a new modern context.
  prefs: []
  type: TYPE_NORMAL
- en: Once the modern context is created, you will need to get function pointers to
    all OpenGL functions. The functions need to be loaded with `wglGetProcAdress`,
    which returns a function pointer.
  prefs: []
  type: TYPE_NORMAL
- en: Loading every OpenGL function in this fashion would be very time-consuming.
    This is where having an OpenGL loader comes in; `glad` will do all this work for
    you. An OpenGL loader is a library or some code that calls `wglGetProcAdress`
    on the functions that the OpenGL API defines.
  prefs: []
  type: TYPE_NORMAL
- en: There are several OpenGL loaders available on Windows.; this book will use `glad`.
    `glad` is a small library that consists of only a few files. It has a simple API;
    you call one function and get access to all the OpenGL functions. `glad` has a
    web-based interface; you can find it at [https://glad.dav1d.de/](https://glad.dav1d.de/).
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: When using an X Windows system, such as many popular Linux distributions, the
    function to load OpenGL functions is `glXGetProcAddress`. As with Windows, there
    are OpenGL loaders available for Linux as well. Not all OSes need an OpenGL loader;
    for example, macOS, iOS, and Android don't need a loader. Both iOS and Android
    run on OpenGL ES.
  prefs: []
  type: TYPE_NORMAL
- en: Getting glad
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can get `glad` from [https://glad.dav1d.de/](https://glad.dav1d.de/), a
    web-based generator:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to the site, select **Version 3.3** from the **gl** dropdown, and select
    **Core** from the **Profile** dropdown:![Figure 1.4: Configuring glad'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_1.4_B16191.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.4: Configuring glad'
  prefs: []
  type: TYPE_NORMAL
- en: Scroll to the bottom and hit the **Generate** button. This should start downloading
    a ZIP file that contains all of the required code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The code presented in this book is forward compatible with OpenGL version 3.3
    or a more recent version. If you want to use a newer OpenGL version, such as 4.6,
    change the gl dropdown under API to the desired version. You will be adding the
    contents of this ZIP file to your main project in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Adding glad to the project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once `glad.zip` is downloaded, extract its contents. Add the following files
    from the ZIP file to your project. The directory structure does not need to be
    maintained; all of these files can be placed next to each other:'
  prefs: []
  type: TYPE_NORMAL
- en: '`src/glad.c`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`include/glad/glad.h`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`include/KHR/khrplatform.h`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These files will be included as normal project files—you don''t have to set
    up `include` paths—but that does mean that the contents of the files need to be
    edited:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `glad.c` and find the following #include:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`#include <glad/glad.h>`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Replace the `include` path with the relative path of `glad.h`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`#include "glad.h"`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, open `glad.h` and find the following #include:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`#include <KHR/khrplatform.h>`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Replace the `include` path with the relative path of `khrplatform.h`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`#include "khrplatform.h"`'
  prefs: []
  type: TYPE_NORMAL
- en: '`glad` should now be added to the project and there should be no compilation
    errors. In the next section, you will start implementing the Win32 window.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a window
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you will create a window. This means you will be using Win32
    API calls directly to open a window and control its life cycle from code. You
    will also set up a debug console that can run alongside the window, which is useful
    for viewing logs.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: An in-depth discussion of the Win32 API is beyond the scope of this book. For
    additional information on any of the Win32 APIs, refer to the Microsoft Developers
    Network (MSDN) at [https://docs.microsoft.com/en-us/windows/win32/api/](https://docs.microsoft.com/en-us/windows/win32/api/).
  prefs: []
  type: TYPE_NORMAL
- en: To make logging a bit easier, two windows will be open at the same time in debug
    mode. One will be the standard Win32 window, and the other will be a console window
    for viewing logs. This can be achieved by setting the linker conditionally. In
    debug mode, the application should link to the console subsystem. In release mode,
    it should link to the window subsystem.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the linker subsystem can be done through the project's properties or
    in code using a `#pragma` comment. Once the subsystem is set to the console, the
    `WinMain` function can be called from `main`, which will launch a window that
    is attached to the console.
  prefs: []
  type: TYPE_NORMAL
- en: Additional linker actions, such as linking to external libraries, can be done
    from code, too. You will be using a `#pragma` command to link with OpenGL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start the window implementation by creating a new file, `WinMain.cpp`. This
    file will contain all of the window logic. Then, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to the beginning of the file. It creates `#define` constants
    that reduce the amount of code that is brought in by including `<windows.h>`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The window entry function and the window event processing function both need
    to be forward declared. These are the two Win32 functions that we will need to
    open a new window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Use a `#pragma` comment to link to `OpenGL32.lib` in code, rather than going
    through the project''s properties window. Add the following code to `WinMain.cpp`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now, a few OpenGL functions need to be declared. Creating a modern OpenGL context
    is done through `wglCreateContextAttribsARB`, but there is no reference to this
    function. This is one of the functions that needs to be loaded through `wglGetProcAddress`,
    as it's an extension function.
  prefs: []
  type: TYPE_NORMAL
- en: The function signature of `wglCreateContextAttribsARB` can be found in `wglext.h`.
    The `wglext.h` header is hosted by Khronos and can be found online in the OpenGL
    registry at [https://www.khronos.org/registry/OpenGL/index_gl.php](https://www.khronos.org/registry/OpenGL/index_gl.php).
  prefs: []
  type: TYPE_NORMAL
- en: 'There is no need to include the entire `wglext.h` header file; you will only
    need the function relevant to creating a modern context. The following code is
    directly copied from the file. It contains the declarations for the relevant `#define`
    constants and the function pointer types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The previous code defines a function pointer type for `wglCreatecontextAttribsARB`.
    In addition to this, there are `#define` constants that are needed to make an
    OpenGL 3.3 Core context. The samples for this book will have `vsynch` enabled,
    which can be done through `wglSwapIntervalEXT`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you will guess, this function needs to be loaded using OpenGL''s extension
    mechanism, too. It also needs two additional support functions: `wglGetExtensionStringEXT`
    and `wglGetSwapIntervalEXT`. All three of these functions are found in `wgl.h`,
    which is hosted by Khronos in the OpenGL registry linked previously.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of including `wgl.h`, add the following code to `WinMain.cpp`. The
    code defines function pointer signatures for `wglGetExtensionStringEXT`, `wglSwapIntervalEXT`,
    and `wglGetSwapIntervalEXT`, copied out of `wgl.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is required to work with OpenGL. It's common to copy the
    code instead of including these headers directly. In the next section, you will
    begin working on the actual window.
  prefs: []
  type: TYPE_NORMAL
- en: Global variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Two global variables are required for easy window cleanup: a pointer to the
    currently running application and a handle to the global OpenGL **Vertex Array
    Object** (**VAO**). Instead of each draw call having its own VAO, one will be
    bound for the entire duration of the sample.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, create the following global variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Throughout the rest of this book, there will be no other global variables. Global
    variables can make the program state harder to track. The reason these two exist
    is to easily reference them when the application is shutting down later. Next,
    you will start implementing the `WinMain` function to open a new window.
  prefs: []
  type: TYPE_NORMAL
- en: Opening a window
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, you need to implement the window entry function, `WinMain`. This function
    will be responsible for creating a window class, registering the window class,
    and opening a new window:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start the definition of `WinMain` by creating a new instance of the `Application`
    class and storing it in the global pointer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, an instance of `WNDCLASSEX` needs to be filled out. There isn''t anything
    special that goes into this; it''s just a standard window definition. The only
    thing to look out for is whether the `WndProc` function is set correctly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'A new application window should launch in the center of the monitor. To do
    this, find the width and height of the screen using `GetSystemMetrics`. Then,
    adjust `windowRect` to the desired size around the center of the screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'To figure out the size of the window, not just the client area, the style of
    the window needs to be known. The following code sample creates a window that
    can be minimized or maximized but not resized. To resize the window, use a bitwise
    OR (`|`) operator with the `WS_THICKFRAME` defined:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the desired window style is defined, call the `AdjustWindowRectEx` function
    to adjust the size of the client rectangle to include all the window dressing
    in its size as well. When the final size is known, `CreateWindowEx` can be used
    to create the actual window. Once the window is created, store a reference to
    its device context:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that the window is created, you will next create an OpenGL context. To
    do this, you first need to find the correct pixel format, and then apply it to
    the device context of the window. The following code shows you how to do this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'With the pixel format set, create a temporary OpenGL context using `wglCreateContext`.
    This temporary context is only needed to get a pointer to `wglCreateContextAttribsARB`,
    which will be used to create a modern context:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'A temporary OpenGL context exists and is bound, so call the `wglCreateContextAttribsARB`
    function next. This function will return an OpenGL 3.3 Core context profile, bind
    it, and delete the legacy context:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'With an OpenGL 3.3 Core context active, `glad` can be used to load all the
    OpenGL 3.3 Core functions. Call `gladLoadGL` to do this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'An OpenGL 3.3 Core context should now be initialized, with all of the core
    OpenGL functions loaded. Next, you will enable `vsynch` on the window. `vsynch`
    is not a built-in function; it''s an extension and, as such, support for it needs
    to be queried with `wglGetExtensionStringEXT`. The extension string for `vsynch`
    is `WGL_EXT_swap_control`. Check whether this is in the list of extension strings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'If the `WGL_EXT_swap_control` extension is available, it needs to be loaded.
    The actual function is `wglSwapIntervalEXT`, which can be found in `wgl.h`. Passing
    an argument to `wglSwapIntervalEXT` turns on `vsynch`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'There is just a little bit more housekeeping to do to finish setting up an
    OpenGL-enabled window. OpenGL 3.3 Core requires a VAO to be bound for all draw
    calls. Instead of creating a VAO for each draw call, you will create one global
    VAO that is bound in `WinMain` and never unbound until the window is destroyed.
    The following code creates this VAO and binds it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Call the `ShowWindow` and `UpdateWindow` functions to display the current window;
    this is also a good place to initialize the global application. Depending on the
    amount of work that the application''s `Initialize` function ends up doing, the
    window may appear frozen for a little bit:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'You''re now ready to implement the actual game loop. You will need to keep
    track of the last frame time to calculate the delta time between frames. In addition
    to game logic, the loop needs to handle window events by peeking at the current
    message stack and dispatching messages accordingly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'After the window events are processed, the `Application` instance needs to
    update and render. First, find the delta time between the last frame and this
    one, converting it into seconds. For example, a game that''s running at 60 FPS
    should have a delta time of 16.6 milliseconds, or 0.0166 seconds:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Rendering the currently running application needs just a little bit more housekeeping.
    Set the OpenGL viewport with `glViewport` every frame and clear the color, depth,
    and stencil buffer. In addition to this, make sure all OpenGL states are correct
    before rendering. This means that the correct VAO is bound, depth test and face
    culling are enabled, and the appropriate point size is set:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'After the current `Application` instance has updated and rendered, the back
    buffer needs to be presented. This is done by calling `SwapBuffers`. If `vsynch`
    is enabled, `glFinish` needs to be called right after `SwapBuffers`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s it for the window loop. After the window loop exits, it''s safe to
    return from the `WinMain` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: If you want to use a version of OpenGL other than 3.3, adjust the major and
    minor values in the `attribList` variable presented in Step 8\. Even though the
    `WinMain` function is written, you still can't compile this file; it would fail
    because `WndProc` was never defined. The `WndProc` function handles events such
    as mouse motion or resizing for a window. In the next section, you will implement
    the `WndProc` function.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the event handler
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to have a properly functioning window, or to even compile the application,
    at this point, the event processing function, `WndProc`, must be defined. The
    implementation here will be very simple, mostly focusing on how to destroy the
    window:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start implementing the `WndProc` function in `WinMain.cpp`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'When the `WM_CLOSE` message is received, you need to shut down the `Application`
    class and emit a destroy window message. Once the application is shut down, don''t
    forget to delete it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'When the destroy message is received, the window''s OpenGL resources need to
    be released. This means deleting the global vertex array object, and then deleting
    the OpenGL context:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The paint and erase background messages are safe to ignore since OpenGL is
    managing rendering to the window. If the message received isn''t one of the messages
    already handled, forward it to the default window message function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Now that you have written the windows event loop, you should be able to compile
    and run a blank window. In the following section, you'll explore the downloadable
    samples for this book.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the samples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All of the code presented in this book is available in the downloadable content
    for the book. There is one large sample, called `AllChapters`, which includes
    every sample in a single application. There is a `Bin` ZIP file that contains
    a pre-compiled executable of the `AllChapters` sample.
  prefs: []
  type: TYPE_NORMAL
- en: There are also individual folders for each chapter that contain multiple sub-folders.
    Every chapter contains `Sample00`, which is the code as it was written in the
    book with no additional content. The subsequently numbered samples add content.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `AllChapters` sample looks a bit different from the samples in the individual
    chapter folders. This application uses Nuklear ([https://github.com/vurtun/nuklear](https://github.com/vurtun/nuklear))
    to display its UI. The part of the UI that is displayed is a stats counter in
    the upper-right corner of the screen. It looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.5: Stats counter for the AllChapters sample'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_1.5_B16191.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.5: Stats counter for the AllChapters sample'
  prefs: []
  type: TYPE_NORMAL
- en: The top box contains some general information about the display that the application
    opened on. This information contains the display frequency, whether `vsynch` is
    enabled, and what the frame budget is in milliseconds.
  prefs: []
  type: TYPE_NORMAL
- en: The second box down contains high-level frame timings. The time displayed will
    turn red if there was a stale frame in the last 60 frames. Some stale frames are
    unavoidable; if the frame rate drops to 59.9, the text will show red for a second.
    Seeing red here occasionally is OK; it's only a concern if the numbers are solid
    red.
  prefs: []
  type: TYPE_NORMAL
- en: The third box down contains two GPU timers; these measure how fast the sample
    is running on the GPU. This is useful for debugging any heavy draw calls. The
    final box contains CPU timers, which are helpful for figuring out which phase
    of the problem has a bottleneck.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this book, you will use C++ `stl` containers. The Standard Library
    is a bit slow in debug mode, mostly due to error checking. It's a good idea to
    profile any samples in release mode only.
  prefs: []
  type: TYPE_NORMAL
- en: These examples should do a fair job of demonstrating what you will learn in
    each of the upcoming chapters. They also provide an example for you to compare
    your code against.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you explored the process of setting up a new Win32 window.
    An OpenGL 3.3 Core context was set up to render to the window, with `vsynch` enabled.
    You learned about OpenGL loaders and how `glad` can load all the relevant OpenGL
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: This window will serve as a foundation for you to build on; all future samples
    are built on the framework you created in this chapter. In the next chapter, you
    will start to explore some of the math required for rendering and animation.
  prefs: []
  type: TYPE_NORMAL
