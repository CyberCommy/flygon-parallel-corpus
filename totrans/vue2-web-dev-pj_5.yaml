- en: Project 3 - Support Center
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will build a more complex application with a routing system
    (this means multiple virtual pages). This is going to be a support center for
    a fictional company called "My Shirt Shop". It will have two main parts:'
  prefs: []
  type: TYPE_NORMAL
- en: An FAQ page with a few questions and answers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A support ticket management page where the user will be able to display and
    create new tickets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The application will have an authentication system that will allow users to
    create an account or log in.
  prefs: []
  type: TYPE_NORMAL
- en: We will first start creating some basic routes, then we will integrate this
    account system to finish with more advanced topics regarding routing. Through
    the chapter, we will reuse our code as much as possible and apply best practices.
  prefs: []
  type: TYPE_NORMAL
- en: General app structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this first part, we are going to create the project structure and learn more
    about routing and pages.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For setting up the project, the following steps need to be followed:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, generate a Vue project with the `vue init webpack-simple <folder>` command,
    like we did in [Chapter 4](cb653442-5aaa-47b6-ad7b-d94ce15821b7.xhtml), *Advanced
    Project Setup*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Install the packages necessary to compile Stylus code (our style will be written
    using Stylus):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`stylus`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stylus-loader`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Don't forget to save the development tools packages in the development dependencies
    of your `package.json` file with the `--save-dev` flag.
  prefs: []
  type: TYPE_NORMAL
- en: Remove the content of the `src` folder where we will put all the sources of
    our app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then create a `main.js` file with the code needed to create a Vue app:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: You can now try to run the app with the `npm run dev` command!
  prefs: []
  type: TYPE_NORMAL
- en: Most the style for the app is already available. Download it ([https://github.com/Akryum/packt-vue-project-guide/tree/master/chapter5-download)](https://github.com/Akryum/packt-vue-project-guide/tree/master/chapter5-download)
    and extract the Stylus files into a `style` folder inside the `src` directory.Extract
    the `assets` folder too.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Routing and pages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our app will be organized in six main pages:'
  prefs: []
  type: TYPE_NORMAL
- en: The home page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The public FAQ page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The login page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The tickets page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A page to send a new ticket
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A page showing one ticket details and conversation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A route is a path representing a state of the application, usually in the form
    of pages. Each route is associated with a URL pattern that will trigger the route
    when the address matches. Then, the corresponding page will be presented to the
    user.
  prefs: []
  type: TYPE_NORMAL
- en: Vue plugins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To enable routing in our app, we need an official Vue plugin called `vue-router`.
    A Vue plugin is some JavaScript code designed to add more features to the Vue
    library. You can find many plugins on the npm registry, and I recommend the awesome–vue
    GitHub repository ([https://github.com/vuejs/awesome-vue](https://github.com/vuejs/awesome-vue))
    that lists them by category:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Download the `vue-router` package from npm with the following command in the
    project directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We will put all the routing–related code in a new `router.js` file next to the
    `main.js` file, which you need to create. Then, we need to install the plugin
    we want to use (which is `vue-router` in our case) with the global `Vue.use()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `router.js` file and import both the `Vue` library and the `VueRouter`
    plugin from their corresponding packages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Then install the plugin into Vue:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `vue-router` plugin is now ready to be used!
  prefs: []
  type: TYPE_NORMAL
- en: Our first routes with vue–router
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will go through the steps required to set up routing in
    our Vue application.
  prefs: []
  type: TYPE_NORMAL
- en: Layouts with router–view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before adding routes, we need to setup a layout for the app where the route
    components will be rendered.
  prefs: []
  type: TYPE_NORMAL
- en: Let's create a component called `AppLayout.vue` in a new `components` folder
    inside the `src` directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write the template of the component--a `<div>` element containing a `<header>`
    with an image and some text. Then, add a `<router-view />` component after the
    header:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `<router-view />` component is a special component provided by the `vue-router`
    plugin that will render the component of the current matching route. It is not
    a real component since it doesn't have its own template, and it will not appear
    in the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the template, add a `style` tag importing the main Stylus file from the
    `styles` folder you downloaded earlier in the *Setting up the project* section.
    Don''t forget to specify that we are using `stylus` with the `lang` attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we can have as many `style` tags as we need in a SFC, add another one,
    but scoped this time. We will specify the size of the `header` logo in this second
    style section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: To improve the performance, it is recommended to use classes inside scoped styles.
  prefs: []
  type: TYPE_NORMAL
- en: Our layout component is ready to be included in our app!
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `main.js` file, import it and render it on the `root` Vue instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We can't start the app yet, since we are not finished with routing!
  prefs: []
  type: TYPE_NORMAL
- en: If you look at the console of your browser, you might see an error message complaining
    about the `<router-view />` component being missing. This is because we don't
    have the imported `router.js` file where we installed the `vue-router` plugin
    into Vue, so the code isn't included in our app yet.
  prefs: []
  type: TYPE_NORMAL
- en: Creating routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create a few dumb pages for test routing:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `components` folder, create a `Home.vue` component containing a very
    simple template with a `<main>` element, a title, and some text:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, create an `FAQ.vue` component next to `Home.vue`. It should also contain
    a `<main>` element, inside of which you can add a simple title:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We now have what we need to create a few routes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `router.js` file, import the two components we just created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, create a `routes` array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'A route is an object containing a path, a name, and a component to render:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The path is the pattern that the current URL should match for the route to be
    activated. The component will be rendered in the special `<router-view />` component.
  prefs: []
  type: TYPE_NORMAL
- en: The route name is optional, but I strongly recommend using it. It allows you
    to specify the names of the routes instead of the path, so that you can move and
    change your routes around without ending up with broken links.
  prefs: []
  type: TYPE_NORMAL
- en: 'With that in mind, we can now add our two routes in the `routes` array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s review what it will do:'
  prefs: []
  type: TYPE_NORMAL
- en: When the browser URL is `http://localhost:4000/`, the `Home.vue` component will
    be rendered
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the URL is `http://localhost:4000/faq/`, the `FAQ.vue` component will be
    displayed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The router object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With our routes ready, we need to create a `router` object that will take care
    of managing the routing for us. We will use the `VueRouter` constructor from the
    `vue-router` package. It takes one `options` parameter and for now, we are going
    to use the `routes` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'After the `routes` array in the `router.js` file, create a new `router` object
    and specify the `routes` parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The plugin we installed is also the router constructor, so we are using the
    same `VueRouter` variable. `VueRouter` is in fact a valid Vue plugin because it
    has an `install` method. We will create our own plugin in this chapter!
  prefs: []
  type: TYPE_NORMAL
- en: 'Export the `router` object as the default exported value of the module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now back to our `main.js` file, we need to provide the `router` object to the
    Vue application. Import the `router` we just created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add it as a definition option to the root Vue instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'That is all we need to have routing working! You can now try to change the
    URL in your browser to either `http://localhost:4000/#/` or `http://localhost:4000/#/faq`
    and get a different page each time:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/573630b2-2281-4d69-a433-340ca757d243.png)Don''t forget the sharp
    `#` character in the URL; it is needed to fake the route changes while not changing
    the real web page. This is the default router mode called `hash`, and it works
    with any browser and server.'
  prefs: []
  type: TYPE_NORMAL
- en: Router modes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can change the router mode with the `mode` parameter in the constructor options.
    It can either be `'hash'` (default), `'history'`, or `'abstract'`.
  prefs: []
  type: TYPE_NORMAL
- en: The `hash` mode is the default we are already using. It is the "safest" choice
    since it is compatible with any browser and server. It consists of using the "hash"
    part of the URL (which means the part after the sharp character) and change it
    or react to changes to it. The big advantage is that changing the hash part will
    not change the real web page where our app is running (which would be very unfortunate).
    The obvious drawback is that it forces us to separate the URL in two with the
    not so pretty sharp symbol.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thanks to the HTML5 `history.pushState` API, we can get rid of this sharp character
    and get a real URL for our app! We need to change the mode to `''history''` in
    the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can use pretty URLs such as `http://localhost:4000/faq` in our Single-Page
    App! There are two problems though:'
  prefs: []
  type: TYPE_NORMAL
- en: The browser needs to support this HTML5 API, which means it won't work on Internet
    Explorer 9 or less (all other major browsers have supported it for quite some
    time).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The server has to be configured to send the home page instead of throwing a
    404 error when accessing a route such as `/faq`, since it doesn't really exist
    (you don't have a file called `faq.html`). This also means we will have to implement
    the 404 page ourselves.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thankfully, the webpack server used by `vue build` is configured to support
    this by default. So you can go ahead and try the new `http://localhost:4000/faq`
    URL!
  prefs: []
  type: TYPE_NORMAL
- en: There is a third mode called `abstract` that can be used in any JavaScript environment
    (including Node.js). If there is no browser API available, the router will be
    forced to use this mode.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a navigation menu
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Instead of manually typing the URL, it would be great to have a proper navigation
    `menu` in our app! Let''s create a new `NavMenu.vue` file in our `components`
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will add it in the layout. Import the new component in the `AppLayout`
    one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add it to the `AppLayout` template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Router links
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `vue-router` plugin provides us with another handy special component--`<router-link>`.
    It is a component that will change to a specified route when clicked thanks to
    its `to` prop. By default, it will be a `<a>` HTML element, but this can be customized
    with the `tag` prop.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, a link to the FAQ page would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The `to` prop can also get an object with the name property instead of the
    path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This will dynamically generate the correct path for the route. I recommend you
    to use this second method as opposed to only specifying the path--that way, if
    you change the paths of your routes, your navigation links will still work.
  prefs: []
  type: TYPE_NORMAL
- en: When using the object notation, don't forget to bind the `to` prop with `v-bind`
    or the `:` shorthand, or else the `router-link` component will get a string and
    won't understand it's an object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can add the links to our `NavMenu` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'You should now have a working menu in the app:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/09491639-cb34-4468-a2ec-e31562b55427.png)'
  prefs: []
  type: TYPE_IMG
- en: Active class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A router link gets the active class when the route it is associated with is
    currently active. By default, the component gets the `router-link-active` CSS
    class, so you can change its visuals accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In our `NavMenu.vue` component, declare some scoped style to add a bottom border
    to the active link using Stylus:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We include the `$primary-color` variable with the `@import '../style/imports';`
    statement, which imports the `imports.styl` file containing the Stylus variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you try the app now, you will find that something weird is happening with
    our menu. If you go to the Home page, it is working as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/fcd3f66c-a061-4b55-8c19-ba01405e923f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'But when you go to the FAQ page, both the Home and the FAQ links are highlighted:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/8baa75ec-9101-4117-8793-7168c1a06fd4.png)'
  prefs: []
  type: TYPE_IMG
- en: This is because by default, the active class matching behavior is inclusive!
    This means `<router-link to="/faq">` will get the active class if the path is
    `/faq` or starts with `/faq/`. But it also means `<router-link to="/">` will get
    the class if the current path starts with `/`, which are all possible paths! That's
    why our Home link will always get the class.
  prefs: []
  type: TYPE_NORMAL
- en: To prevent this from happening, there is the `exact` prop, which is a Boolean.
    If it is set to `true`, the link will only get the active class if the current
    path is matching exactly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `exact` prop to the Home link:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, only the FAQ link should be highlighted:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/218e9760-554f-4d93-bd60-423a3ca235d1.png)'
  prefs: []
  type: TYPE_IMG
- en: FAQ - Consuming an API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will create the FAQ page, which will get data from the server.
    It will display a loading animation and then the list of questions and answers.
  prefs: []
  type: TYPE_NORMAL
- en: Server setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is our first app that will communicate with a server. You will get a server
    with a ready-to-use API.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can download the server files ([https://github.com/Akryum/packt-vue-project-guide/tree/master/chapter5-download](https://github.com/Akryum/packt-vue-project-guide/tree/master/chapter5-download)).
    Extract them into another folder than our app and run the following commands to
    install the dependencies and launch the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: You should now have the server running on port 3000\. When this is done, we
    can continue building our app with a real backend this time!
  prefs: []
  type: TYPE_NORMAL
- en: Using fetch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the `FAQ.vue` Single File Component, we will use the standard `fetch` API
    of the web browser to retrieve the questions from our server. The request will
    be a very simple `GET` request to `http://localhost:3000/questions` with no authentication.
    Each question object will have `title` and `content` fields:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `FAQ.vue` and start by adding the `questions` data property in the component
    script, which will hold the array of questions retrieved from the server. We also
    need an `error` property to display a message when something goes wrong during
    the network request:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can add the questions and answers to the template with a `v-for` loop,
    and the following error message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We are ready to fetch! The fetch API is promised-based and quite simple to
    use. Here is an example of `fetch` usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: We first call `fetch` with the first parameter being the URL of the request.
    It returns a promise with a `response` object, which holds information about the
    request result. If it was successful, we use `response.json()`, which returns
    a new promise with the JSON parsed result object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The request will be made inside the component as soon as it is created when
    the route is matched, which means that you should use the `created` life cycle
    hook in the component definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: If everything goes well, we will set the questions property with the JSON parsed
    result. Or else we will display an error message.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by calling `fetch` with the right URL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the first `then` callback with the `response` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We need another `then` callback since `response.json()` returns a new promise:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we catch all possible errors to display the error message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a summary of our `created` hook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We can rewrite this code using the `async` and `await` JavaScript keywords
    to make it look like sequential code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now try the page, which should display a list of questions and answers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ad13159c-6d51-4eaf-b5b4-bdcc1805b9ce.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To see if our error management is working, you can go to the console where
    the server is running, and stop it (for example, with the C*trl*+*C* keyboard
    shortcut). Then, you can reload the app and the following error message should
    be displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/409552ab-7806-49a0-bf57-e5ca5a8cd921.png)'
  prefs: []
  type: TYPE_IMG
- en: Loading animation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is one last thing missing--we should show a loading animation to inform
    the user that an operation is in progress instead of an empty screen. To this
    effect, the server is faking a 1.5 s delay on the `/questions` request so we can
    easily see the loading animation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we are going to display loading animations inside multiple components,
    we are going to create a new global component:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `components` folder, create a new `Loading.vue` file with the following
    template:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new `global-components.js` file next to the `main.js` file in the
    `main` folder. In this file, we are going to register the `Loading` component
    globally with the `Vue.component()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: This is the file where we will register all the global components used across
    all the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, in the `main.js` file, import the `global-components.js` module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Back to our `FAQ.vue` component, we need a new `loading` Boolean data property
    to toggle the display of the animation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'In the template, add the loading animation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, change the `created` hook a bit by setting `loading` to `true` at
    the beginning, and `false` when everything is done:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now reload the page and briefly see the loading animation before the
    questions appear:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/436a47ea-2274-4dbd-8f07-146d12974f14.png)'
  prefs: []
  type: TYPE_IMG
- en: Extending Vue with our own plugin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since we will use fetch in multiple components for our application and we want
    to reuse code as much as possible, it would be nice to have a method on all of
    our components that makes a request to the server with a predefined URL.
  prefs: []
  type: TYPE_NORMAL
- en: This a nice use case for a custom Vue plugin! Don't worry, writing a plugin
    is actually pretty simple.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a plugin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create a plugin, there is only one rule--a plugin should be an object with
    an `install` method, which takes the Vue constructor as the first argument, and
    an optional `options` argument. This method will then add new features to the
    framework by modifying the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new `plugins` folder in the `src` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the `plugins` folder, create a `fetch.js` file where we will write our
    plugin. In this case, our plugin will add a new `$fetch` special method on all
    of our components. We will do that by changing the prototype of Vue.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s try creating a very simple plugin, by exporting an object with an `install`
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: That's it! We have created a Vue plugin! Now, we need to install it into our
    application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `main.js` file, import the plugin and then call the `Vue.use()` method
    just like we did for `vue-router`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: You should now see the `'Installed!'` message in your browser console.
  prefs: []
  type: TYPE_NORMAL
- en: Plugin options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can configure the plugin with an `options` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `install` method to add this parameter after `Vue`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: We can now add a configuration object to the `Vue.use()` method in the `main.js`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add a `baseUrl` property to the configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: You should now see the `options` object in the browser console.
  prefs: []
  type: TYPE_NORMAL
- en: 'Store `baseUrl` into a variable so we can use it later:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Fetch method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we are going to write the `$fetch` method. We will take most of the code
    we used in the `created` hook of the FAQ component:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement the `$fetch` method using `fetch`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: We export it so we can use it in our plain JavaScript code too. The `url` parameter
    is now just the path of the query without the domain, which is now in our `baseUrl`
    variable--this allows us to change it easily without having to refactor each component.
    We also take care of the JSON parsing, since all the data from the server will
    be encoded in JSON.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make it available in all components, simply add it to the prototype of `Vue`
    (which is the constructor used to create components):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, refactor the FAQ component to use our new special `$fetch` method in
    the created hook:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Our code in the component is now shorter, easier to read, and more scalable
    since we can change the base URL easily.
  prefs: []
  type: TYPE_NORMAL
- en: Reusing code with mixins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen how to create plugins, but there is another way to improve our
    code--what if we could reuse component definitions such as computed properties,
    methods, or watchers across multiple components? This is what mixins are for!
  prefs: []
  type: TYPE_NORMAL
- en: A mixin is a component definition object that can be applied to other definition
    objects (including other mixins). It is very simple to write, because it looks
    exactly the same as a regular component definition!
  prefs: []
  type: TYPE_NORMAL
- en: 'Our objective here is to have a `RemoteData` mixin that will allow any component
    to make requests to the server in order to fetch data. Let''s add a new `mixins`
    folder in the `src` directory, and create a new `RemoteData.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start simple by exporting a definition with a data property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: This `remoteDataLoading` property will be used to count the number of requests
    that are currently loading, to help us display a loading animation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to use this mixin in our FAQ component, we need to import it and add it
    in the `mixins` array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'If you inspect the component, you should now see an additional `remoteDataLoading`
    property displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/be837ea2-b9ad-4921-9e14-2231c38ab64d.png)'
  prefs: []
  type: TYPE_IMG
- en: So what happened? The mixin got applied and merged into the component definition
    of `FAQ.vue`, which means that the data hook was called twice--first from the
    mixin, then from the FAQ definition and a new property was added!
  prefs: []
  type: TYPE_NORMAL
- en: Vue will automatically merge the standard options such as hooks, data, computed,
    methods, and watch, but if you have, for example, a property of a method with
    the same name, the last one applied will override the previous ones.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try overriding the new property in our component with another value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in the component inspector, the final component definition has
    a higher priority than the mixin. Also, you may have noticed that the `mixins`
    option is an array, thus we can apply multiple mixins to the definition, which
    will be merged in order. For example, consider we have two mixins and want to
    apply them to a component definition. Here is what will happen:'
  prefs: []
  type: TYPE_NORMAL
- en: The definition object contains the options of mixin 1.
  prefs:
  - PREF_OL
  - PREF_OL
  type: TYPE_NORMAL
- en: The options of mixin 2 are merged into the definition object (existing property/method
    names are overriden).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the same way, the options of the component are merged into the final definition
    object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can now remove the duplicate `remoteDataLoading: 42,` from the FAQ component
    definition.'
  prefs: []
  type: TYPE_NORMAL
- en: Hooks such as `data`, `created`, `mounted`... are each called individually in
    the order they were applied to the final definition. This also means that the
    final component definition hooks will be called last.
  prefs: []
  type: TYPE_NORMAL
- en: Fetching remote data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have a problem--each component using our `RemoteData` mixin will have different
    data properties to fetch. Therefore, we need to pass parameters to our mixin.
    Since a mixin is essentially a definition object, why not use a function that
    can take parameters and then return a definition object? That's what we will do
    in our case!
  prefs: []
  type: TYPE_NORMAL
- en: 'Wrap the object we have defined inside a function with a `resources` parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The `resources` parameter will be an object with each key being the name of
    the data property we want to add, and the value being the path of the request
    that needs to be made to the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'So we need to change the way we use the mixin in our `FAQ.vue` component to
    a function call:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are going to fetch the `http://localhost:3000/questions` URL (with
    the special `$fetch` method we created earlier) and put the result in the `questionList`
    property.
  prefs: []
  type: TYPE_NORMAL
- en: Now onto our `RemoteData` mixin!
  prefs: []
  type: TYPE_NORMAL
- en: 'First things first, we need to initialize each data property to a `null` value,
    so Vue can set up reactivity on them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: This step is important--if you don't initialize the data, it won't be made reactive
    by Vue, so the component will not be updated when the properties change.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can try the app and see in the component inspector that a new `questionList`
    data property has been added to the FAQ component:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/3e9d5417-0726-4394-8b40-50815458cf77.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, we will create a new `fetchResource` method that fetches one resource
    and update the corresponding data property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Our component now has access to this new method and can use it directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make our mixin smarter, we will automatically call it inside the `created`
    hook (which will be merged):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now verify that the `questionList` data property gets updated with
    a new request made to the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/3eee8bfd-5850-4a4e-8d45-c5c574fd1549.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, you can remove the old code with the `questions` property in the `FAQ.vue`
    component and change the template to use the new property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Loading management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next thing we want to do is provide a way to know if the loading animation
    should be displayed. Since we could potentially have multiple requests, we are
    going to use a numeric counter instead of a Boolean--`remoteDataLoading` that
    we already declared in the `data` hook. Each time a request is made, we increment
    the counter, and when it is complete we decrement the counter. This means if it
    is equal to zero no request is currently pending, and if it is greater or equal
    to one we should display a loading animation:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the two statements incrementing and decrementing the `remoteDataLoading`
    counter in the `fetchResource` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'To make our life easier when using the mixin, let''s add a computed property
    called `remoteDataBusy` that will be `true` when we need to display the loading
    animation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Back to our FAQ component, we can now remove the `loading` property, change
    the `v-if` expression for the `Loading` component, and use the `remoteDataLoading`
    computed property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: You can try refreshing the page to see the loading animation displayed before
    the data is retrieved.
  prefs: []
  type: TYPE_NORMAL
- en: Error management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Finally, we could manage the errors that could occur for any resource request:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will store the errors for each resource in a new `remoteErrors` object,
    which needs to be initialized:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: The key of the `remoteErrors` object will be the same as the resource, and the
    value will be the error or `null` if there is no error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to modify the `fetchResource` method:'
  prefs: []
  type: TYPE_NORMAL
- en: Before the request, reset the error by setting it to `null`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If there is an error in the catch block, put it into the `remoteErrors` object
    at the right key
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `fetchResource` method should now look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: We could now display specific error messages for each resource, but we will
    simply display a generic error message in this project. Let's add another computed
    property called `hasRemoteErrors`, which will return true if there is at least
    one error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the JavaScript `Object.keys()` method, we can iterate on the keys of
    the `remoteErrors` object and check if some values are not `null` (which means
    that they are truthy):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now change the FAQ component template again by replacing the `error`
    property with the new one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Like we did before, you can shut down the server to see the error message displayed.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have now finished the FAQ component, whose script should now look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, it is very concise now!
  prefs: []
  type: TYPE_NORMAL
- en: Support tickets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this last part, we will create an authenticated section of our app, where
    the user will be able to add and view support tickets. All the necessary requests
    are available on the server you already downloaded and if you are curious about
    how this has been done in the node with `passport.js`, you can take a look at
    the sources!
  prefs: []
  type: TYPE_NORMAL
- en: User authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this first section, we will take care of the user system of our app. We will
    have both login and sign up components, to be able to create new users.
  prefs: []
  type: TYPE_NORMAL
- en: Storing the user in a centralized state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will store the user data inside a state object like we did in [Chapter 3](1f1ee662-c20d-4926-9b9a-4fcfaedf4b84.xhtml),
    *Project 2* - *Castle Duel Browser Game*, so we can access it in any component
    of the app:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new `state.js` file next to `main.js`, which exports the state object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: The `user` property will be null when no user is logged in, or else it will
    contain the user data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, in the `main.js` file, import the state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, use it as the data of the root instance so Vue makes it reactive:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Another plugin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We could then import the state in component files when we need it, but it would
    be more convenient to be able to access it with a special getter called `$state`
    on the Vue prototype like we did for the `fetch` plugin. We will pass the state
    object to the plugin options, and the getter will return it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `plugins` folder, create a `state.js` file that exports the new plugin:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Here we are using the JavaScript `Object.defineProperty()` method to set up
    a getter on the Vue prototype, so every component will inherit it!
  prefs: []
  type: TYPE_NORMAL
- en: One last thing--we need to install the state plugin!
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `main.js` file, import the new plugin:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Then install it with the state object as the options parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now use `$state` in our components to access the global state! Here
    is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: This should output the state object with the `user` property.
  prefs: []
  type: TYPE_NORMAL
- en: Login forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will first create new components to help us build forms
    faster, and then we will add the sign up and the login forms to the application
    with a `Login.vue` component. In later sections, we will create another form to
    submit new support tickets.
  prefs: []
  type: TYPE_NORMAL
- en: Smart form
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This generic component will take care of the very general structure of our form
    components, and will automatically call an `operation` function, display a loading
    animation and the eventual error messages thrown by the operation. Most of the
    time, the operation will be a `POST` request made to the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'The template is essentially a form with a title, a default slot where the inputs
    will be rendered, an `actions` slot for the buttons, a loading animation, and
    a place for the error messages. This will be generic enough for the two forms
    we need in the application:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new `SmartForm.vue` component in the `components` folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: On the `<form>` element, we set up an event listener on the `'submit'` event,
    which prevents the default behavior of the browser (reloading the page) with the
    `prevent` modifier.
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, the `SmartForm` component will have three props:'
  prefs: []
  type: TYPE_NORMAL
- en: '`title`: This is displayed in the `<h2>` element.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`operation`: The asynchronous function called when the form is submitted. It
    should return a promise.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`valid`: A Boolean to prevent calling the operation if the form is not valid.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Add them to the `script` part of the component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we are now using a different way of declaring the props--by
    using an object, we can specify more details of the prop. For example, with `required:
    true`, Vue will warn us if we forget a prop. We can also put a type that Vue will
    check too. This syntax is recommended since it helps both understanding the props
    of the component and avoiding errors.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need two data properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`busy`: A Boolean to toggle the display of the loading animation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`error`: This is the error message or `null` if there aren''t any'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Add them with the `data` hook:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to write the `submit` method called when the form is submitted:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: If the form isn't valid or is still busy, we don't call the operation. Or else
    we reset the `error` property and then call the `operation` prop, with the `await`
    keyword since it should be an asynchronous function that returns a promise. If
    we catch an error, we set the message to the `error` property so it is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that our generic form is ready, we can register it in the `global-components.js`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Form input component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In our forms, we will have many inputs with the same markup and functionalities.
    This is the perfect occasion to make another generic and reusable component. It
    will have a small template with mainly an `<input>` element and will be able to
    show the user that it is invalid with a red border:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by creating a new `FormInput.vue` component with the following props:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`name` is the HTML name of the input, needed for the browser autocompletion
    to work.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`type` will be `''text''` by default, but we will need to set `''password''`
    eventually.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`value` is the current value of the input.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`placeholder` is the label displayed inside the input.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`invalid` is a Boolean to toggle the invalid display (the red border). It will
    default to `false`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The script should look like this with the prop object notation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'For the invalid display, we will add a computed property to dynamically change
    the CSS classes of the input:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can write our template. It will have a `<div>` element containing the
    `<input>`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: We use the `prop` modifier on the `v-bind:value` directive to tell Vue to set
    the DOM node `value` property directly instead of setting the HTML attribute.
    This is a good practise when dealing with properties such as `value` for input
    HTML elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin testing it, we can register the component in the `global-components.js`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new `Login.vue` component using the `FormInput` component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Don''t forget the corresponding route in the `router.js` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'You can test the component by opening the app with the `/login` path in the
    URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/5730642f-6612-40ca-8845-041eaa6f0b34.png)'
  prefs: []
  type: TYPE_IMG
- en: For now, the `FormInput` component is read-only because we don't do any thing
    when the user types something into the field.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add a method to take care of that:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we can listen to the `input` event on the text field:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: Now if you type into the text field, the content should be printed to the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `update` method, we are going to emit an event to send the new value
    to the parent component. By default, the `v-model` directive listens to the `input`
    event, with the new value being the first parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: To understand how things work, we are not going to use `v-model` yet.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now listen to this `input` event and update the `username` prop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'The value of the `username` prop should be updated on the `Login` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a4105d26-4d80-40f0-9e45-8e9b20793a4e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Using the `v-model` directive, we can simplify this code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: It will use the `value` prop and listen to the `input` event for us!
  prefs: []
  type: TYPE_NORMAL
- en: Customizing v-model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By default, `v-model` uses the `value` prop and the `input` event as we just
    saw, but we can customize that:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `FormInput` component, add the `model` option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'We then need to change the name of our `value` prop to `text`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'And in the template:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'Plus the `input` event should be renamed to `update`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: The component should still work in the `Login` component, since we told `v-model`
    to use the `text` prop and `update` event!
  prefs: []
  type: TYPE_NORMAL
- en: Our input component is now ready! For this project, we have kept this component
    simple, but you can add more features into it if you want to, such as icons, error
    messages, floating label, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Login component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can now continue building the `Login` component, which will take care of
    signing in and signing up the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several data properties we need for the state of this component:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mode`: This can either be `''login''` or `''signup''`. We will change the
    layout a bit depending on this.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`username`: Used in both modes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`password`: Also used in both modes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`password2`: Used to verify the password when signing up.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`email`: Used in sign up mode.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Our `data` hook should now look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then add a `title` computed property to change the form title depending
    on the mode:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: We will also add some basic input validation. First, we would like to highlight
    the retype `password` field when it's not equal to the first password.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add another computed property for that:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: Then, we will also check that no field is empty since they are all mandatory.
  prefs: []
  type: TYPE_NORMAL
- en: 'This time, we will break it up into two computed properties, since we don''t
    want to check the sign up specific fields when in `login` mode:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, add the methods we will use to either `login` or `sign up` the user (we
    will implement them later in the *Sign up operation* and *Login operation* sections):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now move onto the template. Start by adding a `SmartForm` component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we can add the `input` fields:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: Don't forget the name attributes--it will allow the browser to auto-complete
    the fields.
  prefs: []
  type: TYPE_NORMAL
- en: 'Below the `input` fields, we need two different buttons for each mode. For
    the login mode, we need a `sign up` and `login` button. For the `sign up` mode,
    we need a Back button and a Create account button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can test the component and switch between the `login` and `sign up`
    modes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/472e2d84-4be7-41cf-b5dd-f4be4516d939.png)'
  prefs: []
  type: TYPE_IMG
- en: Style children of scoped elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The form is currently taking all the space available. It would be better to
    shrink it a bit.
  prefs: []
  type: TYPE_NORMAL
- en: For this section to work, you need the latest `vue-loader` package installed
    in your project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add some style to put a maximum width to the form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'The `>>>` combinator allows us to target elements inside the components used
    in the template, while still scoping the rest of the `CSS` selector. In our example,
    the generated `CSS` will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'If we didn''t use this combinator, we would have this `CSS`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: This wouldn't work since the `.content` element is inside the `SmartForm` component
    we are using in the template.
  prefs: []
  type: TYPE_NORMAL
- en: If you are using SASS, you need to use the `/deep/` selector instead of the
    `>>>` combinator.
  prefs: []
  type: TYPE_NORMAL
- en: 'The form should look like this now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/1e6f948a-9608-463b-a8ba-db80dc50186a.png)'
  prefs: []
  type: TYPE_IMG
- en: Improving our fetch plugin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Currently, our `$fetch` method can only make `GET` requests to the server.
    It was enough for loading the FAQ, but now we need to add more features to it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `plugins/fetch.js` file, edit the signature of the function to accept
    a new `options` parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: The `options` argument is an optional object for the browser's `fetch` method
    that will allow us to change different parameters, such as the HTTP method used,
    the request body, and more.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the beginning of the `$fetch` function, we would like to put some default
    values for this `options` parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: The default options tell the server we will always send JSON in the request
    body, and tell the browser that we will also include the authorization token necessary
    to authenticate the user if they are logged in. Then, the provided `options` argument,
    if any, add its value to the `finalOptions` object (for example, the `method`
    property or the `body` property).
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we add the new options to the `fetch` browser method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, the server will always send errors as text, so we can catch them and
    display them to the user:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: We are now ready to make our first `POST` request to the server in order to
    create for the user a new account and then log him in!
  prefs: []
  type: TYPE_NORMAL
- en: Sign up operation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will start with the account creation, since we don''t have any user yet.
    The path to call on the server is `/signup`, and it expects a `POST` request with
    a JSON object in the request body containing the username, password, and email
    of the new account:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s implement this using the `$fetch` method we just improved:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: We don't manage errors here, as it's the job of the `SmartForm` component we
    built earlier.
  prefs: []
  type: TYPE_NORMAL
- en: That's it! You can now create a new account with a simple `password` you will
    have to remember for later. If the account creation succeeds, the form goes back
    to `login` mode.
  prefs: []
  type: TYPE_NORMAL
- en: One thing we don't do here, but that could be improved, is to let the user know
    their account has been created and that they can now log in. You could add a message
    below the form, or even make a floating notification appear!
  prefs: []
  type: TYPE_NORMAL
- en: Login operation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The login method will be almost identical to the sign up. The differences are:'
  prefs: []
  type: TYPE_NORMAL
- en: We only send the `username` and `password` in the request body, to the `/login`
    path
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The response is the user object we need to set into the global state so every
    component can know if there is a connected user (using the plugin we made exposing
    the `$state` property)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then we redirect to the home page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It should look like this now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: You can now try to log in with the `username` and the `password` you used to
    create the account earlier. If the login is successful, you should be redirected
    to the home page thanks to the `router.push()` method.
  prefs: []
  type: TYPE_NORMAL
- en: The `user` object returned by this request contains the `username` field that
    will be displayed in the navigation menu.
  prefs: []
  type: TYPE_NORMAL
- en: User menu
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now it is time to add the user-related features to the navigation menu we made
    at the beginning in the `NavMenu.vue` file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We want them to appear to the far right side of the menu, so we will add this
    element just after the router links we already wrote:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: This will simply grow to take all the available space in the menu using the
    CSS flexbox properties, so that anything we put after will be pushed to the right.
  prefs: []
  type: TYPE_NORMAL
- en: Thanks to the plugin we made earlier in the *Storing the user in a centralized
    State* section, we have access to the global state with the `$state` property.
    It contains the `user` object, which allows us to know if the user is logged in,
    and displays their `username` and a `logout` link.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the user menu in the `NavMenu.vue` component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'If the user isn''t connected, we just display a `login` link (add this below
    the `template` we just added):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: The `logout` link needs a new `logout` method that we will create now.
  prefs: []
  type: TYPE_NORMAL
- en: Logout method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The logout method consists of a simple call to the `/logout` path on the server,
    which should return an object with the `status` property equal to `''ok''`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: If the user successfully logged out, we reset the `user` value in the global
    state.
  prefs: []
  type: TYPE_NORMAL
- en: Private routes with navigation guards
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have an authentication system ready, we can have different types
    of routes:'
  prefs: []
  type: TYPE_NORMAL
- en: Public routes are always accessible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Private routes are restricted to logged users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Guest routes are accessible only to users that are not connected yet
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We are going to create one of the routes components ahead of time to test our
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create the `TicketsLayout.vue` component that we will use later to display
    either of the user support tickets:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, add the corresponding route in the `router.js` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, add the link to this new page in the navigation menu:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: Route meta properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can add the page access type information in the `meta` object on the impacted
    routes in the `router.js` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The route we just created should be private and only accessible to connected
    users:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `private` attribute to the `meta` object on the route:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if you go to the tickets page and inspect any component, you should see
    the `$route` object exposed by the `vue-router` plugin. It contains the `private`
    property in the `meta` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/febb8fe5-3e14-4956-a451-eb4cbd4a167f.png)You can put any additional
    information in the `meta` object of a route to extend the router capabilities.'
  prefs: []
  type: TYPE_NORMAL
- en: Router navigation guards
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we know the tickets route is private, we would like to execute some
    logic before the route is resolved to check if the user is connected. That is
    where navigation guards come in handy--there are function hooks called when something
    happens regarding routes and they can change the behavior of the router.
  prefs: []
  type: TYPE_NORMAL
- en: 'The navigation guard we need is `beforeEach` and it is run each time before
    a route is resolved. It allows us to replace the target route with another one
    if necessary. It accepts a callback with three arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '`to` is the route currently being targeted'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`from` is the previous route'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`next` is a function we have to call at some point for the resolution to proceed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you forget to call `next` in your navigation guard, your app will be stuck.
    This is because you can do asynchronous operations before calling it, so the router
    doesn't make any assumption on its own.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before exporting the router instance, add the `beforeEach` navigation guard:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need to determine if the route we target is a private route:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'To check if the user is connected, we need the global state--you can import
    it at the start of the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: 'Change the condition to also check for the user state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: The next function can be called with a route argument, to redirect the navigation
    to another route.
  prefs: []
  type: TYPE_NORMAL
- en: 'So here, we can redirect to the login route just like we would do with the
    `router.push()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: Don't forget to return, or you will call `next` a second time at the end of
    the function!
  prefs: []
  type: TYPE_NORMAL
- en: We can now try to log out and click on the support tickets link. You should
    be immediately redirected to the login page instead.
  prefs: []
  type: TYPE_NORMAL
- en: When redirecting with `next`, no additional entry is added to the browser history
    for each redirection. Only the final route has a history entry.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see in the browser console, the navigation guard was called each
    time we try to resolve to a route:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a7f7d374-8b84-4412-80d1-1b21b70356ef.png)'
  prefs: []
  type: TYPE_IMG
- en: That explains why the function is called `next`--the resolving process will
    continue until we don't redirect to another route.
  prefs: []
  type: TYPE_NORMAL
- en: This means the navigation guard can be called multiple times, but this also
    means you should be careful of not creating an infinite "loop" of resolutions!
  prefs: []
  type: TYPE_NORMAL
- en: Redirecting to the wanted route
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After the user is logged in, the app should redirect him to the page they initially
    wanted to browse:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pass the current wanted URL as a parameter to the login route:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'Now if you click on the support tickets link and get redirected to the login
    page, you should see the `wantedRoute` parameter in the `$route` object on any
    component:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/d3bca6d2-077c-46fd-a9b6-f5c59b653462.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the `Login` component, we can change the redirection in the `login` method
    and use this parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: The `router.replace()` method is very similar to the `router.push()` method,
    the difference being it replaces the current entry in the browser history with
    the new route instead of adding a new entry.
  prefs: []
  type: TYPE_NORMAL
- en: Now if you log in, you should be redirected to the support ticket page instead
    of the home page.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing user authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When the page load and the application start, we need to check if the user
    is already connected. For this reason, the server has a `/user` path that returns
    the user object if they are logged in. We will put it in the global state just
    like if we logged in. Then, we will start the Vue app:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `main.js` file, import `$fetch` from our plugin:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we need to create a new asynchronous function called `main`, inside of
    which we will request the user data and then start the app:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: Now if you log in and then you refresh the page, you should still be connected!
  prefs: []
  type: TYPE_NORMAL
- en: Guest routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is another case we don't manage yet--we don't want an already connected
    user to access the login route!
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s why we will mark it as a guest route:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `beforeEach` navigation guard, we will check if the route is guest-only
    and if the user is already connected, then redirect to the home page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: If you are logged in, you can try going to the login URL--you should be immediately
    redirected to the home page! You can only access this page if you are not logged
    in.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying and adding tickets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will add the ticket support content to the app. First we
    will display them and then build a form to let the user create new ones. We will
    have two components for this, nested in the `TicketsLayout` component we made
    earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Don't worry! When you created your account, an example support ticket was automatically
    created for your user.
  prefs: []
  type: TYPE_NORMAL
- en: Tickets list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The tickets can be requested at `/tickets` on the server:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new `Tickets.vue` component that will be pretty much like the FAQ component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use the `RemoteData` mixin to fetch the tickets:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the template with a loading animation, an empty message, and the list
    of the tickets:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: We need a filter to display the ticket date!
  prefs: []
  type: TYPE_NORMAL
- en: 'Kill the client compilation and install `momentjs` with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new `filters.js` file next to the `main.js` file, with a `date` filter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: 'Then in `main.js`, import the `filters` and register them with a handy loop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now display the dates in a more human-friendly way in the `Tickets`
    component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then add this new component to the `TicketsLayout` component and get
    the list of tickets:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/32ded18f-6a20-4a04-a4d2-8e5af3f44dd2.png)'
  prefs: []
  type: TYPE_IMG
- en: Don't forget to import `Tickets` and set it in the `components` option!
  prefs: []
  type: TYPE_NORMAL
- en: Session expiration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After some time, the user session might become no longer valid. This could
    happen because of timed expiration (for this server this is set to three hours),
    or simply because the server was restarted. Let''s try to reproduce this kind
    of situation--we are going to restart the server and try to load the tickets again:'
  prefs: []
  type: TYPE_NORMAL
- en: Make sure you are logged into the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type `rs` and then press `Return` in the Terminal where the server is running
    to restart it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the Home button in the app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the support ticket button to go back to the tickets list page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You should have a stuck loading animation and an error message in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a356239a-cb14-4919-82be-6145adbf8c1d.png)'
  prefs: []
  type: TYPE_IMG
- en: The server has returned an unauthorized error--that's because we are no longer
    logged in!
  prefs: []
  type: TYPE_NORMAL
- en: To fix this, we need to log the user out and redirect them to the login page
    if we are in a private route.
  prefs: []
  type: TYPE_NORMAL
- en: The best place to put our code is the `$fetch` method used in all our components,
    located in the `plugins/fetch.js` file. The server will always return a 403 error
    when trying to access a path restricted to connected users.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before modifying the method, we need to import both the state and the router:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s add a new case in the response processing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: We use the `replace` method instead of `push` because we don't want to create
    a new navigation in the browser history. Imagine if the user clicks the back button,
    it will redirect again to the login page and the user will not be able to go back
    to the page before the private one.
  prefs: []
  type: TYPE_NORMAL
- en: You can now try again--when you restart the server and click on the support
    tickets link, you should be redirected to the login page and the navigation menu
    should not display your username anymore.
  prefs: []
  type: TYPE_NORMAL
- en: Nested routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since we also want to switch to a form in this page, it would be a good idea
    to structure our components with nested routes--each route can have child routes
    if they have at least a router view! So under the `/tickets` router, we will have
    two children for now:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''''` will be the tickets list (full path will be `/tickets/`). It acts like
    the default route under `/tickets`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''/new''` will be the form to send new tickets (full path will be `/tickets/new/`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Create a new `NewTicket.vue` component with a temporary template:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `routes.js` file, add the two new routes under the `/tickets` route
    inside the children attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: Since the first child route is an empty string, it will be the default when
    the parent route is resolved. This means you should move the name of the route
    (`'tickets'`) from the parent to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we can change the `TicketsLayout` component to use a router view along
    with a few buttons to switch between the child routes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: You can use the `tag` prop on router links to change the HTML tag used to render
    it.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we hide each button depending on the current route name--we
    don't want to display the Show tickets button when we are already on the tickets
    page, and we don't want the New ticket button when we are already on the corresponding
    form!
  prefs: []
  type: TYPE_NORMAL
- en: 'You can now switch between the two child routes and see the URL change accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/cf2479f9-c46e-42fc-a2b5-19b470ea7f57.png)'
  prefs: []
  type: TYPE_IMG
- en: Fixing our navigation guard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you log out and then go to the tickets page, you should be surprised to be
    able to access the page! This is because there is a flaw in the implementation
    of our `beforeEach` navigation guard--we poorly designed it without taking into
    account the fact we could have nested routes! The reason for this issue is that
    the `to` parameter is only the target route, which is the first child route of
    the `/tickets` route--it doesn't have the `private` meta attribute!
  prefs: []
  type: TYPE_NORMAL
- en: So instead of relying solely on the target route, we should also check all the
    matched nested route objects. Thankfully, every route object gives us access to
    the list of these route objects with the `matched` property. We can then use the
    `some` array method to verify if at least one route object has the desired meta
    attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can change the conditions code to this in the `beforeEach` navigation guard
    in the `router.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: Now our code works regardless of the number of nested routes!
  prefs: []
  type: TYPE_NORMAL
- en: It is strongly recommended to use this approach with the `matched` property
    every time to avoid errors.
  prefs: []
  type: TYPE_NORMAL
- en: Sending a form
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we are going to complete the `NewTicket` component that will
    allow the user to send a new support ticket. We need two fields to create a new
    ticket--`title` and `description`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the template of the `NewTicket.vue` component, we can already add a `SmartForm`
    component with the title `InputForm` component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also add the two data properties, the `operation` method and some input
    validation with the `valid` computed property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: Form textarea
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For the `description` field, we need a `<textarea>` element so the user can
    write a multiline text. Unfortunately, our `FormInput` component doesn''t support
    this yet, so we need to modify it a bit. We will use the `type` prop of the component
    with the value `''textarea''` to change the `<input>` element to a `<textarea>`
    element:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a new computed property to determine which kind of HTML element
    we are going to render:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: So when the value `'textarea'` is passed, we need to render a `<textarea>`.
    All the other types will make the component render an `<input>` element.
  prefs: []
  type: TYPE_NORMAL
- en: We can now use the special `<component>` component, which can render either
    elements with the `is` prop, instead of the static `<input>` element.
  prefs: []
  type: TYPE_NORMAL
- en: 'The line in the template should now look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now add the `description` textarea to the `NewTicket` form just after
    the `title` input:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: Binding attributes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Among other elements, `<textarea>` has some handy attributes we would like to
    use, such as the `rows` attribute. We could create a prop for each of them, but
    this could become tedious very quickly. Instead, we are going to use the handy
    `$attrs` special property of the Vue component, which gets all the non-prop attributes
    set on the component as an object with the keys being the names of the attributes.
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that if you have let''s say, one `text` prop on your component and
    that you write this in another component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: Vue will treat `required` as an attribute, since it is not in the list of props
    exposed by the `FormInput` component. Then you can access it with `$attrs.required`!
  prefs: []
  type: TYPE_NORMAL
- en: The `v-bind` directive can get an object with the keys being the names of the
    props and attributes to set. This will be very useful!
  prefs: []
  type: TYPE_NORMAL
- en: 'We can write this on `<component>` in the `FormInput.vue` component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can add the `rows` attribute on the `description` input in the `NewTicket.vue`
    component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see in the rendered HTML that the attribute has been set on the
    `<textarea>` element inside the `FormInput` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: User actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will now implement the few actions the users will be able to do in the form:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `SmarForm` component, add these two buttons after the inputs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: 'Then implement the `operation` method, which will be similar to what we have
    done in the `Login` component. The server path we need to send the `POST` request
    to is `/tickets/new`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: You can now create new tickets!
  prefs: []
  type: TYPE_NORMAL
- en: Backup user input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To improve the user experience, we should automatically back up what the user
    has typed into the form in case something goes wrong--for example, the browser
    could crash or the user could accidentally refresh the page.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to write a mixin that will automatically save some data properties
    into the browser local storage, and restore them when the component is created:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new `PersistantData.js` file in the `mixins` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Like the other mixin we did, it will have some parameters, so we need to export
    it as a function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: The `id` argument is the unique identifier to store the data for this specific
    component.
  prefs: []
  type: TYPE_NORMAL
- en: First we are going to watch all the fields passed in the mixin.
  prefs: []
  type: TYPE_NORMAL
- en: 'For that, we will dynamically create the `watch` object, with each key being
    the field and the value being the handler function that will save the value into
    the local storage:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: 'Go back to the `NewTicket` component and add the mixin:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: 'So, the mixin added watchers to the component with the `reduce` producing the
    equivalent of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: We are saving the property values as JSON since the local storage only supports
    strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can try typing into the fields, and then look at the browser dev tools
    to see that two new local storage items have been saved:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/f2105df0-659f-4c82-8e3f-71c21eb1e58c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the mixin, we can also save the fields when the component is destroyed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to restore the values when the component is created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: Now if you type something into the form, and then refresh the page, what you
    typed should be still in the form!
  prefs: []
  type: TYPE_NORMAL
- en: With the session expiration management we added to `$fetch`, you will be redirected
    to the login page if you try to send your new ticket while you are no longer connected.
    Then, once you're logged in again, you should be right back to the form with what
    you typed still there!
  prefs: []
  type: TYPE_NORMAL
- en: Advanced routing features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is the last section of this chapter, in which we will explore routing a
    bit more!
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic routes with parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last component we will add in the application is `Ticket`, which display
    a detailed view of one ticket by its ID. It will show the title and description
    inputted by the user, plus the date and the status.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new `Ticket.vue` file and add this template with the usual loading
    animation and `not found` notice:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add an `id` prop to the component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: Dynamic remote data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `id` prop will be the ID of the ticket for which we will fetch the details.
    The server provides a dynamic route in the form of `/ticket/<id>`, with `<id>`
    being the ID of the ticket.
  prefs: []
  type: TYPE_NORMAL
- en: 'It would be nice to be able to use our `RemoteData` mixin, but it currently
    lacks support for dynamic paths! What we could do is to pass a function instead
    of a plain string as the values of the mixin''s parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `RemoteData` mixin, we just need to modify the way we process the parameter
    in the `created` hook. If the value is a function, we will use the `$watch` method
    to watch its value instead of directly calling the `fetchResource` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: 'Don''t forget the `immediate: true` option for the watcher since we want to
    call `fetchResource` a first time before watching the value.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `Ticket` component, we can now use this mixin to load the data of the
    ticket depending on the `id` prop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: Let's try this in the `Tickets` component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the new `Ticket` component to it with a new `id` data property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: 'Then in the template, add a `Ticket` component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: 'In the ticket list, change the title to a link that sets the `id` data property
    on `click`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: 'If you click on the tickets in the application, you should have the details
    in the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/291c8703-598a-43a2-b94e-af8a7c2de73e.png)'
  prefs: []
  type: TYPE_IMG
- en: The dynamic route
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since we are going to put the ticket details in another route, you can undo
    what we just did in the `Tickets` component.
  prefs: []
  type: TYPE_NORMAL
- en: The route will be a child route of the tickets route, and will be of the form
    `/tickets/<id>` where `<id>` is the ID of the ticket being displayed. This is
    possible thanks to the dynamic route matching feature of vue-router!
  prefs: []
  type: TYPE_NORMAL
- en: 'You can add dynamic segments to your route path with the semicolon. Then, each
    segment will be exposed in the route `params` object. Here are some examples of
    routes with parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Pattern | Example path | `$route.params` value |'
  prefs: []
  type: TYPE_TB
- en: '| `/tickets/:id` | `/tickets/abc` | `{ id: ''abc'' }` |'
  prefs: []
  type: TYPE_TB
- en: '| `/tickets/:id/comments/:comId` | `/tickets/abc/comments/42` | `{ id: ''abc'',
    comId: ''42'' }` |'
  prefs: []
  type: TYPE_TB
- en: 'Let''s add the new route in the `router.js` file as a child route of `/tickets`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `Tickets` component list, we need to change the title element to a link
    pointing to the new route:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: Now if you click on a ticket, the `$route.params` object will have the `id`
    property set to the of the ticket.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could change our `Ticket` component to use this with a computed property
    instead of a prop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: But this is a bad idea--we are coupling the component to the route! This means
    we won't be able to reuse it in another way easily. The best practice is to use
    props to pass info to components, so let's continue to do that!
  prefs: []
  type: TYPE_NORMAL
- en: 'So we are going to keep the ID prop of the `Ticket` component and tell `vue-router`
    to pass all the route parameters to it as prop with the `props` attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: 'This is equivalent to this more flexible syntax based on a function that gets
    the route object as the argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: 'Another syntax based on an object exists too (useful when the props are static):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: We won't use this third syntax since our `id` prop should be equal to the dynamic
    parameter of the route.
  prefs: []
  type: TYPE_NORMAL
- en: If you need to combine static and dynamic props, use the function syntax! This
    is also useful if the route parameters and the component props names don't match.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the `id` parameter is passed as a prop to the component and you should
    see the ticket details page when clicking on a ticket in the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/bbad02ee-1190-4f86-9416-dafa76a361f7.png)'
  prefs: []
  type: TYPE_IMG
- en: Not found page
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Currently, if you enter an invalid URL into the app, you are greeted with a
    boring blank page. This is the default behavior of `vue-router`, but it can thankfully
    be changed! We will now customize the "not found" page of our app!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a better "not found" page with a new `NotFound.vue` component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: 'Now in the `router.js` file, we just need to add a new route matching the `''*''`
    path:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: This means that for any route, we display the `NotFound` component. The very
    important fact is that we put this route at the end of the `routes` array--this
    ensures that all the legit routes will be matched before matching this last particular,
    catch-all route.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can now try a URL that doesn''t exist, like `/foo`, to have the page displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/343904f2-8f5a-4a56-9b8b-c20d75db9122.png)'
  prefs: []
  type: TYPE_IMG
- en: Transitions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Animating the route changes is very easy--this is done in exactly the same
    way we did before:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `AppLayout` component, wrap the router view with this transition:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: The `router-view` special component will be replaced by the different component
    of the routes we have, and thus trigger the transition.
  prefs: []
  type: TYPE_NORMAL
- en: Scrolling behavior
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The history mode of the router allows us to manage the page scrolling when a
    route changes. We can reset the position to the top every time, or restore the
    position the user was in before changing the route (this is very useful when they
    go back in the browser).
  prefs: []
  type: TYPE_NORMAL
- en: 'When creating the router instance, we can pass a `scrollBehavior` function
    that will get three arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '`to` is the target route object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`from` is the previous route object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`savedPosition` is the scroll position that has been automatically saved for
    each entry in the browser history. Each new entry will not have this until the
    route changes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `scrollBehavior` function expects an object that can take two different
    forms. The first is the coordinate of the scroll we want to apply; for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: 'The second one is a selector of the HTML element we want the page to scroll
    to, with an optional offset:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: 'So to scroll to the top of the page when the route changes, we need to write
    this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: 'To scroll to the `<h1>` element each time, we could do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead, we will check if the route has a hash to mimic the browser behavior:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can restore the scroll position if there is any:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: It's that simple! The app now should behave like an old multi-page website.
    You can then customize the way the scroll behaves with offset or route meta properties.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we created a fairly big application with the help of Vue and
    the official `vue-router` library. We created a few routes and connected them
    with links that turned into a real navigation menu. Then, we created a generic
    and reusable component to build the application forms, which helped us make the
    login and signup forms. We then integrated the user authentication system with
    the router, so our application could react in smart ways to page refreshes or
    session expirations. Finally, we went deeper into the features and capabilities
    of `vue-router` to enhance our application and user experience even further.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are done with the app, but feel free to improve it on your own! Here are
    some ideas you could implement:'
  prefs: []
  type: TYPE_NORMAL
- en: Add comments to the tickets. Display the list of comments with the name of the
    corresponding user.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add close this ticket button, preventing users from adding new comments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Display a special icon next to a closed ticket in the tickets list!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add roles to users. For example, normal users could open tickets, but only admin
    users could close them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next chapter, we will create a geolocated blogging application and we
    will learn how to scale our apps more with a centralized state solution and how
    to integrate third-party libraries to extend the features of Vue.
  prefs: []
  type: TYPE_NORMAL
