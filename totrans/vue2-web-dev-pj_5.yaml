- en: Project 3 - Support Center
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目 3 - 支持中心
- en: 'In this chapter, we will build a more complex application with a routing system
    (this means multiple virtual pages). This is going to be a support center for
    a fictional company called "My Shirt Shop". It will have two main parts:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将构建一个更复杂的应用程序，具有路由系统（这意味着多个虚拟页面）。这将是一个名为“我的衬衫店”的虚构公司的支持中心。它将有两个主要部分：
- en: An FAQ page with a few questions and answers
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个包含一些问题和答案的常见问题页面
- en: A support ticket management page where the user will be able to display and
    create new tickets
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个支持工单管理页面，用户将能够显示和创建新工单
- en: The application will have an authentication system that will allow users to
    create an account or log in.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序将具有身份验证系统，允许用户创建帐户或登录。
- en: We will first start creating some basic routes, then we will integrate this
    account system to finish with more advanced topics regarding routing. Through
    the chapter, we will reuse our code as much as possible and apply best practices.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建一些基本路由，然后将集成此帐户系统，最后涉及更高级的路由主题。在整个章节中，我们将尽可能重用我们的代码并应用最佳实践。
- en: General app structure
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一般应用程序结构
- en: In this first part, we are going to create the project structure and learn more
    about routing and pages.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一部分中，我们将创建项目结构并了解更多关于路由和页面的知识。
- en: Setting up the project
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置项目
- en: 'For setting up the project, the following steps need to be followed:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设置项目，需要按照以下步骤进行操作：
- en: 'First, generate a Vue project with the `vue init webpack-simple <folder>` command,
    like we did in [Chapter 4](cb653442-5aaa-47b6-ad7b-d94ce15821b7.xhtml), *Advanced
    Project Setup*:'
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，使用 `vue init webpack-simple <folder>` 命令生成一个 Vue 项目，就像我们在[第 4 章](cb653442-5aaa-47b6-ad7b-d94ce15821b7.xhtml)中所做的那样，*高级项目设置*：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Install the packages necessary to compile Stylus code (our style will be written
    using Stylus):'
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装编译 Stylus 代码所需的软件包（我们的样式将使用 Stylus 编写）：
- en: '`stylus`'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stylus`'
- en: '`stylus-loader`'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stylus-loader`'
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Don't forget to save the development tools packages in the development dependencies
    of your `package.json` file with the `--save-dev` flag.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记使用 `--save-dev` 标志将开发工具包保存在 `package.json` 文件的开发依赖项中。
- en: Remove the content of the `src` folder where we will put all the sources of
    our app.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除 `src` 文件夹的内容，我们将把所有应用程序源代码放在其中。
- en: 'Then create a `main.js` file with the code needed to create a Vue app:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后创建一个 `main.js` 文件，其中包含创建 Vue 应用程序所需的代码：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You can now try to run the app with the `npm run dev` command!
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以使用 `npm run dev` 命令运行应用程序了！
- en: Most the style for the app is already available. Download it ([https://github.com/Akryum/packt-vue-project-guide/tree/master/chapter5-download)](https://github.com/Akryum/packt-vue-project-guide/tree/master/chapter5-download)
    and extract the Stylus files into a `style` folder inside the `src` directory.Extract
    the `assets` folder too.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 大多数应用程序的样式已经可用。下载它（[https://github.com/Akryum/packt-vue-project-guide/tree/master/chapter5-download)](https://github.com/Akryum/packt-vue-project-guide/tree/master/chapter5-download)
    并将 Stylus 文件提取到 `src` 目录内的 `style` 文件夹中。也提取 `assets` 文件夹。
- en: Routing and pages
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由和页面
- en: 'Our app will be organized in six main pages:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序将组织在六个主要页面中：
- en: The home page
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主页
- en: The public FAQ page
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公共常见问题页面
- en: The login page
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 登录页面
- en: The tickets page
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工单页面
- en: A page to send a new ticket
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送新工单的页面
- en: A page showing one ticket details and conversation
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示一个工单详情和对话的页面
- en: A route is a path representing a state of the application, usually in the form
    of pages. Each route is associated with a URL pattern that will trigger the route
    when the address matches. Then, the corresponding page will be presented to the
    user.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 路由是表示应用程序状态的路径，通常以页面的形式存在。每个路由都与一个 URL 模式相关联，当地址匹配时将触发路由。然后，相应的页面将呈现给用户。
- en: Vue plugins
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Vue 插件
- en: 'To enable routing in our app, we need an official Vue plugin called `vue-router`.
    A Vue plugin is some JavaScript code designed to add more features to the Vue
    library. You can find many plugins on the npm registry, and I recommend the awesome–vue
    GitHub repository ([https://github.com/vuejs/awesome-vue](https://github.com/vuejs/awesome-vue))
    that lists them by category:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在我们的应用程序中启用路由，我们需要一个名为`vue-router`的官方Vue插件。Vue插件是一些设计用来为Vue库添加更多功能的JavaScript代码。您可以在npm注册表上找到许多插件，我推荐使用awesome-vue
    GitHub存储库（[https://github.com/vuejs/awesome-vue](https://github.com/vuejs/awesome-vue)）按类别列出它们：
- en: 'Download the `vue-router` package from npm with the following command in the
    project directory:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目目录中使用以下命令从npm下载`vue-router`包：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We will put all the routing–related code in a new `router.js` file next to the
    `main.js` file, which you need to create. Then, we need to install the plugin
    we want to use (which is `vue-router` in our case) with the global `Vue.use()`
    method.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把所有与路由相关的代码放在`main.js`文件旁边的新`router.js`文件中，您需要创建该文件。然后，我们需要使用全局的`Vue.use()`方法安装我们想要使用的插件（在我们的情况下是`vue-router`）。
- en: 'Create the `router.js` file and import both the `Vue` library and the `VueRouter`
    plugin from their corresponding packages:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`router.js`文件，并从它们对应的包中导入`Vue`库和`VueRouter`插件：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then install the plugin into Vue:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后将插件安装到Vue中：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `vue-router` plugin is now ready to be used!
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`vue-router`插件现在已准备好使用！'
- en: Our first routes with vue–router
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们的第一个使用vue-router的路由
- en: In this section, we will go through the steps required to set up routing in
    our Vue application.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍在Vue应用程序中设置路由所需的步骤。
- en: Layouts with router–view
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用router-view的布局
- en: Before adding routes, we need to setup a layout for the app where the route
    components will be rendered.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加路由之前，我们需要为应用程序设置一个布局，路由组件将在其中呈现。
- en: Let's create a component called `AppLayout.vue` in a new `components` folder
    inside the `src` directory.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在`src`目录内的新`components`文件夹中创建一个名为`AppLayout.vue`的组件。
- en: 'Write the template of the component--a `<div>` element containing a `<header>`
    with an image and some text. Then, add a `<router-view />` component after the
    header:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写组件的模板--包含一个带有图像和一些文本的`<header>`的`<div>`元素。然后，在标题后添加一个`<router-view />`组件：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `<router-view />` component is a special component provided by the `vue-router`
    plugin that will render the component of the current matching route. It is not
    a real component since it doesn't have its own template, and it will not appear
    in the DOM.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`<router-view />`组件是由`vue-router`插件提供的特殊组件，它将呈现当前匹配路由的组件。它不是一个真正的组件，因为它没有自己的模板，并且不会出现在DOM中。'
- en: 'After the template, add a `style` tag importing the main Stylus file from the
    `styles` folder you downloaded earlier in the *Setting up the project* section.
    Don''t forget to specify that we are using `stylus` with the `lang` attribute:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模板之后，添加一个`style`标签，从*设置项目*部分中下载的`styles`文件夹中导入主Stylus文件。不要忘记使用`lang`属性指定我们正在使用`stylus`：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Since we can have as many `style` tags as we need in a SFC, add another one,
    but scoped this time. We will specify the size of the `header` logo in this second
    style section:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们可以在SFC中拥有尽可能多的`style`标签，因此再添加一个，但这次是有作用域的。我们将在第二个样式部分中指定`header`标志的大小：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: To improve the performance, it is recommended to use classes inside scoped styles.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高性能，建议在有作用域的样式中使用类。
- en: Our layout component is ready to be included in our app!
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的布局组件已准备好包含在我们的应用程序中！
- en: 'In the `main.js` file, import it and render it on the `root` Vue instance:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main.js`文件中导入它并在`root`Vue实例上呈现它：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We can't start the app yet, since we are not finished with routing!
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还不能启动应用程序，因为我们的路由还没有完成！
- en: If you look at the console of your browser, you might see an error message complaining
    about the `<router-view />` component being missing. This is because we don't
    have the imported `router.js` file where we installed the `vue-router` plugin
    into Vue, so the code isn't included in our app yet.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看浏览器的控制台，你可能会看到一个错误消息，抱怨`<router-view />`组件丢失了。这是因为我们没有导入`router.js`文件，我们在其中将`vue-router`插件安装到Vue中，所以代码还没有包含在我们的应用程序中。
- en: Creating routes
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建路由
- en: 'Let''s create a few dumb pages for test routing:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为测试路由创建一些愚蠢的页面：
- en: 'In the `components` folder, create a `Home.vue` component containing a very
    simple template with a `<main>` element, a title, and some text:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`components`文件夹中，创建一个`Home.vue`组件，其中包含一个非常简单的模板，包括一个`<main>`元素，一个标题和一些文本：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then, create an `FAQ.vue` component next to `Home.vue`. It should also contain
    a `<main>` element, inside of which you can add a simple title:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在`Home.vue`旁边创建一个`FAQ.vue`组件。它也应该包含一个`<main>`元素，其中你可以添加一个简单的标题：
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We now have what we need to create a few routes.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了创建一些路由所需的东西。
- en: 'In the `router.js` file, import the two components we just created:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`router.js`文件中，导入我们刚刚创建的两个组件：
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then, create a `routes` array:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，创建一个`routes`数组：
- en: '[PRE13]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'A route is an object containing a path, a name, and a component to render:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 路由是一个包含路径、名称和要渲染的组件的对象：
- en: '[PRE14]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The path is the pattern that the current URL should match for the route to be
    activated. The component will be rendered in the special `<router-view />` component.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 路径是当前URL应该匹配的模式，以激活路由。组件将呈现在特殊的`<router-view />`组件中。
- en: The route name is optional, but I strongly recommend using it. It allows you
    to specify the names of the routes instead of the path, so that you can move and
    change your routes around without ending up with broken links.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 路由名称是可选的，但我强烈建议使用它。它允许您指定路由的名称而不是路径，这样您就可以移动和更改路由而不会出现断开的链接。
- en: 'With that in mind, we can now add our two routes in the `routes` array:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑到这一点，我们现在可以在`routes`数组中添加我们的两个路由：
- en: '[PRE15]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let''s review what it will do:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来回顾一下它将会做什么：
- en: When the browser URL is `http://localhost:4000/`, the `Home.vue` component will
    be rendered
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当浏览器URL为`http://localhost:4000/`时，将呈现`Home.vue`组件
- en: When the URL is `http://localhost:4000/faq/`, the `FAQ.vue` component will be
    displayed
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当URL为`http://localhost:4000/faq/`时，将显示`FAQ.vue`组件
- en: The router object
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由对象
- en: 'With our routes ready, we need to create a `router` object that will take care
    of managing the routing for us. We will use the `VueRouter` constructor from the
    `vue-router` package. It takes one `options` parameter and for now, we are going
    to use the `routes` parameter:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 有了我们准备好的路由，我们需要创建一个`router`对象来负责管理路由。我们将使用`vue-router`包中的`VueRouter`构造函数。它接受一个`options`参数，现在，我们将使用`routes`参数：
- en: 'After the `routes` array in the `router.js` file, create a new `router` object
    and specify the `routes` parameter:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`router.js`文件中的`routes`数组之后，创建一个新的`router`对象并指定`routes`参数：
- en: '[PRE16]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The plugin we installed is also the router constructor, so we are using the
    same `VueRouter` variable. `VueRouter` is in fact a valid Vue plugin because it
    has an `install` method. We will create our own plugin in this chapter!
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们安装的插件也是路由构造函数，所以我们使用相同的`VueRouter`变量。`VueRouter`实际上是一个有效的Vue插件，因为它有一个`install`方法。在本章中，我们将创建自己的插件！
- en: 'Export the `router` object as the default exported value of the module:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`router`对象导出为模块的默认导出值：
- en: '[PRE17]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now back to our `main.js` file, we need to provide the `router` object to the
    Vue application. Import the `router` we just created:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在回到我们的`main.js`文件，我们需要将`router`对象提供给Vue应用程序。导入我们刚刚创建的`router`：
- en: '[PRE18]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then add it as a definition option to the root Vue instance:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后将其作为根Vue实例的定义选项添加：
- en: '[PRE19]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'That is all we need to have routing working! You can now try to change the
    URL in your browser to either `http://localhost:4000/#/` or `http://localhost:4000/#/faq`
    and get a different page each time:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们让路由工作所需的全部！现在你可以尝试在浏览器中更改URL为`http://localhost:4000/#/`或`http://localhost:4000/#/faq`，每次都会得到不同的页面：
- en: '![](assets/573630b2-2281-4d69-a433-340ca757d243.png)Don''t forget the sharp
    `#` character in the URL; it is needed to fake the route changes while not changing
    the real web page. This is the default router mode called `hash`, and it works
    with any browser and server.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/573630b2-2281-4d69-a433-340ca757d243.png)不要忘记URL中的尖号`#`字符；在不更改真正的网页的情况下，需要伪造路由更改。这是称为`hash`的默认路由器模式，并且可以与任何浏览器和服务器一起使用。'
- en: Router modes
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由器模式
- en: We can change the router mode with the `mode` parameter in the constructor options.
    It can either be `'hash'` (default), `'history'`, or `'abstract'`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过构造函数选项中的`mode`参数来更改路由器模式。它可以是`'hash'`（默认值）、`'history'`或`'abstract'`。
- en: The `hash` mode is the default we are already using. It is the "safest" choice
    since it is compatible with any browser and server. It consists of using the "hash"
    part of the URL (which means the part after the sharp character) and change it
    or react to changes to it. The big advantage is that changing the hash part will
    not change the real web page where our app is running (which would be very unfortunate).
    The obvious drawback is that it forces us to separate the URL in two with the
    not so pretty sharp symbol.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`hash`模式是我们已经在使用的默认模式。这是“最安全”的选择，因为它与任何浏览器和服务器兼容。它包括使用URL的“hash”部分（也就是尖号后面的部分）并更改它或对其进行反应。最大的优势是更改哈希部分不会更改我们的应用程序正在运行的真正网页（这将是非常不幸的）。显而易见的缺点是它强迫我们用不太漂亮的尖号符号将URL分成两部分。'
- en: 'Thanks to the HTML5 `history.pushState` API, we can get rid of this sharp character
    and get a real URL for our app! We need to change the mode to `''history''` in
    the constructor:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 由于HTML5的`history.pushState` API，我们可以摆脱这个尖锐字符，并为我们的应用程序获得一个真正的URL！我们需要在构造函数中将模式更改为`'history'`：
- en: '[PRE20]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now we can use pretty URLs such as `http://localhost:4000/faq` in our Single-Page
    App! There are two problems though:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以在我们的单页面应用程序中使用漂亮的URL，比如`http://localhost:4000/faq`！不过有两个问题：
- en: The browser needs to support this HTML5 API, which means it won't work on Internet
    Explorer 9 or less (all other major browsers have supported it for quite some
    time).
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浏览器需要支持这个HTML5 API，这意味着它在Internet Explorer 9或更低版本上无法工作（其他主要浏览器已经支持了相当长的时间）。
- en: The server has to be configured to send the home page instead of throwing a
    404 error when accessing a route such as `/faq`, since it doesn't really exist
    (you don't have a file called `faq.html`). This also means we will have to implement
    the 404 page ourselves.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器必须配置为在访问`/faq`这样的路由时发送主页，而不是抛出404错误，因为它实际上并不存在（你没有一个名为`faq.html`的文件）。这也意味着我们将不得不自己实现404页面。
- en: Thankfully, the webpack server used by `vue build` is configured to support
    this by default. So you can go ahead and try the new `http://localhost:4000/faq`
    URL!
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 值得庆幸的是，由`vue build`使用的webpack服务器默认配置为支持这一点。所以你可以继续尝试新的`http://localhost:4000/faq`
    URL！
- en: There is a third mode called `abstract` that can be used in any JavaScript environment
    (including Node.js). If there is no browser API available, the router will be
    forced to use this mode.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 有第三种模式称为“抽象”，可以在任何JavaScript环境中使用（包括Node.js）。如果没有浏览器API可用，路由将被迫使用此模式。
- en: Creating a navigation menu
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建导航菜单
- en: 'Instead of manually typing the URL, it would be great to have a proper navigation
    `menu` in our app! Let''s create a new `NavMenu.vue` file in our `components`
    folder:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 与手动输入URL相比，在我们的应用程序中拥有一个合适的导航`菜单`将会很棒！让我们在我们的`components`文件夹中创建一个新的`NavMenu.vue`文件：
- en: '[PRE21]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Next, we will add it in the layout. Import the new component in the `AppLayout`
    one:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在布局中添加它。在`AppLayout`中导入新组件：
- en: '[PRE22]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Then add it to the `AppLayout` template:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将其添加到`AppLayout`模板中：
- en: '[PRE23]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Router links
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由链接
- en: The `vue-router` plugin provides us with another handy special component--`<router-link>`.
    It is a component that will change to a specified route when clicked thanks to
    its `to` prop. By default, it will be a `<a>` HTML element, but this can be customized
    with the `tag` prop.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`vue-router`插件为我们提供了另一个方便的特殊组件--`<router-link>`。这是一个组件，当单击时将切换到指定的路由，这要归功于它的`to`属性。默认情况下，它将是一个`<a>`
    HTML元素，但可以使用`tag`属性进行自定义。'
- en: 'For example, a link to the FAQ page would be:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，指向FAQ页面的链接将是：
- en: '[PRE24]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `to` prop can also get an object with the name property instead of the
    path:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`to`属性也可以获得一个具有名称属性而不是路径的对象：'
- en: '[PRE25]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This will dynamically generate the correct path for the route. I recommend you
    to use this second method as opposed to only specifying the path--that way, if
    you change the paths of your routes, your navigation links will still work.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这将动态生成路由的正确路径。我建议您使用这种第二种方法，而不是仅指定路径--这样，如果您更改路由的路径，您的导航链接仍将起作用。
- en: When using the object notation, don't forget to bind the `to` prop with `v-bind`
    or the `:` shorthand, or else the `router-link` component will get a string and
    won't understand it's an object.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用对象表示法时，不要忘记使用`v-bind`或`:`简写将`to`属性绑定到`router-link`组件，否则`router-link`组件将获得一个字符串，并且不会理解它是一个对象。
- en: 'Now we can add the links to our `NavMenu` component:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以将链接添加到我们的`NavMenu`组件中：
- en: '[PRE26]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'You should now have a working menu in the app:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您应该在应用程序中有一个可用的菜单：
- en: '![](assets/09491639-cb34-4468-a2ec-e31562b55427.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/09491639-cb34-4468-a2ec-e31562b55427.png)'
- en: Active class
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 活动类
- en: 'A router link gets the active class when the route it is associated with is
    currently active. By default, the component gets the `router-link-active` CSS
    class, so you can change its visuals accordingly:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当与其关联的路由当前处于活动状态时，路由链接将获得活动类。默认情况下，组件会获得`router-link-active` CSS类，因此您可以相应地更改其外观：
- en: 'In our `NavMenu.vue` component, declare some scoped style to add a bottom border
    to the active link using Stylus:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的`NavMenu.vue`组件中，声明一些作用域样式，使用Stylus为活动链接添加底部边框：
- en: '[PRE27]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We include the `$primary-color` variable with the `@import '../style/imports';`
    statement, which imports the `imports.styl` file containing the Stylus variables.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`@import '../style/imports';`语句中包含了`$primary-color`变量，该语句导入了包含Stylus变量的`imports.styl`文件。
- en: 'If you try the app now, you will find that something weird is happening with
    our menu. If you go to the Home page, it is working as expected:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您现在尝试该应用程序，您会发现我们的菜单出现了一些奇怪的情况。如果您转到主页，它会按预期工作：
- en: '![](assets/fcd3f66c-a061-4b55-8c19-ba01405e923f.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/fcd3f66c-a061-4b55-8c19-ba01405e923f.png)'
- en: 'But when you go to the FAQ page, both the Home and the FAQ links are highlighted:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 但当您转到FAQ页面时，主页和FAQ链接都会被突出显示：
- en: '![](assets/8baa75ec-9101-4117-8793-7168c1a06fd4.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/8baa75ec-9101-4117-8793-7168c1a06fd4.png)'
- en: This is because by default, the active class matching behavior is inclusive!
    This means `<router-link to="/faq">` will get the active class if the path is
    `/faq` or starts with `/faq/`. But it also means `<router-link to="/">` will get
    the class if the current path starts with `/`, which are all possible paths! That's
    why our Home link will always get the class.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为默认情况下，活动类匹配行为是包容的！这意味着`<router-link to="/faq">`如果路径是`/faq`或以`/faq/`开头，将获得活动类。但这也意味着`<router-link
    to="/">`如果当前路径以`/`开头，将获得该类，这些都是可能的路径！这就是为什么我们的主页链接总是会获得该类。
- en: To prevent this from happening, there is the `exact` prop, which is a Boolean.
    If it is set to `true`, the link will only get the active class if the current
    path is matching exactly.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止这种情况发生，有一个`exact`属性，它是一个布尔值。如果设置为`true`，则只有在当前路径完全匹配时，链接才会获得活动类。
- en: 'Add the `exact` prop to the Home link:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`exact`属性添加到主页链接：
- en: '[PRE28]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, only the FAQ link should be highlighted:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，只有FAQ链接应该被突出显示：
- en: '![](assets/218e9760-554f-4d93-bd60-423a3ca235d1.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/218e9760-554f-4d93-bd60-423a3ca235d1.png)'
- en: FAQ - Consuming an API
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FAQ - 使用API
- en: In this section, we will create the FAQ page, which will get data from the server.
    It will display a loading animation and then the list of questions and answers.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建FAQ页面，该页面将从服务器获取数据。它将显示加载动画，然后显示问题和答案列表。
- en: Server setup
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器设置
- en: This is our first app that will communicate with a server. You will get a server
    with a ready-to-use API.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的第一个与服务器通信的应用程序。您将获得一个带有可用API的服务器。
- en: 'You can download the server files ([https://github.com/Akryum/packt-vue-project-guide/tree/master/chapter5-download](https://github.com/Akryum/packt-vue-project-guide/tree/master/chapter5-download)).
    Extract them into another folder than our app and run the following commands to
    install the dependencies and launch the server:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以下载服务器文件（[https://github.com/Akryum/packt-vue-project-guide/tree/master/chapter5-download](https://github.com/Akryum/packt-vue-project-guide/tree/master/chapter5-download)）。将它们解压到与我们的应用程序不同的文件夹中，并运行以下命令来安装依赖项并启动服务器：
- en: '[PRE29]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: You should now have the server running on port 3000\. When this is done, we
    can continue building our app with a real backend this time!
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您应该在端口3000上运行服务器。完成后，我们可以继续构建我们的应用程序，这次使用真正的后端！
- en: Using fetch
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用fetch
- en: 'In the `FAQ.vue` Single File Component, we will use the standard `fetch` API
    of the web browser to retrieve the questions from our server. The request will
    be a very simple `GET` request to `http://localhost:3000/questions` with no authentication.
    Each question object will have `title` and `content` fields:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在`FAQ.vue`单文件组件中，我们将使用Web浏览器的标准`fetch` API从服务器检索问题。请求将是一个非常简单的`GET`请求到`http://localhost:3000/questions`，不需要身份验证。每个问题对象将有`title`和`content`字段：
- en: 'Open `FAQ.vue` and start by adding the `questions` data property in the component
    script, which will hold the array of questions retrieved from the server. We also
    need an `error` property to display a message when something goes wrong during
    the network request:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`FAQ.vue`，并首先在组件脚本中添加`questions`数据属性，该属性将保存从服务器检索的问题数组。我们还需要一个`error`属性，在网络请求期间出现问题时显示消息：
- en: '[PRE30]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now we can add the questions and answers to the template with a `v-for` loop,
    and the following error message:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以使用`v-for`循环将问题和答案添加到模板中，并显示以下错误消息：
- en: '[PRE31]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We are ready to fetch! The fetch API is promised-based and quite simple to
    use. Here is an example of `fetch` usage:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们准备好进行获取了！fetch API是基于promise的，非常简单易用。以下是`fetch`用法示例：
- en: '[PRE33]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We first call `fetch` with the first parameter being the URL of the request.
    It returns a promise with a `response` object, which holds information about the
    request result. If it was successful, we use `response.json()`, which returns
    a new promise with the JSON parsed result object.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用请求的URL作为第一个参数调用`fetch`。它返回一个带有`response`对象的promise，该对象保存有关请求结果的信息。如果成功，我们使用`response.json()`，它返回一个解析后的JSON结果对象的新promise。
- en: 'The request will be made inside the component as soon as it is created when
    the route is matched, which means that you should use the `created` life cycle
    hook in the component definition:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 请求将在组件内部进行，一旦创建时路由匹配，这意味着您应该在组件定义中使用`created`生命周期钩子：
- en: '[PRE34]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: If everything goes well, we will set the questions property with the JSON parsed
    result. Or else we will display an error message.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，我们将使用JSON解析后的结果设置问题属性。否则，我们将显示错误消息。
- en: 'Start by calling `fetch` with the right URL:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从正确的URL调用`fetch`开始：
- en: '[PRE35]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Add the first `then` callback with the `response` object:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加第一个`then`回调与`response`对象：
- en: '[PRE36]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We need another `then` callback since `response.json()` returns a new promise:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Finally, we catch all possible errors to display the error message:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Here is a summary of our `created` hook:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We can rewrite this code using the `async` and `await` JavaScript keywords
    to make it look like sequential code:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'You can now try the page, which should display a list of questions and answers:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ad13159c-6d51-4eaf-b5b4-bdcc1805b9ce.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
- en: 'To see if our error management is working, you can go to the console where
    the server is running, and stop it (for example, with the C*trl*+*C* keyboard
    shortcut). Then, you can reload the app and the following error message should
    be displayed:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/409552ab-7806-49a0-bf57-e5ca5a8cd921.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
- en: Loading animation
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is one last thing missing--we should show a loading animation to inform
    the user that an operation is in progress instead of an empty screen. To this
    effect, the server is faking a 1.5 s delay on the `/questions` request so we can
    easily see the loading animation.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we are going to display loading animations inside multiple components,
    we are going to create a new global component:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `components` folder, create a new `Loading.vue` file with the following
    template:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Create a new `global-components.js` file next to the `main.js` file in the
    `main` folder. In this file, we are going to register the `Loading` component
    globally with the `Vue.component()` method:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This is the file where we will register all the global components used across
    all the application.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, in the `main.js` file, import the `global-components.js` module:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Back to our `FAQ.vue` component, we need a new `loading` Boolean data property
    to toggle the display of the animation:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'In the template, add the loading animation:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Finally, change the `created` hook a bit by setting `loading` to `true` at
    the beginning, and `false` when everything is done:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'You can now reload the page and briefly see the loading animation before the
    questions appear:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/436a47ea-2274-4dbd-8f07-146d12974f14.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
- en: Extending Vue with our own plugin
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since we will use fetch in multiple components for our application and we want
    to reuse code as much as possible, it would be nice to have a method on all of
    our components that makes a request to the server with a predefined URL.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: This a nice use case for a custom Vue plugin! Don't worry, writing a plugin
    is actually pretty simple.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Creating a plugin
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create a plugin, there is only one rule--a plugin should be an object with
    an `install` method, which takes the Vue constructor as the first argument, and
    an optional `options` argument. This method will then add new features to the
    framework by modifying the constructor:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Create a new `plugins` folder in the `src` folder.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the `plugins` folder, create a `fetch.js` file where we will write our
    plugin. In this case, our plugin will add a new `$fetch` special method on all
    of our components. We will do that by changing the prototype of Vue.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s try creating a very simple plugin, by exporting an object with an `install`
    method:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: That's it! We have created a Vue plugin! Now, we need to install it into our
    application.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `main.js` file, import the plugin and then call the `Vue.use()` method
    just like we did for `vue-router`:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: You should now see the `'Installed!'` message in your browser console.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Plugin options
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can configure the plugin with an `options` parameter:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `install` method to add this parameter after `Vue`:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: We can now add a configuration object to the `Vue.use()` method in the `main.js`
    file.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add a `baseUrl` property to the configuration:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: You should now see the `options` object in the browser console.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: 'Store `baseUrl` into a variable so we can use it later:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Fetch method
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we are going to write the `$fetch` method. We will take most of the code
    we used in the `created` hook of the FAQ component:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement the `$fetch` method using `fetch`:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: We export it so we can use it in our plain JavaScript code too. The `url` parameter
    is now just the path of the query without the domain, which is now in our `baseUrl`
    variable--this allows us to change it easily without having to refactor each component.
    We also take care of the JSON parsing, since all the data from the server will
    be encoded in JSON.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: 'To make it available in all components, simply add it to the prototype of `Vue`
    (which is the constructor used to create components):'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Then, refactor the FAQ component to use our new special `$fetch` method in
    the created hook:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Our code in the component is now shorter, easier to read, and more scalable
    since we can change the base URL easily.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: Reusing code with mixins
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen how to create plugins, but there is another way to improve our
    code--what if we could reuse component definitions such as computed properties,
    methods, or watchers across multiple components? This is what mixins are for!
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: A mixin is a component definition object that can be applied to other definition
    objects (including other mixins). It is very simple to write, because it looks
    exactly the same as a regular component definition!
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: 'Our objective here is to have a `RemoteData` mixin that will allow any component
    to make requests to the server in order to fetch data. Let''s add a new `mixins`
    folder in the `src` directory, and create a new `RemoteData.js` file:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start simple by exporting a definition with a data property:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: This `remoteDataLoading` property will be used to count the number of requests
    that are currently loading, to help us display a loading animation.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to use this mixin in our FAQ component, we need to import it and add it
    in the `mixins` array:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'If you inspect the component, you should now see an additional `remoteDataLoading`
    property displayed:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/be837ea2-b9ad-4921-9e14-2231c38ab64d.png)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
- en: So what happened? The mixin got applied and merged into the component definition
    of `FAQ.vue`, which means that the data hook was called twice--first from the
    mixin, then from the FAQ definition and a new property was added!
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: Vue will automatically merge the standard options such as hooks, data, computed,
    methods, and watch, but if you have, for example, a property of a method with
    the same name, the last one applied will override the previous ones.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try overriding the new property in our component with another value:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'As you can see in the component inspector, the final component definition has
    a higher priority than the mixin. Also, you may have noticed that the `mixins`
    option is an array, thus we can apply multiple mixins to the definition, which
    will be merged in order. For example, consider we have two mixins and want to
    apply them to a component definition. Here is what will happen:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: The definition object contains the options of mixin 1.
  id: totrans-239
  prefs:
  - PREF_OL
  - PREF_OL
  type: TYPE_NORMAL
- en: The options of mixin 2 are merged into the definition object (existing property/method
    names are overriden).
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the same way, the options of the component are merged into the final definition
    object.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can now remove the duplicate `remoteDataLoading: 42,` from the FAQ component
    definition.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: Hooks such as `data`, `created`, `mounted`... are each called individually in
    the order they were applied to the final definition. This also means that the
    final component definition hooks will be called last.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: Fetching remote data
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have a problem--each component using our `RemoteData` mixin will have different
    data properties to fetch. Therefore, we need to pass parameters to our mixin.
    Since a mixin is essentially a definition object, why not use a function that
    can take parameters and then return a definition object? That's what we will do
    in our case!
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: 'Wrap the object we have defined inside a function with a `resources` parameter:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The `resources` parameter will be an object with each key being the name of
    the data property we want to add, and the value being the path of the request
    that needs to be made to the server.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: 'So we need to change the way we use the mixin in our `FAQ.vue` component to
    a function call:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Here, we are going to fetch the `http://localhost:3000/questions` URL (with
    the special `$fetch` method we created earlier) and put the result in the `questionList`
    property.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: Now onto our `RemoteData` mixin!
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: 'First things first, we need to initialize each data property to a `null` value,
    so Vue can set up reactivity on them:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: This step is important--if you don't initialize the data, it won't be made reactive
    by Vue, so the component will not be updated when the properties change.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: 'You can try the app and see in the component inspector that a new `questionList`
    data property has been added to the FAQ component:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/3e9d5417-0726-4394-8b40-50815458cf77.png)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
- en: 'Then, we will create a new `fetchResource` method that fetches one resource
    and update the corresponding data property:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Our component now has access to this new method and can use it directly.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: 'To make our mixin smarter, we will automatically call it inside the `created`
    hook (which will be merged):'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'You can now verify that the `questionList` data property gets updated with
    a new request made to the server:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/3eee8bfd-5850-4a4e-8d45-c5c574fd1549.png)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
- en: 'Then, you can remove the old code with the `questions` property in the `FAQ.vue`
    component and change the template to use the new property:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Loading management
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next thing we want to do is provide a way to know if the loading animation
    should be displayed. Since we could potentially have multiple requests, we are
    going to use a numeric counter instead of a Boolean--`remoteDataLoading` that
    we already declared in the `data` hook. Each time a request is made, we increment
    the counter, and when it is complete we decrement the counter. This means if it
    is equal to zero no request is currently pending, and if it is greater or equal
    to one we should display a loading animation:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the two statements incrementing and decrementing the `remoteDataLoading`
    counter in the `fetchResource` method:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'To make our life easier when using the mixin, let''s add a computed property
    called `remoteDataBusy` that will be `true` when we need to display the loading
    animation:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Back to our FAQ component, we can now remove the `loading` property, change
    the `v-if` expression for the `Loading` component, and use the `remoteDataLoading`
    computed property:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: You can try refreshing the page to see the loading animation displayed before
    the data is retrieved.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: Error management
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Finally, we could manage the errors that could occur for any resource request:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: 'We will store the errors for each resource in a new `remoteErrors` object,
    which needs to be initialized:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The key of the `remoteErrors` object will be the same as the resource, and the
    value will be the error or `null` if there is no error.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to modify the `fetchResource` method:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: Before the request, reset the error by setting it to `null`
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If there is an error in the catch block, put it into the `remoteErrors` object
    at the right key
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `fetchResource` method should now look as follows:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: We could now display specific error messages for each resource, but we will
    simply display a generic error message in this project. Let's add another computed
    property called `hasRemoteErrors`, which will return true if there is at least
    one error.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the JavaScript `Object.keys()` method, we can iterate on the keys of
    the `remoteErrors` object and check if some values are not `null` (which means
    that they are truthy):'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'We can now change the FAQ component template again by replacing the `error`
    property with the new one:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Like we did before, you can shut down the server to see the error message displayed.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: 'We have now finished the FAQ component, whose script should now look as follows:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: As you can see, it is very concise now!
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: Support tickets
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this last part, we will create an authenticated section of our app, where
    the user will be able to add and view support tickets. All the necessary requests
    are available on the server you already downloaded and if you are curious about
    how this has been done in the node with `passport.js`, you can take a look at
    the sources!
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: User authentication
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this first section, we will take care of the user system of our app. We will
    have both login and sign up components, to be able to create new users.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: Storing the user in a centralized state
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will store the user data inside a state object like we did in [Chapter 3](1f1ee662-c20d-4926-9b9a-4fcfaedf4b84.xhtml),
    *Project 2* - *Castle Duel Browser Game*, so we can access it in any component
    of the app:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new `state.js` file next to `main.js`, which exports the state object:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The `user` property will be null when no user is logged in, or else it will
    contain the user data.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, in the `main.js` file, import the state:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Then, use it as the data of the root instance so Vue makes it reactive:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Another plugin
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We could then import the state in component files when we need it, but it would
    be more convenient to be able to access it with a special getter called `$state`
    on the Vue prototype like we did for the `fetch` plugin. We will pass the state
    object to the plugin options, and the getter will return it.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `plugins` folder, create a `state.js` file that exports the new plugin:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Here we are using the JavaScript `Object.defineProperty()` method to set up
    a getter on the Vue prototype, so every component will inherit it!
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: One last thing--we need to install the state plugin!
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `main.js` file, import the new plugin:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Then install it with the state object as the options parameter:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'We can now use `$state` in our components to access the global state! Here
    is an example:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: This should output the state object with the `user` property.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: Login forms
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will first create new components to help us build forms
    faster, and then we will add the sign up and the login forms to the application
    with a `Login.vue` component. In later sections, we will create another form to
    submit new support tickets.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: Smart form
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This generic component will take care of the very general structure of our form
    components, and will automatically call an `operation` function, display a loading
    animation and the eventual error messages thrown by the operation. Most of the
    time, the operation will be a `POST` request made to the server.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: 'The template is essentially a form with a title, a default slot where the inputs
    will be rendered, an `actions` slot for the buttons, a loading animation, and
    a place for the error messages. This will be generic enough for the two forms
    we need in the application:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new `SmartForm.vue` component in the `components` folder:'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: On the `<form>` element, we set up an event listener on the `'submit'` event,
    which prevents the default behavior of the browser (reloading the page) with the
    `prevent` modifier.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, the `SmartForm` component will have three props:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: '`title`: This is displayed in the `<h2>` element.'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`operation`: The asynchronous function called when the form is submitted. It
    should return a promise.'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`valid`: A Boolean to prevent calling the operation if the form is not valid.'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Add them to the `script` part of the component:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'As you can see, we are now using a different way of declaring the props--by
    using an object, we can specify more details of the prop. For example, with `required:
    true`, Vue will warn us if we forget a prop. We can also put a type that Vue will
    check too. This syntax is recommended since it helps both understanding the props
    of the component and avoiding errors.'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need two data properties:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: '`busy`: A Boolean to toggle the display of the loading animation'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`error`: This is the error message or `null` if there aren''t any'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Add them with the `data` hook:'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Finally, we need to write the `submit` method called when the form is submitted:'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: If the form isn't valid or is still busy, we don't call the operation. Or else
    we reset the `error` property and then call the `operation` prop, with the `await`
    keyword since it should be an asynchronous function that returns a promise. If
    we catch an error, we set the message to the `error` property so it is displayed.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that our generic form is ready, we can register it in the `global-components.js`
    file:'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Form input component
  id: totrans-346
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In our forms, we will have many inputs with the same markup and functionalities.
    This is the perfect occasion to make another generic and reusable component. It
    will have a small template with mainly an `<input>` element and will be able to
    show the user that it is invalid with a red border:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by creating a new `FormInput.vue` component with the following props:'
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`name` is the HTML name of the input, needed for the browser autocompletion
    to work.'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`type` will be `''text''` by default, but we will need to set `''password''`
    eventually.'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`value` is the current value of the input.'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`placeholder` is the label displayed inside the input.'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`invalid` is a Boolean to toggle the invalid display (the red border). It will
    default to `false`.'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The script should look like this with the prop object notation:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'For the invalid display, we will add a computed property to dynamically change
    the CSS classes of the input:'
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Now we can write our template. It will have a `<div>` element containing the
    `<input>`:'
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: We use the `prop` modifier on the `v-bind:value` directive to tell Vue to set
    the DOM node `value` property directly instead of setting the HTML attribute.
    This is a good practise when dealing with properties such as `value` for input
    HTML elements.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin testing it, we can register the component in the `global-components.js`
    file:'
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Create a new `Login.vue` component using the `FormInput` component:'
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Don''t forget the corresponding route in the `router.js` file:'
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'You can test the component by opening the app with the `/login` path in the
    URL:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/5730642f-6612-40ca-8845-041eaa6f0b34.png)'
  id: totrans-368
  prefs: []
  type: TYPE_IMG
- en: For now, the `FormInput` component is read-only because we don't do any thing
    when the user types something into the field.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add a method to take care of that:'
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Then we can listen to the `input` event on the text field:'
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Now if you type into the text field, the content should be printed to the console.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `update` method, we are going to emit an event to send the new value
    to the parent component. By default, the `v-model` directive listens to the `input`
    event, with the new value being the first parameter:'
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: To understand how things work, we are not going to use `v-model` yet.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now listen to this `input` event and update the `username` prop:'
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'The value of the `username` prop should be updated on the `Login` component:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a4105d26-4d80-40f0-9e45-8e9b20793a4e.png)'
  id: totrans-381
  prefs: []
  type: TYPE_IMG
- en: 'Using the `v-model` directive, we can simplify this code:'
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: It will use the `value` prop and listen to the `input` event for us!
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: Customizing v-model
  id: totrans-385
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By default, `v-model` uses the `value` prop and the `input` event as we just
    saw, but we can customize that:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `FormInput` component, add the `model` option:'
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'We then need to change the name of our `value` prop to `text`:'
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'And in the template:'
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Plus the `input` event should be renamed to `update`:'
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: The component should still work in the `Login` component, since we told `v-model`
    to use the `text` prop and `update` event!
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: Our input component is now ready! For this project, we have kept this component
    simple, but you can add more features into it if you want to, such as icons, error
    messages, floating label, and so on.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: Login component
  id: totrans-397
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can now continue building the `Login` component, which will take care of
    signing in and signing up the user.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several data properties we need for the state of this component:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: '`mode`: This can either be `''login''` or `''signup''`. We will change the
    layout a bit depending on this.'
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`username`: Used in both modes.'
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`password`: Also used in both modes.'
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`password2`: Used to verify the password when signing up.'
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`email`: Used in sign up mode.'
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Our `data` hook should now look like this:'
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'We can then add a `title` computed property to change the form title depending
    on the mode:'
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: We will also add some basic input validation. First, we would like to highlight
    the retype `password` field when it's not equal to the first password.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add another computed property for that:'
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: Then, we will also check that no field is empty since they are all mandatory.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: 'This time, we will break it up into two computed properties, since we don''t
    want to check the sign up specific fields when in `login` mode:'
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Next, add the methods we will use to either `login` or `sign up` the user (we
    will implement them later in the *Sign up operation* and *Login operation* sections):'
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'We can now move onto the template. Start by adding a `SmartForm` component:'
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Then we can add the `input` fields:'
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: Don't forget the name attributes--it will allow the browser to auto-complete
    the fields.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: 'Below the `input` fields, we need two different buttons for each mode. For
    the login mode, we need a `sign up` and `login` button. For the `sign up` mode,
    we need a Back button and a Create account button:'
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE106]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Now you can test the component and switch between the `login` and `sign up`
    modes:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/472e2d84-4be7-41cf-b5dd-f4be4516d939.png)'
  id: totrans-425
  prefs: []
  type: TYPE_IMG
- en: Style children of scoped elements
  id: totrans-426
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The form is currently taking all the space available. It would be better to
    shrink it a bit.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: For this section to work, you need the latest `vue-loader` package installed
    in your project.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add some style to put a maximum width to the form:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'The `>>>` combinator allows us to target elements inside the components used
    in the template, while still scoping the rest of the `CSS` selector. In our example,
    the generated `CSS` will look as follows:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'If we didn''t use this combinator, we would have this `CSS`:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: This wouldn't work since the `.content` element is inside the `SmartForm` component
    we are using in the template.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: If you are using SASS, you need to use the `/deep/` selector instead of the
    `>>>` combinator.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: 'The form should look like this now:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/1e6f948a-9608-463b-a8ba-db80dc50186a.png)'
  id: totrans-438
  prefs: []
  type: TYPE_IMG
- en: Improving our fetch plugin
  id: totrans-439
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Currently, our `$fetch` method can only make `GET` requests to the server.
    It was enough for loading the FAQ, but now we need to add more features to it:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `plugins/fetch.js` file, edit the signature of the function to accept
    a new `options` parameter:'
  id: totrans-441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE110]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: The `options` argument is an optional object for the browser's `fetch` method
    that will allow us to change different parameters, such as the HTTP method used,
    the request body, and more.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: 'At the beginning of the `$fetch` function, we would like to put some default
    values for this `options` parameter:'
  id: totrans-444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE111]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: The default options tell the server we will always send JSON in the request
    body, and tell the browser that we will also include the authorization token necessary
    to authenticate the user if they are logged in. Then, the provided `options` argument,
    if any, add its value to the `finalOptions` object (for example, the `method`
    property or the `body` property).
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we add the new options to the `fetch` browser method:'
  id: totrans-447
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE112]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Also, the server will always send errors as text, so we can catch them and
    display them to the user:'
  id: totrans-449
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE113]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: We are now ready to make our first `POST` request to the server in order to
    create for the user a new account and then log him in!
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: Sign up operation
  id: totrans-452
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will start with the account creation, since we don''t have any user yet.
    The path to call on the server is `/signup`, and it expects a `POST` request with
    a JSON object in the request body containing the username, password, and email
    of the new account:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s implement this using the `$fetch` method we just improved:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: We don't manage errors here, as it's the job of the `SmartForm` component we
    built earlier.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: That's it! You can now create a new account with a simple `password` you will
    have to remember for later. If the account creation succeeds, the form goes back
    to `login` mode.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: One thing we don't do here, but that could be improved, is to let the user know
    their account has been created and that they can now log in. You could add a message
    below the form, or even make a floating notification appear!
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: Login operation
  id: totrans-459
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The login method will be almost identical to the sign up. The differences are:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: We only send the `username` and `password` in the request body, to the `/login`
    path
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The response is the user object we need to set into the global state so every
    component can know if there is a connected user (using the plugin we made exposing
    the `$state` property)
  id: totrans-462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then we redirect to the home page
  id: totrans-463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It should look like this now:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: You can now try to log in with the `username` and the `password` you used to
    create the account earlier. If the login is successful, you should be redirected
    to the home page thanks to the `router.push()` method.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: The `user` object returned by this request contains the `username` field that
    will be displayed in the navigation menu.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: User menu
  id: totrans-468
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now it is time to add the user-related features to the navigation menu we made
    at the beginning in the `NavMenu.vue` file:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: 'We want them to appear to the far right side of the menu, so we will add this
    element just after the router links we already wrote:'
  id: totrans-470
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE116]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: This will simply grow to take all the available space in the menu using the
    CSS flexbox properties, so that anything we put after will be pushed to the right.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: Thanks to the plugin we made earlier in the *Storing the user in a centralized
    State* section, we have access to the global state with the `$state` property.
    It contains the `user` object, which allows us to know if the user is logged in,
    and displays their `username` and a `logout` link.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the user menu in the `NavMenu.vue` component:'
  id: totrans-474
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE117]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'If the user isn''t connected, we just display a `login` link (add this below
    the `template` we just added):'
  id: totrans-476
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE118]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: The `logout` link needs a new `logout` method that we will create now.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: Logout method
  id: totrans-479
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The logout method consists of a simple call to the `/logout` path on the server,
    which should return an object with the `status` property equal to `''ok''`:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: If the user successfully logged out, we reset the `user` value in the global
    state.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
- en: Private routes with navigation guards
  id: totrans-483
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have an authentication system ready, we can have different types
    of routes:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: Public routes are always accessible
  id: totrans-485
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Private routes are restricted to logged users
  id: totrans-486
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Guest routes are accessible only to users that are not connected yet
  id: totrans-487
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We are going to create one of the routes components ahead of time to test our
    code:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create the `TicketsLayout.vue` component that we will use later to display
    either of the user support tickets:'
  id: totrans-489
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE120]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'Then, add the corresponding route in the `router.js` file:'
  id: totrans-491
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE121]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'Finally, add the link to this new page in the navigation menu:'
  id: totrans-493
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE122]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: Route meta properties
  id: totrans-495
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can add the page access type information in the `meta` object on the impacted
    routes in the `router.js` file.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
- en: 'The route we just created should be private and only accessible to connected
    users:'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `private` attribute to the `meta` object on the route:'
  id: totrans-498
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE123]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'Now, if you go to the tickets page and inspect any component, you should see
    the `$route` object exposed by the `vue-router` plugin. It contains the `private`
    property in the `meta` object:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/febb8fe5-3e14-4956-a451-eb4cbd4a167f.png)You can put any additional
    information in the `meta` object of a route to extend the router capabilities.'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
- en: Router navigation guards
  id: totrans-502
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we know the tickets route is private, we would like to execute some
    logic before the route is resolved to check if the user is connected. That is
    where navigation guards come in handy--there are function hooks called when something
    happens regarding routes and they can change the behavior of the router.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
- en: 'The navigation guard we need is `beforeEach` and it is run each time before
    a route is resolved. It allows us to replace the target route with another one
    if necessary. It accepts a callback with three arguments:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
- en: '`to` is the route currently being targeted'
  id: totrans-505
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`from` is the previous route'
  id: totrans-506
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`next` is a function we have to call at some point for the resolution to proceed'
  id: totrans-507
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you forget to call `next` in your navigation guard, your app will be stuck.
    This is because you can do asynchronous operations before calling it, so the router
    doesn't make any assumption on its own.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
- en: 'Before exporting the router instance, add the `beforeEach` navigation guard:'
  id: totrans-509
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE124]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'Now we need to determine if the route we target is a private route:'
  id: totrans-511
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE125]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'To check if the user is connected, we need the global state--you can import
    it at the start of the file:'
  id: totrans-513
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE126]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'Change the condition to also check for the user state:'
  id: totrans-515
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE127]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: The next function can be called with a route argument, to redirect the navigation
    to another route.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
- en: 'So here, we can redirect to the login route just like we would do with the
    `router.push()` method:'
  id: totrans-518
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE128]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: Don't forget to return, or you will call `next` a second time at the end of
    the function!
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
- en: We can now try to log out and click on the support tickets link. You should
    be immediately redirected to the login page instead.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
- en: When redirecting with `next`, no additional entry is added to the browser history
    for each redirection. Only the final route has a history entry.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see in the browser console, the navigation guard was called each
    time we try to resolve to a route:'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a7f7d374-8b84-4412-80d1-1b21b70356ef.png)'
  id: totrans-524
  prefs: []
  type: TYPE_IMG
- en: That explains why the function is called `next`--the resolving process will
    continue until we don't redirect to another route.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
- en: This means the navigation guard can be called multiple times, but this also
    means you should be careful of not creating an infinite "loop" of resolutions!
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
- en: Redirecting to the wanted route
  id: totrans-527
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After the user is logged in, the app should redirect him to the page they initially
    wanted to browse:'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
- en: 'Pass the current wanted URL as a parameter to the login route:'
  id: totrans-529
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE129]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'Now if you click on the support tickets link and get redirected to the login
    page, you should see the `wantedRoute` parameter in the `$route` object on any
    component:'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/d3bca6d2-077c-46fd-a9b6-f5c59b653462.png)'
  id: totrans-532
  prefs: []
  type: TYPE_IMG
- en: 'In the `Login` component, we can change the redirection in the `login` method
    and use this parameter:'
  id: totrans-533
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE130]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: The `router.replace()` method is very similar to the `router.push()` method,
    the difference being it replaces the current entry in the browser history with
    the new route instead of adding a new entry.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
- en: Now if you log in, you should be redirected to the support ticket page instead
    of the home page.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
- en: Initializing user authentication
  id: totrans-537
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When the page load and the application start, we need to check if the user
    is already connected. For this reason, the server has a `/user` path that returns
    the user object if they are logged in. We will put it in the global state just
    like if we logged in. Then, we will start the Vue app:'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `main.js` file, import `$fetch` from our plugin:'
  id: totrans-539
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE131]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'Then we need to create a new asynchronous function called `main`, inside of
    which we will request the user data and then start the app:'
  id: totrans-541
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE132]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: Now if you log in and then you refresh the page, you should still be connected!
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
- en: Guest routes
  id: totrans-544
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is another case we don't manage yet--we don't want an already connected
    user to access the login route!
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s why we will mark it as a guest route:'
  id: totrans-546
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE133]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'Inside the `beforeEach` navigation guard, we will check if the route is guest-only
    and if the user is already connected, then redirect to the home page:'
  id: totrans-548
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE134]'
  id: totrans-549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: If you are logged in, you can try going to the login URL--you should be immediately
    redirected to the home page! You can only access this page if you are not logged
    in.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
- en: Displaying and adding tickets
  id: totrans-551
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will add the ticket support content to the app. First we
    will display them and then build a form to let the user create new ones. We will
    have two components for this, nested in the `TicketsLayout` component we made
    earlier.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
- en: Don't worry! When you created your account, an example support ticket was automatically
    created for your user.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
- en: Tickets list
  id: totrans-554
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The tickets can be requested at `/tickets` on the server:'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
- en: Create a new `Tickets.vue` component that will be pretty much like the FAQ component.
  id: totrans-556
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use the `RemoteData` mixin to fetch the tickets:'
  id: totrans-557
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE135]'
  id: totrans-558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'Then add the template with a loading animation, an empty message, and the list
    of the tickets:'
  id: totrans-559
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE136]'
  id: totrans-560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: We need a filter to display the ticket date!
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
- en: 'Kill the client compilation and install `momentjs` with the following command:'
  id: totrans-562
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE137]'
  id: totrans-563
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'Create a new `filters.js` file next to the `main.js` file, with a `date` filter:'
  id: totrans-564
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE138]'
  id: totrans-565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'Then in `main.js`, import the `filters` and register them with a handy loop:'
  id: totrans-566
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE139]'
  id: totrans-567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'We can now display the dates in a more human-friendly way in the `Tickets`
    component:'
  id: totrans-568
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE140]'
  id: totrans-569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'You can then add this new component to the `TicketsLayout` component and get
    the list of tickets:'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/32ded18f-6a20-4a04-a4d2-8e5af3f44dd2.png)'
  id: totrans-571
  prefs: []
  type: TYPE_IMG
- en: Don't forget to import `Tickets` and set it in the `components` option!
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
- en: Session expiration
  id: totrans-573
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After some time, the user session might become no longer valid. This could
    happen because of timed expiration (for this server this is set to three hours),
    or simply because the server was restarted. Let''s try to reproduce this kind
    of situation--we are going to restart the server and try to load the tickets again:'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
- en: Make sure you are logged into the application.
  id: totrans-575
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type `rs` and then press `Return` in the Terminal where the server is running
    to restart it.
  id: totrans-576
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the Home button in the app.
  id: totrans-577
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the support ticket button to go back to the tickets list page.
  id: totrans-578
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You should have a stuck loading animation and an error message in the console:'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a356239a-cb14-4919-82be-6145adbf8c1d.png)'
  id: totrans-580
  prefs: []
  type: TYPE_IMG
- en: The server has returned an unauthorized error--that's because we are no longer
    logged in!
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
- en: To fix this, we need to log the user out and redirect them to the login page
    if we are in a private route.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
- en: The best place to put our code is the `$fetch` method used in all our components,
    located in the `plugins/fetch.js` file. The server will always return a 403 error
    when trying to access a path restricted to connected users.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
- en: 'Before modifying the method, we need to import both the state and the router:'
  id: totrans-584
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE141]'
  id: totrans-585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'Let''s add a new case in the response processing:'
  id: totrans-586
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE142]'
  id: totrans-587
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: We use the `replace` method instead of `push` because we don't want to create
    a new navigation in the browser history. Imagine if the user clicks the back button,
    it will redirect again to the login page and the user will not be able to go back
    to the page before the private one.
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
- en: You can now try again--when you restart the server and click on the support
    tickets link, you should be redirected to the login page and the navigation menu
    should not display your username anymore.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
- en: Nested routes
  id: totrans-590
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since we also want to switch to a form in this page, it would be a good idea
    to structure our components with nested routes--each route can have child routes
    if they have at least a router view! So under the `/tickets` router, we will have
    two children for now:'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
- en: '`''''` will be the tickets list (full path will be `/tickets/`). It acts like
    the default route under `/tickets`.'
  id: totrans-592
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''/new''` will be the form to send new tickets (full path will be `/tickets/new/`).'
  id: totrans-593
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Create a new `NewTicket.vue` component with a temporary template:'
  id: totrans-594
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE143]'
  id: totrans-595
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'In the `routes.js` file, add the two new routes under the `/tickets` route
    inside the children attribute:'
  id: totrans-596
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE144]'
  id: totrans-597
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: Since the first child route is an empty string, it will be the default when
    the parent route is resolved. This means you should move the name of the route
    (`'tickets'`) from the parent to it.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we can change the `TicketsLayout` component to use a router view along
    with a few buttons to switch between the child routes:'
  id: totrans-599
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE145]'
  id: totrans-600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: You can use the `tag` prop on router links to change the HTML tag used to render
    it.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we hide each button depending on the current route name--we
    don't want to display the Show tickets button when we are already on the tickets
    page, and we don't want the New ticket button when we are already on the corresponding
    form!
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
- en: 'You can now switch between the two child routes and see the URL change accordingly:'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/cf2479f9-c46e-42fc-a2b5-19b470ea7f57.png)'
  id: totrans-604
  prefs: []
  type: TYPE_IMG
- en: Fixing our navigation guard
  id: totrans-605
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you log out and then go to the tickets page, you should be surprised to be
    able to access the page! This is because there is a flaw in the implementation
    of our `beforeEach` navigation guard--we poorly designed it without taking into
    account the fact we could have nested routes! The reason for this issue is that
    the `to` parameter is only the target route, which is the first child route of
    the `/tickets` route--it doesn't have the `private` meta attribute!
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
- en: So instead of relying solely on the target route, we should also check all the
    matched nested route objects. Thankfully, every route object gives us access to
    the list of these route objects with the `matched` property. We can then use the
    `some` array method to verify if at least one route object has the desired meta
    attribute.
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
- en: 'We can change the conditions code to this in the `beforeEach` navigation guard
    in the `router.js` file:'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  id: totrans-609
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: Now our code works regardless of the number of nested routes!
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
- en: It is strongly recommended to use this approach with the `matched` property
    every time to avoid errors.
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
- en: Sending a form
  id: totrans-612
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we are going to complete the `NewTicket` component that will
    allow the user to send a new support ticket. We need two fields to create a new
    ticket--`title` and `description`:'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
- en: 'In the template of the `NewTicket.vue` component, we can already add a `SmartForm`
    component with the title `InputForm` component:'
  id: totrans-614
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE147]'
  id: totrans-615
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'We can also add the two data properties, the `operation` method and some input
    validation with the `valid` computed property:'
  id: totrans-616
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE148]'
  id: totrans-617
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: Form textarea
  id: totrans-618
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For the `description` field, we need a `<textarea>` element so the user can
    write a multiline text. Unfortunately, our `FormInput` component doesn''t support
    this yet, so we need to modify it a bit. We will use the `type` prop of the component
    with the value `''textarea''` to change the `<input>` element to a `<textarea>`
    element:'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a new computed property to determine which kind of HTML element
    we are going to render:'
  id: totrans-620
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE149]'
  id: totrans-621
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: So when the value `'textarea'` is passed, we need to render a `<textarea>`.
    All the other types will make the component render an `<input>` element.
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
- en: We can now use the special `<component>` component, which can render either
    elements with the `is` prop, instead of the static `<input>` element.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
- en: 'The line in the template should now look like this:'
  id: totrans-624
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE150]'
  id: totrans-625
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'We can now add the `description` textarea to the `NewTicket` form just after
    the `title` input:'
  id: totrans-626
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE151]'
  id: totrans-627
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: Binding attributes
  id: totrans-628
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Among other elements, `<textarea>` has some handy attributes we would like to
    use, such as the `rows` attribute. We could create a prop for each of them, but
    this could become tedious very quickly. Instead, we are going to use the handy
    `$attrs` special property of the Vue component, which gets all the non-prop attributes
    set on the component as an object with the keys being the names of the attributes.
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that if you have let''s say, one `text` prop on your component and
    that you write this in another component:'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  id: totrans-631
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: Vue will treat `required` as an attribute, since it is not in the list of props
    exposed by the `FormInput` component. Then you can access it with `$attrs.required`!
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
- en: The `v-bind` directive can get an object with the keys being the names of the
    props and attributes to set. This will be very useful!
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
- en: 'We can write this on `<component>` in the `FormInput.vue` component:'
  id: totrans-634
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE153]'
  id: totrans-635
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'Now you can add the `rows` attribute on the `description` input in the `NewTicket.vue`
    component:'
  id: totrans-636
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE154]'
  id: totrans-637
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: 'You should see in the rendered HTML that the attribute has been set on the
    `<textarea>` element inside the `FormInput` component:'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  id: totrans-639
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: User actions
  id: totrans-640
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will now implement the few actions the users will be able to do in the form:'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `SmarForm` component, add these two buttons after the inputs:'
  id: totrans-642
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE156]'
  id: totrans-643
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'Then implement the `operation` method, which will be similar to what we have
    done in the `Login` component. The server path we need to send the `POST` request
    to is `/tickets/new`:'
  id: totrans-644
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE157]'
  id: totrans-645
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: You can now create new tickets!
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
- en: Backup user input
  id: totrans-647
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To improve the user experience, we should automatically back up what the user
    has typed into the form in case something goes wrong--for example, the browser
    could crash or the user could accidentally refresh the page.
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to write a mixin that will automatically save some data properties
    into the browser local storage, and restore them when the component is created:'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
- en: Create a new `PersistantData.js` file in the `mixins` folder.
  id: totrans-650
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Like the other mixin we did, it will have some parameters, so we need to export
    it as a function:'
  id: totrans-651
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE158]'
  id: totrans-652
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: The `id` argument is the unique identifier to store the data for this specific
    component.
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
- en: First we are going to watch all the fields passed in the mixin.
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
- en: 'For that, we will dynamically create the `watch` object, with each key being
    the field and the value being the handler function that will save the value into
    the local storage:'
  id: totrans-655
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE159]'
  id: totrans-656
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: 'Go back to the `NewTicket` component and add the mixin:'
  id: totrans-657
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE160]'
  id: totrans-658
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: 'So, the mixin added watchers to the component with the `reduce` producing the
    equivalent of this:'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  id: totrans-660
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: We are saving the property values as JSON since the local storage only supports
    strings.
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
- en: 'You can try typing into the fields, and then look at the browser dev tools
    to see that two new local storage items have been saved:'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/f2105df0-659f-4c82-8e3f-71c21eb1e58c.png)'
  id: totrans-663
  prefs: []
  type: TYPE_IMG
- en: 'In the mixin, we can also save the fields when the component is destroyed:'
  id: totrans-664
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE162]'
  id: totrans-665
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: 'Finally, we need to restore the values when the component is created:'
  id: totrans-666
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE163]'
  id: totrans-667
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: Now if you type something into the form, and then refresh the page, what you
    typed should be still in the form!
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
- en: With the session expiration management we added to `$fetch`, you will be redirected
    to the login page if you try to send your new ticket while you are no longer connected.
    Then, once you're logged in again, you should be right back to the form with what
    you typed still there!
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
- en: Advanced routing features
  id: totrans-670
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is the last section of this chapter, in which we will explore routing a
    bit more!
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic routes with parameters
  id: totrans-672
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last component we will add in the application is `Ticket`, which display
    a detailed view of one ticket by its ID. It will show the title and description
    inputted by the user, plus the date and the status.
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new `Ticket.vue` file and add this template with the usual loading
    animation and `not found` notice:'
  id: totrans-674
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE164]'
  id: totrans-675
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: 'Then add an `id` prop to the component:'
  id: totrans-676
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE165]'
  id: totrans-677
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: Dynamic remote data
  id: totrans-678
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `id` prop will be the ID of the ticket for which we will fetch the details.
    The server provides a dynamic route in the form of `/ticket/<id>`, with `<id>`
    being the ID of the ticket.
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
- en: 'It would be nice to be able to use our `RemoteData` mixin, but it currently
    lacks support for dynamic paths! What we could do is to pass a function instead
    of a plain string as the values of the mixin''s parameter:'
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `RemoteData` mixin, we just need to modify the way we process the parameter
    in the `created` hook. If the value is a function, we will use the `$watch` method
    to watch its value instead of directly calling the `fetchResource` method:'
  id: totrans-681
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE166]'
  id: totrans-682
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: 'Don''t forget the `immediate: true` option for the watcher since we want to
    call `fetchResource` a first time before watching the value.'
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `Ticket` component, we can now use this mixin to load the data of the
    ticket depending on the `id` prop:'
  id: totrans-684
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE167]'
  id: totrans-685
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: Let's try this in the `Tickets` component.
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the new `Ticket` component to it with a new `id` data property:'
  id: totrans-687
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE168]'
  id: totrans-688
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: 'Then in the template, add a `Ticket` component:'
  id: totrans-689
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE169]'
  id: totrans-690
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: 'In the ticket list, change the title to a link that sets the `id` data property
    on `click`:'
  id: totrans-691
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE170]'
  id: totrans-692
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: 'If you click on the tickets in the application, you should have the details
    in the following list:'
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/291c8703-598a-43a2-b94e-af8a7c2de73e.png)'
  id: totrans-694
  prefs: []
  type: TYPE_IMG
- en: The dynamic route
  id: totrans-695
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since we are going to put the ticket details in another route, you can undo
    what we just did in the `Tickets` component.
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
- en: The route will be a child route of the tickets route, and will be of the form
    `/tickets/<id>` where `<id>` is the ID of the ticket being displayed. This is
    possible thanks to the dynamic route matching feature of vue-router!
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
- en: 'You can add dynamic segments to your route path with the semicolon. Then, each
    segment will be exposed in the route `params` object. Here are some examples of
    routes with parameters:'
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
- en: '| Pattern | Example path | `$route.params` value |'
  id: totrans-699
  prefs: []
  type: TYPE_TB
- en: '| `/tickets/:id` | `/tickets/abc` | `{ id: ''abc'' }` |'
  id: totrans-700
  prefs: []
  type: TYPE_TB
- en: '| `/tickets/:id/comments/:comId` | `/tickets/abc/comments/42` | `{ id: ''abc'',
    comId: ''42'' }` |'
  id: totrans-701
  prefs: []
  type: TYPE_TB
- en: 'Let''s add the new route in the `router.js` file as a child route of `/tickets`:'
  id: totrans-702
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE171]'
  id: totrans-703
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: 'In the `Tickets` component list, we need to change the title element to a link
    pointing to the new route:'
  id: totrans-704
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE172]'
  id: totrans-705
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: Now if you click on a ticket, the `$route.params` object will have the `id`
    property set to the of the ticket.
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
- en: 'We could change our `Ticket` component to use this with a computed property
    instead of a prop:'
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  id: totrans-708
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: But this is a bad idea--we are coupling the component to the route! This means
    we won't be able to reuse it in another way easily. The best practice is to use
    props to pass info to components, so let's continue to do that!
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
- en: 'So we are going to keep the ID prop of the `Ticket` component and tell `vue-router`
    to pass all the route parameters to it as prop with the `props` attribute:'
  id: totrans-710
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE174]'
  id: totrans-711
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: 'This is equivalent to this more flexible syntax based on a function that gets
    the route object as the argument:'
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  id: totrans-713
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: 'Another syntax based on an object exists too (useful when the props are static):'
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  id: totrans-715
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: We won't use this third syntax since our `id` prop should be equal to the dynamic
    parameter of the route.
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
- en: If you need to combine static and dynamic props, use the function syntax! This
    is also useful if the route parameters and the component props names don't match.
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the `id` parameter is passed as a prop to the component and you should
    see the ticket details page when clicking on a ticket in the list:'
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/bbad02ee-1190-4f86-9416-dafa76a361f7.png)'
  id: totrans-719
  prefs: []
  type: TYPE_IMG
- en: Not found page
  id: totrans-720
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Currently, if you enter an invalid URL into the app, you are greeted with a
    boring blank page. This is the default behavior of `vue-router`, but it can thankfully
    be changed! We will now customize the "not found" page of our app!
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a better "not found" page with a new `NotFound.vue` component:'
  id: totrans-722
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE177]'
  id: totrans-723
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: 'Now in the `router.js` file, we just need to add a new route matching the `''*''`
    path:'
  id: totrans-724
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE178]'
  id: totrans-725
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: This means that for any route, we display the `NotFound` component. The very
    important fact is that we put this route at the end of the `routes` array--this
    ensures that all the legit routes will be matched before matching this last particular,
    catch-all route.
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
- en: 'You can now try a URL that doesn''t exist, like `/foo`, to have the page displayed:'
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/343904f2-8f5a-4a56-9b8b-c20d75db9122.png)'
  id: totrans-728
  prefs: []
  type: TYPE_IMG
- en: Transitions
  id: totrans-729
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Animating the route changes is very easy--this is done in exactly the same
    way we did before:'
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `AppLayout` component, wrap the router view with this transition:'
  id: totrans-731
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE179]'
  id: totrans-732
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: The `router-view` special component will be replaced by the different component
    of the routes we have, and thus trigger the transition.
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
- en: Scrolling behavior
  id: totrans-734
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The history mode of the router allows us to manage the page scrolling when a
    route changes. We can reset the position to the top every time, or restore the
    position the user was in before changing the route (this is very useful when they
    go back in the browser).
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
- en: 'When creating the router instance, we can pass a `scrollBehavior` function
    that will get three arguments:'
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
- en: '`to` is the target route object.'
  id: totrans-737
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`from` is the previous route object.'
  id: totrans-738
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`savedPosition` is the scroll position that has been automatically saved for
    each entry in the browser history. Each new entry will not have this until the
    route changes.'
  id: totrans-739
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `scrollBehavior` function expects an object that can take two different
    forms. The first is the coordinate of the scroll we want to apply; for example:'
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  id: totrans-741
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: 'The second one is a selector of the HTML element we want the page to scroll
    to, with an optional offset:'
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  id: totrans-743
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: 'So to scroll to the top of the page when the route changes, we need to write
    this:'
  id: totrans-744
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE182]'
  id: totrans-745
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: 'To scroll to the `<h1>` element each time, we could do this:'
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  id: totrans-747
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: 'Instead, we will check if the route has a hash to mimic the browser behavior:'
  id: totrans-748
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE184]'
  id: totrans-749
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: 'Finally, we can restore the scroll position if there is any:'
  id: totrans-750
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE185]'
  id: totrans-751
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: It's that simple! The app now should behave like an old multi-page website.
    You can then customize the way the scroll behaves with offset or route meta properties.
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-753
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we created a fairly big application with the help of Vue and
    the official `vue-router` library. We created a few routes and connected them
    with links that turned into a real navigation menu. Then, we created a generic
    and reusable component to build the application forms, which helped us make the
    login and signup forms. We then integrated the user authentication system with
    the router, so our application could react in smart ways to page refreshes or
    session expirations. Finally, we went deeper into the features and capabilities
    of `vue-router` to enhance our application and user experience even further.
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
- en: 'We are done with the app, but feel free to improve it on your own! Here are
    some ideas you could implement:'
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
- en: Add comments to the tickets. Display the list of comments with the name of the
    corresponding user.
  id: totrans-756
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add close this ticket button, preventing users from adding new comments.
  id: totrans-757
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Display a special icon next to a closed ticket in the tickets list!
  id: totrans-758
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add roles to users. For example, normal users could open tickets, but only admin
    users could close them.
  id: totrans-759
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next chapter, we will create a geolocated blogging application and we
    will learn how to scale our apps more with a centralized state solution and how
    to integrate third-party libraries to extend the features of Vue.
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
