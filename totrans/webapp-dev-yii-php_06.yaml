- en: Chapter 6. User Management and Authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have made a lot of progress in a very short amount of time. The basic foundation
    of our TrackStar application has been laid. We now have the ability to manage
    projects and issues within projects, which is the primary purpose of this application.
    Of course, there is still a lot left to do.
  prefs: []
  type: TYPE_NORMAL
- en: Back in [Chapter 3](ch03.html "Chapter 3. The TrackStar Application"), *The
    TrackStar Application*, when we were introducing this application, we described
    it as a user-based application that provides the ability to create user accounts
    and grants access to the application features once a user has been authenticated
    and authorized. In order for this application to be useful to more than one person
    we need to add the ability to manage users within projects. This is going to be
    the focus of the next two chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Feature planning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we used the `yiic` command-line tool to initially create our TrackStar
    application, we noticed that basic login functionality was automatically created
    for us. The login page allows for two username/password credential combinations,
    `demo/demo` and `admin/admin`. You may recall that we had to log in to the application
    in order to perform some of our CRUD operations on our project and issue entities
    in the previous two chapters.
  prefs: []
  type: TYPE_NORMAL
- en: This basic authentication skeleton code provides a great start, but we need
    to make a few changes in order to support any number of users. We also need to
    add user CRUD functionality to the application to allow us to manage these multiple
    users. This chapter is going to focus on extending the authentication model to
    use the `tbl_user` database table and add the needed functionality to allow for
    basic user data management.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to achieve the above outlined goals, we will need to work on the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the controller classes that will house the functionality to allow us
    to:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create new users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retrieve a list of existing users from the database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update/edit existing users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Delete existing users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Create the view files and presentation tier logic that will:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Display the form to allow for new user creation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Display a listing of all the existing users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Display the form to allow the editing of an existing user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a delete button so we can delete users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make adjustments to the create new user form so that it can be used by external
    users as a self-registration process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Alter the authentication process to use the database to validate the login credentials
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User CRUD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we are building a user-based web application, we must have a way to add and
    manage users. We added a `tbl_user` table to our database in [Chapter 5](ch05.html
    "Chapter 5. Managing Issues"), *Managing Issues*. You may recall that we left
    it as an exercise to the reader to create the associated AR model class. If you
    are following along and did not create the necessary user model class, you will
    need to do so now.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a brief reminder on using the Gii code creation tool to create
    the model class:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to the Gii tool via `http://localhost/trackstar/index.php?r=gii` and
    select the **Model Generator** link.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Leave the table prefix as `tbl_`. Fill in the **Table Name** field as `tbl_user`,
    which will autopopulate the **Model Class** name field as **User**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the form is filled out, click on the **Preview** button to get a link to
    a pop up that will show you all of the code about to be generated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, click on the **Generate** button to actually create the new `User.php`
    model class file in the `/protected/models/ directory`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With the `User` AR class in place, creating the CRUD scaffolding is a snap.
    We have done this before, using the Gii tool. As a reminder, the following are
    the necessary steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to the tool via `http://localhost/trackstar/index.php?r=gii`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Crud Generator** link from the list of available generators.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type in `User` for the **Model Class** name field. The corresponding **Controller
    ID** will autopopulate with **User**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will then be presented with options to preview each file prior to generating.
    Click on the **Generate** button, which will generate all of the associated CRUD
    files in their proper locations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With this in place, we can view our user listing page at `http://localhost/trackstar/index.php?r=user/index`.
    In the previous chapter, we manually created a couple of users in our system so
    that we could properly handle the relationships between projects, issues, and
    users. This is why we see a couple of users listed on this page. The following
    screenshot shows how this page is displayed for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '![User CRUD](graphics/8727_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We can also view the new **Create User** form by visiting `http://localhost/trackstar/index.php?r=user/create`.
    If you are not currently logged in, you will be first routed to the login page
    before being able to view the form. So you might have to log in using `demo/demo`
    or `admin/admin` to view this form.
  prefs: []
  type: TYPE_NORMAL
- en: Having created and used our CRUD operation functionality first on our project
    entity, and then again with issues, we are very familiar at this point with how
    these features are initially implemented by the Gii code generation tool. The
    generated code for creating and updating is a great start, but needs some adjusting
    to meet the specific application requirements. The form we just generated for
    creating a new user is no exception. It has an input form field for every single
    column that has been defined in the `tbl_user` table. We don't want to expose
    all of these fields for user input. The columns for last login time, creation
    time and user, and update time and user should all be set programmatically after
    the form is submitted.
  prefs: []
  type: TYPE_NORMAL
- en: Updating our common audit history columns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Back in the previous chapters, when we introduced our **Project** and **Issue**
    CRUD functionality, we also noticed that our forms had more input fields than
    they should. Since we have defined all of our database tables to have the same
    creation and update time and user columns, every one of our autocreated input
    forms has these fields exposed. We completely ignored these fields when dealing
    with the project creation form back in [Chapter 4](ch04.html "Chapter 4. Project
    CRUD"), *Project CRUD*. Then, with the new issue creation form in [Chapter 5](ch05.html
    "Chapter 5. Managing Issues"), *Managing Issues*, we took the step to remove the
    fields from displaying in the form, but we never added in the logic to properly
    set these values when a new row is added.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a minute to add in this needed logic. Since all of our entity tables,
    `tbl_project`, `tbl_issue`, and `tbl_user`, have the same columns defined, we
    could add our logic to a common base class and then have each of the individual
    AR classes extend from this new base class. This is a common approach to applying
    the same functionality to entities of the same type. However, Yii components—that
    is any instance of `CComponent` or a derived class of `CComponent`, which are
    typically the majority of your classes in a Yii application—offer you another
    and arguably more flexible alternative.
  prefs: []
  type: TYPE_NORMAL
- en: Component behavior
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Behaviors in Yii are classes implementing the `IBehavior` interface, and whose
    methods can be used to extend the functionality of components by being attached
    to the component, rather than the component explicitly extending the class. Behaviors
    can be attached to multiple components and components can attach multiple behaviors.
    This re-use of behaviors across components makes them very flexible, and by being
    able to attach multiple behaviors to the same component, we are able to achieve
    a kind of *multiple inheritance* for our Yii component classes.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to use this approach to add the needed functionality to our model
    classes. The reason we are taking this approach, rather than just adding the logic
    directly to our `User` model class, is because our other model classes, `Issue`
    and `Project`, also need this same logic. Rather than duplicate the code in every
    AR model class, placing the functionality in behaviors, and then attaching the
    behaviors to the model classes, will allow us to properly set these fields for
    every AR model class in just one place.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order for a component to use the methods of a behavior, the behavior has
    to be attached to the component. This is as simple as calling the `attachBehavior()`
    method on a component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous code, `$name` is a unique identifier for the behavior within
    the component. Once attached, the component can call the methods defined in the
    behavior class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code, `myBehaviorMethod()` is defined in the `$behavior` class,
    but can be called as if it was defined in the `$component` class.
  prefs: []
  type: TYPE_NORMAL
- en: For model classes, we can add our desired behaviors to the `behaviors()` method,
    which is the approach we will take for these model classes. Now we just need to
    create a behavior to attach.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, the Zii extension library, which is packaged with the Yii framework,
    already has a ready-made behavior that will update our date-time columns, `create_time`
    and `update_time`, which we have on each of our underlying tables. This behavior
    is called `CTimestampBehavior`. So, let's put this behavior to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with our `User` model class. Add the following method to `protected/models/User.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Here we are attaching the Zii extension library's `CTimestampBehavior` to our
    `User` model class. We have specified the create time and update time attributes
    and have also configured the behavior to set the update time when a new record
    is created. With this in place, we can try it out. Create a new user, and you'll
    see the `create_time` and `update_time` records being automatically inserted for
    us. Pretty cool, right?
  prefs: []
  type: TYPE_NORMAL
- en: '![Component behavior](graphics/8727_06_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is great, but we need to repeat this in our other model classes. We could
    duplicate the `behaviors()` method in each one, and continue to do so as we add
    more model classes. Alternatively, we could put this in a common base class and
    have each of our model classes extend this new base class. This way, we would
    only need to define the `behaviors()` method once.
  prefs: []
  type: TYPE_NORMAL
- en: We need to insert our `create_user_id` and `update_user_id` columns as well
    when we save and update a record. We could handle this in a number of ways. Since
    multiple behaviors can be attached to a component, we could create a new behavior,
    that is similar to `CTimestampBehavior`, which updates the create and update user
    ID columns. Or, we could simply extend `CTimestampBehavior`, and add the extra
    functionality to this child class. Or we could tap into the model `beforeSave`
    event directly and set our necessary fields there. Extending the existing behavior
    to add this extra functionality would probably make the most sense in a real-world
    application; however, to demonstrate another approach, let's tap into the active
    record `beforeSave` event, and do this in a common base class from which all of
    our AR model classes can extend. This way, you'll have exposure to a couple of
    different approaches and have more options to choose from when building your own
    Yii applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we need to create a new base class for our AR model classes. We''ll also
    make this new class `abstract` since it should not be instantiated directly. First,
    go ahead and remove the `behaviors()` method from the `User` AR class, as we''ll
    put this in our base class. Then create a new file, `protected/models/TrackStarActiveRecord.php`,
    and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, as discussed, we are overriding the `CActiveRecord::beforeSave()` method.
    This is one of the many events that `CActiveRecord` exposes to allow customization
    of its process workflow. There are two methods exposed that allow us to tap into
    the record saving workflow and perform any necessary logic either right before
    or right after the active record is saved: `beforeSave()` and `afterSave()`. In
    this case, we have decided to explicitly set our create and update user fields
    just prior to saving the active record, that is just before it is written to the
    database.'
  prefs: []
  type: TYPE_NORMAL
- en: We determine whether or not we are dealing with a new record (that is an insert)
    or an existing record (that is an update) by using the property `$this->isNewRecord`,
    and set our fields appropriately. We then make sure to invoke the parent implementation
    by returning `parent::beforeSave()` to ensure it has a chance to do everything
    it needs to do. We are performing a `NULL` check on `Yii::app()->user` to handle
    instances where we may be using this model class outside of a web application
    context, for example in a Yii console application (covered in a later chapter).
    If we don't have a valid user, we are simply defaulting to the first user, `id
    = 1`, which we could set up to be a super user.
  prefs: []
  type: TYPE_NORMAL
- en: Also, as discussed, we have moved our `behaviors()` method to this base class
    so that all AR model classes that extend it will have this behavior attached.
  prefs: []
  type: TYPE_NORMAL
- en: 'To try this out, we now need to alter each of the three existing AR classes
    `Project.php`, `User.php`, and `Issue.php` to extend from our new abstract class
    rather than directly from `CActiveRecord`. So, for example, rather than the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to have:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We need to make similar changes for our other model classes.
  prefs: []
  type: TYPE_NORMAL
- en: Now if we add another new user, we should see all four of our audit history
    columns populated with timestamps and user IDs respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'With these changes now in place, we should remove these fields from each of
    the forms for creating new projects, issues, and users (we already removed them
    from the issues form in the previous chapter). The HTML for these form fields
    is in the `protected/views/project/_form.php`, `protected/views/issue/_form.php`,
    and `protected/views/user/_form.php` files. The lines we need to remove from each
    of these files are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'And from the user creation form, `protected/views/user/_form.php`, we can also
    remove the last login time field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we are removing these from being form inputs, we should also remove the
    validation rules defined for these fields in the associated rules method. These
    validation rules are defined to ensure the data submitted by the user is valid
    and correctly formatted. Removing the rules also prevents them from being able
    to be a part of the bulk assignment of properties that occurs when we take all
    of the submitted querystring or post variables and assign their values to our
    AR model properties. For example, we see lines like the following in our create
    and update controller actions for AR models:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This is doing a mass assignment of all of the model attributes from the posted
    form fields. As an added security measure, this only works for attributes that
    have validation rules assigned for them. You can use the `CSafeValidator` as a
    way to mark model attributes that don't otherwise have any validation rules as
    being safe for this mass assignment.
  prefs: []
  type: TYPE_NORMAL
- en: Since these fields are not going to be filled in by the user, and we don't need
    them to be massively assigned, we can remove the rules.
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, so let''s remove them. Open up `protected/models/User.php` and in the
    `rules()` method, remove the following two rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The project and issue AR classes have similar rules defined, but not identical.
    When removing those rules, be sure to leave in the rules that do still apply to
    the user input fields.
  prefs: []
  type: TYPE_NORMAL
- en: The removal of the rule for the `last_login_time` attribute above was intentional.
    We should remove this from being exposed as a user input field as well. This field
    needs to be updated automatically upon a successful login. Since we had the view
    file open and were removing the other fields, we decided to remove this one now
    as well. However, we will wait to add the necessary application logic until after
    we make a few other changes and cover a few other topics.
  prefs: []
  type: TYPE_NORMAL
- en: 'Actually, while we still have our hands in this validation rules method for
    the `User` class, we should make another change. We want to ensure that the e-mail
    as well as the username for every user is unique. We should validate this requirement
    when the form is submitted. Also, we should validate that the data submitted for
    the e-mail conforms to a standard e-mail format. You may recall from back in [Chapter
    4](ch04.html "Chapter 4. Project CRUD"), *Project CRUD* that we introduced Yii''s
    built-in validators, and two of these are perfect for our needs. We''ll use the
    `CEmailValidator` and `CUniqueValidator` classes to achieve our validation needs.
    We can quickly add these rules by adding the following two lines of code to this
    `rules()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The entire `User::rules()` method should now look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The *unique* declaration in the above rule is an alias that refers to Yii's
    built-in validator, `CUniqueValidator`. This validates the uniqueness of the model
    class attribute against the underlying database table. With the addition of this
    validation rule, we will receive an error when attempting to enter either an e-mail
    and/or username that already exists in the database. Also, with the addition of
    the e-mail validation, we will receive an error when the value in the e-mail form
    field is not of a correct e-mail format.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we first created our `tbl_user` table in the previous chapter, we added
    two test users so we would have some data to play with. The first of these two
    users has an e-mail address of `test1@notanaddress.com`. Try to add another user
    using this same e-mail. The following screenshot shows the error message received
    and the highlighting of the field in error after such an attempt:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Component behavior](graphics/8727_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Submitting a value that is not in a valid e-mail format will also produce an
    error message.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a password confirmation field
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to the changes we just made, we should add a new field to force
    the user to confirm the password they entered. This is a standard practice on
    user registration forms and helps the user not to make a mistake when entering
    this important piece of information. Fortunately, Yii comes with another built-in
    validator, `CCompareValidator`, which does exactly what you think it might do.
    It compares the values of two attributes, and returns an error if they are not
    equal.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to take advantage of this built-in validation, we need to add a new
    attribute to our model class. Add the following attribute to the top of the `User`
    model AR class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We named this attribute by appending `_repeat` to the name of the attribute
    we want to compare against. The compare validator will allow you to specify any
    two attributes to compare, or compare an attribute to a constant value. If no
    comparison attribute or value is specified when declaring the compare rule, it
    will default to looking for an attribute beginning with the same name as the one
    being compared, with the addition of `_repeat` appended to the end. This is why
    we named the attribute in this manner. Now we can add a simple validation rule
    to the `User::rules()` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If not using the `_repeat` convention, you would need to specify the attribute
    with which you want the comparison performed. For example, if we wanted to compare
    the `$password` attribute to an attribute named `$confirmPassword`, we could use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we have explicitly added the `$password_repeat` attribute to the user
    AR class, and there is no validation rule defined for it, we need to also tell
    the model class to allow this field to be set in a bulk manner when the `setAttributes()`
    method is called. As previously mentioned, we do this by explicitly adding our
    new attribute to the *safe* attributes list for our `User` model class. To do
    this, add the following to the `User::rules()` array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s make one more change to our validation rules. All of the fields we currently
    have on the user form should be required. Currently, our required rule is only
    being applied to the `email` field. While we are making changes to this `User::rules()`
    method, let''s add username and password to this list as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For more information on validation rules, see: [http://www.yiiframework.com/doc/guide/1.1/en/form.model#declaring-validation-rules](http://www.yiiframework.com/doc/guide/1.1/en/form.model#declaring-validation-rules)'
  prefs: []
  type: TYPE_NORMAL
- en: Okay, now all of our rules are set. However, we still need to add the password
    confirmation field to the form. Let's do that now.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add this field, open up `protected/views/user/_form.php`, and add the following
    code block below the password field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'With all of these form changes in place, the **Create User** form should look
    as depicted in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a password confirmation field](graphics/8727_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And now, if we attempt to submit the form with different values in the **Password**
    and **Password Repeat** fields, we will be met with an error as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding a password confirmation field](graphics/8727_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Hash the password
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One last change we should make before we leave the new user creation process
    is to create a hashed version of the user's password before we store it in our
    database. It is a very common practice to apply a one-way hashing algorithm on
    sensitive user information before adding it to persistent storage.
  prefs: []
  type: TYPE_NORMAL
- en: We will add this logic to the `User.php` AR class by taking advantage of another
    method of `CActiveRecord` that allows us to customize the default active record
    workflow. This time we'll override the `afterValidate()` method and apply a basic
    one-way hash to the password after we validate all the input fields, but before
    we save the record.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Similar to our use of the `CActiveRecord::beforeSave()` method when setting
    our create and update timestamps, here we are overriding the `CActiveRecord::beforeValidate()`
    method. This is one of the many events that `CActiveRecord` exposes to allow customization
    of its process workflow. As a quick reminder, if you do not explicitly send `false`
    as a parameter when calling the `save()` method on an AR class, the validation
    process will be triggered. This process performs the validations as specified
    in the `rules()` method within the AR class. There are two methods exposed that
    allow us to tap into the validation workflow and perform any necessary logic either
    right before or right after the validation is performed, that is, `beforeValidate()`
    and `afterValidate()`. In this case, we have decided to hash the password just
    after performing the validation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open up the `User` AR class and add the following to the bottom of the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We mentioned this in the previous chapter, but it is worth mentioning again.
    We are using the one-way MD5 hashing algorithm here because of its ease of use
    and that it is widely available on 5.x Versions of MySQL and PHP. However, it
    is now known that MD5 is "broken" as a one-way hashing algorithm with regard to
    security and it is not suggested that you use this hashing algorithm in a production
    environment. Please consider using Bcrypt for your real, production applications.
    The following are some URLs providing more information on Bcrypt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://en.wikipedia.org/wiki/Bcrypt](http://en.wikipedia.org/wiki/Bcrypt)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://php.net/manual/en/function.crypt.php](http://php.net/manual/en/function.crypt.php)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://www.openwall.com/phpass/](http://www.openwall.com/phpass/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With this in place, it will hash the password just after all of the other attribute
    validations have successfully passed.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This approach works fine for brand new records, but for updates, if the user
    is not updating his/her password information, it runs the risk of hashing an already
    hashed value. We could handle this in a number of ways, but to keep things simple
    for now, we will need to ensure we ask the user to supply a valid password every
    time they desire to update their user data.
  prefs: []
  type: TYPE_NORMAL
- en: We now have the ability to add new users to our application. Since we initially
    created this form using the Gii tool's **Crud Generator** link, we also have read,
    update, and delete functionality for users. Try it out by adding some new users,
    viewing a list of them, update some of the information, and then delete a few
    of the entries to ensure everything is working as expected. (Remember that you
    will need to be logged in as `admin`, as opposed to `demo`, in order to perform
    the deletes.)
  prefs: []
  type: TYPE_NORMAL
- en: Authenticating users using the database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we know, a basic login form and user authentication process was created for
    us simply by using the `yiic` command to create our new application. This authentication
    scheme is very simple. It interrogates the input form's username/password values,
    and if they are either `demo/demo` or `admin/admin`, it passes, otherwise it fails.
    This is obviously not intended to be a permanent solution, but rather a foundation
    on which to build. We are going to build upon this by altering the authentication
    process to use our `tbl_user` database table that we already have as part of our
    model. But before we start changing the default implementation, let's take a closer
    look at how Yii implements an authentication model.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the Yii authentication model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Central to the Yii authentication framework is an application component called
    **user**, which, in the most general case, is an object implementing the `IWebUser`
    interface. The specific class used by our default implementation is the framework
    class, `CWebUser`. This user component encapsulates all the identity information
    for the current user of the application. This component was configured for us
    as part of the autogenerated application code when we initially created our application
    using the `yiic` tool. The configuration can be seen in the `protected/config/main.php`
    file, under the `components` array element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Since it is configured as an application component, with the name `'user'`,
    we can access it at any place throughout our application using `Yii::app()->user`.
  prefs: []
  type: TYPE_NORMAL
- en: We also notice that the class property, `allowAutoLogin`, is being set here
    as well. This property is `false` by default, but setting it to `true` enables
    user information to be stored in persistent browser cookies. This data is then
    used to automatically authenticate the user upon subsequent visits. This is what
    will allow us to have a **Remember Me** checkbox on the login form so that, if
    the user chooses, they can be automatically logged into the application upon subsequent
    visits to the site.
  prefs: []
  type: TYPE_NORMAL
- en: The Yii authentication framework defines a separate entity to house the actual
    authentication logic. This is called an **identity class**, and in general can
    be any class that implements the `IUserIdentity` interface. One of the primary
    roles of this class is to encapsulate the authentication logic to easily allow
    for different implementations. Depending on the application requirements, we may
    need to validate a username and password against values stored in a database,
    or allow users to log in with their OpenID credentials, or integrate with an existing
    LDAP approach. Separating the logic that is specific to the authentication approach
    from the rest of the application login process allows us to easily switch between
    such implementations. The identity class provides this separation.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we initially created our application, a user identity class file, namely
    `protected/components/UserIdentity.php`, was generated for us. It extends the
    Yii framework class, `CUserIdentity`, which is a base class for authentication
    implementations that uses a username and password. Let''s take a closer look at
    the code that was generated for this class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The bulk of the work in defining an identity class is the implementation of
    the `authenticate()` method. This is where we place the code that is specific
    to the authentication approach. This implementation simply uses the hardcoded
    username/password values of `demo/demo` and `admin/admin`. It checks these values
    against the username and password class properties (properties defined in the
    parent class, `CUserIdentity`) and if they don't match, it will set and return
    an appropriate error code.
  prefs: []
  type: TYPE_NORMAL
- en: In order to better understand how these pieces fit into the entire end-to-end
    authentication process, let's walk through the logic starting with the login form.
    If we navigate to the login page, `http://localhost/trackstar/index.php?r=site/login`,
    we see a simple form allowing the input of a username, a password, and an optional
    checkbox for the **Remember Me Next Time** functionality that we discussed before.
    Submitting this form invokes the logic contained in the `SiteController::actionLogin()`
    method. The following sequence diagram depicts the class interaction that occurs
    during a successful login from the time the form is submitted.
  prefs: []
  type: TYPE_NORMAL
- en: '![Introducing the Yii authentication model](graphics/8727_06_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The process starts with setting the class attributes on the form model class,
    `LoginForm`, to the form values submitted. The `LoginForm->validate()` method
    is then called, which validates these attribute values based on the rules defined
    in the `rules()` method. This method is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The last of these rules stipulates that the password attribute be validated
    using the custom method `authenticate()`, which is also defined in the `LoginForm`
    class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Continuing to follow the sequence diagram, the password validation within `LoginForm`
    calls the `authenticate()` method within the same class. This method creates a
    new instance of the authentication identity class being used, in this case it
    is `/protected/components/UserIdentity.php`, and then calls its `authenticate()`
    method. This method, `UserIdentity::authenticate()` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This is implemented to use the username and password to perform its authentication.
    In this implementation, as long as the username/password combination is either
    `demo/demo` or `admin/admin`, this method will return `true`. Since we are walking
    through a successful log in, the authentication succeeds and then the `SiteController`
    calls the `LoginForm::login()` method, which looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: And we can see that this in turn calls `Yii::app()->user->login` (that is `CWebUser::login()`),
    passing in the `CUserIdentity` class instance as well as a duration to which to
    set the cookie for autologin.
  prefs: []
  type: TYPE_NORMAL
- en: By default, the web application is configured to use the Yii framework class,
    `CWebuser` as the user application component. Its `login()` method takes in an
    identity class and an optional duration parameter used to set the time to live
    on the browser cookie. In the previous code, we see that this is set to `30 days`
    if the **Remember Me** checkbox was checked when the form was submitted. If you
    do not pass in a duration, it is set to zero. A value of zero will result in no
    cookie being created at all.
  prefs: []
  type: TYPE_NORMAL
- en: The `CWebUser::login()` method takes the information contained in the identity
    class and saves it in persistent storage for the duration of the user session.
    By default, this storage is the PHP session storage.
  prefs: []
  type: TYPE_NORMAL
- en: After all of this is completed, the `login()` method on `LoginForm` that was
    initially called by our controller class returns `true`, which indicates a successful
    log in. The controller class then redirects to the URL value in `Yii::app()->user->returnUrl`.
    You can set this on certain pages throughout the application if you want to ensure
    that the user be redirected back to their previous page, that is wherever they
    were in the application before they decided (or were forced) to log in. This value
    defaults to the application entry URL.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the authenticate implementation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that we understand the entire authentication process, we can easily see
    where we need to make the change to use our `tbl_user` table to validate the username
    and password credentials submitted via the login form. We can simply alter the
    `authenticate()` method in the user identity class to verify the existence of
    a matching row with the supplied username and password values. Since, at the moment,
    there is nothing else in our `UserIdentity.php` class except the authenticate
    method, let''s completely replace the contents of this file with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'And since we are going to have our `User` model class do the actual password
    validation, we also need to add the following method to our `User` model class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: There are a few things going on with this new code that should be pointed out.
    First, it is now attempting to retrieve a row from the `tbl_user` table, by way
    of creating a new `User` model AR class instance, where the username is the same
    as the `UserIdentity` class's attribute value (remember that this is set to be
    the value from the login form). Since we enforced the uniqueness of the username
    when creating a new user, this should find at most one matching row. If it does
    not find a matching row, an error message is set to indicate the username is incorrect.
    If a matching row is found, it compares the passwords by calling our new `User::validatePassword()`
    method. If the password fails the validation, it sets an error message to indicate
    an incorrect password.
  prefs: []
  type: TYPE_NORMAL
- en: If the authentication is successful, a couple of other things happen before
    the method returns. First, we have set a new attribute on the `UserIdentity` class
    for the user ID. The default implementation in the parent class is to return the
    username for the ID. Since we are using a database, and have a numeric primary
    key as our unique user identifier, we want to make sure this is what is set and
    returned throughout the application when the user ID is requested. For example,
    when the code `Yii::app()->user->id` is executed, we want to make sure that the
    unique ID from the database is returned, not the username.
  prefs: []
  type: TYPE_NORMAL
- en: Extending user attributes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The second thing happening here is the setting of an attribute on the user
    identity to be the last login time returned from the database, and then also updating
    the `last_login_time` field in the database to be the current time. The specific
    code from the previous snippet doing this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The user application component, `CWebUser`, derives its user attributes from
    the explicit ID and name attributes defined in the identity class, and then from
    `name=>value` pairs set in an array called the `identity states`. These are the
    extra user values that can be persisted throughout a user''s session. As an example
    of this, we are setting the attribute named `lastLogin` to be the value of the
    `last_login_time` field in the database. This way, at any place throughout the
    application, this attribute can be accessed via:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The reason we take a different approach when storing the last login time versus
    the ID is that *ID* just happens to be an explicitly defined property on the `CUserIdentity`
    class. So, other than *name* and *ID*, all other user attributes that need to
    be persisted throughout the session can be set in a similar manner.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When cookie-based authentication is enabled (by setting `CWebUser::allowAutoLogin`
    to be `true`), the persistent information will be stored in the cookie. Therefore,
    you should *not* store sensitive information (for example, your password) in the
    same manner as we have stored the user's last login time.
  prefs: []
  type: TYPE_NORMAL
- en: 'With these changes in place, you will now need to provide a correct username
    and password combination for a user defined in the `tbl_user` table in the database.
    Using `demo/demo` or `admin/admin` will, of course, no longer work. Give it a
    try. You should be able to login as any one of the users you created earlier in
    this chapter. If you followed along and have the same user data as we do, the
    credentials Username: `User One`, Password: `test1` should work.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have altered the login process to authenticate against the database,
    we won't be able to access the delete functionality for any of our project, issue,
    or user entities. The reason for this is that there are authorization checks in
    place to ensure that the user is an admin prior to allowing access. Currently,
    none of our database users have been configured to be authorized administrators.
    Don't worry, authorization is the focus of the next chapter, so we will be able
    to access that functionality again very soon.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying the last login time on the home page
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we are updating the last login time in the database, and saving it
    to persistent session storage when logging in, let's go ahead and display this
    time on our welcome screen that a user will see after a successful log in. This
    will also help make us feel better that all of this is working as expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open up the default view file that is responsible for displaying our home page
    `protected/views/site/index.php`. Add the following highlighted lines of code
    just below the welcome statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'And since we are in there, let''s go ahead and remove all of the other autogenerated
    help text, which is everything else below the lines we just added. Once you save
    and log in again, you should see something similar to the following screenshot,
    which displays the welcome message followed by a formatted time indicating your
    last successful log in:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Displaying the last login time on the home page](graphics/8727_06_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter was the first of two where we focus on user management, authentication,
    and authorization. We created the ability to manage CRUD operations for application
    users, making many adjustments to the new user creation process along the way.
    We added a new base class for all of our active record classes so that we can
    easily manage our audit history table columns that are present on all of our tables.
    We also updated our code to properly manage the user's last login time that we
    are storing in the database. In doing so, we learned about tapping into the `CActiveRecord`
    validation workflow to allow for prevalidation/postvalidation and presaving/postsaving
    processing.
  prefs: []
  type: TYPE_NORMAL
- en: We then focused on understanding the Yii authentication model in order to enhance
    it to meet our application requirements so that the user credentials are validated
    against the values stored in the database.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have covered authentication, we can turn our focus to the second
    part of Yii's auth-and-auth framework, *authorization*. This is the focus of the
    next chapter.
  prefs: []
  type: TYPE_NORMAL
