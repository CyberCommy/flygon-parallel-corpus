- en: '*Chapter 12*: Visual Testing in Cypress'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第12章*：Cypress中的视觉测试'
- en: Before we get started with visual testing, you should have an idea of the other
    forms of testing and how we can use Cypress to accomplish this. The previous chapters
    of this book covered, at a basic to intermediate level, how to easily get started
    with Cypress, how to configure Cypress, and how you can optimize your use of Cypress
    to develop a more creative workflow for your test writing process. The background
    information in the previous chapters will provide you with the context required
    to tackle this chapter. Our focus in this last chapter of this book will be on
    visual testing using Cypress.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始进行视觉测试之前，您应该了解其他形式的测试以及我们如何使用Cypress来完成这些测试。本书的前几章介绍了如何轻松入门Cypress，如何配置Cypress，以及如何优化您使用Cypress来为测试编写过程开发更有创意的工作流程。前几章的背景信息将为您提供解决本章所需的上下文。本书的最后一章将重点介绍使用Cypress进行视觉测试。
- en: In this chapter, we will cover the basics of visual testing and understand why
    we need it. We will also learn about some of the tools we can use to carry out
    visual testing. The topics in this chapter will help you, as an engineer or a
    tester, understand why visual testing is important for web applications and how
    we can leverage it to write better tests.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍视觉测试的基础知识，并了解为什么我们需要它。我们还将学习一些工具，可以用来进行视觉测试。本章的主题将帮助你作为工程师或测试人员理解为什么视觉测试对于Web应用程序很重要，以及我们如何利用它来编写更好的测试。
- en: 'We will cover the following key topics in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中涵盖以下关键主题：
- en: Visual testing
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视觉测试
- en: Understanding viewports
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解视口
- en: Visual testing tools in Cypress tests
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cypress测试中的视觉测试工具
- en: Once you've worked through each of these topics, you will be ready to start
    your journey into the automation testing world with Cypress as your tool of choice.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您完成了每个主题，您将准备好开始使用Cypress作为您的选择工具进入自动化测试世界的旅程。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 技术要求
- en: To get started, we recommend that you clone the GitHub repository for this book,
    which contains the source code and all the tests, exercises, and solutions that
    we will be writing in this chapter.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，请克隆本书的GitHub存储库，其中包含本章中将编写的所有源代码、测试、练习和解决方案。
- en: The GitHub repository for this chapter can be found at [https://github.com/PacktPublishing/End-to-End-Web-Testing-with-Cypress](https://github.com/PacktPublishing/End-to-End-Web-Testing-with-Cypress).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的GitHub存储库可以在[https://github.com/PacktPublishing/End-to-End-Web-Testing-with-Cypress](https://github.com/PacktPublishing/End-to-End-Web-Testing-with-Cypress)找到。
- en: The source code for this chapter can be found in the `chapter-12` directory.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码可以在`chapter-12`目录中找到。
- en: Inside our GitHub repository, we have a finance test application that we will
    use for the different examples and exercises in this chapter.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的GitHub存储库中，我们有一个金融测试应用程序，我们将在本章的不同示例和练习中使用它。
- en: 'Important note: Running commands in Windows'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示：在Windows中运行命令
- en: 'NB: The default Windows Command Prompt and PowerShell do not correctly resolve
    the directory locations.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 注：默认的Windows命令提示符和PowerShell无法正确解析目录位置。
- en: Kindly follow the Windows commands listed further that work exclusively on Windows
    operating systems suffixed with the word `*windows`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 请遵循以下列出的Windows命令，这些命令仅适用于Windows操作系统，并以`*windows`结尾。
- en: 'To make sure the test application is running on your machine, run the following
    commands from the root folder directory of the repository on your machine''s terminal:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保测试应用程序在您的计算机上运行，请从存储库的根文件夹目录中在您计算机的终端上运行以下命令：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Important note
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: We have our tests in the `chapter-12` directory and the test application located
    in the root directory of the repository. To run our tests properly, we have to
    run both our application and the Cypress tests since the tests run on the live
    application, which has to run locally on our machines. It is important to note
    that the test application will require the use of port `3000` for the frontend
    application and port `3001` for the server application.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试位于`chapter-12`目录中，测试应用程序位于存储库的根目录中。为了正确运行我们的测试，我们必须同时运行我们的应用程序和Cypress测试，因为测试是在实时应用程序上运行的，而这个应用程序必须在我们的计算机上本地运行。重要的是要注意，测试应用程序将需要使用端口`3000`用于前端应用程序和端口`3001`用于服务器应用程序。
- en: The first command will navigate us to the `cypress-realworld-app` directory,
    which is where our application is located. The `npm run cypress-init` command
    will install the dependencies that the application requires to run, while the
    `npm run cypress-app` command will start the application. Optionally, you can
    reset the application state using the `npm run cypress-app-reset` command. Resetting
    the application removes any data that was added that was not part of the application,
    thus taking the application's state back to when you cloned the repository.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个命令将导航到`cypress-realworld-app`目录，这是我们的应用程序所在的位置。`npm run cypress-init`命令将安装应用程序运行所需的依赖项，而`npm
    run cypress-app`命令将启动应用程序。可选地，您可以使用`npm run cypress-app-reset`命令重置应用程序状态。重置应用程序会删除任何不属于应用程序的已添加数据，从而将应用程序状态恢复到克隆存储库时的状态。
- en: Visual testing
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视觉测试
- en: Whether you are a web developer or a tester, there is a need to ensure that
    the application under development retains the look and feel that was intended
    at project conception. As a developer, you may want to verify that there are no
    visual aspects about your application that changed between releases. As a tester,
    you may want to validate that the application's user interface remains consistent
    between releases and is consistent with the design.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您是Web开发人员还是测试人员，都需要确保正在开发的应用程序保留了项目概念时预期的外观和感觉。作为开发人员，您可能希望验证应用程序在发布之间没有发生视觉方面的变化。作为测试人员，您可能希望验证应用程序的用户界面在发布之间保持一致，并且与设计一致。
- en: '**Functional testing** can be used to check for visual aspects, such as validating
    that a button or an input box is present. However, this may involve a lot of code
    being written and, most of the time, will not allow you to test every aspect of
    the application, such as CSS changes when we use it to validate user interface
    elements. Visual testing is the ability to verify visual aspects of an application''s
    user interface and ensure that they are consistent with the expectations.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will learn what visual testing is, what the different types
    of visual testing are, the differences between manual and automated visual testing,
    and when to use different types of visual testing approaches.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Why visual testing?
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Visual testing takes a practical approach as you must directly map the visual
    aspects of a page and compare those aspects to the expected designs. It is possible
    to dismiss the idea of visual testing because we think that our eyes are accurate
    enough for validation purposes, which is a flawed assumption. While the naked
    eye can notice visible page changes, it is a little bit more difficult for the
    eye to detect minute details, such as a change in the CSS properties that made
    an input element move by several pixels or minimal pixel changes.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: Visual testing exists to give both developers and testers confidence that a
    web page's user interface was not broken by any developer changes that were made.
    For instance, with visual testing, there is no need to fear if a version of the
    application that was deployed to the production environment is missing a signup
    button while previous versions of the application had it.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two types of visual testing, as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: Manual visual testing
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automated visual testing
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These two types of visual testing will open our worlds up to how important visual
    testing is, as well as how we can take advantage of these two testing methods
    to write better tests.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Manual visual testing
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Manual visual testing involves using the naked eye to validate whether the
    changes that were made by the development team did not break any visible user
    interface functionality. Manual visual testing involves either the testers or
    the development team visually testing the developed user interface and comparing
    it to the designs that were initially created. The process of visually testing
    the application confirms that there are no changes in the behavior, look, and
    feel of the user interface that were not intended. Manual visual testing is good
    and suitable for small changes in the user interface, but this may not be a very
    accurate way of validating an application with a lot of pages and visual elements
    or different viewports. To identify the limitations of manual visual testing,
    the following image, by *Atlantide Phototravel*, shows a side-by-side comparison
    of the Eiffel tower. They are very similar but minute details have been omitted
    in the second frame. Take a few seconds to compare the images and try to find
    the visual differences without looking at the rounded regions in the second image:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.1 – Spotting the differences in the Eiffel Tower image'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_12.1_B15616.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.1 – Spotting the differences in the Eiffel Tower image
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Even to the trained eye, there are details such as bird patterns, missing people,
    and even missing clouds that could make it almost visually impossible to tell
    if there is actually a difference between the two photographs. By applying the
    same idea of manual visual testing, it is very possible to miss details and not
    be able to find any differences between them, even when some elements are missing
    or have been added to the applications under test.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: Automated visual testing
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Automated visual testing involves testing the visual elements of the page. Instead
    of using a manual approach, an automated process to check the consistency of the
    application pages is used. To run automated visual tests properly, we must save
    and define our desired user interface as a **baseline**. We can then use this
    in our tests to check whether we need to update the baseline or modify the changes
    made to our application.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化视觉测试涉及测试页面的视觉元素。与手动方法不同，使用自动化流程来检查应用程序页面的一致性。要正确运行自动化视觉测试，我们必须将所需的用户界面保存和定义为基线。然后我们可以在测试中使用这个基线来检查是否需要更新基线或修改应用程序所做的更改。
- en: Automated visual testing has its roots in functional testing. Instead of asserting
    every element in a page and also checking the properties of the elements in a
    page, automated visual testing takes the approach of checking the entire page
    with a single assertion.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化视觉测试源于功能测试。自动化视觉测试采用了检查整个页面的方法，而不是断言页面中的每个元素并检查元素的属性。
- en: 'There are two types of automated visual testing:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化视觉测试有两种类型：
- en: Snapshot testing
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快照测试
- en: Visual AI testing
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视觉AI测试
- en: Let's look at each of them in detail.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细看看每一种。
- en: Snapshot testing
  id: totrans-45
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 快照测试
- en: Snapshot testing is a type of automated visual testing where a raster graphic
    or a bitmap of a specific screen is recorded when the test is running. The recorded
    bitmap is then checked against the baseline bitmap that was recorded previously
    (baseline). The algorithms in the snapshot testing tools only check whether there
    are pixel differences in the bitmap by comparing **hex color codes**. If any color
    code differences are identified, then a snapshot bug is reported or an image showing
    visual differences is generated.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 快照测试是一种自动化视觉测试，当测试运行时，记录特定屏幕的光栅图形或位图。然后检查记录的位图与先前记录的基线位图（基线）是否一致。快照测试工具中的算法仅通过比较十六进制颜色代码来检查位图中是否存在像素差异。如果识别出任何颜色代码差异，则报告快照错误或生成显示视觉差异的图像。
- en: Snapshot testing is a significantly quicker way to identify bugs in user interfaces
    compared to manual testing. Snapshot testing is the preferred way of testing web
    applications if the application is somewhat static in nature and does not have
    a lot of dynamic content changes in the user interface. Snapshot testing does
    not handle dynamic content properly as the algorithm detects any change in content
    as a visual difference due to pixel changes. With all visual changes being identified
    as a visual difference or a potential bug, it would be impossible to have consistent
    snapshot images of pages that contain dynamic data.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 与手动测试相比，快照测试是识别用户界面中的错误的一种更快的方法。如果应用程序在某种程度上是静态的，并且用户界面中没有太多的动态内容更改，那么快照测试是测试Web应用程序的首选方式。快照测试无法正确处理动态内容，因为算法将内容中的任何更改都视为视觉差异，由于像素更改。由于所有视觉变化都被识别为视觉差异或潜在的错误，因此在包含动态数据的页面上拥有一致的快照图像将是不可能的。
- en: Visual AI testing
  id: totrans-48
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 视觉AI测试
- en: Visual AI testing is the new generation of automated visual testing and makes
    use of **AI** (**AI**). The main goal of visual AI testing is to improve on the
    shortcomings of snapshot testing, such as handling dynamic content when testing
    applications. By using computer vision, visual AI algorithms can identify images
    and areas where our tests can run and even in the event of dynamic content, they
    can identify the regions where our content is allowed to be dynamic and the regions
    that should remain unchanged.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 视觉AI测试是自动化视觉测试的新一代，利用了人工智能（AI）。视觉AI测试的主要目标是改进快照测试的缺点，例如在测试应用程序时处理动态内容。通过使用计算机视觉，视觉AI算法可以识别图像和测试可以运行的区域，甚至在动态内容的情况下，它们可以识别内容允许动态的区域和应保持不变的区域。
- en: Visual AI testing also makes it easier for developers and testers to perform
    cross-browser testing. With cross-browser applications, the user can write a single
    test that can then be run in different **viewports** that are supported by the
    application. **Viewport testing** is a handy tool as it removes the burden of
    the developer – or the tester writing snapshot tests for every device – checking
    every viewport to verify that there are no visual changes.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 视觉AI测试还使开发人员和测试人员更容易进行跨浏览器测试。对于跨浏览器应用程序，用户可以编写单个测试，然后在应用程序支持的不同视口中运行该测试。视口测试是一个方便的工具，因为它消除了开发人员或测试人员为每个设备编写快照测试的负担，以验证是否存在视觉变化。
- en: Recap – visual testing
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回顾-视觉测试
- en: In this section, we learned about what visual testing is, the different types
    of visual testing, and when to use each type of visual testing. We learned the
    difference between automated visual testing and manual visual testing, and we
    also learned about the different types of automated visual testing. We then learned
    why visual testing is a preferred approach to manual testing and why there is
    a new generation of visual testing that improves on the shortcomings that were
    present in the first-generation visual testing tools. Now that we know all about
    visual testing, in the next section, we will explore more areas that require visual
    testing by understanding what viewports are and how to test them.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们了解了什么是视觉测试，不同类型的视觉测试以及何时使用每种类型的视觉测试。我们了解了自动化视觉测试和手动视觉测试之间的区别，还了解了不同类型的自动化视觉测试。然后我们了解了为什么视觉测试是手动测试的首选方法，以及为什么有一种新一代的视觉测试工具改进了第一代视觉测试工具存在的缺点。现在我们已经了解了关于视觉测试的一切，在下一节中，我们将通过了解视口是什么以及如何测试它们来探索更多需要视觉测试的领域。
- en: Understanding viewports
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解视口
- en: A viewport is the visible area of a user's web page. Therefore, the term viewport
    is used to measure the rectangular viewing region on a user's device. When computers
    were first invented, there were only a few available viewports, though that has
    significantly increased due to more devices being created. At the time of writing,
    new viewports are being created by devices such as folding phones or flipping
    screens, and smart televisions with different dimensions, so it is up to developers
    to ensure that their applications are compatible with the user's devices. With
    different viewports, new challenges arise in terms of making applications compatible
    with such viewports, and this is even a greater nightmare for testers as it is
    practically not possible to test an application through every available viewport.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will explore the importance of viewports, how to approach
    testing in different viewports, and the role of viewports in visual testing.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: Viewports and testing
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Viewports play a major role when it comes to testing web applications as they
    show how the actual users will view the web application that is under test. At
    the time of writing, mobile viewports are the most commonly used viewports. This
    is because phones have been evolving to become the most powerful pieces of technology
    that are both portable and handheld. To provide good experiences for users, viewport
    testing should be a top priority. With viewport testing, we can check for qualities
    such as how responsive the web application is to different screen sizes.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: Developing responsive web applications provides an advantage over non-responsive
    web applications as they take less time and resources to develop compared to standalone
    mobile applications, which are either on iOS or Android and performing the same
    functions.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: 'All modern browsers allow us check and test for responsiveness when building
    applications. The following screenshot shows an iPhone 6 viewport rendered on
    a Chrome browser showing how the Cypress documentation page would appear on a
    mobile phone:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.2 – iPhone 6 mobile viewport'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_12.2_B15616.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.2 – iPhone 6 mobile viewport
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the **toggle device toolbar** on the browser to toggle between the
    normal web view and the mobile device view. This allows us to see how different
    web applications are rendered on different viewports. In instances where the web
    applications are responsive, there will be no issue testing the different viewports
    as the applications will automatically adapt to the changing viewports. However,
    this is not the case for non-responsive web applications. In the following screenshot,
    you can see the options for the current viewports, as well as the ability to add
    custom viewports that have not been defined by the browser:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.3 – Browser viewport selection'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_12.3_B15616.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.3 – Browser viewport selection
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: As shown in the preceding screenshot, it is possible to add new test viewports
    that do not exist in the Chrome browser's list of devices.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: When choosing a viewport, the Chrome web area automatically adjusts the content
    that's visible on the browser. As a developer or a tester, it is easy to find
    out whether changes are required for the application.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: Viewports and automated visual testing
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Considering the number of viewports shown in the preceding screenshot, it is
    cumbersome to manually test every single viewport and verify that there were no
    changes that broke the user interface of the application, or any that introduced
    unnecessary changes that were not intended. To ensure that the viewports are tested,
    we can use automated visual testing to check for consistency in the application
    through different viewports. With visual testing, we can validate that no unintended
    changes were made to our application in the different viewports that we configure
    in our tests.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: Recap – viewports
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Viewports are a critical aspect of visual testing, especially since most of
    the major issues regarding web applications responsiveness are a result of viewport
    bugs. In this section, we learned about different types of viewports and how we
    can check the responsiveness of our web applications using the browser's toggle
    option, which switches between different device viewports and the normal computer
    viewport. We also learned that by using automated visual testing, we can automate
    different test cases for different viewports and automatically know whether unintended
    changes were made to the application. In the next section, we will explore how
    we can use Cypress to write automated visual tests using an automated Visual AI
    tool and Percy, which utilizes snapshots to record visual tests.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: Automated visual testing tools
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Visual testing is an important part of Cypress as it is a transition from what
    we are familiar with, which is functional testing. With visual testing, Cypress
    presents a new world of opportunities regarding how we can test user interfaces
    without necessarily writing hundreds of lines of functional code to assert individual
    elements on a page.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will dive into working with two automated visual testing
    tools by integrating them with Cypress, and then learn how we can achieve our
    goals of visually testing applications using them. One of these tools uses snapshots
    that record a **baseline bitmap** and compare the bitmap image pixels one after
    the other, checking for whether there are any discrepancies in the hex colors.
    The other tool uses AI algorithms to compare snapshots from our web application.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this section, we will have an idea of what tool to use, when and
    how Cypress plays a role in creating simple integrations of the testing tools,
    and the tests themselves. The two tools we will look at are Applitools Eyes SDK
    and Percy.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: Percy
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Percy is a visual testing and review platform that integrates with testing tools.
    This enables developers and QA engineers identify visual bugs that would otherwise
    have been difficult to identify and report. Percy makes visual testing a walk
    in the park – all you need to do is to download the Percy npm module, configure
    **BrowserStack**, and add Percy to your tests. Once you've done all the necessary
    configuration, you can copy the **TOKEN** that Percy provides, which will be used
    as an environment variable in your machine and is required if you wish to upload
    your test snapshots to the Browserstack cloud to review and identify visual differences,
    if any.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: Browserstack is a visual testing and review tool, and it owns the **Percy**
    tool. To configure Percy, you need to configure Browserstack; all the configurations
    will be synced between the two platforms.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: Percy mainly relies on the Firefox and Chrome browsers. To test an application,
    Percy runs it through a set of browsers in various viewports, and any changes
    that have been made to the various viewports are recorded. When the first image
    is recorded and saved, Percy then makes the image in your test **baseline**, and
    will use the image to check for any changes in the subsequent test runs for similar
    images before highlighting any visual differences that may have occurred.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Percy
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Setting up Percy is not complicated and involves the following steps:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: Create an account with BrowserStack ([https://www.browserstack.com/](https://www.browserstack.com/)).
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Verify your BrowserStack email address.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an organization in the Browserstack dashboard.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Log into the Percy dashboard using your BrowserStack account.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a project on the Percy dashboard.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure Percy on your local project using the instructions on the Percy website
    ([https://docs.percy.io/docs/cypress](https://docs.percy.io/docs/cypress)).
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a Percy TOKEN to your local machine as an environment variable.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Voila! You are now ready to write your tests!
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once *steps 1 - 4* have been completed, Percy provides you with a TOKEN that
    you must add to your machine environment variable before executing your tests.
    You can visit the Percy documentation ([https://docs.percy.io/docs/cypress](https://docs.percy.io/docs/cypress))
    for more information on how to set up Percy using Cypress.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 完成*步骤1-4*后，Percy会提供一个令牌，您必须在执行测试之前将其添加到机器环境变量中。您可以访问Percy文档（[https://docs.percy.io/docs/cypress](https://docs.percy.io/docs/cypress)）了解如何使用Cypress设置Percy的更多信息。
- en: 'Once everything has been set up, we can run our first test, which will involve
    checking whether we can see visual differences on our login page when the content
    is changed. As shown in the following screenshot, we have run our test by entering
    a username and a password on the login page:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都设置好后，我们可以运行第一个测试，这将涉及检查当内容更改时我们的登录页面是否有视觉差异。如下截图所示，我们在登录页面上输入用户名和密码运行了我们的测试：
- en: '![Figure 12.4 – Percy – new snapshot'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.4 – Percy – 新快照'
- en: '](image/Figure_12.4_B15616.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_12.4_B15616.jpg)'
- en: Figure 12.4 – Percy – new snapshot
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.4 – Percy – 新快照
- en: Here, we can see the snapshot image that was uploaded to the Percy dashboard.
    The uploaded snapshot is our login page. Immediately after uploading the snapshot,
    Percy gives us the option to toggle the Chrome and Firebox browsers so that we
    can check the consistency of the snapshots. On the main Percy dashboard, we have
    the option to approve all our snapshots, reject and accept a single snapshot,
    and even toggle between the desktop viewport and the mobile viewport presented
    to us.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到上传到Percy仪表板的快照图像。上传的快照是我们的登录页面。在上传快照后，Percy让我们可以切换Chrome和Firebox浏览器，以便我们可以检查快照的一致性。在主Percy仪表板上，我们可以批准所有快照，拒绝和接受单个快照，甚至在桌面视口和移动视口之间切换。
- en: Important note
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Percy only uploads the snapshots to the dashboard when the test's execution
    is terminated and the terminal running the tests is closed. This is different
    from the Applitools tool, which continuously uploads the test snapshots immediately
    when the tests have finished execution.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当测试执行结束并关闭运行测试的终端时，Percy才会将快照上传到仪表板。这与Applitools工具不同，后者在测试执行结束后立即连续上传测试快照。
- en: 'As we mentioned earlier, we can use Percy to compare bitmap images of our recorded
    baseline images and the newly generated bitmap images. The algorithm involved
    then checks for pixel by pixel differences, which are then recorded as visual
    differences when the baseline image is not similar to the newly generated image
    that was generated in the second run of our test application. The following screenshot
    shows a second build of our tests on the Percy dashboard. Here, we have omitted
    some of the characters in the username and password fields and we want to check
    whether Percy identifies these discrepancies:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，我们可以使用Percy来比较我们记录的基准图像和新生成的位图图像。然后涉及的算法逐像素检查差异，当基准图像与在测试应用程序的第二次运行中生成的新图像不相似时，这些差异被记录为视觉差异。以下截图显示了我们在Percy仪表板上测试的第二次构建。在这里，我们省略了用户名和密码字段中的一些字符，并且我们想检查Percy是否识别出这些差异：
- en: '![Figure 12.5 – Percy pixel differences'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.5 – Percy像素差异'
- en: '](image/Figure_12.5_B15616.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_12.5_B15616.jpg)'
- en: Figure 12.5 – Percy pixel differences
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.5 – Percy像素差异
- en: As shown in the preceding screenshot, once we ran our second build, we omitted
    some of the characters in both our username and password fields. When the snapshots
    are uploaded to Percy, the program identifies the visual differences by checking
    the pixels of the different images and provides us with the region where the pixel
    differences were identified. On our second run, when we *approve* these changes,
    Percy adopts our second image as the **baseline**. If we *Request changes* on
    the image, Percy will then retain our first image as the baseline for this particular
    snapshot.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的截图所示，当我们运行第二个构建时，我们省略了用户名和密码字段中的一些字符。当快照上传到Percy时，程序通过检查不同图像的像素来识别视觉差异，并为我们提供识别出像素差异的区域。在我们的第二次运行中，当我们*批准*这些更改时，Percy采用我们的第二个图像作为**基准**。如果我们在图像上*请求更改*，Percy将保留我们的第一个图像作为此特定快照的基准。
- en: Upon closer inspection, our first snapshot login username was *Kathe*, while
    in our second snapshot, the login username was *Kat*. The omission of some characters
    in the password and some characters in the username is what triggers Percy to
    show these visual differences. This gives us the option to either accept the changes
    and change our baseline or request changes from the developers if the change is
    not consistent with our expectations.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细检查后，我们发现第一个快照的登录用户名是*Kathe*，而在第二个快照中，登录用户名是*Kat*。密码中的一些字符和用户名中的一些字符的省略是触发Percy显示这些视觉差异的原因。这使我们可以选择接受更改并更改我们的基准，或者如果更改与我们的期望不一致，则向开发人员请求更改。
- en: Reminder
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 提醒
- en: For you to successfully run tests and upload the snapshots to the Percy dashboard,
    you need to create an account with BrowserStack, create an organization in BrowserStack,
    sign in with Browserstack on your Percy dashboard, create a project in Percy,
    and add the token provided on the Percy project dashboard to your machine's environment
    variables.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 要成功运行测试并将快照上传到Percy仪表板，您需要在BrowserStack上创建一个帐户，在BrowserStack中创建一个组织，在Percy仪表板上使用Browserstack登录，创建一个Percy项目，并将Percy项目仪表板上提供的令牌添加到机器的环境变量中。
- en: 'Percy is quick to set up, both locally on the machine and also on the tests.
    To invoke Percy, only a single line needs to be added to the test. The following
    code block shows the first and second snapshots being generated, as well as the
    arguments that are passed to the `cy.percySnapshot()` command for naming the snapshots:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Percy在本地机器上和测试中都很容易设置。要调用Percy，只需要在测试中添加一行代码。以下代码块显示了生成第一和第二快照，以及传递给`cy.percySnapshot()`命令的参数来命名快照：
- en: '[PRE1]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The first test in the preceding code block was run in the first build, while
    the second test was run in the second build along with the modified username and
    password details to provide the pixel differences in our login page. To run these
    tests yourself, all you need to do is obtain the Percy token by following the
    Percy setup process mentioned previously and add your Percy project token as an
    environment variable of your machine. The complete source code for these tests
    can be obtained from this book's GitHub repository, in the `chapter-12` directory.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 1
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we are going to practice what we learned in the previous
    section: we will learn how to use Percy to perform visual testing and then interact
    with the Percy configuration and dashboard. Follow these steps:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Using Percy and Cypress, log into our test application and navigate to the dashboard.
    Then, using the `Percy` command, take a snapshot of the public transactions page.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new transaction by clicking the **New transactions** button on the application
    and add the transaction details.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Take another snapshot and use Percy to compare the transactions page's differences
    when another transaction is added.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Important note
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Remember to add your Percy **TOKEN** variable, which can be obtained from the
    Percy project dashboard, to your local machine before running your tests so that
    the snapshots taken by Percy can be successfully uploaded to the Percy dashboard.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: The solutions to this exercise can be found in `chapter-12/cypress/integration/percy/percy-excercise.spec.js`
    directory.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: By going through this exercise and being able to properly set up Percy in Cypress,
    I believe you now understand how you can use Percy to identify visual differences
    in your tests, as well as quickly identify discrepancies when your application's
    user interfaces change. You can do this by doing a pixel-by-pixel comparison of
    the bitmap images of our application.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Applitools
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Applitools is a tool that utilizes AI to visually test and monitor applications.
    Just like Percy, Applitools is easy to set up using Cypress and focuses on improving
    the shortcomings of tools such as Percy. Percy identifies visual differences by
    comparing individual pixels, while Applitools identifies visual differences by
    using its AI powered algorithms to check whether the changes are expected changes
    or bugs. With Applitools, it is easier to test dynamic changes as we can omit
    areas where we do not want Applitools to check for visual differences.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: The ability to identify bugs by specifying regions that should be checked, and
    others that should be ignored, is what makes Applitools a better tool when it
    comes to testing applications that involve dynamic content.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Applitools
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Just like Percy, the Applitools Eyes SDK is relatively easy to set up with
    Cypress. This can be achieved by performing the following steps:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Create an account with Applitools ([https://auth.applitools.com/users/register](https://auth.applitools.com/users/register)).
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Verify your Applitools email address.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the Applitools dashboard to obtain the API key.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure Applitools on your local project.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the Applitools **APPLITOOLS_API_KEY** to your local machine as an environment
    variable.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Party!
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once *steps 1* and *2* have been completed, Applitools provides you with an
    **APPLITOOLS_API_KEY**, similar to the Percy **TOKEN**, that you must add as an
    environment variable to your machine before executing your tests. You can visit
    the Applitools and Cypress documentation ([https://applitools.com/tutorials/cypress.html](https://applitools.com/tutorials/cypress.html))
    to find out more about how to set up the Applitools Eyes SDK using Cypress.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: 'Once everything has been set up, we can now run our first test using Cypress
    and the Applitools Eyes SDK. Applitools is a very rich tool, so we will not be
    able to cover all the features that it comes bundled with. Instead, we will focus
    on the advantages of Applitools in terms of using it as a visual testing tool.
    In the following screenshot, we have the same login test that we ran in our Percy
    example but modified for Applitools Eyes tests:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都设置好后，我们现在可以使用Cypress和Applitools Eyes SDK运行我们的第一个测试。Applitools是一个非常丰富的工具，所以我们无法涵盖它捆绑的所有功能。相反，我们将专注于Applitools作为视觉测试工具的优势。在下面的屏幕截图中，我们有相同的登录测试，我们在Percy示例中运行了该测试，但修改为Applitools
    Eyes测试：
- en: '![Figure 12.6 – Applitools login page snapshot'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.6 – Applitools登录页面快照'
- en: '](image/Figure_12.6_B15616.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_12.6_B15616.jpg)'
- en: Figure 12.6 – Applitools login page snapshot
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.6 – Applitools登录页面快照
- en: Here, we can see the snapshot representing the first login page snapshot that
    the Applitools Eyes SDK took and uploaded to the Applitools dashboard. Applitools
    uses three commands to control Cypress tests. The first command, `cy.eyesOpen()`,
    is for initializing and starting the test, the second command, `cy.eyesCheckWindow()`,
    is responsible for taking screenshots, as in the previous case, and the third
    command, `eyesClose()`, completes the Applitools Eyes session and uploads the
    screenshots to the dashboard.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到代表Applitools Eyes SDK拍摄并上传到Applitools仪表板的第一个登录页面快照的快照。Applitools使用三个命令来控制Cypress测试。第一个命令`cy.eyesOpen()`用于初始化和启动测试，第二个命令`cy.eyesCheckWindow()`负责拍摄屏幕截图，就像前面的情况一样，第三个命令`eyesClose()`完成Applitools
    Eyes会话并将屏幕截图上传到仪表板。
- en: 'Our login test can be written in the following format. This opens the Applitools
    Eyes SDK, takes a screenshot, and closes the SDK before uploading the screenshots
    to the Applitools dashboard so that they can be compared visually by the Applitools
    AI algorithms. The following code block shows the second build provided in the
    preceding screenshot:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的登录测试可以以以下格式编写。这会打开Applitools Eyes SDK，拍摄屏幕截图，并在上传屏幕截图到Applitools仪表板之前关闭SDK，以便Applitools
    AI算法可以通过视觉比较进行比较。以下代码块显示了前面屏幕截图中提供的第二个构建：
- en: '[PRE2]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, we can observe that to run the tests, we need to initialize the Applitools
    Eyes SDK, then take the screenshot before closing our tests. All three methods
    that the Eyes SDK utilizes can have configuration parameters that can be changed,
    depending on your needs. In our code block, for example, we have configured the
    `cy.eyesOpen()` command so that we have our test batch name and the configuration
    of the browser window visible.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以观察到，为了运行测试，我们需要初始化Applitools Eyes SDK，然后在关闭测试之前拍摄屏幕截图。Eyes SDK使用的所有三种方法都可以具有配置参数，这些参数可以根据您的需求进行更改。例如，在我们的代码块中，我们已配置`cy.eyesOpen()`命令，以便我们有测试批次名称和浏览器窗口可见的配置。
- en: 'Applitools goes a step further when it comes to reporting errors. In Percy,
    we identified that due to its pixel-by-pixel comparisons, any change in the user
    interface is detected as a visual difference and potentially a user interface
    bug. In the following screenshot, we can see how, after running a similar test
    with different user interface renderings, we can tell Applitools to ignore certain
    regions in our screens and mark our test as passed:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在报告错误方面，Applitools更进一步。在Percy中，我们发现由于其逐像素比较，用户界面的任何更改都被检测为视觉差异，可能是用户界面错误。在下面的屏幕截图中，我们可以看到，在使用不同用户界面渲染运行类似测试后，我们可以告诉Applitools忽略屏幕中的某些区域，并将我们的测试标记为通过：
- en: '![Figure 12.7 – Applitools ignore region options'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.7 – Applitools忽略区域选项'
- en: '](image/Figure_12.7_B15616.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_12.7_B15616.jpg)'
- en: Figure 12.7 – Applitools ignore region options
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.7 – Applitools忽略区域选项
- en: Here, we can see the different options that Applitools provides. Even when different
    regions have different visual elements, it is possible to ignore such regions
    if they are not visual bugs or if they have been generated from dynamic content.
    After ignoring the region with visual differences, we proceeded to mark the screenshot
    as accepted.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到Applitools提供的不同选项。即使不同区域有不同的视觉元素，如果它们不是视觉错误，或者它们是从动态内容生成的，也可以忽略这些区域。在忽略具有视觉差异的区域后，我们继续将屏幕截图标记为已接受。
- en: Important note
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Remember to add your **APPLITOOLS_API_KEY** variable, which was obtained from
    the Applitools dashboard, to your local machine as an environment variable before
    running your tests. This token ensures that the snapshots taken by the Applitools
    Eyes SDK are successfully uploaded to your Applitools dashboard.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住在运行测试之前将**APPLITOOLS_API_KEY**变量添加到本地机器作为环境变量，该变量是从Applitools仪表板获取的。此令牌确保Applitools
    Eyes SDK拍摄的快照成功上传到Applitools仪表板。
- en: 'The following screenshot shows Cypress rerunning the test and now passing it
    locally. It''s doing this because we have instructed the Applitools Eyes SDK to
    accept the visual changes present compared to our baseline snapshot:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的屏幕截图显示了Cypress重新运行测试并在本地通过测试。这是因为我们已指示Applitools Eyes SDK接受与我们基准快照相比存在的视觉变化：
- en: '![Figure 12.8 – Passing the test after ignoring the test regions in the Applitools
    dashboard'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.8 – 在Applitools仪表板中忽略测试区域后通过测试'
- en: '](image/Figure_12.8_B15616.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_12.8_B15616.jpg)'
- en: Figure 12.8 – Passing the test after ignoring the test regions in the Applitools
    dashboard
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.8 – 在Applitools仪表板中忽略测试区域后通过测试
- en: Voila – our test passed! Any changes that are made to the Applitools test dashboard
    are reflected on the local test runs. This is made possible by the API key that
    you must add to your environment variables before running your Applitools visual
    tests. You can read more about Applitools Eyes ([https://applitools.com/tutorials/cypress.html](https://applitools.com/tutorials/cypress.html))
    to learn more about how to use Applitools to test user interfaces on the dynamic
    modern web.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 2
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we will test our knowledge of the Applitools Eyes SDK tool
    and how we can use it to perform visual testing. This exercise will help us practically
    implement the theoretical section of this chapter, and also find out how to use
    Cypress and Applitools to write visual tests. Perform the following steps:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: Using Applitools and Cypress, log into our test application and navigate to
    the dashboard. Then, using `Applitools Eyes SDK` snapshot command, take a snapshot
    of the public transactions page.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add another new transaction by clicking the new transactions button on the application
    and add the transaction details.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Take another snapshot and use Applitools to compare the transactions page differences
    from when the new transaction was created.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ignore the region in the Applitools dashboard where the new transactions are
    created and rerun the test with the ignore region.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The solutions to the preceding exercise can be found in the `chapter-12/cypress/integration/applitools/applitools-excercise.spec.js`
    directory.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: With that, I believe that you have learned how to use Applitools' automated
    visual testing and that this exercise has helped you harness your skills and knowledge
    of automated visual testing using Cypress. With that, we have come to the end
    of this book and by the power vested in me, I declare you a qualified "bug hunter!"
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Recap – automated visual testing tools
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we learned about two automated visual testing tools, Percy
    and Applitools, and how they can be integrated with Cypress tests. We then learned
    the differences between Percy and Applitools and how Percy, using the snapshot
    way of testing, is different from Applitools, which uses AI to analyze visual
    differences in tests. Finally, we learned where we can utilize testing by using
    tools such as Applitools. We did this by understanding how the content on browsers
    has changed with time and how more dynamic websites are demanding tools that can
    "adapt" to the dynamic content on the modern web.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we set out to understand how to do visual testing and its importance,
    as well as the viewports and tools we can use to carry out automated visual testing.
    Throughout this chapter, we've learned how to properly carry out visual testing.
    This involved understanding how to create viewports, how to test on different
    viewports, and also why we need automated visual tests to run on multiple viewports.
    We then explored two testing tools, Percy and the Applitools Eyes SDK, and extensively
    covered their use cases, their setup processes, and how to write Cypress tests
    using them. Finally, we worked on some exercises to improve our familiarity and
    interaction with these tools.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: With that, we have come to the end of this book. If you have been consistently
    reading all the chapters in this book, I am confident that you have more Cypress
    knowledge than you started out with. I hope that this book has challenged the
    way you think, made you develop a love for Cypress as a testing tool, and also
    changed you in terms of becoming a better tester or developer.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
