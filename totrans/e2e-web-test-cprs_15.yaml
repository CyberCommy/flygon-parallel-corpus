- en: '*Chapter 12*: Visual Testing in Cypress'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we get started with visual testing, you should have an idea of the other
    forms of testing and how we can use Cypress to accomplish this. The previous chapters
    of this book covered, at a basic to intermediate level, how to easily get started
    with Cypress, how to configure Cypress, and how you can optimize your use of Cypress
    to develop a more creative workflow for your test writing process. The background
    information in the previous chapters will provide you with the context required
    to tackle this chapter. Our focus in this last chapter of this book will be on
    visual testing using Cypress.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will cover the basics of visual testing and understand why
    we need it. We will also learn about some of the tools we can use to carry out
    visual testing. The topics in this chapter will help you, as an engineer or a
    tester, understand why visual testing is important for web applications and how
    we can leverage it to write better tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following key topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Visual testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding viewports
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visual testing tools in Cypress tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once you've worked through each of these topics, you will be ready to start
    your journey into the automation testing world with Cypress as your tool of choice.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get started, we recommend that you clone the GitHub repository for this book,
    which contains the source code and all the tests, exercises, and solutions that
    we will be writing in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The GitHub repository for this chapter can be found at [https://github.com/PacktPublishing/End-to-End-Web-Testing-with-Cypress](https://github.com/PacktPublishing/End-to-End-Web-Testing-with-Cypress).
  prefs: []
  type: TYPE_NORMAL
- en: The source code for this chapter can be found in the `chapter-12` directory.
  prefs: []
  type: TYPE_NORMAL
- en: Inside our GitHub repository, we have a finance test application that we will
    use for the different examples and exercises in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Important note: Running commands in Windows'
  prefs: []
  type: TYPE_NORMAL
- en: 'NB: The default Windows Command Prompt and PowerShell do not correctly resolve
    the directory locations.'
  prefs: []
  type: TYPE_NORMAL
- en: Kindly follow the Windows commands listed further that work exclusively on Windows
    operating systems suffixed with the word `*windows`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make sure the test application is running on your machine, run the following
    commands from the root folder directory of the repository on your machine''s terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: We have our tests in the `chapter-12` directory and the test application located
    in the root directory of the repository. To run our tests properly, we have to
    run both our application and the Cypress tests since the tests run on the live
    application, which has to run locally on our machines. It is important to note
    that the test application will require the use of port `3000` for the frontend
    application and port `3001` for the server application.
  prefs: []
  type: TYPE_NORMAL
- en: The first command will navigate us to the `cypress-realworld-app` directory,
    which is where our application is located. The `npm run cypress-init` command
    will install the dependencies that the application requires to run, while the
    `npm run cypress-app` command will start the application. Optionally, you can
    reset the application state using the `npm run cypress-app-reset` command. Resetting
    the application removes any data that was added that was not part of the application,
    thus taking the application's state back to when you cloned the repository.
  prefs: []
  type: TYPE_NORMAL
- en: Visual testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whether you are a web developer or a tester, there is a need to ensure that
    the application under development retains the look and feel that was intended
    at project conception. As a developer, you may want to verify that there are no
    visual aspects about your application that changed between releases. As a tester,
    you may want to validate that the application's user interface remains consistent
    between releases and is consistent with the design.
  prefs: []
  type: TYPE_NORMAL
- en: '**Functional testing** can be used to check for visual aspects, such as validating
    that a button or an input box is present. However, this may involve a lot of code
    being written and, most of the time, will not allow you to test every aspect of
    the application, such as CSS changes when we use it to validate user interface
    elements. Visual testing is the ability to verify visual aspects of an application''s
    user interface and ensure that they are consistent with the expectations.'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will learn what visual testing is, what the different types
    of visual testing are, the differences between manual and automated visual testing,
    and when to use different types of visual testing approaches.
  prefs: []
  type: TYPE_NORMAL
- en: Why visual testing?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Visual testing takes a practical approach as you must directly map the visual
    aspects of a page and compare those aspects to the expected designs. It is possible
    to dismiss the idea of visual testing because we think that our eyes are accurate
    enough for validation purposes, which is a flawed assumption. While the naked
    eye can notice visible page changes, it is a little bit more difficult for the
    eye to detect minute details, such as a change in the CSS properties that made
    an input element move by several pixels or minimal pixel changes.
  prefs: []
  type: TYPE_NORMAL
- en: Visual testing exists to give both developers and testers confidence that a
    web page's user interface was not broken by any developer changes that were made.
    For instance, with visual testing, there is no need to fear if a version of the
    application that was deployed to the production environment is missing a signup
    button while previous versions of the application had it.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two types of visual testing, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Manual visual testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automated visual testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These two types of visual testing will open our worlds up to how important visual
    testing is, as well as how we can take advantage of these two testing methods
    to write better tests.
  prefs: []
  type: TYPE_NORMAL
- en: Manual visual testing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Manual visual testing involves using the naked eye to validate whether the
    changes that were made by the development team did not break any visible user
    interface functionality. Manual visual testing involves either the testers or
    the development team visually testing the developed user interface and comparing
    it to the designs that were initially created. The process of visually testing
    the application confirms that there are no changes in the behavior, look, and
    feel of the user interface that were not intended. Manual visual testing is good
    and suitable for small changes in the user interface, but this may not be a very
    accurate way of validating an application with a lot of pages and visual elements
    or different viewports. To identify the limitations of manual visual testing,
    the following image, by *Atlantide Phototravel*, shows a side-by-side comparison
    of the Eiffel tower. They are very similar but minute details have been omitted
    in the second frame. Take a few seconds to compare the images and try to find
    the visual differences without looking at the rounded regions in the second image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.1 – Spotting the differences in the Eiffel Tower image'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_12.1_B15616.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.1 – Spotting the differences in the Eiffel Tower image
  prefs: []
  type: TYPE_NORMAL
- en: Even to the trained eye, there are details such as bird patterns, missing people,
    and even missing clouds that could make it almost visually impossible to tell
    if there is actually a difference between the two photographs. By applying the
    same idea of manual visual testing, it is very possible to miss details and not
    be able to find any differences between them, even when some elements are missing
    or have been added to the applications under test.
  prefs: []
  type: TYPE_NORMAL
- en: Automated visual testing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Automated visual testing involves testing the visual elements of the page. Instead
    of using a manual approach, an automated process to check the consistency of the
    application pages is used. To run automated visual tests properly, we must save
    and define our desired user interface as a **baseline**. We can then use this
    in our tests to check whether we need to update the baseline or modify the changes
    made to our application.
  prefs: []
  type: TYPE_NORMAL
- en: Automated visual testing has its roots in functional testing. Instead of asserting
    every element in a page and also checking the properties of the elements in a
    page, automated visual testing takes the approach of checking the entire page
    with a single assertion.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two types of automated visual testing:'
  prefs: []
  type: TYPE_NORMAL
- en: Snapshot testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visual AI testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's look at each of them in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Snapshot testing
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Snapshot testing is a type of automated visual testing where a raster graphic
    or a bitmap of a specific screen is recorded when the test is running. The recorded
    bitmap is then checked against the baseline bitmap that was recorded previously
    (baseline). The algorithms in the snapshot testing tools only check whether there
    are pixel differences in the bitmap by comparing **hex color codes**. If any color
    code differences are identified, then a snapshot bug is reported or an image showing
    visual differences is generated.
  prefs: []
  type: TYPE_NORMAL
- en: Snapshot testing is a significantly quicker way to identify bugs in user interfaces
    compared to manual testing. Snapshot testing is the preferred way of testing web
    applications if the application is somewhat static in nature and does not have
    a lot of dynamic content changes in the user interface. Snapshot testing does
    not handle dynamic content properly as the algorithm detects any change in content
    as a visual difference due to pixel changes. With all visual changes being identified
    as a visual difference or a potential bug, it would be impossible to have consistent
    snapshot images of pages that contain dynamic data.
  prefs: []
  type: TYPE_NORMAL
- en: Visual AI testing
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Visual AI testing is the new generation of automated visual testing and makes
    use of **AI** (**AI**). The main goal of visual AI testing is to improve on the
    shortcomings of snapshot testing, such as handling dynamic content when testing
    applications. By using computer vision, visual AI algorithms can identify images
    and areas where our tests can run and even in the event of dynamic content, they
    can identify the regions where our content is allowed to be dynamic and the regions
    that should remain unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: Visual AI testing also makes it easier for developers and testers to perform
    cross-browser testing. With cross-browser applications, the user can write a single
    test that can then be run in different **viewports** that are supported by the
    application. **Viewport testing** is a handy tool as it removes the burden of
    the developer – or the tester writing snapshot tests for every device – checking
    every viewport to verify that there are no visual changes.
  prefs: []
  type: TYPE_NORMAL
- en: Recap – visual testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we learned about what visual testing is, the different types
    of visual testing, and when to use each type of visual testing. We learned the
    difference between automated visual testing and manual visual testing, and we
    also learned about the different types of automated visual testing. We then learned
    why visual testing is a preferred approach to manual testing and why there is
    a new generation of visual testing that improves on the shortcomings that were
    present in the first-generation visual testing tools. Now that we know all about
    visual testing, in the next section, we will explore more areas that require visual
    testing by understanding what viewports are and how to test them.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding viewports
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A viewport is the visible area of a user's web page. Therefore, the term viewport
    is used to measure the rectangular viewing region on a user's device. When computers
    were first invented, there were only a few available viewports, though that has
    significantly increased due to more devices being created. At the time of writing,
    new viewports are being created by devices such as folding phones or flipping
    screens, and smart televisions with different dimensions, so it is up to developers
    to ensure that their applications are compatible with the user's devices. With
    different viewports, new challenges arise in terms of making applications compatible
    with such viewports, and this is even a greater nightmare for testers as it is
    practically not possible to test an application through every available viewport.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will explore the importance of viewports, how to approach
    testing in different viewports, and the role of viewports in visual testing.
  prefs: []
  type: TYPE_NORMAL
- en: Viewports and testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Viewports play a major role when it comes to testing web applications as they
    show how the actual users will view the web application that is under test. At
    the time of writing, mobile viewports are the most commonly used viewports. This
    is because phones have been evolving to become the most powerful pieces of technology
    that are both portable and handheld. To provide good experiences for users, viewport
    testing should be a top priority. With viewport testing, we can check for qualities
    such as how responsive the web application is to different screen sizes.
  prefs: []
  type: TYPE_NORMAL
- en: Developing responsive web applications provides an advantage over non-responsive
    web applications as they take less time and resources to develop compared to standalone
    mobile applications, which are either on iOS or Android and performing the same
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'All modern browsers allow us check and test for responsiveness when building
    applications. The following screenshot shows an iPhone 6 viewport rendered on
    a Chrome browser showing how the Cypress documentation page would appear on a
    mobile phone:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.2 – iPhone 6 mobile viewport'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_12.2_B15616.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.2 – iPhone 6 mobile viewport
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the **toggle device toolbar** on the browser to toggle between the
    normal web view and the mobile device view. This allows us to see how different
    web applications are rendered on different viewports. In instances where the web
    applications are responsive, there will be no issue testing the different viewports
    as the applications will automatically adapt to the changing viewports. However,
    this is not the case for non-responsive web applications. In the following screenshot,
    you can see the options for the current viewports, as well as the ability to add
    custom viewports that have not been defined by the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.3 – Browser viewport selection'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_12.3_B15616.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.3 – Browser viewport selection
  prefs: []
  type: TYPE_NORMAL
- en: As shown in the preceding screenshot, it is possible to add new test viewports
    that do not exist in the Chrome browser's list of devices.
  prefs: []
  type: TYPE_NORMAL
- en: When choosing a viewport, the Chrome web area automatically adjusts the content
    that's visible on the browser. As a developer or a tester, it is easy to find
    out whether changes are required for the application.
  prefs: []
  type: TYPE_NORMAL
- en: Viewports and automated visual testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Considering the number of viewports shown in the preceding screenshot, it is
    cumbersome to manually test every single viewport and verify that there were no
    changes that broke the user interface of the application, or any that introduced
    unnecessary changes that were not intended. To ensure that the viewports are tested,
    we can use automated visual testing to check for consistency in the application
    through different viewports. With visual testing, we can validate that no unintended
    changes were made to our application in the different viewports that we configure
    in our tests.
  prefs: []
  type: TYPE_NORMAL
- en: Recap – viewports
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Viewports are a critical aspect of visual testing, especially since most of
    the major issues regarding web applications responsiveness are a result of viewport
    bugs. In this section, we learned about different types of viewports and how we
    can check the responsiveness of our web applications using the browser's toggle
    option, which switches between different device viewports and the normal computer
    viewport. We also learned that by using automated visual testing, we can automate
    different test cases for different viewports and automatically know whether unintended
    changes were made to the application. In the next section, we will explore how
    we can use Cypress to write automated visual tests using an automated Visual AI
    tool and Percy, which utilizes snapshots to record visual tests.
  prefs: []
  type: TYPE_NORMAL
- en: Automated visual testing tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Visual testing is an important part of Cypress as it is a transition from what
    we are familiar with, which is functional testing. With visual testing, Cypress
    presents a new world of opportunities regarding how we can test user interfaces
    without necessarily writing hundreds of lines of functional code to assert individual
    elements on a page.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will dive into working with two automated visual testing
    tools by integrating them with Cypress, and then learn how we can achieve our
    goals of visually testing applications using them. One of these tools uses snapshots
    that record a **baseline bitmap** and compare the bitmap image pixels one after
    the other, checking for whether there are any discrepancies in the hex colors.
    The other tool uses AI algorithms to compare snapshots from our web application.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this section, we will have an idea of what tool to use, when and
    how Cypress plays a role in creating simple integrations of the testing tools,
    and the tests themselves. The two tools we will look at are Applitools Eyes SDK
    and Percy.
  prefs: []
  type: TYPE_NORMAL
- en: Percy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Percy is a visual testing and review platform that integrates with testing tools.
    This enables developers and QA engineers identify visual bugs that would otherwise
    have been difficult to identify and report. Percy makes visual testing a walk
    in the park – all you need to do is to download the Percy npm module, configure
    **BrowserStack**, and add Percy to your tests. Once you've done all the necessary
    configuration, you can copy the **TOKEN** that Percy provides, which will be used
    as an environment variable in your machine and is required if you wish to upload
    your test snapshots to the Browserstack cloud to review and identify visual differences,
    if any.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Browserstack is a visual testing and review tool, and it owns the **Percy**
    tool. To configure Percy, you need to configure Browserstack; all the configurations
    will be synced between the two platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Percy mainly relies on the Firefox and Chrome browsers. To test an application,
    Percy runs it through a set of browsers in various viewports, and any changes
    that have been made to the various viewports are recorded. When the first image
    is recorded and saved, Percy then makes the image in your test **baseline**, and
    will use the image to check for any changes in the subsequent test runs for similar
    images before highlighting any visual differences that may have occurred.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Percy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Setting up Percy is not complicated and involves the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an account with BrowserStack ([https://www.browserstack.com/](https://www.browserstack.com/)).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Verify your BrowserStack email address.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an organization in the Browserstack dashboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Log into the Percy dashboard using your BrowserStack account.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a project on the Percy dashboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure Percy on your local project using the instructions on the Percy website
    ([https://docs.percy.io/docs/cypress](https://docs.percy.io/docs/cypress)).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a Percy TOKEN to your local machine as an environment variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Voila! You are now ready to write your tests!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once *steps 1 - 4* have been completed, Percy provides you with a TOKEN that
    you must add to your machine environment variable before executing your tests.
    You can visit the Percy documentation ([https://docs.percy.io/docs/cypress](https://docs.percy.io/docs/cypress))
    for more information on how to set up Percy using Cypress.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once everything has been set up, we can run our first test, which will involve
    checking whether we can see visual differences on our login page when the content
    is changed. As shown in the following screenshot, we have run our test by entering
    a username and a password on the login page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.4 – Percy – new snapshot'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_12.4_B15616.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.4 – Percy – new snapshot
  prefs: []
  type: TYPE_NORMAL
- en: Here, we can see the snapshot image that was uploaded to the Percy dashboard.
    The uploaded snapshot is our login page. Immediately after uploading the snapshot,
    Percy gives us the option to toggle the Chrome and Firebox browsers so that we
    can check the consistency of the snapshots. On the main Percy dashboard, we have
    the option to approve all our snapshots, reject and accept a single snapshot,
    and even toggle between the desktop viewport and the mobile viewport presented
    to us.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Percy only uploads the snapshots to the dashboard when the test's execution
    is terminated and the terminal running the tests is closed. This is different
    from the Applitools tool, which continuously uploads the test snapshots immediately
    when the tests have finished execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we mentioned earlier, we can use Percy to compare bitmap images of our recorded
    baseline images and the newly generated bitmap images. The algorithm involved
    then checks for pixel by pixel differences, which are then recorded as visual
    differences when the baseline image is not similar to the newly generated image
    that was generated in the second run of our test application. The following screenshot
    shows a second build of our tests on the Percy dashboard. Here, we have omitted
    some of the characters in the username and password fields and we want to check
    whether Percy identifies these discrepancies:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.5 – Percy pixel differences'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_12.5_B15616.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.5 – Percy pixel differences
  prefs: []
  type: TYPE_NORMAL
- en: As shown in the preceding screenshot, once we ran our second build, we omitted
    some of the characters in both our username and password fields. When the snapshots
    are uploaded to Percy, the program identifies the visual differences by checking
    the pixels of the different images and provides us with the region where the pixel
    differences were identified. On our second run, when we *approve* these changes,
    Percy adopts our second image as the **baseline**. If we *Request changes* on
    the image, Percy will then retain our first image as the baseline for this particular
    snapshot.
  prefs: []
  type: TYPE_NORMAL
- en: Upon closer inspection, our first snapshot login username was *Kathe*, while
    in our second snapshot, the login username was *Kat*. The omission of some characters
    in the password and some characters in the username is what triggers Percy to
    show these visual differences. This gives us the option to either accept the changes
    and change our baseline or request changes from the developers if the change is
    not consistent with our expectations.
  prefs: []
  type: TYPE_NORMAL
- en: Reminder
  prefs: []
  type: TYPE_NORMAL
- en: For you to successfully run tests and upload the snapshots to the Percy dashboard,
    you need to create an account with BrowserStack, create an organization in BrowserStack,
    sign in with Browserstack on your Percy dashboard, create a project in Percy,
    and add the token provided on the Percy project dashboard to your machine's environment
    variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Percy is quick to set up, both locally on the machine and also on the tests.
    To invoke Percy, only a single line needs to be added to the test. The following
    code block shows the first and second snapshots being generated, as well as the
    arguments that are passed to the `cy.percySnapshot()` command for naming the snapshots:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The first test in the preceding code block was run in the first build, while
    the second test was run in the second build along with the modified username and
    password details to provide the pixel differences in our login page. To run these
    tests yourself, all you need to do is obtain the Percy token by following the
    Percy setup process mentioned previously and add your Percy project token as an
    environment variable of your machine. The complete source code for these tests
    can be obtained from this book's GitHub repository, in the `chapter-12` directory.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 1
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we are going to practice what we learned in the previous
    section: we will learn how to use Percy to perform visual testing and then interact
    with the Percy configuration and dashboard. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Using Percy and Cypress, log into our test application and navigate to the dashboard.
    Then, using the `Percy` command, take a snapshot of the public transactions page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new transaction by clicking the **New transactions** button on the application
    and add the transaction details.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Take another snapshot and use Percy to compare the transactions page's differences
    when another transaction is added.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Remember to add your Percy **TOKEN** variable, which can be obtained from the
    Percy project dashboard, to your local machine before running your tests so that
    the snapshots taken by Percy can be successfully uploaded to the Percy dashboard.
  prefs: []
  type: TYPE_NORMAL
- en: The solutions to this exercise can be found in `chapter-12/cypress/integration/percy/percy-excercise.spec.js`
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: By going through this exercise and being able to properly set up Percy in Cypress,
    I believe you now understand how you can use Percy to identify visual differences
    in your tests, as well as quickly identify discrepancies when your application's
    user interfaces change. You can do this by doing a pixel-by-pixel comparison of
    the bitmap images of our application.
  prefs: []
  type: TYPE_NORMAL
- en: Applitools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Applitools is a tool that utilizes AI to visually test and monitor applications.
    Just like Percy, Applitools is easy to set up using Cypress and focuses on improving
    the shortcomings of tools such as Percy. Percy identifies visual differences by
    comparing individual pixels, while Applitools identifies visual differences by
    using its AI powered algorithms to check whether the changes are expected changes
    or bugs. With Applitools, it is easier to test dynamic changes as we can omit
    areas where we do not want Applitools to check for visual differences.
  prefs: []
  type: TYPE_NORMAL
- en: The ability to identify bugs by specifying regions that should be checked, and
    others that should be ignored, is what makes Applitools a better tool when it
    comes to testing applications that involve dynamic content.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Applitools
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Just like Percy, the Applitools Eyes SDK is relatively easy to set up with
    Cypress. This can be achieved by performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an account with Applitools ([https://auth.applitools.com/users/register](https://auth.applitools.com/users/register)).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Verify your Applitools email address.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the Applitools dashboard to obtain the API key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure Applitools on your local project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the Applitools **APPLITOOLS_API_KEY** to your local machine as an environment
    variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Party!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once *steps 1* and *2* have been completed, Applitools provides you with an
    **APPLITOOLS_API_KEY**, similar to the Percy **TOKEN**, that you must add as an
    environment variable to your machine before executing your tests. You can visit
    the Applitools and Cypress documentation ([https://applitools.com/tutorials/cypress.html](https://applitools.com/tutorials/cypress.html))
    to find out more about how to set up the Applitools Eyes SDK using Cypress.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once everything has been set up, we can now run our first test using Cypress
    and the Applitools Eyes SDK. Applitools is a very rich tool, so we will not be
    able to cover all the features that it comes bundled with. Instead, we will focus
    on the advantages of Applitools in terms of using it as a visual testing tool.
    In the following screenshot, we have the same login test that we ran in our Percy
    example but modified for Applitools Eyes tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.6 – Applitools login page snapshot'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_12.6_B15616.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.6 – Applitools login page snapshot
  prefs: []
  type: TYPE_NORMAL
- en: Here, we can see the snapshot representing the first login page snapshot that
    the Applitools Eyes SDK took and uploaded to the Applitools dashboard. Applitools
    uses three commands to control Cypress tests. The first command, `cy.eyesOpen()`,
    is for initializing and starting the test, the second command, `cy.eyesCheckWindow()`,
    is responsible for taking screenshots, as in the previous case, and the third
    command, `eyesClose()`, completes the Applitools Eyes session and uploads the
    screenshots to the dashboard.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our login test can be written in the following format. This opens the Applitools
    Eyes SDK, takes a screenshot, and closes the SDK before uploading the screenshots
    to the Applitools dashboard so that they can be compared visually by the Applitools
    AI algorithms. The following code block shows the second build provided in the
    preceding screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can observe that to run the tests, we need to initialize the Applitools
    Eyes SDK, then take the screenshot before closing our tests. All three methods
    that the Eyes SDK utilizes can have configuration parameters that can be changed,
    depending on your needs. In our code block, for example, we have configured the
    `cy.eyesOpen()` command so that we have our test batch name and the configuration
    of the browser window visible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Applitools goes a step further when it comes to reporting errors. In Percy,
    we identified that due to its pixel-by-pixel comparisons, any change in the user
    interface is detected as a visual difference and potentially a user interface
    bug. In the following screenshot, we can see how, after running a similar test
    with different user interface renderings, we can tell Applitools to ignore certain
    regions in our screens and mark our test as passed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.7 – Applitools ignore region options'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_12.7_B15616.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.7 – Applitools ignore region options
  prefs: []
  type: TYPE_NORMAL
- en: Here, we can see the different options that Applitools provides. Even when different
    regions have different visual elements, it is possible to ignore such regions
    if they are not visual bugs or if they have been generated from dynamic content.
    After ignoring the region with visual differences, we proceeded to mark the screenshot
    as accepted.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Remember to add your **APPLITOOLS_API_KEY** variable, which was obtained from
    the Applitools dashboard, to your local machine as an environment variable before
    running your tests. This token ensures that the snapshots taken by the Applitools
    Eyes SDK are successfully uploaded to your Applitools dashboard.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows Cypress rerunning the test and now passing it
    locally. It''s doing this because we have instructed the Applitools Eyes SDK to
    accept the visual changes present compared to our baseline snapshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.8 – Passing the test after ignoring the test regions in the Applitools
    dashboard'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_12.8_B15616.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.8 – Passing the test after ignoring the test regions in the Applitools
    dashboard
  prefs: []
  type: TYPE_NORMAL
- en: Voila – our test passed! Any changes that are made to the Applitools test dashboard
    are reflected on the local test runs. This is made possible by the API key that
    you must add to your environment variables before running your Applitools visual
    tests. You can read more about Applitools Eyes ([https://applitools.com/tutorials/cypress.html](https://applitools.com/tutorials/cypress.html))
    to learn more about how to use Applitools to test user interfaces on the dynamic
    modern web.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 2
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we will test our knowledge of the Applitools Eyes SDK tool
    and how we can use it to perform visual testing. This exercise will help us practically
    implement the theoretical section of this chapter, and also find out how to use
    Cypress and Applitools to write visual tests. Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Using Applitools and Cypress, log into our test application and navigate to
    the dashboard. Then, using `Applitools Eyes SDK` snapshot command, take a snapshot
    of the public transactions page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add another new transaction by clicking the new transactions button on the application
    and add the transaction details.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Take another snapshot and use Applitools to compare the transactions page differences
    from when the new transaction was created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ignore the region in the Applitools dashboard where the new transactions are
    created and rerun the test with the ignore region.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The solutions to the preceding exercise can be found in the `chapter-12/cypress/integration/applitools/applitools-excercise.spec.js`
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: With that, I believe that you have learned how to use Applitools' automated
    visual testing and that this exercise has helped you harness your skills and knowledge
    of automated visual testing using Cypress. With that, we have come to the end
    of this book and by the power vested in me, I declare you a qualified "bug hunter!"
  prefs: []
  type: TYPE_NORMAL
- en: Recap – automated visual testing tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we learned about two automated visual testing tools, Percy
    and Applitools, and how they can be integrated with Cypress tests. We then learned
    the differences between Percy and Applitools and how Percy, using the snapshot
    way of testing, is different from Applitools, which uses AI to analyze visual
    differences in tests. Finally, we learned where we can utilize testing by using
    tools such as Applitools. We did this by understanding how the content on browsers
    has changed with time and how more dynamic websites are demanding tools that can
    "adapt" to the dynamic content on the modern web.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we set out to understand how to do visual testing and its importance,
    as well as the viewports and tools we can use to carry out automated visual testing.
    Throughout this chapter, we've learned how to properly carry out visual testing.
    This involved understanding how to create viewports, how to test on different
    viewports, and also why we need automated visual tests to run on multiple viewports.
    We then explored two testing tools, Percy and the Applitools Eyes SDK, and extensively
    covered their use cases, their setup processes, and how to write Cypress tests
    using them. Finally, we worked on some exercises to improve our familiarity and
    interaction with these tools.
  prefs: []
  type: TYPE_NORMAL
- en: With that, we have come to the end of this book. If you have been consistently
    reading all the chapters in this book, I am confident that you have more Cypress
    knowledge than you started out with. I hope that this book has challenged the
    way you think, made you develop a love for Cypress as a testing tool, and also
    changed you in terms of becoming a better tester or developer.
  prefs: []
  type: TYPE_NORMAL
