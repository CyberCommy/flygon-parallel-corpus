- en: Chapter 2. Adding Authentication
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The chat application we built in the previous chapter focused on high-performance
    transmission of messages from the clients to the server and back again, but our
    users have no way of knowing who they are talking to. One solution to this problem
    is building of some kind of signup and login functionality and letting our users
    create accounts and authenticate themselves before they can open the chat page.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Whenever we are about to build something from scratch, we must ask ourselves
    how others have solved this problem before (it is extremely rare to encounter
    genuinely original problems), and whether any open solutions or standards already
    exist that we can make use of. Authorization and authentication are hardly new
    problems, especially in the world of the Web, with many different protocols out
    there to choose from. So how do we decide on the best option to pursue? As always,
    we must look at this question from the point of view of the user.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: A lot of websites these days allow you to sign in using your accounts existing
    elsewhere on a variety of social media or community websites. This saves users
    the tedious job of entering all their account information over and over again
    as they decide to try out different products and services. It also has a positive
    effect on the conversion rates for new sites.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will enhance our chat codebase to add authentication, which
    will allow our users to sign in using Google, Facebook, or GitHub and you'll see
    how easy it is to add other sign-in portals too. In order to join the chat, users
    must first sign in. Following this, we will use the authorized data to augment
    our user experience so everyone knows who is in the room, and who said what.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn to:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: Use the decorator pattern to wrap `http.Handler` types to add additional functionality
    to handlers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serve HTTP endpoints with dynamic paths
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the Gomniauth open source project to access authentication services
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get and set cookies using the `http` package
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encode objects as Base64 and back to normal again
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Send and receive JSON data over a web socket
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Give different types of data to templates
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Work with channels of your own types
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handlers all the way down
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For our chat application, we implemented our own `http.Handler` type in order
    to easily compile, execute, and deliver HTML content to browsers. Since this is
    a very simple but powerful interface, we are going to continue to use it wherever
    possible when adding functionality to our HTTP processing.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: In order to determine whether a user is authenticated, we will create an authentication
    wrapper handler that performs the check, and passes execution on to the inner
    handler only if the user is authenticated.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Our wrapper handler will satisfy the same `http.Handler` interface as the object
    inside it, allowing us to wrap any valid handler. In fact, even the authentication
    handler we are about to write could be later encapsulated inside a similar wrapper
    if needed.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '![Handlers all the way down](img/Image00002.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
- en: Diagram of a chaining pattern when applied to HTTP handlers
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: The preceding figure shows how this pattern could be applied in a more complicated
    HTTP handler scenario. Each object implements the `http.Handler` interface, which
    means that object could be passed into the `http.Handle` method to directly handle
    a request, or it can be given to another object, which adds some kind of extra
    functionality. The `Logging` handler might write to a logfile before and after
    the `ServeHTTP` method is called on the inner handler. Because the inner handler
    is just another `http.Handler` , any other handler can be wrapped in (or decorated
    with) the `Logging` handler.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: It is also common for an object to contain logic that decides which inner handler
    should be executed. For example, our authentication handler will either pass the
    execution to the wrapped handler, or handle the request itself by issuing a redirect
    to the browser.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s plenty of theory for now; let''s write some code. Create a new file
    called `auth.go` in the `chat` folder:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在理论已经足够了；让我们写一些代码。在`chat`文件夹中创建一个名为`auth.go`的新文件：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `authHandler` type not only implements the `ServeHTTP` method (which satisfies
    the `http.Handler` interface) but also stores (wraps) `http.Handler` in the next
    field. Our `MustAuth` helper function simply creates `authHandler` that wraps
    any other `http.Handler` . Let''s tweak the following root mapping line:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`authHandler`类型不仅实现了`ServeHTTP`方法（满足`http.Handler`接口），还在`next`字段中存储（包装）`http.Handler`。我们的`MustAuth`辅助函数只是创建包装任何其他`http.Handler`的`authHandler`。让我们调整以下根映射行：'
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let''s change the first argument to make it explicit about the page meant for
    chatting. Next, let''s use the `MustAuth` function to wrap `templateHandler` for
    the second argument:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更改第一个参数，以明确指定用于聊天的页面。接下来，让我们使用`MustAuth`函数包装`templateHandler`作为第二个参数：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Wrapping `templateHandler` with the `MustAuth` function will cause execution
    to run first through our `authHandler` , and only to `templateHandler` if the
    request is authenticated.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`MustAuth`函数包装`templateHandler`将导致执行首先通过我们的`authHandler`，仅在请求经过身份验证时才到达`templateHandler`。
- en: The `ServeHTTP` method in our `authHandler` will look for a special cookie called
    `auth` , and use the `Header` and `WriteHeader` methods on `http.ResponseWriter`
    to redirect the user to a login page if the cookie is missing.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`authHandler`中的`ServeHTTP`方法将寻找一个名为`auth`的特殊cookie，并使用`http.ResponseWriter`上的`Header`和`WriteHeader`方法来重定向用户到登录页面，如果缺少cookie。
- en: 'Build and run the chat application and try to hit `http://localhost:8080/chat`
    :'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 构建并运行聊天应用程序，并尝试访问`http://localhost:8080/chat`：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Tip
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You need to delete your cookies to clear out previous auth tokens, or any other
    cookies that might be left over from other development projects served through
    localhost.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要删除您的cookie以清除先前的auth令牌，或者从通过localhost提供的其他开发项目中留下的任何其他cookie。
- en: If you look in the address bar of your browser, you will notice that you are
    immediately redirected to the `/login` page. Since we cannot handle that path
    yet, you'll just get a **404 page not found** error.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看浏览器的地址栏，您会注意到您立即被重定向到“/login”页面。由于我们目前无法处理该路径，您将收到一个**404页面未找到**错误。
- en: Making a pretty social sign-in page
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个漂亮的社交登录页面
- en: So far we haven't paid much attention to making our application look nice, after
    all this book is about Go and not user-interface development. However, there is
    no excuse for building ugly apps, and so we will build a social sign-in page that
    is as pretty as it is functional.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们并没有太关注使我们的应用程序看起来漂亮，毕竟这本书是关于Go而不是用户界面开发。但是，构建丑陋的应用程序是没有借口的，因此我们将构建一个既漂亮又实用的社交登录页面。
- en: Bootstrap is a frontend framework used to develop responsive projects on the
    Web. It provides CSS and JavaScript code that solve many user-interface problems
    in a consistent and good-looking way. While sites built using Bootstrap all tend
    to look the same (although there are plenty of ways in which the UI can be customized),
    it is a great choice for early versions of apps, or for developers who don't have
    access to designers.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Bootstrap是用于在Web上开发响应式项目的前端框架。它提供了解决许多用户界面问题的CSS和JavaScript代码，以一致和美观的方式。虽然使用Bootstrap构建的网站往往看起来都一样（尽管UI可以定制的方式有很多），但它是早期应用程序的绝佳选择，或者对于没有设计师访问权限的开发人员。
- en: Tip
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you build your application using the semantic standards set forth by Bootstrap,
    it becomes easy for you to make a Bootstrap theme for your site or application
    and you know it will slot right into your code.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用Bootstrap制定的语义标准构建应用程序，那么为您的站点或应用程序制作Bootstrap主题将变得很容易，并且您知道它将完全适合您的代码。
- en: We will use the version of Bootstrap hosted on a CDN so we don't have to worry
    about downloading and serving our own version through our chat application. This
    means that in order to render our pages properly, we will need an active Internet
    connection, even during development.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用托管在CDN上的Bootstrap版本，因此我们不必担心通过我们的聊天应用程序下载和提供自己的版本。这意味着为了正确呈现我们的页面，我们需要保持活动的互联网连接，即使在开发过程中也是如此。
- en: Note
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you prefer to download and host your own copy of Bootstrap, you can do so.
    Keep the files in an `assets` folder and add the following call to your `main`
    function (it uses `http.Handle` to serve the assets via your application):'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您喜欢下载和托管自己的Bootstrap副本，可以这样做。将文件保存在`assets`文件夹中，并将以下调用添加到您的`main`函数中（它使用`http.Handle`通过您的应用程序提供资产）：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Notice how the `http.StripPrefix` and `http.FileServer` functions return objects
    that satisfy the `http.Handler` interface as per the decorator pattern that we
    implement with our `MustAuth` helper function.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`http.StripPrefix`和`http.FileServer`函数返回满足`http.Handler`接口的对象，这是我们使用`MustAuth`辅助函数实现的装饰器模式。
- en: 'In `main.go` , let''s add an endpoint for the login page:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main.go`中，让我们为登录页面添加一个端点：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Obviously, we do not want to use the `MustAuth` method for our login page because
    it will cause an infinite redirection loop.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们不希望在我们的登录页面使用`MustAuth`方法，因为它会导致无限重定向循环。
- en: 'Create a new file called `login.html` inside our `templates` folder, and insert
    the following HTML code:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`templates`文件夹中创建一个名为`login.html`的新文件，并插入以下HTML代码：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Restart the web server and navigate to `http://localhost:8080/login` . You
    will notice that it now displays our sign-in page:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 重新启动Web服务器并导航到`http://localhost:8080/login`。您会注意到它现在显示我们的登录页面：
- en: '![Making a pretty social sign-in page](img/Image00003.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![创建漂亮的社交登录页面](img/Image00003.jpg)'
- en: Endpoints with dynamic paths
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 具有动态路径的端点
- en: 'Pattern matching for the `http` package in the Go standard library isn''t the
    most comprehensive and fully featured implementation out there. For example, Ruby
    on Rails makes it much easier to have dynamic segments inside the path:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Go标准库中的`http`包的模式匹配并不是最全面和功能齐全的实现。例如，Ruby on Rails更容易在路径内部具有动态段。
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This then provides a data map (or dictionary) containing the values that the
    framework automatically extracted from the matched path. So if you visit `auth/login/google`
    , then `params[:provider_name]` would equal `google` , and `params[:action]` would
    equal `login` .
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: 'The most the `http` package lets us specify by default is a path prefix, which
    we can do by leaving a trailing slash at the end of the pattern:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We would then have to manually parse the remaining segments to extract the
    appropriate data. This is acceptable for relatively simple cases, which suits
    our needs for the time being since we only need to handle a few different paths
    such as:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '`/auth/login/google`'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/auth/login/facebook`'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/auth/callback/google`'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/auth/callback/facebook`'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you need to handle more advanced routing situations, you might want to consider
    using dedicated packages such as Goweb, Pat, Routes, or mux. For extremely simple
    cases such as ours, the built-in capabilities will do.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to create a new handler that powers our login process. In `auth.go`
    , add the following `loginHandler` code:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the preceding code, we break the path into segments using `strings.Split`
    before pulling out the values for `action` and `provider` . If the action value
    is known, we will run the specific code; otherwise, we will write out an error
    message and return an `http.StatusNotFound` status code (which in the language
    of HTTP status code, is a `404` code).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will not bullet-proof our code right now but it's worth noticing that if
    someone hits `loginHandler` with too few segments, our code will panic because
    it expects `segs[2]` and `segs[3]` to exist.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: For extra credit, see whether you can protect against this and return a nice
    error message instead of a panic if someone hits `/auth/nonsense` .
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `loginHandler` is only a function and not an object that implements the
    `http.Handler` interface. This is because, unlike other handlers, we don''t need
    it to store any state. The Go standard library supports this, so we can use the
    `http.HandleFunc` function to map it in a way similar to how we used `http.Handle`
    earlier. In `main.go` , update the handlers:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Rebuild and run the chat application:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Hit the following URLs and notice the output logged in the terminal:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '`http://localhost:8080/auth/login/google` outputs `TODO handle login for google`'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`http://localhost:8080/auth/login/facebook` outputs `TODO handle login for
    facebook`'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have successfully implemented a dynamic path-matching mechanism that so far
    just prints out to-do messages; next we need to write code that integrates with
    the authentication services.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: 读累了记得休息一会哦~
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**公众号：古德猫宁李**'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: 电子书搜索下载
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 书单分享
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 书友学习交流
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**网站：**[沉金书屋 https://www.chenjin5.com](https://www.chenjin5.com)'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: 电子书搜索下载
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 电子书打包资源分享
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 学习资源分享
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OAuth2
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OAuth2 is an open authentication and authorization standard designed to allow
    resource owners to give clients delegated access to private data (such as wall
    posts or tweets) via an access token exchange handshake. Even if you do not wish
    to access the private data, OAuth2 is a great option that allows people to sign
    in using their existing credentials, without exposing those credentials to a third-party
    site. In this case, we are the third party and we want to allow our users to sign
    in using services that support OAuth2.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: 'From a user''s point of view, the OAuth2 flow is:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: A user selects provider with whom they wish to sign in to the client app.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The user is redirected to the provider's website (with a URL that includes the
    client app ID) where they are asked to give permission to the client app.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The user signs in from the OAuth2 service provider and accepts the permissions
    requested by the third-party application.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The user is redirected back to the client app with a request code.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the background, the client app sends the grant code to the provider, who
    sends back an auth token.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The client app uses the access token to make authorized requests to the provider,
    such as to get user information or wall posts.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To avoid reinventing the wheel, we will look at a few open source projects that
    have already solved this problem for us.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免重复造轮子，我们将看一些已经为我们解决了这个问题的开源项目。
- en: Open source OAuth2 packages
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开源OAuth2包
- en: Andrew Gerrand has been working on the core Go team since February 2010, that
    is two years before Go 1.0 was officially released. His `goauth2` package (see
    [https://code.google.com/p/goauth2/](https://code.google.com/p/goauth2/) ) is
    an elegant implementation of the OAuth2 protocol written entirely in Go.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Andrew Gerrand自2010年2月以来一直在核心Go团队工作，即在Go 1.0正式发布两年前。他的`goauth2`包（请参阅[https://code.google.com/p/goauth2/](https://code.google.com/p/goauth2/)）是OAuth2协议的优雅实现，完全使用Go编写。
- en: Andrew's project inspired Gomniauth (see [https://github.com/stretchr/gomniauth](https://github.com/stretchr/gomniauth)
    ). An open source Go alternative to Ruby's `omniauth` project, Gomniauth provides
    a unified solution to access different OAuth2 services. In the future, when OAuth3
    (or whatever next-generation authentication protocol it is) comes out, in theory,
    Gomniauth could take on the pain of implementing the details, leaving the user
    code untouched.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Andrew的项目启发了Gomniauth（请参阅[https://github.com/stretchr/gomniauth](https://github.com/stretchr/gomniauth)）。作为Ruby的`omniauth`项目的开源Go替代品，Gomniauth提供了一个统一的解决方案来访问不同的OAuth2服务。在未来，当OAuth3（或者下一代认证协议）推出时，理论上，Gomniauth可以承担实现细节的痛苦，使用户代码不受影响。
- en: 'For our application, we will use Gomniauth to access OAuth services provided
    by Google, Facebook, and GitHub, so make sure you have it installed by running
    the following command:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的应用程序，我们将使用Gomniauth来访问Google、Facebook和GitHub提供的OAuth服务，因此请确保您已通过运行以下命令进行安装：
- en: '[PRE12]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Tip
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Some of the project dependencies of Gomniauth are kept in Bazaar repositories,
    so you'll need to head over to [http://wiki.bazaar.canonical.com](http://wiki.bazaar.canonical.com)
    to download them.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Gomniauth的一些项目依赖项存储在Bazaar存储库中，因此您需要前往[http://wiki.bazaar.canonical.com](http://wiki.bazaar.canonical.com)下载它们。
- en: Tell the authentication providers about your app
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 告诉身份验证提供程序有关您的应用
- en: 'Before we ask an authentication provider to help our users sign in, we must
    tell them about our application. Most providers have some kind of web tool or
    console where you can create applications to kick-start the process. Here''s one
    from Google:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们要求身份验证提供程序帮助我们的用户登录之前，我们必须告诉他们有关我们的应用程序。大多数提供程序都有一种网络工具或控制台，您可以在其中创建应用程序以启动该过程。以下是Google的一个示例：
- en: '![Tell the authentication providers about your app](img/Image00004.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![告诉身份验证提供程序有关您的应用](img/Image00004.jpg)'
- en: In order to identify the client application, we need to create a client ID and
    secret. Despite the fact that OAuth2 is an open standard, each provider has their
    own language and mechanism to set things up, so you will most likely have to play
    around with the user interface or the documentation to figure it out in each case.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为了识别客户端应用程序，我们需要创建客户端ID和密钥。尽管OAuth2是一个开放标准，但每个提供程序都有自己的语言和机制来设置事物，因此您很可能需要在每种情况下通过用户界面或文档进行尝试来弄清楚。
- en: At the time of writing this, in **Google Developer Console** , you navigate
    to **APIs & auth** | **Credentials** and click on the **Create new Client ID**
    button.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，在**Google开发者控制台**中，您可以导航到**API和身份验证** | **凭据**，然后单击**创建新的客户端ID**按钮。
- en: In most cases, for added security, you have to be explicit about the host URLs
    from where requests will come. For now, since we're hosting our app locally on
    `localhost:8080` , you should use that. You will also be asked for a redirect
    URI that is the endpoint in our chat application and to which the user will be
    redirected after successfully signing in. The callback will be another action
    on our `loginHandler` , so the redirection URL for the Google client will be `http://localhost:8080/auth/callback/google`
    .
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，为了增加安全性，您必须明确指定请求将来自哪些主机URL。目前，因为我们将在`localhost:8080`上本地托管我们的应用程序，所以您应该使用该URL。您还将被要求提供一个重定向URI，该URI是我们聊天应用程序中的端点，并且用户在成功登录后将被重定向到该端点。回调将是我们`loginHandler`上的另一个操作，因此Google客户端的重定向URL将是`http://localhost:8080/auth/callback/google`。
- en: Once you finish the authentication process for the providers you want to support,
    you will be given a client ID and secret for each provider. Make a note of these,
    because we will need them when we set up the providers in our chat application.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 完成要支持的提供程序的身份验证过程后，您将为每个提供程序获得客户端ID和密钥。记下这些信息，因为在设置我们的聊天应用程序中的提供程序时，我们将需要它们。
- en: Note
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If we host our application on a real domain, we have to create new client IDs
    and secrets, or update the appropriate URL fields on our authentication providers
    to ensure that they point to the right place. Either way, it's not bad practice
    to have a different set of development and production keys for security.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将我们的应用程序托管在真实域上，我们必须创建新的客户端ID和密钥，或者更新我们的身份验证提供程序的适当URL字段，以确保它们指向正确的位置。无论哪种方式，为了安全起见，为开发和生产的密钥设置不同的密钥并不是坏习惯。
- en: Implementing external logging in
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现外部登录
- en: 'In order to make use of the projects, clients, or accounts that we created
    on the authentication provider sites, we have to tell Gomniauth which providers
    we want to use, and how we will interact with them. We do this by calling the
    `WithProviders` function on the primary Gomniauth package. Add the following code
    snippet to `main.go` (just underneath the `flag.Parse()` line towards the top
    of the `main` function):'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用我们在身份验证提供程序网站上创建的项目、客户端或帐户，我们必须告诉Gomniauth我们想要使用哪些提供程序，以及我们将如何与它们交互。我们通过在主要的Gomniauth包上调用`WithProviders`函数来实现这一点。将以下代码片段添加到`main.go`（就在`main`函数顶部的`flag.Parse()`行下面）：
- en: '[PRE13]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You should replace the `key` and `secret` placeholders with the actual values
    you noted down earlier. The third argument represents the callback URL that should
    match the ones you provided when creating your clients on the provider's website.
    Notice the second path segment is `callback` ; while we haven't implemented this
    yet, this is where we handle the response from the authentication process.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: 'As usual, you will need to ensure all the appropriate packages are imported:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Gomniauth requires the `SetSecurityKey` call because it sends state data between
    the client and server along with a signature checksum, which ensures that the
    state values haven't been tempered with while transmitting. The security key is
    used when creating the hash in a way that it is almost impossible to recreate
    the same hash without knowing the exact security key. You should replace `some
    long key` with a security hash or phrase of your choice.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: Logging in
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have configured Gomniauth, we need to redirect users to the provider''s
    authentication page when they land on our `/auth/login/{provider}` path. We just
    have to update our `loginHandler` function in `auth.go` :'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We do two main things here. First, we use the `gomniauth.Provider` function
    to get the provider object that matches the object specified in the URL (such
    as `google` or `github` ). Then we use the `GetBeginAuthURL` method to get the
    location where we must send users in order to start the authentication process.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `GetBeginAuthURL(nil, nil)` arguments are for the state and options respectively,
    which we are not going to use for our chat application.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: The first argument is a state map of data that is encoded, and signed and sent
    to the authentication provider. The provider doesn't do anything with the state,
    it just sends it back to our callback endpoint. This is useful if, for example,
    we want to redirect the user back to the original page they were trying to access
    before the authentication process intervened. For our purpose, we have only the
    `/chat` endpoint, so we don't need to worry about sending any state.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: The second argument is a map of additional options that will be sent to the
    authentication provider, which somehow modifies the behavior of the authentication
    process. For example, you can specify your own `scope` parameter, which allows
    you to make a request for permission to access additional information from the
    provider. For more information about the available options, search for OAuth2
    on the Internet or read the documentation for each provider, as these values differ
    from service to service.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: If our code gets no error from the `GetBeginAuthURL` call, we simply redirect
    the user's browser to the returned URL.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: 'Rebuild and run the chat application:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Open the main chat page by accessing `http://localhost:8080/chat` . As we aren''t
    logged in yet, we are redirected to our sign-in page. Click on the Google option
    to sign in using your Google account, and you will notice that you are presented
    with a Google-specific sign-in page (if you are not already signed in to Google).
    Once you are signed in, you will be presented with a page asking you to give permission
    for our chat application before you can view basic information about your account:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '![Logging in](img/Image00005.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
- en: This is the same flow that users of our chat application will experience when
    signing in.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Click on **Accept** and you will notice that you are redirected back to our
    application code, but presented with an `Auth action callback not supported` error.
    This is because we haven't yet implemented the callback functionality in `loginHandler`
    .
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Handling the response from the provider
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once the user clicks on **Accept** on the provider's website (or if they click
    on the equivalent of **Cancel** ), they will be redirected back to the callback
    endpoint in our application.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: A quick glance at the complete URL that comes back shows us the grant code that
    the provider has given us.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We don't have to worry about what to do with this code because Gomniauth will
    process the OAuth URL parameters for us (by sending the grant code to Google servers
    and exchanging it for an access token as per the OAuth specification), so we can
    simply jump to implementing our callback handler. However, it's worth knowing
    that this code will be exchanged by the authentication provider for a token that
    allows us to access private user data. For added security, this additional step
    happens behind the scenes, from server to server rather than in the browser.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不必担心该代码该怎么处理，因为Gomniauth将为我们处理OAuth URL参数（通过将授权代码发送到Google服务器并根据OAuth规范将其交换为访问令牌），因此我们可以直接跳转到实现我们的回调处理程序。然而，值得知道的是，这段代码将被身份验证提供程序交换为一个允许我们访问私人用户数据的令牌。为了增加安全性，这个额外的步骤是在后台从服务器到服务器进行的，而不是在浏览器中进行的。
- en: 'In `auth.go` , we are ready to add another switch case to our action path segment.
    Insert the following code above the default case:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在`auth.go`中，我们准备向我们的动作路径段添加另一个switch case。在默认情况之前插入以下代码：
- en: '[PRE18]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: When the authentication provider redirects the users back after they have granted
    permission, the URL specifies that it is a callback action. We look up the authentication
    provider as we did before, and call its `CompleteAuth` method. We parse the `RawQuery`
    from the `http.Request` (the `GET` request that the user's browser is now making)
    into `objx.Map` (the multi-purpose map type that Gomniauth uses) and the `CompleteAuth`
    method uses the URL query parameter values to complete the authentication handshake
    with the provider. All being well, we will be given some authorized credentials
    with which we access our user's basic data. We then use the `GetUser` method for
    the provider and Gomniauth uses the specified credentials to access some basic
    information about the user.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当身份验证提供程序在用户授予权限后将用户重定向回来时，URL指定它是一个回调动作。我们像之前一样查找身份验证提供程序，并调用它的`CompleteAuth`方法。我们将`http.Request`（用户浏览器现在正在进行的`GET`请求）中的`RawQuery`解析为`objx.Map`（Gomniauth使用的多用途映射类型），`CompleteAuth`方法使用URL查询参数值来完成与提供程序的身份验证握手。一切顺利的话，我们将获得一些授权凭据，用于访问用户的基本数据。然后我们使用提供程序的`GetUser`方法，Gomniauth使用指定的凭据访问用户的一些基本信息。
- en: Once we have the user data, we Base64-encode the `Name` field in a JSON object
    and store it as the value to our `auth` cookie for later use.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了用户数据，我们将`Name`字段在JSON对象中进行Base64编码，并将其存储为我们的`auth` cookie的值，以便以后使用。
- en: Tip
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Base64-encoding of data ensures it won't contain any special or unpredictable
    characters, like passing data in a URL or storing it in a cookie. Remember that
    although Base64-encoded data looks encrypted, it is not—you can easily decode
    Base64-encoded data back into the original text with little effort. There are
    online tools that do this for you.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 数据的Base64编码确保它不会包含任何特殊或不可预测的字符，就像在URL中传递数据或将其存储在cookie中一样。请记住，尽管Base64编码的数据看起来像是加密的，但实际上并不是——您可以很容易地将Base64编码的数据解码回原始文本，而不费吹灰之力。有在线工具可以为您完成这项工作。
- en: After setting the cookie, we redirect the user to the chat page, which we can
    safely assume was the original destination.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 设置完cookie后，我们将用户重定向到聊天页面，可以安全地假设这是最初的目的地。
- en: 'Once you build and run the code again and hit the `/chat` page, you will notice
    that the signup flow works, and we are finally allowed back to the chat page.
    Most browsers have an inspector or a console—a tool that allows you to view the
    cookies that the server has sent you—that you can use to see whether the `auth`
    cookie has appeared:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 再次构建和运行代码，然后访问`/chat`页面，您会注意到注册流程起作用了，我们最终被允许返回到聊天页面。大多数浏览器都有检查器或控制台——一种允许您查看服务器发送给您的cookie的工具——您可以使用它来查看`auth`
    cookie是否已出现：
- en: '[PRE19]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In our case, the cookie value is `eyJuYW1lIjoiTWF0IFJ5ZXIifQ==,` which is a
    Base64-encoded version of `{"name":"Mat Ryer"}` . Remember, we never typed in
    a name in our chat application; instead, Gomniauth asked Google for a name when
    we opted to sign in with Google. Storing non-signed cookies like this is fine
    for incidental information such as a user's name, however, you should avoid storing
    any sensitive information using non-signed cookies, as it's easy for people to
    access and change the data.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，cookie值是`eyJuYW1lIjoiTWF0IFJ5ZXIifQ==`，这是`{"name":"Mat Ryer"}`的Base64编码版本。请记住，我们在聊天应用中从未输入过名字；相反，当我们选择使用Google登录时，Gomniauth会向Google请求一个名字。像这样存储非签名的cookie对于像用户姓名这样的偶发信息是可以的，但是，您应该避免使用非签名的cookie存储任何敏感信息，因为人们可以轻松访问和更改数据。
- en: Presenting the user data
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 呈现用户数据
- en: Having the user data inside a cookie is a good start, but nontechnical people
    will never even know it's there, so we must bring the data to the fore. We will
    do this by enhancing our `templateHandler` method that first passes the user data
    into the template's `Execute` method; this allows us to use template annotations
    in our HTML to display the user data to the users.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 将用户数据放在cookie中是一个很好的开始，但非技术人员甚至不会知道它的存在，所以我们必须将数据提到前台。我们将通过增强我们的`templateHandler`方法来实现这一点，该方法首先将用户数据传递到模板的`Execute`方法中；这使我们能够在HTML中使用模板注释来向用户显示用户数据。
- en: 'Update the `ServeHTTP` method of our `templateHandler` in `main.go` :'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 更新`main.go`中我们的`templateHandler`的`ServeHTTP`方法：
- en: '[PRE20]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Instead of just passing the entire `http.Request` object to our template as
    data, we are creating a new `map[string]interface{}` definition for a data object
    that potentially has two fields: `Host` and `UserData` (the latter will only appear
    if an `auth` cookie is present). By specifying the map type followed by curly
    braces, we are able to add the `Host` entry at the same time as making our map.
    We then pass this new `data` object as the second argument to the `Execute` method
    on our template.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不仅仅将整个`http.Request`对象作为数据传递给我们的模板，而是为一个数据对象创建一个新的`map[string]interface{}`定义，该对象可能有两个字段：`Host`和`UserData`（后者只有在存在`auth`
    cookie时才会出现）。通过指定映射类型后跟花括号，我们能够在同一时间添加`Host`条目和创建我们的映射。然后我们将这个新的`data`对象作为第二个参数传递给我们模板的`Execute`方法。
- en: 'Now we add an HTML file to our template source to display the name. Update
    the `chatbox` form in `chat.html` :'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们在模板源中添加一个HTML文件来显示名称。更新`chat.html`中的`chatbox`表单：
- en: '[PRE21]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `{{.UserData.name}}` annotation tells the template engine to insert our
    user's name before the `textarea` control.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`{{.UserData.name}}`注释告诉模板引擎在`textarea`控件之前插入我们用户的名称。'
- en: Tip
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Since we're using the `objx` package, don't forget to run `go get` [http://github.com/stretchr/objx](http://github.com/stretchr/objx)
    , and import it.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在使用`objx`包，请不要忘记运行`go get` [http://github.com/stretchr/objx](http://github.com/stretchr/objx)，并导入它。
- en: 'Rebuild and run the chat application again, and you will notice the addition
    of your name before the chat box:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 重新构建并再次运行聊天应用程序，您会注意到在聊天框之前添加了您的名称。
- en: '[PRE22]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Augmenting messages with additional data
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 增加消息的附加数据
- en: So far, our chat application has only transmitted messages as slices of bytes
    or `[]byte` types between the client and the server; therefore, our forward channel
    for our room has the `chan []byte` type. In order to send data (such as who sent
    it and when) in addition to the message itself, we enhance our forward channel
    and also how we interact with the web socket on both ends.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的聊天应用程序只传输消息作为字节片或`[]byte`类型在客户端和服务器之间；因此，我们的房间的`forward`通道具有`chan []byte`类型。为了发送数据（例如发送者和发送时间）以及消息本身，我们增强了我们的`forward`通道以及我们在两端与web套接字交互的方式。
- en: 'Define a new type that will replace the `[]byte` slice by creating a new file
    called `message.go` in the `chat` folder:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在`chat`文件夹中创建一个名为`message.go`的新文件，定义一个将`[]byte`切片替换的新类型：
- en: '[PRE23]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `message` type will encapsulate the message string itself, but we have also
    added the `Name` and `When` fields that respectively hold the user's name and
    a timestamp of when the message was sent.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`message`类型将封装消息字符串本身，但我们还添加了分别保存用户名称和消息发送时间戳的`Name`和`When`字段。'
- en: 'Since the `client` type is responsible for communicating with the browser,
    it needs to transmit and receive more than just the single message string. As
    we are talking to a JavaScript application (that is the chat client running in
    the browser) and the Go standard library has a great JSON implementation, this
    seems the perfect choice to encode additional information in the messages. We
    will change the `read` and `write` methods in `client.go` to use the `ReadJSON`
    and `WriteJSON` methods on the socket, and we will encode and decode our new `message`
    type:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`client`类型负责与浏览器通信，它需要传输和接收的不仅仅是单个消息字符串。由于我们正在与JavaScript应用程序（即在浏览器中运行的聊天客户端）进行交流，并且Go标准库具有出色的JSON实现，因此这似乎是在消息中编码附加信息的完美选择。我们将更改`client.go`中的`read`和`write`方法，以使用套接字上的`ReadJSON`和`WriteJSON`方法，并对我们的新`message`类型进行编码和解码：
- en: '[PRE24]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: When we receive a message from the browser, we will expect to populate only
    the `Message` field, which is why we set the `When` and `Name` fields ourselves
    in the preceding code.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从浏览器接收到消息时，我们只期望填充`Message`字段，这就是为什么我们在前面的代码中设置了`When`和`Name`字段。
- en: You will notice that when you try to build the preceding code, it complains
    about a few things. The main reason is that we are trying to send a `*message`
    object down our `forward` and `send chan []byte` channels. This is not allowed
    until we change the type of the channel. In `room.go` , change the `forward` field
    to be of type `chan *message` , and do the same for the `send chan` type in `client.go`
    .
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 当您尝试构建前面的代码时，您会注意到它会抱怨一些问题。主要原因是我们试图通过`forward`和`send chan []byte`通道发送`*message`对象。在`room.go`中，将`forward`字段更改为`chan
    *message`类型，并在`client.go`中对`send chan`类型执行相同操作。
- en: 'We must update the code that initializes our channels since the types have
    now changed. Alternatively, you can wait for the compiler to raise these issues
    and fix them as you go. In `room.go` , you need to make the following changes:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须更新初始化通道的代码，因为类型现在已经改变。或者，您可以等待编译器提出这些问题，并在进行修复时解决它们。在`room.go`中，您需要进行以下更改：
- en: 'Change `forward: make(chan []byte)` to `forward: make(chan *message)`'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '将`forward: make(chan []byte)`更改为`forward: make(chan *message)`'
- en: 'Change `r.tracer.Trace("Message received: ", string(msg))` to `r.tracer.Trace("Message
    received: ", msg.Message)`'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '将`r.tracer.Trace("Message received: ", string(msg))`更改为`r.tracer.Trace("Message
    received: ", msg.Message)`'
- en: 'Change `send: make(chan []byte, messageBufferSize)` to `send: make(chan *message,
    messageBufferSize)`'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '将`send: make(chan []byte, messageBufferSize)`更改为`send: make(chan *message,
    messageBufferSize)`'
- en: 'The compiler will also complain about the lack of user data on a client, which
    is a fair point because the `client` type has no idea about the new user data
    we have added to the cookie. Update the `client` struct to include a new `map[string]interface{}`
    called `userData` :'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器还会抱怨客户端缺少用户数据，这是一个公平的观点，因为`client`类型对我们已添加到cookie中的新用户数据一无所知。更新`client`结构以包括一个名为`userData`的新`map[string]interface{}`：
- en: '[PRE25]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The user data comes from the client cookie that we access through the `http.Request`
    objects''s `Cookie` method. In `room.go` , update `ServeHTTP` with the following
    changes:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 用户数据来自客户端cookie，我们通过`http.Request`对象的`Cookie`方法访问它。在`room.go`中，使用以下更改更新`ServeHTTP`：
- en: '[PRE26]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We use the `Cookie` method on the `http.Request` type to get our user data before
    passing it to the client. We are using the `objx.MustFromBase64` method to convert
    our encoded cookie value back into a usable map object.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`http.Request`类型上的`Cookie`方法来获取用户数据，然后将其传递给客户端。我们使用`objx.MustFromBase64`方法将编码的cookie值转换回可用的map对象。
- en: 'Now that we have changed the type being sent and received on the socket from
    `[]byte` to `*message` , we must tell our JavaScript client that we are sending
    JSON instead of just a plain string. Also we must ask that it send JSON back to
    the server when a user submits a message. In `chat.html` , first update the `socket.send`
    call:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将从套接字发送和接收的类型从`[]byte`更改为`*message`，我们必须告诉我们的JavaScript客户端，我们正在发送JSON而不仅仅是普通字符串。还必须要求在用户提交消息时，它将JSON发送回服务器。在`chat.html`中，首先更新`socket.send`调用：
- en: '[PRE27]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We are using `JSON.stringify` to serialize the specified JSON object (containing
    just the `Message` field) into a string, which is then sent to the server. Our
    Go code will decode (or unmarshal) the JSON string into a `message` object, matching
    the field names from the client JSON object with those of our `message` type.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`JSON.stringify`将指定的JSON对象（仅包含`Message`字段）序列化为字符串，然后发送到服务器。我们的Go代码将把JSON字符串解码（或取消编组）为`message`对象，将客户端JSON对象的字段名称与我们的`message`类型的字段名称匹配。
- en: 'Finally, update the `socket.onmessage` callback function to expect JSON, and
    also add the name of the sender to the page:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，更新`socket.onmessage`回调函数以期望JSON，并在页面上添加发送者的名称：
- en: '[PRE28]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In the preceding code snippet, we've used JavaScript's `eval` function to turn
    the JSON string into a JavaScript object, and then access the fields to build
    up the elements needed to properly display them.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们使用了JavaScript的`eval`函数将JSON字符串转换为JavaScript对象，然后访问字段以构建显示它们所需的元素。
- en: 'Build and run the application, and if you can, log in with two different accounts
    in two different browsers (or invite a friend to help you test it):'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 构建并运行应用程序，如果可以的话，在两个不同的浏览器中使用两个不同的帐户登录（或者邀请朋友帮助测试）：
- en: '[PRE29]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The following screenshot shows the chat application''s browser chat screens:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了聊天应用程序的浏览器聊天界面：
- en: '![Augmenting messages with additional data](img/Image00006.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![使用附加数据增强消息](img/Image00006.jpg)'
- en: Summary
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we added a useful and necessary feature to our chat application
    by asking users to authenticate themselves using OAuth2 service providers, before
    allowing them to join the conversation. We made use of several open source packages
    such as `Objx` and `Gomniauth` , which dramatically reduced the amount of multi-server
    complexity we would otherwise need to deal with.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过要求用户使用OAuth2服务提供商进行身份验证，然后允许他们加入对话，为我们的聊天应用程序添加了一个有用且必要的功能。我们利用了几个开源包，如`Objx`和`Gomniauth`，大大减少了我们需要处理的多服务器复杂性。
- en: We implemented a pattern when we wrapped `http.Handler` types to allow us to
    easily specify which paths require the user to be authenticated, and which were
    available even without an `auth` cookie. Our `MustAuth` helper function allowed
    us to generate the wrapper types in a fluent and simple way, without adding clutter
    and confusion to our code.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们包装`http.Handler`类型时，我们实现了一种模式，以便轻松指定哪些路径需要用户进行身份验证，哪些即使没有`auth` cookie也是可用的。我们的`MustAuth`辅助函数使我们能够以流畅简单的方式生成包装类型，而不会给我们的代码添加混乱和困惑。
- en: We saw how to use cookies and Base64-encoding to safely (although not securely)
    store the state of particular users in their browser, and to make use of that
    data over normal connections and through web sockets. We took more control of
    the data available to our templates in order to provide the name of the user to
    the UI, and saw how to only provide certain data under specific conditions.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到如何使用Cookie和Base64编码来安全（虽然不安全）地在用户的浏览器中存储特定用户的状态，并利用该数据通过普通连接和网络套接字。我们更多地控制了模板中可用的数据，以便向UI提供用户的名称，并看到如何在特定条件下仅提供某些数据。
- en: Since we needed to send and receive additional information over the web socket,
    we learned how easy it was to change channels of native types into channels that
    work with types of our own such as our `message` type. We also learned how to
    transmit JSON objects over the socket, rather than just slices of bytes. Thanks
    to the type safety of Go, and the ability to specify types for channels, the compiler
    helps ensure that we do not send anything other than `message` objects through
    `chan *message` . Attempting to do so would result in a compiler error, alerting
    us to the fact right away.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们需要通过网络套接字发送和接收附加信息，我们学会了如何轻松地将本机类型的通道更改为适用于我们自己的类型（如我们的`message`类型）的通道。我们还学会了如何通过套接字传输JSON对象，而不仅仅是字节片。由于Go的类型安全性，以及能够为通道指定类型，编译器有助于确保我们不会通过`chan
    *message`发送除`message`对象以外的任何东西。尝试这样做将导致编译器错误，立即提醒我们这一事实。
- en: To see the name of the person chatting is a great leap forward in usability
    from the application we built in the previous chapter, but it's very formal and
    might not attract modern users of the Web, who are used to a much more visual
    experience. We are missing pictures of people chatting, and in the next chapter,
    we will explore different ways in which we can allow users to better represent
    themselves in our application.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前构建的应用程序中，看到聊天的人的名字是一个巨大的可用性进步，但它非常正式，可能不会吸引现代Web用户，他们习惯于更加视觉化的体验。我们缺少聊天的人的图片，在下一章中，我们将探讨不同的方式，让用户更好地在我们的应用程序中代表自己。
- en: As an extra assignment, see if you can make use of the `time.Time` field that
    we put into the `message` type to tell users when the messages were sent.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 作为额外的任务，看看是否可以利用我们放入`message`类型中的`time.Time`字段，告诉用户消息何时发送。
