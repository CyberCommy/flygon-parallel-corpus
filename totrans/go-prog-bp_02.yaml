- en: Chapter 2. Adding Authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The chat application we built in the previous chapter focused on high-performance
    transmission of messages from the clients to the server and back again, but our
    users have no way of knowing who they are talking to. One solution to this problem
    is building of some kind of signup and login functionality and letting our users
    create accounts and authenticate themselves before they can open the chat page.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever we are about to build something from scratch, we must ask ourselves
    how others have solved this problem before (it is extremely rare to encounter
    genuinely original problems), and whether any open solutions or standards already
    exist that we can make use of. Authorization and authentication are hardly new
    problems, especially in the world of the Web, with many different protocols out
    there to choose from. So how do we decide on the best option to pursue? As always,
    we must look at this question from the point of view of the user.
  prefs: []
  type: TYPE_NORMAL
- en: A lot of websites these days allow you to sign in using your accounts existing
    elsewhere on a variety of social media or community websites. This saves users
    the tedious job of entering all their account information over and over again
    as they decide to try out different products and services. It also has a positive
    effect on the conversion rates for new sites.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will enhance our chat codebase to add authentication, which
    will allow our users to sign in using Google, Facebook, or GitHub and you'll see
    how easy it is to add other sign-in portals too. In order to join the chat, users
    must first sign in. Following this, we will use the authorized data to augment
    our user experience so everyone knows who is in the room, and who said what.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn to:'
  prefs: []
  type: TYPE_NORMAL
- en: Use the decorator pattern to wrap `http.Handler` types to add additional functionality
    to handlers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serve HTTP endpoints with dynamic paths
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the Gomniauth open source project to access authentication services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get and set cookies using the `http` package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encode objects as Base64 and back to normal again
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Send and receive JSON data over a web socket
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Give different types of data to templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Work with channels of your own types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handlers all the way down
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For our chat application, we implemented our own `http.Handler` type in order
    to easily compile, execute, and deliver HTML content to browsers. Since this is
    a very simple but powerful interface, we are going to continue to use it wherever
    possible when adding functionality to our HTTP processing.
  prefs: []
  type: TYPE_NORMAL
- en: In order to determine whether a user is authenticated, we will create an authentication
    wrapper handler that performs the check, and passes execution on to the inner
    handler only if the user is authenticated.
  prefs: []
  type: TYPE_NORMAL
- en: Our wrapper handler will satisfy the same `http.Handler` interface as the object
    inside it, allowing us to wrap any valid handler. In fact, even the authentication
    handler we are about to write could be later encapsulated inside a similar wrapper
    if needed.
  prefs: []
  type: TYPE_NORMAL
- en: '![Handlers all the way down](img/Image00002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Diagram of a chaining pattern when applied to HTTP handlers
  prefs: []
  type: TYPE_NORMAL
- en: The preceding figure shows how this pattern could be applied in a more complicated
    HTTP handler scenario. Each object implements the `http.Handler` interface, which
    means that object could be passed into the `http.Handle` method to directly handle
    a request, or it can be given to another object, which adds some kind of extra
    functionality. The `Logging` handler might write to a logfile before and after
    the `ServeHTTP` method is called on the inner handler. Because the inner handler
    is just another `http.Handler` , any other handler can be wrapped in (or decorated
    with) the `Logging` handler.
  prefs: []
  type: TYPE_NORMAL
- en: It is also common for an object to contain logic that decides which inner handler
    should be executed. For example, our authentication handler will either pass the
    execution to the wrapped handler, or handle the request itself by issuing a redirect
    to the browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s plenty of theory for now; let''s write some code. Create a new file
    called `auth.go` in the `chat` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `authHandler` type not only implements the `ServeHTTP` method (which satisfies
    the `http.Handler` interface) but also stores (wraps) `http.Handler` in the next
    field. Our `MustAuth` helper function simply creates `authHandler` that wraps
    any other `http.Handler` . Let''s tweak the following root mapping line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s change the first argument to make it explicit about the page meant for
    chatting. Next, let''s use the `MustAuth` function to wrap `templateHandler` for
    the second argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Wrapping `templateHandler` with the `MustAuth` function will cause execution
    to run first through our `authHandler` , and only to `templateHandler` if the
    request is authenticated.
  prefs: []
  type: TYPE_NORMAL
- en: The `ServeHTTP` method in our `authHandler` will look for a special cookie called
    `auth` , and use the `Header` and `WriteHeader` methods on `http.ResponseWriter`
    to redirect the user to a login page if the cookie is missing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Build and run the chat application and try to hit `http://localhost:8080/chat`
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You need to delete your cookies to clear out previous auth tokens, or any other
    cookies that might be left over from other development projects served through
    localhost.
  prefs: []
  type: TYPE_NORMAL
- en: If you look in the address bar of your browser, you will notice that you are
    immediately redirected to the `/login` page. Since we cannot handle that path
    yet, you'll just get a **404 page not found** error.
  prefs: []
  type: TYPE_NORMAL
- en: Making a pretty social sign-in page
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far we haven't paid much attention to making our application look nice, after
    all this book is about Go and not user-interface development. However, there is
    no excuse for building ugly apps, and so we will build a social sign-in page that
    is as pretty as it is functional.
  prefs: []
  type: TYPE_NORMAL
- en: Bootstrap is a frontend framework used to develop responsive projects on the
    Web. It provides CSS and JavaScript code that solve many user-interface problems
    in a consistent and good-looking way. While sites built using Bootstrap all tend
    to look the same (although there are plenty of ways in which the UI can be customized),
    it is a great choice for early versions of apps, or for developers who don't have
    access to designers.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you build your application using the semantic standards set forth by Bootstrap,
    it becomes easy for you to make a Bootstrap theme for your site or application
    and you know it will slot right into your code.
  prefs: []
  type: TYPE_NORMAL
- en: We will use the version of Bootstrap hosted on a CDN so we don't have to worry
    about downloading and serving our own version through our chat application. This
    means that in order to render our pages properly, we will need an active Internet
    connection, even during development.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you prefer to download and host your own copy of Bootstrap, you can do so.
    Keep the files in an `assets` folder and add the following call to your `main`
    function (it uses `http.Handle` to serve the assets via your application):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Notice how the `http.StripPrefix` and `http.FileServer` functions return objects
    that satisfy the `http.Handler` interface as per the decorator pattern that we
    implement with our `MustAuth` helper function.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `main.go` , let''s add an endpoint for the login page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Obviously, we do not want to use the `MustAuth` method for our login page because
    it will cause an infinite redirection loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file called `login.html` inside our `templates` folder, and insert
    the following HTML code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Restart the web server and navigate to `http://localhost:8080/login` . You
    will notice that it now displays our sign-in page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Making a pretty social sign-in page](img/Image00003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Endpoints with dynamic paths
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Pattern matching for the `http` package in the Go standard library isn''t the
    most comprehensive and fully featured implementation out there. For example, Ruby
    on Rails makes it much easier to have dynamic segments inside the path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This then provides a data map (or dictionary) containing the values that the
    framework automatically extracted from the matched path. So if you visit `auth/login/google`
    , then `params[:provider_name]` would equal `google` , and `params[:action]` would
    equal `login` .
  prefs: []
  type: TYPE_NORMAL
- en: 'The most the `http` package lets us specify by default is a path prefix, which
    we can do by leaving a trailing slash at the end of the pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We would then have to manually parse the remaining segments to extract the
    appropriate data. This is acceptable for relatively simple cases, which suits
    our needs for the time being since we only need to handle a few different paths
    such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/auth/login/google`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/auth/login/facebook`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/auth/callback/google`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/auth/callback/facebook`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you need to handle more advanced routing situations, you might want to consider
    using dedicated packages such as Goweb, Pat, Routes, or mux. For extremely simple
    cases such as ours, the built-in capabilities will do.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to create a new handler that powers our login process. In `auth.go`
    , add the following `loginHandler` code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we break the path into segments using `strings.Split`
    before pulling out the values for `action` and `provider` . If the action value
    is known, we will run the specific code; otherwise, we will write out an error
    message and return an `http.StatusNotFound` status code (which in the language
    of HTTP status code, is a `404` code).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will not bullet-proof our code right now but it's worth noticing that if
    someone hits `loginHandler` with too few segments, our code will panic because
    it expects `segs[2]` and `segs[3]` to exist.
  prefs: []
  type: TYPE_NORMAL
- en: For extra credit, see whether you can protect against this and return a nice
    error message instead of a panic if someone hits `/auth/nonsense` .
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `loginHandler` is only a function and not an object that implements the
    `http.Handler` interface. This is because, unlike other handlers, we don''t need
    it to store any state. The Go standard library supports this, so we can use the
    `http.HandleFunc` function to map it in a way similar to how we used `http.Handle`
    earlier. In `main.go` , update the handlers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Rebuild and run the chat application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Hit the following URLs and notice the output logged in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '`http://localhost:8080/auth/login/google` outputs `TODO handle login for google`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`http://localhost:8080/auth/login/facebook` outputs `TODO handle login for
    facebook`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have successfully implemented a dynamic path-matching mechanism that so far
    just prints out to-do messages; next we need to write code that integrates with
    the authentication services.
  prefs: []
  type: TYPE_NORMAL
- en: 读累了记得休息一会哦~
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**公众号：古德猫宁李**'
  prefs: []
  type: TYPE_NORMAL
- en: 电子书搜索下载
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 书单分享
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 书友学习交流
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**网站：**[沉金书屋 https://www.chenjin5.com](https://www.chenjin5.com)'
  prefs: []
  type: TYPE_NORMAL
- en: 电子书搜索下载
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 电子书打包资源分享
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 学习资源分享
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OAuth2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OAuth2 is an open authentication and authorization standard designed to allow
    resource owners to give clients delegated access to private data (such as wall
    posts or tweets) via an access token exchange handshake. Even if you do not wish
    to access the private data, OAuth2 is a great option that allows people to sign
    in using their existing credentials, without exposing those credentials to a third-party
    site. In this case, we are the third party and we want to allow our users to sign
    in using services that support OAuth2.
  prefs: []
  type: TYPE_NORMAL
- en: 'From a user''s point of view, the OAuth2 flow is:'
  prefs: []
  type: TYPE_NORMAL
- en: A user selects provider with whom they wish to sign in to the client app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The user is redirected to the provider's website (with a URL that includes the
    client app ID) where they are asked to give permission to the client app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The user signs in from the OAuth2 service provider and accepts the permissions
    requested by the third-party application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The user is redirected back to the client app with a request code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the background, the client app sends the grant code to the provider, who
    sends back an auth token.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The client app uses the access token to make authorized requests to the provider,
    such as to get user information or wall posts.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To avoid reinventing the wheel, we will look at a few open source projects that
    have already solved this problem for us.
  prefs: []
  type: TYPE_NORMAL
- en: Open source OAuth2 packages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Andrew Gerrand has been working on the core Go team since February 2010, that
    is two years before Go 1.0 was officially released. His `goauth2` package (see
    [https://code.google.com/p/goauth2/](https://code.google.com/p/goauth2/) ) is
    an elegant implementation of the OAuth2 protocol written entirely in Go.
  prefs: []
  type: TYPE_NORMAL
- en: Andrew's project inspired Gomniauth (see [https://github.com/stretchr/gomniauth](https://github.com/stretchr/gomniauth)
    ). An open source Go alternative to Ruby's `omniauth` project, Gomniauth provides
    a unified solution to access different OAuth2 services. In the future, when OAuth3
    (or whatever next-generation authentication protocol it is) comes out, in theory,
    Gomniauth could take on the pain of implementing the details, leaving the user
    code untouched.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our application, we will use Gomniauth to access OAuth services provided
    by Google, Facebook, and GitHub, so make sure you have it installed by running
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some of the project dependencies of Gomniauth are kept in Bazaar repositories,
    so you'll need to head over to [http://wiki.bazaar.canonical.com](http://wiki.bazaar.canonical.com)
    to download them.
  prefs: []
  type: TYPE_NORMAL
- en: Tell the authentication providers about your app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we ask an authentication provider to help our users sign in, we must
    tell them about our application. Most providers have some kind of web tool or
    console where you can create applications to kick-start the process. Here''s one
    from Google:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Tell the authentication providers about your app](img/Image00004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In order to identify the client application, we need to create a client ID and
    secret. Despite the fact that OAuth2 is an open standard, each provider has their
    own language and mechanism to set things up, so you will most likely have to play
    around with the user interface or the documentation to figure it out in each case.
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing this, in **Google Developer Console** , you navigate
    to **APIs & auth** | **Credentials** and click on the **Create new Client ID**
    button.
  prefs: []
  type: TYPE_NORMAL
- en: In most cases, for added security, you have to be explicit about the host URLs
    from where requests will come. For now, since we're hosting our app locally on
    `localhost:8080` , you should use that. You will also be asked for a redirect
    URI that is the endpoint in our chat application and to which the user will be
    redirected after successfully signing in. The callback will be another action
    on our `loginHandler` , so the redirection URL for the Google client will be `http://localhost:8080/auth/callback/google`
    .
  prefs: []
  type: TYPE_NORMAL
- en: Once you finish the authentication process for the providers you want to support,
    you will be given a client ID and secret for each provider. Make a note of these,
    because we will need them when we set up the providers in our chat application.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If we host our application on a real domain, we have to create new client IDs
    and secrets, or update the appropriate URL fields on our authentication providers
    to ensure that they point to the right place. Either way, it's not bad practice
    to have a different set of development and production keys for security.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing external logging in
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to make use of the projects, clients, or accounts that we created
    on the authentication provider sites, we have to tell Gomniauth which providers
    we want to use, and how we will interact with them. We do this by calling the
    `WithProviders` function on the primary Gomniauth package. Add the following code
    snippet to `main.go` (just underneath the `flag.Parse()` line towards the top
    of the `main` function):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: You should replace the `key` and `secret` placeholders with the actual values
    you noted down earlier. The third argument represents the callback URL that should
    match the ones you provided when creating your clients on the provider's website.
    Notice the second path segment is `callback` ; while we haven't implemented this
    yet, this is where we handle the response from the authentication process.
  prefs: []
  type: TYPE_NORMAL
- en: 'As usual, you will need to ensure all the appropriate packages are imported:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Gomniauth requires the `SetSecurityKey` call because it sends state data between
    the client and server along with a signature checksum, which ensures that the
    state values haven't been tempered with while transmitting. The security key is
    used when creating the hash in a way that it is almost impossible to recreate
    the same hash without knowing the exact security key. You should replace `some
    long key` with a security hash or phrase of your choice.
  prefs: []
  type: TYPE_NORMAL
- en: Logging in
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have configured Gomniauth, we need to redirect users to the provider''s
    authentication page when they land on our `/auth/login/{provider}` path. We just
    have to update our `loginHandler` function in `auth.go` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We do two main things here. First, we use the `gomniauth.Provider` function
    to get the provider object that matches the object specified in the URL (such
    as `google` or `github` ). Then we use the `GetBeginAuthURL` method to get the
    location where we must send users in order to start the authentication process.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `GetBeginAuthURL(nil, nil)` arguments are for the state and options respectively,
    which we are not going to use for our chat application.
  prefs: []
  type: TYPE_NORMAL
- en: The first argument is a state map of data that is encoded, and signed and sent
    to the authentication provider. The provider doesn't do anything with the state,
    it just sends it back to our callback endpoint. This is useful if, for example,
    we want to redirect the user back to the original page they were trying to access
    before the authentication process intervened. For our purpose, we have only the
    `/chat` endpoint, so we don't need to worry about sending any state.
  prefs: []
  type: TYPE_NORMAL
- en: The second argument is a map of additional options that will be sent to the
    authentication provider, which somehow modifies the behavior of the authentication
    process. For example, you can specify your own `scope` parameter, which allows
    you to make a request for permission to access additional information from the
    provider. For more information about the available options, search for OAuth2
    on the Internet or read the documentation for each provider, as these values differ
    from service to service.
  prefs: []
  type: TYPE_NORMAL
- en: If our code gets no error from the `GetBeginAuthURL` call, we simply redirect
    the user's browser to the returned URL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rebuild and run the chat application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the main chat page by accessing `http://localhost:8080/chat` . As we aren''t
    logged in yet, we are redirected to our sign-in page. Click on the Google option
    to sign in using your Google account, and you will notice that you are presented
    with a Google-specific sign-in page (if you are not already signed in to Google).
    Once you are signed in, you will be presented with a page asking you to give permission
    for our chat application before you can view basic information about your account:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Logging in](img/Image00005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is the same flow that users of our chat application will experience when
    signing in.
  prefs: []
  type: TYPE_NORMAL
- en: Click on **Accept** and you will notice that you are redirected back to our
    application code, but presented with an `Auth action callback not supported` error.
    This is because we haven't yet implemented the callback functionality in `loginHandler`
    .
  prefs: []
  type: TYPE_NORMAL
- en: Handling the response from the provider
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once the user clicks on **Accept** on the provider's website (or if they click
    on the equivalent of **Cancel** ), they will be redirected back to the callback
    endpoint in our application.
  prefs: []
  type: TYPE_NORMAL
- en: A quick glance at the complete URL that comes back shows us the grant code that
    the provider has given us.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We don't have to worry about what to do with this code because Gomniauth will
    process the OAuth URL parameters for us (by sending the grant code to Google servers
    and exchanging it for an access token as per the OAuth specification), so we can
    simply jump to implementing our callback handler. However, it's worth knowing
    that this code will be exchanged by the authentication provider for a token that
    allows us to access private user data. For added security, this additional step
    happens behind the scenes, from server to server rather than in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `auth.go` , we are ready to add another switch case to our action path segment.
    Insert the following code above the default case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: When the authentication provider redirects the users back after they have granted
    permission, the URL specifies that it is a callback action. We look up the authentication
    provider as we did before, and call its `CompleteAuth` method. We parse the `RawQuery`
    from the `http.Request` (the `GET` request that the user's browser is now making)
    into `objx.Map` (the multi-purpose map type that Gomniauth uses) and the `CompleteAuth`
    method uses the URL query parameter values to complete the authentication handshake
    with the provider. All being well, we will be given some authorized credentials
    with which we access our user's basic data. We then use the `GetUser` method for
    the provider and Gomniauth uses the specified credentials to access some basic
    information about the user.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have the user data, we Base64-encode the `Name` field in a JSON object
    and store it as the value to our `auth` cookie for later use.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Base64-encoding of data ensures it won't contain any special or unpredictable
    characters, like passing data in a URL or storing it in a cookie. Remember that
    although Base64-encoded data looks encrypted, it is not—you can easily decode
    Base64-encoded data back into the original text with little effort. There are
    online tools that do this for you.
  prefs: []
  type: TYPE_NORMAL
- en: After setting the cookie, we redirect the user to the chat page, which we can
    safely assume was the original destination.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you build and run the code again and hit the `/chat` page, you will notice
    that the signup flow works, and we are finally allowed back to the chat page.
    Most browsers have an inspector or a console—a tool that allows you to view the
    cookies that the server has sent you—that you can use to see whether the `auth`
    cookie has appeared:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In our case, the cookie value is `eyJuYW1lIjoiTWF0IFJ5ZXIifQ==,` which is a
    Base64-encoded version of `{"name":"Mat Ryer"}` . Remember, we never typed in
    a name in our chat application; instead, Gomniauth asked Google for a name when
    we opted to sign in with Google. Storing non-signed cookies like this is fine
    for incidental information such as a user's name, however, you should avoid storing
    any sensitive information using non-signed cookies, as it's easy for people to
    access and change the data.
  prefs: []
  type: TYPE_NORMAL
- en: Presenting the user data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Having the user data inside a cookie is a good start, but nontechnical people
    will never even know it's there, so we must bring the data to the fore. We will
    do this by enhancing our `templateHandler` method that first passes the user data
    into the template's `Execute` method; this allows us to use template annotations
    in our HTML to display the user data to the users.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `ServeHTTP` method of our `templateHandler` in `main.go` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of just passing the entire `http.Request` object to our template as
    data, we are creating a new `map[string]interface{}` definition for a data object
    that potentially has two fields: `Host` and `UserData` (the latter will only appear
    if an `auth` cookie is present). By specifying the map type followed by curly
    braces, we are able to add the `Host` entry at the same time as making our map.
    We then pass this new `data` object as the second argument to the `Execute` method
    on our template.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we add an HTML file to our template source to display the name. Update
    the `chatbox` form in `chat.html` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `{{.UserData.name}}` annotation tells the template engine to insert our
    user's name before the `textarea` control.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since we're using the `objx` package, don't forget to run `go get` [http://github.com/stretchr/objx](http://github.com/stretchr/objx)
    , and import it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rebuild and run the chat application again, and you will notice the addition
    of your name before the chat box:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Augmenting messages with additional data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, our chat application has only transmitted messages as slices of bytes
    or `[]byte` types between the client and the server; therefore, our forward channel
    for our room has the `chan []byte` type. In order to send data (such as who sent
    it and when) in addition to the message itself, we enhance our forward channel
    and also how we interact with the web socket on both ends.
  prefs: []
  type: TYPE_NORMAL
- en: 'Define a new type that will replace the `[]byte` slice by creating a new file
    called `message.go` in the `chat` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `message` type will encapsulate the message string itself, but we have also
    added the `Name` and `When` fields that respectively hold the user's name and
    a timestamp of when the message was sent.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the `client` type is responsible for communicating with the browser,
    it needs to transmit and receive more than just the single message string. As
    we are talking to a JavaScript application (that is the chat client running in
    the browser) and the Go standard library has a great JSON implementation, this
    seems the perfect choice to encode additional information in the messages. We
    will change the `read` and `write` methods in `client.go` to use the `ReadJSON`
    and `WriteJSON` methods on the socket, and we will encode and decode our new `message`
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: When we receive a message from the browser, we will expect to populate only
    the `Message` field, which is why we set the `When` and `Name` fields ourselves
    in the preceding code.
  prefs: []
  type: TYPE_NORMAL
- en: You will notice that when you try to build the preceding code, it complains
    about a few things. The main reason is that we are trying to send a `*message`
    object down our `forward` and `send chan []byte` channels. This is not allowed
    until we change the type of the channel. In `room.go` , change the `forward` field
    to be of type `chan *message` , and do the same for the `send chan` type in `client.go`
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'We must update the code that initializes our channels since the types have
    now changed. Alternatively, you can wait for the compiler to raise these issues
    and fix them as you go. In `room.go` , you need to make the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Change `forward: make(chan []byte)` to `forward: make(chan *message)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Change `r.tracer.Trace("Message received: ", string(msg))` to `r.tracer.Trace("Message
    received: ", msg.Message)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Change `send: make(chan []byte, messageBufferSize)` to `send: make(chan *message,
    messageBufferSize)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The compiler will also complain about the lack of user data on a client, which
    is a fair point because the `client` type has no idea about the new user data
    we have added to the cookie. Update the `client` struct to include a new `map[string]interface{}`
    called `userData` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The user data comes from the client cookie that we access through the `http.Request`
    objects''s `Cookie` method. In `room.go` , update `ServeHTTP` with the following
    changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We use the `Cookie` method on the `http.Request` type to get our user data before
    passing it to the client. We are using the `objx.MustFromBase64` method to convert
    our encoded cookie value back into a usable map object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have changed the type being sent and received on the socket from
    `[]byte` to `*message` , we must tell our JavaScript client that we are sending
    JSON instead of just a plain string. Also we must ask that it send JSON back to
    the server when a user submits a message. In `chat.html` , first update the `socket.send`
    call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We are using `JSON.stringify` to serialize the specified JSON object (containing
    just the `Message` field) into a string, which is then sent to the server. Our
    Go code will decode (or unmarshal) the JSON string into a `message` object, matching
    the field names from the client JSON object with those of our `message` type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, update the `socket.onmessage` callback function to expect JSON, and
    also add the name of the sender to the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, we've used JavaScript's `eval` function to turn
    the JSON string into a JavaScript object, and then access the fields to build
    up the elements needed to properly display them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Build and run the application, and if you can, log in with two different accounts
    in two different browsers (or invite a friend to help you test it):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the chat application''s browser chat screens:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Augmenting messages with additional data](img/Image00006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we added a useful and necessary feature to our chat application
    by asking users to authenticate themselves using OAuth2 service providers, before
    allowing them to join the conversation. We made use of several open source packages
    such as `Objx` and `Gomniauth` , which dramatically reduced the amount of multi-server
    complexity we would otherwise need to deal with.
  prefs: []
  type: TYPE_NORMAL
- en: We implemented a pattern when we wrapped `http.Handler` types to allow us to
    easily specify which paths require the user to be authenticated, and which were
    available even without an `auth` cookie. Our `MustAuth` helper function allowed
    us to generate the wrapper types in a fluent and simple way, without adding clutter
    and confusion to our code.
  prefs: []
  type: TYPE_NORMAL
- en: We saw how to use cookies and Base64-encoding to safely (although not securely)
    store the state of particular users in their browser, and to make use of that
    data over normal connections and through web sockets. We took more control of
    the data available to our templates in order to provide the name of the user to
    the UI, and saw how to only provide certain data under specific conditions.
  prefs: []
  type: TYPE_NORMAL
- en: Since we needed to send and receive additional information over the web socket,
    we learned how easy it was to change channels of native types into channels that
    work with types of our own such as our `message` type. We also learned how to
    transmit JSON objects over the socket, rather than just slices of bytes. Thanks
    to the type safety of Go, and the ability to specify types for channels, the compiler
    helps ensure that we do not send anything other than `message` objects through
    `chan *message` . Attempting to do so would result in a compiler error, alerting
    us to the fact right away.
  prefs: []
  type: TYPE_NORMAL
- en: To see the name of the person chatting is a great leap forward in usability
    from the application we built in the previous chapter, but it's very formal and
    might not attract modern users of the Web, who are used to a much more visual
    experience. We are missing pictures of people chatting, and in the next chapter,
    we will explore different ways in which we can allow users to better represent
    themselves in our application.
  prefs: []
  type: TYPE_NORMAL
- en: As an extra assignment, see if you can make use of the `time.Time` field that
    we put into the `message` type to tell users when the messages were sent.
  prefs: []
  type: TYPE_NORMAL
