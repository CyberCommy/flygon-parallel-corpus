- en: Chapter 4. Thread Executors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a thread executor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a fixed-size thread executor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executing tasks in an executor that returns a result
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running multiple tasks and processing the first result
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running multiple tasks and processing all the results
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running a task in an executor after a delay
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running a task in an executor periodically
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Canceling a task in an executor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling a task finishing in an executor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Separating the launching of tasks and the processing of their results in an
    executor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling the rejected tasks of an executor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Usually, when you develop a simple, concurrent-programming application in Java,
    you create some `Runnable` objects and then create the corresponding `Thread`
    objects to execute them. If you have to develop a program that runs a lot of concurrent
    tasks, this approach has the following disadvantages:'
  prefs: []
  type: TYPE_NORMAL
- en: You have to implement all the code-related information to the management of
    the `Thread` objects (creation, ending, obtaining results).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You create a `Thread` object per task. If you have to execute a big number of
    tasks, this can affect the throughput of the application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You have to control and manage efficiently the resources of the computer. If
    you create too many threads, you can saturate the system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since Java 5, the Java concurrency API provides a mechanism that aims at resolving
    problems. This mechanism is called the **Executor framework** and is around the
    `Executor` interface, its subinterface `ExecutorService`, and the `ThreadPoolExecutor`
    class that implements both interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: This mechanism separates the task creation and its execution. With an executor,
    you only have to implement the `Runnable` objects and send them to the executor.
    It is responsible for their execution, instantiation, and running with necessary
    threads. But it goes beyond that and improves performance using a pool of threads.
    When you send a task to the executor, it tries to use a pooled thread for the
    execution of this task, to avoid continuous spawning of threads.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another important advantage of the Executor framework is the `Callable` interface.
    It''s similar to the `Runnable` interface, but offers two improvements, which
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The main method of this interface, named `call()`, may return a result.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you send a `Callable` object to an executor, you get an object that implements
    the `Future` interface. You can use this object to control the status and the
    result of the `Callable` object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter presents 11 recipes that show you how to work with the Executor
    framework using the classes mentioned earlier and other variants provided by the
    Java Concurrency API.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a thread executor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first step to work with the Executor framework is to create an object of
    the `ThreadPoolExecutor` class. You can use the four constructors provided by
    that class or use a factory class named `Executors` that creates `ThreadPoolExecutor`.
    Once you have an executor, you can send `Runnable` or `Callable` objects to be
    executed.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how these two operations implement an example
    that will simulate a web server processing requests from various clients.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You should read the *Creating and running a thread* recipe in [Chapter 1](ch01.html
    "Chapter 1. Thread Management") to learn the basic mechanism of thread creation
    in Java. You can compare both mechanisms and select the best one depending on
    the problem.
  prefs: []
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: First, you have to implement the tasks that will be executed by the server.
    Create a class named `Task` that implements the `Runnable` interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Declare a `Date` attribute named `initDate` to store the creation date of the
    task and a `String` attribute named `name` to store the name of the task.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Implement the constructor of the class that initializes both attributes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `run()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: First, write to the console the `initDate` attribute and the actual date, which
    is the starting date of the task.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Then, put the task to sleep for a random period of time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Finally, write to the console the completion date of the task.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now, implement the `Server` class that will execute every task it receives using
    an executor. Create a class named `Server`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Declare a `ThreadPoolExecutor` attribute named `executor`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Implement the constructor of the class that initializes the `ThreadPoolExecutor`
    object using the `Executors` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `executeTask()` method. It receives a `Task` object as a parameter
    and sends it to the executor. First, write a message to the console indicating
    that a new task has arrived.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Then, call the `execute()` method of the executor to send it the task.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Finally, write some executor data to the console to see its status.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `endServer()` method. In this method, call the `shutdown()` method
    of the executor to finish its execution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Finally, implement the main class of the example by creating a class named `Main`
    and implement the `main()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The key of this example is the `Server` class. This class creates and uses `ThreadPoolExecutor`
    to execute tasks.
  prefs: []
  type: TYPE_NORMAL
- en: The first important point is the creation of `ThreadPoolExecutor` in the constructor
    of the `Server` class. The `ThreadPoolExecutor` class has four different constructors
    but, due to their complexity, the Java concurrency API provides the `Executors`
    class to construct executors and other related objects. Although we can create
    `ThreadPoolExecutor` directly using one of its constructors, it's recommended
    to use the `Executors` class.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, you have created a cached thread pool using the `newCachedThreadPool()`
    method. This method returns an `ExecutorService` object, so it's been cast to
    `ThreadPoolExecutor` to have access to all its methods. The cached thread pool
    you have created creates new threads if needed to execute the new tasks, and reuses
    the existing ones if they have finished the execution of the task they were running,
    which are now available. The reutilization of threads has the advantage that it
    reduces the time taken for thread creation. The cached thread pool has, however,
    a disadvantage of constant lying threads for new tasks, so if you send too many
    tasks to this executor, you can overload the system.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Use the executor created by the `newCachedThreadPool()` method only when you
    have a reasonable number of threads or when they have a short duration.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have created the executor, you can send tasks of the `Runnable` or
    `Callable` type for execution using the `execute()` method. In this case, you
    send objects of the `Task` class that implements the `Runnable` interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'You also have printed some log messages with information about the executor.
    Specifically, you have used the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`getPoolSize()`: This method returns the actual number of threads in the pool
    of the executor'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getActiveCount()`: This method returns the number of threads that are executing
    tasks in the executor'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getCompletedTaskCount()`: This method returns the number of tasks completed
    by the executor'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One critical aspect of the `ThreadPoolExecutor` class, and of the executors
    in general, is that you have to end it explicitly. If you don't do this, the executor
    will continue its execution and the program won't end. If the executor doesn't
    have tasks to execute, it continues waiting for new tasks and it doesn't end its
    execution. A Java application won't end until all its non-daemon threads finish
    their execution, so, if you don't terminate the executor, your application will
    never end.
  prefs: []
  type: TYPE_NORMAL
- en: To indicate to the executor that you want to finish it, you can use the `shutdown()`
    method of the `ThreadPoolExecutor` class. When the executor finishes the execution
    of all pending tasks, it finishes its execution. After you call the `shutdown()`
    method, if you try to send another task to the executor, it will be rejected and
    the executor will throw a `RejectedExecutionException` exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows part of one execution of this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/7881_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When the last task arrives to the server, the executor has a pool of 100 tasks
    and 97 active threads.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `ThreadPoolExecutor` class provides a lot of methods to obtain information
    about its status. We used in the example the `getPoolSize()`, `getActiveCount()`,
    and `getCompletedTaskCount()` methods to obtain information about the size of
    the pool, the number of threads, and the number of completed tasks of the executor.
    You can also use the `getLargestPoolSize()` method that returns the maximum number
    of threads that has been in the pool at a time.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ThreadPoolExecutor` class also provides other methods related with the
    finalization of the executor. These methods are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`shutdownNow()`: This method shut downs the executor immediately. It doesn''t
    execute the pending tasks. It returns a list with all these pending tasks. The
    tasks that are running when you call this method continue with their execution,
    but the method doesn''t wait for their finalization.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isTerminated()`: This method returns `true` if you have called the `shutdown()`
    or `shutdownNow()` methods and the executor finishes the process of shutting it
    down.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isShutdown()`: This method returns `true` if you have called the `shutdown()`
    method of the executor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`awaitTermination(long``timeout,``TimeUnit``unit)`: This method blocks the
    calling thread until the tasks of the executor have ended or the timeout occurs.
    The `TimeUnit` class is an enumeration with the following constants: `DAYS`, `HOURS`,
    `MICROSECONDS`, `MILLISECONDS`, `MINUTES`, `NANOSECONDS`, and `SECONDS`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you want to wait for the completion of the tasks, regardless of their duration,
    use a big timeout, for example, `DAYS`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Controlling rejected tasks of an executor* recipe in [Chapter 4](ch04.html
    "Chapter 4. Thread Executors"), *Thread Executors*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Monitoring an Executor framework* recipe in [Chapter 8](ch08.html "Chapter 8. Testing
    Concurrent Applications"), *Testing Concurrent Applications*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a fixed-size thread executor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you use basic `ThreadPoolExecutor` created with the `newCachedThreadPool()`
    method of the `Executors` class, you can have a problem with the number of threads
    the executor is running at a time. The executor creates a new thread for each
    task that receives, (if there is no pooled thread free) so, if you send a large
    number of tasks and they have long duration, you can overload the system and provoke
    a poor performance of your application.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to avoid this problem, the `Executors` class provides a method to
    create a fixed-size thread executor. This executor has a maximum number of threads.
    If you send more tasks than the number of threads, the executor won't create additional
    threads and the remaining tasks will be blocked until the executor has a free
    thread. With this behavior, you guarantee that the executor won't yield a poor
    performance of your application.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you are going to learn how to create a fixed-size thread executor
    modifying the example implemented in the first recipe of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You should read the *Creating a thread executor* recipe in this chapter and
    implement the example explained in it, because you're going to modify this example.
  prefs: []
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: Implement the example described in the first recipe of this chapter. Open the
    `Server` class and modify its constructor. Use the `newFixedThreadPool()` method
    to create the executor and pass the number `5` as the parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Modify the `executeTask()` method including an additional line of log message.
    Call the `getTaskCount()` method to obtain the number of tasks that have been
    sent to the executor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this case, you have used the `newFixedThreadPool()` method of the `Executors`
    class to create the executor. This method creates an executor with a maximum number
    of threads. If you send more tasks than the number of threads, the remaining tasks
    will be blocked until there is a free thread to process them This method receives
    the maximum number of threads as a parameter you want to have in your executor.
    In your case, you have created an executor with five threads.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows part of the output of one execution of this
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/7881_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To write the output of the program, you have used some methods of the `ThreadPoolExecutor`
    class, including:'
  prefs: []
  type: TYPE_NORMAL
- en: '`getPoolSize()`: This method returns the actual number of threads in the pool
    of the executor'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getActiveCount()`: This method returns the number of threads that are executing
    tasks in the executor'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can see how the output of these methods is **5**, indicating that the executor
    has five threads. It does not exceed the established maximum number of threads.
  prefs: []
  type: TYPE_NORMAL
- en: When you send the last task to the executor, it has only **5** active threads.
    The remaining 95 tasks are waiting for free threads. We used the `getTaskCount()`
    method to show how many you have sent to the executor.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Executors` class also provides the `newSingleThreadExecutor()` method.
    This is an extreme case of a fixed-size thread executor. It creates an executor
    with only one thread, so it can only execute one task at a time.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Creating a thread executor* recipe in [Chapter 4](ch04.html "Chapter 4. Thread
    Executors"), *Thread Executors*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Monitoring an Executor framework* recipe in [Chapter 8](ch08.html "Chapter 8. Testing
    Concurrent Applications"), *Testing Concurrent Applications*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executing tasks in an executor that returns a result
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the advantages of the Executor framework is that you can run concurrent
    tasks that return a result. The Java Concurrency API achieves this with the following
    two interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Callable`: This interface has the `call()` method. In this method, you have
    to implement the logic of a task. The `Callable` interface is a parameterized
    interface, meaning you have to indicate the type of data the `call()` method will
    return.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Future`: This interface has some methods to obtain the result generated by
    a `Callable` object and to manage its state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to implement tasks that return a result and
    run them on an executor.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a class named `FactorialCalculator`. Specify that it implements the `Callable`
    interface parameterized with the `Integer` type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '`Declare` a private `Integer` attribute called `number` to store the number
    that this task will use for its calculations.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Implement the constructor of the class that initializes the attribute of the
    class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `call()` method. This method returns the factorial of the `number`
    attribute of `FactorialCalculator`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: First, create and initialize the internal variables used in the method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: If the number is `0` or `1`, return `1`. Otherwise, calculate the factorial
    of the number. Between two multiplications, and for educational purposes, put
    this task to sleep for 20 milliseconds.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Write a message to the console with the result of the operation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Return the result of the operation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Implement the main class of the example by creating a class named `Main` and
    implement the `main()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Create `ThreadPoolExecutor` to run the tasks using the `newFixedThreadPool()`
    method of the `Executors` class. Pass `2` as the parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Create a list of `Future<Integer>` objects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Create a random number generator with the `Random` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Generate 10 new random integers between zero and 10.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Create a `FactorialCaculator` object passing this random number as a parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Call the `submit()` method of the executor to send the `FactorialCalculator`
    task to the executor. This method returns a `Future<Integer>` object to manage
    the task, and eventually get its result.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Add the `Future` object to the list created before.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Create a `do` loop to monitor the status of the executor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: First, write a message to the console indicating the number of completed tasks
    with the `getCompletedTaskNumber()` method of the executor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Then, for the 10 `Future` objects in the list, write a message indicating whether
    the tasks that it manages have finished or not using the `isDone()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Put the thread to sleep for 50 milliseconds.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Repeat this loop while the number of completed tasks of the executor is less
    than 10.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Write to the console the results obtained by each task. For each `Future` object,
    get the `Integer` object returned by its task using the `get()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Then, print the number to the console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Finally, call the `shutdown()` method of the executor to finalize its execution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, you have learned how to use the `Callable` interface to launch
    concurrent tasks that return a result. You have implemented the `FactorialCalculator`
    class that implements the `Callable` interface with `Integer` as the type of the
    result. Hence, it returns before type of the `call()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other critical point of this example is in the `Main` class. You send a
    `Callable` object to be executed in an executor using the `submit()` method. This
    method receives a `Callable` object as a parameter and returns a `Future` object
    that you can use with two main objectives:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can control the status of the task: you can cancel the task and check if
    it has finished. For this purpose, you have used the `isDone()` method to check
    if the tasks had finished.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can get the result returned by the `call()` method. For this purpose, you
    have used the `get()` method. This method waits until the `Callable` object has
    finished the execution of the `call()` method and has returned its result. If
    the thread is interrupted while the `get()` method is waiting for the result,
    it throws an `InterruptedException` exception. If the `call()` method throws an
    exception, this method throws an `ExecutionException` exception.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you call the `get()` method of a `Future` object and the task controlled
    by this object hasn't finished yet, the method blocks until the task finishes.
    The `Future` interface provides another version of the `get()` method.
  prefs: []
  type: TYPE_NORMAL
- en: '`get(long``timeout,``TimeUnit``unit)`: This version of the get method, if the
    result of the task isn''t available, waits for it for the specified time. If the
    specified period of time passes and the result isn''t yet available, the method
    returns a `null` value. The `TimeUnit` class is an enumeration with the following
    constants: `DAYS`, `HOURS`, `MICROSECONDS`, `MILLISECONDS`, `MINUTES`, `NANOSECONDS`,
    and `SECONDS`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Creating a thread executor* recipe in [Chapter 4](ch04.html "Chapter 4. Thread
    Executors"), *Thread Executors*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Running multiple tasks and processing the first result* recipe in [Chapter
    4](ch04.html "Chapter 4. Thread Executors"), *Thread Executors*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Running multiple tasks and processing all the results* recipe in [Chapter
    4](ch04.html "Chapter 4. Thread Executors"), *Thread Executors*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running multiple tasks and processing the first result
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A common problem in concurrent programming is when you have various concurrent
    tasks that solve a problem, and you are only interested in the first result of
    those tasks. For example, you want to sort an array. You have various sort algorithms.
    You can launch all of them and get the result of the first one that sorts these,
    that is, the fastest sorting algorithm for a given array.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to implement this scenario using the `ThreadPoolExecutor`
    class. You are going to implement an example where a user can be validated by
    two mechanisms. The user will be validated if one of those mechanisms validates
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a class named `UserValidator` that will implement the process of user
    validation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Declare a private `String` attribute named `name` that will store the name of
    a user validation system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Implement the constructor of the class that initializes its attributes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `validate()` method. It receives two `String` parameters with
    the name and the password of the user you want to validate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Create a `Random` object named `random`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Wait for a random period of time to simulate the process of user validation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Return a random `Boolean` value. The method returns a `true` value when the
    user is validated and a `false` value when the user is not validated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `getName()` method. This method returns the value of the name
    attribute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Now, create a class named `TaskValidator` that will execute a validation process
    with a `UserValidation` object as a concurrent task. Specify that it implements
    the `Callable` interface parameterized with the `String` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Declare a private `UserValidator` attribute named `validator`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Declare two private `String` attributes named `user` and `password`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Implement the constructor of the class that will initialize all the attributes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `call()` method that will return a `String` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: If the user is not validated by the `UserValidator` object, write a message
    to the console indicating this circumstance and throw an `Exception` exception.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Otherwise, write a message to the console indicating that the user has been
    validated and return the name of the `UserValidator` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Now, implement the main class of the example by creating a class named `Main`
    and add the `main()` method to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Create two `String` objects named `user` and `password` and initialize them
    with the `test` value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Create two `UserValidator` objects named `ldapValidator` and `dbValidator`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Create two `TaskValidator` objects named `ldapTask` and `dbTask`. Initialize
    them with `ldapValidator` and `dbValidator` respectively.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Create a list of `TaskValidator` objects and add to it the two objects that
    you have created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Create a new `ThreadPoolExecutor` object using the `newCachedThreadPool()` method
    of the `Executors` class and a `String` object named `result`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Call the `invokeAny()` method of the `executor` object. This method receives
    `taskList` as a parameter and returns `String`. Also, it writes the `String` object
    returned by this method to the console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Terminate the executor using the `shutdown()` method and write a message to
    the console to indicate that the program has ended.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The key of the example is in the `Main` class. The `invokeAny()` method of the
    `ThreadPoolExecutor` class receives a list of tasks, launches them, and returns
    the result of the first task that finishes without throwing an exception. This
    method returns the same data type that the `call()` method of the tasks you launch
    returns. In this case, it returns a `String` value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the output of an execution of the example when
    one task validates the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/7881_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The example has two `UserValidator` objects that return a random `boolean` value.
    Each `UserValidator` object is used by a `Callable` object, implemented by the
    `TaskValidator` class. If the `validate()` method of the `UserValidator` class
    returns a `false` value, the `TaskValidator` class throws `Exception`. Otherwise,
    it returns the `true` value.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we have two tasks that can return the `true` value or throw an `Exception`
    exception. You can have the following four possibilities:'
  prefs: []
  type: TYPE_NORMAL
- en: Both tasks return the `true` value. The result of the `invokeAny()` method is
    the name of the task that finishes in the first place.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first task returns the `true` value and the second one throws `Exception`.
    The result of the `invokeAny()` method is the name of the first task.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first task throws `Exception` and the second one returns the `true` value.
    The result of the `invokeAny()` method is the name of the second task.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both tasks throw `Exception`. In that class, the `invokeAny()` method throws
    an `ExecutionException` exception.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you run the examples several times, you get the four possible solutions you
    can get.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the output of the application when both tasks
    throw an exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/7881_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `ThreadPoolExecutor` class provides another version of the `invokeAny()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '`invokeAny(Collection<?``extends``Callable<T>>``tasks,``long``timeout,``TimeUnit``unit)`:
    This method executes all the tasks and returns the result of the first one that
    finishes without throwing an exception, if it finishes before the given timeout
    passes. The `TimeUnit` class is an enumeration with the following constants: `DAYS`,
    `HOURS`, `MICROSECONDS`, `MILLISECONDS`, `MINUTES`, `NANOSECONDS`, and `SECONDS`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Running multiple tasks and processing all the results* recipe in [Chapter
    4](ch04.html "Chapter 4. Thread Executors"), *Thread Executors*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running multiple tasks and processing all the results
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Executor framework allows you to execute concurrent tasks without worrying
    about thread creation and execution. It provides you the `Future` class that you
    can use to control the status and get the results of any task executed in an executor.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you want to wait for the finalization of a task, you can use the following
    two methods:'
  prefs: []
  type: TYPE_NORMAL
- en: The `isDone()` method of the `Future` interface returns `true` if the task has
    finished its execution.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `awaitTermination()` method of the `ThreadPoolExecutor` class puts the thread
    to sleep until all the tasks have finished their execution after a call to the
    `shutdown()` method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These two methods have some drawbacks. With the first one, you can only control
    the completion of a task, and with the second one, you have to shutdown the executor
    to wait for a thread, otherwise the method's call returns immediately.
  prefs: []
  type: TYPE_NORMAL
- en: The `ThreadPoolExecutor` class provides a method that allows you to send to
    the executor a list of tasks and wait for the finalization of all the tasks in
    the list. In this recipe, you will learn how to use this feature by implementing
    an example with three tasks executed and their results printed out when they finish.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a class named `Result` to store the results generated in the concurrent
    tasks of this example.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Declare two private attributes. One `String` attribute named `name` and one
    `int` attribute named `value`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Implement the corresponding `get()` and `set()` methods to set and return the
    value of the name and value attributes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Create a class named `Task` that implements the `Callable` interface parameterized
    with the `Result` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Declare a private `String` attribute named `name`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Implement the constructor of the class that initializes its attribute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `call()` method of the class. In this case, this method will return
    a `Result` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: First, write a message to the console to indicate that the task is starting.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Then, wait for a random period of time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: To generate an `int` value to return in the `Result` object, calculate the sum
    of five random numbers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Create a `Result` object and initialize it with the name of this task and the
    result of the operation done earlier.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Write a message to the console to indicate that the task has finished.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Return the `Result` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Finally, implement the main class of the example by creating a class named `Main`
    and add the `main()` method to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Create a `ThreadPoolExecutor` object using the `newCachedThreadPool()` method
    of the `Executors` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Create a list of `Task` objects. Create three `Task` objects and save them on
    that list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Create a list of `Future` objects. These objects are parameterized with the
    `Result` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Call the `invokeAll()` method of the `ThreadPoolExecutor` class. This class
    will return the list of the `Future` objects created earlier.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Finalize the executor using the `shutdown()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Write the results of the tasks processing the list of the `Future` objects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, you have learned how to send a list of tasks to an executor
    and wait for the finalization of all of them using the `invokeAll()` method. This
    method receives a list of the `Callable` objects and returns a list of the `Future`
    objects. This list will have a `Future` object per task in the list. The first
    object in the list of the `Future` objects will be the object that controls the
    first task in the list of the `Callable` objects, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first point to take into consideration is that the type of data used for
    the parameterization of the `Future` interface in the declaration of the list
    that stores the result objects must be compatible with the one used to parameterized
    the `Callable` objects. In this case, you have used the same type of data: the
    `Result` class.'
  prefs: []
  type: TYPE_NORMAL
- en: Another important point about the `invokeAll()` method is that you will use
    the `Future` objects only to get the results of the tasks. As the method finishes
    when all the tasks have finished, if you call the `isDone()` method of the `Future`
    objects that is returned, all the calls will return the `true` value.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `ExecutorService` class provides another version of the `invokeAll()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '`invokeAll(Collection<?``extends``Callable<T>>``tasks,``long``timeout,``TimeUnit``unit)`:
    This method executes all the tasks and returns the result of their execution when
    all of them have finished, if they finish before the given timeout passes. The
    `TimeUnit` class is an enumeration with the following constants: `DAYS`, `HOURS`,
    `MICROSECONDS`, `MILLISECONDS`, `MINUTES`, `NANOSECONDS`, and `SECONDS`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Executing tasks in an executor that returns a result* recipe in [Chapter
    4](ch04.html "Chapter 4. Thread Executors"), *Thread Executors*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Running multiple tasks and processing the first result* recipe in [Chapter
    4](ch04.html "Chapter 4. Thread Executors"), *Thread Executors*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running a task in an executor after a delay
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Executor framework provides the `ThreadPoolExecutor` class to execute `Callable`
    and `Runnable` tasks with a pool of threads, which avoid you all the thread creation
    operations. When you send a task to the executor, it's executed as soon as possible,
    according to the configuration of the executor. There are used cases when you
    are not interested in executing a task as soon as possible. You may want to execute
    a task after a period of time or to execute a task periodically. For these purposes,
    the Executor framework provides the `ScheduledThreadPoolExecutor` class.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to create `ScheduledThreadPoolExecutor` and
    how to use it to schedule execution of a task after a given period of time.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a class named `Task` that implements the `Callable` interface parameterized
    with the `String` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Declare a private `String` attribute named `name` that will store the name of
    the task.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Implement the constructor of the class that initializes the `name` attribute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `call()` method. Write a message to the console with the actual
    date and return a text, for example, `Hello, world`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: Implement the main class of the example by creating a class named `Main` and
    add the `main()` method to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: Create an executor of the `ScheduledThreadPoolExecutor` class using the `newScheduledThreadPool()`
    method of the `Executors` class passing `1` as a parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Initialize and start a few tasks (five in our case) with the `schedule()` method
    of the `ScheduledThreadPoolExecutor` instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: Request the finalization of the executor using the `shutdown()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: Wait for the finalization of all the tasks using the `awaitTermination()` method
    of the executor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: Write a message to indicate the time when the program finishes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The key point of this example is the `Main` class and the management of `ScheduledThreadPoolExecutor`.
    As with class `ThreadPoolExecutor`, to create a scheduled executor, Java recommends
    the utilization of the `Executors` class. In this case, you have to use the `newScheduledThreadPool()`
    method. You have passed the number `1` as a parameter to this method. This parameter
    is the number of threads you want to have in the pool.
  prefs: []
  type: TYPE_NORMAL
- en: 'To execute a task in this scheduled executor after a period of time, you have
    to use the `schedule()` method. This method receives the following three parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: The task you want to execute
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The period of time you want the task to wait before its execution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The unit of the period of time, specified as a constant of the `TimeUnit` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this case, each task will wait for a number of seconds (`TimeUnit.SECONDS`)
    equal to its position in the array of tasks plus one.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you want to execute a task at a given time, calculate the difference between
    that date and the current date and use that difference as the delay of the task.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the output of an execution of this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/7881_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can see how the tasks start their execution one per second. All the tasks
    are sent to the executor at the same time, but each one with a delay of 1 second
    later than the previous task.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can also use the `Runnable` interface to implement the tasks, because the
    `schedule()` method of the `ScheduledThreadPoolExecutor` class accepts both types
    of tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Although the `ScheduledThreadPoolExecutor` class is a child class of the `ThreadPoolExecutor`
    class and, therefore, inherits all its features, Java recommends the utilization
    of `ScheduledThreadPoolExecutor` only for scheduled tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you can configure the behavior of the `ScheduledThreadPoolExecutor`
    class when you call the `shutdown()` method and there are pending tasks waiting
    for the end of their delay time. The default behavior is that those tasks will
    be executed despite the finalization of the executor. You can change this behavior
    using the `setExecuteExistingDelayedTasksAfterShutdownPolicy()` method of the
    `ScheduledThreadPoolExecutor` class. With `false`, at the time of `shutdown()`,
    pending tasks won't get executed.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Executing tasks in an executor that returns a result* recipe in [Chapter
    4](ch04.html "Chapter 4. Thread Executors"), *Thread Executors*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running a task in an executor periodically
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Executor framework provides the `ThreadPoolExecutor` class to execute concurrent
    tasks using a pool of threads that avoids you all the thread creation operations.
    When you send a task to the executor, according to its configuration, it executes
    the task as soon as possible. When it ends, the task is deleted from the executor
    and, if you want to execute them again, you have to send it again to the executor.
  prefs: []
  type: TYPE_NORMAL
- en: But the Executor framework provides the possibility of executing periodic tasks
    through the `ScheduledThreadPoolExecutor` class. In this recipe, you will learn
    how to use this functionality of that class to schedule a periodic task.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a class named `Task` and specify that it implements the `Runnable` interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: Declare a private `String` attribute named `name` that will store the name of
    the task.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: Implement the constructor of the class that initializes that attribute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `run()` method. Write a message to the console with the actual
    date to verify that the task is executed within the specified period.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: Implement the main class of the example by creating a class named `Main` and
    implement the `main()` method in it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: Create `ScheduledThreadPoolExecutor` using the `newScheduledThreadPool()` method
    of the `Executors` class. Pass the number `1` as the parameter to that method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: Write a message to the console with the actual date.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: Create a new `Task` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: Send it to the executor using the `scheduledAtFixRate()` method. Use as parameters
    the task created earlier, the number one, the number two, and the constant `TimeUnit.SECONDS`.
    This method returns a `ScheduledFuture` object that you can use to control the
    status of the task.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: Create a loop with 10 steps to write the time remaining for the next execution
    of the task. In the loop, use the `getDelay()` method of the `ScheduledFuture`
    object to get the number of milliseconds until the next execution of the task.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: Finish the executor using the `shutdown()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: Put the thread to sleep for 5 seconds to verify that the periodic tasks have
    finished.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: Write a message to indicate the end of the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you want to execute a periodic task using the Executor framework, you need
    a `ScheduledExecutorService` object. To create it (as with every executor), Java
    recommends the use of the `Executors` class. This class works as a factory of
    executor objects. In this case, you should use the `newScheduledThreadPool()`
    method to create a `ScheduledExecutorService` object. That method receives as
    a parameter the number of threads of the pool. As you have only one task in this
    example, you have passed the value `1` as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have the executor needed to execute a periodic task, you send the
    task to the executor. You have used the `scheduledAtFixedRate()` method. This
    method accepts four parameters: the task you want to execute periodically, the
    delay of time until the first execution of the task, the period between two executions,
    and the time unit of the second and third parameters. It''s a constant of the
    `TimeUnit` class. The `TimeUnit` class is an enumeration with the following constants:
    `DAYS`, `HOURS`, `MICROSECONDS`, `MILLISECONDS`, `MINUTES`, `NANOSECONDS`, and
    `SECONDS`.'
  prefs: []
  type: TYPE_NORMAL
- en: An important point to consider is that the period between two executions is
    the period of time between these two executions that begins. If you have a periodic
    task that takes 5 sceconds to execute and you put a period of 3 seconds, you will
    have two instances of the task executing at a time.
  prefs: []
  type: TYPE_NORMAL
- en: The method `scheduleAtFixedRate()` returns a `ScheduledFuture` object, which
    extends the `Future` interface, with methods to work with scheduled tasks. `ScheduledFuture`
    is a parameterized interface. In this example, as your task is a `Runnable` object
    that is not parameterized, you have to parameterize them with the `?` symbol as
    a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: You have used one method of the `ScheduledFuture` interface. The `getDelay()`
    method returns the time until the next execution of the task. This method receives
    a `TimeUnit` constant with the time unit in which you want to receive the results.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the output of an execution of the example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/7881_04_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can see the task executing every 2 seconds (denoted with `Task:` prefix)
    and the delay written in the console every 500 milliseconds. That's how long the
    main thread has been put to sleep. When you shut down the executor, the scheduled
    task ends its execution and you don't see more messages in the console.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`ScheduledThreadPoolExecutor` provides other methods to schedule periodic tasks.
    It is the `scheduleWithFixedRate()` method. It has the same parameters as the
    `scheduledAtFixedRate()` method, but there is a difference worth noticing. In
    the `scheduledAtFixedRate()` method, the third parameter determines the period
    of time between the starting of two executions. In the `scheduledWithFixedRate()`
    method, parameter determines the period of time between the end of an execution
    of the task and the beginning of the next execution.'
  prefs: []
  type: TYPE_NORMAL
- en: You can also configure the behavior of an instance of the `ScheduledThreadPoolExecutor`
    class with the `shutdown()` method. The default behavior is that the scheduled
    tasks finish when you call that method. You can change this behavior using the
    `setContinueExistingPeriodicTasksAfterShutdownPolicy()` method of the `ScheduledThreadPoolExecutor`
    class with a `true` value. The periodic tasks won't finish upon calling the `shutdown()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Creating a thread executor* recipe in [Chapter 4](ch04.html "Chapter 4. Thread
    Executors"), *Thread Executors*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Running a task in an executor after a delay* recipe in [Chapter 4](ch04.html
    "Chapter 4. Thread Executors"), *Thread Executors*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Canceling a task in an executor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you work with an executor, you don't have to manage threads. You only implement
    the `Runnable` or `Callable` tasks and send them to the executor. It's the executor
    that's responsible for creating threads, managing them in a thread pool, and finishing
    them if they are not needed. Sometimes, you may want to cancel a task that you
    sent to the executor. In that case, you can use the `cancel()` method of `Future`
    that allows you to make that cancellation operation. In this recipe, you will
    learn how to use this method to cancel the tasks that you have sent to an executor.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a class named `Task` and specify that it implements the `Callable` interface
    parameterized with the `String` class. Implement the `call()` method. Write a
    message to the console and put it to sleep for 100 milliseconds inside an infinite
    loop.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: Implement the main class of the example by creating a class named `Main` and
    add the `main()` method to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: Create a `ThreadPoolExecutor` object using the `newCachedThreadPool()` method
    of the `Executors` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: Create a new `Task` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: Send the task to the executor using the `submit()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: Put the main task to sleep for 2 seconds.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: Cancel the execution of the task using the `cancel()` method of the `Future`
    object named `result` returned by the `submit()` method. Pass the `true` value
    as a parameter of the `cancel()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: Write to the console the result of a calling to the methods `isCancelled()`
    and `isDone()` to verify that the task has been canceled and hence, is already
    done.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: Finish the executor with the `shutdown()` method and write a message indicating
    the finalization of the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You use the `cancel()` method of the `Future` interface when you want to cancel
    a task that you have sent to an executor. Depending on the parameter of the `cancel()`
    method and the status of the task, the behavior of this method is different:'
  prefs: []
  type: TYPE_NORMAL
- en: If the task has finished or has been canceled earlier or it can't be canceled
    for other reasons, the method will return the `false` value and the task won't
    be canceled.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the task is waiting in the executor to get a `Thread` object that will execute
    it, the task is canceled and never begins its execution. If the task is already
    running, it depends on the parameter of the method. The `cancel()` method receives
    a `Boolean` value as a parameter. If the value of that parameter is `true` and
    the task is running, it will be canceled. If the value of the parameter is `false`
    and the task is running, it won't be canceled.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following screenshot shows the output of an execution of this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/7881_04_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you use the `get()` method of a `Future` object that controls a task that
    has been canceled, the `get()` method will throw a `CancellationException` exception.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Executing tasks in an executor that returns a result* recipe in [Chapter
    4](ch04.html "Chapter 4. Thread Executors"), *Thread Executors*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling a task finishing in an executor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `FutureTask` class provides a method called `done()` that allows you to
    execute some code after the finalization of a task executed in an executor. It
    can be used to make some post-process operations, generating a report, sending
    results by e-mail, or releasing some resources. This method is called internally
    by the `FutureTask` class when the execution of the task that this `FutureTask`
    object is controlling finishes. The method is called after the result of the task
    is set and its status is changed to the `isDone` status, regardless of whether
    the task has been canceled or finished normally.
  prefs: []
  type: TYPE_NORMAL
- en: By default, this method is empty. You can override the `FutureTask` class and
    implement this method to change this behavior. In this recipe, you will learn
    how to override this method to execute code after the finalization of the tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or other IDE such as NetBeans, open it and create a new Java project..
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a class named `ExecutableTask` and specify that it implements the `Callable`
    interface parameterized with the `String` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: Declare a private `String` attribute named `name`. It will store the name of
    the task. Implement the method `getName()` to return the value of this attribute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: Implement the constructor of the class to initialize the name of the task.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `call()` method. Put the task to sleep for a random period of
    time and return a message with the name of the task.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: Implement a class named `ResultTask` that extends the `FutureTask` class parameterized
    with the `String` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: Declare a private `String` attribute named `name`. It will store the name of
    the task.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: Implement the constructor of the class. It has to receive a `Callable` object
    as a parameter. Call the constructor of the parent class and initialize the `name`
    attribute using the attribute of the task received.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: Override the `done()` method. Check the value of the `isCancelled()` method
    and write a different message to the console depending on the returned value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: Implement the main class of the example by creating a class named `Main` and
    add the `main()` method to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: Create `ExecutorService` using the `newCachedThreadPool()` method of the `Executors`
    class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: Create an array to store five `ResultTask` objects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: Initialize the `ResultTask` objects. For each position in the array, first,
    you have to create `ExecutorTask` and then `ResultTask` using that object. Then,
    send to the executor `ResultTask` using the `submit()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: Put the main thread to sleep for 5 seconds.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: Cancel all the tasks you have sent to the executor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: Write to the console the result of those tasks that haven't been canceled using
    the `get()` method of the `ResultTask` objects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: Finish the executor using the `shutdown()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `done()`method is called by the `FutureTask` class when the task that is
    being controlled finishes its execution. In this example, you have implemented
    a `Callable` object, the `ExecutableTask` class, and then, a subclass of the `FutureTask`
    class that controls the execution of the `ExecutableTask` objects.
  prefs: []
  type: TYPE_NORMAL
- en: The `done()` method is called internally by the `FutureTask` class after establishing
    the return value and changing the status of the task to the `isDone` status. You
    can't change the result value of the task or change its status, but you can close
    resources used by the task, write log messages, or send notifications.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Executing tasks in an executor that returns a result* recipe in [Chapter
    4](ch04.html "Chapter 4. Thread Executors"), *Thread Executors*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Separating the launching of tasks and the processing of their results in an
    executor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Normally, when you execute concurrent tasks using an executor, you will send
    `Runnable` or `Callable` tasks to the executor and get `Future` objects to control
    the method. You can find situations, where you need to send the tasks to the executor
    in one object and process the results in another one. For such situations, the
    Java Concurrency API provides the `CompletionService` class.
  prefs: []
  type: TYPE_NORMAL
- en: This `CompletionService` class has a method to send the tasks to an executor
    and a method to get the `Future` object for the next task that has finished its
    execution. Internally, it uses an `Executor` object to execute the tasks. This
    behavior has the advantage to share a `CompletionService` object, and sends tasks
    to the executor so the others can process the results. The limitation is that
    the second object can only get the `Future` objects for those tasks that have
    finished its execution, so these `Future` objects can only be used to get the
    results of the tasks.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to use the `CompletionService` class to separate
    launching tasks in an executor from processing their results.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a class named `ReportGenerator` and specify that it implements the `Callable`
    interface parameterized with the `String` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: Declare two private `String` attributes named `sender` and `title` that will
    represent data for the report.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: Implement the constructor of the class that initializes the two attributes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `call()` method. First, put the thread to sleep for a random period
    of time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: Then, generate the report as a string with the sender and title attributes and
    return that string.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: Create a class named `ReportRequest` and specify that it implements the `Runnable`
    interface. This class will simulate some report requests.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: Declare a private `String` attribute named `name` to store the name of `ReportRequest`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: Declare a private `CompletionService` attribute named `service`. The `CompletionService`
    interface is a parameterized interface. Use the `String` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: Implement the constructor of the class that initializes the two attributes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `run()` method. Create three `ReportGenerator` objects and send
    them to the `CompletionService` object using the `submit()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: Create a class named `ReportProcessor`. This class will get the results of the
    `ReportGenerator` tasks. Specify that it implements the `Runnable` interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: Declare a private `CompletionService` attribute named `service`. As the `CompletionService`
    interface is a parameterized interface, use the `String` class as parameter of
    this `CompletionService` interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: Declare a private `boolean` attribute named `end`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: Implement the constructor of the class to initialize the two attributes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `run()` method. While the attribute `end` is `false`, call the
    `poll()` method of the `CompletionService` interface to get the `Future` object
    of the next task executed by the completion service that has finished.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: Then, get the results of the task using the `get()` method of the `Future` object
    and write those results to the console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `setEnd()` method that modifies the value of the end attribute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: Implement the main class of the example by creating a class named `Main` and
    add the `main()` method to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: Create `ThreadPoolExecutor` using the `newCachedThreadPool()` method of the
    `Executors` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: Create `CompletionService` using the executor created earlier as a parameter
    of the constructor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: Create two `ReportRequest` objects and the threads to execute them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: Create a `ReportProcessor` object and the thread to execute it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: Start the three threads.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: Wait for the finalization of the `ReportRequest` threads.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: Finish the executor using the `shutdown()` method and wait for the finalization
    of the tasks with the `awaitTermination()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: Finish the execution of the `ReportSender` object setting the value of its end
    attribute to `true`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the main class of the example, you have created `ThreadPoolExecutor` using
    the `newCachedThreadPool()` method of the `Executors` class. Then, you have used
    that object to initialize a `CompletionService` object because the completion
    service uses an executor to execute its tasks. To execute a task using the completion
    service, you use the `submit()` method as in the `ReportRequest` class.
  prefs: []
  type: TYPE_NORMAL
- en: When one of these tasks is executed when the completion service finishes its
    execution, the completion service stores the `Future` object used to control its
    execution in a queue. The `poll()` method accesses this queue to see if there
    is any task that has finished its execution and, if so, returns the first element
    of that queue which is a `Future` object for a task that has finished its execution.
    When the `poll()` method returns a `Future` object, it deletes it from the queue.
    In this case, you have passed two attributes to that method to indicate the time
    you want to wait for the finalization of a task, in case the queue with the results
    of the finished tasks is empty.
  prefs: []
  type: TYPE_NORMAL
- en: Once the `CompletionService` object is created, you create two `ReportRequest`
    objects that execute three `ReportGenerator` tasks, each one in `CompletionService`,
    and a `ReportSender` task that will process the results generated by the tasks
    sent by the two `ReportRequest` objects.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `CompletionService` class can execute `Callable` or `Runnable` tasks. In
    this example, you have used `Callable`, but you could also send `Runnable` objects.
    Since `Runnable` objects don't produce a result, the philosophy of the `CompletionService`
    class doesn't apply in such cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'This class also provides two other methods to obtain the `Future` objects of
    the finished tasks. These methods are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`poll()`: The version of the `poll()` method without arguments checks if there
    are any `Future` objects in the queue. If the queue is empty, it returns `null`
    immediately. Otherwise, it returns its first element and removes it from the queue.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`take()`: This method, without arguments, checks if there are any `Future`
    objects in the queue. If it is empty, it blocks the thread until the queue has
    an element. When the queue has elements, it returns and deletes its first element
    from the queue.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Executing tasks in an executor that returns a result* recipe in [Chapter
    4](ch04.html "Chapter 4. Thread Executors"), *Thread Executor*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling rejected tasks of an executor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you want to finish the execution of an executor, you use the `shutdown()`
    method to indicate that it should finish. The executor waits for the completion
    of the tasks that are running or waiting for their execution, and then finishes
    its execution.
  prefs: []
  type: TYPE_NORMAL
- en: If you send a task to an executor between the `shutdown()` method and the end
    of its execution, the task is rejected, because the executor no longer accepts
    new tasks. The `ThreadPoolExecutor` class provides a mechanism, which is called
    when a task is rejected.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to manage rejecting tasks in an executor
    that is implementing with `RejectedExecutionHandler`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a class named `RejectedTaskController` that implements the `RejectedExecutionHandler`
    interface. Implement the `rejectedExecution()` method of that interface. Write
    to the console the name of the task that has been rejected and the name and status
    of the executor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: Implement a class named `Task` and specify that it implements the `Runnable`
    interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: Declare a private `String` attribute named `name`. It will store the name of
    the task.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: Implement the constructor of the class. It will initialize the attribute of
    the class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: Implement the `run()` method. Write a message to the console to indicate the
    starting of the method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: Wait for a random period of time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: Write a message to the console to indicate the finalization of the method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: Override the `toString()` method. Return the name of the task.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: Implement the main class of the example by creating a class named `Main` and
    add the `main()` method to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: Create a `RejectedTaskController` object to manage the rejected tasks.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: Create `ThreadPoolExecutor` using the `newCachedThreadPool()` method of the
    `Executors` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: Establish the rejected task controller of the executor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: Create three tasks and send them to the executor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: Shutdown the executor using the `shutdown()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: Create another task and send it to the executor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: Write a message to the console to indicate the finalization of the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the following screenshot, you can see the result of an execution of the
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/7881_04_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can see that the task is rejected when execution has been shut down and
    `RejectecTaskController` writes to the console information about the task and
    the executor.
  prefs: []
  type: TYPE_NORMAL
- en: 'To manage rejected tasks for an executor, you should create a class that implements
    the `RejectedExecutionHandler` interface. This interface has a method called `rejectedExecution()`
    with two parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: A `Runnable` object that stores the task that has been rejected
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An `Executor` object that stores the executor that rejected the task
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This method is called for every task that is rejected by the executor. You need
    to establish the handler of the rejected tasks using the `setRejectedExecutionHandler()`
    method of the `Executor` class.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When an executor receives a task to execute, it checks if the `shutdown()` method
    has been called. If so, it rejects the task. First, it looks for the handler established
    with `setRejectedExecutionHandler()`. If there's one, it calls the `rejectedExecution()`
    method of that class, otherwise it throws `RejectedExecutionExeption`. This is
    a runtime exception, so you don't need to put a `catch` clause to control it.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Creating a thread executor* recipe in [Chapter 4](ch04.html "Chapter 4. Thread
    Executors"), *Thread Executors*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
