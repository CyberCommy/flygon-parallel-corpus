- en: XML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Say we would like to store information that has a structure that is meaningful
    to our program. Also, we would like this information to be human-readable to some
    degree and sometimes even human-editable. To accomplish this, we very often turn
    to XML.
  prefs: []
  type: TYPE_NORMAL
- en: Java provides us with powerful tools for manipulating, reading, and writing
    XML raw text and files. However, as is the case with many powerful tools, there's
    a bit of a knowledge overhead for us to learn how to use them. In this chapter,
    we'll first look at how to use Java to load an XML file into a Java object. Next,
    we'll walk through how to parse XML data using Java. Finally, we'll see the Java
    code to write and modify XML data.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Java code for reading XML data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parsing XML data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing and modifying XML data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading XML data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we''ll accomplish a very simple task to get ourselves started
    on the road to learning how Java interacts with XML. We''ll use the XML information
    from the `cars.xml` file, provided in the code file of the book. This file should
    be stored in the current directory of our Java project, so when we run our Java
    program, it will be able to access `cars.xml` without any additional pathing required.
    We''ll edit the following Java program to load the `cars.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Before we get started, notice that there's a whole lot of imports necessary
    for this program. The `transform` classes we have imported are not necessary for
    anything we're going to write; I've written a function called `PrintXmlDocument()`,
    which will print our XML document to the console window if we successfully load
    it. If you're following along the code in this section, I'd recommend that you
    first import these `transform` classes from the start. Then, as you use additional
    functionality, go ahead and use NetBeans' Fix Imports functionality to see exactly
    from where the libraries, that the tools were utilizing, are coming from.
  prefs: []
  type: TYPE_NORMAL
- en: So let's get started. Our end goal here is to have an object of the `Document`
    class that contains the information in our `cars.xml` file. Once we have this
    `Document` object, all we would need to do to see the information in our console
    window is to call the `PrintXmlDocument()` function on the `Document` instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, creating this `Document` object is not as simple as saying the `Document
    dom = new Document();` statement. Rather, we need to create it in a structured
    and procedural manner that will properly preserve the parsable nature of our XML
    file. To do this, we''ll make use of two additional classes: the `DocumentBuilder` and `DocumentBuilderFactory`
    classes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `DocumentBuilder` class, believe it or not, will take care of the responsibility
    of actually building the document for us. The `DocumentBuilder` class exists as
    a separate entity from the `Document` object so that we, as programmers, can logically
    separate the methodology we can perform on the document itself and the additional
    range of methodology needed to create that document in the first place. Similar
    to the `Document` class, we can''t just instantiate the `DocumentBuilder` class.
    Instead, there''s a third class we''ll utilize to get `DocumentBuilder`, the `DocumentBuilderFactory`
    class. I have divided the code required to create a `Document` object, which stores
    our XML file, into three parts:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `DocumentBuilderFactory` class contains a static method called `newInstance()`.
    Let''s add the following method call to our first `try` block in the `main()`
    method. This will instantiate `DocumentBuilderFactory` for us to work from:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have `DocumentBuilderFactory`, we can acquire for ourselves a new `DocumentBuilder`
    object. To do this, we''re going to call the factory''s `newDocumentBuilder()`
    method. Let''s add it to our try block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to instruct `DocumentBuilder` to build us a `Document` object
    and that this object should mirror the structure of our `cars.xml` file. We''ll
    simply instantiate our `Document` object with a value in our `try` block. We''ll
    acquire this value from the `parse()` method of `builder`. One of this method''s
    parameters is a string that references a filename. If we had a referenced file
    object in our Java program, we could also use that:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'So now our `main()` method looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now it''s time to check whether our code works. We acquired the `DocumentBuilderFactory` object
    using the static method of the `DocumentBuilderFactory` class, and this creates
    a brand new instance. With `DocumentBuilderFactory`, we created a new `DocumentBuilder`
    object, which will be able to intelligently parse our XML file. In parsing our
    XML file, the `DocumentBuilder` object understands the nature of the information
    contained within and is able to store it in our XML document or the `Document`
    object model element. When we run this program, we get the raw text view of the
    original XML document as output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/96ce926c-1c7d-4208-8372-e8f3e4917da1.png)'
  prefs: []
  type: TYPE_IMG
- en: Because there are so many steps to loading an XML file like this, I wanted to
    put it in its own section. This is so that down the road, when we, as programmers,
    learn about manipulating and reading valuable information from XML, we'll not
    be bogged down by all of the syntax we've seen here.
  prefs: []
  type: TYPE_NORMAL
- en: Parsing XML data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Document` class provides an easy way for us to store formatted information
    in an object. In the preceding section''s program, we read in information from
    a `cars.xml` file into our Java `Document` object. Here''s what the `cars.xml`
    file looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The root node of this file is the `cars` node and contained within this node
    are two `owner` nodes, namely Billy and Jane, each of which has a number of `car`
    nodes within them. The information stored within these `car` elements is mirrored
    by the information that can be stored by the preceding Java class we have.
  prefs: []
  type: TYPE_NORMAL
- en: Our goal in this section is to take the car information from `cars.xml` for
    only a specific owner-in this case, Jane-and store this information in our custom
    `Car` class so that we can utilize the `Car` class's `toString()` override to
    print all of Jane's cars to our console in a nicely formatted manner.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the code we have already set up, our `Document` object `dom` mirrors the
    information stored in `cars.xml` in the same format, so we simply need to figure
    out how to ask this `Document` object this question: what cars does Jane own?
    In order to figure out how to write the code, you''d need to know a little bit
    about XML terminology. We''re going to be dealing with the terms "element" and
    "node" throughout this section.'
  prefs: []
  type: TYPE_NORMAL
- en: In XML, an **element** is an entity that has a start and end tag, and it also
    contains all of the information within it. When our `Document` object returns
    information, it will often return the information in terms of nodes. **Nodes**
    are the building blocks of XML documents, and we can almost think of them as an
    inheritance relationship, where all the elements are nodes, but not all nodes
    are elements. Nodes can be much simpler and smaller than an entire XML element.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing Jane's XML element
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This section will help us access the information about the cars owned by Jane,
    using the following code. I have divided the code to be added to our `main()`
    function in six parts:'
  prefs: []
  type: TYPE_NORMAL
- en: So, in the pursuit of finding all the cars owned by Jane, let's see what functionality
    our XML document provides for us right off the bat. If we take a look at code
    completion to quickly scan through our list of methods, we can call `dom` from
    our `Document` instance. We're going to see the `getDocumentElement()` method return
    an element for us:![](img/3e2462a0-5917-4b88-93da-b4d3a49a4e49.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This is probably a good way to start. This method returns the top-level element
    in our XML; in this case, we''re going to get the `cars` element, which contains
    all of the information that we''re going to need. It also contains some information
    we don''t need, such as Billy''s cars, but we''ll parse that out after we''ve
    accessed it. Once we''ve imported the right libraries, we can directly reference
    the concept of an XML element within our code using the `Element` class. We can
    create a new `Element` object and assign its value to the root element of our
    XML document:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Of course, we need to go deeper. The root level of our XML document `cars` is
    not directly useful to us; we need the information contained within it. We only
    really want the information from one `owner` node (containing information about
    Jane's cars). But because of the way XML parsing works, it probably makes sense
    for us to first acquire both of these owner nodes and then find the one that we're
    really interested in.
  prefs: []
  type: TYPE_NORMAL
- en: To acquire both of these nodes, we can call a method on the root XML element
    we've just created and stored in `doc`. XML elements can contain other elements
    within them; in this case, our root element contains a number of `owner` elements.
    The `getElementsByTagName()` method allows us to collect a number of these inner
    elements. The tag name of an XML element is just what you would expect; it is
    the name we gave to that particular element of our XML. In this case, if we ask
    for all the elements with the tag name `owner` contained within our document's
    root element, we're going to further narrow down the amount of XML we're working
    with, getting closer to the small section we desire.
  prefs: []
  type: TYPE_NORMAL
- en: 'What''s returned by the `getElementsByTagName()`method is not a single element
    though. There are two distinct elements in this section even at the highest level,
    two owners: `Billy` and `Jane`. So, the `getElementsByTagLineName()` method doesn''t
    return a single element; instead, it returns a `NodeList` object, which is a collection
    of XML nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we''re no longer dealing with our root node at all; we only have its contents.
    It''s time for us to really narrow down our search. Our `NodeList` object contains
    multiple owners, but we only want an owner if the attribute name associated with
    that owner happens to be `Jane`. In order to find this particular element, if
    it exists, we''re simply going to loop through `NodeList`, checking the attributes
    of each element it contains. Note that `ownersList` is not a traditional array.
    It''s a `NodeList` object, its own kind of object. So, we can''t use normal array
    syntax on it. Fortunately, it exposes methods to us that mimic normal array syntax.
    For example, the `getLength()` method will tell us how many objects are in `ownersList`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, when we attempt to create a new `Element` object and assign that
    value to the currently looped-through portion of `ownersList`, we're not going
    to be able to use the normal syntax we would for an array. Once again though,
    `ownersList` provides us a method to do the same thing. The `item()` method provides,
    or asks for, an index as input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Note that `ownersList` is `NodeList`, but while elements are nodes, not all
    nodes are elements, so we need to make a decision here. We could check the nature
    of the objects that are returned by this function and assure ourselves that they
    are, in fact, XML elements. But to keep things moving, we''re just going to assume
    that our XML was properly formatted, and we''re simply going to let Java know
    that the node returned by the `item()` method is in fact an element; that is,
    it has a start tag and a closing tag and can contain other elements and nodes
    within it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Once we've successfully accessed an element from our list of owners, it's time
    to check and see whether this is the owner that we're looking for; therefore,
    we're going to need a conditional statement. XML elements expose to us the `getAttribute()`
    method, and the attribute that we're interested in is the `name` attribute. So,
    the following bit of code right here will ask the current `owner`, "What is the
    value of your `name` attribute?" If that value is equal to `Jane`, then we know
    we have accessed the right XML element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within Jane''s XML element, now we only have a number of `car` elements. So,
    once again, it''s time to create `NodeList` and populate it with these `car` elements.
    We now need to call the `getElementByTagName()` method on `Jane`, our current
    owner. If we were to use the top-level document to call this function, we would
    get all the `car` elements in the document, even Billy''s:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This `main()` method is getting a little intense; this is how far I''m willing
    to go in one method. We''re already a couple of levels deep in our code, and it''s
    not exactly simple code we''ve been writing. I think it''s time for us to parse
    out the next bit into its own method. Let''s simply declare that we''re going
    to have a `PrintCars()` method, and this function will take `NodeList` of the
    `car` elements to print the car nodes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `main` method now looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Printing Jane's car details
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, leaving our `main()` method, we''ll define our new `PrintCars()` method.
    I have divided the definition of the `PrintCars()` function into eight parts:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Because we''re in the entry class of our program and the `PrintCars()` method
    is being called by the static `main()` method, it should probably be a `static`
    function. All it''s going to do is print to our console, so `void` is an appropriate
    return type. We already know it''s going to take `NodeList` of cars as input:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we''ve entered this function, we know we have a list of `car` XML elements
    at our disposal. But in order to print each one out, we''re going to have to loop
    through them. We''ve already looped through XML `NodeList` in our program already,
    so we''re going to be using some very similar syntax. Let''s take a look at what
    needs to change for this new code. Well, we''re no longer looping through `ownersList`;
    we have a new `NodeList` object to loop through the `NodeList` of `cars`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We know that cars are still `Element` instances, so our casting a shortcut
    here is still appropriate, but we probably want to rename the variable we''re
    using for each `car` we loop through to something like `carNode`. Each time we
    loop through a car, we''re going to create a new `Car` object and store the information
    in that car''s XML in this actual Java object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'So, in addition to accessing the `car` XML, let''s also declare a `Car` object
    and just instantiate it to be a new `Car` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we''re going to build up the values stored within `carObj` by reading them
    from `carNode`. If we jump back to the XML file quickly and take a look at the
    information stored in the `car` element, we''ll see that it stores `make`, `model`,
    `year`, and `color` as XML nodes. The vehicle identification number `vin` is actually
    an attribute. Let''s take a brief look at our `Car.java` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Let's start with the easy pieces first; so, `make`, `model`, and `color` are
    all strings stored in the `Car` class and they all happen to be nodes within the
    `car` element.
  prefs: []
  type: TYPE_NORMAL
- en: Back to our `PrintCars()` function, we already know how to access nodes within
    an element. We're simply going to use `carNode` and the `getElementsByTagName()`
    function again. If we get all the elements with the tag name of `color`, we should
    get back a list that contains only a single element-the element we're interested
    in, which tells us the color of our car. Unfortunately, we do have a list here,
    so we can't manipulate that element directly until we pull it from the list. Once
    again though, we know how to do this. If we're confident that our XML is properly
    formatted, we know we'll achieve a list with exactly one item in it. Therefore,
    if we get the item at the 0th index of that list, that will be the XML element
    that we're looking for.
  prefs: []
  type: TYPE_NORMAL
- en: Color information stored in this XML element isn't an attribute though; it's
    inner text. So, we're going to take a look at what methods the XML element exposes
    and see whether there's an appropriate one to acquire the inner text. There is
    the `getTextContent()` function that will give us all of the inner text that's
    not actually part of the XML element tags. In this case, it's going to give us
    the color of our cars.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s not enough just to acquire this information; we need to store it. Fortunately,
    all of the attributes of `carObj` are public, so we can freely assign them with
    values after we''ve created our `car` object. If these were private fields without
    setters, we''d probably have to do this information before constructing `carObj`
    and then passing them through to a constructor that it would hopefully have:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re going to do pretty much the exact same thing for `make` and `model`.
    The only thing we''re going to have to change is the keyword we provide when looking
    for the elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can continue using the same general strategy for our car''s `year`,
    but we should note that as far as `carObj` is concerned, `year` is an integer.
    As far as our XML element is concerned, `year`, just like anything else, is a
    `TextContent` string. Fortunately, converting a `string` into an `integer`, as
    long as it''s well formed, which is an assumption that we''ll make here, isn''t
    too difficult. We''re simply going to use the `Integer` class and call its `parseInt()`
    method. This will do its best to convert a string value into an integer. We''ll
    assign it to the `year` field of `carObj`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This leaves only one more field for us. Note that `carObj` has a vehicle identification
    number field. This field is not actually an integer; vehicle identification numbers
    can contain letters, so this value is stored as a string. It''s going to be a
    little different for us to get though because rather than being an inner element,
    it''s actually an attribute of the `car` element itself. Once again, we know how
    to acquire an attribute from `carNode`; we''re simply going to get the attribute
    with the name `vin` and assign it to `carObj`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'With all of this done, our `carObj` object should be fully built with reasonable
    values in all of its members. Now it''s time to use `carObj` for the reason it
    exists: to override the `toString()` function. For each car we loop through, let''s
    call the `toString()` function of `carObj` and print that result to our console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `PrintCars()` function will now look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We should be good to compile our program. Now when we run it, hopefully it''ll
    print out all of Jane''s cars, making use of the overridden `toString()` method
    of `carObj`, to nicely format the output. When we run this program, we get two
    cars printed as output, and if we go to our XML and take a look at the cars assigned
    to Jane, we''ll see that this information does indeed match the information stored
    in these cars:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4d51007d-148e-44a8-a834-c655dd9fa7aa.png)'
  prefs: []
  type: TYPE_IMG
- en: The XML and Java combination is really powerful. XML is human-readable. We can
    understand it and even make modifications to it as people, but it also contains
    really valuable information in terms of how it is structured. This is something
    that programming languages, such as Java, can understand as well. The program
    we've written here-while it does have its quirks and requires a certain amount
    of knowledge to write it-is much easier to write and far easier for a programmer
    to understand and maintain than a similar program from a raw text file.
  prefs: []
  type: TYPE_NORMAL
- en: Writing XML data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Being able to read XML information is all well and good, but for the language
    to be truly useful to us, our Java programs probably need to be able to write
    out XML information as well. The following program is a bare bones model of a
    program that both reads from and writes to the same XML file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Its `main()` method is extremely simple. It takes a file and then reads XML
    from that file storing it in an XML document's tree object. Then, this program
    calls `WriteXMLDocument()` to write the XML back to the same file. Currently,
    the method that reads in the XML has been implemented for us (`LoadXMLDocument()`);
    however, the method to write out the XML is not yet complete. Let's see what needs
    to happen for us to write XML information to a document. I have divided the code
    for the `WriteXMLDocument()` function into four parts.
  prefs: []
  type: TYPE_NORMAL
- en: Java code to write XML data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are the steps to be performed for writing XML data:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Because of the way an XML document is stored, we need to convert it into a
    different format before it''s really feasible for us to print it out to a file
    in the same format in which we got the original XML. To do this, we''re going
    to make use of an XML-specific class called `Transformer`. As with a number of
    the classes we deal with when dealing with XML in the document model, `Transformer`
    instances are best created using a factory. In this case, the factory is called
    `TransformerFactory`, and like many factories, it exposes the `newInstance()`
    method, allowing us to create one when we need it. To get our new `Transformer`
    object, which will allow us to convert our `Document` object into something streamable
    that we can send to a file, we''re simply going to call the `newTransformer()`
    method of `TransformerFactory`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, before `Transformer` can transform our XML document into something else,
    it''s going to need to know what we would like it to convert our XML document''s
    information into. This class is the `StreamResult` class; it''s the target for
    the information stored within our current `Document` object. The stream is a raw
    binary information pump that can be sent to any number of targets. In this case,
    our target is going to be the destination file provided to the `StreamResult`
    constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `Transformer` object though is not automatically linked to our XML document,
    and it expects us to reference our XML document in a unique manner: as a `DOMSource`
    object. Notice that our `source` object (defined next) is being paired with the
    `result` object. The `Transformer` object, when we provide it both these objects,
    will know how to convert one to another. Now, to create our `DOMSource` object,
    we simply need to pass in our XML document:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, when all of that setup is complete, we can execute the functional
    piece of the code. Let''s grab our `Transformer` object and ask it to transform
    our source, that is, the `DOMSource` object, to a streamable result targeted at
    our destination file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The following becomes our `WriteXMLDocument()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run this program, we''ll get some XML in our file, but you''ll have
    to trust me when I say this: this is the same XML we had before, which is expected
    as we read in the XML first and then print it back as a result.'
  prefs: []
  type: TYPE_NORMAL
- en: To really test whether our program is working, we're going to need to make some
    changes to our `Document` object within the Java code and then see whether we
    can print those changes out to this file. Let's change the names of the cars'
    owners. Let's transfer the deals of all the cars to an owner called Mike.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying XML data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The power of the XML I/O system is that in between loading and writing our
    XML document, we can freely modify the `Document` object `dom` stored in memory.
    Also, the changes we make to the object in Java memory will then be written to
    our permanent XML file. So let''s begin by making some changes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re going to use `getElementsByTagName()` to get all the `owner` elements
    in our XML document. This will return a `NodeList` object and we''ll call it `owners`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: To convert the names of all of these owners to `Mike`, we're going to have to
    loop through this list. As a refresher, we can get the number of items in the
    list by calling the `getLength()` function of `owners`, that is, our `NodeList`
    object. To access the item that we're currently iterating through, we'll use the
    `item()` function of `owners` and pass in our iterating variable `i` to get the
    item at that index. Let's store this value in a variable so that we can use it
    easily; once again, we'll just assume that our XML is well formatted and inform
    Java that we are, in fact, dealing with a fully fledged XML element at this point.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, XML elements expose a number of methods that allow us to modify them.
    One of these elements is the `setAttribute()` method, and that''s what we''ll
    be using here. Note that `setAttribute()` takes two strings as input. First, it
    wants to know what attribute we''d like to modify. We''re going to be modifying
    the `name` attribute (it''s the only attribute available to us here), and we''re
    going to assign its value to `Mike`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now our `main()` method will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run our program and check our XML file, we''ll see that `Mike` is now
    the owner of all these cars as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fe46f87a-5603-44b1-89f4-7c2826e14c0a.png)'
  prefs: []
  type: TYPE_IMG
- en: Now it might make sense to combine these two XML elements so that `Mike` is
    only a single owner, not split it into two. That's a little bit out of the scope
    for this section, but it's an interesting question and one I want to encourage
    you to reflect on and maybe take a shot at right now.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we saw the Java code to read an XML file into a `Document`
    object. We also saw how to parse XML data using Java. Finally, we saw how to write
    and modify XML data in Java.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You are now a Java programmer.
  prefs: []
  type: TYPE_NORMAL
