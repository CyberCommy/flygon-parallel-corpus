- en: API Design Best Practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter discusses how to design consumer-centric APIs that are granular
    and functionality-oriented. It also discusses the various best practices for API
    design concerns, such as how to identify the resources that will be used to form
    the API, how to categorize the APIs, API error handling, API versioning, and so
    on. We will cover models for describing the API through Open API and RAML.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: API design concerns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API gateway deployment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API design concerns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The APIs are meant to be consumed and define how the API can be consumed. APIs
    specify the list of commands/operations as well as the format/schema of those
    commands that are required for interaction with the API.
  prefs: []
  type: TYPE_NORMAL
- en: When defining a REST API, the key abstraction of information is the resource.
    A resource is defined as a conceptual mapping to a set of entities. API design
    is centered around the resource that forms the nucleus of the design. **Uniform
    Resource Identifier **(**URI**), operations (using HTTP methods), and resource
    representations (JSON schema) are built keeping the resource in mind. It becomes
    very important to have the right abstraction of the resource to enable consumption,
    re-usability, and maintainability of the API.
  prefs: []
  type: TYPE_NORMAL
- en: 'The resource can point to a single entity or a collection of entities. For
    example, a product is a singular resource, whereas products are a collection of
    resources. We will cover the design guidelines at two levels:'
  prefs: []
  type: TYPE_NORMAL
- en: How to identify the right level of resource granularity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to design the API around the identified resource
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API resource identification
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The design of the API is tied to the underlying business domain model of the
    problem domain. The APIs need to be consumer-centric and focus on the needs of
    the consumer. The domain-driven design principles are applied to identify the
    right granularity. The bounded context pattern is the central pattern that helps
    in dividing the problem area into different bounded contexts and being explicit
    about their relationship. For an enterprise, the resource identification is also
    driven by the canonical models defined by the central/group architecture teams.
  prefs: []
  type: TYPE_NORMAL
- en: 'Furthermore, depending upon where the API is defined and what features/functionality
    it is exposing, APIs can be classified into three, broad categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/105a7699-7bf2-4e86-8fc5-57dd56a50515.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Let's discuss these categories in detail in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: System API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Key enterprise resources or systems of records need to be opened or exposed
    as a set of APIs for all downstream systems to build logic/experience around these
    services. For green field projects, system APIs typically represent the system
    of records or data stores that are being developed as part of the functionality.
    When it comes to enterprises, the system API represents all the enterprise systems,
    such as core **enterprise resource planning** (**ERP**) systems, operational data
    stores, mainframe applications, or many **commercial off-the-shelf** (**COTS**)
    products, such as **c****ustomer relationship management** (**CRM**), and so on
    that run the core processes of the enterprise. Some of the distinguishing features
    of system APIs are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The genesis of the domain-driven design stems from looking at the core system
    domains, and creating bounded contexts to define the system APIs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These systems of records typically map to the HTTP resource types—noun—and provide
    the entity services. For example, in the case of banking accounts, mortgages,
    securities, and cards are the core entities or nouns around which the system API
    is built.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The model of bounded context defines that the services own their data stores.
    But in the case of existing systems, such as **enterprise resource planning** (**ERP**),
    the services might share the same underlying system. This requires a careful study
    of the underlying business process, identifying the domain (aka nouns), and exposing
    them as system APIs. Accounts can be a system API but account transfer will be
    a process API that makes use of the underlying account system API to provide the
    service.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: System APIs are traditionally very stable and are agnostic of the change in
    the channel or the process API layers. These form part of the core, stable enterprise
    side.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The composition and integration mechanism of this enterprise system defines
    how the system APIs integrate with the underlying systems. For example, a mainframe
    dictates the use of MQ as the integration mechanism, leaving the system API to
    implement MQ to expose the mainframe functionality as an API.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The biggest issue with system APIs is their uptime and resiliency being tied
    to the stability of the underlying system. If the core application is going down
    frequently or has issues, these tend to get passed onto the system API layer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Process API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The purists will say that the system API exposes the core functionality of
    the systems and the applications should mash up the functionality from system
    APIs to provide the requisite functionality to the end customers. This might work
    well for smaller applications or initial iterations of your application. As the
    application grows bigger, or you start to expose the functionality across multiple
    channels or devices, you start looking at scenarios where the functionality starts
    getting replicated, which means lack of reuse resulting in harder to maintain
    systems. Some of the distinguishing features of process APIs are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Process APIs provide a richer functionality built on top of the system APIs.
    For example, instead of every channel writing an account transfer functionality,
    we can write the account transfer as a process API that gets reused across the
    channels to provide a consistent and reusable model.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From a consumer's point of view, process APIs provide a simpler model for accessing
    functionality than trying to orchestrate multiple system APIs. This helps improve
    the ease of use from the client side and helps reduce traffic at the API gateway
    level.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Process APIs can also be used to provide cross-channel/omni-channel capabilities
    to the application. Concerns such as channel context switchovers can be handled
    at this level.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applications tend to introduce process APIs to improve the performance of the
    overall systems. If the system API is tied to systems that are slow or can handle
    only limited throughput, a process API can be used to cache the data coming from
    the system API to avoid going to the underlying systems every time. In case of
    unavailability of a system of records and subsequently of the system API, the
    process API can be used to handle such requests by providing an alternate functional
    flow.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Process APIs can also act as adapters to external third-party calls instead
    of applications making third-party calls directly. Using a process API allows
    us to handle scenarios where the failure of a third-party API does not impact
    the rest of the application. A process API can apply patterns, such as circuit
    breakers and throttling outgoing requests to handle multiple scenarios.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Channel API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The final API categorization is the channel API. As the name suggests, these
    APIs are channel-specific and mapped to the customer journeys that are being built
    as part of the application. These are also referred to as experience APIs or journey
    APIs. For example, if you are building your application using Angular or React,
    customer journeys that are part of the **Single-Page Applications** (**SPA**)
    need to be mapped to underlying services that can be provided by channel APIs.
    Some of the distinguishing features of channel APIs are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Channel APIs are mapped to customer journeys, which are invariably tied to the
    channel. These are also called experience APIs at times. These APIs can be stateful
    since they serve customers during their journey and need to carry the session
    context. One can build stateless services, by externalizing the state to a session
    store such as Redis.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Channel APIs will undergo change every time there is a change in the customer
    journey. The re-usability quotient among channel APIs is not very high. It usually
    ranges between 10-15%. For example, if a similar customer journey is mapped across
    Android and iOS applications, then there are chances of the same API getting reused.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Channel APIs do not tend to have business logic or any service orchestration
    logic, as these concerns tend to be handled by the process API layer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Concerns such as security (CQRS, CORS), authentication, authorization, throttling,
    and so on are handled at the API gateway level and not passed onto the channel
    API layer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At times, during API development one might have done such a rigid differentiation
    and definition of APIs. But over the course of many application iterations, such
    differentiations start appearing in the API and one can start seeing the application
    moving toward these classifications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we will cover API design guidelines that are applicable to the three classifications
    we saw.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API design guidelines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once the right level of resource granularity has been identified, the rest of
    the API design guidelines help craft the right level of contract/interface to
    enable consumption, reusability, and maintainability.
  prefs: []
  type: TYPE_NORMAL
- en: 'The RESTful client should be able to discover all the available actions and
    resources required by accessing the URI path. The client should be able to handle
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Request**: Handle the inbound processing message that is sent to the server
    side'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Response**: Encapsulated information provided by the server'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Path**: Unique identifier of the resource being requested'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Parameters**: Elements added to the request as key/value pairs to specify
    operations such as filter, subset, and so on to the request'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we begin designing the API, we are sharing some of the best practices that
    we have encountered over the years.
  prefs: []
  type: TYPE_NORMAL
- en: Naming and associations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The resource names are typically referring to the nouns extracted from the
    business domain. Once the nouns are identified, API contracts can be modeled as
    HTTP verbs against these nouns:'
  prefs: []
  type: TYPE_NORMAL
- en: The selection of the resource needs to account for the fine-grained versus coarse-grained
    model. Too fine-grained means too much chattiness, and coarse-grained means to
    narrow the focus resulting in support for variations. One can reason that by using
    the system versus the process API model to an extent. But the issue becomes, if
    the resources are too fine-grained, the number of system APIs rises leading to
    unmaintainable complexity.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: APIs are designed by looking at the needs of the consumer. Derive your API needs
    based on the customer journeys and how they will map to the underlying data store.
    This means, look at the API design using the top design approach. Using the bottom
    model of doing data modeling first, might not yield the right balance. In case
    you have existing enterprise assets, you will need to perform a meet-in-the-middle
    kind of approach, where you need to balance the needs of the customers by writing
    process APIs that help bridge the gap.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Base URLs for a resource
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This depends on how you treat the resource—as a singleton or as a collection.
    So ideally, you will end up with two base URLs for one resource, one for the collection
    and a second for the entity. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Resource** | `POST`(**Create**) | `GET`(**Read**) | `PUT`(**Update**) |
    `DELETE`(**Delete**) |'
  prefs: []
  type: TYPE_TB
- en: '| `/orders` | Create new order | Order list | Replace with a new order | Error
    (do not want to delete all orders) |'
  prefs: []
  type: TYPE_TB
- en: '| `/orders/1234` | error | Show the order with ID: `1234` | If it exists update
    the order; if it does not, create a new order | Delete the order with ID: `1234`
    |'
  prefs: []
  type: TYPE_TB
- en: Handling errors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Make use of the standard HTTP status code to indicate the problem/error:'
  prefs: []
  type: TYPE_NORMAL
- en: If using JSON, the error should be a top-level property
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With errors—be descriptive, correct, and informative
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A sample error message is as shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Some examples of HTTP code usage are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 400 Bad Request
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 401 Unauthorized
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 403 Forbidden
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 404 Not Found
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 409 Conflict
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 429 Too Many Requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 5xx API is faulty
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Versioning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are multiple models for service versioning:'
  prefs: []
  type: TYPE_NORMAL
- en: '**URL**: You simply add the API version into the URL, for example: `https://getOrder/order/v2.0/sobjects/Account`.
    Used frequently, but not good practice.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Accept header**: You modify the accept header to specify the version, for
    example: `Accept: application/vnd.getOrders.v2+json`. Rarely used and cumbersome
    for the client.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Schema level**: Enforce the validation using schema, difficult to enforce
    with JSON, and works well with XML. Good practice/rare.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**API facade layer**: Use the facade layer to hide the version complexity from
    the client.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remember, a resource is a semantic model; a resource's representational form
    and state may change over time but the identifier must consistently address the
    same resource. Hence, new URIs should only be used when there is an underlying
    change in concept. The API facade layer can abstract the Northbound API from underlying
    service and schema versions. API management platforms support creating the API
    facade layer.
  prefs: []
  type: TYPE_NORMAL
- en: Pagination
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Use the URL with the pagination information to handle results offset and limits.
    For example, `/orders?limit=25&offset=50`.
  prefs: []
  type: TYPE_NORMAL
- en: Attributes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The API should support provisioning of data attributes asked by the consumer
    using the query parameter model. For example, `/orders?fields=id,orderDate,total`.
  prefs: []
  type: TYPE_NORMAL
- en: Data formats
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The API should provide support for multiple data formats based on what the consumer
    asks for. For example, `/orders/1234.json` returns data in JSON format.
  prefs: []
  type: TYPE_NORMAL
- en: Client support for limited HTTP methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Depending upon the device and its limited capability to support HTTP verbs,
    you may want to provide support for HTTP methods using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Create**: `/orders?method=post`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Read**: `/orders`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Update**: `/orders/1234?method=put&location=park`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Delete** `/orders/1234?method=delete`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authentication and authorization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: REST services use a role-based membership for each exposed method when appropriate
    and provide the ability to independently enable `GET`, `POST`, `PUT`, and `DELETE`
    based on any number of specific roles.
  prefs: []
  type: TYPE_NORMAL
- en: Typically, this concern should be handled at the API gateway level. You should
    not be handling this as part of the service.
  prefs: []
  type: TYPE_NORMAL
- en: Endpoint redirection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Service inventories may change over time for business or technical reasons.
    It may not be possible to replace all references to old endpoints simultaneously.
  prefs: []
  type: TYPE_NORMAL
- en: 'By adopting this design practice, consumers of a service endpoint adapt when
    service inventories are restructured. It automatically refers service consumers
    that access the stale endpoint identifier to the current identifier:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/af4ea0b7-d13a-46fd-a7d2-d3e5990d80b6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'HTTP natively supports the endpoint redirection pattern using a combination
    of 3xx status codes and standard headers:'
  prefs: []
  type: TYPE_NORMAL
- en: 301 moved permanently
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 307 temporary redirect
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: location/newURI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Content negotiation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Service consumers may change their requirements in a way that is not backward
    compatible. A service may have to support both old and new consumers without having
    to introduce a specific capability for each kind of consumer.
  prefs: []
  type: TYPE_NORMAL
- en: A service can specify specific content and data representation formats to be
    accepted or returned by a service capability negotiated at runtime as part of
    its invocation. The service contract refers to multiple standardized media types.
  prefs: []
  type: TYPE_NORMAL
- en: Secure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Always use SSL for your securing the URIs. SSL ensures guaranteed encrypted
    communications, which in turn simplifies authentication efforts—one need not sign
    each API request.
  prefs: []
  type: TYPE_NORMAL
- en: This covers some of the best practices that go with the API design. One can
    learn from how Google, Facebook, and Amazon are defining their public APIs and
    use those as the basis for your API design.
  prefs: []
  type: TYPE_NORMAL
- en: API modeling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are two standards that are competing to describe the APIs—Open APIs and
    RESTful APIs. We will discuss them more in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Open API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Open API initiative is focused on creating and promoting a vendor-neutral
    API description format based on the Swagger specification. The Open API specification
    allows us to define a standard, language-agnostic interface for REST APIs, which
    allows both humans and computers to discover and understand the capabilities of
    the service without access to source code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following figures, we have described a sample API definition based on
    Open API along with the various sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/44109d4d-7d5b-4fe3-8a9a-4397dfba17e6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Code continues in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b70bd4dd-d2e9-42cd-ad0f-9e1f48d9bb96.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Code continues in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a66becbc-6580-4d77-bacc-d5ecc9ade2ca.jpg)'
  prefs: []
  type: TYPE_IMG
- en: RESTful API Modeling Language (RAML)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**RESTful API Modeling Language** (**RAML**) is a standard language to describe
    the RESTful APIs. RAML is written in the same way as YAML, which is a human-readable
    data serialization language. The goal of RAML is to provide all the necessary
    information required to describe API. RAML provides a machine-readable API design
    that can be read by various API management tools.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following figure, we have described a sample RAML along with the various
    sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/22192408-6050-466b-9aa6-aab8c5e6ab51.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'RAML maps to the full API design life, which can be categorized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/05a2aabd-5ec8-474c-967f-8add021bf9dc.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s have a look at the flow:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Design**: API vendors provide editors as part of the API development suite
    to help design/write the API/RAML definition, resulting in faster development
    and fewer errors. The generated RAML can be augmented with mock data and allows
    iterations with respect to design with the business owners/consumers for validation
    and correctness.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Build**: The generated RAML provides the specifications for the build of
    the API. The development suites can generate stubs based on the RAML for plugging
    in the logic.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Test**: RAML can be used to generate test scripts. Tools such as Postman
    and Abao allow RAML specifications to be imported and tests generated that are
    used to validate the API. In addition, tools such as API Fortress and SmartBear,
    can also test for response latency, payloads, and errors.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Document**: The RAML specification can be converted into an HTML-based model.
    Tools such as RAML2HTML for PHP, API Console, and so on provide an easy way to
    expose the documentation specified as part of the RAML. This model allows any
    changes in the specification to be reflected in the documentation and keep them
    in sync.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Integrate**: The last stage of the API lifecycle is the ability to integrate
    or consume the API. Usage of RAML allows vendors/tools to create multiple ways
    to integrate and consumer the API. Using RAML, API-specific SDKs can be built.
    Vendors also provide tools that can make use of RAML to integrate with client-side
    logic.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The choice between the two standards depends upon the API gateway product stack
    chosen by the organization. Most of the products have a preference of one standard
    over the other although every product claims to provide support for both standards.
  prefs: []
  type: TYPE_NORMAL
- en: API gateway deployment models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The API gateway provides a facade pattern that encapsulates the inner workings
    of the system providing a single point of entry for all incoming clients. An API
    gateway can provide an API tailored for each type of client, all the while addressing
    concerns such as security, authentication, authorization, throttling, load balancing,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at the factors that impact how the APIs are deployed on the API gateway.
  prefs: []
  type: TYPE_NORMAL
- en: '**Type of client or channel**: Depending upon the device or channel from where
    the request originates, the API might need to serve different subsets of data.
    For example, the desktop version of the service might be asking for more details
    as compared to the mobile client. There can be a difference in data even between
    phone and tablet. How do we make sure that the same microservice can service all
    device type requests and still handle these variations? In this case, we create
    multiple APIs for different device types that meet the specific needs of the client
    without the microservice being bothered.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data transformation**: At times, the service on the backend is built to service
    JSON content. A requirement originates asking for an XML response or vice versa.
    In this case, the API gateway exposes an API that provides the XML as a response
    while doing the data transformation at the gateway level, allowing the service
    to work without any changes or knowledge of the client''s needs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Versioning**: For public APIs or APIs tied to a resource where versioning
    has not been added to the URI, an API gateway can route the incoming requests
    based on the client and the version used to the correct service. In this case,
    the API gateway can decipher the service version by using multiple techniques:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Client identifiers can be used to identify whether they have moved to a new
    version or are using an older version.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clients can be segregated into multiple categories based on SLAs. When the new
    version is released, the lowermost category, or low usage clients, can be asked
    to move to a new version. As clients upgrade, the API gateway can redirect them
    to the right version of the service.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Orchestration**: At times, the API might require multiple backend services
    invoked and results be aggregated. In this case, the API gateway must invoke multiple
    services concurrently and aggregate the results. At times, there can be a dependency
    between the service calls. For example, incoming requests might need to be authenticated
    before actual service invocation, or additional client or session information
    might need to be pulled for invoking the call. One can write the entire orchestration
    logic in the API gateway layer as some of the products provide runtime support.
    Another option could be to write a process API that does the orchestration across
    the other services and provides a consolidated API for consumption. This helps
    reduce chattiness and improves the overall performance from a client''s perspective.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We covered the orchestration patterns in Chapter 3, *Designing Your Cloud-Native
    Application*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Service discovery**: With the service instance going up and down, the service
    registry is the only true source of data in terms of the endpoints of the service
    that are available at any given point of time. An API gateway should be able to
    invoke the service registry to get the service endpoint at runtime and use that
    to invoke the service. A service registry can be used as a mechanism to load-balance
    the service calls across the registered service instances.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Handling timeouts**: For services that do not respond within a reasonable
    time, the API gateway allows you to timeout the request. This allows the gateway
    to handle timeout failures and even provide a failure mode for the clients. One
    option can be to provide cached data (if applicable and depending upon the type
    of service) or fail fast model, where the gateway can return an error or failure
    immediately without invoking the service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data caching**: The API gateway can also cache data for service calls that
    provide static data or data that does not change frequently. This model allows
    the traffic getting reduced on the service instance. This improves the overall
    response latency and the overall system resiliency. The cached data can also be
    used as a secondary failure flow, in case of failure of the primary flow.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Service invocation**: The service getting deployed can be using multiple
    interfaces or protocols. For example, you might have services that make use of
    an asynchronous messaging based mechanism (such as JMS, MQ, Kafka, and so on)
    or others can make use of synchronous models such as HTTP or Thrift. The API gateway
    should be able to support multiple service invocation models and provide orchestration
    models on top of these invocation methods.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Service metering/throttling**: For certain categories of clients, you may
    want to limit the number of service calls they can make. For example, if you are
    providing a freemium model of service with reduced functionality, along with limits
    of calls that can be made in a time frame. The ability to meter and throttle the
    incoming requests based on type of client (free or paid) helps provide a business
    model around your API and underlying services. This can also be helpful if you
    are making external API calls to another SaaS provider, routing those calls through
    the API gateway can help predict/manage the number of outgoing calls and give
    unnecessary shocks when the usage bill comes up.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**API monitoring**: Another important concern is monitoring your API calls
    for any deviation, whether in terms of response latency across various percentiles,
    failures rates, API availability, and so on. These metrics need to be plotted
    on a dashboard with appropriate alerts and notification systems. Based on the
    type of failure, one can automate the recovery scripts to overcome them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This concludes the various usage scenarios and patterns that can be applied
    to an API gateway to expose your services as API to the consumers.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we saw how an API can be categorized into different models
    based on its primary usage and underlying resource. We saw the best practice with
    respect to the overall API design and the standards available to model the API
    through Open API or RAML specification. Next, we saw how the API gateway can be
    leveraged to address concerns not handled at the service levels.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will cover the impact of cloud development on the existing
    landscape of an enterprise, and how it can achieve the transformation of moving
    toward a digital enterprise.
  prefs: []
  type: TYPE_NORMAL
