- en: '*Chapter 2*: First Contact: Java, XML, and the UI Designer'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At this stage, we have a working Android development environment and we have
    built and deployed our first app. It is obvious, however, that the auto-generated
    code from Android Studio is not going to make the next top-selling app on Google
    Play. We need to explore this auto-generated code so we can begin to understand
    Android and then learn how to build upon this useful template. With this aim in
    mind, in this chapter, we will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: See how to get technical feedback from our apps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examine the Java code and UI XML code from our first app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get our first taste of using the Android Studio **User Interface** (**UI**)
    designer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn some core Java fundamentals and how they relate to Android
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write our first Java code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First, let's see how to get feedback from our apps.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find the code for this chapter on GitHub at [https://github.com/PacktPublishing/Android-Programming-for-Beginners-Third-Edition/tree/main/chapter%2002](https://github.com/PacktPublishing/Android-Programming-for-Beginners-Third-Edition/tree/main/chapter%2002).
  prefs: []
  type: TYPE_NORMAL
- en: Examining the logcat output
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we mentioned that our app was running in debug mode
    on the emulator or real device, so we can monitor it and get feedback when things
    go wrong. So, where is all this feedback then?
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed a whole load of scrolling text at the bottom of the
    Android Studio window. If not, click on the **Logcat** tab, as shown by the highlighted
    area labeled **1** in the next figure:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The emulator must be running, or a real device must be attached in debugging
    mode, for you to see the following window. Furthermore, if you restarted Android
    Studio for some reason and have not executed the app since restarting, then the
    **Logcat** window will be empty. Refer to the first chapter to get the app running
    on an emulator or a real device.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1 – The Logcat tab'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.01_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.1 – The Logcat tab
  prefs: []
  type: TYPE_NORMAL
- en: You can drag the window to make it taller, just like you can in most other Windows
    applications if you want to see more.
  prefs: []
  type: TYPE_NORMAL
- en: This window is called **logcat** or is sometimes referred to as the **console**.
    It is our app's way of telling us what is going on underneath what the user sees.
    If the app crashes or has errors, the reason or clues to the reason will appear
    here. If we need to output debugging information, we can do so here as well.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The app we are building should not have any problems at this stage, but in the
    future, if you just cannot work out why your app is crashing, copying and pasting
    a bit of text from logcat into Google will often reveal the reason.
  prefs: []
  type: TYPE_NORMAL
- en: Filtering the logcat output
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You might have noticed that most if not all of the contents of logcat is almost
    unintelligible. That's OK. For now, we are only interested in errors, which will
    be highlighted in red, and the debugging information, about which we will learn
    next. So that we see less of the unneeded text in our logcat window, we can turn
    on some filters to make things clearer.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous figure, I highlighted two more areas, as **2** and **3**. Area
    **2** is a drop-down list that controls the first filter. Left-click it now and
    change it from **Verbose** to **Info**. We have cut down the text output significantly.
    We will see how this is useful when we have made some changes to our app and redeployed
    it. We will do this after we have explored the code and the assets that make up
    our project. Also, double-check in the area that is labeled **3** that says **Show
    only the selected application**. If it doesn't, left-click on it and change it
    to **Show only the selected application** now.
  prefs: []
  type: TYPE_NORMAL
- en: Now we can look at what Android Studio automatically generated for us and then
    we can set about changing and adding to the code to personalize it beyond what
    we got from the project creation phase.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the project Java and the main layout XML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are going to look at the resource files that have the code that defines our
    simple UI layout and the file that has our Java code. At this stage, we will not
    try to understand it all, as we need to learn some more basics before it makes
    sense to do so. What we will see, however, is the basic contents and structure
    of both files, so we can reconcile their contents with what we already know about
    Android resources and Java.
  prefs: []
  type: TYPE_NORMAL
- en: Examining the MainActivity.java file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s look at the Java code first. If, for some reason, this isn''t currently
    visible, you can see this code by left-clicking on the **MainActivity.java** tab,
    as shown in the next figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.2 – MainActivity.java tab'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.02_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.2 – MainActivity.java tab
  prefs: []
  type: TYPE_NORMAL
- en: 'As we are not looking at the intricate details of the code, an annotated screenshot
    is more useful than reproducing the actual code in text form. Regularly refer
    to the next figure while reading on in this section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.3 – Java code'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.03_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.3 – Java code
  prefs: []
  type: TYPE_NORMAL
- en: The first thing to note is that I have added a few empty lines among the code
    to space things out a little bit and present a clearer image.
  prefs: []
  type: TYPE_NORMAL
- en: Code folding (hiding) in Android Studio
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now look at the left-hand side of the figure where multiple parts are labeled
    **9**. This points to all the little + and - buttons in the editor, which can
    collapse and expand parts of the code. I have indeed collapsed some parts of the
    code, and other parts I have left visible. So, what you can see on your screen
    is slightly different to what you will see if you look at the figure. In Android
    Studio, play with the + and – buttons for a while to practice hiding and unhiding
    sections of the code. You might want to get your screen to look like the figure,
    but this is not a requirement to continue. The technical term for hiding code
    like this is **folding**.
  prefs: []
  type: TYPE_NORMAL
- en: The package declaration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Part `package`. Every Java file will have a package declaration at the top.
  prefs: []
  type: TYPE_NORMAL
- en: Importing classes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Part `import`. After the word `import`, we can see there are various dot-separated
    words. The last word of each line is the name of the class that line imports into
    our project and all the earlier words in each line are the packages and sub-packages
    that contain these classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, this next line imports the `AppCompatActivity` class from the
    `androidx.appcompat.app` package and sub-packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The semicolon at the end of the lines shows the compiler that it is the end
    of that line of code.
  prefs: []
  type: TYPE_NORMAL
- en: This means that in this file we will have access to these classes. In fact,
    it is these classes that the auto-generated code uses to make the simple app that
    we saw in action in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We will not discuss all these classes in this chapter. It is just the concept
    that we can do this importing that is significant right now. Note that we can
    add extra classes from any package at any time and we will when we improve upon
    our app shortly.
  prefs: []
  type: TYPE_NORMAL
- en: The class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Part **3** of our code is called the **class declaration**. Here is that line
    in full; I have highlighted one part of it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The class declaration is the start of a class. Notice the highlighted part,
    `MainActivity`. This is the name Android Studio gave the class when we created
    the project and it is also the same as the `MainActivity.java` filename as we
    would expect having discussed Java classes previously.
  prefs: []
  type: TYPE_NORMAL
- en: The class and the file can be renamed, but since this is the key/main activity
    of our app, `MainActivity` seems appropriate. The `extends` keyword means that
    our class called `MainActivity` will be of the type `AppCompatActivity`.
  prefs: []
  type: TYPE_NORMAL
- en: We can, and will, use some classes without this `extends` part. We use `extends`
    here because we want to use all the code that went into the `AppCompatActivity`
    class, as well as adding our own code to it as well. So, we **extend** it. All
    this and more will become clear in [*Chapter 10*](B16773_10_ePub_RK.xhtml#_idTextAnchor187)*,
    Object-Oriented Programming.*
  prefs: []
  type: TYPE_NORMAL
- en: Finally, for part `{`. Now look at the bottom of the figure at part `}` denotes
    the end of the class. Everything in between the opening and closing curly braces,
    `{...}`, is part of the `MainActivity` class.
  prefs: []
  type: TYPE_NORMAL
- en: Methods inside the class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now look at part **5** of the code. Here is that line of code in full with
    the key part for our discussion highlighted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This is a method `onCreate`, is the method **name**. We make a method execute
    its code by using its name. We say we are **calling** a method when we do this.
  prefs: []
  type: TYPE_NORMAL
- en: Although we will not concern ourselves now with the details of the parts of
    the code on either side of the method name, you might have noticed `Bundle`, one
    of the classes we imported at part `import` line, Android Studio would not know
    what `Bundle` was and it would be unusable and indicated with a red underline
    as an error.
  prefs: []
  type: TYPE_NORMAL
- en: Our code would then not compile and run. Notice the very last thing in the preceding
    line of code is an opening curly brace, `{`. This denotes the start of the code
    contained within the `onCreate` method. Now jump to part `}`. You might have guessed
    that this is the end of the method. Everything in between the opening and closing
    curly braces of the `onCreate` method is the code that executes when the method
    is called.
  prefs: []
  type: TYPE_NORMAL
- en: We do not need to go into what this code does yet, but as an overview, it sets
    up the appearance/layout of the app by referring to a resource file that was auto-generated
    by Android Studio when we created the project. I have highlighted the resource
    files with an outline in the previous figure.
  prefs: []
  type: TYPE_NORMAL
- en: Parts `onCreateOptionsMenu` and `onOptionsItemSelected`.
  prefs: []
  type: TYPE_NORMAL
- en: We know enough about our Java code to make some progress. We will see this code
    again and change it later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary of the Java code so far
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is true that contained within the code we have just had an overview of, there
    is some complex syntax. However, what we are doing is building up just enough
    knowledge about this code, so we can work with it to begin to make fast progress
    in learning Java and Android without having to learn hundreds of pages of Java
    theory first. By the end of the book, all the code will make sense, but to make
    quick progress now, we just need to accept that some of the details will remain
    a mystery for a little while longer.
  prefs: []
  type: TYPE_NORMAL
- en: Examining the app layout file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now we will look at just one of the many `.xml` files. There are several different
    layout files and we will meet them all throughout the course of the book, but
    let's start with the most recognizable one, which decides most of the appearance
    of our app.
  prefs: []
  type: TYPE_NORMAL
- en: In the project explorer window, left-click on the `fragment_first.xml` file.
    The XML code contents of the file is now displayed in the main window of Android
    Studio.
  prefs: []
  type: TYPE_NORMAL
- en: We can ignore the **res generated** folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will explore this XML code soon but first find and left-click the **Design**
    button (shown next) to switch to the design view:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.4 – To open design view'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.04_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.4 – To open design view
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can see the design view that shows us what the XML code will cause to
    be displayed when the app is run in the emulator:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.5 – App display'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.05_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.5 – App display
  prefs: []
  type: TYPE_NORMAL
- en: The preceding figure should look familiar because it shows the layout of our
    first app that we ran at the end of the previous chapter – the one with the `fragment_second.xml`
    file from the same folder as `fragment_first.xml`, you will see the second layout
    we saw in the previous chapter, the one that had the **Previous** button on it.
    In fact, there are even more layout-related files than we might first expect,
    but we will get to discussing them in this chapter and the next.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the work that we do throughout the book when we design apps will be
    done in this design view. It is important, however, to know what is going on behind
    the scenes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The design view is a graphical representation of the XML code contained in
    the `fragment_first.xml` file. Click on the **Code** tab (near the **Design**
    tab in the previous figure) to see the XML code which forms the layout. I have
    annotated a screenshot of the XML text, so we can discuss it next:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.6 – Screenshot of the XML text'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.06_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.6 – Screenshot of the XML text
  prefs: []
  type: TYPE_NORMAL
- en: The first thing to note is that this file does not represent the entire layout.
    It does however represent most of the surface area and the entire **Hello first
    fragment** message and the **Next** button. Also, on the left-hand side, we can
    see the now-familiar + and – icons so we can fold and unfold sections of the code.
  prefs: []
  type: TYPE_NORMAL
- en: UI layout elements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If we first look at the part of the code labeled `…ConstraintLayout...`. Now,
    `ConstraintLayout` is a UI element that is used to wrap other parts of the UI.
  prefs: []
  type: TYPE_NORMAL
- en: When we add a new element to a UI in Android, we always start a line with a
    `<` followed by the element's name.
  prefs: []
  type: TYPE_NORMAL
- en: The code that follows that rather long and cumbersome-looking line defines the
    `layout_width` and `layout_height`. All these attributes define how the `ConstraintLayout`
    element will appear on the user's screen. The attributes for the `ConstraintLayout`
    element end at the first `>` labeled **1b**.
  prefs: []
  type: TYPE_NORMAL
- en: If we look at the bottom of our XML screenshot, we will see some code labeled
    `</…ConstraintLayout>`, marks the end of the `ConstraintLayout` element. Anything
    in between the closing `>` of the element's attributes and `</…ConstraintLayout>`,
    which defines its end, is considered a child of the element. So, we can see that
    our `ConstraintLayout` has/contains two child elements. Let's look at those children
    now.
  prefs: []
  type: TYPE_NORMAL
- en: UI text elements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Using what we just learned, we can say that the UI element that starts at position
    `<` and its name: `<TextView...`. If we look further into our `TextView` element,
    we can see it has several attributes. It has a `text` attribute that is set to
    `"Hello first fragment"`. This of course is the exact text that our app shows
    to the user. It also has `layout_width` and `layout_height` attributes that are
    both set to `"wrap_content"`. This tells `TextView` it can take up as much space
    as the content it has needs. As we will see throughout the book, there are many
    more attributes available for this and other UI elements. The final attribute
    in `TextView` is `id`, and we will see how we and Android use the `id` attribute
    in the next section when we improve this first app.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that the code at `/>`. This marks the end of the `TextView` element.
    This is slightly different to how the end of the `ConstraintLayout` element was
    written. When an element in XML has no children, we can just end it like this:
    `/>`. When the element has children and its end comes further on in the code from
    where its attributes are defined, it is much clearer to end the element by repeating
    its name like this: `</…ConstraintLayout>`.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You might be wondering why the element name for `TextView` is clear and concise
    (simply `TextView`) yet the full name for the `ConstraintView` is preceded by
    complicated apparent clutter (`androidx.constraintlayout.widget.ConstraintLayout`).
    This `ConstraintLayout` element is a special layout that is used to ensure our
    app's compatibility with older versions of Android. As we will see in a minute
    when we add buttons to the app, most elements have simple and concise names.
  prefs: []
  type: TYPE_NORMAL
- en: UI Button elements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now we should be able to quickly identify that the code that starts at `<`
    and its name: `<Button...`. If we look further into our `Button`, we can see it
    has several attributes. It has a text attribute that is set to `"Next"`. This
    of course is the exact text displayed on the button the user can click. It also
    has `layout_width` and `layout_height` attributes that are both set to `"wrap_content"`.
    This, as with the `TextView` element, causes the onscreen button to take up as
    much space as the content it has needs. The final attribute in `Button` is `id`,
    and for buttons this is often a vital attribute, even more so than for some other
    parts of the UI. As the `id` attribute can distinguish this button from other
    buttons, we can program different functionality for different buttons based on
    the value held in the `id` attribute. We will see this principle in action soon.'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the code at `/>`. As we have come to know, this marks the end of
    the `Button` element.
  prefs: []
  type: TYPE_NORMAL
- en: We will edit and add to this XML code in the next section and learn more about
    the attributes.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The elements of a layout are often referred to as **widgets**.
  prefs: []
  type: TYPE_NORMAL
- en: Adding buttons to the main layout file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here we will add a couple of button widgets to the screen and we will then see
    a fast way to make them actually do something. We will add a button in two different
    ways, firstly using the visual designer and secondly by adding to and editing
    the XML code directly.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a button via the visual designer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To get started with adding our first button, `fragment_first.xml`, open it
    in the editor and switch back to the design view by clicking the **Design** tab
    (shown next):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.7 – Design tab'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.07_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.7 – Design tab
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice to the left-hand side of the layout we have a window that is called
    the **Palette** and is shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.8 – Palette window'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.08_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.8 – Palette window
  prefs: []
  type: TYPE_NORMAL
- en: The palette is divided into two parts. The left-hand list has the categories
    of UI elements and allows you to select a category, and then the right-hand side
    shows you all the available UI elements from the currently selected category.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure that the **Common** category is selected as shown in the previous
    figure. Now, left-click and hold on the **Button** widget and then drag it onto
    the layout somewhere near the top center.
  prefs: []
  type: TYPE_NORMAL
- en: 'It doesn''t matter if it is not exact. It is good to practice getting it right,
    however. So, if you are not happy with the position of your button, then you can
    left-click it to select it on the layout and then tap the *Delete* key on the
    keyboard to get rid of it. Now you can repeat the previous step until you have
    a new neatly placed button that you are happy with, as here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.9 – Updating the layout'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.09_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.9 – Updating the layout
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we could run the app on the emulator or on a real device and
    the button would be there – kind of. If we clicked it, there would even be a simple
    animation to represent the button being pressed and released. Feel free to try
    this now if you like. If you do, you will notice that the button isn''t positioned
    as you expect it to be:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.10 – Button not positioned correctly'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.10_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.10 – Button not positioned correctly
  prefs: []
  type: TYPE_NORMAL
- en: Don't concern yourself with this apparent anomaly for now; we will look into
    this over the next few sections.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we are going to edit the attributes of our button in the **Attributes**
    window.
  prefs: []
  type: TYPE_NORMAL
- en: Editing the button's attributes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Make sure the button is selected by left-clicking it. Now find the **Attributes**
    window to the right of the editing window as shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.11 – Attributes window'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.11_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.11 – Attributes window
  prefs: []
  type: TYPE_NORMAL
- en: In the previous figure, you can see that we have access to a wide selection
    of attributes from the currently selected UI element. To reveal more of the attributes,
    we click the different categories of attributes and scroll through them using
    the scrollbar to the right. If they are not open already by default, left-click
    on the **Common** **Attributes** and **All Attributes** sections' arrows to reveal
    their options.
  prefs: []
  type: TYPE_NORMAL
- en: Now you can see the full details of the button and we can set about editing
    it. It might seem surprising the substantial number of attributes that something
    as simple as a button has. This is a sign of the versatility and power that the
    Android API provides for UI manipulation.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, there is a large array of different attributes that we can edit
    right here in the UI designer. In [*Chapter 13*](B16773_13_ePub_RK.xhtml#_idTextAnchor228)*,
    Anonymous Classes – Bringing Android Widgets to Life*, we will also edit and manipulate
    these attributes using our Java code.
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, we will edit just one attribute. Scroll the **Attributes** window
    until you see the **onClick** attribute in the **Common Attributes** section and
    then left-click it to select it for editing, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.12 – Common Attributes section'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.12_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.12 – Common Attributes section
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you ever have trouble finding an attribute, you can always find it in the
    **All Attributes** section, where attributes are arranged in alphabetical order.
    Therefore, the **onClick** attribute can also be found about two-thirds of the
    way down the lengthy list of the **All Attributes** section.
  prefs: []
  type: TYPE_NORMAL
- en: Type `topClick` in the `t` and uppercase `C`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Attributes** window will look like this when you are done:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.13 – onClick option'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.13_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.13 – onClick option
  prefs: []
  type: TYPE_NORMAL
- en: What we have done here is named the Java method in our code that we want to
    call when this button is clicked by the user. The name is arbitrary but as this
    button is in the top part of the screen, the name seems meaningful and easy to
    remember. The odd casing that we used is a convention that will help us keep our
    code clear and easy to read. We will see the benefits of this as our code gets
    longer and more complicated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, the `topClick` method doesn''t exist yet. Android Studio is very
    helpful, but there are some things we need to do ourselves. We will write this
    method using Java code after we have added another button to our UI. You could
    run the app at this point and it would still work. But if you click the button,
    it will crash, and you will get an error because the method does not exist. Android
    Studio is forewarning us of this impending crash by outlining the **onClick**
    attribute in red, as shown in the previous figure. If you hover the mouse cursor
    over this red outline, you will see the details of the problem: **Corresponding
    method handler… Not found**.'
  prefs: []
  type: TYPE_NORMAL
- en: Examining the XML code for the new button
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we add our final button for this project. Click the **Code** tab to switch
    back to seeing the XML code that makes our UI.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that there is a new block of code among the XML that we examined earlier.
    Here is an image of the new block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.14 – New block of code among the XML'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.14_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.14 – New block of code among the XML
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, notice the following details, which should correspond to what we know
    about XML and Android UI elements:'
  prefs: []
  type: TYPE_NORMAL
- en: The new code starts with the text `<Button` and ends with `/>`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code has a range of attributes that define the button, including `layoutWidth`
    and `layoutHeight`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code includes the `onClick` attribute that we just added with a value of
    `"topClick"`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `topClick` value of the `onClick` attribute is underlined in red, showing
    the missing method error.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The start and end of the code representing the button are enclosed within the
    `ConstraintLayout` element.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As in the design view, you can hover the mouse cursor over the red-underlined
    `topClick` code to reveal the details of the problem: **Corresponding method handler…
    Not found**.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: During the writing of this book, Android Studio updated the way it shows errors
    in XML. Currently, it highlights the error in red, not underlining in red as shown
    in the figures and descriptions. The underlining is clearer in black and white
    print so they have been left as they are.
  prefs: []
  type: TYPE_NORMAL
- en: We can see that the issue is that Android Studio expects a method called `topClick`
    to be implemented within our Java code. We will do this as soon as we have added
    that second button.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a button by editing the XML code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just for variety and to prove that we can, we will now add another button using
    only XML code, not the UI designer. Most of the time, we will use the UI designer,
    but this quick exercise should cement in your mind the relationship between the
    UI designer and the underlying XML code.
  prefs: []
  type: TYPE_NORMAL
- en: We will achieve this by copying and pasting the code for the existing button.
    We will then make some minor edits to the pasted code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Left-click just before the button code that starts `<Button`. Notice that the
    beginning and end of the code now have a slight highlight:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.15 – Button code'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.15_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.15 – Button code
  prefs: []
  type: TYPE_NORMAL
- en: 'This has identified the part of the code we want to copy. Now left-click and
    drag to select all the button code, including the highlighted start and end, as
    shown in this next figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.16 – Select all the button code'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.16_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.16 – Select all the button code
  prefs: []
  type: TYPE_NORMAL
- en: Press the *Ctrl + C* keyboard combination to copy the highlighted text. Place
    the keyboard cursor below the existing button code and tap the *Enter* key a few
    times to leave some spare empty lines.
  prefs: []
  type: TYPE_NORMAL
- en: 'Press the *Ctrl + V* keyboard combination to paste the button code. At this
    point, we have two buttons. There are a couple of problems, however:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.17 – Additional error'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.17_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.17 – Additional error
  prefs: []
  type: TYPE_NORMAL
- en: We have an additional error in both blocks of code that represent our buttons.
    The `id` attribute (in both blocks) is underlined in red. The reason for this
    error is that both buttons have an `id` attribute that is the same. The `id` attribute
    is supposed to distinguish a UI element from all other UI elements. Let's fix
    that.
  prefs: []
  type: TYPE_NORMAL
- en: Giving the buttons unique id attributes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We could solve the problem by calling the second button, `button2`, but it
    would be more meaningful to change them both. Edit the code in the first button
    to give it an ID of `buttonTop`. To do so, find the following line of code (in
    the first button):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Change it to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Notice the lowercase `b` in `button` and the uppercase `T` in `Top`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now identify this line of code in the second button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Change it to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The errors on the `id` attribute lines are gone. At this point, you might think
    we can move on to solve our missing method problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if you run the app and take a quick glance at it, you will see we
    only appear to have one button. Not only that but (as alluded to previously) the
    buttons are not in the place we expected them to be either:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.18 – Single button'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.18_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.18 – Single button
  prefs: []
  type: TYPE_NORMAL
- en: The reason for this is we haven't explicitly positioned them, so they have defaulted
    to the top left. The position we see on the **Design** tab is just a design-time
    position. Let's change that now.
  prefs: []
  type: TYPE_NORMAL
- en: Positioning the two buttons in the layout
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The reason we can only see one button is that both buttons are in the same position.
    The second button is exactly covering the first button. And even in the **Design**
    tab (feel free to have a look), the buttons are still sat on top of each other,
    although they are in the middle of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'You might be wondering why the UI layout tool was designed in this apparently
    counterintuitive way. The reason is flexibility. As we will see in the next two
    chapters, not only is it possible to position UI elements differently at design
    time to when the app is running but there is also a whole bunch of different layout
    schemes that the app designer (that''s you) can choose from to suit their plans.
    This flexibility results in a little awkwardness while learning about Android
    but great design power once you have got past the awkwardness. Don''t worry: we
    will move a step at a time until you have this thing beaten.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will make Android Studio solve the problem for us automatically by first
    adding to our code and then using the UI designer. First, let''s get the design-time
    layout right. In the code for the second button, find this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Edit it to be the same as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This subtle change will move the second button down a little, but only for design
    time. If you look in the **Design** tab, the button is positioned neatly underneath
    the first button, but if you run the app on the emulator, they are both still
    in the top-left corner and on top of one another.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: It is possible, even likely, that the exact `dp` measurements in your layout
    will be slightly different to those shown in the book. As long as the second button's
    `layout_editor_absoluteY` attribute is about `70dp` greater than the first, then
    all will be neat and tidy. Feel free to play with this attribute on both buttons
    while switching between the **Code** and **Design** tabs until the buttons are
    positioned to your liking.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you are satisfied with the position of the buttons, switch to the **Design**
    tab and find the **Infer constraints** button, shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.19 – Infer constraints button'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.19_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.19 – Infer constraints button
  prefs: []
  type: TYPE_NORMAL
- en: Click the **Infer constraints** button. Android Studio will edit the XML. Let's
    take a brief look at what has happened behind the scenes. From the end of both
    of the buttons, the following lines of code were removed.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the constraints aren''t being applied, hit the **Clear All Constraints**
    button, which is to the left of **Infer constraints**; sometimes Android Studio
    can get confused and needs to reset the existing constraints before inferring
    the rest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: These two lines of code were what positioned the buttons horizontally (`…absoluteX`)
    and vertically (`…absoluteY`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Android Studio also added four lines of code to the first button and three
    to the second. Here is the code added near the start of the first button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This code causes the button to have a margin of 30 at the top. But at the top
    relative to what exactly? Look at these three lines of code that were added at
    the end of the first button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice the new attributes of `layout_constraintEnd_toEndOf`, `layout_constraintStart_toStartOf`,
    and `layout_constraintTop_toTopOf`. The value assigned to each of these attributes
    is `"parent"`. This causes the first button to be positioned relative to the *parent*
    UI element. The parent is the containing layout: the `ConstraintLayout` element.'
  prefs: []
  type: TYPE_NORMAL
- en: Now look at the three lines of code added to the second (bottom) button.
  prefs: []
  type: TYPE_NORMAL
- en: 'Near the start of the code, we see this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'And at the end of the code for the second button, we see these two extra lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This means that the second button is positioned with a margin of 22 relative
    to the `buttonTop` widget.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The `dp` code is a unit of measurement/distance and will be discussed in more
    depth in [*Chapter 5*](B16773_05_ePub_RK.xhtml#_idTextAnchor101)*, Beautiful Layouts
    with CardView and ScrollView*. The precise values for the `dp` measurement will
    likely vary slightly on your layout.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now run the app and you will see we have two distinct buttons. One has an `id`
    attribute of `buttonTop` and it is above the other button, with an `id` attribute
    of `buttonBottom`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.20 – Two button options'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.20_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.20 – Two button options
  prefs: []
  type: TYPE_NORMAL
- en: Clearly, there is more to layouts than I have alluded to so far, but you have
    had your first glance at one of the options we have to design the UI of our apps.
    We will be taking a closer look at the `ConstraintLayout` layout element as well
    as exploring more layout options in [*Chapter 4*](B16773_04_ePub_RK.xhtml#_idTextAnchor076)*,
    Getting Started with Layouts and Material Design*.
  prefs: []
  type: TYPE_NORMAL
- en: We want to make one more change in our XML code.
  prefs: []
  type: TYPE_NORMAL
- en: Making the buttons call different methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Switch back to the `buttonBottom`) button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Edit the code to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Now we have two buttons, one above the other. The top one has an `id` attribute
    of `buttonTop` and an `onClick` attribute with a value of `topClick`. The other
    has an `id` attribute of `buttonBottom` and an `onClick` attribute with a value
    of `bottomClick`.
  prefs: []
  type: TYPE_NORMAL
- en: These last XML code changes now mean we need to code two methods (`topClick`
    and `bottomClick`) in our Java code.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: It is OK for two buttons to call the same method when they are clicked; it is
    not a syntax error. However, most buttons do have distinct purposes, so this exercise
    will be more meaningful if our buttons do different things.
  prefs: []
  type: TYPE_NORMAL
- en: We will do that soon, but before we do, let's learn a little bit more about
    Java comments and look at some Java code we can write to send messages. We will
    learn to send messages to the user to keep them informed and to ourselves for
    debugging purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Leaving comments in our Java code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In programming, it is always a clever idea to write notes, known as code comments,
    and sprinkle them liberally throughout your code. This is to remind us what we
    were thinking at the time we wrote the code. To do this, you simply append a double
    forward slash and then type your comment, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition, we can use comments to *comment out* a line of code. Suppose we
    have a line of code that we temporarily want to disable. We can do so by adding
    the two forward slashes, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Using comments to comment out code should only be a temporary measure. Once
    you have found the correct code to use, commented-out code should be deleted to
    keep the code file clean and organized.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at two separate ways to send messages in Android, and then we can
    write some methods that will send messages when our new UI buttons are pressed.
  prefs: []
  type: TYPE_NORMAL
- en: Coding messages to the user and the developer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the introduction to this chapter and in the previous chapter, we talked a
    bit about using other people's code, specifically via the classes and their methods,
    of the Android API. We saw that we could do some quite complex things with insignificant
    amounts of code (such as talk to satellites).
  prefs: []
  type: TYPE_NORMAL
- en: To get us started, we are going to use two different classes from the Android
    API that allow us to output messages. The first class, `Log`, allows us to output
    messages to the Logcat window. The second class, `Toast`, is not a tasty breakfast
    treat, but it will produce a toast-shaped pop-up message for our app's user to
    see.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code we need to write to send a message to the Logcat window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Exactly why this works will become clearer in [*Chapter 10*](B16773_10_ePub_RK.xhtml#_idTextAnchor187)*,
    Object-Oriented Programming*, but for now, we just need to know that whatever
    we put between the two sets of quote marks will be output to the Logcat window.
    We will see where to write this type of code shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code we need to write to send a message to the user''s screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This is a very convoluted-looking line of code, and exactly how it works, again,
    will not become clear until [*Chapter 10*](B16773_10_ePub_RK.xhtml#_idTextAnchor187)*,
    Object-Oriented Programming.* The important thing here is that whatever we put
    between the quote marks will appear in a pop-up message to our users.
  prefs: []
  type: TYPE_NORMAL
- en: Let's put some code, much like we have just seen, into our app for real.
  prefs: []
  type: TYPE_NORMAL
- en: Writing our first Java code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, we now know the code that will output to Logcat or the user's screen. But
    *where* do we write the code? To answer this question, we need to understand that
    the `onCreate` method in `MainActivity.java` executes as the app is preparing
    to be shown to the user. So, if we put our code at the end of this method, it
    will execute just as the user sees the app. Sounds good.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'We know that to execute the code in a method, we need to call it. We have wired
    our buttons up to call a couple of methods: `topClick` and `bottomClick`. Soon
    we will write these methods. But who or what is calling `onCreate`!? The answer
    to this mystery is that the Android operating system itself calls `onCreate`.
    It does so when the user clicks the app icon to run the app. In [*Chapter 6*](B16773_06_ePub_RK.xhtml#_idTextAnchor119)*,
    The Android Lifecycle*, we will look deeper at this phenomenon, and it will be
    clear exactly what code executes and when. You don''t need to completely comprehend
    this now. I just wanted to give you an overview of what was going on.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's quickly try this out. Switch to the `MainActivity.java` tab in Android
    Studio.
  prefs: []
  type: TYPE_NORMAL
- en: We know that the `onCreate` method is called just before the app starts. Let's
    copy and paste some code into the `onCreate` method of our app and see what happens
    when we run it.
  prefs: []
  type: TYPE_NORMAL
- en: Adding message code to the onCreate method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Find the closing curly brace `}` of the `onCreate` method and add the highlighted
    code shown next. In the code, I haven''t shown the complete contents of the `onCreate`
    method but have used `…` to indicate some lines of code not being shown. The important
    thing is to place the new code (shown in full) right at the end but before that
    closing curly brace, `}`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the two instances of the word `Toast` and the word `Log` are highlighted
    in red in Android Studio. They are errors. We know that `Toast` and `Log` are
    classes and that classes are containers for code.
  prefs: []
  type: TYPE_NORMAL
- en: The problem is that Android Studio doesn't know about them until we tell it
    about them. We must add an `import` for each class. Fortunately, this is semi-automatic.
  prefs: []
  type: TYPE_NORMAL
- en: Left-click on the red `Toast` code in the `onCreate` method. Now hold the *Alt*
    key and then tap *Enter*. When prompted, choose `Log`. Android Studio adds the
    import directives at the top of the code with our other imports and the errors
    are gone.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '*Alt + Enter* is just one of many useful keyboard shortcuts. The following
    link is to a keyboard shortcut reference for Android Studio. More specifically,
    it is for the IntelliJ Idea IDE, upon which Android Studio is based. Look at and
    bookmark this web page; it will be invaluable over the course of this book: [http://www.jetbrains.com/idea/docs/IntelliJIDEA_ReferenceCard.pdf](http://www.jetbrains.com/idea/docs/IntelliJIDEA_ReferenceCard.pdf).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Scroll to the top of `MainActivity.java` and look at the added `import` directives.
    Here they are for your convenience:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Run the app in the usual way and look at the output in the **Logcat** window.
  prefs: []
  type: TYPE_NORMAL
- en: Examining the output
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The next figure shows a screenshot of the output in the **Logcat** window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.21 – Output in the Logcat window'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.21_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.21 – Output in the Logcat window
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at the **Logcat** window, you can see our message **Done creating the
    app** was output, although it is mixed up among other system messages that we
    are currently not interested in. If you watch the emulator when the app first
    starts, you will also see the neat pop-up message that the user will see:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.22 – Pop-up message'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.22_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.22 – Pop-up message
  prefs: []
  type: TYPE_NORMAL
- en: It is possible that you might be wondering why the messages were output at the
    time they were. The answer is that the `onCreate` method is called just *before*
    the app starts to respond to the user. It is for this reason, it's common practice
    among Android developers to put code in this method to get their apps set up and
    ready for the user.
  prefs: []
  type: TYPE_NORMAL
- en: Now we will go a step further and write our own methods that will be called
    by our two buttons in the UI. We will place similar `Log` and `Toast` messages
    inside these new methods.
  prefs: []
  type: TYPE_NORMAL
- en: Writing our own Java methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's get straight on with writing our first Java methods with some more `Log`
    and `Toast` messages inside them.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Now would be a good time, if you haven't already, to get the download bundle
    that contains all the code files. You can view the completed code for each chapter.
    For example, the completed code for this chapter can be found in the [*Chapter
    2*](B16773_02_ePub_RK.xhtml#_idTextAnchor043) folder. I have further subdivided
    the [*Chapter 2*](B16773_02_ePub_RK.xhtml#_idTextAnchor043) folder into `java`
    and `res` folders (for Java and resource files). In chapters with more than one
    project, I will divide the folders further to include the project name. You should
    view these files in a text editor. My favorite is Notepad++, a free download from
    [https://notepad-plus-plus.org/download/](https://notepad-plus-plus.org/download/).
    The code viewed in a text editor is easier to read than from the book directly,
    especially the paperback version, and even more so where the lines of code are
    long. The text editor is also a great way to select sections of the code to copy
    and paste into Android Studio. You could open the code in Android Studio, but
    then you'd risk mixing up my code with the auto-generated code of Android Studio.
  prefs: []
  type: TYPE_NORMAL
- en: Identify the closing curly brace, `}`, of the `MainActivity` class.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You are looking for the end of the entire class, not the end of the `onCreate`
    method as in the previous section. Take your time to identify the new code and
    where it goes among the existing code.
  prefs: []
  type: TYPE_NORMAL
- en: Inside that curly brace, enter the following code that is highlighted.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the two instances of the word `View` might be red, indicating an
    error. Simply use the *Alt + Enter* keyboard combination to import the `View`
    class and remove the errors.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The reason I said there "might" be an error is because it depends on how you
    entered the code. If you copied and pasted the code, then Android Studio may automatically
    add the `View` class import code. If you typed the new code, then the error will
    appear, and you will need to use the *Alt + Enter* key solution. This is just
    a quirk of Android Studio.
  prefs: []
  type: TYPE_NORMAL
- en: Deploy the app to a real device or emulator in the usual way and start tapping
    the buttons so we can observe the output.
  prefs: []
  type: TYPE_NORMAL
- en: Examining the output
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At last, our app does something we told it to do when we told it to do it. We
    can see that the method names we defined in the button `onClick` attribute are
    indeed called when the buttons are clicked, and the appropriate messages are added
    to the `Toast` messages are shown to the user.
  prefs: []
  type: TYPE_NORMAL
- en: Admittedly, we still don't understand why or how the `Toast` and `Log` classes
    really work, neither do we fully comprehend the `public void` and `(View v)` parts
    of our method's syntax (or much of the rest of the auto-generated code). This
    will become clearer as we progress. As said previously, in [*Chapter 10*](B16773_10_ePub_RK.xhtml#_idTextAnchor187)*,
    Object-Oriented Programming*, we will take a deep dive into the world of classes,
    and in [*Chapter 9*](B16773_09_ePub_RK.xhtml#_idTextAnchor169)*, Learning Java
    Methods*, we will master the rest of the syntax associated with methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Check the `onCreate` method just as before, as well as from the two methods
    that we wrote ourselves, each time you clicked one of the buttons. In the following
    figure, you can see I clicked each button three times:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.23 – Logcat window output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.23_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.23 – Logcat window output
  prefs: []
  type: TYPE_NORMAL
- en: 'As you are now familiar with where to find the **Logcat** window, in future
    I will present **Logcat** output as trimmed text as follows, as it is easier to
    read:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'And in the next figure, you can see that the top button has been clicked and
    the `topClick` method was called, triggering the pop-up `Toast` message highlighted
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.24 – Pop-up Toast message'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.24_B16773.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.24 – Pop-up Toast message
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this book, we will regularly output to the **Logcat** window, so
    we can see what is going on behind the UI of our apps. Toast messages are more
    for notifying the user that something has occurred. This might be a download that
    has completed, a new email that has arrived, or some other occurrence that the
    user might want to be informed about.
  prefs: []
  type: TYPE_NORMAL
- en: Frequently asked questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Can you remind me what methods are?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Methods are containers for our code that can be executed (called) from other
    parts of our code. Methods are contained within a class.
  prefs: []
  type: TYPE_NORMAL
- en: Like the first, I found this chapter tough going. Do I need to reread it?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: No; if you managed to build the app, you have made enough progress to handle
    the next chapter. All the blanks in your knowledge will be steadily filled in
    and replaced with glorious moments of realization as the book progresses.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have achieved a lot in this chapter. It is true that much of the XML code
    is still generally incomprehensible. That's OK, because in the next two chapters
    we will be really getting to grips with the visual designer and learning more
    about XML, although ultimately our aim is to use XML as little as possible.
  prefs: []
  type: TYPE_NORMAL
- en: We have seen how, when we drag a button onto our design, the XML code is generated
    for us. Also, if we change an attribute in the **Attributes** window, then, again,
    the XML code is edited for us. Furthermore, we saw that we can type (or, in our
    case, copy and paste) XML code directly in the **Code** tab to create new buttons
    on our UI or edit existing ones.
  prefs: []
  type: TYPE_NORMAL
- en: We have seen as well as written our first Java, including comments that help
    us document our code, and we have even added our own methods to output debugging
    messages to the Logcat window and pop-up `Toast` messages to the user.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will take a full guided tour of Android Studio to see
    exactly where different things get done at the same time as understanding how
    our project's assets, such as files and folders, are structured and how we can
    manage them. This will prepare us to go for a more in-depth look at UI design
    in [*Chapter 4*](B16773_04_ePub_RK.xhtml#_idTextAnchor076)*, Getting Started with
    Layouts and Material Design,* and [*Chapter 5*](B16773_05_ePub_RK.xhtml#_idTextAnchor101)*,
    Beautiful Layouts with CardView and ScrollView*, when we will build some significant
    real-world layouts for our apps.
  prefs: []
  type: TYPE_NORMAL
