- en: Database Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter explains how to write Java code that can manipulate—insert, read,
    update, delete—data in a database. It also provides a short introduction to the
    SQL language and basic database operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What is **Java Database Connectivity** (**JDBC**)?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create/delete a database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Short overview of **Structured Query Language** (**SQL**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create/delete/modify a database table
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Create, read, update, and delete** (**CRUD**) database data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exercise – Selecting unique first names
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is Java Database Connectivity (JDBC)?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Java Database Connectivity** (**JDBC**) is Java functionality that allows
    us to access and modify data in a database. It is supported by the JDBC API (the `java.sql`, `javax.sql`,
    and `java.transaction.xa` packages) and the database-specific implementation of
    an interface for the database access (called a database driver) provided by each
    database vendor.'
  prefs: []
  type: TYPE_NORMAL
- en: When people say they are using JDBC, it means they write code that manages data
    in a database using the interfaces and classes of the JDBC API and a database-specific
    driver that knows how to connect the application with the particular database.
    Using this connection, an application can then issue requests written in **Structured
    Query Language** (**SQL**). Naturally, we are talking here only about the databases
    that understand SQL. They are called relational (or tabular) and compose the vast
    majority of the currently used databases, although some alternatives—a navigational
    database and NoSql, for example—are used too.
  prefs: []
  type: TYPE_NORMAL
- en: The `java.sql` and `javax.sql` packages are included in the Java Platform Standard
    Edition (Java SE). Historically, the `java.sql` package belonged to Java core,
    while the `javax.sql` package was considered a core extension. But later, the `javax.sql` package
    was included in the core too and the name was not changed to avoid breaking the
    existing application that used it. The `javax.sql` package contains the `DataSource`
    interface that supports the statement's pooling, distributed transactions, and
    rowsets. We will discuss each of these features in greater details in the following
    sections of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Working with a database includes eight steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Install the database by following the vendor instructions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a database user, a database, and the database schema – tables, views,
    stored procedures, and so on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the dependency to the application on a `.jar` with the database-specific
    driver.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect to the database from the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Construct a SQL statement.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Execute a SQL statement.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the result of the execution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Release (close) the database connection and other resources opened in the process.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Steps 1-3 are done only once, at the database setup before the application is
    run. Steps 4-8 are performed by the application repeatedly as needed. Steps 5-7
    can be repeated multiple times with the same database connection.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to the database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is the code fragment to connect to the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: String URL = "jdbc:postgresql://localhost/javaintro";
  prefs: []
  type: TYPE_NORMAL
- en: Properties prop = new Properties( );
  prefs: []
  type: TYPE_NORMAL
- en: //prop.put( "user", "java" );
  prefs: []
  type: TYPE_NORMAL
- en: //prop.put( "password", "secretPass123" );
  prefs: []
  type: TYPE_NORMAL
- en: try {
  prefs: []
  type: TYPE_NORMAL
- en: Connection conn = DriverManager.getConnection(URL, prop);
  prefs: []
  type: TYPE_NORMAL
- en: '} catch(SQLException ex){'
  prefs: []
  type: TYPE_NORMAL
- en: ex.printStackTrace();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: The commented lines show how you can set a user and password for your connection
    using the `java.util.Properties` class. The preceding is just an example of how to
    get a connection using the `DriverManger` class directly. Many keys for the passed-in
    properties are the same for all major databases, but some of them are database-specific.
    So, read your database vendor documentation for such details.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, for passing user and password only, we could use an overloaded
    version, `DriverManager.getConnection(String url, String user, String password)`.
  prefs: []
  type: TYPE_NORMAL
- en: It is a good practice to keep the password encrypted. We are not going to show
    you how to do it, but there are plenty of guides available on the internet.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way of connecting to a database is to use the `DataSource` interface.
    Its implementation is included in the same `.jar` with the database driver. In
    the case of PostgreSQL, there are two classes that implemented the `DataSource`
    interface: `org.postgresql.ds.PGSimpleDataSource` and `org.postgresql.ds.PGConnectionPoolDataSource`.
    We can use them instead of `DriverManager`. The following is an example of creating
    a database connection using the `org.postgresql.ds.PGSimpleDataSource` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: PGSimpleDataSource source = new PGSimpleDataSource();
  prefs: []
  type: TYPE_NORMAL
- en: source.setServerName("localhost");
  prefs: []
  type: TYPE_NORMAL
- en: source.setDatabaseName("javaintro");
  prefs: []
  type: TYPE_NORMAL
- en: source.setLoginTimeout(10);
  prefs: []
  type: TYPE_NORMAL
- en: Connection conn = source.getConnection();
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'To connect to the database using the `org.postgresql.ds.PGConnectionPoolDataSource` class,
    we only need to replace the first line in the preceding code with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: PGConnectionPoolDataSource source = new PGConnectionPoolDataSource();
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Using the `PGConnectionPoolDataSource` class allows us to create a pool of `Connection`
    objects in-memory. It is a preferred way because creating a `Connection` object
    takes time. The pooling allows us to do it up-front and then reuse the already
    created objects as needed. The pool size and other parameters can be set in the `postgresql.conf` file.
  prefs: []
  type: TYPE_NORMAL
- en: But whatever method of creating a database connection is used, we are going
    to hide it inside the `getConnection()` method and use it in all our code examples
    in the same way.
  prefs: []
  type: TYPE_NORMAL
- en: With the object of the `Connection` class acquired, we can now access the database
    to add, read, delete, or modify the stored data.
  prefs: []
  type: TYPE_NORMAL
- en: Closing the database connection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Keeping a database connection alive requires a significant amount of resources
    memory and CPU—so it is a good idea to close the connection and release the allocated
    resources as soon as you do not need them anymore. In the case of the pooling,
    the `Connection` object, when closed, is returned to the pool and consumes fewer
    resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before Java 7, the way to close a connection was by invoking the `close()` method
    in a `finally`-block with or without a catch-block:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Connection conn = getConnection();
  prefs: []
  type: TYPE_NORMAL
- en: try {
  prefs: []
  type: TYPE_NORMAL
- en: //use object conn here
  prefs: []
  type: TYPE_NORMAL
- en: '} finally {'
  prefs: []
  type: TYPE_NORMAL
- en: if(conn != null){
  prefs: []
  type: TYPE_NORMAL
- en: conn.close();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'The code inside the `finally`-block is always executed, whether the exception
    inside the try-block was thrown or not. But since Java 7, the `try...with...resources` construct
    does the job just fine on any object that implements the `java.lang.AutoCloseable` or `java.io.Closeable` interfaces. Since
    the `java.sql.Connection` object implements `AutoCloseable`, we can rewrite the
    previous code snippet as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: try (Connection conn = getConnection()) {
  prefs: []
  type: TYPE_NORMAL
- en: //use object conn here
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: catch(SQLException ex) {
  prefs: []
  type: TYPE_NORMAL
- en: ex.printStackTrace();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'The catch-clause is necessary because the auto-closeable resource throws `java.sql.SQLException`.
    One can argue that it does not save much in the way of typing. But the `close()` method of
    the `Connection` class can throw `SQLException` too, so the code with `finally`-block
    should be written more defensively:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Connection conn = getConnection();
  prefs: []
  type: TYPE_NORMAL
- en: try {
  prefs: []
  type: TYPE_NORMAL
- en: //use object conn here
  prefs: []
  type: TYPE_NORMAL
- en: '} finally {'
  prefs: []
  type: TYPE_NORMAL
- en: if(conn != null){
  prefs: []
  type: TYPE_NORMAL
- en: try {
  prefs: []
  type: TYPE_NORMAL
- en: conn.close();
  prefs: []
  type: TYPE_NORMAL
- en: '} catch(SQLException ex){'
  prefs: []
  type: TYPE_NORMAL
- en: //do here what has to be done
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding block already looks definitely like a more boilerplate code.
    Yet, even more, if we take into account that usually inside the `try`-block, some
    other code can throw `SQLException` too, then the preceding code should look as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Connection conn = getConnection();
  prefs: []
  type: TYPE_NORMAL
- en: try {
  prefs: []
  type: TYPE_NORMAL
- en: //use object conn here
  prefs: []
  type: TYPE_NORMAL
- en: '} catch(SQLException ex) {'
  prefs: []
  type: TYPE_NORMAL
- en: ex.printStackTrace();
  prefs: []
  type: TYPE_NORMAL
- en: '} finally {'
  prefs: []
  type: TYPE_NORMAL
- en: if(conn != null){
  prefs: []
  type: TYPE_NORMAL
- en: try {
  prefs: []
  type: TYPE_NORMAL
- en: conn.close();
  prefs: []
  type: TYPE_NORMAL
- en: '} catch(SQLException ex){'
  prefs: []
  type: TYPE_NORMAL
- en: //do here what has to be done
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'The boilerplate code grows, doesn''t it? And that is not the end of the story.
    In the next sections, you will learn that to send a database request, you also
    need to create a `java.sql.Statement`, which throws `SQLException` and has to
    be closed too. Then the preceding code grows even more:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Connection conn = getConnection();
  prefs: []
  type: TYPE_NORMAL
- en: try {
  prefs: []
  type: TYPE_NORMAL
- en: Statement statement = conn.createStatement();
  prefs: []
  type: TYPE_NORMAL
- en: try{
  prefs: []
  type: TYPE_NORMAL
- en: //use statement here
  prefs: []
  type: TYPE_NORMAL
- en: '} catch(SQLException ex){'
  prefs: []
  type: TYPE_NORMAL
- en: //some code here
  prefs: []
  type: TYPE_NORMAL
- en: '} finally {'
  prefs: []
  type: TYPE_NORMAL
- en: if(statement != null){
  prefs: []
  type: TYPE_NORMAL
- en: try {
  prefs: []
  type: TYPE_NORMAL
- en: '} catch (SQLException ex){'
  prefs: []
  type: TYPE_NORMAL
- en: //some code here
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '} catch(SQLException ex) {'
  prefs: []
  type: TYPE_NORMAL
- en: ex.printStackTrace();
  prefs: []
  type: TYPE_NORMAL
- en: '} finally {'
  prefs: []
  type: TYPE_NORMAL
- en: if(conn != null){
  prefs: []
  type: TYPE_NORMAL
- en: try {
  prefs: []
  type: TYPE_NORMAL
- en: conn.close();
  prefs: []
  type: TYPE_NORMAL
- en: '} catch(SQLException ex){'
  prefs: []
  type: TYPE_NORMAL
- en: //do here what has to be done
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can appreciate the `try...with...resources` construct in its full glory,
    especially if we take into account that it allows us to include multiple auto-closeable
    resources in the same clause:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: try (Connection conn = getConnection();
  prefs: []
  type: TYPE_NORMAL
- en: Statement statement = conn.createStatement()) {
  prefs: []
  type: TYPE_NORMAL
- en: //use statement here
  prefs: []
  type: TYPE_NORMAL
- en: '} catch(SQLException ex) {'
  prefs: []
  type: TYPE_NORMAL
- en: ex.printStackTrace();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'And since Java 9, we can make it even simpler:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Connection conn = getConnection();
  prefs: []
  type: TYPE_NORMAL
- en: try (conn; Statement statement = conn.createStatement()) {
  prefs: []
  type: TYPE_NORMAL
- en: //use statement here
  prefs: []
  type: TYPE_NORMAL
- en: '} catch(SQLException ex) {'
  prefs: []
  type: TYPE_NORMAL
- en: ex.printStackTrace();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Now it is clear that the `try...with...resources` construct is a hands-down
    winner.
  prefs: []
  type: TYPE_NORMAL
- en: Structured Query Language (SQL)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SQL is a rich language, and we do not have enough space to cover all its features.
    We just would like to enumerate a few of the most popular ones, so you become
    aware of their existence and can look them up as needed.
  prefs: []
  type: TYPE_NORMAL
- en: Similar to a Java statement, there is a SQL statement that expresses a database
    request like a complete sentence in the English language. Every statement can
    be executed either in a database console or by Java code using the JDBC connection.
    Programmers often test a SQL statement in a console before using it in the Java
    code because the turnaround in a console is much faster. One does not need to
    compile and execute a program while using a console.
  prefs: []
  type: TYPE_NORMAL
- en: There are SQL statements that create and delete a user and database. We will
    see the examples of such statements in the next section. There are also other
    statements related to a database as a whole, that are outside the scope of this
    book.
  prefs: []
  type: TYPE_NORMAL
- en: 'After a database is created, the following three SQL statements allow us to
    build and change the database structure – a table, function, constraint, or another
    database entity:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CREATE`: This statement creates a database entity'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ALTER`: This statement changes a database entity'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DROP`: This statement deletes a database entity'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are also various SQL statements that allow us to enquire about each database
    entity, which are outside the scope of this book too.
  prefs: []
  type: TYPE_NORMAL
- en: 'And there are four kinds of SQL statements that manipulate the data in the
    database:'
  prefs: []
  type: TYPE_NORMAL
- en: '`INSERT`: This statement adds data to the database'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SELECT`: This statement reads data from the database'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UPDATE`: This statement changes data in the database'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DELETE`: This statement deletes data from the database'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One or several various clauses can be added to the preceding statements that
    identify the data requested (`WHERE`-clause), the order in which the results have
    to be returned (`ORDER`-clause), and similar.
  prefs: []
  type: TYPE_NORMAL
- en: 'The JDBC connection allows to wrap one or a combination of the preceding SQL
    statements in one of the three classes that provide a different functionality
    on the database side:'
  prefs: []
  type: TYPE_NORMAL
- en: '`java.sql.Statement`: Just sends the statement to the database server for an
    execution'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.sql.PreparedStatement`: Caches the statement within a certain execution
    path on the database server, allowing it to be executed multiple times with different
    parameters in an efficient manner'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`java.sql.CallableStatement`: Executes a stored procedure in the database'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will start our demonstration with the statements that create and delete a
    database and its user.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a database and its structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Look up how to download and install your preferred database server. A database
    server is a software system that maintains and manages the database. For our demonstrations,
    we are going to use PostgreSQL, a free, open source database server.
  prefs: []
  type: TYPE_NORMAL
- en: After the database server is installed, we'll use its console for creating a
    database and its user with the corresponding permissions. There are many ways
    to structure the data store and the system of users with different levels of access.
    In this book, we will introduce only the basic approach, which allows us to demonstrate
    the main JDBC capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: CREATE and DROP the database and its user
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Read the database instructions and create, first, a `java` user and a `javaintro` database
    (or select any other name you prefer and use them instead in the provided code
    examples). Here is how we did it for PostgreSQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: CREATE USER java SUPERUSER;
  prefs: []
  type: TYPE_NORMAL
- en: CREATE DATABASE javaintro OWNER java;
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you made a mistake and decide to start anew, you can delete the created
    user and database using the following statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: DROP USER java;
  prefs: []
  type: TYPE_NORMAL
- en: DROP DATABASE javaintro;
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: We selected the `SUPERUSER` role for our user, but a good security practice
    recommends assigning such a powerful role to an administrator only. For an application,
    it is recommended to create a user who cannot create or change the database itself—its
    tables and constraints—but can only manage data. Also, it is a good practice to
    create another logical layer, called **schema**, that can have its own set of
    users and permissions. This way, several schemas in the same database could be
    isolated and each user (one of them is your application) can access only certain
    schemas. On an enterprise level, the common practice is to create synonyms for
    the database schema so that no application can access the original structure directly.
  prefs: []
  type: TYPE_NORMAL
- en: But, as we have mentioned already, for the purpose of this book, it is not needed,
    so we leave it to the database administrators who establish rules and guidelines
    suitable for the particular working conditions of each enterprise.
  prefs: []
  type: TYPE_NORMAL
- en: Now we can connect our application to the database.
  prefs: []
  type: TYPE_NORMAL
- en: CREATE, ALTER, and DROP table
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The standard SQL statement for the table creation looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: CREATE TABLE tablename (
  prefs: []
  type: TYPE_NORMAL
- en: column1 type1,
  prefs: []
  type: TYPE_NORMAL
- en: column2 type2,
  prefs: []
  type: TYPE_NORMAL
- en: column3 type3,
  prefs: []
  type: TYPE_NORMAL
- en: '....'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'The limitations for a table name, column names, and types of values that can
    be used depend on the particular database.  Here is an example of a command that
    creates table person in PostgreSQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: CREATE TABLE person (
  prefs: []
  type: TYPE_NORMAL
- en: id SERIAL PRIMARY KEY,
  prefs: []
  type: TYPE_NORMAL
- en: first_name VARCHAR NOT NULL,
  prefs: []
  type: TYPE_NORMAL
- en: last_name VARCHAR NOT NULL,
  prefs: []
  type: TYPE_NORMAL
- en: dob DATE NOT NULL
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, we have made the `dob` (date of birth) column not nullable.
    That imposes a constraint on our `Person` Java class that is going to represent
    the records of this table: its `dob` field cannot be `null`. And that was what
    we have done, you may recall, in [Chapter 6](6f2efa7b-2fd2-4c5d-a190-e58eb0cd6332.xhtml), *Interfaces,
    Classes, and Objects Construction*, when we created our `Person` class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: class Person {
  prefs: []
  type: TYPE_NORMAL
- en: private String firstName, lastName;
  prefs: []
  type: TYPE_NORMAL
- en: private LocalDate dob;
  prefs: []
  type: TYPE_NORMAL
- en: public Person(String firstName, String lastName, LocalDate dob) {
  prefs: []
  type: TYPE_NORMAL
- en: 'this.firstName = firstName == null ? "" : firstName;'
  prefs: []
  type: TYPE_NORMAL
- en: 'this.lastName = lastName == null ? "" : lastName;'
  prefs: []
  type: TYPE_NORMAL
- en: if(dob == null){
  prefs: []
  type: TYPE_NORMAL
- en: throw new RuntimeException("Date of birth is null");
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: this.dob = dob;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public String getFirstName() { return firstName; }
  prefs: []
  type: TYPE_NORMAL
- en: public String getLastName() { return lastName; }
  prefs: []
  type: TYPE_NORMAL
- en: public LocalDate getDob() { return dob; }
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: We did not set the size of the columns of the `VARCHAR` type, thus allowing
    those columns to store values of any length, while the integer type allows them
    to store numbers from 4,713 BC to 5,874,897 AD. `NOT NULL` was added because by
    default the column would be nullable, while we would like to make sure that all
    the columns are populated for each record. And our `Person` class supports it
    by setting first and last names to empty `String` values if they are `null`, as
    the parameters of the `Person` constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also identified the `id` column as `PRIMARY KEY`, which indicates that this
    column uniquely identifies the record. The `SERIAL` keyword means that we ask
    the database to generate the next integer value every time a new record is added,
    so each record will have a unique integer number. Alternatively, we could make `PRIMARY
    KEY` from the combination of `first_name`, `last_name`, and `dob`:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: CREATE TABLE person (
  prefs: []
  type: TYPE_NORMAL
- en: first_name VARCHAR NOT NULL,
  prefs: []
  type: TYPE_NORMAL
- en: last_name VARCHAR NOT NULL,
  prefs: []
  type: TYPE_NORMAL
- en: dob DATE NOT NULL,
  prefs: []
  type: TYPE_NORMAL
- en: PRIMARY KEY (first_name, last_name, dob)
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'But there is a chance that there are two people who have the same name and
    who were born on the same day, so we decided not to do it and added another field
    and constructor to the `Person` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: public class Person {
  prefs: []
  type: TYPE_NORMAL
- en: private String firstName, lastName;
  prefs: []
  type: TYPE_NORMAL
- en: private LocalDate dob;
  prefs: []
  type: TYPE_NORMAL
- en: private int id;
  prefs: []
  type: TYPE_NORMAL
- en: public Person(int id, String firstName,
  prefs: []
  type: TYPE_NORMAL
- en: String lastName, LocalDate dob) {
  prefs: []
  type: TYPE_NORMAL
- en: this(firstName, lastName, dob);
  prefs: []
  type: TYPE_NORMAL
- en: this.id = id;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public Person(String firstName, String lastName, LocalDate dob) {
  prefs: []
  type: TYPE_NORMAL
- en: 'this.firstName = firstName == null ? "" : firstName;'
  prefs: []
  type: TYPE_NORMAL
- en: 'this.lastName = lastName == null ? "" : lastName;'
  prefs: []
  type: TYPE_NORMAL
- en: if(dob == null){
  prefs: []
  type: TYPE_NORMAL
- en: throw new RuntimeException("Date of birth is null");
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: this.dob = dob;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public String getFirstName() { return firstName; }
  prefs: []
  type: TYPE_NORMAL
- en: public String getLastName() { return lastName; }
  prefs: []
  type: TYPE_NORMAL
- en: public LocalDate getDob() { return dob; }
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: We will use the constructor that accepts `id` for constructing an object based
    on the record in a database, while the other constructor will be used to create
    an object before inserting a new record.
  prefs: []
  type: TYPE_NORMAL
- en: 'We run the preceding SQL statement in a database console and create this table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00af477d-66c8-4e49-941b-8a8ddbaf76f0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If necessary, the table can be deleted by the `DROP` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: DROP table person;
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'The existing table can be changed using the `ALTER` command. For example, we
    can add an `address` column:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: ALTER table person add column address VARCHAR;
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are not sure whether such a column exists already, you can add IF EXISTS
    or IF NOT EXISTS:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: ALTER table person add column IF NOT EXISTS address VARCHAR;
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: But this possibility exists only since PostgreSQL 9.6.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another important consideration of the database table creation is whether an
    index has to be added. An index is a data structure that helps to accelerate the
    data search in the table without having to check every table record. An index
    can include one or more columns of a table. For example, an index for a primary
    key is created automatically. If you bring up the description of the table we
    have created already, you will see:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b447b61b-1d4f-4578-a9be-778d1c6c8ec9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can also add any index ourselves if we think (and have proven it through
    the experimentation) it will help the application''s performance. For example,
    we can allow case-insensitive search by first and last name by adding the following
    index:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: CREATE INDEX idx_names ON person ((lower(first_name), lower(last_name));
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'If the search speed improves, we leave the index in place. If not, it can be
    removed:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: drop index idx_names;
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: We remove it because an index has an overhead of additional writes and storage
    space.
  prefs: []
  type: TYPE_NORMAL
- en: 'And we can remove a column from a table too:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: ALTER table person DROP column address;
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: In our examples, we followed the naming convention of PostgreSQL. If you use
    a different database, we suggest you look up its naming convention and follow
    it, so the names you create align with those created automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Create, read, update, and delete (CRUD) data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have used a console to send SQL statements to the database. The same
    statements could be executed from Java code using the JDBC API, but tables are
    created only once, so there is not much sense in writing a program for a one-time
    execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'But managing data is another matter. That is the primary purpose of a program
    we are going to write now. In order to do that, first, we add the following dependency
    to the `pom.xml` file because we have installed PostgreSQL 9.6:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: <dependency>
  prefs: []
  type: TYPE_NORMAL
- en: <groupId>org.postgresql</groupId>
  prefs: []
  type: TYPE_NORMAL
- en: <artifactId>postgresql</artifactId>
  prefs: []
  type: TYPE_NORMAL
- en: <version>42.2.2</version>
  prefs: []
  type: TYPE_NORMAL
- en: </dependency>
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: INSERT statement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The SQL statement that creates (populates) data in the database has the following
    format:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: INSERT INTO table_name (column1,column2,column3,...)
  prefs: []
  type: TYPE_NORMAL
- en: VALUES (value1,value2,value3,...);
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'When several tables records have to be added, it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: INSERT INTO table_name (column1,column2,column3,...)
  prefs: []
  type: TYPE_NORMAL
- en: VALUES (value1,value2,value3,...), (value11,value21,value31,...), ...;
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before writing a program, let''s test our `INSERT` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c87f8461-b463-4dcb-a806-01b2bac288c7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'It worked without an error and returned the number of inserted rows as 1, so
    we are going to create the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: void executeStatement(String sql){
  prefs: []
  type: TYPE_NORMAL
- en: Connection conn = getConnection();
  prefs: []
  type: TYPE_NORMAL
- en: try (conn; Statement st = conn.createStatement()) {
  prefs: []
  type: TYPE_NORMAL
- en: st.execute(sql);
  prefs: []
  type: TYPE_NORMAL
- en: '} catch (SQLException ex) {'
  prefs: []
  type: TYPE_NORMAL
- en: ex.printStackTrace();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can execute the preceding method and insert another row:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: executeStatement("insert into person (first_name, last_name, dob)" +
  prefs: []
  type: TYPE_NORMAL
- en: '" values (''Bill'', ''Grey'', ''1980-01-27'')");'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: We will see the result of this and previous `INSERT`-statement execution in
    the next section, when we demonstrate `SELECT`-statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Meanwhile, we would like to discuss the most popular methods of the `java.sql.Statement`
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '`boolean execute(String sql)`: It returns `true` if the executed statement
    returns data (as a `java.sql.ResultSet` object) that can be retrieved using the `ResultSet
    getResultSet()` method of the `java.sql.Statement` interface. It returns `false`
    if the executed statement does not return data (the SQL statement was probably
    updating or inserting some rows) and the subsequent call to the `int getUpdateCount()` method
    of the `java.sql.Statement` interface returns the number of the affected rows.
    For example, if we have added the print statements to our `executeStatement()`
    method, we would see the following results after inserting a row:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: void executeStatement(String sql){
  prefs: []
  type: TYPE_NORMAL
- en: Connection conn = getConnection();
  prefs: []
  type: TYPE_NORMAL
- en: try (conn; Statement st = conn.createStatement()) {
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(st.execute(sql));      //prints: false'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(st.getResultSet());    //prints: null'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(st.getUpdateCount());  //prints: 1'
  prefs: []
  type: TYPE_NORMAL
- en: '} catch (SQLException ex) {'
  prefs: []
  type: TYPE_NORMAL
- en: ex.printStackTrace();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: '`ResultSet executeQuery(String sql)`: It returns data as a `java.sql.ResultSet` object
    (the executed SQL statement is expected to be `SELECT`-statement). The same data
    can be also retrieved by the subsequent call to the `ResultSet getResultSet()` method
    of the `java.sql.Statement` interface. The `int getUpdateCount()` method of the `java.sql.Statement` interface
    returns `-1`. For example, if we change our `executeStatement()` method and use `executeQuery()`,
    the results of `executeStatement("select first_name from person")` would be:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: void executeStatement(String sql){
  prefs: []
  type: TYPE_NORMAL
- en: Connection conn = getConnection();
  prefs: []
  type: TYPE_NORMAL
- en: try (conn; Statement st = conn.createStatement()) {
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(st.executeQuery(sql)); //prints: ResultSet'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(st.getResultSet());    //prints: ResultSet'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(st.getUpdateCount());  //prints: -1'
  prefs: []
  type: TYPE_NORMAL
- en: '} catch (SQLException ex) {'
  prefs: []
  type: TYPE_NORMAL
- en: ex.printStackTrace();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: '`int executeUpdate(String sql)`: It returns the number of the affected rows
    (the executed SQL statement is expected to be `UPDATE`-statement). The same number
    returns the subsequent call to the `int getUpdateCount()` method of the `java.sql.Statement` 
    interface. The subsequent call to the `ResultSet getResultSet()` method of the `java.sql.Statement` interface
    returns `null`. For example, if we change our `executeStatement()` method and
    use `executeUpdate()`, the results of `executeStatement("update person set first_name
    = ''Jim'' where last_name = ''Adams''")` would be:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: void executeStatement4(String sql){
  prefs: []
  type: TYPE_NORMAL
- en: Connection conn = getConnection();
  prefs: []
  type: TYPE_NORMAL
- en: try (conn; Statement st = conn.createStatement()) {
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(st.executeUpdate(sql));//prints: 1'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(st.getResultSet());    //prints: null'
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.println(st.getUpdateCount());  //prints: 1'
  prefs: []
  type: TYPE_NORMAL
- en: '} catch (SQLException ex) {'
  prefs: []
  type: TYPE_NORMAL
- en: ex.printStackTrace();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: SELECT-statement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `SELECT`-statement has the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: SELECT column_name, column_name
  prefs: []
  type: TYPE_NORMAL
- en: FROM table_name WHERE some_column = some_value;
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'When all the columns have to be selected, it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: SELECT * FROM table_name WHERE some_column=some_value;
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a more general definition of `WHERE`-clause:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: WHERE column_name operator value
  prefs: []
  type: TYPE_NORMAL
- en: 'Operator:'
  prefs: []
  type: TYPE_NORMAL
- en: =   Equal
  prefs: []
  type: TYPE_NORMAL
- en: <>  Not equal. In some versions of SQL, !=
  prefs: []
  type: TYPE_NORMAL
- en: Greater than
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: <   Less than
  prefs: []
  type: TYPE_NORMAL
- en: '>=  Greater than or equal'
  prefs: []
  type: TYPE_NORMAL
- en: <=  Less than or equal
  prefs: []
  type: TYPE_NORMAL
- en: IN  Specifies multiple possible values for a column
  prefs: []
  type: TYPE_NORMAL
- en: LIKE  Specifies the search pattern
  prefs: []
  type: TYPE_NORMAL
- en: BETWEEN  Specifies the inclusive range of vlaues in a column
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: The `column_name` operator value constructs can be combined using the `AND`
    and `OR` logical operator and grouped by brackets, `( )`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous statement, we have executed a `select first_name from person` SELECT-statement that
    returns all the first names recorded in the `person` table. Let''s now execute
    it again and print out the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Connection conn = getConnection();
  prefs: []
  type: TYPE_NORMAL
- en: try (conn; Statement st = conn.createStatement()) {
  prefs: []
  type: TYPE_NORMAL
- en: ResultSet rs = st.executeQuery("select first_name from person");
  prefs: []
  type: TYPE_NORMAL
- en: while (rs.next()){
  prefs: []
  type: TYPE_NORMAL
- en: 'System.out.print(rs.getString(1) + " "); //prints: Jim Bill'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '} catch (SQLException ex) {'
  prefs: []
  type: TYPE_NORMAL
- en: ex.printStackTrace();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: The `getString(int position)` method of the `ResultSet` interface extracts the `String`
    value from position `1` (the first in the list of columns in the `SELECT`-statement).
    There are similar getters for all primitive types, such as `getInt()` and `getByte()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also possible to extract the value from the `ResultSet` object by column
    name. In our case, it would be `getString("first_name")`. It is especially useful
    when the `SELECT`-statement looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: select * from person;
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: But bear in mind that extracting values from the `ResultSet` object by the column
    name is less efficient. The difference in performance is very small and becomes
    important only when the operation happens many times. Only the actual measuring
    and testing can tell if the difference is significant for your application or
    not. Extracting values by column name is especially attractive because it provides
    better code readability, which pays well in a long time during the application
    maintenance.
  prefs: []
  type: TYPE_NORMAL
- en: There are many other useful methods in the `ResultSet` interface. If your application
    reads data from a database, we highly recommend you read the documentation of
    the `SELECT`-statement and the `ResultSet` interface.
  prefs: []
  type: TYPE_NORMAL
- en: UPDATE-statement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The data can be changed by the `UPDATE`-statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: UPDATE table_name SET column1=value1,column2=value2,... WHERE-clause;
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have used such a statement to change the first name in one of the records
    from the original value `John` to a new value, `Jim`:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: update person set first_name = 'Jim' where last_name = 'Adams'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Later, using the `SELECT`-statement, we will prove that the change was successful. Without
    the `WHERE`-clause, all the records of the table would be affected.
  prefs: []
  type: TYPE_NORMAL
- en: DELETE-statement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The data can be deleted by the `DELETE`-statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: DELETE FROM table_name WHERE-clause;
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Without the `WHERE`-clause, all the records of the table are deleted. In the
    case of the `person` table, we can delete all the records using the `delete from
    person` SQL statement. The following statement deletes all the records with first
    name Jim from the `person` table:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: delete from person where first_name = 'Jim';
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Using the PreparedStatement class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An object of `PreparedStatement` —a sub-interface of the `Statement` interface—is
    designed to be cached in the database and then used to efficiently execute the
    SQL statement multiple times for different input values. Similar to an object
    of `Statement` (created by the `createStatement()` method), it can be created
    by the `prepareStatement()` method of the same `Connection` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same SQL statement that was used to generate the `Statement` object can
    be used to generate the `PreparedStatement` object, too. In fact, it is a good
    idea to consider using `PreparedStatement` for any SQL statement that is called
    multiple times because it performs better than `Statement`. To do it, all we need
    to change are these two lines in our preceding sample code:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: try (conn; Statement st = conn.createStatement()) {
  prefs: []
  type: TYPE_NORMAL
- en: ResultSet rs = st.executeQuery(sql);
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, we can use the `PreparedStatement` class the same way:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: try (conn; PreparedStatement st = conn.prepareStatement(sql)) {
  prefs: []
  type: TYPE_NORMAL
- en: ResultSet rs = st.executeQuery();
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'But the true usefulness of `PreparedStatement` shines because of its ability
    to accept parameters – the input values that substitute (in the order of their
    appearance) the `?` symbol. For example, we can create the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: List<Person> selectPersonsByFirstName(String sql, String searchValue){
  prefs: []
  type: TYPE_NORMAL
- en: List<Person> list = new ArrayList<>();
  prefs: []
  type: TYPE_NORMAL
- en: Connection conn = getConnection();
  prefs: []
  type: TYPE_NORMAL
- en: try (conn; PreparedStatement st = conn.prepareStatement(sql)) {
  prefs: []
  type: TYPE_NORMAL
- en: st.setString(1, searchValue);
  prefs: []
  type: TYPE_NORMAL
- en: ResultSet rs = st.executeQuery();
  prefs: []
  type: TYPE_NORMAL
- en: while (rs.next()){
  prefs: []
  type: TYPE_NORMAL
- en: list.add(new Person(rs.getInt("id"),
  prefs: []
  type: TYPE_NORMAL
- en: rs.getString("first_name"),
  prefs: []
  type: TYPE_NORMAL
- en: rs.getString("last_name"),
  prefs: []
  type: TYPE_NORMAL
- en: rs.getDate("dob").toLocalDate()));
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '} catch (SQLException ex) {'
  prefs: []
  type: TYPE_NORMAL
- en: ex.printStackTrace();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: return list;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the preceding method to read those records form the `person` table
    that match the `WHERE`-clause. For example, we can find all the records that have
    the first name `Jim`:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: String sql = "select * from person where first_name = ?";
  prefs: []
  type: TYPE_NORMAL
- en: List<Person> list = selectPersonsByFirstName(sql, "Jim");
  prefs: []
  type: TYPE_NORMAL
- en: 'for(Person person: list){'
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(person);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'The result will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: Person{firstName='Jim', lastName='Adams', dob=1999-08-23, id=1}
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Person` object is printed this way because we have added the following `toString()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: '@Override'
  prefs: []
  type: TYPE_NORMAL
- en: public String toString() {
  prefs: []
  type: TYPE_NORMAL
- en: return "Person{" +
  prefs: []
  type: TYPE_NORMAL
- en: '"firstName=''" + firstName + ''\'''' +'
  prefs: []
  type: TYPE_NORMAL
- en: '", lastName=''" + lastName + ''\'''' +'
  prefs: []
  type: TYPE_NORMAL
- en: '", dob=" + dob +'
  prefs: []
  type: TYPE_NORMAL
- en: '", id=" + id +'
  prefs: []
  type: TYPE_NORMAL
- en: '''}'';'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: 'The same result we would get from running the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: String sql = "select * from person where last_name = ?";
  prefs: []
  type: TYPE_NORMAL
- en: List<Person> list = selectPersonsByFirstName(sql, "Adams");
  prefs: []
  type: TYPE_NORMAL
- en: 'for(Person person: list){'
  prefs: []
  type: TYPE_NORMAL
- en: System.out.println(person);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: It is not a bad idea to always use prepared statements for CRUD operations.
    They might be a little slower if executed only once, but you can test to see whether
    this is the price you're willing to pay. What you get with prepared statements
    is consistent (better readable) code, more security (prepared statements are not
    vulnerable to SQL injection attack), and one fewer decision to make – just reuse
    the same code everywhere.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise – Selecting unique first names
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Write an SQL statement that selects all the names from the person table without
    duplicates. For example, assume that there are three records in the `person` table
    that have these first names: `Jim`, `Jim`, and `Bill`. The SQL statement you write
    must return `Jim` and `Bill`, without repeating the name `Jim` twice.'
  prefs: []
  type: TYPE_NORMAL
- en: We did not explain how to do it; you have to read the SQL documentation to find
    out how to select unique values.
  prefs: []
  type: TYPE_NORMAL
- en: Answer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Use the `distinct` keyword. The following SQL statement returns unique first
    names:'
  prefs: []
  type: TYPE_NORMAL
- en: '```java'
  prefs: []
  type: TYPE_NORMAL
- en: select distinct first_name from person;
  prefs: []
  type: TYPE_NORMAL
- en: '```'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter explained how to write Java code that can manipulate—insert, read,
    update, delete—data in a database. It also provided a short introduction to the
    SQL language and basic database operations. The reader has learned what JDBC is,
    how to create and delete a database and a table, and how to write a program that
    manages data in a table.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, the reader will learn the concept of functional programming.
    We will provide an overview of functional interfaces that come with JDK, explain
    how to use them in lambda expressions, and look at how to use lambda expressions
    in datastream processing.
  prefs: []
  type: TYPE_NORMAL
