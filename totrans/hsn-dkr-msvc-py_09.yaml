- en: Local Development with Kubernetes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Kubernetes进行本地开发
- en: In this chapter, you'll learn how to define a cluster, deploying all the interacting
    microservices, and how to work locally for development purposes. We will build
    on the concepts introduced in the previous chapter and we will describe how to
    configure the whole system in Kubernetes in practical terms, deploying multiple
    microservices, and how to make it work as a whole on your own local computer.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何定义一个集群，部署所有交互式微服务，以及如何在本地进行开发。我们将在上一章介绍的概念基础上构建，并描述如何在Kubernetes中实际配置整个系统，部署多个微服务，并使其在您自己的本地计算机上作为整体运行。
- en: 'Here, we will introduce the other two microservices: the Frontend and the Users
    Backend. They were discussed in [Chapter 1](ddb0a00a-6c5b-4ffe-b403-0f5f9f7a7df2.xhtml), *Making
    the Move – Design, Plan, and Execute*, in the *Strategic planning to break the
    monolith* section. We will see in this chapter how they need to be configured
    to work in Kubernetes. This is in addition to the Thoughts Backend introduced
    in [Chapter 2](8f5b60ee-fa8e-42ff-aa6c-fb27d4bd574a.xhtml), *Creating a REST Service
    with Python;* [Chapter 3](05dd2141-e113-43a2-8bd9-26fb97057913.xhtml), *Build,
    Run, and Test Your Service Using Docker*, and [Chapter 4](872309f3-42ba-493c-8595-af1e610af61a.xhtml),
    *Creating a Pipeline and Workflow*. We will discuss how to configure the three
    of them properly and add some other options to ensure their smooth operation once
    they''re deployed in a production environment.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将介绍另外两个微服务：前端和用户后端。它们在[第1章](ddb0a00a-6c5b-4ffe-b403-0f5f9f7a7df2.xhtml)中讨论过，“进行移动-设计，计划和执行”，在“战略规划以打破单体架构”部分。我们将在本章中看到它们需要如何配置才能在Kubernetes中运行。这是在[第2章](8f5b60ee-fa8e-42ff-aa6c-fb27d4bd574a.xhtml)中介绍的Thoughts后端，“使用Python创建REST服务”；[第3章](05dd2141-e113-43a2-8bd9-26fb97057913.xhtml)中介绍的“构建，运行和测试使用Docker的服务”；以及[第4章](872309f3-42ba-493c-8595-af1e610af61a.xhtml)中介绍的“创建管道和工作流程”。我们将讨论如何正确配置它们三个，并添加一些其他选项，以确保它们在部署到生产环境后能够顺利运行。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Implementing multiple services
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实施多个服务
- en: Configuring the services
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置服务
- en: Deploying the full system locally
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本地部署完整系统
- en: By the end of the chapter, you will have a working local Kubernetes system with
    the three microservices deployed and working as a whole. You will understand how
    the different elements work and how to configure and tweak them.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将拥有一个在本地工作的Kubernetes系统，其中部署并作为整体运行的三个微服务。您将了解不同元素的工作原理以及如何配置和调整它们。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For this chapter, you need to have a local Kubernetes instance running as described
    in the previous chapter. Remember to have the Ingress controller installed.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，您需要按照上一章的描述运行本地Kubernetes实例。记得安装Ingress控制器。
- en: You can check the full code that we are going to use in the GitHub repository
    ([https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/tree/master/Chapter06](https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/tree/master/Chapter06)).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub存储库中查看我们将在其中使用的全部代码（[https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/tree/master/Chapter06](https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/tree/master/Chapter06)）。
- en: Implementing multiple services
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施多个服务
- en: 'In the GitHub repo, you can find the three microservices that we will be using
    in this chapter. They are based on the monolith introduced in [Chapter 1](ddb0a00a-6c5b-4ffe-b403-0f5f9f7a7df2.xhtml),
    *Making the Move – Design, Plan, and Execute*, and are split into three elements:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在GitHub存储库中，您可以找到本章将使用的三个微服务。它们基于[第1章](ddb0a00a-6c5b-4ffe-b403-0f5f9f7a7df2.xhtml)中介绍的单体架构，“进行移动-设计，计划和执行”，并分为三个元素：
- en: '**Thoughts Backend**: As described in the previous chapter, this handles the
    storage of thoughts and the search for them.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Thoughts后端**：如前一章所述，它处理了思想的存储和搜索。'
- en: '**Users Backend**: This stores the users and allows them to log in. Based on
    the description of the authentication method, this creates a token that can be
    used to authenticate against other systems.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户后端**：这里存储用户并允许他们登录。根据身份验证方法的描述，它创建一个可用于对其他系统进行身份验证的令牌。'
- en: '**Frontend**: This comes from the monolith, but instead of accessing a database directly,
    it makes requests to the User and Thoughts Backends to replicate the functionality.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**前端**：这来自单体，但不直接访问数据库，而是向用户和Thoughts后端发出请求以复制功能。'
- en: Note that the static files are still being served by the Frontend, even though
    we described the final stage of the cluster serving them independently. This is
    done for simplicity and to avoid having an extra service.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，尽管我们描述了集群独立提供静态文件的最终阶段，但静态文件仍然由前端提供。这样做是为了简单起见，避免多余的服务。
- en: The aforementioned services are Dockerized in similar ways to how the Thoughts
    Backend was in [Chapter 3](05dd2141-e113-43a2-8bd9-26fb97057913.xhtml), *Build,
    Run, and Test Your Service Using Docker*. Let's look at some of the details for
    the other microservices.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 前述的服务都以类似的方式进行了Docker化，就像[第3章](05dd2141-e113-43a2-8bd9-26fb97057913.xhtml)中的Thoughts后端一样，*使用Docker构建、运行和测试您的服务*。让我们来看看其他微服务的一些细节。
- en: Describing the Users Backend microservice
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 描述用户后端微服务
- en: The code for the Users Backend can be found at [https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/tree/master/Chapter06/users_backend](https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/tree/master/Chapter06/users_backend).
    The structure is very similar to the Thoughts Backend, a Flask-RESTPlus application
    that communicates to a PostgreSQL database.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 用户后端的代码可以在[https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/tree/master/Chapter06/users_backend](https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/tree/master/Chapter06/users_backend)找到。结构与Thoughts后端非常相似，是一个与PostgreSQL数据库通信的Flask-RESTPlus应用程序。
- en: 'It has two endpoints, as seen in its Swagger interface:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 它有两个端点，如其Swagger接口中所示：
- en: '![](assets/b3fae995-d64e-42dd-90ab-e11643f75592.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/b3fae995-d64e-42dd-90ab-e11643f75592.png)'
- en: 'The endpoints are as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 端点如下：
- en: '|  | **Endpoint** | **Input** | **Returns** |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '|  | **端点** | **输入** | **返回** |'
- en: '| `POST` | `/api/login` | `{username: <username>, password: <password>}` |
    `{Authorized: <token header>}` |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| `POST` | `/api/login` | `{username: <username>, password: <password>}` |
    `{Authorized: <token header>}` |'
- en: '| `POST` | `/admin/users` | `{username: <username>, password: <password>}`
    | `<new_user>` |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| `POST` | `/admin/users` | `{username: <username>, password: <password>}`
    | `<new_user>` |'
- en: The `admin` endpoint allows you to create new users, and the login API returns
    a valid header that can be used for the Thoughts Backend.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`admin`端点允许您创建新用户，登录API返回一个有效的标头，可用于Thoughts后端。'
- en: 'The users are stored in the database with the following schema:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 用户存储在数据库中，具有以下模式：
- en: '| **Field** | **Format** | **Comments** |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| **字段** | **格式** | **注释** |'
- en: '| `id` | `Integer` | Primary key |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| `id` | `Integer` | 主键 |'
- en: '| `username` | `String (50)` | Username |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| `username` | `String (50)` | 用户名 |'
- en: '| `password` | `String(50)` | Password stored in plain text, which is a bad
    idea, but simplifies the example |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| `password` | `String(50)` | 以明文存储的密码，这是一个坏主意，但简化了示例 |'
- en: '| `creation` | `Datetime` | The time of the creation of the user |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `creation` | `Datetime` | 用户创建时间 |'
- en: 'This schema, in SQLAlchemy model definition, is described using the following
    code:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模式在SQLAlchemy模型定义中使用以下代码描述：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note that the creation date gets stored automatically. Also, note that we store
    the password in plain text. This is a *terrible, terrible idea in a production
    service*. You can check out an article called *How to store a password in the
    database?* ([https://www.geeksforgeeks.org/store-password-database/](https://www.geeksforgeeks.org/store-password-database/))
    to get general ideas for encrypting passwords with a salt seed. You can use a
    package such as `pyscrypt` ([https://github.com/ricmoo/pyscrypt](https://github.com/ricmoo/pyscrypt))
    to implement this kind of structure in Python.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，创建日期会自动存储。另外，请注意我们以明文形式存储密码。这在生产服务中是一个*非常糟糕的想法*。您可以查看一篇名为*如何在数据库中存储密码？*的文章（[https://www.geeksforgeeks.org/store-password-database/](https://www.geeksforgeeks.org/store-password-database/)）以获取有关使用盐种加密密码的一般想法。您可以使用`pyscrypt`（[https://github.com/ricmoo/pyscrypt](https://github.com/ricmoo/pyscrypt)）等软件包在Python中实现这种结构。
- en: The users *bruce* and *stephen *are added to the `db` example as a way of having
    example data.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 用户*bruce*和*stephen*被添加到`db`示例中，作为示例数据的一种方式。
- en: Describing the Frontend microservice
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 描述前端微服务
- en: The Frontend code is available in the GitHub repo. It is based on the Django
    monolith ([https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/tree/master/Chapter01/Monolith](https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/tree/master/Chapter01/Monolith))
    introduced in [Chapter 1](ddb0a00a-6c5b-4ffe-b403-0f5f9f7a7df2.xhtml), *Making
    the Move – Design, Plan, and Execute*.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 前端代码可以在GitHub仓库中找到。它基于第1章介绍的Django单体应用（[https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/tree/master/Chapter01/Monolith](https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/tree/master/Chapter01/Monolith)）。
- en: The main difference from the monolith is that the database is not accessed.
    Therefore, there are no uses for the Django ORM. They are replaced with HTTP requests
    to the other backends. To make the requests, we use the fantastic `requests` library.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 与单体应用的主要区别在于不访问数据库。因此，Django ORM没有用处。它们被替换为对其他后端的HTTP请求。为了发出请求，我们使用了很棒的`requests`库。
- en: 'For example, the `search.py` file gets converted into the following code, which
    delegates the search toward the Thoughts Backend microservice. Note how the request
    by the customer gets transformed into an internal API call to the `GET /api/thoughts`
    endpoint. The result is decoded in JSON and rendered in the template:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`search.py`文件被转换为以下代码，该代码将搜索委托给Thoughts后端微服务。请注意，客户的请求如何转换为对`GET /api/thoughts`端点的内部API调用。结果以JSON格式解码并在模板中呈现。
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The monolith equivalent code can be compared in the `Chapter01` subdirectory
    of the repo ([https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/blob/master/Chapter01/Monolith/mythoughts/thoughts/search.py](https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/blob/master/Chapter01/Monolith/mythoughts/thoughts/search.py)).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 单体应用的等效代码可以在仓库的`Chapter01`子目录中进行比较（[https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/blob/master/Chapter01/Monolith/mythoughts/thoughts/search.py](https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/blob/master/Chapter01/Monolith/mythoughts/thoughts/search.py)）。
- en: Note how we make a `get` request through the `requests` library to the defined
    search endpoint, which results in the `json` format being returned and rendered.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们通过`requests`库进行了`get`请求，以定义搜索端点，结果以`json`格式返回并呈现。
- en: The `THOUGTHS_BACKEND` root URL comes from the settings, in usual Django fashion.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`THOUGTHS_BACKEND`根URL来自设置，通常是Django的风格。'
- en: This example is a simple one because there's no authentication involved. The
    parameters are captured from the user interface, then routed toward the backend.
    The request gets properly formatted both toward the backend and once the result
    is obtained, and then rendered. This is the core of two microservices working
    together.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子很简单，因为没有涉及身份验证。参数是从用户界面捕获的，然后路由到后端。请求在向后端和获取结果时都得到了正确的格式化，然后呈现。这是两个微服务共同工作的核心。
- en: 'A more interesting case is the `list_thought` ([https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/blob/master/Chapter06/frontend/mythoughts/thoughts/thoughts.py#L18](https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/blob/master/Chapter06/frontend/mythoughts/thoughts/thoughts.py#L18))
    view. The following code lists the thoughts for the logged in user:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 更有趣的情况是“list_thought”（[https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/blob/master/Chapter06/frontend/mythoughts/thoughts/thoughts.py#L18](https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/blob/master/Chapter06/frontend/mythoughts/thoughts/thoughts.py#L18)）视图。以下代码列出了已登录用户的想法：
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, before doing anything, we need to check whether a user is logged in. This
    is done in the `get_username_from_session` call, which returns the `username`
    or `None`, if they're not logged in. If they're not logged in, the return gets
    redirected to the login screen.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之前，我们需要检查用户是否已登录。这是在“get_username_from_session”调用中完成的，该调用返回“用户名”或“无”，如果他们未登录。如果他们未登录，则返回将被重定向到登录屏幕。
- en: As this endpoint requires authentication, we need to add the session from the
    user in an `Authorization` header to our request. The session of the user can
    be obtained from the `request.COOKIES` dictionary.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 由于此端点需要身份验证，我们需要在请求中添加用户会话的“授权”标头。用户的会话可以从“request.COOKIES”字典中获取。
- en: As a safeguard, we need to check whether the returning status code from the
    backend is correct. For this call, any resulting status code that's not a 200
    (HTTP call correct) will produce a redirection to the login page.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 为了安全起见，我们需要检查后端返回的状态代码是否正确。对于此调用，任何不是200（HTTP调用正确）的结果状态代码都将重定向到登录页面。
- en: For simplicity and clarity, our example services are not handling different
    error cases. In a production system, there should be a differentiation between
    errors where the issue is that either the user is not logged in or there's another
    kind of user error (a 400 error), or the backend service is not available (a 500
    status code).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单和清晰起见，我们的示例服务不处理不同的错误情况。在生产系统中，应区分错误，其中问题是用户未登录或存在其他类型的用户错误（400错误），或者后端服务不可用（500状态代码）。
- en: Error handling, when done properly, is difficult, but worth doing well, especially
    if the error helps users to understand what happened.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当正确处理错误时，这是困难的，但值得做好，特别是如果错误有助于用户理解发生了什么。
- en: 'The `get_username_from_session` function encapsulates a call to `validate_token_header`,
    the same one as introduced in the previous chapter:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: “get_username_from_session”函数封装了对“validate_token_header”的调用，与上一章介绍的相同：
- en: '[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `settings` file contains the public key required to decode the token.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: “settings”文件包含解码令牌所需的公钥。
- en: In this chapter, for simplicity, we copied the key directly into the `settings`
    file. This is not the way to go for a production environment. Any secret should
    be obtained through the Kubernetes environment configuration. We will see how
    to do this in the following chapters.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，为简单起见，我们直接将密钥复制到“settings”文件中。这不是生产环境的做法。任何秘密都应通过Kubernetes环境配置获取。我们将在接下来的章节中看到如何做到这一点。
- en: The environment file needs to specify where both the base URLs for the Users
    Backend and the Thoughts Backend are, to be able to connect to them.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 环境文件需要指定用户后端和思想后端的基本URL，以便能够连接到它们。
- en: Connecting the services
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接服务
- en: It's possible to test the services working in unison only with `docker-compose`.
    Check that the `docker-compose.yaml` files in both the Users Backend and the Thoughts
    Backend expose different ports externally.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 只有使用`docker-compose`才能测试服务是否协同工作。检查用户后端和思想后端的`docker-compose.yaml`文件是否在外部暴露了不同的端口。
- en: 'The Thoughts Backend exposes port `8000` and the Users Backend exposes port
    `8001`. This allows the Frontend to connect to them (and expose port `8002`).
    This diagram shows how this system works:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 思想后端暴露端口`8000`，用户后端暴露端口`8001`。这允许前端连接到它们（并暴露端口`8002`）。这张图展示了这个系统是如何工作的：
- en: '![](assets/1a463150-339d-4bf2-8a94-374bb6a34ec3.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/1a463150-339d-4bf2-8a94-374bb6a34ec3.png)'
- en: You can see how the three services are isolated, as `docker-compose` will create
    its own network for them to connect. Both backends have their own container, which
    acts as the database.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到这三个服务是如何被隔离的，因为`docker-compose`将为它们创建自己的网络以便连接。两个后端都有自己的容器，充当数据库。
- en: The Frontend service needs to connect to the others. The URL of the services
    should be added to the `environment.env` file and should indicate the service
    with the IP of the computer.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 前端服务需要连接到其他服务。服务的URL应该添加到`environment.env`文件中，并指示具有计算机IP的服务。
- en: An internal IP such as localhost or `127.0.0.1` does not work, as it gets interpreted
    **inside the container. **You can obtain the local IP by running `ifconfig`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 像localhost或`127.0.0.1`这样的内部IP是无法工作的，因为它在容器内被解释。你可以通过运行`ifconfig`来获取本地IP。
- en: 'For example, if your local IP is `10.0.10.3`, the `environment.env` file should
    contain the following:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你的本地IP是`10.0.10.3`，`environment.env`文件应包含以下内容：
- en: '[PRE4]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If you access the Frontend service in your browser, it should connect to the
    other services.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在浏览器中访问前端服务，它应该连接到其他服务。
- en: A possibility could be to generate a bigger `docker-compose` file that includes
    everything. This could make sense if all the microservices are in the same Git
    repo, a technique known as **monorepo** ([https://gomonorepo.org/](https://gomonorepo.org/)).
    Possible problems include keeping both the internal `docker-compose` to work with
    a single system and the general one in sync so that the automated tests should
    detect any problems.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 一个可能的选择是生成一个更大的`docker-compose`文件，其中包括所有内容。如果所有微服务都在同一个Git存储库中，这可能是有意义的，这种技术被称为**monorepo**（[https://gomonorepo.org/](https://gomonorepo.org/)）。可能的问题包括保持内部`docker-compose`与单个系统一起工作，并使通用的`docker-compose`保持同步，以便自动化测试能够检测到任何问题。
- en: This structure is a bit cumbersome, so we can transform it into a proper Kubernetes
    cluster, aiming at local development.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这种结构有点麻烦，所以我们可以将其转换为一个适合本地开发的正确的Kubernetes集群。
- en: Configuring the services
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置服务
- en: 'To configure the apps in Kubernetes, we need to define the following Kubernetes
    objects per app:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Kubernetes中配置应用程序，我们需要为每个应用程序定义以下Kubernetes对象：
- en: '**Deployment**: The deployment will control the creation of pods, so they will
    always be available. It will also create them based on the image and will add
    configuration, where needed. The pod runs the app.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**部署**：部署将控制pod的创建，以便它们始终可用。它还将根据图像创建它们，并在需要时添加配置。pod运行应用程序。'
- en: '**Service**: The service will make the RESTful requests available inside the
    cluster, with a short name. This routes the requests to any available pod.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务**：服务将使RESTful请求在集群内可用，使用一个简短的名称。这将把请求路由到任何可用的pod。'
- en: '**Ingress**: This makes the service available outside of the cluster, so we
    can access the app from outside the cluster.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Ingress**：这使得服务在集群外可用，因此我们可以从集群外访问该应用程序。'
- en: In this section, we will look at the Thoughts Backend configuration in detail
    as an example. Later, we will see how the different parts connect. We created
    a Kubernetes sub-directory ([https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/tree/master/Chapter06/thoughts_backend/kubernetes](https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/tree/master/Chapter06/thoughts_backend/kubernetes))
    to store the `.yaml` files with each of the definitions.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将详细查看Thoughts Backend配置作为一个例子。稍后，我们将看到不同部分是如何连接的。我们创建了一个Kubernetes子目录（[https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/tree/master/Chapter06/thoughts_backend/kubernetes](https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/tree/master/Chapter06/thoughts_backend/kubernetes)）来存储每个定义的`.yaml`文件。
- en: 'We will use the `example` namespace, so be sure that it''s created:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`example`命名空间，所以请确保它已经创建：
- en: '[PRE5]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Let's start with the first Kubernetes object.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从第一个Kubernetes对象开始。
- en: Configuring the deployment
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置部署
- en: For the Thoughts Backend deployment, we will deploy a pod with two containers,
    one with the database, and another with the application. This configuration makes
    it easy to work locally but keep in mind that recreating the pod will restart
    both containers.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Thoughts Backend部署，我们将部署一个包含两个容器的pod，一个是数据库，另一个是应用程序。这种配置使得在本地工作变得容易，但请记住，重新创建pod将重新启动两个容器。
- en: 'The file for configuration is fully available here ([https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/blob/master/Chapter06/thoughts_backend/kubernetes/deployment.yaml](https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/blob/master/Chapter06/thoughts_backend/kubernetes/deployment.yaml)),
    so let''s take a look at its different parts. The first element describes what
    it is and its name, as well as the namespace it lives at:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 配置文件完全在这里可用（[https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/blob/master/Chapter06/thoughts_backend/kubernetes/deployment.yaml](https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/blob/master/Chapter06/thoughts_backend/kubernetes/deployment.yaml)），所以让我们来看看它的不同部分。第一个元素描述了它是什么以及它的名称，以及它所在的命名空间：
- en: '[PRE6]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then, we generate `spec`. It contains how many pods we should keep and the
    template for each pod. `selector` defines what labels are monitored, and it should
    match the `labels` in the template:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们生成`spec`。它包含了我们应该保留多少个pod以及每个pod的模板。`selector`定义了要监视的标签，它应该与模板中的`labels`匹配：
- en: '[PRE7]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `template` section defines the containers in its own `spec` section:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`template`部分定义了其自己的`spec`部分中的容器：'
- en: '[PRE8]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`thoughts-backend-db` is simpler. The only required element is to define the
    name of the container and the image. We need to define the pulling policy as `Never`
    to indicate that the image is available in the local Docker repo, and that it''s
    not necessary to pull it from a remote registry:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`thoughts-backend-db`更简单。唯一需要的元素是定义容器的名称和镜像。我们需要将拉取策略定义为`Never`，以指示镜像在本地Docker仓库中可用，并且不需要从远程注册表中拉取它：'
- en: '[PRE9]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`thoughts-backend-service` needs to define the exposed port for the service
    as well as the environment variables. The variable values are the ones that we
    used previously when creating the database, except for `POSTGRES_HOST`, where
    we have the advantage that all containers in the same pod share the same IP:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`thoughts-backend-service`需要定义服务的暴露端口以及环境变量。变量的值是我们之前创建数据库时使用的值，除了`POSTGRES_HOST`，在这里我们有一个优势，即同一pod中的所有容器共享相同的IP：'
- en: '[PRE10]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To get the deployment in Kubernetes, you need to apply the file, as shown here:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Kubernetes中获取部署，您需要应用该文件，如下所示：
- en: '[PRE11]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The deployment is now created in the cluster:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 部署现在在集群中创建了：
- en: '[PRE12]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This creates pods automatically. If the pod is deleted or crashes, the deployment
    will restart it with a different name:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这将自动创建Pod。如果Pod被删除或崩溃，部署将使用不同的名称重新启动它：
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The deployment is tracking the latest image, but it won''t create a new pod
    unless it''s deleted. To make changes, be sure to delete the pod manually, after
    which it will be recreated:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 部署正在跟踪最新的镜像，但除非删除了Pod，否则不会创建新的Pod。要进行更改，请务必手动删除Pod，之后它将被重新创建：
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The application is still not discoverable inside the cluster, other than referring
    to it by its specific pod name, which can change, so we need to create a service
    for that.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序在集群内仍然无法被发现，除非通过其特定的Pod名称引用它，但是Pod名称可能会更改，因此我们需要为此创建一个服务。
- en: Configuring the service
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置服务
- en: 'We create a Kubernetes service to create a name for the application exposed
    by the created deployment. The service can be checked in the `service.yaml` file.
    Let''s take a look:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个Kubernetes服务，为创建的部署公开的应用程序创建了一个名称。服务可以在`service.yaml`文件中进行检查。让我们来看一下：
- en: '[PRE15]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The initial data is similar to the deployment. The `spec` section defines the
    open ports, routing access to the service on port `80` to port `8000` in containers
    in `thoughts-backend`, the name of the deployment. The `selector` part routes
    all the requests to any pod that matches.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 初始数据类似于部署。`spec`部分定义了开放端口，将对端口`80`上的服务的访问路由到`thoughts-backend`中容器的端口`8000`，这是部署的名称。`selector`部分将所有请求路由到与之匹配的任何Pod。
- en: 'The type is `NodePort` to allow access from outside the cluster. This allows
    us to check that it is working correctly, once we find the externally exposed
    IP:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 类型是`NodePort`，以允许从集群外部访问。这使我们能够检查它是否正常工作，一旦我们找到外部暴露的IP：
- en: '[PRE16]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We can access the Thoughts Backend by accessing localhost with the described
    pod. In this case, `http://127.0.0.1:31600`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过访问描述的Pod在本地主机上访问Thoughts Backend。在这种情况下，是`http://127.0.0.1:31600`：
- en: '![](assets/4281d880-2b90-4375-b757-16fca37b7c00.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/4281d880-2b90-4375-b757-16fca37b7c00.png)'
- en: The service gives us an internal name, but if we want to have control over how
    it is exposed externally, we need to configure an Ingress.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 服务为我们提供了一个内部名称，但如果我们想要控制它如何在外部暴露，我们需要配置一个Ingress。
- en: Configuring the Ingress
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置Ingress
- en: 'Finally, we describe the Ingress in `ingress.yaml` ([https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/blob/master/Chapter06/thoughts_backend/kubernetes/ingress.yaml](https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/blob/master/Chapter06/thoughts_backend/kubernetes/ingress.yaml)).
    The file is copied here. Note how we set up the metadata to live in the proper
    namespace:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在`ingress.yaml`中描述了Ingress（[https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/blob/master/Chapter06/thoughts_backend/kubernetes/ingress.yaml](https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/blob/master/Chapter06/thoughts_backend/kubernetes/ingress.yaml)）。该文件在此处被复制。请注意我们如何设置元数据以存在于正确的命名空间中：
- en: '[PRE17]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This Ingress will make the service be exposed to the nodes on port `80`. As
    multiple services can be exposed on the same nodes, they get distinguished by
    their hostname, in this case, `thoughts.example.local`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这个Ingress将使服务在端口`80`上暴露给节点。由于多个服务可以在同一节点上暴露，它们通过主机名进行区分，在这种情况下是`thoughts.example.local`。
- en: The Ingress controller we are using only allows exposing ports `80` (HTTP) and
    `443` (HTTPS) in `servicePort`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用的Ingress控制器只允许在`servicePort`中公开端口`80`（HTTP）和`443`（HTTPS）。
- en: 'After applying the service, we can try to access the page, but, unless we address
    the calls toward the proper host, we will get a 404 error:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 应用服务后，我们可以尝试访问页面，但是，除非我们将调用指向正确的主机，否则会收到404错误：
- en: '[PRE18]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We need to be able to point any request to `thoughts.example.local` to our
    localhost. In Linux and macOS, the easiest way is to change your `/etc/hosts`
    file to include the following line:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要能够将任何请求指向`thoughts.example.local`到我们的localhost。在Linux和macOS中，最简单的方法是更改您的`/etc/hosts`文件以包括以下行：
- en: '[PRE19]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then, we can use a browser to check our application, this time in `http://thoughts.example.local`
    (and port `80`):'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用浏览器检查我们的应用程序，这次是在`http://thoughts.example.local`（端口`80`）：
- en: '![](assets/ce2705b4-0075-4086-9b08-df80806271e5.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ce2705b4-0075-4086-9b08-df80806271e5.png)'
- en: Defining different host entries allows us to access all the services externally,
    to be able to tweak them and debug problems. We will define the rest of the Ingresses
    in the same way.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 定义不同的主机条目允许我们外部访问所有服务，以便能够调整它们并调试问题。我们将以相同的方式定义其余的Ingresses。
- en: If you get a `Connection refused` error and the word `localhost` does not appear
    when running `kubectl get ingress -n example`, your Kubernetes installation does
    not have the Ingress controller installed. Double-check the installation documentation
    at [https://github.com/kubernetes/ingress-nginx/blob/master/docs/deploy/index.md.](https://github.com/kubernetes/ingress-nginx/blob/master/docs/deploy/index.md)
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在运行`kubectl get ingress -n example`时出现`Connection refused`错误，并且单词`localhost`没有出现，您的Kubernetes安装没有安装Ingress控制器。请仔细检查[https://github.com/kubernetes/ingress-nginx/blob/master/docs/deploy/index.md](https://github.com/kubernetes/ingress-nginx/blob/master/docs/deploy/index.md)的安装文档。
- en: So now we have a working application deployed in Kubernetes locally!
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们在Kubernetes中本地部署了一个可工作的应用程序！
- en: Deploying the full system locally
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在本地部署完整系统
- en: Each of our microservices works on its own, but to have the whole system working,
    we need to deploy the three of them (Thoughts Backend, Users Backend, and Frontend)
    and connect them to each other. The Frontend, in particular, requires the other
    two microservices to be up and running. With Kubernetes, we can deploy it locally.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的每个微服务都可以独立运行，但要使整个系统工作，我们需要部署这三个（Thoughts后端、用户后端和前端）并将它们连接起来。特别是前端需要其他两个微服务正在运行。使用Kubernetes，我们可以在本地部署它。
- en: To deploy the full system, we need to deploy the Users Backend first, and then
    the Frontend. We will describe each of these systems, relating them to the already
    deployed Thoughts Backend, which we saw how to deploy before.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 要部署完整系统，我们需要先部署用户后端，然后再部署前端。我们将描述这些系统中的每一个，将它们与已部署的Thoughts后端相关联，我们之前看到如何部署它。
- en: Deploying the Users Backend
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署用户后端
- en: 'The Users Backend files are very similar to the Thoughts Backend. You can check
    them in the GitHub repo ([https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/tree/master/Chapter06/users_backend/kubernetes](https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/tree/master/Chapter06/users_backend/kubernetes)).
    Be sure that the environment settings in the `deployment.yaml` values are correct:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 用户后端文件与Thoughts后端非常相似。您可以在GitHub存储库中检查它们（[https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/tree/master/Chapter06/users_backend/kubernetes](https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/tree/master/Chapter06/users_backend/kubernetes)）。确保`deployment.yaml`中的环境设置值是正确的：
- en: '[PRE20]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Remember to be sure to include the new hostname in `/etc/hosts`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 请记得确保在`/etc/hosts`中包含新的主机名。
- en: '[PRE21]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: You can access the Users Backend in `http://users.example.local`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`http://users.example.local`访问用户后端。
- en: Adding the Frontend
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加前端
- en: 'The Frontend service and Ingress are very similar to the previous ones. The
    deployment is slightly different. Let''s take a look at the configuration, in
    three groups:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 前端服务和Ingress与之前的非常相似。部署略有不同。让我们分三组看一下配置：
- en: 'First, we add the metadata about the `namespace`, `name`, and the `kind` (deployment)
    as shown in the following code:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们添加关于`namespace`、`name`和`kind`（deployment）的元数据，如下面的代码所示：
- en: '[PRE22]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Then, we define the `spec` with the template and the number of `replicas`.
    Only one replica is fine for a local system:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用模板和`replicas`的数量定义`spec`。对于本地系统来说，一个副本就可以了：
- en: '[PRE23]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Finally, we `spec` out the template with the container definition:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们使用容器定义来`spec`出模板：
- en: '[PRE24]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The main difference from the previously defined Thoughts Backend deployment
    is that there's a single container and that the environment on it is simpler.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前定义的Thoughts后端部署的主要区别在于只有一个容器，而且它的环境更简单。
- en: We define the backend URLs environments as the service endpoints. These endpoints
    are available inside the cluster, so they'll be directed to the proper containers.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将后端URL环境定义为服务端点。这些端点在集群内可用，因此它们将被定向到正确的容器。
- en: Remember that the `*.example.local` addresses are only available in your computer,
    as they only live in `/etc/hosts`. Inside the container, they won't be available.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`*.example.local`地址仅在您的计算机上可用，因为它们只存在于`/etc/hosts`中。在容器内，它们将不可用。
- en: This is suitable for local development, but an alternative is to have a DNS
    domain that can be redirected to `127.0.0.1` or similar.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这适用于本地开发，但另一种选择是拥有一个可以重定向到`127.0.0.1`或类似地址的DNS域。
- en: 'We should add a new domain name in the `/etc/hosts` file:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该在`/etc/hosts`文件中添加一个新的域名：
- en: '[PRE25]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Django requires you to set up the `ALLOWED_HOSTS` setting's value, to allow
    it to accept the hostname, as, by default, it only allows connections from localhost.
    See the Django documentation ([https://docs.djangoproject.com/en/2.2/ref/settings/#allowed-hosts](https://docs.djangoproject.com/en/2.2/ref/settings/#allowed-hosts))
    for more information. To simplify things, we can allow any host using `'*'`. Check
    out the code on GitHub ([https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/blob/master/Chapter06/frontend/mythoughts/mythoughts/settings.py#L28](https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/blob/master/Chapter06/frontend/mythoughts/mythoughts/settings.py#L28)).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Django要求您设置`ALLOWED_HOSTS`设置的值，以允许它接受主机名，因为默认情况下它只允许从localhost进行连接。有关更多信息，请参阅Django文档（[https://docs.djangoproject.com/en/2.2/ref/settings/#allowed-hosts](https://docs.djangoproject.com/en/2.2/ref/settings/#allowed-hosts)）。为了简化事情，我们可以使用`'*'`来允许任何主机。在GitHub上查看代码（[https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/blob/master/Chapter06/frontend/mythoughts/mythoughts/settings.py#L28](https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/blob/master/Chapter06/frontend/mythoughts/mythoughts/settings.py#L28)）。
- en: In production, it's good practice to limit the hosts to the **Fully Qualified
    Domain Name** (**FQDN**), the full DNS name of a host, but the Kubernetes Ingress
    will check the host header and reject it if it's not correct.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产中，限制主机使用**完全合格的域名**（**FQDN**）是一个好的做法，即主机的完整DNS名称，但Kubernetes Ingress将检查主机头并在不正确时拒绝它。
- en: 'The Frontend application gets deployed as we''ve done before:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 前端应用程序部署与之前一样：
- en: '[PRE26]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Then we can access the full system, login, search, and so on.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以访问整个系统，登录，搜索等等。
- en: Remember that there are two users, `bruce` and `stephen`. Their passwords are
    the same as their usernames. You don't need to be logged in to search.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住有两个用户，`bruce`和`stephen`。他们的密码与用户名相同。您无需登录即可搜索。
- en: 'In your browser, go to `http://frontend.example.local/`:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中，转到`http://frontend.example.local/`：
- en: '![](assets/b45ab968-9029-4a8b-9c2a-7571d2057c07.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/b45ab968-9029-4a8b-9c2a-7571d2057c07.png)'
- en: Congratulations! You have a working Kubernetes system, including different deployed
    microservices. You can access each of the microservices independently to debug
    it or to carry out actions such as creating a new user, and so on.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您拥有一个可工作的Kubernetes系统，包括不同的部署的微服务。您可以独立访问每个微服务以进行调试或执行诸如创建新用户等操作。
- en: If you need to deploy a new version, build the proper containers using the `docker-compose`
    build and delete the pod to force the recreation of it.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要部署新版本，请使用`docker-compose`构建适当的容器并删除pod以强制重新创建它。
- en: Summary
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we saw how to deploy our microservices in a Kubernetes local
    cluster to allow local development and testing. Having the whole system deployed
    on your local computer greatly simplifies developing new features or debugging
    the behavior of the system. The production environment will be very similar, so
    this also lays the foundation for it.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了如何在Kubernetes本地集群中部署我们的微服务，以便进行本地开发和测试。在本地计算机上部署整个系统大大简化了开发新功能或调试系统行为的过程。生产环境将非常相似，因此这也为其奠定了基础。
- en: We first described the two microservices that were missing. The Users Backend
    handles the authentication for users and Frontend is a modified version of the
    monolith presented in [Chapter 1](ddb0a00a-6c5b-4ffe-b403-0f5f9f7a7df2.xhtml),
    *Making the Move – Design, Plan, and Execute*, which connects to the two backends.
    We showed how to build and run them in a `docker-compose` way.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先描述了两个缺失的微服务。用户后端处理用户的身份验证，前端是[第一章](ddb0a00a-6c5b-4ffe-b403-0f5f9f7a7df2.xhtml)中介绍的单体应用的修改版本，连接了这两个后端。我们展示了如何以`docker-compose`的方式构建和运行它们。
- en: After that, we described how to set up a combination of `.yaml` files to configure
    applications properly in Kubernetes. Each microservice has its own deployment
    to define the available pods, a service to define a stable access point, and an
    Ingress to allow external access. We described them in detail, and then applied
    them to all of the microservices.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们描述了如何设置一组`.yaml`文件的组合，以在Kubernetes中正确配置应用程序。每个微服务都有自己的部署来定义可用的pod，一个服务来定义一个稳定的访问点，以及一个Ingress来允许外部访问。我们对它们进行了详细描述，然后将它们应用到所有的微服务上。
- en: In the next chapter, we will see how to move from local deployment and deploy
    a Kubernetes cluster ready for production.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到如何从本地部署转移到部署一个准备好投入生产的Kubernetes集群。
- en: Questions
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What are the three microservices that we are deploying?
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们正在部署的三个微服务是什么？
- en: Which microservice requires the other two to be available?
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个微服务需要其他两个微服务可用？
- en: Why do we need to use external IPs to connect the microservices while running
    in `docker-compose`?
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么我们在运行`docker-compose`时需要使用外部IP来连接微服务？
- en: What are the main Kubernetes objects required for each application?
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个应用程序所需的主要Kubernetes对象是什么？
- en: Are any of the objects not required?
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是否有任何不需要的对象？
- en: Can you see any issues if we scale any of the microservices to more than one
    pod?
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们将任何微服务扩展到多个pod，您能否看到任何问题？
- en: Why are we using the `/etc/hosts` file?
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么我们要使用`/etc/hosts`文件？
- en: Further reading
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: You can learn more about Kubernetes in the books *Kubernetes for Developers*
    ([https://www.packtpub.com/eu/virtualization-and-cloud/kubernetes-developers](https://www.packtpub.com/eu/virtualization-and-cloud/kubernetes-developers))
    and *Kubernetes Cookbook - Second Edition* ([https://www.packtpub.com/in/virtualization-and-cloud/kubernetes-cookbook-second-edition](https://www.packtpub.com/in/virtualization-and-cloud/kubernetes-cookbook-second-edition)).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在书籍《Kubernetes for Developers》([https://www.packtpub.com/eu/virtualization-and-cloud/kubernetes-developers](https://www.packtpub.com/eu/virtualization-and-cloud/kubernetes-developers))和《Kubernetes
    Cookbook - Second Edition》([https://www.packtpub.com/in/virtualization-and-cloud/kubernetes-cookbook-second-edition](https://www.packtpub.com/in/virtualization-and-cloud/kubernetes-cookbook-second-edition))中了解更多关于Kubernetes的知识。
