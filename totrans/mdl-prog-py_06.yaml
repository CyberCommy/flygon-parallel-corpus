- en: Chapter 6. Creating Reusable Modules
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章。创建可重用模块
- en: 'As well as being a good technique for writing programs for your own use, modular
    programming is also an excellent way of writing programs that can be used by other
    programmers. In this chapter, we will look at how to design and implement modules
    and packages that can be shared and reused in other programs. In particular, we
    will:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 模块化编程不仅是一种为自己编写程序的好技术，也是一种为其他程序员编写的程序的绝佳方式。在本章中，我们将看看如何设计和实现可以在其他程序中共享和重用的模块和包。特别是，我们将：
- en: See how modules and packages can be used as a way of sharing the code that you
    write
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 看看模块和包如何被用作分享您编写的代码的一种方式
- en: See how writing a module for reuse differs from writing a module for use as
    part of just one program
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 看看为重用编写模块与为作为一个程序的一部分使用编写模块有何不同
- en: Discover what makes a module suitable for reuse
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发现什么使一个模块适合重用
- en: Look at examples of successful reusable modules
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 看一下成功可重用模块的例子
- en: Design a package to be reusable
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计一个可重用的包
- en: Implement a reusable package
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现一个可重用的包
- en: Let's start by taking a look at how you can use modules and packages to share
    your code with other people.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先看一下如何使用模块和包与其他人分享您的代码。
- en: Using modules and packages to share your code
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用模块和包来分享你的代码
- en: Whenever you write some Python source code, the code you create will perform
    a task of some sort. Maybe your code analyzes some data, stores some information
    into a file, or prompts the user to choose an item from a list. It doesn't matter
    what your code is—ultimately, your code does *something*.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您编写的Python源代码是什么，您创建的代码都会执行某种任务。也许您的代码分析一些数据，将一些信息存储到文件中，或者提示用户从列表中选择一个项目。您的代码是什么并不重要——最终，您的代码会*做某事*。
- en: 'Often, this something is very specific. For example, you might have a function
    that calculates compound interest, generates a Venn diagram, or displays a warning
    message to the user. Once you''ve written this code, you can then use it wherever
    you want in your own program. This is the simply abstraction pattern that was
    described in the previous chapter: you separate *what* you want to do from *how*
    you do it.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这是非常具体的。例如，您可能有一个计算复利、生成维恩图或向用户显示警告消息的函数。一旦您编写了这段代码，您就可以在自己的程序中随时使用它。这就是前一章中描述的简单抽象模式：您将*想要做什么*与*如何做*分开。
- en: Once you've written your function, you can then call it whenever you want to
    perform that task. For example, you can call your `display_warning()` function
    whenever you want to display a warning to the user, without worrying about the
    details of how the warning is displayed.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您编写了函数，您就可以在需要执行该任务时调用它。例如，您可以在需要向用户显示警告时调用您的`display_warning()`函数，而不必担心警告是如何显示的细节。
- en: However, this hypothetical `display_warning()` function isn't just useful in
    the program you are currently writing. Other programs may want to perform the
    same task—both programs that you write in the future and programs that other people
    may write. Rather than reinvent the wheel each time, it often makes sense to *reuse*
    your code.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个假设的`display_warning()`函数不仅在您当前编写的程序中有用。其他程序可能也想执行相同的任务——无论是您将来编写的程序还是其他人可能编写的程序。与其每次重新发明轮子，通常更有意义的是*重用*您的代码。
- en: To reuse your code, you have to share it. Sometimes, you might share your code
    with yourself so that you can use it within a different program. At other times,
    you might share your code with other developers so that they can use it within
    their own programs.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要重用您的代码，您必须分享它。有时，您可能会与自己分享代码，以便在不同的程序中使用它。在其他时候，您可能会与其他开发人员分享代码，以便他们在自己的程序中使用它。
- en: Of course, you don't just share code with others for philanthropic reasons.
    In a larger organization, you are often required to share code to improve the
    productivity of your peers. Even if you work by yourself, you will benefit by
    using code other people have shared and, by sharing your own code, other people
    can help find bugs and fix problems that you're not able to fix yourself.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您不仅仅出于慈善目的与他人分享代码。在一个较大的组织中，您经常需要分享代码以提高同事的生产力。即使您是独自工作，通过使用其他人分享的代码，您也会受益，并且通过分享自己的代码，其他人可以帮助找到错误并解决您自己无法解决的问题。
- en: 'Regardless of whether you share your code with yourself (in other projects)
    or with others (within your organization or in the wider development community),
    the basic process is the same. There are three main ways in which you can share
    your code:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您是与自己（在其他项目中）分享代码还是与他人（在您的组织或更广泛的开发社区中）分享代码，基本过程是相同的。有三种主要方式可以分享您的代码：
- en: You can create a code snippet that is then copied and pasted into the new program.
    The code snippet might be stored in an application called a `Code Snippet Manager`
    or a folder of text files, or even published as part of a blog.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以创建一个代码片段，然后将其复制并粘贴到新程序中。代码片段可以存储在一个名为“代码片段管理器”的应用程序中，也可以存储在一个文本文件夹中，甚至可以作为博客的一部分发布。
- en: You can place the code you want to share into a module or package, and then
    import this module or package into the new program. The module or package can
    be physically copied into the new program's source code, it can be placed in your
    Python installation's `site-packages` directory, or you can modify `sys.path`
    to include the directory where the module or package can be found.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以将要分享的代码放入一个模块或包中，然后将此模块或包导入新程序。该模块或包可以被物理复制到新程序的源代码中，可以放置在您的Python安装的`site-packages`目录中，或者您可以修改`sys.path`以包括可以找到模块或包的目录。
- en: Alternatively, you can turn your code into a standalone program, and then call
    this program from other code using `os.system()`.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 或者，您可以将您的代码转换为一个独立的程序，然后使用`os.system()`从其他代码中调用这个程序。
- en: 'While all these options work, not all of them are ideal. Let''s take a closer
    look at each one:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然所有这些选项都可以工作，但并非所有选项都是理想的。让我们更仔细地看看每一个：
- en: Code snippets are great for short pieces of code that form just part of a function.
    They're terrible, however, at keeping track of where that code ends up. Because
    you've copied and pasted the code into the middle of a new program, it is very
    easy to modify it as there's no easy way of distinguishing the pasted code from
    the rest of the program you've written. Also, if the original snippet needs to
    be modified, for example, to fix a bug, you'll have to find where you've used
    the snippet in your program and update it to match. All of this is rather messy
    and prone to errors.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码片段非常适合形成函数的代码的一部分。然而，它们非常糟糕，无法跟踪代码的最终位置。因为你已经将代码复制并粘贴到新程序的中间，所以很容易修改它，因为没有简单的方法可以区分粘贴的代码和你编写的程序的其余部分。此外，如果原始代码片段需要修改，例如修复错误，你将不得不找到在程序中使用代码片段的位置并更新以匹配。所有这些都相当混乱且容易出错。
- en: The technique of importing modules or packages has the advantage of working
    well with larger chunks of code. The code you are sharing can include multiple
    functions and even be split across multiple source files using a Python package.
    You are also much less likely to accidentally modify an imported module as the
    source code is stored in a separate file.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入模块或包的技术具有与较大代码块很好地配合的优势。你要分享的代码可以包括多个函数，甚至可以使用Python包将其拆分成多个源文件。由于源代码存储在单独的文件中，你也不太可能意外修改导入的模块。
- en: If you have copied the source module or package across to your new program,
    then you will need to manually update it if the original is changed. This is not
    ideal, but since you're replacing whole files, this isn't too difficult. On the
    other hand, if your new program uses a module stored elsewhere, then there's nothing
    to update—any changes made to the original module will immediately apply to any
    programs which use that module.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经将源模块或包复制到新程序中，那么如果原始模块发生更改，你将需要手动更新它。这并不理想，但由于你替换了整个文件，这并不太困难。另一方面，如果你的新程序使用存储在其他位置的模块，那么就没有需要更新的内容——对原始模块所做的任何更改将立即应用于使用该模块的任何程序。
- en: 'Finally, organizing your code into a standalone program means that your new
    program has to execute it. This can be done in the following way:'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，将代码组织成独立的程序意味着你的新程序必须执行它。可以通过以下方式完成：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see, it is possible to run another Python program, wait for it to
    finish, and then check the returned status code to ensure that the program ran
    successfully. You can also pass parameters to the running program if you wish.
    However, the information you can pass to the program and receive back is extremely
    limited. This approach will work, for example, if you have a program that parses
    an XML file and saves a summary of this file into a different file on disk, but
    you can't directly pass Python data structures to another program for processing,
    and you can't receive Python data structures back again.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，可以运行另一个Python程序，等待其完成，然后检查返回的状态码，以确保程序成功运行。如果需要，还可以向运行的程序传递参数。但是，你可以传递给程序和接收的信息非常有限。例如，如果你有一个解析XML文件并将该文件的摘要保存到磁盘上的不同文件的程序，这种方法将起作用，但你不能直接传递Python数据结构给另一个程序进行处理，也不能再次接收Python数据结构。
- en: Note
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Actually, you *can* transmit Python data structures between running programs,
    but the process involved is so complicated that it isn't worth considering.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，*可以*在运行的程序之间传输Python数据结构，但涉及的过程非常复杂，不值得考虑。
- en: 'As you can see, snippets, module/package imports, and standalone programs form
    a kind of continuum: snippets are very small and fine-grained, module and package
    imports support larger chunks of code while still being easy to use and update,
    and standalone programs are large but limited in the way you can interact with
    them.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，代码片段、模块/包导入和独立程序形成一种连续体：代码片段非常小且细粒度，模块和包导入支持更大的代码块，同时仍然易于使用和更新，独立程序很大，但在与其交互的方式上受到限制。
- en: 'Of these three, using module and package imports to share code appears to hit
    the sweet spot: they can be used for large amounts of code, are easy to use and
    interact with, and are trivially easy to update when necessary. This makes modules
    and packages the ideal mechanism for sharing your Python source code—both with
    yourself, for use in future projects, and with other people.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这三种方法中，使用模块和包导入来共享代码似乎是最合适的：它们可以用于大量代码，易于使用和交互，并且在必要时非常容易更新。这使得模块和包成为共享Python源代码的理想机制——无论是与自己共享，用于将来的项目，还是与其他人共享。
- en: What makes a module reusable?
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么使模块可重用？
- en: 'In order for a module or package to be reusable, it has to meet the following
    requirements:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使模块或包可重用，它必须满足以下要求：
- en: It must function as a standalone unit
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它必须作为一个独立的单元运行
- en: If your package is intended to be included as part of the source code for another
    system, you must use relative imports to load the other modules within your package
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你的包意图作为另一个系统的源代码的一部分被包含，你必须使用相对导入来加载包内的其他模块。
- en: Any external dependencies must be clearly noted
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何外部依赖关系都必须明确说明
- en: If a module or package does not meet these three requirements, it would be very
    hard, if not impossible, to reuse it in other programs. Let's now take a closer
    look at each of these requirements in turn.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个模块或包不满足这三个要求，要在其他程序中重用它将非常困难，甚至不可能。现在让我们依次更详细地看看这些要求。
- en: Functioning as a standalone unit
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 作为独立单元运行
- en: 'Imagine that you decide to share a module named `encryption`, which performs
    text encryption using public/private key pairs. Another programmer then copies
    this module into their program. When they try to use it, however, their program
    crashes with the following error message:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你决定分享一个名为`encryption`的模块，它使用公钥/私钥对执行文本加密。然后，另一个程序员将此模块复制到他们的程序中。然而，当他们尝试使用它时，他们的程序崩溃，并显示以下错误消息：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `encryption` module may have been shared, but it was dependent on another
    module within the original program (`hash_utils.py`) that wasn't shared, and so
    the `encryption` module by itself is useless.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution to this problem is to combine the module you want to share with
    any other modules it may depend upon, putting the modules together into a package.
    You then share the package, rather than the individual module. The following illustration
    shows how this might be done:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '![Functioning as a standalone unit](graphics/B05012_6_01.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
- en: In this example, we have created a new package named `encryptionlib` and moved
    both the `encryption.py` and `hash_utils.py` files into this package. Of course,
    this requires you to refactor the rest of your program to allow for the new position
    of these modules, but it does then allow you to reuse your encryption logic in
    other programs.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While it can be a nuisance having to refactor your program in this way, the
    result is almost always an improvement on your original program. Putting dependent
    modules together into a package helps to improve the overall organization of your
    code.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Using relative imports
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Continuing with the example from the previous section, imagine that you want
    to use your new `encryptionlib` package as part of another program, but don''t
    want to make it publically available as a separate package. In this case, you
    can simply include the entire `encryptionlib` directory as part of your new system''s
    source code. When you do this, however, you can run into problems if your modules
    don''t use relative imports. For example, if your `encryption` module is dependent
    on the `hash_utils` module, then the `encryption` module is going to include an
    `import` statement referring to the `hash_utils` module. However, the resulting
    package cannot be reused if the `encryption` module imports `hash_utils` in any
    of the following ways:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: All of these import statements will fail because they assume that the `hash_utils.py`
    file is at a particular fixed point in your program's source code. Any assumption
    about the position of a dependent module within the program's source code will
    limit the reusability of the package as you can't then move the package to a different
    place and expect it to work. Given the requirements of the new project, you will
    often have to store packages and modules in a different place from where they
    were originally developed. For example, perhaps the `encryptionlib` package needs
    to be installed in a `thirdparty` package along with all the other reused libraries.
    Using absolute imports, your package will fail because the location of the modules
    within it will have changed.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This doesn't apply if you publish your package and then install it into your
    Python `site-packages` directory. However, there are many situations where you
    don't want to install a reusable package inside the `site-packages` directory,
    and so you will need to be careful about relative imports.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, make sure that any `import` statements within a package
    that refer to other modules within the same package always use a relative import.
    For example:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This will allow your package to work no matter where in the Python source tree
    the package has been placed.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: Noting external dependencies
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Imagine that our new `encryptionlib` package makes use of the `NumPy` library
    we encountered in the previous chapter. Perhaps `hash_utils` imports some functions
    from NumPy and uses them to quickly calculate a binary hash of a list of numbers.
    Even though NumPy was installed as part of the original program, you can''t assume
    that the same is true of the new program: if you were to install the `encryptionlib`
    package into a new program and run it, it would eventually fail with the following
    error:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: To prevent this from happening, it is important that anyone wanting to reuse
    your module is aware of the dependency on a third-party module and knows exactly
    what needs to be installed for your module or package to function. An ideal place
    to include this information is in the `README` file or other documentation for
    the module or package you are sharing.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止发生这种情况，重要的是任何想要重用您的模块的人都知道对第三方模块的依赖，并且清楚地知道为了使您的模块或软件包正常运行需要安装什么。包含这些信息的理想位置是您共享的模块或软件包的`README`文件或其他文档。
- en: Note
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you are using an automated deployment system such as setuptools or pip, these
    tools have their own way of identifying your package's requirements. It is still
    a good idea, though, to list the requirements in your documentation so your users
    will be aware of them before the package is installed.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用诸如setuptools或pip之类的自动部署系统，这些工具有其自己的方式来识别您的软件包的要求。然而，将要求列在文档中仍然是一个好主意，这样您的用户在安装软件包之前就会意识到这些要求。
- en: What makes a good reusable module?
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是一个好的可重用模块？
- en: In the previous section, we looked at the *minimum* requirements for a reusable
    module. Let's now examine the *ideal* requirements for reusability. What would
    a perfect reusable module look like?
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们看了可重用模块的*最低*要求。现在让我们来看看可重用性的*理想*要求。一个完美的可重用模块会是什么样子？
- en: 'There are three things that distinguish an excellent reusable module from a
    poor one:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 优秀的可重用模块与糟糕的模块有三个区别：
- en: It attempts to solve a general problem (or range of problems), rather than just
    performing a specific task
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它试图解决一个一般性问题（或一系列问题），而不仅仅是执行一个特定的任务
- en: It follows standard conventions that make it easier to use the module elsewhere
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它遵循标准约定，使得在其他地方使用模块更容易
- en: The module is clearly documented so that other people can easily understand
    and use it
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该模块有清晰的文档，以便其他人可以轻松理解和使用它
- en: Let's take a closer look at each of these points.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看这些要点。
- en: Solving a general problem
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决一个一般性问题
- en: 'Often when you are programming, you will find that you need a specific task
    performed, and so you write a function to perform this task. For example, consider
    the following:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 通常在编程时，您会发现自己需要执行特定的任务，因此编写一个函数来执行此任务。例如，考虑以下情况：
- en: You need to convert from inches into centimeters, so you write an `inch_to_cm()`
    function to perform this task.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您需要将英寸转换为厘米，因此编写一个`inch_to_cm()`函数来执行此任务。
- en: 'You need to read a list of place names from a text file, which uses vertical
    bar characters (`|`) as delimiters between the fields:'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您需要从文本文件中读取地名列表，该文件使用垂直条字符（`|`）作为字段之间的分隔符：
- en: '[PRE5]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: To do this, you create a `load_placenames()` function that reads data from this
    file.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，您创建一个`load_placenames()`函数，从该文件中读取数据。
- en: 'You need to display the number of customers to a user:'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您需要向用户显示客户数量：
- en: '[PRE6]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Whether the message uses the word `customer` or `customers` depends on the number
    supplied. To handle this, you create a `pluralize_customers()` function that returns
    the appropriately pluralized version of the message depending on the number provided.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 消息使用`customer`还是`customers`取决于提供的数量。为了处理这个问题，您创建一个`pluralize_customers()`函数，根据提供的数量返回相应的复数形式的消息。
- en: 'In all of these examples, you are solving a specific problem. Quite frequently,
    functions like this will end up as part of a module, which you may want to reuse
    or share with others. However, these three functions, `inch_to_cm()`, `load_placenames()`,
    and `pluralize_customers()`, are all very specific to the problem you were trying
    to solve and so have limited applicability to new programs. All three are crying
    out to be made more general:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些例子中，您都在解决一个具体的问题。很多时候，这样的函数最终会成为一个模块的一部分，您可能希望重用或与他人分享。然而，这三个函数`inch_to_cm()`、`load_placenames()`和`pluralize_customers()`都非常特定于您尝试解决的问题，因此对新程序的适用性有限。这三个函数都迫切需要更加通用化：
- en: Instead of the `inch_to_cm()` function, write a function that converts *any*
    imperial distance into metric, and then create another function that does the
    opposite.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要编写`inch_to_cm()`函数，而是编写一个将*任何*英制距离转换为公制的函数，然后创建另一个函数来执行相反的操作。
- en: Instead of writing a function that just loads place names, implement a `load_delimited_text()`
    function which works for any sort of delimited text file and doesn't assume particular
    column names or that the delimiter is a vertical bar character.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要编写一个仅加载地名的函数，而是实现一个`load_delimited_text()`函数，该函数适用于任何类型的分隔文本文件，并且不假定特定的列名或分隔符是垂直条字符。
- en: 'Instead of pluralizing just customer names, write a more general `pluralize()`
    function that will pluralize the complete range of names you might need in your
    program. Because of the vagaries of the English language, you can''t just assume
    that all names can be pluralized by adding an *s* to the end; you''ll need a dictionary
    of exceptions such as person/people, axis/axes, and series/series, so that this
    function can handle the various sorts of names you might want to pluralize. To
    make this function even more useful, you can have it optionally accept the plural
    version of the name if it doesn''t know about the type of units you are pluralizing:'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要仅仅将客户名称变为复数形式，而是编写一个更通用的`pluralize()`函数，该函数将为程序中可能需要的所有名称变为复数形式。由于英语的种种变化，您不能仅仅假定所有名称都可以通过在末尾添加*s*来变为复数形式；您需要一个包含人/人们、轴/轴等的例外词典，以便该函数可以处理各种类型的名称。为了使这个函数更加有用，您可以选择接受名称的复数形式，如果它不知道您要变为复数的单位类型的话：
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: While these are just three specific examples, you can see that, by generalizing
    the code that you are sharing, you can make it apply to a much wider range of
    tasks. Often, there's very little more work involved in generalizing a function,
    but the result will be hugely appreciated by the people who use the code that
    you create.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这只是三个具体的例子，但您可以看到，通过将您共享的代码泛化，可以使其适用于更广泛的任务。通常，泛化函数所需的工作量很少，但结果将受到使用您创建的代码的人们的极大赞赏。
- en: Following standard conventions
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 遵循标准约定
- en: While you can write code any way you like, if you want to share your code with
    others it makes sense to follow standard coding conventions. This makes it easier
    for others to use your code without having to remember your library's particular
    style.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以按照自己的喜好编写代码，但如果你想与他人分享你的代码，遵循标准的编码约定是有意义的。这样可以使其他人在不必记住你的库特定风格的情况下更容易使用你的代码。
- en: 'To use a real-world example, consider the following snippet of code:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 举个实际的例子，考虑以下代码片段：
- en: '[PRE8]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This snippet of code makes use of two libraries: the Shapely library, which
    performs computational geometry, and the OGR library, which reads and writes geospatial
    data. The Shapely library follows the standard Python conventions of using lowercase
    letters for function and method names:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码利用了两个库：Shapely库，用于执行计算几何，以及OGR库，用于读写地理空间数据。Shapely库遵循使用小写字母命名函数和方法的标准Python约定：
- en: '[PRE9]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'While the details of these libraries are rather complex, the naming of these
    functions and methods is easy to remember and use. Compare this with the OGR library,
    however, which capitalizes the first letter of each function and method name:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些库的细节相当复杂，但这些函数和方法的命名易于记忆和使用。然而，与之相比，OGR库将每个函数和方法的第一个字母大写：
- en: '[PRE10]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Using these two libraries together, you have to constantly remember that OGR
    capitalizes the first letter of each function and method name, while Shapely does
    not. This makes using OGR more awkward than it needs to be and leads to quite
    a few errors in the resulting code that then need to be fixed.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这两个库时，你必须不断地记住OGR将每个函数和方法的第一个字母大写，而Shapely则不会。这使得使用OGR比必要更加麻烦，并导致生成的代码中出现相当多的错误，需要进行修复。
- en: All of this could have been avoided if the OGR library had simply followed the
    same naming conventions as Shapely.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果OGR库简单地遵循了与Shapely相同的命名约定，所有这些问题都可以避免。
- en: Fortunately, for Python there is a document called the **Python Style Guide**
    ([https://www.python.org/dev/peps/pep-0008/](https://www.python.org/dev/peps/pep-0008/))
    that provides a clear set of recommendations for how to format and style your
    code. The use of lowercase letters for function and method names comes from this
    guide, as does a whole raft of other recommendations which most Python code also
    follows. Everything from how to name your variables to when to place whitespace
    around a parenthesis is described in this document.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，对于Python来说，有一份名为**Python风格指南**（[https://www.python.org/dev/peps/pep-0008/](https://www.python.org/dev/peps/pep-0008/)）的文件，提供了一套清晰的建议，用于格式化和设计你的代码。函数和方法名称使用小写字母的惯例来自于这份指南，大多数Python代码也遵循这个指南。从如何命名变量到何时在括号周围放置空格，这份文件中都有描述。
- en: While coding conventions are a matter of personal preference, and you certainly
    aren't required to slavishly follow the instructions in the Python Style Guide,
    doing so (at least in so far as it affects the users of your code) will make your
    reusable modules and packages easier for others to use—just like with the example
    of the OGR library, you don't want users to have to constantly remember an unusual
    naming style whenever someone wants to import and use your code.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然编码约定是个人偏好的问题，你当然不必盲目遵循Python风格指南中的指示，但这样做（至少在影响你的代码用户方面）将使其他人更容易使用你的可重用模块和包——就像OGR库的例子一样，你不希望用户在想要导入和使用你的代码时不断记住一个不寻常的命名风格。
- en: Having clear documentation
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 清晰的文档
- en: 'Even if you wrote the perfect module, solving a range of generalized problems
    and faithfully adhering to the Python Style Guide, your module would be useless
    if nobody knew how to use it. Unfortunately, as programmers, we are often too
    close to our code: it''s obvious to us how our code works, and so we fall into
    the trap of assuming it must be obvious to others, too. On top of this, programmers
    often *hate* writing documentation—we''d much rather write a thousand lines of
    well-crafted Python code than one paragraph describing how it works. As a result,
    documentation for the code we share is often written reluctantly, if at all.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你编写了完美的模块，解决了一系列通用问题，并忠实地遵循了Python风格指南，如果没有人知道如何使用它，你的模块也是无用的。不幸的是，作为程序员，我们经常对我们的代码太过了解：我们很清楚我们的代码是如何工作的，所以我们陷入了假设其他人也应该很清楚的陷阱。此外，程序员通常*讨厌*编写文档——我们更愿意编写一千行精心编写的Python代码，而不是写一段描述它如何工作的话。因此，我们共享的代码的文档通常是勉强写的，甚至根本不写。
- en: The thing is, a high-quality reusable module or package will *always* include
    documentation. This documentation will both explain what the module does and how
    it works, and include examples so that readers can immediately see how to use
    this module or package within their own programs.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是，高质量的可重用模块或包将*始终*包括文档。这份文档将解释模块的功能和工作原理，并包括示例，以便读者可以立即看到如何在他们自己的程序中使用这个模块或包。
- en: 'For an example of an excellently documented Python module or package, we need
    look no further than the **Pyth** **on Standard Library** ([https://docs.python.org/3/library/](https://docs.python.org/3/library/)).
    Every module is clearly documented, with detailed information and examples to
    help guide the programmer. For example, the following is an abbreviated version
    of the documentation for the `datetime.timedelta` class:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个出色文档化的Python模块或包的例子，我们无需去看**Python标准库**（[https://docs.python.org/3/library/](https://docs.python.org/3/library/)）之外的地方。每个模块都有清晰的文档，包括详细的信息和示例，以帮助程序员进行指导。例如，以下是`datetime.timedelta`类的文档的简化版本：
- en: '![Having clear documentation](graphics/B05012_6_02.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![清晰的文档](graphics/B05012_6_02.jpg)'
- en: Every module, class, function, and method is clearly documented, with examples
    and detailed notes to help the user of this module.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 每个模块、类、函数和方法都有清晰的文档，包括示例和详细的注释，以帮助这个模块的用户。
- en: 'As the developer of a reusable module, you aren''t expected to quite reach
    these heights. The Python Standard Library is a huge, collaborative effort, and
    no one person wrote all this documentation. But this is a good example of the
    *type* of documentation that you should be aiming for: comprehensive documentation
    with plenty of examples.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 作为可重用模块的开发人员，您不必达到这些高度。Python标准库是一个庞大的协作努力，没有一个人编写了所有这些文档。但这是您应该追求的文档类型的一个很好的例子：包含大量示例的全面文档。
- en: 'While you can create documentation in a word processor, or using a sophisticated
    documentation-generation system such as the Sphinx system used to build the Python
    documentation, there are two very easy ways in which you can write documentation
    with a minimum of fuss: by creating a README file, or by using docstrings.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然您可以在文字处理器中创建文档，或者使用类似Sphinx系统的复杂文档生成系统来构建Python文档，但有两种非常简单的方法可以在最少的麻烦下编写文档：创建README文件或使用文档字符串。
- en: A `README` file is simply a text file that gets included with the various source
    files which make up your module or package. It would typically be named `README.txt`,
    and it is just an ordinary text file. You can create this file using the same
    editor that you use to edit your Python source code.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`README`文件只是一个文本文件，它与组成您的模块或包的各种源文件一起包含在内。它通常被命名为`README.txt`，它只是一个普通的文本文件。您可以使用用于编辑Python源代码的相同编辑器创建此文件。'
- en: A README file can be as extensive or minimal as you want. It is often helpful
    to include information on how to install and use the module, any licensing issues,
    a few usage examples, and acknowledgements if your module or package includes
    code from someone else.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: README文件可以是尽可能广泛或最小化的。通常有助于包括有关如何安装和使用模块的信息，任何许可问题，一些使用示例以及如果您的模块或包包含来自他人的代码，则包括致谢。
- en: 'A docstring is a Python string that gets *attached* to a module or function.
    This is used specifically for documentation purposes, and there is a very special
    Python syntax for creating docstrings:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 文档字符串是附加到模块或函数的Python字符串。这专门用于文档目的，有一个非常特殊的Python语法用于创建文档字符串：
- en: '[PRE11]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In Python, you can use three quote characters to mark a string that goes across
    more than one line of the Python source file. These triple-quoted strings can
    be used in various places, including docstrings. If a module starts with a triple-quoted
    string, then this string is used as the documentation for the module as a whole.
    Similarly, if any function starts with a triple-quoted string, then this string
    is used as documentation for that function.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，您可以使用三个引号字符标记跨越Python源文件的多行的字符串。这些三引号字符串可以用于各种地方，包括文档字符串。如果一个模块以三引号字符串开头，那么这个字符串将用作整个模块的文档。同样，如果任何函数以三引号字符串开头，那么这个字符串将用作该函数的文档。
- en: Note
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The same applies to other definitions in Python, such as classes, methods, and
    so on.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 同样适用于Python中的其他定义，例如类、方法等。
- en: Docstrings are typically used to describe what a module or function does, the
    parameters that are needed, and what information is returned. Any noteworthy aspects
    of the module or function should also be included, for example unexpected side
    effects, usage examples, and so on.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 文档字符串通常用于描述模块或函数的功能，所需的参数以及返回的信息。还应包括模块或函数的任何值得注意的方面，例如意外的副作用、使用示例等。
- en: Docstrings (and README files) don't have to be very extensive. You don't want
    to spend hours writing documentation on some obscure function within a module
    that only three people are ever likely to use. But well-written docstrings and
    README files are a sign of an excellent and easy-to-use module or package.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 文档字符串（和README文件）不必非常广泛。您不希望花费数小时来撰写关于模块中只有三个人可能会使用的某个晦涩函数的文档。但是写得很好的文档字符串和README文件是出色且易于使用的模块或包的标志。
- en: Writing documentation is a skill; like all skills, you get better at it with
    practice. To create high-quality modules and packages that can be shared, you
    should get into the habit of creating docstrings and README files as well as following
    coding conventions and generalizing your code as much as possible, as we described
    in previous sections of this chapter. If you aim to produce high-quality reusable
    code from the outset, you'll find that it isn't that hard.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 撰写文档是一种技能；像所有技能一样，通过实践可以变得更好。要创建可以共享的高质量模块和包，您应该养成创建文档字符串和README文件的习惯，以及遵循编码约定并尽可能地泛化您的代码，正如我们在本章的前几节中所描述的那样。如果您的目标是从一开始就产生高质量的可重用代码，您会发现这并不难。
- en: Examples of reusable modules
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可重用模块的示例
- en: You don't have to look very far to find examples of reusable modules; the **Python
    Package Index** ([https://pypi.python.org/pypi](https://pypi.python.org/pypi))
    provides a huge repository of shared modules and packages. You can search for
    a package by name or keyword, or you can browse through the repository by topic,
    license, intended audience, development status, and so on.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 您不必走得很远才能找到可重用模块的示例；**Python包索引**（[https://pypi.python.org/pypi](https://pypi.python.org/pypi)）提供了一个庞大的共享模块和包的存储库。您可以按名称或关键字搜索包，也可以按主题、许可证、预期受众、开发状态等浏览存储库。
- en: 'While the Python Package Index is huge, it is also extremely useful: all of
    the most successful packages and modules are included. Let''s look more closely
    at some of these more popular reusable packages.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Python包索引非常庞大，但也非常有用：所有最成功的包和模块都包含在其中。让我们更仔细地看一些更受欢迎的可重用包。
- en: requests
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: requests
- en: The `requests` library ([http://docs.python-requests.org/en/master/](http://docs.python-requests.org/en/master/))
    is a Python package that makes it easy to send HTTP requests to remote servers
    and process the response. While the `urllib2` package included in the Python Standard
    Library does allow you to make HTTP requests, it is often difficult to use and
    fails in unexpected ways. The `requests` package is far easier to use and more
    reliable; as a result, it has become extremely popular.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`requests`库（[http://docs.python-requests.org/en/master/](http://docs.python-requests.org/en/master/)）是一个Python包，它可以轻松地向远程服务器发送HTTP请求并处理响应。虽然Python标准库中包含的`urllib2`包允许您发出HTTP请求，但往往难以使用并以意想不到的方式失败。`requests`包更容易使用和更可靠；因此，它变得非常受欢迎。'
- en: 'The following example code shows how the `requests` library allows you to send
    a complex HTTP request and easily process the response:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例代码显示了`requests`库如何允许您发送复杂的HTTP请求并轻松处理响应：
- en: '[PRE12]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `requests` library automatically encodes the parameters that you want to
    send to the server, gracefully handles timeouts, and makes it easy to retrieve
    a JSON-format response.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`requests`库会自动对要发送到服务器的参数进行编码，优雅地处理超时，并轻松检索JSON格式的响应。'
- en: The requests library is very easy to install (in most cases, you can simply
    use pip install requests). It has excellent documentation, including a user's
    guide, a community guide, and detailed API documentation, and it fully conforms
    with the Python Style Guide. It also provides a very general set of features,
    handling all sorts of communication with external web sites and systems via the
    HTTP protocol. With all these things going for it, it's no wonder that `requests`
    is the third most popular package in the entire Python Package Index.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`requests`库非常容易安装（在大多数情况下，您可以简单地使用pip install requests）。它有很好的文档，包括用户指南、社区指南和详细的API文档，并且完全符合Python样式指南。它还提供了一套非常通用的功能，通过HTTP协议处理与外部网站和系统的各种通信。有了这些优点，难怪`requests`是整个Python包索引中第三受欢迎的包。'
- en: python-dateutil
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: python-dateutil
- en: The `dateutil` package ([https://github.com/dateutil/dateutil](https://github.com/dateutil/dateutil))
    extends the `datetime` package included in the Python Standard Library, adding
    support for recurring dates, time zones, complex relative dates, and more.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`dateutil`包（[https://github.com/dateutil/dateutil](https://github.com/dateutil/dateutil)）扩展了Python标准库中包含的`datetime`包，添加了对重复日期、时区、复杂相对日期等的支持。'
- en: 'The following example code calculates the date of Easter Friday in a much easier
    form than we used for the *happy hour* calculation in the previous chapter:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例代码计算复活节星期五的日期，比我们在上一章中用于*快乐时光*计算的形式要简单得多：
- en: '[PRE13]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`dateutil` provides excellent documentation with plenty of examples, is easy
    to install using `pip install python-dateutil`, follows the Python Style guide,
    and is extremely useful for solving a range of date- and time-related challenges.
    It is another example of a successful and popular package within the Python Package
    Index.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`dateutil`提供了大量示例的优秀文档，使用`pip install python-dateutil`很容易安装，遵循Python样式指南，对解决各种与日期和时间相关的挑战非常有用。它是Python包索引中另一个成功和受欢迎的包的例子。'
- en: lxml
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: lxml
- en: The `lxml` toolkit ([http://lxml.de](http://lxml.de)) is an example of a highly
    successful Python package that acts as a wrapper for two existing C libraries.
    As the well-written web site says, `lxml` takes the pain out of reading and writing
    XML- and HTML-formatted documents. It has been modeled after an existing library
    in the Python Standard Library (`ElementTree`) but is much faster, has more features,
    and won't crash in unexpected ways.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`lxml`工具包（[http://lxml.de](http://lxml.de)）是一个非常成功的Python包的例子，它作为两个现有的C库的包装器。正如其写得很好的网站所说，`lxml`简化了读取和写入XML和HTML格式文档的过程。它是在Python标准库中现有库（`ElementTree`）的基础上建模的，但速度更快，功能更多，并且不会以意想不到的方式崩溃。'
- en: 'The following example code shows how `lxml` can be used to quickly generate
    XML-format data:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例代码显示了如何使用`lxml`快速生成XML格式数据：
- en: '[PRE14]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This will print out an XML-formatted document with information about three
    classic movies:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印出一个包含三部经典电影信息的XML格式文档：
- en: '[PRE15]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Of course, `lxml` can do much more than this simple example shows. It can be
    used to parse documents as well as programmatically generate huge and complex
    XML files.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，`lxml`可以做的远不止这个简单的示例所展示的。它可以用于解析文档以及以编程方式生成庞大而复杂的XML文件。
- en: The `lxml` web site includes excellent documentation, including tutorials, information
    on how to install the package, and a complete API reference. For the particular
    tasks that it solves, `lxml` is extremely inviting and easy to use. It is no wonder
    that this is a highly popular package within the Python Package Index.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`lxml`网站包括优秀的文档，包括教程、如何安装包以及完整的API参考。对于它解决的特定任务，`lxml`非常吸引人且易于使用。难怪这是Python包索引中非常受欢迎的包。'
- en: Designing a reusable package
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计可重用的包
- en: 'Let''s now take what we''ve learned and apply it to the design and implementation
    of a useful Python package. In the previous chapter, we looked at the concept
    of encapsulating a recipe using a Python module. Part of each recipe is the notion
    of an ingredient, which has three parts:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将学到的知识应用到一个有用的Python包的设计和实现中。在上一章中，我们讨论了使用Python模块封装食谱的概念。每个食谱的一部分是成分的概念，它有三个部分：
- en: The name of the ingredient
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成分的名称
- en: How much of the ingredient is needed
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成分所需的数量
- en: The units in which the ingredient is measured
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成分的计量单位
- en: If we want to work with ingredients, we need to be able to handle units properly.
    For example, adding 1.5 kilograms to 750 grams involves more than adding the numbers
    1.5 and 750—you have to know how to *convert* these values from one unit to another.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要处理成分，我们需要能够正确处理单位。例如，将1.5千克加上750克不仅仅是加上数字1.5和750——您必须知道如何将这些值从一个单位转换为另一个单位。
- en: In the case of recipes, there are a number of rather unusual conversions that
    you need to support. For example, did you know that three teaspoons of sugar equals
    one tablespoon of sugar? To handle these types of conversions, let's write a unit
    conversion library.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在食谱的情况下，有一些相当不寻常的转换需要我们支持。例如，你知道三茶匙的糖等于一汤匙的糖吗？为了处理这些类型的转换，让我们编写一个单位转换库。
- en: Our unit converter will have to be aware of all the standard units used in cooking.
    These include cups, tablespoons, teaspoons, grams, ounces, pounds, and so on.
    Our unit converter will need some way of representing a quantity, such as 1.5
    kilograms, and of converting quantities from one unit to another.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的单位转换器将需要了解烹饪中使用的所有标准单位。这些包括杯、汤匙、茶匙、克、盎司、磅等。我们的单位转换器将需要一种表示数量的方式，比如1.5千克，并且能够将数量从一种单位转换为另一种单位。
- en: As well as representing and converting quantities, we would like our library
    to be able to display quantities, automatically using the singular or plural version
    of the unit name as appropriate, for example, **6 cups**, **1 gallon**, **150
    grams**, and so on.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 除了表示和转换数量，我们希望我们的图书馆能够显示数量，自动使用适当的单位名称的单数或复数形式，例如，**6杯**，**1加仑**，**150克**等。
- en: Since we're displaying quantities, it would also be helpful if our library could
    parse quantities. This way, the user could enter a value such as `3 tbsp` and
    our library would know that the user entered a quantity of three tablespoons.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在显示数量，如果我们的图书馆能够解析数量，将会很有帮助。这样，用户就可以输入像`3汤匙`这样的值，我们的图书馆就会知道用户输入了三汤匙的数量。
- en: The more we think about this library, the more it seems like a useful tool in
    its own right. We thought of this in connection with our recipe-handling program,
    but it seems that this could be an ideal candidate for a reusable module or package.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们越想这个图书馆，它似乎越像一个有用的工具。我们是在考虑我们的处理食谱程序时想到的这个，但似乎这可能是一个理想的可重用模块或包的候选者。
- en: Following the guidelines we looked at earlier, let's consider how we can generalize
    our library as much as possible to make it more useful in other programs and to
    other programmers.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们之前看过的指南，让我们考虑如何尽可能地概括我们的图书馆，使其在其他程序和其他程序员中更有用。
- en: Rather than just thinking about the sorts of quantities you might find in a
    recipe, let's change the scope of our library to handle *any* type of quantity.
    It could handle weights, lengths, areas, volumes, and possibly even units of time,
    force, speed, and the like.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 与其只考虑在食谱中可能找到的各种数量，不如改变我们的图书馆的范围，以处理*任何*类型的数量。它可以处理重量、长度、面积、体积，甚至可能处理时间、力量、速度等单位。
- en: Thinking of it like this, our library isn't so much a unit converter as a library
    that works with **quantities**. A quantity is a number and its associated units,
    for example, 150 millimeters, 1.5 ounces, or 5 acres. Our library, which we will
    call Quantities, will be a tool for parsing, displaying, and creating quantities,
    as well as converting quantities from one unit to another. As you can see, our
    initial concept for the library is now just one of the things that the library
    will be able to do.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这样想，我们的图书馆不仅仅是一个单位转换器，而是一个处理**数量**的图书馆。数量是一个数字及其相关的单位，例如，150毫米，1.5盎司，或5英亩。我们将称之为Quantities的图书馆将是一个用于解析、显示和创建数量的工具，以及将数量从一种单位转换为另一种单位。正如你所看到的，我们对图书馆的最初概念现在只是图书馆将能够做的事情之一。
- en: 'Let''s now design our Quantities library in more detail. We''d like the user
    of our library to be able to create a new quantity very easily. For example:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们更详细地设计我们的Quantities图书馆。我们希望我们的图书馆的用户能够很容易地创建一个新的数量。例如：
- en: '[PRE16]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We also want to be able to parse a string into a quantity value, like this:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望能够将字符串解析为数量值，就像这样：
- en: '[PRE17]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We then want to be able to display a quantity in the following manner:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们希望能够以以下方式显示数量：
- en: '[PRE18]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We also want to be able to tell what kind of value a quantity is representing,
    for example:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望能够知道一个数量代表的是什么类型的值，例如：
- en: '[PRE19]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This will let us tell whether a quantity represents a weight, a length, or a
    distance, among others.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这将让我们知道一个数量代表重量、长度或距离等。
- en: 'We can also retrieve the value and units for a quantity:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以获取数量的值和单位：
- en: '[PRE20]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We also need the ability to convert a quantity into a different unit. For example:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要能够将一个数量转换为不同的单位。例如：
- en: '[PRE21]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Finally, we would like to be able to get a list of all the kinds of units that
    our library supports and the individual units of each kind:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们希望能够获得我们的图书馆支持的所有单位种类的列表以及每种单位的个体单位：
- en: '[PRE22]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'There is one final feature that our Quantities library will need to support:
    the ability to *localize* units and quantities. Unfortunately, the conversion
    values for certain quantities will vary depending on whether you are in the United
    States or elsewhere. For example, in the U.S. a teaspoon has a volume of approximately
    4.93 cubic centimeters, while in the rest of the world a teaspoon is considered
    to have a volume of 5 cubic centimeters. There are also naming conventions to
    deal with: in the U.S. the base unit of length in the metric system is referred
    to as a *meter*, while in the rest of the world the same unit is spelled *metre*.
    Our unit will have to handle both the different conversion values and the different
    naming conventions.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的Quantities图书馆还需要支持一个最终功能：*本地化*单位和数量的能力。不幸的是，某些数量的转换值会根据你是在美国还是其他地方而有所不同。例如，在美国，一茶匙的体积约为4.93立方厘米，而在世界其他地方，一茶匙被认为有5立方厘米的体积。还有命名约定要处理：在美国，米制系统的基本长度单位被称为*米*，而在世界其他地方，同样的单位被拼写为*metre*。我们的单位将不得不处理不同的转换值和不同的命名约定。
- en: 'To do this, we will need to support the notion of a **locale**. When our library
    is initialized, the caller will specify the locale under which our module should
    operate:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们需要支持**区域设置**的概念。当我们的图书馆被初始化时，调用者将指定我们的模块应该在哪个区域下运行：
- en: '[PRE23]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This will affect the conversion values and spelling used by the library:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: 'Given the complexity of our Quantities library, it doesn''t make sense to try
    and squeeze all this into a single module. Instead, we''ll break our library up
    into three separate modules: a `units` module which defines all the different
    type of units that we support, an `interface` module which implements the various
    public functions for our package, and a `quantity` module which encapsulates the
    concept of a quantity being a value and its associated unit.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: These three modules will be combined into a single Python package, which we
    will call `quantities`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that we deliberately used the term *library* to refer to the system as
    we were designing it; this ensured that we didn't pre-empt our design by thinking
    of it as a single module or as a package. Only now is it clear that we are going
    to write a Python package. Often, something that you think of as a module will
    end up growing into a package. Occasionally the opposite happens. It's important
    to be flexible about this.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a good design for our Quantities library, what it will do,
    and how we'd like to structure it, let's start writing some code.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a reusable package
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tip
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This section includes a lot of source code. Remember that you don't have to
    type it all in by hand; a complete copy of the `quantities` package is provided
    as part of the sample code that can be downloaded for this chapter.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: Start by creating the directory named `quantities` to hold our new package.
    Inside this directory, create a new file named `quantity.py`. This module will
    hold our implementation of a quantity—that is, a value together with its associated
    units.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: While you don't need to understand object-oriented programming techniques to
    work through this book, this is the one place where we need to use object-oriented
    programming. This is because we want the user to be able to print a quantity directly,
    and the only way to do that in Python is to use objects. Don't worry, though—this
    code is very straightforward, and we'll take it one step at a time.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `quantity.py` module, enter the following Python code:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: What we are doing here is defining a new type of object called a `Quantity`.
    The second line looks very much like a function definition, only we are defining
    a special type of function, called a **method**, and giving it a special name,
    `__init__`. This method is used to initialize a new object when it is created.
    The `self` parameter refers to the object that is being created; as you can see,
    our `__init__` function takes two additional parameters named `value` and `units`,
    and stores these two values into `self.value` and `self.units`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: 'With our new `Quantity` object defined, we can create new objects and retrieve
    their values. For example:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The first line creates a new object using the `Quantity` class, passing `1`
    for the `value` parameter and `"inch"` for the `units` parameter. The `__init__`
    method then stores these within the `value` and `units` attributes within the
    object. As you can see in the second line, it's easy to retrieve these attributes
    when we need them.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve almost completed our implementation of the `quantity.py` module. There''s
    just one more thing to do: in order to be able to print a `Quantity` value, we
    need to add another method to our `Quantity` class; this one will be called `__str__`
    and will be used whenever we need to print a quantity. To do this, add the following
    Python code to the end of your `quantity.py` module:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Make sure that the `def` statement is indented to the same level as the `def
    __init__()` statement earlier so that it''s part of the class we''re creating.
    This will allow us to do things such as the following:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The Python `print()` function calls the specially named `__str__` method to
    get the text to display for a quantity. Our `__str__` method returns the value
    and the units, separated by a single space, which makes for a nicely formatted
    summary of the quantity.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: This completes our `quantity.py` module. As you can see, working with objects
    wasn't as difficult as it might seem.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: Our next task is to collect all the information we need to store about the various
    units that our package will support. Because there is a lot of information here,
    we'll put this into a module by itself, which we will call `units.py`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `units.py` module within your `quantities` package, and start by
    entering the following into this file:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `UNITS` dictionary will map the kind of unit to a list of the units defined
    for that kind. For example, all units of length would go into the `UNITS['length']`
    list.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: 'For each unit, we will store the information about that unit in the form of
    a dictionary with the following entries:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '| Dictionary entry | Description |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
- en: '| `name` | The name for this unit, for example, `inch`. |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
- en: '| `abbreviation` | The official abbreviation for this unit, for example, `in`.
    |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
- en: '| `plural` | The plural name for this unit. This is the name to use when there
    is more than one of this unit, for example, `inches`. |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
- en: '| `num_units` | The number of units needed to convert between these units and
    others of the same type. For example, if the `centimeter` unit had a `num_units`
    value of `1`, then the `inch` unit would have a `num_units` value of `2.54` because
    1 inch equals 2.54 centimeters. |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
- en: 'As we discussed in the previous section, we need to be able to localize our
    various units and quantities. To allow for this, all of these dictionary entries
    can either have a single value or a dictionary mapping each locale to a value.
    For example, the `liter` unit might be defined using the following Python dictionary:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This allows us to have a different spelling for the word `liter` in different
    locales. Other units might have different numbers of units or different abbreviations,
    depending on the locale selected.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we know how we''re going to store our various unit definitions, let''s
    implement the next part of our `units.py` module. To avoid having to repetitively
    type lots of unit dictionaries, we''re going to create a few helper functions.
    Add the following to the end of your module:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This function will return a dictionary mapping the `us` and `international`
    locales to the given values, making it easier to create a locale-specific dictionary
    entry.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, add the following function to your module:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This complex-looking function creates the dictionary entry for a single unit.
    It uses the special `*args` parameter form to accept a variable number of parameters;
    the caller can provide either an abbreviation, a name, and the number of units,
    or else the abbreviation, the name, the plural name, and the number of units.
    If the plural name is not provided, it is calculated automatically by adding `s`
    to the end of the unit's singular name.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: Note that the logic here allows for the possibility of the name being a dictionary
    of locale-specific names; if the name is localized, then the plural name will
    also be calculated on a locale-by-locale basis.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we define a simple helper function that makes it easier to define
    a list of units all at once:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'With all these helper functions in place, it will be quite easy for us to add
    our various units to the `UNITS` dictionary. Add the following code to the end
    of your module; this defines the various weight-based units that our package will
    support:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Next, add some length-based units:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As you can see, we've use the `by_locale()` function to create different versions
    of the unit name and plural name based on the user's current locale. We also supply
    the plural name for the `inch` and `foot` units as these can't be calculated by
    adding an `s` to the singular version of the name.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now add some area-based units:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Finally, we''ll define some volume-based units:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: For the `"cup"` unit, we are localizing the number of units rather than the
    name. This is because in the US a cup is considered to be `236.588` mls, while
    elsewhere in the world a cup is measured as 250 mls.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These unit listings have been abbreviated to keep the code listing to a reasonable
    size. The version of the `quantities` package included in the sample code for
    this chapter has a more comprehensive list of units.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: 'This completes our unit definitions. To make it easy for our code to use these
    various units, we''re going to add two extra functions to the end of our `units.py`
    module. First off is a function to choose the appropriate localized version of
    a value from a unit''s dictionary:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: As you can see, we check to see if `value` is a dictionary; if so, we return
    the entry within that dictionary for the supplied `locale`. Otherwise, we return
    `value` directly. We'll use this function whenever we need to retrieve a name,
    plural name, abbreviation, or value from a unit's dictionary.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: 'The second function we are going to need is a function to search through the
    various units stored in the `UNITS` global variable. We want to be able to find
    a unit based on its singular or plural name, or its abbreviation, allowing for
    the spelling specific to the current locale. To do this, add the following code
    to the end of the `units.py` module:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Notice that we use `s.lower()` to convert the string to lowercase before checking
    it. This ensures that we find the `inch` unit, for example, even if the user spelled
    it as `Inch` or `INCH`. Upon completion, our `find_units()` function returns the
    kind of unit and the unit dictionary for the found unit, or `(None, None)` if
    the unit can't be found.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: This completes the `units.py` module. Let's now create the `interface.py` module,
    which will hold the public interface to our `quantities` package.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We could put all this code directly in the package initialization file, `__init__.py`,
    but this can be a bit confusing as many programmers don't expect to find code
    within an `__init__.py` file. Instead, we'll define all our public functions in
    the `interface.py` module, and import the contents of this module into `__init__.py`.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `interface.py` module, placing it into the `quantities` package
    directory alongside `units.py` and `quantities.py`. Then, add the following `import`
    statements to the top of this module:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: As you can see, we are using a relative import statement to load the `UNITS`
    global variable and the `localize()` and `find_unit()` functions from our `units.py`
    module. We then use another relative import to load the `Quantity` class which
    we defined in our `quantity.py` module. This makes these important functions,
    classes, and variables available for our code to use.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: 'We now need to implement the various functions we identified in the previous
    section of this chapter. We''ll start with `init()`, which initializes the entire
    quantities package. Add the following to the end of your `interface.py` module:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The caller will provide the name of a locale (which should be a string containing
    either `us` or `international` as these are the two locales we are supporting),
    which we store into a private global variable named `_locale`.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: 'The next function we want to implement is `new()`. This lets the user define
    a new quantity by supplying a value and the name of the desired units. We''ll
    use the `find_unit()` function to make sure the unit exists, and then create and
    return a new `Quantity` object with the supplied value and units:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Because the name of the unit can vary depending on the locale, we use the `_locale`
    private global variable to help find the unit with the supplied name, plural name,
    or abbreviation. Once a unit has been found, we use the official name of that
    unit to create a new `Quantity` object, which we then return to the caller.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: 'As well as creating a new quantity by supplying the value and units, we also
    need to implement a `parse()` function that converts a string into a `Quantity`
    object. Let''s do this now:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We split the string at the first space, converting the first part into a floating-point
    number and searching for a unit with a name or abbreviation equal to the second
    part of the string.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: 'Next up, we need to write some functions to return information about a quantity.
    Let''s just go ahead and implement these functions by adding the following code
    to the end of your `interface.py` module:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: These functions allow the user of our package to identify the kind of units
    associated with a given quantity (for example, length, weight, or volume), and
    to retrieve a quantity's value and units.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that the user could also retrieve these last two values by accessing the
    attributes within the `Quantity` object directly, for example, `print(q.value)`.
    We can't stop the user from doing this but, because we're not implementing this
    as an object-oriented package, we don't want to encourage it.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: 'We are almost there. Our next function will convert a quantity from one unit
    to another, returning a `ValueError` if the conversion is impossible. Here is
    the necessary code to do this:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The final two functions we need to implement return a list of the different
    kinds of unit we support and a list of the individual units of a given kind. Here
    are the final two functions for our `interface.py` module:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now that we''ve finished implementing the `interface.py` module, there is only
    one last thing to do: create the package initialization file for our `quantities`
    package, `__init__.py`, and enter the following into this file:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This makes all of the functions we defined in the `interface.py` module available
    to users of our package.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: Testing our reusable package
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we''ve written the code (or alternatively, downloaded it), let''s
    take a look at how this package works. In a terminal window, set the current directory
    to the folder containing your `quantities` package directory, and type `python`
    to start the Python interpreter. Then, type the following:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: If you haven't made any mistakes in typing in the source code, the interpreter
    should come back without any errors. If you have made any typos, you'll need to
    fix them before you can proceed.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we have to initialize our `quantities` package by supplying the locale
    we want to use:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: If you are in the United States, feel free to replace the value `international`
    with `us` so that you get localized spelling and units for your country.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a simple quantity, and then ask the Python interpreter to display
    it:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: As you can see, the international spelling for the word `kilometer` is automatically
    used.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try converting this unit into inches:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'There are other functions we haven''t tested yet, but already we can see that
    our `quantities` package solves a very general problem, conforms to the Python
    Style guide, and is easy to use. It isn''t quite an ideal reusable module, but
    it''s close. Here are a few things we could do to improve it:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: Restructure our package to be more object-oriented. For example, instead of
    calling `quantities.convert(q, "inch")`, users could simply say `q.convert("inch")`.
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improve the implementation of the `__str__()` function so that the unit name
    is displayed as a plural if the value is greater than one. Also, change the code
    to avoid floating-point rounding issues, which can produce odd results when printing
    out certain quantity values.
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add functions (or methods) to add, subtract, multiply, and divide quantities.
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add docstrings to our package source code, and then use a tool such as **Sphinx**
    ([http://www.sphinx-doc.org](http://www.sphinx-doc.org)) to convert the docstrings
    into API documentation for our package.
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Upload the source code for the `quantities` package to **GitHub** ([https://github.com](https://github.com))
    to make it easier to obtain.
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a web site (possibly as a simple README file within the GitHub repository)
    so that people can find out more about this package.
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Submit the package to the PyPI so that people can find it.
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Feel free to extend the `quantities` package and submit it if you want; this
    is only an example for this book, but it certainly has potential as a general-purpose
    (and popular) reusable Python package.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at the concept of a reusable module or package. We
    saw how reusable packages and modules can be used to share code with other people.
    We learned that a reusable module or package needs to function as a standalone
    unit, should ideally use relative imports, and should note any external dependencies
    it may have. Ideally, a reusable package or module will also solve a general problem
    rather than a specific one, follow standard Python coding conventions, and have
    good documentation. We then looked at some examples of good reusable modules,
    before writing one of our own.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at some of the more advanced aspects of working
    with modules and packages in Python.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
