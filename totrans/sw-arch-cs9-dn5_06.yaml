- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Azure Service Fabric
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is dedicated to describing Azure Service Fabric, which is a Microsoft
    opinionated microservices orchestrator. It is available on Azure, but Service
    Fabric software is also available for download, meaning users can use it to define
    their own on-premises microservices clusters.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: While Service Fabric is not as diffused as Kubernetes, it has a better learning
    curve and enables you to experiment with the fundamental concepts of microservices,
    and to build sophisticated solutions in a very short space of time. Moreover,
    it offers an integrated deployment environment, which includes everything you
    need to implement a complete application. More specifically, it also offers its
    integrated communication protocol, and an easy and reliable way to store state
    information.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio support for Azure Service Fabric applications
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to define and configure an Azure Service Fabric cluster
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to code reliable services, and their communication in practice, through
    the "logging microservices" use case
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have learned how to implement a complete
    solution based on Azure Service Fabric.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you will require the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio 2019 free Community Edition or better, with all the database tools
    and the Azure development workload installed.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A free Azure account. The *Creating an Azure account* section in *Chapter 1*,
    *Understanding the Importance of Software Architecture*, explains how to create
    one.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A local emulator for Azure Service Fabric to debug your microservices in Visual
    Studio. It is free and can be downloaded from [https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-get-started#install-the-sdk-and-tools](https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-get-started#install-the-sdk-and).
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To avoid installation issues, ensure that your version of Windows is up to
    date. Moreover, the emulator uses PowerShell high-privilege-level commands that,
    by default, are blocked by PowerShell. To enable them, you need to execute the
    following command in the Visual Studio Package Manager Console or in any PowerShell
    console. Visual Studio or an external PowerShell console must be started as an
    *administrator* for the following command to be successful:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Visual Studio support for Azure Service Fabric
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Visual Studio has a specific project template for microservice applications,
    based on the Service Fabric platform, where you can define various microservices,
    configure them, and deploy them to Azure Service Fabric, which is a microservice
    orchestrator. Azure Service Fabric will be described in more detail in the next
    section.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will describe the various types of microservice you can
    define within a Service Fabric Application. A complete code example will be provided
    in the last section of this chapter. If you want to debug microservices on your
    development machine, you need to install the Service Fabric emulator listed in
    this chapter's technical requirements.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: 'Service Fabric Applications can be found by selecting **Cloud** in the *Visual
    Studio project type drop-down filter*:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16756_06_01.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.1: Selecting a Service Fabric Application'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have selected the project and chosen the project and solution names,
    you can choose from a variety of services:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16756_06_02.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.2: Choice of services'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: All projects under .NET Core use a microservice model that is specific to Azure
    Service Fabric. The Guest Executable adds a wrapper around an existing Windows
    application to turn it into a microservice that can run in Azure Service Fabric.
    The Container application enables the addition of any Docker image in the Service
    Fabric application. All the other choices scaffold a template that allows you
    to code a microservice with a Service Fabric-specific pattern.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: 'If you select **Stateless Service** and fill in all the request information,
    Visual Studio creates two projects: an application project that contains configuration
    information for the overall application, and a project for the specific service
    you have chosen that contains both the service code and a service-specific configuration.
    If you want to add more microservices to your application, right-click on the
    application project and select **Add** | **New Service Fabric Service**.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: If you right-click on the solution and select **Add** | **New project**, a new
    Service Fabric application will be created instead of a new service being added
    to the already existing application.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: 'If you select **Guest Executable**, you need to provide the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: The service name.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A folder containing the main executable file, along with all the files it needs
    in order to work properly. You need this if you want to create a copy of this
    folder in your project or simply to link to the existing folder.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whether to add a link to this folder, or to copy the selected folder into the
    Service Fabric project.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The main executable file.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arguments to pass on the command line to that executable.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which folder to use as a working folder on Azure. You want to use the folder
    containing the main executable (`CodeBase`), the folder where Azure Service Fabric
    will package the entire microservice (`CodePackage`), or a new subfolder named
    `Work`.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you select **Container**, you need to provide the following:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: The service name.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The complete name of a Docker image in your private Azure Container Registry.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The username that will be used to connect to Azure Container Registry. The password
    will be specified manually in the same `RepositoryCredentials` XML element of
    the application configuration file that was automatically created for the username.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The port where you can access your service (host port) and the port inside the
    container that the host port must be mapped to (container port). The container
    port must be the same port that was exposed in the Dockerfile and used to define
    the Docker image.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Afterward, you may need to add further manual configuration to ensure that your
    Docker application works properly. The *Further reading* section contains links
    to the official documentation where you can find more details.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: There are five types of .NET Core native Service Fabric services. The Actor
    service pattern is an opinionated pattern that was conceived several years ago
    by Carl Hewitt. We will not discuss it here, but the *Further reading* section
    contains some links that provide more information on this.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: The remaining four patterns refer to the usage (or not) of ASP.NET (Core) as
    the main interaction protocol and to the fact that the service has or hasn't got
    an internal state. In fact, Service Fabric allows microservices to use distributed
    queues and dictionaries that are globally accessible to all instances of the microservice
    that declares them, independent of the hardware node where they are running (they
    are serialized and distributed to all available instances when they're needed).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: 'Stateful and stateless templates differ mainly in terms of their configuration.
    All native services are classes that specify just two methods. Stateful services
    specify:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'While stateless services specify:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `CreateServiceReplicaListeners` and `CreateServiceInstanceListeners` methods
    specify a list of listeners that are used by the microservice to receive messages
    and the code that handles those messages. Listeners may use any protocol, but
    they are required to specify an implementation of the relative socket.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '`RunAsync` contains the code for background threads that asynchronously run
    tasks that are triggered by received messages. Here, you can build a host that
    runs several hosted services.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: ASP.NET Core templates follow the same pattern; however, they use a unique ASP.NET
    Core-based listener and no `RunAsync` implementation, since background tasks can
    be launched from inside ASP.NET Core, whose listener defines a complete `WebHost`.
    However, you may add further listeners to the array of listeners returned by the
    `CreateServiceReplicaListeners` implementation created by Visual Studio, and also
    a custom `RunAsync` override.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core模板遵循相同的模式；但是，它们使用基于ASP.NET Core的唯一侦听器和没有`RunAsync`实现，因为可以从ASP.NET
    Core内部启动后台任务，其侦听器定义了一个完整的`WebHost`。但是，您可以将更多侦听器添加到由Visual Studio创建的`CreateServiceReplicaListeners`实现返回的侦听器数组中，还可以添加自定义的`RunAsync`覆盖。
- en: It is worth pointing out that as `RunAsync` is optional, and since the ASP.NET
    Core template doesn't implement it, `CreateServiceReplicaListeners` and `CreateServiceInstanceListeners`
    are also optional, and, for instance, a background worker operating on a timer
    doesn't need to implement any of them.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 值得指出的是，由于`RunAsync`是可选的，并且由于ASP.NET Core模板没有实现它，因此`CreateServiceReplicaListeners`和`CreateServiceInstanceListeners`也是可选的，例如，基于计时器的后台工作程序不需要实现它们中的任何一个。
- en: More details on Service Fabric's native services pattern will be provided in
    the following section, while a complete code example will be provided in the *Use
    case – Logging microservices* section of this chapter, which is dedicated to this
    book's use case.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Service Fabric的本机服务模式的更多详细信息将在下一节中提供，而本章的*用例-日志记录微服务*部分将提供一个完整的代码示例，专门针对本书的用例。
- en: Defining and configuring your Azure Service Fabric cluster
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义和配置Azure Service Fabric集群
- en: Azure Service Fabric is the main Microsoft orchestrator that can host Docker
    containers, native .NET applications, and a distributed computing model called
    **reliable services**. We have already explained how we can create applications
    that contain these three types of services in the *Visual Studio support for Azure
    Service Fabric* section. In this section, we will explain how to create an Azure
    Service Fabric cluster in the Azure portal and provide some more details on reliable
    services. More practical details regarding *reliable services* will be provided
    in the example described in the *Use case – Logging microservices* section.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Azure Service Fabric是主要的微软编排器，可以托管Docker容器、本地.NET应用程序和一种名为**可靠服务**的分布式计算模型。我们已经在*Visual
    Studio支持Azure Service Fabric*部分中解释了如何创建包含这三种类型服务的应用程序。在本节中，我们将解释如何在Azure门户中创建Azure
    Service Fabric集群，并提供一些关于可靠服务的详细信息。有关*可靠服务*的更多实际细节将在*用例-日志记录微服务*部分中提供。
- en: You can enter the Service Fabric section of Azure by typing `Service Fabric`
    into the Azure search bar and selecting **Service Fabric Cluster**.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在Azure搜索栏中输入`Service Fabric`并选择**Service Fabric Cluster**来进入Azure的Service
    Fabric部分。
- en: A summary page of all of your Service Fabric clusters appears which, in your
    case, should be empty. When you click the **Add** button to create your first
    cluster, a multi-step wizard is shown. The following subsections describe the
    available steps.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 显示了所有Service Fabric集群的摘要页面，对于您的情况，应该是空的。当您点击**添加**按钮创建第一个集群时，将显示一个多步骤向导。以下小节描述了可用的步骤。
- en: Step 1 – Basic information
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第1步-基本信息
- en: 'The following screenshot shows the creation of Azure Service Fabric:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了Azure Service Fabric的创建过程：
- en: '![](img/B16756_06_03.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16756_06_03.png)'
- en: 'Figure 6.3: Azure Service Fabric creation'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3：Azure Service Fabric创建
- en: Here, you can choose the operating system, resource group, subscription, location,
    and username and password that you want to use to connect the remote desktop to
    all the cluster nodes.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以选择操作系统、资源组、订阅、位置以及要用于连接远程桌面到所有集群节点的用户名和密码。
- en: You are required to choose a cluster name, which will be used to compose the
    cluster URI as `<cluster name>.<location>.cloudapp.azure.com`, where `location`
    is a name associated with the data center location you have chosen. Let's select
    Windows, since Service Fabric was primarily conceived for Windows. A better choice
    for Linux machines is Kubernetes, which will be described in the next chapter.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要选择一个集群名称，该名称将用于组成集群URI，格式为`<集群名称>.<位置>.cloudapp.azure.com`，其中`位置`是您选择的数据中心位置的名称。由于Service
    Fabric主要是为Windows设计的，所以选择Windows是一个更好的选择。对于Linux机器来说，更好的选择是Kubernetes，这将在下一章中介绍。
- en: Then you are required to select your node type, that is, the kind of virtual
    machine you would like to use for your primary nodes, and the initial scale set,
    that is, the maximum number of virtual machines to use. Please choose a cheap
    node type and no more than three nodes, otherwise you might quickly waste all
    your free Azure credit.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您需要选择节点类型，即您想要为主节点使用的虚拟机类型，以及初始规模集，即要使用的虚拟机的最大数量。请选择一个廉价的节点类型，最多不超过三个节点，否则您可能很快就会耗尽所有的免费Azure信用额。
- en: More details on node configurations will be given in the next subsection.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 有关节点配置的更多详细信息将在下一小节中给出。
- en: Finally, you have the option to select a certificate to secure your node-to-node
    communications. Let's click the **Select a certificate** link, and in the window
    that opens, select the automatic creation of a new key vault and of a new certificate.
    More information on security will be provided in the *Step 3 – Security configuration*
    section.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可以选择一个证书来保护节点之间的通信。让我们点击**选择证书**链接，在打开的窗口中选择自动创建新密钥保管库和新证书。有关安全性的更多信息将在*第3步-安全配置*部分中提供。
- en: Step 2 – Cluster configuration
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第2步-集群配置
- en: 'In the second step, you can fine-tune the cluster node type and number:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二步中，您可以对集群节点类型和数量进行微调：
- en: '![](img/B16756_06_04.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16756_06_04.png)'
- en: 'Figure 6.4: Cluster configuration'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4：集群配置
- en: More specifically, in the previous step, we selected the cluster primary node.
    Here, we can choose whether to add various kinds of secondary nodes with their
    scale capacities. Once you have created different node types, you can configure
    services to run only on specific node types whose capabilities are adequate to
    their needs.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s click the **Add** button to add a new node type:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16756_06_05.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.5: Adding a new node type'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: Nodes of a different node type can be scaled independently, and the **primary
    node** type is where Azure Service Fabric runtime services will be hosted. For
    each node type, you can specify the type of machine (**Durability tier**), machine
    dimensions (CPU and RAM), and the initial number of nodes.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: You can also specify all the ports that will be visible from outside the cluster
    (**Custom endpoints**).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: The services that are hosted on the different nodes of a cluster can communicate
    through any port since they are part of the same local network. Therefore, **Custom
    endpoints** must declare the ports that need to accept traffic from outside the
    cluster. The port that are exposed in **Custom endpoints** are the cluster's public
    interface, which can be reached through the cluster URI, that is, `<cluster name>.<location>.cloudapp.azure.com`.
    Their traffic is automatically redirected to all the microservices that have had
    the same ports opened by the cluster load balancer.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: To understand the **Enable reverse proxy** option, we must explain how communications
    are sent to several instances of services whose physical addresses change during
    their lifetimes. From within the cluster, services are identified with a URI such
    as `fabric://<application name>/<service name>`. That is, this name allows us
    to access one of the several load-balanced instances of `<service name>`. However,
    these URIs can't be used directly by communication protocols. Instead, they are
    used to get the physical URI of the required resource, along with all its available
    ports and protocols from the Service Fabric naming service.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: Later, we will learn how to perform this operation with *reliable services*.
    However, this model is not adequate for Dockerized services that weren't conceived
    to run specifically on Azure Service Fabric, since they are not aware of Service
    Fabric-specific naming services and APIs.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, Service Fabric provides two more options that we can use to standardize
    URLs instead of interacting directly with its naming service:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '**DNS**: Each service can specify its `hostname` (also known as its **DNS name**).
    The DNS service takes care of translating it into the actual service URL. For
    example, if a service specifies an `order.processing` DNS name and it has an HTTP
    endpoint on port `80` and a `/purchase` path, we can reach this endpoint with
    `http://order.processing:80/purchase`. By default, the DNS service is active,
    but you can deactivate it either by showing the advanced settings selection in
    the secondary node screen by clicking **Configure advanced settings**, or by going
    to the **Advanced** tab.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reverse proxy**: Service Fabric''s reverse proxy intercepts all the calls
    that have been directed to the cluster address and uses the name service to send
    them to the right application and service within that application. Addresses that
    are resolved by the reverse proxy service have the following structure: `<cluster
    name>.<location>.cloudapp.azure.com: <port>//<app name>/<service name>/<endpoint
    path>?PartitionKey=<value>& PartitionKind=value`. Here, partition keys are used
    to optimize stateful reliable services and will be explained at the end of this
    subsection. This means that stateless services lack the query string part of the
    previous address. Thus, a typical address that''s solved by reverse proxy may
    be something similar to `myCluster.eastus.cloudapp.azure.com: 80//myapp/myservice/<endpoint
    path>?PartitionKey=A & PartitionKind=Named`. If the preceding endpoint is called
    from a service hosted on the same cluster, we can specify `localhost` instead
    of the complete cluster name (that is, from the same cluster, not from the same
    node): `localhost: 80//myapp/myservice/<endpoint path>?PartitionKey=A & PartitionKind=Named`.
    By default, reverse proxy is not enabled.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**反向代理**：Service Fabric的反向代理拦截所有被定向到集群地址的调用，并使用名称服务将它们发送到正确的应用程序和该应用程序中的服务。由反向代理服务解析的地址具有以下结构：`<cluster
    name>.<location>.cloudapp.azure.com: <port>//<app name>/<service name>/<endpoint
    path>?PartitionKey=<value>& PartitionKind=value`。在这里，分区键用于优化有状态的可靠服务，并将在本小节末尾进行解释。这意味着无状态服务缺少前一个地址的查询字符串部分。因此，由反向代理解析的典型地址可能类似于`myCluster.eastus.cloudapp.azure.com:
    80//myapp/myservice/<endpoint path>?PartitionKey=A & PartitionKind=Named`。如果从同一集群上托管的服务调用前面的端点，我们可以指定`localhost`而不是完整的集群名称（即从同一集群，而不是从同一节点）：`localhost:
    80//myapp/myservice/<endpoint path>?PartitionKey=A & PartitionKind=Named`。默认情况下，反向代理未启用。'
- en: Since we are going to use Service Fabric reliable services with Service Fabric
    built-in communication facilities, and since these built-in communication facilities
    don't need either reverse proxy or DNS, please avoid changing these settings.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将使用Service Fabric可靠服务与Service Fabric内置通信设施，并且由于这些内置通信设施不需要反向代理或DNS，请避免更改这些设置。
- en: Moreover, if you are creating the Service Fabric cluster with the sole purpose
    of experimenting with the simple example at the end of the chapter, please stick
    with just the primary nodes and avoid wasting your free Azure credit by creating
    secondary nodes as well.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果您只是为了在本章末尾的简单示例中进行实验而创建Service Fabric集群，请仅使用主节点，并避免通过创建辅助节点来浪费您的免费Azure信用。
- en: Step 3 – Security configuration
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第3步-安全配置
- en: 'Once the second step is complete, we come to a security page:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 完成第二步后，我们来到一个安全页面：
- en: '![](img/B16756_06_06.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16756_06_06.png)'
- en: 'Figure 6.6: Security page'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.6：安全页面
- en: We already defined the main certificate in the first step. Here, you have the
    option to select a secondary certificate to be used when the primary certificate
    is near to its expiration. You can add also a certificate that will be used to
    enable HTTPS communication on reverse proxies. Since, in our example, we will
    not use Dockerized services (so we will not require reverse proxies), we don't
    need this option.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一步中，我们已经定义了主要的证书。在这里，您可以选择一个次要的证书，在主要证书接近到期时使用。您还可以添加一个证书，用于在反向代理上启用HTTPS通信。由于在我们的示例中，我们不使用Docker化服务（因此不需要反向代理），所以我们不需要这个选项。
- en: 'At this point, we can click the review and create button to create the cluster.
    Submitting your approval will create the cluster. Pay attention to this: a cluster
    may spend your free Azure credit in a short time, so just keep your cluster on
    when you are testing. Afterward, you should delete it.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们可以点击“审查和创建”按钮来创建集群。提交您的批准将创建集群。请注意：一个集群可能会在短时间内消耗您的免费Azure信用，所以在测试时请保持您的集群开启。之后，您应该删除它。
- en: 'We need to download our primary certificate to our development machine, since
    we need it to deploy our application. Once the certificate has been downloaded,
    it is enough to double-click on it to install it on our machine. Before deploying
    the application, you are required to insert the following information into the
    **Cloud Publish Profile** of your Visual Studio Service Fabric applications (see
    this chapter''s *Use case – Logging microservices* section for more details):'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将主要证书下载到开发机器上，因为我们需要它来部署我们的应用程序。一旦证书下载完成，只需双击它即可将其安装在我们的机器上。在部署应用程序之前，您需要将以下信息插入到Visual
    Studio Service Fabric应用程序的**Cloud Publish Profile**中（有关更多详细信息，请参见本章的*用例-日志记录微服务*部分）：
- en: '[PRE3]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Since both the client (Visual Studio) and the server use the same certificate
    for authentication, the server and client thumbprint are the same. The certificate
    thumbprint can be copied from your Azure Key Vault. It is worth mentioning that
    you can also add client-specific certificates to the main server certificate by
    selecting the corresponding option in *step 3*.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 由于客户端（Visual Studio）和服务器使用相同的证书进行身份验证，因此服务器和客户端的指纹是相同的。证书指纹可以从Azure密钥保管库中复制。值得一提的是，您还可以通过在*第3步*中选择相应的选项来将特定于客户端的证书添加到主服务器证书中。
- en: 'As we mentioned in the *Visual Studio support for Azure Service Fabric* subsection,
    Azure Service Fabric supports two kinds of *reliable service*: stateless and stateful.
    Stateless services either don''t store permanent data or they store it in external
    supports such as the Redis cache or databases (see *Chapter 9*, *How to Choose
    Your Data Storage in the Cloud*, for the main storage options offered by Azure).'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在*Visual Studio对Azure Service Fabric的支持*小节中提到的，Azure Service Fabric支持两种类型的*可靠服务*：无状态和有状态。无状态服务要么不存储永久数据，要么将其存储在外部支持中，例如Redis缓存或数据库（有关Azure提供的主要存储选项，请参见*第9章*，*如何选择云中的数据存储*）。
- en: Stateful services, on the other hand, use Service Fabric-specific distributed
    dictionaries and queues. Each distributed data structure is accessible from all
    the *identical* replicas of a service, but only one replica, called the primary
    replica, is allowed to write on them to avoid synchronized access to those distributed
    resources, which may cause bottlenecks.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，有状态服务使用Service Fabric特定的分布式字典和队列。每个分布式数据结构可以从服务的所有*相同*副本中访问，但只允许一个副本，称为主副本，在其上进行写操作，以避免对这些分布式资源的同步访问，这可能会导致瓶颈。
- en: All the other replicas, known as secondary replicas, can only read from these
    distributed data structures.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 所有其他副本，即辅助副本，只能从这些分布式数据结构中读取。
- en: You can check if a replica is primary by looking at the context object your
    code receives from the Azure Service Fabric runtime, but usually, you don't need
    to do this. In fact, when you declare your service endpoints, you are required
    to declare those that are read-only. A read-only endpoint is supposed to receive
    requests so that it can read data from the shared data structures. Therefore,
    since only read-only endpoints are activated for secondary replicas, if you implement
    them correctly, write/update operations should automatically be prevented on stateful
    secondary replicas with no need to perform further checks.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过查看您的代码从Azure Service Fabric运行时接收到的上下文对象来检查副本是否为主副本，但通常情况下，您不需要这样做。实际上，当您声明服务端点时，您需要声明那些只读的端点。只读端点应该接收请求，以便它可以从共享数据结构中读取数据。因此，由于只有只读端点被激活用于辅助副本，如果您正确实现了它们，写/更新操作应该自动在有状态辅助副本上被阻止，无需进行进一步的检查。
- en: In stateful services, secondary replicas enable parallelism on read operations,
    so in order to get parallelism on write/update operations, stateful services are
    assigned different data partitions. More specifically, for each stateful service,
    Service Fabric creates a primary instance for each partition. Then, each partition
    may have several secondary replicas.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在有状态服务中，辅助副本可以在读操作上实现并行处理，因此为了在写/更新操作上实现并行处理，有状态服务被分配了不同的数据分区。具体来说，对于每个有状态服务，Service
    Fabric会为每个分区创建一个主实例。然后，每个分区可能有多个辅助副本。
- en: Distributed data structures are shared between the primary instance of each
    partition and its secondary replicas. The whole extent of data that can be stored
    in a stateful service is split among the chosen number of partitions, according
    to a partition key that is generated by a hashing algorithm on the data to be
    stored.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式数据结构在每个分区的主实例和其辅助副本之间共享。可以根据对要存储的数据进行哈希算法生成的分区键将有状态服务中可以存储的全部数据范围划分为所选的分区数。
- en: Typically, partition keys are integers that belong to a given interval that
    is split among all the available partitions. For instance, a partition key can
    be generated by calling a well-known hashing algorithm on one or more string fields
    to get integers that are then processed to get a unique integer (using, for instance,
    an exclusive OR operation on the integer bits). Then, this integer can be constrained
    to the integer interval that was chosen for the partition key by taking the remainder
    of an integer division (for instance, the remainder of a division for 1,000 will
    be an integer in the 0-999 interval). It is important to be sure that all services
    use exactly the same hashing algorithm, so the better solution is to provide a
    common hashing library to all of them.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，分区键是属于给定间隔的整数，该间隔在所有可用分区之间进行划分。例如，可以通过调用一个众所周知的哈希算法对一个或多个字符串字段进行哈希运算来生成分区键，以获得然后处理为唯一整数的整数（例如，对整数位进行异或运算）。然后，可以通过取整数除法的余数来限制该整数在选择的分区键的整数间隔中（例如，除以1,000的余数将是0-999间隔中的整数）。确保所有服务使用完全相同的哈希算法非常重要，因此更好的解决方案是为所有服务提供一个公共的哈希库。
- en: 'Let''s say we want four partitions, which will be selected with an integer
    key in the 0-999 interval. Here, Service Fabric will automatically create four
    primary instances of our stateful service and assign them the following four partition
    key subintervals: 0-249, 250-499, 500-749, and 750-999.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要四个分区，这些分区将在0-999的整数键中进行选择。在这里，Service Fabric将自动创建我们有状态服务的四个主实例，并将它们分配给以下四个分区键子区间：0-249，250-499，500-749和750-999。
- en: From within your code, you are required to compute the partition key of the
    data you send to a stateful service. Then, Service Fabric's runtime will select
    the right primary instance for you. The following section provides more practical
    details on this and how to use reliable services in practice.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，您需要计算发送到有状态服务的数据的分区键。然后，Service Fabric的运行时将为您选择正确的主实例。下面的部分将提供更多关于此的实际细节以及如何在实践中使用可靠服务。
- en: Use case – Logging microservices
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用例 - 日志微服务
- en: In this section, we will look at a microservice-based system that logs data
    about purchases relating to various destinations in our WWTravelClub use case.
    In particular, we will design microservices that take care of computing daily
    revenues per location. Here, we're assuming that these microservices receive data
    from other subsystems hosted in the same Azure Service Fabric application. More
    specifically, each purchase log message is composed of the location name, the
    overall package cost, and the date and time of the purchase.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看一个基于微服务的系统，该系统记录与我们的WWTravelClub用例中的各个目的地相关的购买数据。特别是，我们将设计微服务来计算每个位置的每日收入。在这里，我们假设这些微服务从同一Azure
    Service Fabric应用程序中托管的其他子系统接收数据。具体来说，每个购买日志消息由位置名称、总体套餐费用以及购买日期和时间组成。
- en: 'As a first step, let''s ensure that the Service Fabric emulator that we mentioned
    in the *Technical requirements* section of this chapter has been installed and
    is running on your development machine. Now, we need to switch it so that it runs
    **5 nodes**: right-click on the small Service Fabric cluster icon you have in
    your Windows notification area, and, in the context menu that opens, select **Switch
    Cluster Mode** -> **5 nodes**.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can follow the steps set out in the *Visual Studio support for Azure
    Service Fabric* section to create a Service Fabric project named `PurchaseLogging`.
    Select a .NET Core stateful reliable service and name it `LogStore`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: The solution that's created by Visual Studio is composed of a `PurchaseLogging`
    project, which represents the overall application, and a `LogStore` project, which
    will contain the implementation of the first microservice that's included in the
    `PurchaseLogging` application.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: 'Under the `PackageRoot` folder, the `LogStore` service and each reliable service
    contain the `ServiceManifest.xml` configuration file and a `Settings.xml` folder
    (under the `Config` subfolder). The `Settings.xml` folder contains some settings
    that will be read from the service code. The initial file contains predefined
    settings that are needed by the Service Fabric runtime. Let''s add a new `Settings`
    section, as shown in the following code:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We will use the value of `MessageMaxDelaySeconds` to configure the system component
    and ensure message idempotency. The setting value is empty because most of the
    settings are overridden when the services are deployed by the overall application
    settings contained in the `PurchaseLogging` project.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ServiceManifest.xml` file contains a number of configuration tags that
    are automatically handled by Visual Studio, as well as a list of endpoints. Two
    endpoints are preconfigured since they are used by the Service Fabric runtime.
    Here, we must add the configuration details of all the endpoints our microservice
    will listen to. Each endpoint definition has the following format:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If `Type` is `Internal`, the port will be opened just inside the cluster's local
    network; otherwise, the port will be available from outside the cluster as well.
    In the preceding case, we must declare that port in the configuration of the Azure
    Service Fabric cluster as well, otherwise the cluster load balancer/firewall will
    not forward messages to it.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: Public ports can be reached directly from the cluster URI (`<cluster name>.<location
    code>.cloudapp.azure.com`) since the load balancer that interfaces each cluster
    will forward the input traffic it receives to them.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we won't define endpoints since we are going to use the predefined
    remoting-based communication, but we will show you how to use them later on in
    this section.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: 'The `PurchaseLogging` project contains a reference to the `LogStore` project
    under the *services* Solution Explorer node and contains various folders with
    various XML configuration files. More specifically, we have the following folders:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '`ApplicationPackageRoot`, which contains the overall application manifest named
    `ApplicationManifest.xml`. This file contains some initial parameter definitions
    and then further configurations. Parameters have the following format:'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Once defined, parameters can replace any value in the remainder of the file.
    Parameter values are referenced by enclosing the parameter name between square
    brackets, as shown in the following code:'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Some parameters define the number of replicas and partitions for each service
    and are automatically created by Visual Studio. Let''s replace these initial values
    suggested by Visual Studio with those in the following code snippet:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We will use just two partitions to show you how partitions work, but you can
    increase this value to improve write/update parallelism. Each partition of the
    `LogStore` service doesn't need several replicas, since replicas improve performance
    on read operations and this service is not designed to offer read services. In
    similar situations, you may choose two to three replicas to make the system redundant
    and more robust to failures. However, we've left one since, as this is just an
    example, we are not concerned with failures.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding parameters are used to define the role of the `LogStore` service
    inside the overall application. This definition is generated automatically by
    Visual Studio in the same file, below the initial definition created by Visual
    Studio, with just the partition interval changed to 0-1,000:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`ApplicationParameters` contains possible overrides for parameters defined
    in `ApplicationManifest.xml` for various deployment environments: the cloud (that
    is, the actual Azure Service Fabric cluster) and local emulators with one or five
    nodes.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PublishProfiles` contains the settings that are needed to publish the application
    in the same environments handled by the `ApplicationParameters` folder. You just
    need to customize the cloud publish profile with the actual name of your Azure
    Service Fabric URI and with the authentication certificate you downloaded during
    the Azure cluster configuration process:'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The remaining steps that need to be followed in order to complete the application
    have been organized into several subsections. Let's start by looking at ensuring
    message idempotency.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: Ensuring message idempotency
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Messages can become lost because of failures or small timeouts caused by load
    balancing. Here, we will use a predefined remoting-based communication that performs
    automatic message retries in the event of failures. However, this may cause the
    same messages to be received twice. Since we are summing up the revenues of purchase
    orders, we must protect ourselves from summing up the same purchase several times.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: To do this, we will implement a library containing the necessary tools to ensure
    that message replicas are discarded.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: Let's add a new .NET Standard 2.0 library project called **IdempotencyTools**
    to our solution. Now, we can remove the initial class scaffolded by Visual Studio.
    This library needs a reference to the same version of the `Microsoft.ServiceFabric.Services`
    NuGet package referenced by `LogStore`, so let's verify the version number and
    add the same NuGet package reference to the `IdempotencyTools` project.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: 'The main tool that ensures message idempotency is the `IdempotentMessage` class:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We added the `DataContract` and `DataMember` attributes since they are needed
    by the remoting communication serializer we are going to use for all internal
    messages. Basically, the preceding class is a wrapper that adds a `Guid` and a
    time mark to the message class instance that's passed to its constructor.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: The `IdempotencyFilter` class uses a distributed dictionary to keep track of
    the messages it has already received. To avoid the indefinite growth of this dictionary,
    older entries are periodically deleted. Messages that are too old to be found
    in the dictionary are automatically discarded.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: 'The time interval entries are kept in the dictionary and are passed in the
    `IdempotencyFilter` static factory method, which creates new filter instances,
    along with the dictionary name and the `IReliableStateManager` instance, which
    are needed to create the distributed dictionary:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The dictionary contains each message time mark indexed by the message `Guid`
    and is created by invoking the `GetOrAddAsync` method of the `IReliableStateManager`
    instance with the dictionary type and name. `lastClear` contains the time of the
    removal of all old messages.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: 'When a new message arrives, the `NewMessage` method checks whether it must
    be discarded. If the message must be discarded, it returns `null`; otherwise,
    it adds the new message to the dictionary and returns the message without the
    `IdempotentMessage` wrapper:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'As a first step, the method verifies whether it''s time to clear the dictionary
    and whether the message is too old. Then, it starts a transaction to access the
    dictionary. All distributed dictionary operations must be enclosed in a transaction,
    as shown in the following code:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If the message `Guid` is found in the dictionary, the transaction is aborted
    since the dictionary doesn't need to be updated and the method returns `default(T)`,
    which is actually `null` since the message must not be processed. Otherwise, the
    message entry is added to the dictionary and the unwrapped message is returned.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: The code of the `Clear` method can be found in the GitHub repository associated
    with this book.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: The Interaction library
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are some types that must be shared among all microservices. If the internal
    communication is implemented with either remoting or WCF, each microservice must
    expose an interface with all the methods other microservices call. Such interfaces
    must be shared among all microservices. Moreover, with all communication interfaces,
    the classes that implement the messages must also be shared among all microservices
    (or among some subsets of them). Therefore, all of these structures are declared
    in external libraries that are referenced by the microservices.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's add a new .NET Standard 2.0 library project called `Interactions`
    to our solution. Since this library must use the `IdempotentMessage` generic class,
    we must add it as a reference to the `IdempotencyTools` project. We must also
    add a reference to the remoting communication library contained in the `Microsoft.ServiceFabric.Services.Remoting`
    NuGet package, since all interfaces that are used to expose the microservice's
    remote methods must inherit from the `IService` interface defined in this package.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '`IService` is an empty interface that declares the communication role of the
    inheriting interface. The `Microsoft.ServiceFabric.Services.Remoting` NuGet package
    version must match the version of the `Microsoft.ServiceFabric.Services` package
    declared in the other projects.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows the declarations of the interface that need to be
    implemented by the `LogStore` class:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The following is the code of the `PurchaseInfo` message class, which is referenced
    in the `ILogStore` interface:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now, we are ready to implement our main `LogStore` microservice.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the receiving side of communications
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To implement the `LogStore` microservice, we must add a reference to the `Interaction`
    library, which will automatically create references to the remoting library and
    to the `IdempotencyTools` project.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, the `LogStore` class must implement the `ILogStore` interface:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Once the service receives a `LogPurchase` call from the remoting runtime, it
    puts the message in the `LogQueue` to avoid the caller remaining blocked, waiting
    for message processing completion. This way, we achieve both the reliability of
    a synchronous message passing protocol (the caller knows that the message has
    been received) and the performance advantages of asynchronous message processing
    that are typical of asynchronous communication.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '`LoqQueue`, as a best practice for all distributed collections, is created
    in the `RunAsync` method, so `LogQueue` may be null if the first call arrives
    before the Azure Service Fabric runtime has called `RunAsync`. In this event,
    the method returns `false` to signal that the service isn''t ready yet, in which
    case the sender will wait a little and will then resend the message. Otherwise,
    a transaction is created to enqueue the new message.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: 'However, our service will not receive any communication if we don''t furnish
    an implementation of `CreateServiceReplicaListeners()` that returns all the listeners
    that the service would like to activate. In the case of remoting communications,
    there is a predefined method that performs the whole job, so we just need to call
    it:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, `CreateServiceRemotingReplicaListeners` is an extension method defined
    in the remoting communication library. It creates listeners for both primary replicas
    and secondary replicas (for read-only operations). When creating the client, we
    can specify whether its communications are addressed just to primary replicas
    or to secondary replicas as well.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: 'If you would like to use different listeners, you must create an `IEnumerable`
    of `ServiceReplicaListener` instances. For each listener, you must invoke the
    `ServiceReplicaListener` constructor with three arguments:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: A function that receives the reliable service context object as its input and
    returns an implementation of the `ICommunicationListener` interface.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The name of the listener. This second argument becomes obligatory when the service
    has more than one listener.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Boolean that is true if the listener must be activated on secondary replicas.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For instance, if we would like to add both custom and HTTP listeners, the code
    becomes something like the following:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`MyCustomHttpListener` is a custom implementation of `ICommunicationListener`,
    while `KestrelCommunicationListener` is a predefined HTTP listener based on Kestrel
    and ASP.NET Core. The following is the full code that defines the `KestrelCommunicationListener`
    listener:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '`ICommunicationListener` implementations must also have a `Close` method, which
    must close the opened communication channel, and an `Abort` method, which must
    **immediately** close the communication channel (ungracefully, that is, without
    informing connected clients and so on).'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have turned communications on, we can implement the service logic.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Implementing service logic
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Service logic is executed by the tasks that are launched as independent threads
    when `RunAsync` is invoked by the Service Fabric runtime. It's good practice to
    create an `IHost` and design all the tasks as `IHostedService` implementations
    also when you only need to implement one task. In fact, `IHostedService` implementations
    are independent chunks of software that are easier to unit test. `IHost` and `IHostedService`
    were discussed in detail in the *Using generic hosts* subsection of *Chapter 5*,
    *Applying a Microservice Architecture to Your Enterprise Application*.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will implement the logic that computes daily revenues for
    each location in an `IHostedservice` named `ComputeStatistics`, which uses a distributed
    dictionary whose keys are the location names and whose values are instances of
    a class called `RunningTotal`. This class stores the current running total and
    the day that is being computed:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This class has an `Update` method that updates the instance when a new purchase
    message is received. First of all, the incoming message time is normalized to
    universal time. Then, the day part of this time is extracted and compared with
    the current `Day` of the running total, as shown in the following code:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If it''s a new day, we assume that the running total computation of the previous
    day has finished, so the `Update` method returns it in a new `RunningTotal` instance
    and resets `Day` and `Count` so that it can compute the running total for the
    new day. Otherwise, the new value is added to the running `Count` and the method
    returns `null`, meaning that the day total isn''t ready yet. This implementation
    can be seen in the following code:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `IHostedService` implementation of `ComputeStatistics` requires some parameters
    in order to work properly, as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: The queue containing all the incoming messages
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `IReliableStateManager` service, so that it can create the distributed dictionary
    where it stores data
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ConfigurationPackage` service, so that it can read the settings defined
    in the `Settings.xml` service file and possibly those overridden in the application
    manifest
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The preceding parameters must be passed in the `ComputeStatistics` constructor
    when a `ComputeStatistics` instance is created by `IHost` through dependency injection.
    We will return to the `IHost` definition in the next subsection. For now, let''s
    concentrate on the `ComputeStatistics` constructor and its fields:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'All the constructor parameters are stored in private fields so that they can
    be used when `ExecuteAsync` is called:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Before entering its loop, the `ComputeStatistics` service prepares some structures
    and parameters. It declares that the queue isn''t empty, meaning it can start
    dequeuing messages. Then, it extracts `MessageMaxDelaySeconds` from the service
    settings and turns it into an integer. The value of this parameter was left empty
    in the `Settings.xml` file. Now, it''s time to override it and define its actual
    value in `ApplicationManifest.xml`:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '`ServiceManifestImport` imports the service manifest in the application and
    overrides some configuration. Its version number must be changed every time its
    content and/or the service definition is changed and the application is redeployed
    in Azure because version number changes tell the Service Fabric runtime what to
    change in the cluster. Version numbers also appear in other configuration settings.
    They must be changed every time the entities they refer to change.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '`MessageMaxDelaySeconds` is passed to the instance of the idempotency filter,
    along with a name for the dictionary of the already received messages, and with
    the instance of the `IReliableStateManager` service. Finally, the main distributed
    dictionary that''s used to store running totals is created.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: 'After this, the service enters its loop and finishes when `stoppingToken` is
    signaled, that is, when the Service Fabric runtime signals that the service is
    going to be stopped:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The inner loop runs until the queue becomes empty and then exits and waits 100
    milliseconds before verifying whether new messages have been enqueued.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the code for the inner loop, which is enclosed in a transaction:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Here, the service is trying to dequeue a message. If the queue is empty, it
    sets `queueEmpty` to `true` to exit the loop; otherwise, it passes the message
    through the idempotency filter. If the message survives this step, it uses it
    to update the running total of the location referenced in the message. However,
    correct operation of the distributed dictionary requires that the old counter
    is replaced with a new counter each time an entry is updated. Accordingly, the
    old counter is copied into a new `RunningTotal` object. This new object can be
    updated with the new data if we call the `Update` method:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Then, the transaction is committed, as shown in the following code:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'When the `Update` method returns a complete computation result, that is, when
    `total != null`, the following method is called:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `SendTotal` method sends the total to a service that publicly exposes all
    the statistics through an HTTP endpoint. After reading *Chapter 14*, *Applying
    Service-Oriented Architectures with .NET Core*, which is dedicated to the Web
    API, you may want to implement a similar service with a stateless ASP.NET Core
    microservice connected to a database. The stateless ASP.NET Core service template
    automatically creates an ASP.NET Core-based HTTP endpoint for you.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: However, since this service must receive data from the `SendTotal` method, it
    also needs remote-based endpoints. Therefore, we must create them, just as we
    did for the `LogStore` microservice, and concatenate the remote-based endpoint
    array with the pre-existing array containing the HTTP endpoint.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: Defining the microservice's host
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now we have everything in place to define the microservice''s `RunAsync` method:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Here, the service queue is created, and the service settings are saved in `configurationPackage`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, we can create the `IHost` service, as we explained in the *Using
    generic hosts* subsection of *Chapter 5*, *Applying a Microservice Architecture
    to Your Enterprise Application*:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '`ConfigureServices` defines all singleton instances that are needed by `IHostedService`
    implementations, so they are injected into the constructor of all the implementations
    that reference their types. Then, `AddHostedService` declares the unique `IHostedService`
    of the microservice. Once the `IHost` is built, we run it until the `RunAsync`
    cancellation token is signaled. When the cancellation token is signaled, the request
    to shut down is passed to all `IHostedService` implementations.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: Communicating with the service
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since we haven't implemented the whole purchase logic yet, we will implement
    a stateless microservice that sends random data to the `LogStore` service. Right-click
    on the `PurchaseLogging` project in the **Solution Explorer** and select **Add**
    | **Service Fabric Service**. Then, select the .NET Core stateless template and
    name the new microservice project `FakeSource`.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s add a reference to the `Interaction` project. Before moving on
    to the service code, we need to update the replica count of the newly created
    service in `ApplicationManifest.xml` as well as in all the other environment-specific
    parameter overrides (the cloud, one local cluster node, five local cluster nodes):'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This fake service needs no listeners and its `RunAsync` method is straightforward:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In each loop, a random message is created and sent to the counting microservices.
    Then, the thread sleeps for a second and starts a new loop. The code that sends
    the created messages is as follows:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Here, a key in the 0-9,999 interval is computed from the location string. We
    used `GetHashCode` since we are sure that all involved services use the same .NET
    Core version and accordingly we are sure they use the same `GetHashCode` implementation
    that computes the hash in exactly the same way. However, in general, it is better
    to provide a library with a standard hash code implementation.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: This integer is passed to the `ServicePartitionKey` constructor. Then, a service
    proxy is created, and the URI of the service to call and the partition key are
    passed. The proxy uses this data to ask the naming service for a physical URI
    for a primary instance for the given partition value.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '`ServiceProxy.Create` also accepts a third optional argument that specifies
    whether messages that are sent by the proxy can also be routed to secondary replicas.
    The default is that messages are routed just to primary instances. If the message
    target returns `false`, meaning that it''s not ready (remember that `LogPurchase`
    returns `false` when the `LogStore` message queue hasn''t been created yet), the
    same transmission is attempted after 100 milliseconds.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: 'Sending messages to a remoting target is quite easy. However, other communication
    listeners require that the sender interacts manually with the naming service to
    get a physical service URI. This can be done with the following code:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Moreover, in the case of generic communication protocols, we must manually handle
    failures and retries with a library such as Polly (see the *Resilient task execution*
    subsection of *Chapter 5*, *Applying a Microservice Architecture to Your Enterprise
    Application*, for more information).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: Testing the application
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To test the application, you need to start Visual Studio with administrator
    permissions. Therefore, close Visual studio, then right-click on the Visual Studio
    icon and select the option to launch it as an administrator. Once you are again
    in Visual Studio, load the `PurchaseLogging` solution, and place a breakpoint
    in the `ComputeStatistics.cs` file:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Each time the breakpoint is hit, look at the content of `newCounter` to verify
    how the running totals of all the locations change. Before launching the application
    in debug mode, ensure the local cluster is running with five nodes. If you change
    from one to five nodes, the local cluster menu grays out until the operation is
    completed, so wait until the menu normalizes.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: Once you launch the application and the application is built, a console appears
    and you start receiving notifications of the operation completed in Visual Studio.
    The application takes some minutes to load on all nodes; after that, your breakpoint
    should start being hit.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we described how to define a Service Fabric solution in Visual
    Studio, and how to set up and configure a Service Fabric cluster in Azure.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: We described Service Fabric building blocks, reliable services, the various
    types of reliable services, and their roles within a Service Fabric application.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we put these concepts into practice by implementing a Service Fabric
    application. Here, we provided more practical details on the architecture of each
    reliable service and how to organize and code their communications.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter describes another famous microservices orchestrator, Kubernetes,
    and its implementation in the Azure Cloud.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is a reliable service?
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can you list the different types of reliable services and their roles in a Service
    Fabric application?
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is `ConfigureServices`?
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What kinds of port must be declared during the definition of an Azure Service
    Fabric cluster?
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why are partitions of reliable stateful services needed?
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can we declare that a remoting communication must be addressed by secondary
    replicas? What about other types of communication?
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The official documentation for Azure Service Fabric can be found here: [https://docs.microsoft.com/en-US/azure/service-fabric/](https://docs.microsoft.com/en-US/azure/service-fabric/).'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The official documentation for Azure Service Fabric''s reliable services can
    be found here: [https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-reliable-services-introduction](https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-reliable-services-introduction).'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'More information about the Actor model can be found here: [https://www.researchgate.NET/publication/234816174_Actors_A_conceptual_foundation_for_concurrent_object-oriented_programming](https://www.researchgate.NET/publication/234816174_Actors_A_conceptual_foundation_for_concurrent_obj).'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The official documentation for Actor models that can be implemented in Azure
    Service Fabric can be found here: [https://docs.microsoft.com/en-US/azure/service-fabric/service-fabric-reliable-actors-introduction](https://docs.microsoft.com/en-US/azure/service-fabric/service-fabric-reliable-actors-introduction).'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Microsoft has also implemented an advanced Actor model that is independent
    of Service Fabric. This is known as the Orleans framework. More information about
    Orleans can be found at the following links:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '**Orleans – Virtual Actors**: [https://www.microsoft.com/en-us/research/project/orleans-virtual-actors/?from=https%3A%2F%2Fresearch.microsoft.com%2Fen-us%2Fprojects%2Forleans%2F](https://www.microsoft.com/en-us/research/project/orleans-virtual-actors/?from=https%3A%2F%2Fresearch).'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Orleans** **Documentation**: [https://dotnet.github.io/orleans/docs/index.html](https://dotnet.github.io/orleans/docs/index.html)'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
