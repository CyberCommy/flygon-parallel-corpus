- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Azure Service Fabric
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is dedicated to describing Azure Service Fabric, which is a Microsoft
    opinionated microservices orchestrator. It is available on Azure, but Service
    Fabric software is also available for download, meaning users can use it to define
    their own on-premises microservices clusters.
  prefs: []
  type: TYPE_NORMAL
- en: While Service Fabric is not as diffused as Kubernetes, it has a better learning
    curve and enables you to experiment with the fundamental concepts of microservices,
    and to build sophisticated solutions in a very short space of time. Moreover,
    it offers an integrated deployment environment, which includes everything you
    need to implement a complete application. More specifically, it also offers its
    integrated communication protocol, and an easy and reliable way to store state
    information.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio support for Azure Service Fabric applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to define and configure an Azure Service Fabric cluster
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to code reliable services, and their communication in practice, through
    the "logging microservices" use case
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have learned how to implement a complete
    solution based on Azure Service Fabric.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you will require the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio 2019 free Community Edition or better, with all the database tools
    and the Azure development workload installed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A free Azure account. The *Creating an Azure account* section in *Chapter 1*,
    *Understanding the Importance of Software Architecture*, explains how to create
    one.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A local emulator for Azure Service Fabric to debug your microservices in Visual
    Studio. It is free and can be downloaded from [https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-get-started#install-the-sdk-and-tools](https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-get-started#install-the-sdk-and).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To avoid installation issues, ensure that your version of Windows is up to
    date. Moreover, the emulator uses PowerShell high-privilege-level commands that,
    by default, are blocked by PowerShell. To enable them, you need to execute the
    following command in the Visual Studio Package Manager Console or in any PowerShell
    console. Visual Studio or an external PowerShell console must be started as an
    *administrator* for the following command to be successful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Visual Studio support for Azure Service Fabric
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Visual Studio has a specific project template for microservice applications,
    based on the Service Fabric platform, where you can define various microservices,
    configure them, and deploy them to Azure Service Fabric, which is a microservice
    orchestrator. Azure Service Fabric will be described in more detail in the next
    section.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will describe the various types of microservice you can
    define within a Service Fabric Application. A complete code example will be provided
    in the last section of this chapter. If you want to debug microservices on your
    development machine, you need to install the Service Fabric emulator listed in
    this chapter's technical requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Service Fabric Applications can be found by selecting **Cloud** in the *Visual
    Studio project type drop-down filter*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16756_06_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.1: Selecting a Service Fabric Application'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have selected the project and chosen the project and solution names,
    you can choose from a variety of services:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16756_06_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.2: Choice of services'
  prefs: []
  type: TYPE_NORMAL
- en: All projects under .NET Core use a microservice model that is specific to Azure
    Service Fabric. The Guest Executable adds a wrapper around an existing Windows
    application to turn it into a microservice that can run in Azure Service Fabric.
    The Container application enables the addition of any Docker image in the Service
    Fabric application. All the other choices scaffold a template that allows you
    to code a microservice with a Service Fabric-specific pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you select **Stateless Service** and fill in all the request information,
    Visual Studio creates two projects: an application project that contains configuration
    information for the overall application, and a project for the specific service
    you have chosen that contains both the service code and a service-specific configuration.
    If you want to add more microservices to your application, right-click on the
    application project and select **Add** | **New Service Fabric Service**.'
  prefs: []
  type: TYPE_NORMAL
- en: If you right-click on the solution and select **Add** | **New project**, a new
    Service Fabric application will be created instead of a new service being added
    to the already existing application.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you select **Guest Executable**, you need to provide the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The service name.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A folder containing the main executable file, along with all the files it needs
    in order to work properly. You need this if you want to create a copy of this
    folder in your project or simply to link to the existing folder.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whether to add a link to this folder, or to copy the selected folder into the
    Service Fabric project.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The main executable file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arguments to pass on the command line to that executable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which folder to use as a working folder on Azure. You want to use the folder
    containing the main executable (`CodeBase`), the folder where Azure Service Fabric
    will package the entire microservice (`CodePackage`), or a new subfolder named
    `Work`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you select **Container**, you need to provide the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The service name.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The complete name of a Docker image in your private Azure Container Registry.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The username that will be used to connect to Azure Container Registry. The password
    will be specified manually in the same `RepositoryCredentials` XML element of
    the application configuration file that was automatically created for the username.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The port where you can access your service (host port) and the port inside the
    container that the host port must be mapped to (container port). The container
    port must be the same port that was exposed in the Dockerfile and used to define
    the Docker image.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Afterward, you may need to add further manual configuration to ensure that your
    Docker application works properly. The *Further reading* section contains links
    to the official documentation where you can find more details.
  prefs: []
  type: TYPE_NORMAL
- en: There are five types of .NET Core native Service Fabric services. The Actor
    service pattern is an opinionated pattern that was conceived several years ago
    by Carl Hewitt. We will not discuss it here, but the *Further reading* section
    contains some links that provide more information on this.
  prefs: []
  type: TYPE_NORMAL
- en: The remaining four patterns refer to the usage (or not) of ASP.NET (Core) as
    the main interaction protocol and to the fact that the service has or hasn't got
    an internal state. In fact, Service Fabric allows microservices to use distributed
    queues and dictionaries that are globally accessible to all instances of the microservice
    that declares them, independent of the hardware node where they are running (they
    are serialized and distributed to all available instances when they're needed).
  prefs: []
  type: TYPE_NORMAL
- en: 'Stateful and stateless templates differ mainly in terms of their configuration.
    All native services are classes that specify just two methods. Stateful services
    specify:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'While stateless services specify:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `CreateServiceReplicaListeners` and `CreateServiceInstanceListeners` methods
    specify a list of listeners that are used by the microservice to receive messages
    and the code that handles those messages. Listeners may use any protocol, but
    they are required to specify an implementation of the relative socket.
  prefs: []
  type: TYPE_NORMAL
- en: '`RunAsync` contains the code for background threads that asynchronously run
    tasks that are triggered by received messages. Here, you can build a host that
    runs several hosted services.'
  prefs: []
  type: TYPE_NORMAL
- en: ASP.NET Core templates follow the same pattern; however, they use a unique ASP.NET
    Core-based listener and no `RunAsync` implementation, since background tasks can
    be launched from inside ASP.NET Core, whose listener defines a complete `WebHost`.
    However, you may add further listeners to the array of listeners returned by the
    `CreateServiceReplicaListeners` implementation created by Visual Studio, and also
    a custom `RunAsync` override.
  prefs: []
  type: TYPE_NORMAL
- en: It is worth pointing out that as `RunAsync` is optional, and since the ASP.NET
    Core template doesn't implement it, `CreateServiceReplicaListeners` and `CreateServiceInstanceListeners`
    are also optional, and, for instance, a background worker operating on a timer
    doesn't need to implement any of them.
  prefs: []
  type: TYPE_NORMAL
- en: More details on Service Fabric's native services pattern will be provided in
    the following section, while a complete code example will be provided in the *Use
    case – Logging microservices* section of this chapter, which is dedicated to this
    book's use case.
  prefs: []
  type: TYPE_NORMAL
- en: Defining and configuring your Azure Service Fabric cluster
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Azure Service Fabric is the main Microsoft orchestrator that can host Docker
    containers, native .NET applications, and a distributed computing model called
    **reliable services**. We have already explained how we can create applications
    that contain these three types of services in the *Visual Studio support for Azure
    Service Fabric* section. In this section, we will explain how to create an Azure
    Service Fabric cluster in the Azure portal and provide some more details on reliable
    services. More practical details regarding *reliable services* will be provided
    in the example described in the *Use case – Logging microservices* section.
  prefs: []
  type: TYPE_NORMAL
- en: You can enter the Service Fabric section of Azure by typing `Service Fabric`
    into the Azure search bar and selecting **Service Fabric Cluster**.
  prefs: []
  type: TYPE_NORMAL
- en: A summary page of all of your Service Fabric clusters appears which, in your
    case, should be empty. When you click the **Add** button to create your first
    cluster, a multi-step wizard is shown. The following subsections describe the
    available steps.
  prefs: []
  type: TYPE_NORMAL
- en: Step 1 – Basic information
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following screenshot shows the creation of Azure Service Fabric:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16756_06_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.3: Azure Service Fabric creation'
  prefs: []
  type: TYPE_NORMAL
- en: Here, you can choose the operating system, resource group, subscription, location,
    and username and password that you want to use to connect the remote desktop to
    all the cluster nodes.
  prefs: []
  type: TYPE_NORMAL
- en: You are required to choose a cluster name, which will be used to compose the
    cluster URI as `<cluster name>.<location>.cloudapp.azure.com`, where `location`
    is a name associated with the data center location you have chosen. Let's select
    Windows, since Service Fabric was primarily conceived for Windows. A better choice
    for Linux machines is Kubernetes, which will be described in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Then you are required to select your node type, that is, the kind of virtual
    machine you would like to use for your primary nodes, and the initial scale set,
    that is, the maximum number of virtual machines to use. Please choose a cheap
    node type and no more than three nodes, otherwise you might quickly waste all
    your free Azure credit.
  prefs: []
  type: TYPE_NORMAL
- en: More details on node configurations will be given in the next subsection.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you have the option to select a certificate to secure your node-to-node
    communications. Let's click the **Select a certificate** link, and in the window
    that opens, select the automatic creation of a new key vault and of a new certificate.
    More information on security will be provided in the *Step 3 – Security configuration*
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Step 2 – Cluster configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the second step, you can fine-tune the cluster node type and number:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16756_06_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.4: Cluster configuration'
  prefs: []
  type: TYPE_NORMAL
- en: More specifically, in the previous step, we selected the cluster primary node.
    Here, we can choose whether to add various kinds of secondary nodes with their
    scale capacities. Once you have created different node types, you can configure
    services to run only on specific node types whose capabilities are adequate to
    their needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s click the **Add** button to add a new node type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16756_06_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.5: Adding a new node type'
  prefs: []
  type: TYPE_NORMAL
- en: Nodes of a different node type can be scaled independently, and the **primary
    node** type is where Azure Service Fabric runtime services will be hosted. For
    each node type, you can specify the type of machine (**Durability tier**), machine
    dimensions (CPU and RAM), and the initial number of nodes.
  prefs: []
  type: TYPE_NORMAL
- en: You can also specify all the ports that will be visible from outside the cluster
    (**Custom endpoints**).
  prefs: []
  type: TYPE_NORMAL
- en: The services that are hosted on the different nodes of a cluster can communicate
    through any port since they are part of the same local network. Therefore, **Custom
    endpoints** must declare the ports that need to accept traffic from outside the
    cluster. The port that are exposed in **Custom endpoints** are the cluster's public
    interface, which can be reached through the cluster URI, that is, `<cluster name>.<location>.cloudapp.azure.com`.
    Their traffic is automatically redirected to all the microservices that have had
    the same ports opened by the cluster load balancer.
  prefs: []
  type: TYPE_NORMAL
- en: To understand the **Enable reverse proxy** option, we must explain how communications
    are sent to several instances of services whose physical addresses change during
    their lifetimes. From within the cluster, services are identified with a URI such
    as `fabric://<application name>/<service name>`. That is, this name allows us
    to access one of the several load-balanced instances of `<service name>`. However,
    these URIs can't be used directly by communication protocols. Instead, they are
    used to get the physical URI of the required resource, along with all its available
    ports and protocols from the Service Fabric naming service.
  prefs: []
  type: TYPE_NORMAL
- en: Later, we will learn how to perform this operation with *reliable services*.
    However, this model is not adequate for Dockerized services that weren't conceived
    to run specifically on Azure Service Fabric, since they are not aware of Service
    Fabric-specific naming services and APIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, Service Fabric provides two more options that we can use to standardize
    URLs instead of interacting directly with its naming service:'
  prefs: []
  type: TYPE_NORMAL
- en: '**DNS**: Each service can specify its `hostname` (also known as its **DNS name**).
    The DNS service takes care of translating it into the actual service URL. For
    example, if a service specifies an `order.processing` DNS name and it has an HTTP
    endpoint on port `80` and a `/purchase` path, we can reach this endpoint with
    `http://order.processing:80/purchase`. By default, the DNS service is active,
    but you can deactivate it either by showing the advanced settings selection in
    the secondary node screen by clicking **Configure advanced settings**, or by going
    to the **Advanced** tab.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reverse proxy**: Service Fabric''s reverse proxy intercepts all the calls
    that have been directed to the cluster address and uses the name service to send
    them to the right application and service within that application. Addresses that
    are resolved by the reverse proxy service have the following structure: `<cluster
    name>.<location>.cloudapp.azure.com: <port>//<app name>/<service name>/<endpoint
    path>?PartitionKey=<value>& PartitionKind=value`. Here, partition keys are used
    to optimize stateful reliable services and will be explained at the end of this
    subsection. This means that stateless services lack the query string part of the
    previous address. Thus, a typical address that''s solved by reverse proxy may
    be something similar to `myCluster.eastus.cloudapp.azure.com: 80//myapp/myservice/<endpoint
    path>?PartitionKey=A & PartitionKind=Named`. If the preceding endpoint is called
    from a service hosted on the same cluster, we can specify `localhost` instead
    of the complete cluster name (that is, from the same cluster, not from the same
    node): `localhost: 80//myapp/myservice/<endpoint path>?PartitionKey=A & PartitionKind=Named`.
    By default, reverse proxy is not enabled.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since we are going to use Service Fabric reliable services with Service Fabric
    built-in communication facilities, and since these built-in communication facilities
    don't need either reverse proxy or DNS, please avoid changing these settings.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, if you are creating the Service Fabric cluster with the sole purpose
    of experimenting with the simple example at the end of the chapter, please stick
    with just the primary nodes and avoid wasting your free Azure credit by creating
    secondary nodes as well.
  prefs: []
  type: TYPE_NORMAL
- en: Step 3 – Security configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once the second step is complete, we come to a security page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16756_06_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.6: Security page'
  prefs: []
  type: TYPE_NORMAL
- en: We already defined the main certificate in the first step. Here, you have the
    option to select a secondary certificate to be used when the primary certificate
    is near to its expiration. You can add also a certificate that will be used to
    enable HTTPS communication on reverse proxies. Since, in our example, we will
    not use Dockerized services (so we will not require reverse proxies), we don't
    need this option.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we can click the review and create button to create the cluster.
    Submitting your approval will create the cluster. Pay attention to this: a cluster
    may spend your free Azure credit in a short time, so just keep your cluster on
    when you are testing. Afterward, you should delete it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to download our primary certificate to our development machine, since
    we need it to deploy our application. Once the certificate has been downloaded,
    it is enough to double-click on it to install it on our machine. Before deploying
    the application, you are required to insert the following information into the
    **Cloud Publish Profile** of your Visual Studio Service Fabric applications (see
    this chapter''s *Use case – Logging microservices* section for more details):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Since both the client (Visual Studio) and the server use the same certificate
    for authentication, the server and client thumbprint are the same. The certificate
    thumbprint can be copied from your Azure Key Vault. It is worth mentioning that
    you can also add client-specific certificates to the main server certificate by
    selecting the corresponding option in *step 3*.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we mentioned in the *Visual Studio support for Azure Service Fabric* subsection,
    Azure Service Fabric supports two kinds of *reliable service*: stateless and stateful.
    Stateless services either don''t store permanent data or they store it in external
    supports such as the Redis cache or databases (see *Chapter 9*, *How to Choose
    Your Data Storage in the Cloud*, for the main storage options offered by Azure).'
  prefs: []
  type: TYPE_NORMAL
- en: Stateful services, on the other hand, use Service Fabric-specific distributed
    dictionaries and queues. Each distributed data structure is accessible from all
    the *identical* replicas of a service, but only one replica, called the primary
    replica, is allowed to write on them to avoid synchronized access to those distributed
    resources, which may cause bottlenecks.
  prefs: []
  type: TYPE_NORMAL
- en: All the other replicas, known as secondary replicas, can only read from these
    distributed data structures.
  prefs: []
  type: TYPE_NORMAL
- en: You can check if a replica is primary by looking at the context object your
    code receives from the Azure Service Fabric runtime, but usually, you don't need
    to do this. In fact, when you declare your service endpoints, you are required
    to declare those that are read-only. A read-only endpoint is supposed to receive
    requests so that it can read data from the shared data structures. Therefore,
    since only read-only endpoints are activated for secondary replicas, if you implement
    them correctly, write/update operations should automatically be prevented on stateful
    secondary replicas with no need to perform further checks.
  prefs: []
  type: TYPE_NORMAL
- en: In stateful services, secondary replicas enable parallelism on read operations,
    so in order to get parallelism on write/update operations, stateful services are
    assigned different data partitions. More specifically, for each stateful service,
    Service Fabric creates a primary instance for each partition. Then, each partition
    may have several secondary replicas.
  prefs: []
  type: TYPE_NORMAL
- en: Distributed data structures are shared between the primary instance of each
    partition and its secondary replicas. The whole extent of data that can be stored
    in a stateful service is split among the chosen number of partitions, according
    to a partition key that is generated by a hashing algorithm on the data to be
    stored.
  prefs: []
  type: TYPE_NORMAL
- en: Typically, partition keys are integers that belong to a given interval that
    is split among all the available partitions. For instance, a partition key can
    be generated by calling a well-known hashing algorithm on one or more string fields
    to get integers that are then processed to get a unique integer (using, for instance,
    an exclusive OR operation on the integer bits). Then, this integer can be constrained
    to the integer interval that was chosen for the partition key by taking the remainder
    of an integer division (for instance, the remainder of a division for 1,000 will
    be an integer in the 0-999 interval). It is important to be sure that all services
    use exactly the same hashing algorithm, so the better solution is to provide a
    common hashing library to all of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say we want four partitions, which will be selected with an integer
    key in the 0-999 interval. Here, Service Fabric will automatically create four
    primary instances of our stateful service and assign them the following four partition
    key subintervals: 0-249, 250-499, 500-749, and 750-999.'
  prefs: []
  type: TYPE_NORMAL
- en: From within your code, you are required to compute the partition key of the
    data you send to a stateful service. Then, Service Fabric's runtime will select
    the right primary instance for you. The following section provides more practical
    details on this and how to use reliable services in practice.
  prefs: []
  type: TYPE_NORMAL
- en: Use case – Logging microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will look at a microservice-based system that logs data
    about purchases relating to various destinations in our WWTravelClub use case.
    In particular, we will design microservices that take care of computing daily
    revenues per location. Here, we're assuming that these microservices receive data
    from other subsystems hosted in the same Azure Service Fabric application. More
    specifically, each purchase log message is composed of the location name, the
    overall package cost, and the date and time of the purchase.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a first step, let''s ensure that the Service Fabric emulator that we mentioned
    in the *Technical requirements* section of this chapter has been installed and
    is running on your development machine. Now, we need to switch it so that it runs
    **5 nodes**: right-click on the small Service Fabric cluster icon you have in
    your Windows notification area, and, in the context menu that opens, select **Switch
    Cluster Mode** -> **5 nodes**.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can follow the steps set out in the *Visual Studio support for Azure
    Service Fabric* section to create a Service Fabric project named `PurchaseLogging`.
    Select a .NET Core stateful reliable service and name it `LogStore`.
  prefs: []
  type: TYPE_NORMAL
- en: The solution that's created by Visual Studio is composed of a `PurchaseLogging`
    project, which represents the overall application, and a `LogStore` project, which
    will contain the implementation of the first microservice that's included in the
    `PurchaseLogging` application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Under the `PackageRoot` folder, the `LogStore` service and each reliable service
    contain the `ServiceManifest.xml` configuration file and a `Settings.xml` folder
    (under the `Config` subfolder). The `Settings.xml` folder contains some settings
    that will be read from the service code. The initial file contains predefined
    settings that are needed by the Service Fabric runtime. Let''s add a new `Settings`
    section, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We will use the value of `MessageMaxDelaySeconds` to configure the system component
    and ensure message idempotency. The setting value is empty because most of the
    settings are overridden when the services are deployed by the overall application
    settings contained in the `PurchaseLogging` project.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ServiceManifest.xml` file contains a number of configuration tags that
    are automatically handled by Visual Studio, as well as a list of endpoints. Two
    endpoints are preconfigured since they are used by the Service Fabric runtime.
    Here, we must add the configuration details of all the endpoints our microservice
    will listen to. Each endpoint definition has the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: If `Type` is `Internal`, the port will be opened just inside the cluster's local
    network; otherwise, the port will be available from outside the cluster as well.
    In the preceding case, we must declare that port in the configuration of the Azure
    Service Fabric cluster as well, otherwise the cluster load balancer/firewall will
    not forward messages to it.
  prefs: []
  type: TYPE_NORMAL
- en: Public ports can be reached directly from the cluster URI (`<cluster name>.<location
    code>.cloudapp.azure.com`) since the load balancer that interfaces each cluster
    will forward the input traffic it receives to them.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we won't define endpoints since we are going to use the predefined
    remoting-based communication, but we will show you how to use them later on in
    this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `PurchaseLogging` project contains a reference to the `LogStore` project
    under the *services* Solution Explorer node and contains various folders with
    various XML configuration files. More specifically, we have the following folders:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ApplicationPackageRoot`, which contains the overall application manifest named
    `ApplicationManifest.xml`. This file contains some initial parameter definitions
    and then further configurations. Parameters have the following format:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Once defined, parameters can replace any value in the remainder of the file.
    Parameter values are referenced by enclosing the parameter name between square
    brackets, as shown in the following code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Some parameters define the number of replicas and partitions for each service
    and are automatically created by Visual Studio. Let''s replace these initial values
    suggested by Visual Studio with those in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We will use just two partitions to show you how partitions work, but you can
    increase this value to improve write/update parallelism. Each partition of the
    `LogStore` service doesn't need several replicas, since replicas improve performance
    on read operations and this service is not designed to offer read services. In
    similar situations, you may choose two to three replicas to make the system redundant
    and more robust to failures. However, we've left one since, as this is just an
    example, we are not concerned with failures.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding parameters are used to define the role of the `LogStore` service
    inside the overall application. This definition is generated automatically by
    Visual Studio in the same file, below the initial definition created by Visual
    Studio, with just the partition interval changed to 0-1,000:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '`ApplicationParameters` contains possible overrides for parameters defined
    in `ApplicationManifest.xml` for various deployment environments: the cloud (that
    is, the actual Azure Service Fabric cluster) and local emulators with one or five
    nodes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PublishProfiles` contains the settings that are needed to publish the application
    in the same environments handled by the `ApplicationParameters` folder. You just
    need to customize the cloud publish profile with the actual name of your Azure
    Service Fabric URI and with the authentication certificate you downloaded during
    the Azure cluster configuration process:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The remaining steps that need to be followed in order to complete the application
    have been organized into several subsections. Let's start by looking at ensuring
    message idempotency.
  prefs: []
  type: TYPE_NORMAL
- en: Ensuring message idempotency
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Messages can become lost because of failures or small timeouts caused by load
    balancing. Here, we will use a predefined remoting-based communication that performs
    automatic message retries in the event of failures. However, this may cause the
    same messages to be received twice. Since we are summing up the revenues of purchase
    orders, we must protect ourselves from summing up the same purchase several times.
  prefs: []
  type: TYPE_NORMAL
- en: To do this, we will implement a library containing the necessary tools to ensure
    that message replicas are discarded.
  prefs: []
  type: TYPE_NORMAL
- en: Let's add a new .NET Standard 2.0 library project called **IdempotencyTools**
    to our solution. Now, we can remove the initial class scaffolded by Visual Studio.
    This library needs a reference to the same version of the `Microsoft.ServiceFabric.Services`
    NuGet package referenced by `LogStore`, so let's verify the version number and
    add the same NuGet package reference to the `IdempotencyTools` project.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main tool that ensures message idempotency is the `IdempotentMessage` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We added the `DataContract` and `DataMember` attributes since they are needed
    by the remoting communication serializer we are going to use for all internal
    messages. Basically, the preceding class is a wrapper that adds a `Guid` and a
    time mark to the message class instance that's passed to its constructor.
  prefs: []
  type: TYPE_NORMAL
- en: The `IdempotencyFilter` class uses a distributed dictionary to keep track of
    the messages it has already received. To avoid the indefinite growth of this dictionary,
    older entries are periodically deleted. Messages that are too old to be found
    in the dictionary are automatically discarded.
  prefs: []
  type: TYPE_NORMAL
- en: 'The time interval entries are kept in the dictionary and are passed in the
    `IdempotencyFilter` static factory method, which creates new filter instances,
    along with the dictionary name and the `IReliableStateManager` instance, which
    are needed to create the distributed dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The dictionary contains each message time mark indexed by the message `Guid`
    and is created by invoking the `GetOrAddAsync` method of the `IReliableStateManager`
    instance with the dictionary type and name. `lastClear` contains the time of the
    removal of all old messages.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a new message arrives, the `NewMessage` method checks whether it must
    be discarded. If the message must be discarded, it returns `null`; otherwise,
    it adds the new message to the dictionary and returns the message without the
    `IdempotentMessage` wrapper:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'As a first step, the method verifies whether it''s time to clear the dictionary
    and whether the message is too old. Then, it starts a transaction to access the
    dictionary. All distributed dictionary operations must be enclosed in a transaction,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: If the message `Guid` is found in the dictionary, the transaction is aborted
    since the dictionary doesn't need to be updated and the method returns `default(T)`,
    which is actually `null` since the message must not be processed. Otherwise, the
    message entry is added to the dictionary and the unwrapped message is returned.
  prefs: []
  type: TYPE_NORMAL
- en: The code of the `Clear` method can be found in the GitHub repository associated
    with this book.
  prefs: []
  type: TYPE_NORMAL
- en: The Interaction library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are some types that must be shared among all microservices. If the internal
    communication is implemented with either remoting or WCF, each microservice must
    expose an interface with all the methods other microservices call. Such interfaces
    must be shared among all microservices. Moreover, with all communication interfaces,
    the classes that implement the messages must also be shared among all microservices
    (or among some subsets of them). Therefore, all of these structures are declared
    in external libraries that are referenced by the microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's add a new .NET Standard 2.0 library project called `Interactions`
    to our solution. Since this library must use the `IdempotentMessage` generic class,
    we must add it as a reference to the `IdempotencyTools` project. We must also
    add a reference to the remoting communication library contained in the `Microsoft.ServiceFabric.Services.Remoting`
    NuGet package, since all interfaces that are used to expose the microservice's
    remote methods must inherit from the `IService` interface defined in this package.
  prefs: []
  type: TYPE_NORMAL
- en: '`IService` is an empty interface that declares the communication role of the
    inheriting interface. The `Microsoft.ServiceFabric.Services.Remoting` NuGet package
    version must match the version of the `Microsoft.ServiceFabric.Services` package
    declared in the other projects.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows the declarations of the interface that need to be
    implemented by the `LogStore` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the code of the `PurchaseInfo` message class, which is referenced
    in the `ILogStore` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Now, we are ready to implement our main `LogStore` microservice.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the receiving side of communications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To implement the `LogStore` microservice, we must add a reference to the `Interaction`
    library, which will automatically create references to the remoting library and
    to the `IdempotencyTools` project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, the `LogStore` class must implement the `ILogStore` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Once the service receives a `LogPurchase` call from the remoting runtime, it
    puts the message in the `LogQueue` to avoid the caller remaining blocked, waiting
    for message processing completion. This way, we achieve both the reliability of
    a synchronous message passing protocol (the caller knows that the message has
    been received) and the performance advantages of asynchronous message processing
    that are typical of asynchronous communication.
  prefs: []
  type: TYPE_NORMAL
- en: '`LoqQueue`, as a best practice for all distributed collections, is created
    in the `RunAsync` method, so `LogQueue` may be null if the first call arrives
    before the Azure Service Fabric runtime has called `RunAsync`. In this event,
    the method returns `false` to signal that the service isn''t ready yet, in which
    case the sender will wait a little and will then resend the message. Otherwise,
    a transaction is created to enqueue the new message.'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, our service will not receive any communication if we don''t furnish
    an implementation of `CreateServiceReplicaListeners()` that returns all the listeners
    that the service would like to activate. In the case of remoting communications,
    there is a predefined method that performs the whole job, so we just need to call
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Here, `CreateServiceRemotingReplicaListeners` is an extension method defined
    in the remoting communication library. It creates listeners for both primary replicas
    and secondary replicas (for read-only operations). When creating the client, we
    can specify whether its communications are addressed just to primary replicas
    or to secondary replicas as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you would like to use different listeners, you must create an `IEnumerable`
    of `ServiceReplicaListener` instances. For each listener, you must invoke the
    `ServiceReplicaListener` constructor with three arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: A function that receives the reliable service context object as its input and
    returns an implementation of the `ICommunicationListener` interface.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The name of the listener. This second argument becomes obligatory when the service
    has more than one listener.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Boolean that is true if the listener must be activated on secondary replicas.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For instance, if we would like to add both custom and HTTP listeners, the code
    becomes something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '`MyCustomHttpListener` is a custom implementation of `ICommunicationListener`,
    while `KestrelCommunicationListener` is a predefined HTTP listener based on Kestrel
    and ASP.NET Core. The following is the full code that defines the `KestrelCommunicationListener`
    listener:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '`ICommunicationListener` implementations must also have a `Close` method, which
    must close the opened communication channel, and an `Abort` method, which must
    **immediately** close the communication channel (ungracefully, that is, without
    informing connected clients and so on).'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have turned communications on, we can implement the service logic.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing service logic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Service logic is executed by the tasks that are launched as independent threads
    when `RunAsync` is invoked by the Service Fabric runtime. It's good practice to
    create an `IHost` and design all the tasks as `IHostedService` implementations
    also when you only need to implement one task. In fact, `IHostedService` implementations
    are independent chunks of software that are easier to unit test. `IHost` and `IHostedService`
    were discussed in detail in the *Using generic hosts* subsection of *Chapter 5*,
    *Applying a Microservice Architecture to Your Enterprise Application*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will implement the logic that computes daily revenues for
    each location in an `IHostedservice` named `ComputeStatistics`, which uses a distributed
    dictionary whose keys are the location names and whose values are instances of
    a class called `RunningTotal`. This class stores the current running total and
    the day that is being computed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This class has an `Update` method that updates the instance when a new purchase
    message is received. First of all, the incoming message time is normalized to
    universal time. Then, the day part of this time is extracted and compared with
    the current `Day` of the running total, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'If it''s a new day, we assume that the running total computation of the previous
    day has finished, so the `Update` method returns it in a new `RunningTotal` instance
    and resets `Day` and `Count` so that it can compute the running total for the
    new day. Otherwise, the new value is added to the running `Count` and the method
    returns `null`, meaning that the day total isn''t ready yet. This implementation
    can be seen in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The `IHostedService` implementation of `ComputeStatistics` requires some parameters
    in order to work properly, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The queue containing all the incoming messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `IReliableStateManager` service, so that it can create the distributed dictionary
    where it stores data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ConfigurationPackage` service, so that it can read the settings defined
    in the `Settings.xml` service file and possibly those overridden in the application
    manifest
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The preceding parameters must be passed in the `ComputeStatistics` constructor
    when a `ComputeStatistics` instance is created by `IHost` through dependency injection.
    We will return to the `IHost` definition in the next subsection. For now, let''s
    concentrate on the `ComputeStatistics` constructor and its fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'All the constructor parameters are stored in private fields so that they can
    be used when `ExecuteAsync` is called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Before entering its loop, the `ComputeStatistics` service prepares some structures
    and parameters. It declares that the queue isn''t empty, meaning it can start
    dequeuing messages. Then, it extracts `MessageMaxDelaySeconds` from the service
    settings and turns it into an integer. The value of this parameter was left empty
    in the `Settings.xml` file. Now, it''s time to override it and define its actual
    value in `ApplicationManifest.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '`ServiceManifestImport` imports the service manifest in the application and
    overrides some configuration. Its version number must be changed every time its
    content and/or the service definition is changed and the application is redeployed
    in Azure because version number changes tell the Service Fabric runtime what to
    change in the cluster. Version numbers also appear in other configuration settings.
    They must be changed every time the entities they refer to change.'
  prefs: []
  type: TYPE_NORMAL
- en: '`MessageMaxDelaySeconds` is passed to the instance of the idempotency filter,
    along with a name for the dictionary of the already received messages, and with
    the instance of the `IReliableStateManager` service. Finally, the main distributed
    dictionary that''s used to store running totals is created.'
  prefs: []
  type: TYPE_NORMAL
- en: 'After this, the service enters its loop and finishes when `stoppingToken` is
    signaled, that is, when the Service Fabric runtime signals that the service is
    going to be stopped:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The inner loop runs until the queue becomes empty and then exits and waits 100
    milliseconds before verifying whether new messages have been enqueued.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the code for the inner loop, which is enclosed in a transaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the service is trying to dequeue a message. If the queue is empty, it
    sets `queueEmpty` to `true` to exit the loop; otherwise, it passes the message
    through the idempotency filter. If the message survives this step, it uses it
    to update the running total of the location referenced in the message. However,
    correct operation of the distributed dictionary requires that the old counter
    is replaced with a new counter each time an entry is updated. Accordingly, the
    old counter is copied into a new `RunningTotal` object. This new object can be
    updated with the new data if we call the `Update` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, the transaction is committed, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'When the `Update` method returns a complete computation result, that is, when
    `total != null`, the following method is called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The `SendTotal` method sends the total to a service that publicly exposes all
    the statistics through an HTTP endpoint. After reading *Chapter 14*, *Applying
    Service-Oriented Architectures with .NET Core*, which is dedicated to the Web
    API, you may want to implement a similar service with a stateless ASP.NET Core
    microservice connected to a database. The stateless ASP.NET Core service template
    automatically creates an ASP.NET Core-based HTTP endpoint for you.
  prefs: []
  type: TYPE_NORMAL
- en: However, since this service must receive data from the `SendTotal` method, it
    also needs remote-based endpoints. Therefore, we must create them, just as we
    did for the `LogStore` microservice, and concatenate the remote-based endpoint
    array with the pre-existing array containing the HTTP endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the microservice's host
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now we have everything in place to define the microservice''s `RunAsync` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Here, the service queue is created, and the service settings are saved in `configurationPackage`.
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, we can create the `IHost` service, as we explained in the *Using
    generic hosts* subsection of *Chapter 5*, *Applying a Microservice Architecture
    to Your Enterprise Application*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '`ConfigureServices` defines all singleton instances that are needed by `IHostedService`
    implementations, so they are injected into the constructor of all the implementations
    that reference their types. Then, `AddHostedService` declares the unique `IHostedService`
    of the microservice. Once the `IHost` is built, we run it until the `RunAsync`
    cancellation token is signaled. When the cancellation token is signaled, the request
    to shut down is passed to all `IHostedService` implementations.'
  prefs: []
  type: TYPE_NORMAL
- en: Communicating with the service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since we haven't implemented the whole purchase logic yet, we will implement
    a stateless microservice that sends random data to the `LogStore` service. Right-click
    on the `PurchaseLogging` project in the **Solution Explorer** and select **Add**
    | **Service Fabric Service**. Then, select the .NET Core stateless template and
    name the new microservice project `FakeSource`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s add a reference to the `Interaction` project. Before moving on
    to the service code, we need to update the replica count of the newly created
    service in `ApplicationManifest.xml` as well as in all the other environment-specific
    parameter overrides (the cloud, one local cluster node, five local cluster nodes):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This fake service needs no listeners and its `RunAsync` method is straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'In each loop, a random message is created and sent to the counting microservices.
    Then, the thread sleeps for a second and starts a new loop. The code that sends
    the created messages is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Here, a key in the 0-9,999 interval is computed from the location string. We
    used `GetHashCode` since we are sure that all involved services use the same .NET
    Core version and accordingly we are sure they use the same `GetHashCode` implementation
    that computes the hash in exactly the same way. However, in general, it is better
    to provide a library with a standard hash code implementation.
  prefs: []
  type: TYPE_NORMAL
- en: This integer is passed to the `ServicePartitionKey` constructor. Then, a service
    proxy is created, and the URI of the service to call and the partition key are
    passed. The proxy uses this data to ask the naming service for a physical URI
    for a primary instance for the given partition value.
  prefs: []
  type: TYPE_NORMAL
- en: '`ServiceProxy.Create` also accepts a third optional argument that specifies
    whether messages that are sent by the proxy can also be routed to secondary replicas.
    The default is that messages are routed just to primary instances. If the message
    target returns `false`, meaning that it''s not ready (remember that `LogPurchase`
    returns `false` when the `LogStore` message queue hasn''t been created yet), the
    same transmission is attempted after 100 milliseconds.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Sending messages to a remoting target is quite easy. However, other communication
    listeners require that the sender interacts manually with the naming service to
    get a physical service URI. This can be done with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Moreover, in the case of generic communication protocols, we must manually handle
    failures and retries with a library such as Polly (see the *Resilient task execution*
    subsection of *Chapter 5*, *Applying a Microservice Architecture to Your Enterprise
    Application*, for more information).
  prefs: []
  type: TYPE_NORMAL
- en: Testing the application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To test the application, you need to start Visual Studio with administrator
    permissions. Therefore, close Visual studio, then right-click on the Visual Studio
    icon and select the option to launch it as an administrator. Once you are again
    in Visual Studio, load the `PurchaseLogging` solution, and place a breakpoint
    in the `ComputeStatistics.cs` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Each time the breakpoint is hit, look at the content of `newCounter` to verify
    how the running totals of all the locations change. Before launching the application
    in debug mode, ensure the local cluster is running with five nodes. If you change
    from one to five nodes, the local cluster menu grays out until the operation is
    completed, so wait until the menu normalizes.
  prefs: []
  type: TYPE_NORMAL
- en: Once you launch the application and the application is built, a console appears
    and you start receiving notifications of the operation completed in Visual Studio.
    The application takes some minutes to load on all nodes; after that, your breakpoint
    should start being hit.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we described how to define a Service Fabric solution in Visual
    Studio, and how to set up and configure a Service Fabric cluster in Azure.
  prefs: []
  type: TYPE_NORMAL
- en: We described Service Fabric building blocks, reliable services, the various
    types of reliable services, and their roles within a Service Fabric application.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we put these concepts into practice by implementing a Service Fabric
    application. Here, we provided more practical details on the architecture of each
    reliable service and how to organize and code their communications.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter describes another famous microservices orchestrator, Kubernetes,
    and its implementation in the Azure Cloud.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is a reliable service?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can you list the different types of reliable services and their roles in a Service
    Fabric application?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is `ConfigureServices`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What kinds of port must be declared during the definition of an Azure Service
    Fabric cluster?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why are partitions of reliable stateful services needed?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can we declare that a remoting communication must be addressed by secondary
    replicas? What about other types of communication?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The official documentation for Azure Service Fabric can be found here: [https://docs.microsoft.com/en-US/azure/service-fabric/](https://docs.microsoft.com/en-US/azure/service-fabric/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The official documentation for Azure Service Fabric''s reliable services can
    be found here: [https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-reliable-services-introduction](https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-reliable-services-introduction).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'More information about the Actor model can be found here: [https://www.researchgate.NET/publication/234816174_Actors_A_conceptual_foundation_for_concurrent_object-oriented_programming](https://www.researchgate.NET/publication/234816174_Actors_A_conceptual_foundation_for_concurrent_obj).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The official documentation for Actor models that can be implemented in Azure
    Service Fabric can be found here: [https://docs.microsoft.com/en-US/azure/service-fabric/service-fabric-reliable-actors-introduction](https://docs.microsoft.com/en-US/azure/service-fabric/service-fabric-reliable-actors-introduction).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Microsoft has also implemented an advanced Actor model that is independent
    of Service Fabric. This is known as the Orleans framework. More information about
    Orleans can be found at the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Orleans – Virtual Actors**: [https://www.microsoft.com/en-us/research/project/orleans-virtual-actors/?from=https%3A%2F%2Fresearch.microsoft.com%2Fen-us%2Fprojects%2Forleans%2F](https://www.microsoft.com/en-us/research/project/orleans-virtual-actors/?from=https%3A%2F%2Fresearch).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Orleans** **Documentation**: [https://dotnet.github.io/orleans/docs/index.html](https://dotnet.github.io/orleans/docs/index.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
