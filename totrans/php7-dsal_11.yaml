- en: Solving Problems with Advanced Techniques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have explored different data structures and algorithms so far in this book.
    We are yet to explore some of the most exciting areas of algorithms. There are
    many efficient ways of doing things in computer programming. We will focus on
    some of the key advanced techniques and concepts in this chapter. These topics
    are so important that a separate book could be written about them. However, we
    will keep our focus on the very basic understanding of these advanced topics.
    When we say advanced topics, we are referring to memoization, dynamic programming,
    greedy algorithm, backtracking, puzzle solving, machine learning, and so on. Let's
    learn some new and exciting topics in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Memoization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Memoization is an optimization technique where we the store results of previous
    expensive operations and use them without repeating the operation. It helps us
    speed up the solution significantly. When we have problems where we can have repetitive
    sub problems, we can easily apply this technique to store those results and use
    them later on without repeating the steps. Since PHP has a great support for associative
    arrays and dynamic array properties, we can cache the results without any problems.
    One thing we have to remember is that though we are saving time by caching the
    results, we will require more memory to store these results in the cache. So,
    we have to make the trade-off between space and memory. Now, let''s revisit [Chapter
    5](text00118.html) , *Applying Recursive Algorithms - Recursion* , for our recursive
    example of generating Fibonacci numbers. We will just modify that function with
    a counter to know how many times the function is called and the running time of
    the function to get the thirtieth Fibonacci number. Here is the code for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This will have the following output in the command line. Note that timing and
    results may vary from one system to the other or from one version of PHP to the
    other. It completely depends on the where the program is running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The first number 1346269 is the thirtieth Fibonacci number, and the next line
    shows that the `fibonacci` function was called 2692537 times during the generation
    of the thirtieth number. The whole process took 0.5 seconds (we are using the
    `microtime` function of PHP). If we were generating the fiftieth Fibonacci number,
    the function call count would be more than 40 billion times. That is one big number.
    However, we know from our Fibonacci formula that when we are calculating *n* .
    We are doing it through *n* -1 and *n* -2; those are already calculated in the
    previous steps. So, we are repeating the steps, and hence, it is costing us time
    and efficiency. Now, let''s store the Fibonacci results in an indexed array, and
    we will check whether the Fibonacci number we are looking for is already calculated
    or not. If it is calculated, we will use it; otherwise, we will calculate that
    and store the result. Here is the modified code for generating Fibonacci numbers
    using the same recursive process, but with help of memorization:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see from the preceding code, we have introduced a new global variable
    called `$fibCache` , which will store the calculated Fibonacci numbers. We also
    check whether the number we are looking for is already in the array or not. We
    do not calculate the Fibonacci if the number is already stored in our cache array.
    If we run this code now, we will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's examine the result. The thirtieth Fibonacci number is the same as
    we had the last time. However, look at the function call count. It is just 31
    instead of 2.7 million calls. Now, let's look at the time. We have taken only
    0.00005299 seconds, which is 10,000 times faster than the non-memoized version.
  prefs: []
  type: TYPE_NORMAL
- en: With a simple example, we can see that we can optimize our solutions by utilizing
    memoization where it is applicable. One thing we have to remember is that memoization
    will work better where we have repeating sub problems or where we have to consider
    the previous calculation to compute the current or future calculation. Although
    memoization will take extra space to store the partially computed data, utilization
    of memoization can increase performance by a big margin
  prefs: []
  type: TYPE_NORMAL
- en: Pattern matching algorithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Pattern matching is one of the most common tasks we perform on a day-to-day
    basis. PHP has built-in support for regular expression, and mostly, we rely on
    the regular expression and built-in string functions to solve our regular needs
    for such problems. PHP has a readymade function named `strops` , which returns
    the position of the first occurrence of the string in a text. Since it only returns
    the position of the first occurrence, we can try to write a function that will
    return all possible positions. We will explore the brute-force approach first,
    where we will check each of the character for the actual string with each one
    of the pattern string. Here is the function that will do the job for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The approach is very straightforward. We start from position 0 of the actual
    string and keep on going until the `$N-$M` position, where `$M` is the length
    of the pattern we are looking for. We do not need to search the full string even
    at the worst case where there is no match for the pattern. Now, let''s call the
    function with some arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This will produce following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: If we look at our `$txt` string, we can find that there are tree occurrences
    of our pattern `AABA.` The first one is at the beginning, second one is at the
    center, and third one is close to the end of the string. The algorithm we have
    written will take `O((N - M) * M)` complexity, where N is the length of the text
    and M is the length of the pattern we are searching for. If we want, we can improve
    the efficiency of such matching using a popular algorithm known as **Knuth-Morris-Pratt**
    (**KMP** ) string-matching algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing Knuth-Morris-Pratt algorithm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Knuth-Morris-Pratt (KMP) string-matching algorithm is very similar to the naive
    algorithm we just implemented. The basic difference is that the KMP algorithm
    uses information from the partial matches and takes a decision to stop matching
    on any mismatch. It can also precompute the locations where the pattern can exist
    so that we can reduce the number of repeating comparison or false checks. The
    KMP algorithm pre-computes a table that helps during the search operation and
    increases efficiency. While implementing KMP algorithm, we need to computer the
    **Longest Proper Prefix Suffix** (**LPS** ). Let''s check the function to generate
    the LPS part:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'For our pattern from the previous example AABA, the LPS will be `[0,1,0,1]`
    ; now, let''s write the KMP implementation for our string/pattern search problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code is the implementation of the KMP algorithm. Now, let''s
    run the following example with our implemented algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This will produce the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The complexity of the KMP algorithm is `O(N + M)` , which is much better than
    regular pattern matching. Here, `O (M)` is for computing LPS and `O (N)` for KMP
    algorithm itself.
  prefs: []
  type: TYPE_NORMAL
- en: There are many detailed descriptions of the KMP algorithm that can be found
    online.
  prefs: []
  type: TYPE_NORMAL
- en: Greedy algorithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Though the name is greedy algorithms, actually, it is a programming technique
    that focuses on finding out the best possible solution at the given moment. This
    means that greedy algorithm makes a locally optimal choice in the hope that it
    will lead to the globally optimal solution. One thing we have to remember is that
    not all greedy approaches will take us to globally optimal solutions. However,
    still, greedy algorithm is applied in many problem-solving areas. One of the most
    popular uses of greedy algorithm is in Huffman encoding, which is used to encode
    a big text and compress the string by converting them into different codes. We
    will explore the concept and implementation of Huffman coding in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing Huffman coding algorithm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Huffman coding** is a compression technique used to reduce the number of
    bits required to send or store a message or string. It is based on the idea that
    frequently appearing characters will have shorter bit representation, and less
    frequent characters will have longer bit representation. If we consider the Huffman
    coding as a tree structure, the less frequent characters or items will be at the
    top part of the tree and more frequent items will be at the bottom of the tree
    or in the leaf. Huffman encoding relies a lot on the priority queue. Huffman encoding
    can be computed by first creating a tree of nodes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Process to create a tree of nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: We have to create a leaf node for each symbol and add it to the priority queue.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'While there is more than one node in the queue, do the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 1\. Remove the node of highest priority (lowest probability/frequency) twice
    to get two nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Create a new internal node with these two nodes as children and with probability/frequency
    equal to the sum of the two nodes' probabilities/frequencies.
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Add the new node to the queue.
  prefs: []
  type: TYPE_NORMAL
- en: The remaining node is the root node, and the tree is complete.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, we have to traverse the constructed binary tree from root to leaves assigning
    and accumulating a "0" for one branch and a "1" for the other at each node. The
    accumulated zeros and ones at each leaf constitute a Huffman encoding for those
    symbols and weights. Here is an implementation of Huffman encoding algorithm using
    the SPL priority queue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are building a min heap for each of the symbols and using their weight
    to set the priority. Once the heap is constructed, we extract two nodes one after
    another and combining their data and priority to add them back to the heap. This
    continues unless only one node exists, which is the root node. Now, let''s run
    the following code to generate the Huffman code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are using `str_split` to break the string into an array and then using
    array count values to convert it into an associative array where the character
    will be the key and its number of appearance in the string will be the value.
    The preceding code will produce the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'There are many other practical usages of greedy algorithms. We will solve a
    job-scheduling problem with greedy algorithms. Let''s consider an example of a
    team of agile software developers who are working in a two-week iteration or sprint.
    They have some user stories to complete with some deadlines (by date) for the
    tasks and velocity (size of the story) attached to the story. The target for the
    team is to gain maximum velocity for the sprint within the given deadline. Let''s
    consider the following tasks with deadline and velocity:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Index** | 1 | 2 | 3 | 4 | 5 | 6 |'
  prefs: []
  type: TYPE_TB
- en: '| **Story** | S1 | S2 | S3 | S4 | S5 | S6 |'
  prefs: []
  type: TYPE_TB
- en: '| **Deadline** | 2 | 1 | 2 | 1 | 3 | 4 |'
  prefs: []
  type: TYPE_TB
- en: '| **Velocity** | 95 | 32 | 47 | 42 | 28 | 64 |'
  prefs: []
  type: TYPE_TB
- en: 'As we can see from the preceding table, we have six user stories, and they
    have four different deadlines from **1** to **4** . We have to finish the user
    story **S2** or **S4** for slot 1 since the deadline for the task is 1\. The same
    goes for story **S1** and **S3,** and they have to be finished on or before slot
    **2** . However, since we have **S3** and the velocity of **S3** is bigger than
    **S2** and **S4, S3** will be chosen for slot 1 by the greedy approach. Let''s
    write the greedy code for our velocity calculation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are getting the list of jobs (user story ID, deadline, and velocity)
    that we will use to find the maximum velocity and their respective user story
    ID. First, we sort the jobs array with custom user sort function `usort` and sort
    the array in the descending order based on their velocity. After that, we calculate
    the maximum number of slots available from the deadline column. We are then initializing
    the slot array to -1 to keep a flag of used slots. The next code block is to traverse
    through each of the user stories and find a proper slot for the user story. If
    the available timeslots are filled, we don''t continue further. Now, let''s run
    this code using the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This will produce the following output in command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Greedy algorithms can be helpful in solving locally optimized problems such
    as job scheduling, network traffic control, graph algorithm, among other things.
    However, to get a globally optimized solution, we need to focus on another aspect
    of algorithms, which is known as dynamic programming.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding dynamic programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dynamic programming is a way of solving complex problems by dividing them into
    smaller sub problems and finding solution for those sub problems. We accumulate
    the solutions of sub problems to find the global solution. The good part of dynamic
    programming is that we reduce the recalculation of sub problems by storing their
    results. Dynamic programming is a very well-known method for optimization. The
    use of dynamic algorithm can be found everywhere in the programming world. Dynamic
    programming can solve problems such as coin changing, finding the longest common
    subsequence, finding the longest increasing sequences, sequencing DNA strings,
    and so on. The core difference between the greedy algorithm and dynamic programming
    is that dynamic programming will always prefer a globally optimized solution.
  prefs: []
  type: TYPE_NORMAL
- en: We can solve a problem with dynamic programming if the problem has either optimal
    substructure or overlapping sub problems. Optimal substructure means that the
    optimization for the actual problem can be solved using a combination of optimal
    solution of its sub problems. In other words, if a problem is optimized for n,
    it will be optimized for any size less than n or more than n. The overlapping
    sub problems indicates that smaller sub problems will be solved over and over
    again as they are overlapping with each other. Fibonacci series is a great example
    for overlapping sub problems. So, having basic recursion here will not help at
    all. Dynamic programming solves each subproblem exactly once and does not attempt
    to resolve any further. It is achieved either via a top-down approach or a bottom-up
    approach.
  prefs: []
  type: TYPE_NORMAL
- en: In a top-down approach, we start with a bigger problem and recursively solve
    the smaller sub problems. However, we have to use the memoization technique to
    store the subproblem results so that we do not have to recalculate that subproblem
    in future. In the bottom-up approach, we solve the smallest subproblem first and
    then move to the other smaller sub problems. Usually, subproblem results are stored
    in a tabular format using a multidimensional array for bottom-up approach.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will explore some examples from the dynamic programming world. Some
    might sound very familiar from our day-to-day programming problems. We will get
    started with the famous knapsack problem.
  prefs: []
  type: TYPE_NORMAL
- en: 0 - 1 knapsack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A knapsack is a bag with straps, usually carried by soldiers to help them take
    their necessary items or valuables during their journey. Each item has a value
    and definite weight attached to it. So, the soldier has to pick the most valuable
    items within their maximum weight limit as they cannot put everything in their
    bag. The word 0/1 means that either we can take it or leave it. We cannot take
    an item partially. This is known as the famous 0-1 knapsack problem. We will take
    the bottom-up approach for solving the 0-1 knapsack problem. Here is the pseudocode
    for the solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, if we have five items, `[1,2,3,4,5]` , and they have the weight
    of 10,20,30,40,50, respectively, a maximum allowed weight of 10 will produce the
    following table using the bottom-up approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00091.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As we can see, we build the up the table bottom up where we start with one
    item and one weight and increase it to our desired weight and maximize the value
    count by choosing the best possible items. At the end, the last cell in the bottom-right
    corner is the one with the expected result for the 0-1 knapsack problem. Here
    is the implementation and code to run the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This will show 100 on the command line, which actually matches our expected
    result from the preceding table. The complexity of this algorithm is O (*n* **W*
    ), where n is the number of items and W is the target weight.
  prefs: []
  type: TYPE_NORMAL
- en: Finding the longest common subsequence-LCS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another very popular algorithm to solve using dynamic programming is finding
    the longest common subsequence, or LCS, between two strings. The process is very
    similar to the knapsack solution where we had a two-dimensional table and we started
    with one weight to move to our target weight. Here, we will start with the first
    character of the first string and move across the whole string for the second
    string to match the characters. We will continue this until all the characters
    of the first string are matched with individual characters of the second string.
    So, when we find a match, we consider the top-left corner cell or diagonally left
    cell of the matched cell. Let''s consider the following two tables to understand
    how the matching occurs:'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;  &#124;  &#124; A &#124; B &#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;  &#124; 0 &#124; 0 &#124; 0 &#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124; C &#124; 0 &#124; 0 &#124; 0 &#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124; B &#124; 0 &#124; 0 &#124; 1 &#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;  &#124;  &#124; B &#124; D &#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124;  &#124; 0 &#124; 0 &#124; 0 &#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124; B &#124; 0 &#124; 1 &#124; 1 &#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124; D &#124; 0 &#124; 1 &#124; 2 &#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'On the left table, we have two strings AB and CB. When B matches B in the table,
    the value of the matched cell will be the value of its diagonal cell plus one.
    That is why the dark background cell of the first table has a value of 1 since
    the diagonally left cell has a value of 0\. For the same reason, the table on
    the right has right lowest cell of value 2 as the diagonal cell has a value of
    1\. Here is the pseudocode for finding the LCS length:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the implementation of our pseudocode to find the LCS length:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s run the `LCS` function with two strings to see whether we can find
    the longest common subsequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This will produce the output `LCS Length:5` in the command line. This seems
    to be correct as both the strings have GGTAB as the common subsequence.
  prefs: []
  type: TYPE_NORMAL
- en: DNA sequencing using dynamic programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have just seen how to find the longest common subsequence. Using the same
    principle, we can implement DNA or protein sequencing, which can be very helpful
    for us in solving bioinformatic problems. For alignment purpose, we will use the
    most popular algorithm known as the Needleman-Wunsch algorithm. It is similar
    to our LCS algorithm, but the scoring system is different. Here, we score a match,
    mismatch, and gap in a different scoring system. There are two parts of the algorithm:
    one to calculate the matrix with possible sequence and the second part is tracking
    back the actual sequence with the best possible one. The Needleman-Wunsch algorithm
    provides the best global alignment solution for any given sequence. Since the
    algorithm itself is little bigger along with the scoring system explanation, which
    we can find in many websites or books, we want to keep our focus on the implementation
    part of the algorithm. We will divide the problem into two parts. First, we will
    generate the computational table using dynamic programming, and then, we will
    track it backwards to generate the actual sequence alignment. For our implementation,
    we will use 1 for matching, and -1 for gap penalty and mismatch score. Here is
    the first part of our implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have created a two-dimensional array of size M,N, where M is the size
    of string #1 and N is the size of string #2\. We initialized the first row and
    column of the grid to a negative value in the decreasing order. We multiplied
    the index with a gap penalty to achieve this behavior. Here, our constant SP indicates
    the matching score point, MS for mismatch score, GP for gap penalty, and GC indicates
    the Gap Character, which we will use during sequence printing. At the end of dynamic
    programming, the matrix will be generated. Let''s consider the following two strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, our table will look like this after running the Needleman algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '|  |  | G | A | A | T | T | C | A | G | T | T | A |'
  prefs: []
  type: TYPE_TB
- en: '|  | 0 | -1 | -2 | -3 | -4 | -5 | -6 | -7 | -8 | -9 | -10 | -11 |'
  prefs: []
  type: TYPE_TB
- en: '| G | -1 | 1 | 0 | -1 | -2 | -3 | -4 | -5 | -6 | -7 | -8 | -9 |'
  prefs: []
  type: TYPE_TB
- en: '| G | -2 | 0 | 0 | -1 | -2 | -3 | -4 | -5 | -4 | -5 | -6 | -7 |'
  prefs: []
  type: TYPE_TB
- en: '| A | -3 | -1 | 1 | 1 | 0 | -1 | -2 | -3 | -4 | -5 | -6 | -5 |'
  prefs: []
  type: TYPE_TB
- en: '| T | -4 | -2 | 0 | 0 | 2 | 1 | 0 | -1 | -2 | -3 | -4 | -5 |'
  prefs: []
  type: TYPE_TB
- en: '| C | -5 | -3 | -1 | -1 | 1 | 1 | 2 | 1 | 0 | -1 | -2 | -3 |'
  prefs: []
  type: TYPE_TB
- en: '| G | -6 | -4 | -2 | -2 | 0 | 0 | 1 | 1 | 2 | 1 | 0 | -1 |'
  prefs: []
  type: TYPE_TB
- en: '| A | -7 | -5 | -3 | -1 | -1 | -1 | 0 | 2 | 1 | 1 | 0 | 1 |'
  prefs: []
  type: TYPE_TB
- en: 'Now, using this scoring table, we can find out the actual sequence. Here, we
    will start from the bottom-right cell in the table and consider the top cell,
    left cell, and the diagonal cell values. If the max value among the three cells
    is the top one, then the top string requires an insertion of gap character (-).
    If the maximum value is the diagonal one, then there is a better chance of matching.
    So, we can compare the two characters of the two strings, and if they match, then
    we can put a bar or pipe character to show the alignment. Here is what the sequencing
    function will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we are starting from back and slowly moving to the front, we are using
    array push to keep the alignment in order. Then, we are printing the array by
    reversing it. The complexity of the algorithm is O (M * N). Here is the output
    if we call `NWSquencing` for our two strings `$X` and `$Y` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Backtracking to solve puzzle problem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Backtracking is a recursive algorithm strategy where we backtrack when a result
    is not found and continue search for solution in other possible ways. Backtracking
    is a popular way to solve many famous problems, especially chess, Sudoku, crosswords,
    and so on. Since recursion is the key component of backtracking, we need to ensure
    that our problem can be divided into sub problems, and we apply recursion into
    those sub problems. In this section, we will solve one of the most popular games,
    Sudoku, using backtracking.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Sudoku, we have a partially filled box with nice boxes of size 3X3\. The
    rule of the game is to place a number 1 to 9 in each cell, where the same number
    cannot exist in the same row or column. So, in the 9X9 cell, each number 1 to
    9 will be present only once for each row and each column:'
  prefs: []
  type: TYPE_NORMAL
- en: '|  |  | 7 |  | 3 |  | 8 |  |  |'
  prefs: []
  type: TYPE_TB
- en: '|  |  |  | 2 |  | 5 |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| 4 |  |  | 9 |  | 6 |  |  | 1 |'
  prefs: []
  type: TYPE_TB
- en: '|  | 4 | 3 |  |  |  | 2 | 1 |  |'
  prefs: []
  type: TYPE_TB
- en: '| 1 |  |  |  |  |  |  |  | 5 |'
  prefs: []
  type: TYPE_TB
- en: '|  | 5 | 8 |  |  |  | 6 | 7 |  |'
  prefs: []
  type: TYPE_TB
- en: '| 5 |  |  | 1 |  | 8 |  |  | 9 |'
  prefs: []
  type: TYPE_TB
- en: '|  |  |  | 5 |  | 3 |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '|  |  | 2 |  | 9 |  | 5 |  |  |'
  prefs: []
  type: TYPE_TB
- en: 'For example, in the preceding Sudoku board, the first column has 4, 1, 5 and
    the first row have 7, 3, 8\. As a result, we cannot use any of these six numbers
    in the first empty cell on the top left. So, the possible numbers can be 2, 6,
    and 9\. We do not know which one of these numbers will satisfy the solution. We
    can pick two and put in the first cell and then start looking for values for the
    remaining empty cells. This will continue until all the cells are filled up or
    still there is a way to place a number in the empty cell without violating the
    game principle. If no solution is possible, we will backtrack and come back to
    2 again, replace it with the next possible option 6, and run the same recursive
    way of finding numbers for other empty cells. This continues until the board is
    solved. Let''s write some recursive code to solve the Sudoku:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we can see all the auxiliary functions required to implement the `Sudoku`
    function. First, we defined the max size of the grid along with the unassigned
    cell indicator, which is 0 in this case. The first function we have is to find
    any unassigned location in the 9 X 9 grid, starting from the top-left corner cell,
    and search the empty cell row wise. Then, we have three functions to check whether
    a number is used in a particular row or column or a 3 X 3 box. If the number is
    not used in the row, column, or in the box, we can use it for a possible value
    in the cell, and that is why, we are returning true in the `isSafe` function check.
    If it is used in any one of these places, the function will return false. Now,
    we are ready to implement the recursive function for solving the Sudoku:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The `SolveSudoku` function is self-explanatory. Here, we visited one cell,
    and if the cell is empty, put a temporary number, any number from 1 to 9, in the
    cell. Then, we checked whether the number is redundant in the row or in the column
    or in the 3 X 3 matrix. If it does not conflict, we keep the number in the cell
    and move to the next empty cell. We do this via recursion so that if required,
    we can track back and change the value in the case of a conflict. This continues
    until a solution is found. We also have added a `printGrid` function to print
    a given grid in the command line. Let''s now run the code with the sample Sudoku
    matrix we have used in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We have used a two-dimensional array to represent our Sudoku matrix. If we
    run the code, it will produce following output in the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, if we present that in a nice Sudoku matrix, it will look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '| 2 | 9 | 7 | 4 | 3 | 1 | 8 | 5 | 6 |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | 6 | 1 | 2 | 8 | 5 | 4 | 9 | 7 |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | 8 | 5 | 9 | 7 | 6 | 3 | 2 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 7 | 4 | 3 | 6 | 5 | 9 | 2 | 1 | 8 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 2 | 6 | 8 | 4 | 7 | 9 | 3 | 5 |'
  prefs: []
  type: TYPE_TB
- en: '| 9 | 5 | 8 | 3 | 1 | 2 | 6 | 7 | 4 |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | 3 | 4 | 1 | 2 | 8 | 7 | 6 | 9 |'
  prefs: []
  type: TYPE_TB
- en: '| 8 | 7 | 9 | 5 | 6 | 3 | 1 | 4 | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | 1 | 2 | 7 | 9 | 4 | 5 | 8 | 3 |'
  prefs: []
  type: TYPE_TB
- en: Backtracking can be very useful to find solutions to find path or solve game
    problems. There are many references available online for backtracking, which can
    be very useful to us.
  prefs: []
  type: TYPE_NORMAL
- en: Collaborative filtering recommendation system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Recommendation systems are used everywhere in the Internet today. From e-commerce
    sites to restaurants, hotels, tickets, events, and so on. are recommended to us
    everywhere. Have we ever asked ourselves how do they know what will be the best
    for us? How do they come up with this calculation of showing the items we might
    like? The answer is most sites use collaborative filtering (CF) to recommend something.
    Collaborative filtering is a process of making automatic prediction (filtering)
    about the interests of a user by analyzing other user's choices or preferences
    (collaborative). We will build a simple recommendation system using the Pearson
    correlation method where a similarity score between two people is calculated on
    the range of -1 to +1\. If the similarity score is +1, then it means two people
    are a perfect match. If the similarity score is 0, then it means no there is no
    similarity between them, and if the score is -1, then they are negatively similar.
    Usually, the scores are mostly fractional.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Pearson correlation is calculated using the following formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Image00092.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, *x* denotes preferences from person one, y represents preferences from
    person two, and N represents the number of items in the preferences, which are
    common between *x* and *y* . Let''s now implement a sample review system for restaurants
    in Dhaka. There are reviewers who have reviewed some restaurants. Some of them
    are common, some are not. Our job will be to find a recommendation for person
    *X* based on the reviews of others. Our reviews look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, based on the structure, we can write our Pearson correlation calculation
    between two reviewers. Here is the implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have just implemented the equation we have shown for the Pearson correlation
    calculator. Now, we will write the recommendation function based on Pearson scoring:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding function, we calculated the similarity score between each
    reviewer and weighted their reviews with each other. Based on the top score, we
    showed the recommendation for the reviewer. Let''s run the following code to get
    some recommendations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This will produce the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: We can use the Pearson correlation scoring system to recommend items or show
    users who to follow to get better reviews. There are many other ways to get the
    collaborative filtering to work, but that is beyond the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Using bloom filters and sparse matrix
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sparse matrix can be used as highly efficient data structure. A sparse matrix
    has more 0 values compared to actual values. For example, a 100 X 100 matrix may
    have 10,000 cells. Now, out of this 10,000 cells, only 100 have values; rest are
    0\. Other than the 100 values, remaining cells are occupied with the default value
    of 0, and they are taking same byte size to store the value 0 to indicate the
    empty cell. It is a huge waste of space, and we can reduce it using the sparse
    matrix. We can use different techniques to store the values to the sparse matrix
    in a separate matrix that will be very lean and will not take any unnecessary
    spaces. We can also use a linked list to represent the sparse matrix. Here is
    an example of the sparse matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124; 0 &#124; 0 &#124; 0 &#124; 0 &#124; 0 &#124; 1 &#124; 0 &#124; 0 &#124;
    0 &#124; 0 &#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124; 1 &#124; 0 &#124; 0 &#124; 0 &#124; 0 &#124; 0 &#124; 0 &#124; 0 &#124;
    0 &#124; 0 &#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124; 0 &#124; 0 &#124; 0 &#124; 0 &#124; 2 &#124; 0 &#124; 0 &#124; 0 &#124;
    0 &#124; 0 &#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124; 0 &#124; 0 &#124; 2 &#124; 0 &#124; 0 &#124; 0 &#124; 0 &#124; 0 &#124;
    0 &#124; 0 &#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124; 0 &#124; 0 &#124; 0 &#124; 0 &#124; 0 &#124; 0 &#124; 1 &#124; 0 &#124;
    0 &#124; 0 &#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124; 0 &#124; 0 &#124; 0 &#124; 0 &#124; 0 &#124; 0 &#124; 0 &#124; 2 &#124;
    0 &#124; 0 &#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124; 0 &#124; 0 &#124; 0 &#124; 0 &#124; 0 &#124; 0 &#124; 1 &#124; 0 &#124;
    0 &#124; 0 &#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124; 1 &#124; 0 &#124; 0 &#124; 0 &#124; 0 &#124; 0 &#124; 0 &#124; 0 &#124;
    0 &#124; 0 &#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124; **Row** &#124; **Col** &#124; **Value** &#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124; 0 &#124; 5 &#124; 1 &#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124; 1 &#124; 0 &#124; 1 &#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124; 2 &#124; 4 &#124; 2 &#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124; 3 &#124; 2 &#124; 2 &#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124; 4 &#124; 6 &#124; 1 &#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124; 5 &#124; 7 &#124; 2 &#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124; 6 &#124; 6 &#124; 1 &#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '&#124; 7 &#124; 1 &#124; 1 &#124;'
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since PHP array is dynamic in nature, the best approach for sparse matrix in
    PHP will be using only the indexes that have values; others are not used at all.
    When we are using the cell, we can do a check to see whether the cell has any
    value; else, the default value of 0 is used, just as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'This will produce the following output in the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: When we have a large dataset, doing lookup in the dataset can be very time consuming
    and costly. Let's assume we have a dataset of 10 million phone numbers and we
    want to search for a particular phone number. This can be easily done using a
    database query. However, what if it is 1 billion phone numbers? Will it still
    be faster to find from a database? Such a big database can create slow-performing
    lookups. In order to solve this problem, an efficient approach can be using bloom
    filters.
  prefs: []
  type: TYPE_NORMAL
- en: 'A bloom filter is a space-efficient, probabilistic data structure that determines
    whether a particular item is part of a set or not. It returns two values: "possibly
    in set" and "definitely not in set". If an item does not belong to a set, bloom
    filter returns false. However, if it returns true, the item may or may not be
    in the set. The reason for this is described here.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In general, a bloom filter is a bit array of size m, where all initial values
    are 0\. There is k different `hash` function, which converts an item to a hashed
    integer value, which is mapped in the bit array. This hash value can be between
    0 to m, as m is the max size of our bit array. The `hash` functions are similar
    to `md5` , `sha1` , `crc32` , and so on, but they are very fast and efficient.
    Usually, in bloom filter fnv, murmur, Siphash, and so on, `hash` functions are
    used. Let''s take an example of 16 (16+1 cells) bit bloom filter with the initial
    value of 0:'
  prefs: []
  type: TYPE_NORMAL
- en: '| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: 'Let''s assume that we have two hash functions, `k1` and `k2` , to convert our
    items to integer values between 0 to 16\. Let our first item to store in the bloom
    filter be "PHP". Then, our `hash` function will return following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Two `hash` functions have returned two different values. We can now put 1 in
    the bit array to mark that. The bit array will now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '| 0 | 0 | 0 | 0 | 0 | 1 | 0 | 0 | 0 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: 'Let''s now add another item in the list, for example, "algorithm". Suppose
    our `hash` functions will return the following values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we can see that 5 is already marked by another item, we do not have to
    mark it again. Now, the bit array will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '| 0 | 0 | 1 | 0 | 0 | 1 | 0 | 0 | 0 | 1 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: 'For example, now, we want to check an item called "error", which is hashed
    to the following values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: As we can see that our `hash` functions `k1` and `k2` returned a hashed value
    for string "error," which is not present in the array. So, this is definitely
    an error, and we expect to have such errors if our `hash` functions are only few
    in number. The more `hash` functions we have, lesser the errors we will have,
    as different `hash` functions will return different values. There is a relationship
    between error rate, number of `hash` functions, and the size of bloom filter.
    For example, a bloom filter for 5000 items and 0.0001 error rate will require
    roughly 14 `hash` functions and approximately 96000 bits. We can get such numbers
    from online bloomfilter calculators such as [https://krisives.github.io/bloom-calculator/](https://krisives.github.io/bloom-calculator/)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen many advanced algorithms and techniques that can be used to solve
    different types of problems in this chapter. There are many good resources available
    to study these topics. Dynamic programming is such an important topic and can
    be covered in several chapters or have a separate book for itself. We tried to
    explain few of the topics, but there are more to explore. You also learned about
    sparse matrix and bloom filter, which can be used for efficient data storage for
    big data blocks. We can use these data structure concepts whenever we need them.
    Now, as we are reaching the end of the book, we will wrap up our discussion with
    some available libraries, functions, and references for data structure and algorithm
    in PHP 7.
  prefs: []
  type: TYPE_NORMAL
