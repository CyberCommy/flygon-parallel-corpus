- en: Introduction to Kernel Development
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Linux started as a hobby project in 1991 for a Finnish student, Linus Torvalds.
    The project has gradually grown and still does, with roughly 1000 contributors
    around the world. Nowadays, Linux is a must, in embedded systems as well as on
    servers. A kernel is a center part of an operating system, and its development
    is not so obvious.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'Linux offers many advantages over other operating systems:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: It is free of charge
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Well documented with a large community
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Portable across different platforms
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provides access to the source code
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lots of free open source software
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This book tries to be as generic as possible. There is a special topic, device
    tree, which is not a full x86 feature yet. That topic will then be dedicated to
    ARM processors, and all those fully supporting the device tree. Why those architectures?
    Because they are most used on the desktop and servers (for x86) and on embedded
    systems (ARM).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter deals among others with:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Development environment setup
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting, configure, and build kernel sources
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kernel source code organization
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to kernel coding style
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Environment setup
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before one starts any development, you need to set an environment up. The environment
    dedicated to Linux development is quite simple, at least, on Debian based systems:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'There are parts of codes in this book that are compatible with ARM **system
    on chip** (**SoC** ). One should install `gcc-arm` as well:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: I'm running Ubuntu 16.04, on an ASUS RoG, with an Intel core i7 (8 physical
    cores), 16 GB of RAM, 256 GB of SSD, and 1 TB of magnetic hard drive. My favorite
    editor is Vim, but you are free to use the one you are most comfortable with.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Getting the sources
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the early kernel days (until 2003), odd–even versioning styles were used;
    where odd numbers were stable, even numbers were unstable. When the 2.6 version
    was released, the versioning scheme switched to X.Y.Z, where:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '`X` : This was the actual kernel''s version, also called major, it incremented
    when there were backwards-incompatible API changes'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Y` : This was the minor revision, it incremented after adding a functionality
    in a backwards-compatible manner'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Z` : This is also called PATCH, represented the version relative to bug fixes'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is called semantic versioning, and has been used until the 2.6.39 version;
    when Linus Torvalds decided to bump the version to 3.0, which also meant the end
    of semantic versioning in 2011, and then, an X.Y scheme was adopted.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: 'When it came to the 3.20 version, Linus argued that he could no longer increase
    Y, and decided to switch to an arbitrary versioning scheme, incrementing X whenever
    Y got large enough that he ran out of fingers and toes to count it. This is the
    reason why the version has moved from 3.20 to 4.0 directly. Have a look at: [https://plus.google.com/+LinusTorvalds/posts/jmtzzLiiejc](https://plus.google.com/+LinusTorvalds/posts/jmtzzLiiejc)
    .'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: Now the kernel uses an arbitrary X.Y versioning scheme, which has nothing to
    do with semantic versioning.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Source organization
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the needs of this book, you must use Linus Torvald's Github repository.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`arch/` : The Linux kernel is a fast growing project that supports more and
    more architectures. That being said, the kernel wants to be as generic as possible.
    Architecture specific code is separated from the rest, and falls in this directory.
    This directory contains processor-specific subdirectories such as `alpha/` , `arm/`
    , `mips/` , `blackfin/` , and so on.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`block/` : This directory contains codes for block storage devices, actually
    the scheduling algorithm.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`crypto/` : This directory contains the cryptographic API and the encryption
    algorithms code.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Documentation/` : This should be your favorite directory. It contains the
    descriptions of APIs used for different kernel frameworks and subsystems. You
    should look here prior to asking any questions on forums.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`drivers/` : This is the heaviest directory, continuously growing as device
    drivers get merged. It contains every device driver organized in various subdirectories.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fs/` : This directory contains the implementation of different filesystems
    that the kernel actually supports, such as NTFS, FAT, ETX{2,3,4}, sysfs, procfs,
    NFS, and so on.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`include/` : This contains kernel header files.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`init/` : This directory contains the initialization and start up code.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ipc/` : This contains implementation of the **Inter-Process Communication**
    (**IPC** ) mechanisms, such as message queues, semaphores, and shared memory.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kernel/` : This directory contains architecture-independent portions of the
    base kernel.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lib/` : Library routines and some helper functions live here. They are: generic
    **kernel object** (**kobject** ) handlers and **Cyclic Redundancy Code** (**CRC**
    ) computation functions, and so on.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mm/` : This contains memory management code.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`net/` : This contains networking (whatever network type it is) protocols code.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scripts/` : This contains scripts and tools used during the kernel development.
    There are other useful tools here.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`security/` : This directory contains the security framework code.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sound/` : Audio subsystems codes fall here.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`usr/:` This currently contains the initramfs implementation.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The kernel must remain portable. Any architecture-specific code should be located
    in the `arch` directory. Of course, the kernel code related to user space API
    does not change (system calls, `/proc` , `/sys` ), as it would break the existing
    programs.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: The book deals with version 4.1 of the kernel. Therefore, any changes made until
    v4.11 version are covered too, at least this can be said about the frameworks
    and subsystems.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: Kernel configuration
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Linux kernel is a makefile-based project, with 1000s of options and drivers.
    To configure your kernel, either use `make menuconfig` for an ncurse-based interface
    or `make xconfig` for an X-based interface. Once chosen, options will be stored
    in a `.config` file, at the root of the source tree.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: 'In most of the cases, there will be no need to start a configuration from scratch.
    There are default and useful configuration files available in each `arch` directory,
    which you can use as a start point:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'For ARM-based CPUs, these configs files are located in `arch/arm/configs/`
    , and for an i.MX6 processor, the default file config is `arch/arm/configs/imx_v6_v7_defconfig`
    . Similarly for x86 processors, we find the files in `arch/x86/configs/` , with
    only two default configuration files, `i386_defconfig` and `x86_64_defconfig`
    , for 32 and 64 bits versions respectively. It is quite straightforward for an
    x86 system:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Given an i.MX6-based board, one can start with `ARCH=arm make imx_v6_v7_defconfig`
    , and then `ARCH=arm make menuconfig` . With the former command, you will store
    the default option in `.config` file, and with the latter, you can update add/remove
    options, depending on the needs.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: 'One may run into a Qt4 error with `xconfig` . In such a case, one should just
    use the following command:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Build your kernel
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building the kernel requires you to specify the architecture for which it is
    built for, as well as the compiler. That says, it is not necessary for a native
    build.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'After that, one will see something like:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'From the kernel build, the result will be a single binary image, located in
    `arch/arm/boot/` . Modules are built with the following command:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You can install them using the following command:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `modules_install` target expects an environment variable, `INSTALL_MOD_PATH`
    , which specifies where you should install the modules. If not set, the modules
    will be installed at `/lib/modules/$(KERNELRELEASE)/kernel/` . This is discussed
    in [Chapter 2,](text00034.html) *Device Driver Basis* .
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: 'i.MX6 processors support device trees, which are files you use to describe
    the hardware (this is discussed in detail in [Chapter 6](text00162.html) , *The
    Concept of Device Tree* ). However, to compile every `ARCH` device tree, you can
    run the following command:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'However, the `dtbs` option is not available on all platforms that support device
    tree. To build a standalone DTB, you should use:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Kernel habits
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The kernel code tries to follow standard rules through its evolution. In this
    chapter, we will just be introduced to them. They are all discussed in a dedicated
    chapter, starting from [Chapter 3](http://post) , *Kernel Facilities and Helper
    Functions,* we get a better overview of the kernel development process and tips,
    till [Chapter 13](http://post1) , *Linux Device Model* .
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: Coding style
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before going deep in this section, you should always refer to the kernel coding
    style manual, at `Documentation/CodingStyle` in the kernel source tree. This coding
    style is a set of rules you should respect, at least if you need to get its patches
    accepted by kernel developers. Some of these rules concern indentation, program
    flow, naming convention, and so on.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: 'Most popular ones are:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: 'Always use tab indentation of 8 characters, and the line should be 80 columns
    long. If the indentation prevents you from writing your function, it is because
    this one has too many nesting levels. One can size the tabs and verify the line
    size using `scripts/cleanfile` script in from the kernel source:'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You can also indent the code correctly using the `indent` tool:'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Every function/variable that is not exported should be declared as static.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No spaces should be added around (inside) parenthesized expressions. *s = size
    of (struct file)* ; is accepted, whereas *s = size of( struct file )* ; is not.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `typdefs` is forbidden.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Always use `/* this */` comment style, not `// this`
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'BAD: `// do not use this please`'
  id: totrans-86
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: 'GOOD: `/* Kernel developers like this */`'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You should capitalise macros, but functional macros can be in lowercase.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A comment should not replace a code that is not illegible. Prefer rewriting
    the code rather than adding a comment.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kernel structures allocation/initialization
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The kernel always offers two possible allocation mechanisms for its data structures
    and facilities.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of these structures are:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: Workqueue
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: List
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Waitqueue
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tasklet
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Timer
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Completion
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: mutex
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: spinlock
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Dynamical initializers are all macros it means they are always capitalized:
    `INIT_LIST_HEAD()` , `DECLARE_WAIT_QUEUE_HEAD()` , `DECLARE_TASKLET( )` , and
    so on.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: 'That being said, these are all discussed in [Chapter 3](text00023.html) , *Kernel
    Facilities and Helper Functions* . Therefore, data structures that represent framework
    devices are always allocated dynamically, each of which having its own allocation
    and deallocation API. These framework device types are:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Network
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Input device
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Char device
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IIO device
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Framebuffer
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regulator
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PWM device
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RTC
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scope of the static objects is visible in the whole driver, and by every device
    this driver manages. Dynamically allocated objects are visible only by the device
    that is actually using a given instance of the module.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Classes, objects, and OOP
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The kernel implements OOP by means of a device and a class. Kernel subsystems
    are abstracted by means of classes. There are almost as many subsystems as there
    are directories under `/sys/class/` *.* The `struct kobject` structure is the
    center piece of this implementation. It even brings in a reference counter, so
    that the kernel may know how many users actually use the object. Every object
    has a parent, and has an entry in `sysfs` (if mounted).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Every device that falls into a given subsystem has a pointer to an **operations**
    (**ops** ) structure, which exposes operations that can be executed on this device.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter explained in a very short and simple manner how you should download
    the Linux source and process a first build. It also deals with some common concepts.
    That said, this chapter is quite brief and may not be enough, but never mind,
    it is just an introduction. That is why the next chapter gets more into the details
    of the kernel building process, how to actually compile a driver, either externally
    or as a part of the kernel, as well as some basics that one should learn before
    starting the long journey that kernel development represents.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 本章以非常简短和简单的方式解释了如何下载Linux源代码并进行第一次构建。它还涉及一些常见概念。也就是说，这一章非常简短，可能不够，但没关系，这只是一个介绍。这就是为什么下一章会更深入地介绍内核构建过程，如何实际编译驱动程序，无论是作为外部模块还是作为内核的一部分，以及在开始内核开发这段漫长旅程之前应该学习的一些基础知识。
