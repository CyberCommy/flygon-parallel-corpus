- en: Spring Boot Microservice Performance Tuning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned about **Java Virtual Machine** (**JVM**).
    Starting with the internals of JVM and Java's class-loading mechanism, we learned
    how memory management is performed in Java. The last section of the chapter focused
    on garbage collection and JVM tuning. The chapter was full of pretty important
    details for application performance optimization.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will move toward solving performance problems. The approach
    is to develop microservices. Microservices are having a boom in the software development
    industry right now. There is a lot of buzz around microservices and related keywords.
    This approach basically works at an application-architecture level to tune the
    application''s performance. It describes how we can improve application performance
    by setting up the architecture in a different manner. We will cover the following
    topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Spring Boot configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Metrics with the Spring Boot Actuator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Health checks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microservices using Spring Boot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microservices with Spring Cloud
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring microservice configuration example
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring microservices with Spring Boot admin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Boot performance tuning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Boot configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will focus on making Spring Boot work for us. Before jumping
    on to Spring Boot configuration, we will understand what Spring Boot is, why we
    should use it, and what Spring Boot brings to the table. We will move quickly
    to the how to do it part of it.
  prefs: []
  type: TYPE_NORMAL
- en: What is Spring Boot?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is necessary for software development processes to be faster, more accurate,
    and more robust. Software teams are asked to develop quick prototypes for showcasing
    the application''s features to prospective clients. The same applies to production-grade
    applications. The following are a few areas where software architects focus on
    to improve the effectiveness of development teams:'
  prefs: []
  type: TYPE_NORMAL
- en: Use the right set of tools, which includes frameworks, IDEs, and build tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reduce code clutter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reduce the amount of time spent writing repetitive code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spend the majority of the time implementing business features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's think for a moment. Why are we discussing this? The reason is that this
    is the foundation for Spring Boot. These thoughts are the founding stones for
    the creation of any framework or tool that helps teams to improve their productivity.
    Spring Boot is found with exactly the same reason—to improve productivity!
  prefs: []
  type: TYPE_NORMAL
- en: With Spring Boot, it becomes easy to create production-grade applications that
    are powered by the Spring Framework. It also makes it easy to create production-ready
    services with minimal challenges. Spring Boot helps new and existing users get
    to their productive tasks quickly by taking an opinionated view of the Spring
    Framework. Spring Boot is a tool that facilitates creating a standalone Java application,
    which can be run using the `java -jar` command, or a web application, which can
    be deployed to web servers. The Spring Boot setup is bundled with command-line
    tools to run Spring programs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The major goals of Spring Boot are:'
  prefs: []
  type: TYPE_NORMAL
- en: To gain an extremely fast experience to get started with Spring-powered projects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Broad accessibility
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Major support from out-of-the-box configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flexibility to deviate from Spring default as the need may arise
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That it does not generate any code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That it does not require XML configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Along with previously listed primary features, Spring Boot also provides support
    for non-functional features, listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Support for versioning and configuration for widely known and used frameworks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support for application security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support for monitoring application health check parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support for monitoring of performance metrics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support for externalized configurations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Though Spring Boot provides defaults for the primary and non-functional features,
    it is flexible enough to allow developers to use the frameworks, servers, and
    tools of their choice.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Initializr
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring Boot applications can be kickstarted in multiple ways. One of the ways
    is to use the Eclipse-based Spring Tools Suite IDE ([https://spring.io/tools/sts](https://spring.io/tools/sts)).
    Another way is to use [https://start.spring.io](https://start.spring.io), also
    known as Spring Initializr. First things first, Spring Initializr is not Spring
    Boot or an equivalent. Spring Initializr is a tool that has simple web UI support
    to configure the Spring Boot application. It can be considered a tool for a quick-start
    generation of Spring projects. It provides APIs that can be extended for customization
    in order to generate the projects.
  prefs: []
  type: TYPE_NORMAL
- en: The Spring Initializr tool provides a configuration structure to define a list
    of dependencies, supported Java and Spring Boot versions, and supported dependency
    versioning.
  prefs: []
  type: TYPE_NORMAL
- en: 'Basically, Spring Initializr creates an initial Spring project based on the
    configuration provided and allows the developer to download the project in a ZIP
    file. Here are the steps to be followed:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to [https://start.spring.io/](https://start.spring.io/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose the dependency management tool from Maven or Gradle.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose the JVM-based programming language from Java, Kotlin, and Groovy.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose the Spring Boot version to be used.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Provide the Group artifact by inputting the group name as `com.packt.springhighperformance`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Input Artifact, which is the artifact ID for the Maven project. This will become
    the name of the project WAR or JAR file to be deployed or executed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose a packaging type from Jar and War.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the Switch to the full version link. This will open up a list of starter
    projects to choose from. The starter project will be explained in detail in the
    following section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once we have chosen the starters or dependencies, click on the Generate Project
    button. This will download the ZIP file containing the initial project configuration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following is the Spring Initializr screen with a few configurations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a6a45a4d-e090-4376-ba21-fc3485818310.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once done, a folder structure similar to what is shown in the following screenshot
    will be generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7ea85fbb-0031-4bc6-9bcd-3f572426642f.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Spring Initializr also supports the command-line interface to create the Spring
    project configuration. The following command can be used to generate a project
    configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As mentioned earlier, Spring Initializr supports integration with IDE. It integrates
    well with Eclipse/STS, IntelliJ ultimate edition, and NetBeans with NB the SpringBoot
    plugin.
  prefs: []
  type: TYPE_NORMAL
- en: Starters with Maven
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the preceding section, we looked at the Spring Initializr tool. It is time
    to quickly look at the starters or dependencies supported by Spring Boot.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency management becomes challenging as the project grows in complexity.
    It is recommended not to manage the dependencies manually for a complex project.
    Spring Boot starters fix a similar problem. Spring Boot starters is a set of dependency
    descriptors that can be included in Spring-powered applications using starter
    POMs. It eliminates the need to look for sample code and copy/paste lots of dependency
    descriptors for Spring and related libraries. As an example, if we want to develop
    an application using Spring and JPA, we can include the `spring-boot-data-jpa-starter`
    dependency in the project. `spring-boot-data-jpa-starter` is one of the starters.
    The starters follow uniform naming patterns, such as `spring-boot-starter-*`,
    where `*` denotes the type of application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a list of some Spring Boot application starters:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `spring-boot-starter` | Core starter provides auto-configuration and logging
    support. |'
  prefs: []
  type: TYPE_TB
- en: '| `spring-boot-starter-activemq` | JMS messaging starter using Apache ActiveMQ.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `spring-boot-starter-amqp` | Spring AMQP and Rabbit MQ starter. |'
  prefs: []
  type: TYPE_TB
- en: '| `spring-boot-starter-aop` | Spring AOP and AspectJ starter. |'
  prefs: []
  type: TYPE_TB
- en: '| `spring-boot-starter-artemis` | JMS messaging starter using Apache Artemis.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `spring-boot-starter-batch` | Spring Batch starter. |'
  prefs: []
  type: TYPE_TB
- en: '| `spring-boot-starter-cache` | Spring Framework''s caching support. |'
  prefs: []
  type: TYPE_TB
- en: '| `spring-boot-starter-cloud-connectors` | Starter providing support for simplified
    connections with cloud services using Spring Cloud Connectors in cloud platforms
    such as Cloud Foundry and Heroku. |'
  prefs: []
  type: TYPE_TB
- en: '| `spring-boot-starter-data-elasticsearch` | Starter with support for elasticsearch
    and analytics engine, and Spring Data Elasticsearch. |'
  prefs: []
  type: TYPE_TB
- en: '| `spring-boot-starter-data-jpa` | Spring Data JPA with Hibernate. |'
  prefs: []
  type: TYPE_TB
- en: '| `spring-boot-starter-data-ldap` | Spring Data LDAP. |'
  prefs: []
  type: TYPE_TB
- en: '| `spring-boot-starter-data-mongodb` | MongoDB document-oriented database and
    Spring Data MongoDB. |'
  prefs: []
  type: TYPE_TB
- en: '| `spring-boot-starter-data-redis` | Redis key-value data store with Spring
    Data Redis and the Lettuce client. |'
  prefs: []
  type: TYPE_TB
- en: '| `spring-boot-starter-data-rest` | Starter providing support for exposing
    Spring Data repositories over REST using Spring Data REST. |'
  prefs: []
  type: TYPE_TB
- en: '| `spring-boot-starter-data-solr` | Apache Solr search platform with Spring
    Data Solr. |'
  prefs: []
  type: TYPE_TB
- en: '| `spring-boot-starter-freemarker` | Starter supports building MVC web applications
    using the FreeMarker views. |'
  prefs: []
  type: TYPE_TB
- en: '| `spring-boot-starter-groovy-templates` | Starter supporting building MVC
    web applications using the Groovy templates views. |'
  prefs: []
  type: TYPE_TB
- en: '| `spring-boot-starter-integration` | Spring Integration. |'
  prefs: []
  type: TYPE_TB
- en: '| `spring-boot-starter-jdbc` | JDBC with the Tomcat JDBC connection pool. |'
  prefs: []
  type: TYPE_TB
- en: '| `spring-boot-starter-jersey` | Starter supporting building RESTful web applications
    using JAX-RS and Jersey. It is an alternative to `spring-boot-starter-web starter`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `spring-boot-starter-json` | Starter supporting JSON manipulation. |'
  prefs: []
  type: TYPE_TB
- en: '| `spring-boot-starter-mail` | Starter supporting the use of Java Mail and
    Spring Framework’s email-sending support. |'
  prefs: []
  type: TYPE_TB
- en: '| `spring-boot-starter-quartz` | Starter for using Spring Boot Quartz. |'
  prefs: []
  type: TYPE_TB
- en: '| `spring-boot-starter-security` | Spring Security starter. |'
  prefs: []
  type: TYPE_TB
- en: '| `spring-boot-starter-test` | Support for Spring Boot applications with libraries
    including JUnit, Hamcrest, and Mockito. |'
  prefs: []
  type: TYPE_TB
- en: '| `spring-boot-starter-thymeleaf` | Supports building MVC web applications
    using the Thymeleaf views. |'
  prefs: []
  type: TYPE_TB
- en: '| `spring-boot-starter-validation` | Starter supporting Java Bean Validation
    with Hibernate Validator. |'
  prefs: []
  type: TYPE_TB
- en: '| `spring-boot-starter-web` | Supports building web, including RESTful, applications
    using Spring MVC. It uses Tomcat as the default embedded container. |'
  prefs: []
  type: TYPE_TB
- en: '| `spring-boot-starter-web-services` | Supports use of Spring Web Services.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `spring-boot-starter-websocket` | Supports building WebSocket applications
    using Spring Framework''s WebSocket support. |'
  prefs: []
  type: TYPE_TB
- en: '`spring-boot-starter-actuator` is a production starter for Spring Boot''s Actuator
    tool, which provides support for production-ready features, such as application
    monitoring, health checks, logging, and beans.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following list includes a few of the technical starters for Spring Boot:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `spring-boot-starter-jetty `                        | Support for Jetty as
    the embedded servlet container. This is an alternative to `spring-boot-starter-tomcat`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `spring-boot-starter-log4j2`                          | Starter supporting
    Log4j 2 for logging. This is an alternative to `spring-boot-starter-logging`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `spring-boot-starter-logging` | This is the default logging starter using
    logback. |'
  prefs: []
  type: TYPE_TB
- en: '| `spring-boot-starter-tomcat` | This is the default servlet container starter
    used for `spring-boot-starter-web`. It uses Tomcat as the embedded server. |'
  prefs: []
  type: TYPE_TB
- en: '| `spring-boot-starter-undertow` | This is an alternative to `spring-boot-starter-tomcat
    starter`. It uses Undertow as the embedded server. |'
  prefs: []
  type: TYPE_TB
- en: '| `spring-boot-starter-cache` | Spring Framework''s caching support. |'
  prefs: []
  type: TYPE_TB
- en: Creating your first Spring Boot application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will look at the prerequisites for developing a Spring Boot
    application. We will develop a small Spring Boot application to understand the
    configuration required for a Spring Boot application and the importance of each
    configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the list of prerequisites for working with Spring Boot:'
  prefs: []
  type: TYPE_NORMAL
- en: Java 8 or 9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring 5.0.4 or later
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Spring Boot supports:'
  prefs: []
  type: TYPE_NORMAL
- en: Maven 3.2+ and Gradle 4 for dependency management and explicit builds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tomcat 8.5, Jetty 9.4, and Undertow 1.4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spring Boot applications can be deployed to any servlet 3.0+ compatible servlet
    container.
  prefs: []
  type: TYPE_NORMAL
- en: The first step in developing a Spring Boot application is to install Spring
    Boot. It is extremely easy to set up. It can be set up in the same way as other
    standard Java libraries. To install Spring Boot, we need to include the appropriate
    `spring-boot-*.jar` library files in the classpath. Any IDE or text editor can
    be used as Spring Boot does not require any specialized tools.
  prefs: []
  type: TYPE_NORMAL
- en: Though we can copy the required Spring Boot JAR files in the application classpath,
    the recommendation is to use a build tool, such as Maven or Gradle, for dependency
    management.
  prefs: []
  type: TYPE_NORMAL
- en: The Maven `groupId` used by the Spring Boot dependencies is `org.springframework.boot`.
    For Spring Boot applications, the Maven POM file inherits the `spring-boot-starter-parent`
    project. Spring Boot defines starter projects and it is defined as a dependency
    in the Spring Boot application's dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s jump on to creating our first Spring Boot application by performing
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a kickstarter application using Spring Initializr.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose Maven as the build and dependency management tool.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose the appropriate Spring Boot version.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose the packaging type as War.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the sake of simplicity, we will not include a JPA starter in the application.
    We will include a web module only to demonstrate the one request-response flow.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Download and import the project into STS or Eclipse.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In STS, you can run the application as a Spring Boot application whereas in
    Eclipse, you can choose to run the application as a Java Application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s walk through the code snippets now. The following is the sample Maven
    POM file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: One of the notable configurations in the preceding configuration file is the
    parent dependency. As mentioned earlier, all Spring Boot applications use `spring-boot-starter-parent`
    as the parent dependency in the `pom.xml` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The parent POM helps manage the following for child projects and modules:'
  prefs: []
  type: TYPE_NORMAL
- en: Java version
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Version management for included dependencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The default configuration for the plugin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Spring Boot parent starter defines Spring Boot dependencies as the parent
    POM. So, it inherits dependency-management features from Spring Boot dependencies.
    It defines the default Java version to be 1.6, but at a project level, we can
    change it to `1.8`, as shown in the preceding code sample.
  prefs: []
  type: TYPE_NORMAL
- en: 'Along with the default POM file, Spring Boot also creates a Java class that
    works as an application starter. The following is the sample Java code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '`SpringApplication` is a class responsible for bootstrapping the Spring Boot
    application.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring Boot application developers are used to annotate the main application
    class with `@Configuration`, `@EnableAutoConfiguration`, and `@ComponentScan`
    annotations. Here is a brief description for each of the annotations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@Configuration`: This is a Spring annotation and not specific to Spring Boot
    applications. It indicates that the class is the source for bean definitions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@EnableAutoConfiguration`: This one is a Spring Boot-specific annotation.
    The annotation enables the application to add beans from the classpath definitions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@ComponentScan`**:** This annotation tells the Spring application to search
    for components, configurations, and services in the search path provided.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is the definition for the `@SpringBootApplication` annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Looking at the previous code, it is clear that `@SpringBootApplication` works
    as a convenient annotation to define the Spring Boot application instead of declaring
    three annotations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following block shows the log''s output when the Spring Boot application
    is started:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, we have the kickstarter Spring Boot application ready, but we
    don''t have any URLs to be rendered. So, when you access `http://localhost:8080`,
    a page similar to the one shown in the following screenshot is displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3443f7f2-8712-47e8-9cb8-98bcd0b86b72.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s define the Spring controller and default route, and add text content
    to it. The following is the code snippet for the controller class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example code, we have defined two routes using the `@RequestMapping`
    annotation. The following is a list of annotations used in the preceding code
    block with brief descriptions:'
  prefs: []
  type: TYPE_NORMAL
- en: The `@Controller` annotation indicates that the class is a controller class
    and may contain request mappings.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `@RequestMapping` annotation defines an application URL that the users can
    navigate to in the browser.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `@ResponseBody` annotation indicates that the method return value should
    be rendered on the page as the HTML content. The value parameter can take the
    URL path to be navigated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following screenshot shows the page displayed or rendered when we hit `http://localhost:8080`
    in the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bc305322-30ca-4029-b5c7-2b02130fdb37.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We have also defined parameterized request mapping with the value as `/welcome`.
    The value of the request parameter will be reflected in the message on the page
    when we navigate to the URL in the browser. The following screenshot shows how
    the content is rendered:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3785fbe1-ea04-493b-aae8-f3f9f3383565.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can find the following log entries when the application with these requests
    mappings bootstraps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: At this point, our first Spring Boot application with example request mappings
    are in place. This section served as a step-by-step guide to Spring Boot application
    development. In the next section, we will look at more Spring Boot features.
  prefs: []
  type: TYPE_NORMAL
- en: Metrics with Spring Boot Actuator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we move any further, it is important to understand what a Spring Boot
    Actuator is. We will introduce the Spring Boot Actuator in the sections to follow.
    We will also look at the out-of-the-box capabilities provided by the Spring Boot
    Actuator. We will also go through examples to understand the configuration and
    other necessary details.
  prefs: []
  type: TYPE_NORMAL
- en: What is Spring Actuator?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Essentially, the Spring Boot Actuator can be considered a subproject of Spring
    Boot. It helps bring production-grade features in the application that we develop
    using Spring Boot out of the box. The Spring Boot Actuator needs to be configured
    before we can leverage the features exposed by it. The Spring Boot Actuator has
    been available since Spring Boot first release in April 2014\. The Spring Boot
    Actuator materializes different HTTP endpoints so the development team can perform
    the following tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Application monitoring
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analyzing application metrics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interacting with the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Version information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logger details
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bean details
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enabling Spring Boot Actuator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Apart from helping in bootstrapping application development, Spring Boot enables
    a number of features that can be used in the application. These additional features
    include, but are not limited to, monitoring and managing the application. Application
    management and monitoring can be done over HTTP endpoints or using JMX. Auditing,
    health checkups, and metrics can also be applied with a configuration in a Spring
    Boot application. These are the production-ready features provided by the `spring-boot-actuator`
    module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the definition of the Actuator from the Spring Boot reference documentation
    ([https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#production-ready](https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#production-ready)):'
  prefs: []
  type: TYPE_NORMAL
- en: An actuator is a manufacturing term that refers to a mechanical device for moving
    or controlling something. Actuators can generate a large amount of motion from
    a small change.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to leverage the features of the Spring Boot Actuator, the first step
    is to enable it. It is not enabled by default and we have to add the dependency
    to enable it. It is extremely easy to enable the Spring Boot Actuator in a Spring
    Boot application. We will need to add the `spring-boot-starter-actuator` dependency
    in the `pom.xml` file in case we are using Maven for dependency management in
    the application. The following is the snippet for Maven dependency for the Spring
    Boot Actuator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As mentioned before, the Spring Boot Actuator enables application monitoring
    by exposing or enabling endpoints to interact with. The module has a number of
    out-of-the-box endpoints. It also allows the developer to create their own custom
    endpoints. We can enable or disable each individual endpoint. This ensures that
    the endpoint is created in the application and the corresponding bean exists in
    the application's context.
  prefs: []
  type: TYPE_NORMAL
- en: The endpoint can be accessed remotely by exposing it over JMX or HTTP. Usually,
    applications expose the endpoints over HTTP. The endpoint URL is derived by mapping
    the endpoint ID along with the `/actuator` prefix.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a list of technology-agnostic endpoints:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **ID** | **Description** | **Enabled by default** |'
  prefs: []
  type: TYPE_TB
- en: '| `auditevents` | This endpoint exposes the audio event''s information. | Yes
    |'
  prefs: []
  type: TYPE_TB
- en: '| `beans` | This endpoints shows a complete list of the Spring `beans` available
    in the application. | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| `conditions` | This endpoint displays the `conditions` that are evaluated
    on configuration and auto-configuration classes. | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| `configprops` | This endpoint shows a list of properties marked with `@ConfigurationProperties`.
    | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| `env` | This endpoint displays the properties from Spring''s `ConfigurableEnvironment`.
    | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| `flyway` | The endpoint shows any `flyway` database migrations that might
    have been applied. | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| `health` | This endpoint shows the `health` information of the application.
    | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| `httptrace` | This endpoint shows the HTTP trace information. By default,
    it shows the last 100 HTTP request-response exchanges. | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| `info` | This endpoint exposes application information. | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| `loggers` | This endpoint shows the application `logger` configuration. |
    Yes |'
  prefs: []
  type: TYPE_TB
- en: '| `liquibase` | This endpoint displays any `liquibase` database migrations
    that might have been applied. | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| `metrics` | This endpoint displays `metrics` information for the application.
    | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| `mappings` | This endpoint displays a list of all the `@RequestMapping` paths.
    | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| `scheduledtasks` | This endpoint shows the scheduled tasks for the application.
    | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| `sessions` | This endpoint allows retrieval and deletion of user `sessions`
    from a Spring Session-backed session store. It is not available when using Spring
    Session’s support for reactive web applications. | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| `shutdown` | This endpoint allows the application to be `shutdown` gracefully.
    | No |'
  prefs: []
  type: TYPE_TB
- en: '| `threaddump` | This endpoint performs a `threaddump`. | Yes |'
  prefs: []
  type: TYPE_TB
- en: 'The following is a list of additional endpoints that are exposed if the application
    is a web application:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **ID** | **Description** | **Enabled by default** |'
  prefs: []
  type: TYPE_TB
- en: '| `heapdump` | This endpoint returns a compressed `hprof` heap dump file. |
    Yes |'
  prefs: []
  type: TYPE_TB
- en: '| `jolokia` | This endpoint exposes JMX beans over HTTP. | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| `logfile`                  | This endpoint shows the contents of the `logfile`
    if the `logging.file` or `logging.path` is set in the properties. It uses the
    HTTP range header to partly retrieve contents of the log file. | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| `prometheus` | This endpoint shows metrics in a format that can be scraped
    by a Prometheus server. | Yes |'
  prefs: []
  type: TYPE_TB
- en: Enabling endpoints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With the Spring Boot Actuator, all endpoints are enabled by default, except
    the `shutdown` endpoint. In order to enable or disable a particular endpoint,
    a relevant property should be added in the `application.properties` file. The
    following is the format for enabling the endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'As an example, the following property can be added to enable the `shutdown`
    endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The following log entries can be seen when we bootstrap an application with
    the default Actuator endpoints enabled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Looking at the log entries closely, we find that the following endpoints or
    URLs are exposed:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/actuator`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/actuator/health`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/actuator/info`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Why does the application have three endpoints exposed out of so many listed
    earlier? To answer this question, the Spring Boot Actuator exposes only three
    endpoints over HTTP. The rest of the endpoints, listed previously, are exposed
    over the JMX connection. The following is a list of endpoints and information
    about whether they are exposed over HTTP or JMX:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **ID** | **Exposed over JMX** | **Exposed over HTTP** |'
  prefs: []
  type: TYPE_TB
- en: '| `auditevents` | Yes | No |'
  prefs: []
  type: TYPE_TB
- en: '| `beans` | Yes | No |'
  prefs: []
  type: TYPE_TB
- en: '| `conditions` | Yes | No |'
  prefs: []
  type: TYPE_TB
- en: '| `configprops` | Yes | No |'
  prefs: []
  type: TYPE_TB
- en: '| `env` | Yes | No |'
  prefs: []
  type: TYPE_TB
- en: '| `flyway` | Yes | No |'
  prefs: []
  type: TYPE_TB
- en: '| `health` | Yes | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| `heapdump` | N/A | No |'
  prefs: []
  type: TYPE_TB
- en: '| `httptrace` | Yes | No |'
  prefs: []
  type: TYPE_TB
- en: '| `info` | Yes | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| `jolokia` | N/A | No |'
  prefs: []
  type: TYPE_TB
- en: '| `logfile` | N/A | No |'
  prefs: []
  type: TYPE_TB
- en: '| `loggers` | Yes | No |'
  prefs: []
  type: TYPE_TB
- en: '| `liquibase` | Yes | No |'
  prefs: []
  type: TYPE_TB
- en: '| `metrics` | Yes | No |'
  prefs: []
  type: TYPE_TB
- en: '| `mappings` | Yes | No |'
  prefs: []
  type: TYPE_TB
- en: '| `prometheus` | N/A | No |'
  prefs: []
  type: TYPE_TB
- en: '| `scheduledtasks` | Yes | No |'
  prefs: []
  type: TYPE_TB
- en: '| `sessions` | Yes | No |'
  prefs: []
  type: TYPE_TB
- en: '| `shutdown` | Yes | No |'
  prefs: []
  type: TYPE_TB
- en: '| `threaddump` | Yes | No |'
  prefs: []
  type: TYPE_TB
- en: Why does Spring Boot not expose all the endpoints over HTTP by default? The
    reason is that the endpoints may expose sensitive information. So, a careful consideration
    should be done in exposing them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following properties can be used to change or override the default exposure
    behavior of the endpoints:'
  prefs: []
  type: TYPE_NORMAL
- en: '`management.endpoints.jmx.exposure.exclude`: The endpoint IDs specified in
    a comma-separated list are excluded from default exposure over the JMX connection.
    By default, none of the default endpoints are excluded.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`management.endpoints.jmx.exposure.include`: The endpoint IDs specified in
    a comma-separated list are included along with the default exposure over the JMX
    connection. The property can be used to expose those endpoints that are not included
    in the default list of endpoints. The default value for the property is `*`,which
    indicates that all of the endpoints are exposed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`management.endpoints.web.exposure.exclude`: The endpoint IDs specified by
    a comma-separated list are excluded from being exposed over HTTP. Though no default
    value exists, only `info` and `health` endpoints are exposed. The rest of the
    endpoints are implicitly excluded for HTTP.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`management.endpoints.web.exposure.include`: The endpoint IDs specified in
    a comma-separated list are included along with the default exposure over HTTP.
    The property can be used to expose those endpoints that are not included in the
    default list of endpoints. The default value for the property is `info`, `health`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Health checks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the extremely critical aspects of ensuring the high performance of the
    application is to monitor the health of the application. A production-grade application
    is always under observation of a specialized monitoring and alerting software.
    Threshold values are configured for every parameter, whether it be average response
    time, disk utilization, or CPU utilization. Once the parameter value exceeds the
    specified threshold value, the monitoring software signals an alert via email
    or notifications. Development and operations teams take the necessary actions
    to ensure the application is back to its normal state.
  prefs: []
  type: TYPE_NORMAL
- en: For the Spring Boot application, we can collect health information by navigating
    to the `/actuator/health` URL. The `health` endpoint is enabled by default. For
    the application deployed in the production environment, health information gathered
    using the `health` endpoint can be sent to a monitoring software for alerting
    purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The information presented by the `health` endpoint depends on the `management.endpoint.health.show-details` property.
    The following is the list of supported values for the property:'
  prefs: []
  type: TYPE_NORMAL
- en: '`always`: It indicates that all the information should be shown to all users.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`never`: It indicates that the details should never be shown.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`when-authorized`: This indicates that the details are shown to users with
    authorized roles only. The authorized roles can be configured using the `management.endpoint.health.roles`
    property.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The default value for the `show-details` property is `never`. Also, the user
    can be considered authorized when it has one or more of the endpoint's authorized
    roles. By default, none of the roles are configured as authorized. So, all authenticated
    users are considered authorized users.
  prefs: []
  type: TYPE_NORMAL
- en: '`HealthIndicator` is one of the important interfaces that provides an indication
    of application health on different aspects, such as disk space, data source, or
    JMS. The `health` endpoint collects health information from all the `HealthIndicator`
    implementation beans defined in the application''s context. Spring Boot comes
    with an auto-configured set of health indicators. The framework is flexible enough
    to support custom health indicator implementations. The final health status of
    the application is derived by `HealthAggregator`. The health aggregator sorts
    statuses from all the health indicators as per the order of statuses that have
    been defined.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a list of auto-configured `HealthIndicators` by Spring Boot:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CassandraHealthIndicator`**:** Checks whether the Cassandra database is up'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DiskSpaceHealthIndicator`: Checks whether enough disk space is available'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DataSourceHealthIndicator`: Checks whether the connection with the data source
    can be obtained or not'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ElasticSearchHealthIndicator`: Checks whether the elasticsearch cluster is
    up'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`InfluxDbHealthIndicator`: Checks whether the Influx server is up and running'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`JmsHealthIndicator`: Checks whether the JMS broker is up and running'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MailHealthIndicator`: Checks whether the mail server is up and running'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MongoHealthIndicator`: Checks whether the Mongo database is up and running'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Neo4jHealthIndicator`: Checks whether the Neo4j server is up and running'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RabbitHealthIndicator`: Checks whether the Rabbit server is up and running'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RedisHealthIndicator`: Checks whether the Redis server is up and running'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SolrHealthIndicator`: Checks whether the Solr server is up and running'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These health indicators are auto-configured based on the appropriate Spring
    Boot starter configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the example disk space health check output when we navigate
    to the `http://localhost:8080/actuator/health` URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We can add additional customized health indicators to include the information
    we want to see. The customized health indicator will be displayed in the result
    of the `health` endpoint. It is super easy to create and register a custom health
    indicator.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of a custom health indicator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We have to create a Java class that extends from `AbstractHealthIndicator`.
    In the custom health indicator class, we have to implement the `doHealthCheck()`
    method. The method expects a `Health.Builder` object to be passed. If we find
    that the health parameters OK, then the `builder.up()` method should be called,
    otherwise the `builder.down()` method should be called.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the output rendered on the page when the `/actuator/health`
    URL is hit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The custom health indicator is not required to be registered. The `@Component`
    annotation is scanned and the bean is registered with the `ApplicationContext`.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have learned, in detail, about Spring Boot with examples. The following
    sections will focus on the use of Spring Boot with microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Microservices using Spring Boot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have a hefty amount of information about Spring Boot now from the previous
    sections. With the information that we have so far, we are now in a position to
    build microservices using Spring Boot. Before jumping into the implementation
    of our first microservice with Spring Boot, to proceed with implementing the first
    microservice, it is assumed that you know basic information about microservices,
    including the issues with monoliths, what microservices are, and the features
    microservices bring to the table.
  prefs: []
  type: TYPE_NORMAL
- en: First microservice with Spring Boot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are the details of the microservice that we are going to develop:'
  prefs: []
  type: TYPE_NORMAL
- en: We will implement an accounting service as a microservice.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The microservice will be REST-based. It is an architectural pattern for developing
    web services. It focuses on identifying each resource in the application with
    a unique URL.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will identify the Spring Boot starter project that we will need and generate
    the Maven `pom.xml` file accordingly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will implement an `Account` class with a few basic properties.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will implement `AccountRepository` with the find-by-name example method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will implement the controller class, which has a repository auto-wired. The
    controller exposes the endpoints.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will also implement a way to feed the test data into the database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start!
  prefs: []
  type: TYPE_NORMAL
- en: We will start implementation by generating the Spring Boot application using
    Spring Initializr. We have to decide on the Spring Boot starter projects to be
    used. We want to develop a JPA-based web application. For the purpose of storing
    `Account` data in a database, we can use either MySQL or H2\. Usually, H2 is a
    more convenient option as we don't need to set up anything. We will use MySQL
    for the examples in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the starter projects to be selected:'
  prefs: []
  type: TYPE_NORMAL
- en: Web
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JPA
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MySQL or H2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: REST repositories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can also add the Spring Boot Actuator for application monitoring purpose
    but is not mandatory for the example.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the `pom.xml` file that is generated by Spring Initializr:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Another piece of code that is generated by Spring Initializr is the Spring
    Boot application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: At this point, we should have our project imported in our IDE of preference.
  prefs: []
  type: TYPE_NORMAL
- en: People, get ready for the hands-on development now. We will start by creating
    the `Account` JPA entity class. We will annotate the `Account` class with `@Entity`
    and `@Table` annotations. The `@Table` annotation allows us to supply the desired
    table name. We have one more column, which is `accountName`. It stores and represents
    the name of the `Account`. Basically, the `Account` entity represents the account
    type in the real world. One other important attribute that we have added is `id`.
    `id` represents a unique, autogenerated numeric identifier. We can identify each
    account uniquely using the identifier. The `@GeneratedValue` annotation lets us
    supply the way `id` values will be generated in the database. Keeping it to `AUTO`
    defines that it depends on the database to automatically generate `id` values.
    The `@Column` annotation allows us to match the `accountName` attribute to the `ACCT_NAME`
    database field.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the code for the `Account` entity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Spring Data provides a convenient interface to perform common database operations.
    The interface is called `CrudRepository`. It supports basic `Create`, `Read`,
    `Update`, and `Delete` operations for a specific type. The interface is inherited
    by the `JpaRepository` interface, which is a JPA-specific definition of the `CrudRepository` interface.
    `JpaRepository` also inherits sorting and paging capabilities from the `PagingAndSortingRepository`
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this background, the next task for us is to build an interface to interact
    with the `accounts` database table. The following is the code for the `AccountsRepository`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In the `AccountsRepository` interface, we have defined a method that is intended
    to find the `Account` entries from the database based on the `accountName`. The
    `CrudRepository` interface is very powerful. It will generate the implementation
    for the `findByAccountName` method. It can generate the implementation for all
    such query methods that follow the convention, such as `findBy{model-attribute-name}`.
    It also returns the objects of the `Account` type.
  prefs: []
  type: TYPE_NORMAL
- en: Also, you might have noticed that the use of `@RepositoryRestResource` is provided
    by the Spring Data REST module. It briefly exposes the repository methods for
    data manipulation as REST endpoints without any further configuration or development.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we have the entity and repository in place. Next is the controller part
    of a web application. We have to create a controller class. The following is the
    code for the `AccountsController` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Three notable annotations from the `AccountsController` code are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@RestController`: This annotation is a combination of the `@Controller` and
    `@ResponseBody` annotations. If we used the `@RestController` annotation, we don''t
    need to define these two other annotations. The `@RestController` annotation indicates
    that the class should be treated as a controller and every endpoint method will
    respond with content as a response body.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@GetMapping`**:** This annotation is used to define a REST `GET` endpoint
    mapping.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@PathVariable`**:** This annotation is used to fetch the values supplied in
    the URL path itself.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two things are left. One is the database and other important properties, while
    the other one is a way to populate the initial data in the `accounts` table.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the `application.properties` file that manages the configuration
    part of the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: From the list of properties, the `spring.jpa.hibernate.ddl-auto` property determines
    the initial generation of the database based on the database configurations provided.
    It determines whether the Spring Boot application should create the database schema
    up on application startup. `none`, `validate`, `update`, `create`, and `create-drop`
    are the options available for the property.
  prefs: []
  type: TYPE_NORMAL
- en: 'While booting up the application, we may also receive the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We can use `useSSL=true` in the database connection URL to overcome this warning,
    as you can see in the properties in the preceding code example.
  prefs: []
  type: TYPE_NORMAL
- en: Loading sample data into the database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point in time, it is necessary to have some initial data in the `accounts`
    table in the database. It will help us test the account's microservice that we
    have developed. The Spring modules provide multiple ways to achieve this.
  prefs: []
  type: TYPE_NORMAL
- en: The JPA way of initial data loading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spring Data JPA provides a way to execute database manipulation commands on
    the application startup. As the schema will be generated in the database from
    the JPA entity configuration and `ddl-auto` property value, we have to take care
    to insert the account records in the `accounts` table only. The following are
    the steps to accomplish this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following property to the `application.properties` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `data.sql` file with `INSERT` queries in the `src/main/resources`
    folder of the project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: That's it! When we start the application, Spring will automatically insert the
    data into the `accounts` table in the database.
  prefs: []
  type: TYPE_NORMAL
- en: The ApplicationRunner way of initial data loading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can also accomplish this using the `ApplicationRunner` interface. This interface
    is responsible for executing the code defined in the `run` method on application
    startup.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the code for the `ApplicationRunner` interface''s implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We have auto-wired the repository so that we can access the `AccountsRepository`
    methods for inserting `accounts` records into the database.
  prefs: []
  type: TYPE_NORMAL
- en: Microservice client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have the microservice in place, we have to look at how to consume
    it. The plan is to create another web application using Spring Initializr and
    use the appropriate tools to consume the accounting microservice.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the POM file for the client application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding `pom.xml` file, we have imported Spring Cloud dependencies
    using the Maven dependency-management element. We have added the `openfeign` starter
    project as well. Feign is a client tool to consume web services and provides a
    REST client templating facility.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the code for the `main` class in our Spring Boot client application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We have defined the REST controller in the same Java file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the `application.properties` file that defines the microservices
    URL and defines the `server.port` for running the client application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Microservices with Spring Cloud
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring Cloud provides a declarative approach to building cloud-native web applications.
    Cloud-native is an application development paradigm to encourage adoption of value-driven
    development best practices. Spring Cloud is built on top of Spring Boot. Spring
    Cloud provides a way for all components in a distributed system to have easy access
    to all features.
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring Cloud provides:'
  prefs: []
  type: TYPE_NORMAL
- en: Git-managed versioning of centralized configuration data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pairing with Netflix Eureka and Ribbon for application services to discover
    each other dynamically
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pushing away load-balancing decisions from a dedicated proxy load balancer to
    client services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Externalized configurations is one of the major advantages of Spring Cloud.
    In the next section, we will develop an example to showcase the externalized configuration
    for the Spring Boot application.
  prefs: []
  type: TYPE_NORMAL
- en: Spring microservice configuration example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the externalized configuration to work, we need to set up a centralized
    configuration server. The configuration server will store and provide configuration
    data for the registered Spring Boot applications. In this section, we will develop
    a configuration server, and the accounting service that we developed earlier will
    serve as the configuration client.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the POM file for the Spring Boot config server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Two configurations should be noted from the preceding dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '`spring-cloud-dependencies`**:** It provides a set of dependencies necessary
    for Spring Cloud projects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spring-cloud-config-server`**:** This is the Spring Cloud starter project
    for Spring Boot'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is the `application.properties` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The `spring.cloud.config.server.git.uri` property points to a Git-based directory
    where the configurations are stored. The versioning is maintained by Git itself.
  prefs: []
  type: TYPE_NORMAL
- en: The `spring.profiles.active`denotes profiles to be used by applications. It
    is a common use case for development teams to have multiple environments in place.
    In order to have separate configurations for each environment, we can use this
    property.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `@EnableConfigServer` annotation is provided by the Spring Cloud starter
    project. It marks the class as the configuration server. The following is the
    code for the Spring Boot application `main` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Once this is done, the configuration server is ready to be run. In the Git
    repository, we have created an `accountingservice.properties` file with the following
    contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the application is started, we can navigate to `http://localhost:9000/accountingservice/default`.
    As we do not have profile-specific files for the `accountingservice` application
    in the configuration server, it picks up the default profile. The contents of
    the page are as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7edd193e-7ab4-4cc6-b503-8829d4ce7a94.png)'
  prefs: []
  type: TYPE_IMG
- en: As we can see, the `server.port` property value is rendered on the page.
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to build a client that utilizes the centralized configuration
    defined in the configuration server. We have to create a Spring Boot starter application
    with web dependency.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the POM file for the configuration server client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: As we can see in the preceding Maven file, we need to add the `spring-cloud-config-starter`
    project as the dependency. The project provides the necessary configuration for
    the application to be registered as a config server client.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the `application.properties` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: For the application to be registered as a client to the configuration server,
    we have to enable management web endpoints. The server will be running at port
    `8888`, as per the configuration in the `application.properties` file.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Cloud operates on an additional context, known as the **bootstrap** context.
    The bootstrap context is the parent to the main `ApplicationContext`. The responsibility
    of the bootstrap context is to load configuration properties from external sources
    into local external configurations. It is advisable to have a separate properties
    file for the bootstrap context.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the properties from the `bootstrap.properties` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: We have defined the application name that matches the name of the configuration
    properties file stored in the Git directory on the configuration server. The `bootstrap.properties`
    file also defines the URL for the Spring Cloud configuration server.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is all for the client to register with the Spring Cloud configuration
    server. The following log entries can be seen upon server startup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, though we have defined the server port for the client application
    to be `8888`, it fetches the `server.port` property from the configuration server
    and starts Tomcat on port `8101`. The following is what the page looks like when
    we render the `/accounts` URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c969f12b-ed37-4680-9537-6167a2e1bb93.png)'
  prefs: []
  type: TYPE_IMG
- en: This section described step-by-step ways to create a simple configuration server
    and a client that uses the configuration server. In the section to follow, we
    will see a way to monitor Spring microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring microservices with Spring Boot admin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring Boot admin is an application that facilitates monitoring and managing
    of Spring Boot applications. The latest version of the Spring Boot admin application
    is not yet compatible with Spring 2.0.0\. For the purpose of examples showcased
    in this section, we have used the Spring Boot 1.5.11 snapshot. The Spring Boot
    admin version is 1.5.4.
  prefs: []
  type: TYPE_NORMAL
- en: The Spring Boot client applications register themselves with the Spring Boot
    admin application via HTTP. It is also possible that admin applications discover
    client applications using the Spring Cloud Eureka discovery service. The Spring
    Boot admin user interface is built in AngularJS over Actuator endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: That should be enough for the introduction part as examples will provide more
    insight. Let's build the Spring Boot admin server first.
  prefs: []
  type: TYPE_NORMAL
- en: '`spring-boot-admin-server` is the dependency for building the admin server
    application. The Spring Boot admin application can have multiple Spring Boot applications
    registered, so, it becomes necessary for the Spring Boot admin application to
    be secure. That is the reason we have added the Spring Security starter project
    dependency. We will incorporate basic authentication for the purpose of this application,
    but it is not a limitation. We can add advanced security mechanisms, such as OAuth,
    for securing applications. The following is the POM file for the Spring Boot admin
    server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The `application.properties` file is where we define the security credentials
    for accessing the admin application. The following is the contents of the `application.properties`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '`@EnableAdminServer` is provided by the Spring Boot admin server dependency.
    It indicates that the application works as a Spring Boot admin application. The
    following is the code for the Spring Boot application `main` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to build a sample application that will be registered with
    the Spring Boot admin application. The following is the POM file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We have to define the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`spring.boot.admin.url`: The URL points to the Spring Boot admin application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spring.boot.admin.username`: It is necessary for the admin client to access
    the admin application using security credentials. This property specifies the
    username for the admin application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spring.boot.admin.password`: This property specifies the password for the
    admin application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`management.security.enabled`: This property denotes whether security is enabled
    for the client application or not.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`security.user.name`: This property defines the username for accessing the
    client application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`security.user.password`**:** This property specifies the password for accessing
    the client application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is the `application.properties` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the code for the simple Spring Boot application class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'It is also possible to add customization to default web security configurations
    provided by Spring Security. The following is an example that demonstrates allowing
    all requests for authorization:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, we are ready to start both the Spring Boot admin and client
    applications. When we navigate to the Spring Boot admin application URL, the following
    screen is shown with a list of all the registered applications:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ce6c6bfe-dda9-4ed2-bab8-e4df15e96c25.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Clicking on the Details button on the right side of the application name will
    bring up an interface similar to the one shown here. The Details tab shows the
    health of the application, memory and JVM statistics, and garbage collector details:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/77063b97-a470-4573-9cf0-f7d38b61946d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The Logging tab for the application details and displays a list of all the
    configured loggers. It is possible to change the log level. The following is the
    interface for Logging:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d5126e2b-7604-4b50-beae-0e0ef839d2e9.png)'
  prefs: []
  type: TYPE_IMG
- en: That's all for the Spring Boot admin application. It provides a production-grade
    interface and details for monitoring Spring Boot applications. The next section
    provides performance tuning for Spring Boot applications.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Boot performance tuning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spring Boot is a great tool to bootstrap and develop the Spring Framework-based
    application really quickly. The vanilla version of the Spring Boot application
    provides high performance without a doubt. But as the application starts to grow,
    its performance starts to be a bottleneck. This is a normal scenario for all web
    applications. The performance hit is observed when the different features are
    added and incoming requests are increasing day by day. We will learn the performance
    optimization techniques for Spring Boot applications in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Undertow as an embedded server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Spring Boot provides embedded servers that can run web applications in a JAR
    file. A few of the available embedded servers for use are Tomcat, Undertow, Webflux,
    and Jetty. It is advisable to have Undertow as the embedded server. Undertow provides
    more throughput and consumes less memory compared to Tomcat and Jetty. The following
    comparisons may provide some insight:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Throughput comparison:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|  **Server** | **Samples** | **Error % ** | **Throughput ** |'
  prefs: []
  type: TYPE_TB
- en: '| Tomcat | 3000 |        0 | 293.86 |'
  prefs: []
  type: TYPE_TB
- en: '| Jetty | 3000 | 0 | 291.52 |'
  prefs: []
  type: TYPE_TB
- en: '| Undertow | 3000 | 0 | 295.68 |'
  prefs: []
  type: TYPE_TB
- en: 'Heap memory comparison:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|  **Server** | **Heap size** | **Used** | **Max** |'
  prefs: []
  type: TYPE_TB
- en: '| Tomcat | 665.5 MB | 118.50 MB | 2 GB |'
  prefs: []
  type: TYPE_TB
- en: '| Jetty | 599.5 MB | 297 MB | 2 GB |'
  prefs: []
  type: TYPE_TB
- en: '| Undertow | 602 MB | 109 MB | 2 GB |'
  prefs: []
  type: TYPE_TB
- en: 'Threads comparison:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| **Server** | **Live** | **Started** |'
  prefs: []
  type: TYPE_TB
- en: '| Tomcat | 17 | 22 |'
  prefs: []
  type: TYPE_TB
- en: '| Jetty | 19 | 22 |'
  prefs: []
  type: TYPE_TB
- en: '| Undertow | 17 | 20 |'
  prefs: []
  type: TYPE_TB
- en: From the preceding comparisons, Undertow looks like the obvious choice for an
    embedded server in Spring Boot applications.
  prefs: []
  type: TYPE_NORMAL
- en: Overhead with the @SpringBootApplication annotation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `@SpringBootApplication` annotation is a provision for the developers who
    used to annotate Spring classes with `@ComponentScan`, `@EnableAutoConfiguration`,
    and `@Configuration`. So, the `@SpringBootApplication` annotation is equivalent
    to using three annotations with default configurations. The implicit `@ComponentScan`
    annotation scans the Java classes defined in the base package (package for the
    Spring Boot application main class) and all subpackages. This slows down the application
    startup when the application has grown significantly in size.
  prefs: []
  type: TYPE_NORMAL
- en: To overcome this, we can replace the `@SpringBootApplication` annotation with
    individual annotations where we provide package paths to be scanned with `@ComponentScan`.
    We can also consider using the `@Import` annotation to import only the required
    components, beans, or configurations.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter started with insightful details on Spring Boot, Spring Cloud, microservices,
    and all of these together. We covered the details of Spring Initializr, Spring
    Boot starter projects, and learned how to create our first Spring Boot application.
    Then, we learned about the Spring Boot Actuator and the production-grade features
    provided by the Actuator. The details on the application health checks and endpoints
    are important for production-ready applications.
  prefs: []
  type: TYPE_NORMAL
- en: Later in the chapter, we migrated to the world of microservices. We learned
    how Spring Boot can leverage features for the benefit of building microservices.
    We developed a microservice with Spring Boot and Spring Cloud with support for
    externalized configurations. We also looked at the integration of the Spring Boot
    admin for monitoring Spring Boot applications. Last but not least, we learned
    a few techniques to improve the performance of Spring Boot applications. Pretty
    huge stuff, isn't it?
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you have a very good understanding of performance assessment
    and performance tuning for Spring and, in essence, any Java-based web application.
    This is all for the scope of this book. A step forward, you can learn the JVM
    class-loading mechanism, Spring Batch framework, design patterns for microservices,
    microservices deployment, and **Infrastructure as a Service** (**IaaS**). We hope
    you will find these helpful.
  prefs: []
  type: TYPE_NORMAL
