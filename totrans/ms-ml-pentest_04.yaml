- en: Malware Detection with Deep Learning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The human mind is a fascinating entity. The power of our subconscious and unconscious
    mind is incredible. What makes this power real is our ability to continuously
    self-learn and adapt quickly. This amazing gift of nature can calculate billions
    of tasks before you even realize what it does. For decades, scientists have been
    trying to build machines that are able to do simultaneous tasks like the human
    mind does—in other words, systems that are able to perform a huge number of tasks
    efficiently and at incredible speeds. A subfield of machine learning called **Deep
    Learning (DL)** arose to help us build algorithms that work like the human mind
    and are inspired by its structure. Information security professionals are also
    intrigued by such techniques, as they have provided promising results in defending
    against major cyber threats and attacks. One of the best-suited candidates for
    the implementation of DL is malware analysis.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to discover:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Artificial neural networks: an in-depth overview'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to build your first neural network with Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to build a malware detector with multi-layer perceptrons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Malware visualization techniques and how to build a malware classifier with
    convolutional neural networks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Basically, in this chapter, we are going to use the same Python libraries that
    we have already installed. Generally, we are going to use those libraries during
    most chapters of the book. So, we spent the first chapter teaching you how to
    install all the required libraries that we are going to use in most chapters and
    projects. Find the code files at this link: [https://github.com/PacktPublishing/Mastering-Machine-Learning-for-Penetration-Testing/tree/master/Chapter04](https://github.com/PacktPublishing/Mastering-Machine-Learning-for-Penetration-Testing/tree/master/Chapter04).'
  prefs: []
  type: TYPE_NORMAL
- en: Artificial neural network overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our brains perform many complex functions in the blink of an eye. Thus, in
    order to build algorithms that perform and learn using the same techniques as
    the human mind, it is essential for us to learn how the brain works. By acquiring
    a fair understanding about how the human mind functions, we will have better understanding
    of deep learning. The three major distinctive mind functions are:'
  prefs: []
  type: TYPE_NORMAL
- en: Thinking (analyzing, comparing, and judging)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Feeling (happiness, sadness, and excitement)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wanting (motives, desires, and goals)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These three functions are continuously interacting in a dynamic process.
  prefs: []
  type: TYPE_NORMAL
- en: 'The brain is mainly composed of three components: the **cerebrum**, which is
    the largest part of the brain and controls higher functions, such as vision, hearing,
    and tasting; the **cerebellum**, which is the entity responsible for coordinating
    muscle movements and the general posture of the human body, including its balance;
    and the third part is called the **brainstem**, which connects the two previous
    parts and control many other tasks, including sneezing, coughing, and digesting.'
  prefs: []
  type: TYPE_NORMAL
- en: The brain performs complex operations thanks to its different parts. Logically,
    the anatomy of the human brain is composed of many regions, so each region works
    based on a specific algorithm. Although each part of the brain works using its
    own algorithm, surprisingly, the human brain uses essentially the same algorithm
    to understand many different input modalities. This hypothesis is called the **one
    learning algorithm** hypothesis. Many studies done by *Roe et al.* in 1992 proved
    it, especially ferret experiments, in which the input for vision was plugged into
    auditory part of the ferret's brain, and the auditory cortex learned how to see.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram describes the relationship between **Artificial Intelligence
    (AI)**, **Machine Learning (ML)**, and **Deep Learning (DL)**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00099.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Biologically, the human brain is composed of billions of small organs called
    neurons. Neurons are units that process and transfer information through electrical
    and chemical signals. These nerve cells are mainly composed of:'
  prefs: []
  type: TYPE_NORMAL
- en: Dendrites
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Axons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Synapses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cell body
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nucleus
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram illustrates the different components of a biological
    neuron:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00100.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The analogical representation of a biological neuron is called a **perceptron**.
    The perceptron can be broken down into:'
  prefs: []
  type: TYPE_NORMAL
- en: Inputs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Weights
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Net input function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Activation function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Output
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The analogy between a perceptron and a human neuron is not totally correct.
    It is used just to give a glimpse into how a perceptron works. The human mind
    is far more complicated than artificial neural networks. There are a few similarities
    but a direct comparison between the mind and neural networks is not appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing neural networks in Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Classic computer programs are great when it comes to compute operations based
    on a sequence of instructions and arithmetic, but they face difficulties and challenges
    in many other cases; for example, handwriting-recognition. As a warm up, let''s
    build a handwritten digit recognizer to take the opportunity to install the Python
    libraries needed in the next sections and learn how to build and implement our
    first neural network in Python. To train the model, we need to feed it with data.
    In our implementation, we are going to use the MNIST dataset:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00101.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'First, let''s install the `keras` library using the `pip install` command,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00102.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, install TensorFlow (`tensorflow`) using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00103.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'And finally, install `np_utils`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00104.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Open the Python command-line interface and import the following modules using
    the import commands as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: The `mnist` dataset
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Sequential` model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Dense` and `Dropout` layers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `np_utils` module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The following diagram illustrates the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00105.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Seed is used because we want repeatable results. `numpy.random.seed(seed)`
    is used to seed the generator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Download data from [https://s3.amazonaws.com/img-datasets/mnist.pkl.gz](https://s3.amazonaws.com/img-datasets/mnist.pkl.gz):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `.astype()` is used to convert the variables and `.reshape()` is used
    to give the array a new shape without changing the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00106.gif)'
  prefs: []
  type: TYPE_IMG
- en: The accuracy of our handwritten digit classifier is 99.8%, which is an amazing
    result. Now we have learned how to build our first neural network program, it
    is time to leverage our skills and get hands-on experience in how to build malware
    classifiers using artificial neural networks, especially DL networks.
  prefs: []
  type: TYPE_NORMAL
- en: Deep learning model using PE headers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the concepts we've learned, we are going to build a malware detector with
    artificial neural networks. Let's begin by identifying our dataset. By now, you
    are familiar with the steps required to build a machine learning models. For this
    model, we are going to use the **Portable Executable** (**PE**) files as feeding
    data. As you noticed in the previous chapter, we installed a Python library called
    `pefile`. It is time to use it in this model. Once we install `pefile` with the
    Python package installation manager PIP, we can start using `pefile` to extract
    information from any PE file. In order to gather information from a PE file, import
    the `os` and `pefile` libraries. The `os` library allows you to interface with
    the underlying operating system that Python is running on.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a demonstration, we are going to download a malware PE file delivered by
    Palo Alto networks for experimental purposes. Download it with the `wget` command
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the PE file is installed, open the Python environment and import the required
    libraries, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Load the file using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we are able to extract `PE_HEADER_OPTIONAL` information from the PE file,
    including `MajorLinkerVersion`, `MajorLinkerVersion`, `SizeOfImage`, and `DllCharacteristics`.
    You can find the full list by checking the Microsoft documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00107.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the following script, I have extracted information about:'
  prefs: []
  type: TYPE_NORMAL
- en: '`LinkerVersion`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NumberOfSections`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ImageVersion`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/00108.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'We know that training the model is a high-consumption task when it comes to
    computing. Thus, processing and feeding the model with all the header information
    is not a wise decision. So, we need to feature engineer them. Selecting the good
    features is a skill needed in every data science mission. A research study called
    *Selecting Features to Classify Malware* by Karthik Raman from the **Product Security
    Incident Response Team** (**PSIRT**), Adobe Systems, made a proposal to solve
    that issue by suggesting the most important PE headers that we need to select;
    they are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`DebugSize`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DebugRVA`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ImageVersion`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OperatingSystemVersion`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SizeOfStackReserve`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LinkerVersion`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DllCharacteristics`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IatRVA`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ExportSize`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ExportRVA`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ExportNameLen`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ResourceSize`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ExportFunctionsCount`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To extract them, you can use the imported `PEfile` module like we did previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00109.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'To train the model, there are many publicly available sources. You can download
    different types of file (clean and malicious) from a large list of organizations
    and educational institutions, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ViruSign**: [http://www.virusign.com/](http://www.virusign.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MalShare**: [http://malshare.com/](http://malshare.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Malware DB**: [http://ytisf.github.io/theZoo/](http://ytisf.github.io/theZoo/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Endgame Malware BEnchmark for Research (EMBER)**: One of the largest datasets,
    this contains 1.1 million SHA256 hashes from PE files that were scanned sometime
    in 2017\. I highly recommend you download it and try to build your models using
    it. You can download it from [https://pubdata.endgame.com/ember/ember_dataset.tar.bz2](https://pubdata.endgame.com/ember/ember_dataset.tar.bz2)
    (1.6 GB, expands to 9.2 GB):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/00110.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Your dataset should contain two categories of PE files: **clean** and **malicious
    files**. We need at least 10,000 files to train the model. You will have to start
    extracting header information using the previous scripts. You can automate the
    task by developing an automation script by yourself. Feel free to use any programming
    language. The best way is to export the selected features of all the files to
    CSV files so we can use what we learned in the previous chapters, and so we can
    later load them using pandas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'After preparing the features, we need to merge the two types of data into one.
    For example, we can use `pd.concat` to merge the two files. To train the model,
    we need to import the required modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'For data preparation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This line is for splitting, as we did in the other models:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'For better prediction, we can use `StandScaler()`; it is used for standardizing
    features by removing the mean and scaling to unit variance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'After preparing and feature engineering the data, we have to build the **Multi-Layer
    Perceptron** (**MLP**) network:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `12` is the number of layers and the number of features. Let''s train
    the model and compute the predictions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'To check the evaluation metrics, add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '`ravel()` is used here to return a contiguous flattened array. It is equivalent
    to `reshape(-1, order=order)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Deep learning model with convolutional neural networks and malware visualization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous section was a real-world implementation of MLP networks for detecting
    malware. Now, we are going to explore other artificial network architectures and
    we are also going to learn how to use one of them to help malware analysts and
    information security professionals to detect and classify malicious code. Before
    diving into the technical details and the steps for the practical implementation
    of the DL method, it is essential to learn and discover the other different architectures
    of artificial neural networks. We discussed some of them briefly in [Chapter 1](part0021.html#K0RQ0-49a67f1d6e7843d3b2296f38e3fe05f5),
    *Introduction to Machine Learning in Pentesting*. The major artificial neural
    networks are discussed now.
  prefs: []
  type: TYPE_NORMAL
- en: Convolutional Neural Networks (CNNs)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Convolutional Neural Networks** (**CNNs**) are a deep learning approach to
    tackle the image classification problem, or what we call computer vision problems,
    because classic computer programs face many challenges and difficulties to identify
    objects for many reasons, including lighting, viewpoint, deformation, and segmentation.
    This technique is inspired by how the eye works, especially the visual cortex
    function algorithm in animals. In CNN are arranged in three-dimensional structures
    with width, height, and depth as characteristics. In the case of images, the height
    is the image height, the width is the image width, and the depth is RGB channels.
    To build a CNN, we need three main types of layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Convolutional layer**: A convolutional operation refers to extracting features
    from the input image and multiplying the values in the filter with the original
    pixel values'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pooling layer**: The pooling operation reduces the dimensionality of each
    feature map'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fully-connected layer**: The fully-connected layer is a classic multi-layer
    perceptrons with a softmax activation function in the output layer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To implement a CNN with Python, you can use the following Python script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Recurrent Neural Networks (RNNs)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Recurrent Neural Networks** (**RNNs**) are artificial neural networks where
    we can make use of sequential information, such as sentences. In other words,
    RNNs perform the same task for every element of a sequence, with the output depending
    on the previous computations. RNNs are widely used in language modeling and text
    generation (machine translation, speech recognition, and many other applications).
    RNNs do not remember things for a long time.'
  prefs: []
  type: TYPE_NORMAL
- en: Long Short Term Memory networks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Long Short Term Memory** (**LSTM**) solves the short memory issue in recurrent
    neural networks by building a memory block. This block sometimes is called a **memory
    cell**.'
  prefs: []
  type: TYPE_NORMAL
- en: Hopfield networks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Hopfield networks were developed by John Hopfield in 1982\. The main goal of
    Hopfield networks is auto-association and optimization. We have two categories
    of Hopfield network: **discrete** and **continuous**.'
  prefs: []
  type: TYPE_NORMAL
- en: Boltzmann machine networks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Boltzmann machine networks use recurrent structures and they use only locally
    available information. They were developed by Geoffrey Hinton and Terry Sejnowski
    in 1985\. Also, the goal of a Boltzmann machine is optimizing the solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Malware detection with CNNs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this new model, we are going to discover how to build a malware classifier
    with CNNs. But I bet you are wondering how we can do that while CNNs are taking
    images as inputs. The answer is really simple, the trick here is converting malware
    into an image. Is this possible? Yes, it is. Malware visualization is one of many
    research topics during the past few years. One of the proposed solutions has came
    from a research study called *Malware Images: Visualization and Automatic Classification*
    by *Lakshmanan Nataraj* from the Vision Research Lab, University of California,
    Santa Barbara.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram details how to convert malware into an image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00111.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following is an image of the **Alueron.gen!J** malware:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00112.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'This technique also gives us the ability to visualize malware sections in a
    detailed way:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00113.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'By solving the issue of how to feed malware machine learning classifiers that
    use CNNs by images, information security professionals can use the power of CNNs
    to train models. One of the malware datasets most often used to feed CNNs is the
    **Malimg dataset**. This malware dataset contains 9,339 malware samples from 25
    different malware families. You can download it from Kaggle (a platform for predictive
    modeling and analytics competitions) by visiting this link: [https://www.kaggle.com/afagarap/malimg-dataset/data](https://www.kaggle.com/afagarap/malimg-dataset/data).'
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the malware families:'
  prefs: []
  type: TYPE_NORMAL
- en: Allaple.L
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allaple.A
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Yuner.A
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lolyda.AA 1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lolyda.AA 2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lolyda.AA 3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: C2Lop.P
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: C2Lop.gen!G
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instant access
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Swizzor.gen!I
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Swizzor.gen!E
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: VB.AT
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fakerean
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Alueron.gen!J
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Malex.gen!J
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lolyda.AT
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adialer.C
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wintrim.BX
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dialplatform.B
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dontovo.A
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Obfuscator.AD
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Agent.FYI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Autorun.K
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rbot!gen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Skintrim.N
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After converting malware into grayscale images, you can get the following malware
    representation so you can use them later to feed the machine learning model:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00114.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The conversion of each malware to a grayscale image can be done using the following
    Python script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'For feature selection, you can extract or use any image characteristics, such
    as the texture pattern, frequencies in image, intensity, or color features, using
    different techniques such as **Euclidean distance**, or mean and standard deviation,
    to generate later feature vectors. In our case, we can use algorithms such as
    a color layout descriptor, homogeneous texture descriptor, or **global image descriptors**
    (**GIST**). Let''s suppose that we selected the GIST; `pyleargist` is a great
    Python library to compute it. To install it, use PIP as usual:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'As a use case, to compute a GIST, you can use the following Python script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Here, `320` refers to the first `320` values while we are using grayscale images.
    Don't forget to save them as *NumPy arrays* to use them later to train the model.
  prefs: []
  type: TYPE_NORMAL
- en: After getting the feature vectors, we can train many different models, including
    SVM, k-means, and artificial neural networks. One of the useful algorithms is
    that of the CNN.
  prefs: []
  type: TYPE_NORMAL
- en: Once the feature selection and engineering is done, we can build a CNN. For
    our model, for example, we will build a convolutional network with two convolutional
    layers, with *32 * 32* inputs. To build the model using Python libraries, we can
    implement it with the previously installed TensorFlow and utils libraries.
  prefs: []
  type: TYPE_NORMAL
- en: 'So the overall CNN architecture will be as in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00115.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This CNN architecture is not the only proposal to build the model, but at the
    moment we are going to use it for the implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'To build the model and CNN in general, I highly recommend Keras. The required
    imports are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'As we discussed before, the grayscale image has pixel values that range from
    0 to 255, and we need to feed the net with *32 * 32 * 1* dimension images as a
    result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We will train our network with these parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'To build the architecture, with regards to its format, use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'To compile the model, use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Fit and train the model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'As you noticed, we are respecting the flow of training a neural network that
    was discussed in previous chapters. To evaluate the model, use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Promises and challenges in applying deep learning to malware detection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many different deep network architectures were proposed by machine learning
    practitioners and malware analysts to detect both known and unknown malware; some
    of the proposed architectures include restricted Boltzmann machines and hybrid
    methods. You can check some of them in the *Further reading* section. Novel approaches
    to detect malware and malicious software show many promising results. However,
    there are many challenges that malware analysts face when it comes to detecting
    malware using deep learning networks, especially when analyzing PE files because
    to analyze a PE file, we take each byte as an input unit, so we deal with classifying
    sequences with millions of steps, in addition to the need of keeping complicated
    spatial correlation across functions due to function calls and jump commands.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Malware is a nightmare for every modern organization. Attackers and cyber criminals
    are always coming up with new malicious software to attack their targets. Security
    vendors are doing their best to defend against malware attacks but, unfortunately,
    with millions of malwares discovered monthly, they cannot achieve that. Thus,
    novel approaches are needed, which are exactly what we looked at in this and the
    previous chapter. We discovered how to build malware detectors using different
    machine learning algorithms, especially using the power of deep learning techniques.
    In the next chapter, we will learn how to detect botnets by building and developing
    robust intelligent systems.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the difference between MLP networks and deep learning networks?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why DL recently is taking off?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why do we need to iterate multiple times through different models?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What type of DL needed to translate English to French language?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why malware visualization is a good method to classify malware?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the role of an activation function?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can you mention three DL architectures?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Blog posts**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Keras Tutorial: Deep Learning in Python ([https://www.datacamp.com/community/tutorials/deep-learning-python](https://www.datacamp.com/community/tutorials/deep-learning-python))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Develop Your First Neural Network in Python With Keras Step-By-Step ([https://machinelearningmastery.com/tutorial-first-neural-network-python-keras/](https://machinelearningmastery.com/tutorial-first-neural-network-python-keras/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: THE MNIST Database of handwritten digits ([http://yann.lecun.com/exdb/mnist](http://yann.lecun.com/exdb/mnist)/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Papers and presentations**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: High dimensional visualization of malware families ([https://www.rsaconference.com/writable/presentations/file_upload/tta-f04-high-dimensional-visualization-of-malware-families.pdf](https://www.rsaconference.com/writable/presentations/file_upload/tta-f04-high-dimensional-visualization-of-malware-families.pdf))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Hybrid Malicious Code Detection Method based on Deep Learning ([http://www.covert.io/research-papers/deep-learning-security/A%20Hybrid%20Malicious%20Code%20Detection%20Method%20based%20on%20Deep%20Learning.pdf](http://www.covert.io/research-papers/deep-learning-security/A%20Hybrid%20Malicious%20Code%20Detection%20Method%20based%20on%20Deep%20Learning.pdf)
    )
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Multi-task Learning Model for Malware Classification with Useful File Access
    Pattern from API Call Sequence ([http://www.covert.io/research-papers/deep-learning-security/A%20Multi-task%20Learning%20Model%20for%20Malware%20Classification%20with%20Useful%20File%20Access%20Pattern%20from%20API%20Call%20Sequence.pdf](http://www.covert.io/research-papers/deep-learning-security/A%20Multi-task%20Learning%20Model%20for%20Malware%20Classification%20with%20Useful%20File%20Access%20Pattern%20from%20API%20Call%20Sequence.pdf)
    )
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combining Restricted Boltzmann Machine and One Side Perceptron for Malware Detection
    ([http://www.covert.io/research-papers/deep-learning-security/Combining%20Restricted%20Boltzmann%20Machine%20and%20One%20Side%20Perceptron%20for%20Malware%20Detection.pdf](http://www.covert.io/research-papers/deep-learning-security/Combining%20Restricted%20Boltzmann%20Machine%20and%20One%20Side%20Perceptron%20for%20Malware%20Detection.pdf)
    )
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Convolutional Neural Networks for Malware Classification- Thesis ([http://www.covert.io/research-papers/deep-learning-security/Convolutional%20Neural%20Networks%20for%20Malware%20Classification.pdf](http://www.covert.io/research-papers/deep-learning-security/Convolutional%20Neural%20Networks%20for%20Malware%20Classification.pdf)
    )
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deep Learning for Classification of Malware System Call Sequences ([http://www.covert.io/research-papers/deep-learning-security/Deep%20Learning%20for%20Classification%20of%20Malware%20System%20Call%20Sequences.pdf](http://www.covert.io/research-papers/deep-learning-security/Deep%20Learning%20for%20Classification%20of%20Malware%20System%20Call%20Sequences.pdf)
    )
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deep Neural Network Based Malware Detection using Two Dimensional Binary Program
    Features ([http://www.covert.io/research-papers/deep-learning-security/Deep%20Neural%20Network%20Based%20Malware%20Detection%20Using%20Two%20Dimensional%20Binary%20Program%20Features.pdf](http://www.covert.io/research-papers/deep-learning-security/Deep%20Neural%20Network%20Based%20Malware%20Detection%20Using%20Two%20Dimensional%20Binary%20Program%20Features.pdf)
    )
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'DL4MD: A Deep Learning Framework for Intelligent Malware Detection ([http://www.covert.io/research-papers/deep-learning-security/DL4MD-%20A%20Deep%20Learning%20Framework%20for%20Intelligent%20Malware%20Detection.pdf](http://www.covert.io/research-papers/deep-learning-security/DL4MD-%20A%20Deep%20Learning%20Framework%20for%20Intelligent%20Malware%20Detection.pdf)
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Droid-Sec: Deep Learning in Android Malware Detection ([http://www.covert.io/research-papers/deep-learning-security/DroidSec%20-%20Deep%20Learning%20in%20Android%20Malware%20Detection.pdf](http://www.covert.io/research-papers/deep-learning-security/DroidSec%20-%20Deep%20Learning%20in%20Android%20Malware%20Detection.pdf)
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'HADM: Hybrid Analysis for Detection of Malware ([http://www.covert.io/research-papers/deep-learning-security/HADM-%20Hybrid%20Analysis%20for%20Detection%20of%20Malware.pdf](http://www.covert.io/research-papers/deep-learning-security/HADM-%20Hybrid%20Analysis%20for%20Detection%20of%20Malware.pdf)
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Malware Classification with Recurrent Networks ([http://www.covert.io/research-papers/deep-learning-security/Malware%20Classification%20with%20Recurrent%20Networks.pdf](http://www.covert.io/research-papers/deep-learning-security/Malware%20Classification%20with%20Recurrent%20Networks.pdf)
    )
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
