- en: Introduction to Exploit Development
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: CPU registers
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory dump
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CPU instructions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python is helpful for creating simple prototype codes to test the exploits.
    In this chapter, we can learn the basics of exploit development, which may help
    you to correct broken exploits, or just build your own exploits from scratch.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: CPU registers
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CPU registers, or processor registers, are one of a small set of data holding
    places in the processor, which may hold an instruction, storage address, or any
    data. Registers should be capable of storing the instructions. Registers are the
    fastest computer memory, used to speed up the computer operation.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You need to have a basic idea about the registers before working with exploit
    development. For understanding, let's consider that registers are mainly in two
    forms, general purpose registers and special purpose registers.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: General purpose registers
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'General purpose registers are used to store intermediate results during program
    execution and to run mathematical operations. The four general purpose registers
    are EAX, EBX, ECX, and EDX:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '**EAX (The accumulator register)**: Used for basic mathematical operations
    and to return the value of a function.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**EBX**: This is used for nominal storage as needed.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ECX (The counter register)**: Used for looping through functions and iterations.
    It can also be used for general storage.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**EDX (The data register)**: It is used for higher mathematical operations
    such as multiplication and division. It also stores function variables while running
    a program.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Special purpose registers
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Special purpose registers are used to handle indexing and pointing. These are
    important in the case of writing exploits as we will try to manipulate and overwrite
    the data in these registers. The main special purpose registers are EBP, EDI,
    EIP, and ESP:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '**EBP**: This pointer register indicates where the bottom of the stack is at.
    So, this will point to the top of the stack or set to the old pointer value when
    we are starting a function as it''s the beginning.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**EDI**: This is the destination index register, used for pointers to function.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**EIP**: Instruction pointer register is used to store the next instruction
    to be executed by the CPU. So, this is important for exploit writing as if we
    could edit this we can control the next instruction. Also, if we can overwrite
    this EIP it means that the program itself has failed.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ESP**: Is when the stack pointer indicates the current top (lowest memory
    address) of the stack. This get updates while running the program as items are
    removed from the top of the stack. When new functions are loaded it goes back
    to the top position. If we need to access the stack memory we can use ESP.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To view the registers while running a program we need debuggers, we have to
    install debuggers for this in your system. For debugging Windows programs we can
    use Immunity Debugger and for Linux and Mac we can use `pwngdb`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: You can download and install Immunity Debugger from here: [https://www.immunityinc.com/products/debugger/](https://www.immunityinc.com/products/debugger/).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: 'To install `pwndbg`, get the code from the Git repository and run the setup
    script:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: How to do it...
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can do some quick tasks for better understanding of these registers in the
    debugger tools.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: To view the registers while running a program, we need to use debuggers. So
    open an executable in the Immunity Debugger. For that, open Immunity Debugger
    in a Windows machine.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then load the program to analyze it in Immunity Debugger. From the menu go to
    File | Open and select the application to monitor.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It will open the application in debug mode and print out the current details.
    The top-right box will show the register details. The register pane in the Immunity
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Debugger looks as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00066.gif)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
- en: 'For Linux and macOS, after installing `pwndbg` we can open the application
    in `pwndbg` with the following command:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This will open the application `app` in the debugger
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在调试器中打开应用程序`app`
- en: 'Now we can run the application in the debug mode with a break point set:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以在调试模式下运行应用程序，并设置断点：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This will run the application and break at line `5`
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这将运行应用程序并在第`5`行处中断
- en: 'Now we can view the registers at the current state with the following command:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以使用以下命令查看当前状态的寄存器：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The output will be as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '![](img/00067.jpeg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00067.jpeg)'
- en: If the executable is 64-bit, the registers will start with `r`. Starting them
    with `e` is invalid.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可执行文件是64位的，则寄存器将以`r`开头。以`e`开头是无效的。
- en: Memory dump
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存转储
- en: We can easily view the contents of a memory location with the memory dump. We
    can use Immunity Debugger or `pwndbg` for this.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用内存转储轻松查看内存位置的内容。我们可以使用Immunity Debugger或`pwndbg`来实现这一点。
- en: How to do it...
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Follow the steps for better understanding of memory dump:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤更好地理解内存转储：
- en: Open an application in the Immunity Debugger.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Immunity Debugger中打开一个应用程序。
- en: 'If you want to view the memory dump in ESI register and right-click on the
    address and select the Follow in Dump option:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果要查看ESI寄存器中的内存转储，并右键单击地址，选择转到转储选项：
- en: '![](img/00068.jpeg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00068.jpeg)'
- en: 'This will update the memory dump window in the bottom-left corner. The memory
    dump window in Immunity Debugger looks as follows:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将更新左下角的内存转储窗口。Immunity Debugger中的内存转储窗口如下所示：
- en: '![](img/00069.gif)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00069.gif)'
- en: 'With `pwndbg` we can get the memory dump with the `hexdump` command. For that,
    load the application in `gdb` and run it with a breaker:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`pwndbg`，我们可以使用`hexdump`命令获取内存转储。为此，在`gdb`中加载应用程序并在断点处运行它：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now to view the memory dump in RSI register, run the following command:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在要查看RSI寄存器中的内存转储，请运行以下命令：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The output will be as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '![](img/00070.jpeg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00070.jpeg)'
- en: CPU instructions
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CPU指令
- en: When an application is written in high-level languages is compiled, the language
    instructions will be converted to assembly language corresponding to it. This
    is the code that machines can understand. With the debugger we can view each assembly
    instruction.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序用高级语言编写并编译时，语言指令将被转换为相应的汇编语言。这是机器可以理解的代码。通过调试器，我们可以查看每个汇编指令。
- en: How to do it...
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Follow the steps to understand the usage in debuggers:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤了解调试器的用法：
- en: Open an application in the Immunity Debugger.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Immunity Debugger中打开一个应用程序。
- en: We can view the opcode in the top-left pane of the Immunity Debugger.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以在Immunity Debugger的左上角窗格中查看操作码。
- en: 'We can step through the instructions one by one and see the results by pressing
    *F7*:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以逐步执行指令，并通过按下*F7*来查看结果：
- en: 'Here is how the instructions pane looks:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是指令窗格的外观：
- en: '![](img/00071.jpeg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00071.jpeg)'
- en: This will update the corresponding registers in the top-right pane. Like this,
    we can follow the execution of each CPU instruction within Immunity Debugger.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这将更新右上角窗格中相应的寄存器。通过这样，我们可以在Immunity Debugger中跟踪每个CPU指令的执行。
- en: 'In the case of `pwndbg`, we can use the `entry` command to execute at the entry
    point:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在`pwndbg`的情况下，我们可以使用`entry`命令在入口点执行：
- en: '[PRE6]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This will present with the context screen.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示上下文屏幕。
- en: 'We can use the `nearpc` command to view the opcode near the break pointers:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用`nearpc`命令查看断点附近的操作码：
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The output will be as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '![](img/00072.jpeg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00072.jpeg)'
- en: 'We can step through the instructions with the `stepi` command:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用`stepi`命令逐步执行指令：
- en: '[PRE8]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This will execute one machine instruction, and then it will stop and return
    to the debugger.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这将执行一条机器指令，然后停止并返回到调试器。
- en: Like this, we can go through the instructions to analyze it.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们可以逐步分析指令。
