- en: Introduction to Exploit Development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: CPU registers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory dump
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CPU instructions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python is helpful for creating simple prototype codes to test the exploits.
    In this chapter, we can learn the basics of exploit development, which may help
    you to correct broken exploits, or just build your own exploits from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: CPU registers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CPU registers, or processor registers, are one of a small set of data holding
    places in the processor, which may hold an instruction, storage address, or any
    data. Registers should be capable of storing the instructions. Registers are the
    fastest computer memory, used to speed up the computer operation.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You need to have a basic idea about the registers before working with exploit
    development. For understanding, let's consider that registers are mainly in two
    forms, general purpose registers and special purpose registers.
  prefs: []
  type: TYPE_NORMAL
- en: General purpose registers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'General purpose registers are used to store intermediate results during program
    execution and to run mathematical operations. The four general purpose registers
    are EAX, EBX, ECX, and EDX:'
  prefs: []
  type: TYPE_NORMAL
- en: '**EAX (The accumulator register)**: Used for basic mathematical operations
    and to return the value of a function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**EBX**: This is used for nominal storage as needed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ECX (The counter register)**: Used for looping through functions and iterations.
    It can also be used for general storage.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**EDX (The data register)**: It is used for higher mathematical operations
    such as multiplication and division. It also stores function variables while running
    a program.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Special purpose registers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Special purpose registers are used to handle indexing and pointing. These are
    important in the case of writing exploits as we will try to manipulate and overwrite
    the data in these registers. The main special purpose registers are EBP, EDI,
    EIP, and ESP:'
  prefs: []
  type: TYPE_NORMAL
- en: '**EBP**: This pointer register indicates where the bottom of the stack is at.
    So, this will point to the top of the stack or set to the old pointer value when
    we are starting a function as it''s the beginning.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**EDI**: This is the destination index register, used for pointers to function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**EIP**: Instruction pointer register is used to store the next instruction
    to be executed by the CPU. So, this is important for exploit writing as if we
    could edit this we can control the next instruction. Also, if we can overwrite
    this EIP it means that the program itself has failed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ESP**: Is when the stack pointer indicates the current top (lowest memory
    address) of the stack. This get updates while running the program as items are
    removed from the top of the stack. When new functions are loaded it goes back
    to the top position. If we need to access the stack memory we can use ESP.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To view the registers while running a program we need debuggers, we have to
    install debuggers for this in your system. For debugging Windows programs we can
    use Immunity Debugger and for Linux and Mac we can use `pwngdb`.
  prefs: []
  type: TYPE_NORMAL
- en: You can download and install Immunity Debugger from here: [https://www.immunityinc.com/products/debugger/](https://www.immunityinc.com/products/debugger/).
  prefs: []
  type: TYPE_NORMAL
- en: 'To install `pwndbg`, get the code from the Git repository and run the setup
    script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can do some quick tasks for better understanding of these registers in the
    debugger tools.
  prefs: []
  type: TYPE_NORMAL
- en: To view the registers while running a program, we need to use debuggers. So
    open an executable in the Immunity Debugger. For that, open Immunity Debugger
    in a Windows machine.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then load the program to analyze it in Immunity Debugger. From the menu go to
    File | Open and select the application to monitor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It will open the application in debug mode and print out the current details.
    The top-right box will show the register details. The register pane in the Immunity
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Debugger looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00066.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'For Linux and macOS, after installing `pwndbg` we can open the application
    in `pwndbg` with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This will open the application `app` in the debugger
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can run the application in the debug mode with a break point set:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This will run the application and break at line `5`
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can view the registers at the current state with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00067.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: If the executable is 64-bit, the registers will start with `r`. Starting them
    with `e` is invalid.
  prefs: []
  type: TYPE_NORMAL
- en: Memory dump
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can easily view the contents of a memory location with the memory dump. We
    can use Immunity Debugger or `pwndbg` for this.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow the steps for better understanding of memory dump:'
  prefs: []
  type: TYPE_NORMAL
- en: Open an application in the Immunity Debugger.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you want to view the memory dump in ESI register and right-click on the
    address and select the Follow in Dump option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00068.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'This will update the memory dump window in the bottom-left corner. The memory
    dump window in Immunity Debugger looks as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00069.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'With `pwndbg` we can get the memory dump with the `hexdump` command. For that,
    load the application in `gdb` and run it with a breaker:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now to view the memory dump in RSI register, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00070.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: CPU instructions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When an application is written in high-level languages is compiled, the language
    instructions will be converted to assembly language corresponding to it. This
    is the code that machines can understand. With the debugger we can view each assembly
    instruction.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow the steps to understand the usage in debuggers:'
  prefs: []
  type: TYPE_NORMAL
- en: Open an application in the Immunity Debugger.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can view the opcode in the top-left pane of the Immunity Debugger.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can step through the instructions one by one and see the results by pressing
    *F7*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here is how the instructions pane looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00071.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This will update the corresponding registers in the top-right pane. Like this,
    we can follow the execution of each CPU instruction within Immunity Debugger.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of `pwndbg`, we can use the `entry` command to execute at the entry
    point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This will present with the context screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the `nearpc` command to view the opcode near the break pointers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00072.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can step through the instructions with the `stepi` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This will execute one machine instruction, and then it will stop and return
    to the debugger.
  prefs: []
  type: TYPE_NORMAL
- en: Like this, we can go through the instructions to analyze it.
  prefs: []
  type: TYPE_NORMAL
