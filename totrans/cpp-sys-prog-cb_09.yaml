- en: Dealing with Time Interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Time is used in several forms in operating systems and applications. Typically, applications
    need to deal with the following **categories** of time:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Clock**: The actual time and date, as you would read on your watch'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Time point**: Processing time taken to profile, monitor, and troubleshoot
    an application''s usage (for example, a processor or resource in general)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Duration**: Monotonic time, that is, the elapsed time for a certain event'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we'll deal with all these aspects from both a C++ and POSIX
    point of view in order so that you have more tools available in your toolbox.
    The recipes in this chapter will teach you how to measure an event by using time
    points and why you should use a steady clock for that, as well as when the time
    overruns and how to mitigate it. You'll learn how to implement these concepts
    with both POSIX and C++ `std::chrono`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Learning about the C++ time interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the C++20 calendar and time zone
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning about Linux timing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dealing with time sleep and overruns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To try out the programs in this chapter immediately, we've set up a Docker image that
    contains all the tools and libraries we'll need throughout this book. It is based
    on Ubuntu 19.04.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to set it up, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Download and install Docker Engine from [www.docker.com](https://www.docker.com/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pull the image from Docker Hub: `docker pull kasperondocker/system_programming_cookbook:latest`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The image should now be available. Type in the following command to view the
    image: `docker images`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You should have the following image: `kasperondocker/system_programming_cookbook`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the Docker image with an interactive shell with the help of the `docker
    run -it --cap-add sys_ptrace kasperondocker/system_programming_cookbook:latest /bin/bash` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The shell on the running container is now available. Go to `root@39a5a8934370/#
    cd /BOOK/` to get all the programs that will be developed in this book.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `--cap-add sys_ptrace` argument is needed to allow **GDB** (short for **GNU
    Project Debugger**) to set breakpoints, which Docker doesn't allow by default.
  prefs: []
  type: TYPE_NORMAL
- en: '**Disclaimer**: The C++20 standard has been approved (that is, technically
    finalized) by WG21 in a meeting in Prague at the end of February. This means that
    the GCC compiler version that this book uses, 8.3.0, does not include (or has
    very, very limited support for) the new and cool C++20 features. For this reason,
    the Docker image does not include the C++20 recipe code. GCC keeps the development
    of the newest features in branches (you have to use appropriate flags for that,
    for example, `-std=c++2a`); therefore, you are encouraged to experiment with them
    by yourself. So, clone and explore the GCC contracts and module branches and have
    fun.'
  prefs: []
  type: TYPE_NORMAL
- en: Learning about the C++ time interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The C++11 standard really marks an important step regarding time. Before that
    (C++ standard 98 and before), system and application developers had to rely on
    implementation-specific APIs (that is, POSIX) or external libraries (for example, `boost`)
    to manipulate **time**, which means less portable code. This recipe will teach
    you how to write C++ code by using the standard time manipulation library.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s write a program to learn about the concepts of **clock**, **time point**,
    and **duration**, as supported in the C++ standards:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file and call it `chrono_01.cpp`. We need a few includes first:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `main` part, we need something to measure, so let''s populate an `std::vector`
    with some integers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have the two time points, `start` and `end`, let''s calculate the
    difference (that is, duration) and print it to see how long it took:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we want to print the `start` variable in another format; for example,
    in the format of calendar local time with `ctime`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This program uses a few of the `std::chrono` features, such as `system_clock`,
    `time_point`, and duration available in the Standard Library, and has done since
    version 11 of the C++ standard.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Step 1* takes care of including the headers we''ll need later: `<iostream>`
    for the standard output and `<vector>` and `<chrono>` for the time.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Step 2* defines a vector of **int called elements**. Due to this, we can call
    the `now()` method on the `system_clock` class in the `chrono` namespace to get
    the current time. Although we used `auto`, this method returns a `time_point`
    object representing a point in time. Then, we looped over 100 million times to
    populate the `elements` array in order to highlight that we used the new C++14
    feature to represent *100,000,000*, which improves the readability of the code.
    At the end, we took another point in time by calling the `now()` method and storing
    the `time_point` object in the `end` variable.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In *step 3*, we looked at how long it took to execute the loop. To calculate
    this, we instantiated a `duration` object, which is a template class that needs
    two parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The representation**: A type representing the number of ticks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The period**: This can be (among other things) `std::nano`, `std:micro`,
    `std::milli`, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The default value for the period is `std::seconds`. Then, we just write `diff.cout()` on
    the standard output, which represents the number of milliseconds between `start`
    and `end`. An alternative way of calculating this difference is by using `duration_cast`;
    for example, `std::chrono::duration_cast<std::chrono::milliseconds> (end-start).count()`.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 4,* we print the `start` and `end` `time_point` variables in calendar
    `localtime` representation (note that the container time might not be in sync
    with the host container). To do this, we need to convert them into `time_t` by
    using the `to_time_t()` static variable of the `system_clock` class and then pass
    them to the `std::ctime` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s build and run this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b733171a-695f-4db6-b3ae-eab79b55b5d8.png)'
  prefs: []
  type: TYPE_IMG
- en: We'll learn a bit more about this recipe in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The program we developed uses the `system_clock` class. There are three clock
    classes in the `chrono` namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '`system_clock`: This represents the so-called **wall clock time***.* It can
    be adjusted at any moment, such as when an additional imprecision is introduced
    through a leap second or the user has just set it. Its epoch (that is, its starting
    point), in most implementations, uses UNIX time, which means the start counts
    from 1^(st) January 1970.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`steady_clock`: This represents the so-called **monotonic clock**. It''ll never
    be adjusted. It remains steady. In most implementations, its starting point is
    the time when the machine boots. For calculating the elapsed time of a certain
    event, you should consider using this type of clock.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`high_resolution_clock`: This is the clock with the shortest tick available.
    It might just be an alias for the `system_clock` or `steady_clock` or a completely
    different implementation. It is implementation-defined.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A second aspect to keep in mind is that the C++20 standard includes `time_of_day`,
    calendar, and time zone.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Learning the Linux timing* recipe for a brief comparison
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*A Tour of C++, Second Edition,* by Bjarne Stroustrup'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the C++20 calendar and time zone
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The C++20 standard has enriched the `std::chrono` namespace with calendar features.
    They include all the typical features you would expect, plus a more idiomatic
    and intuitive way of playing with it. This recipe will teach you about some of
    the most important features and how simple it is to interact with the calendar
    section of the `std::chrono` namespace.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s look at some code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file, ensuring that you include `<chrono>` and `<iostream>`. We
    have a date and we want to know what day of the week `bday` will fall on:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'There''s a whole set of classes that allow you to play with the calendar. Let''s
    take a look at some of them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s play with the time zone and print a list of times for different time
    zones:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'One feature that''s used often is used to find the difference between two time
    zones:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Let's go a little deeper into the `std::chrono` calendar section to learn more
    about this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a lot of calendar and time zone helper functions available in the
    new C++20 standard. This recipe just scratched the surface, but still gives us
    an understanding of how easy it is to deal with time. A reference for all the
    `std::chrono` calendar and time zone capabilities can be found at [https://en.cppreference.com/w/cpp/chrono](https://en.cppreference.com/w/cpp/chrono).
  prefs: []
  type: TYPE_NORMAL
- en: '*Step 1* uses the `weekday` method to get the day of the week (using the Gregorian
    calendar). Before calling the `weekday` method, we need to get a specific day
    and with C++20, we can just set `auto bday = January/30/2021`, which represents
    a date. Now, we can pass it to the `weekday` method to get the specific day of
    the week, which in our case is Saturday. One useful property is that we can compare
    dates, just like we can compare between the `bday` and `anotherDay` variables.
    `weekday`, as well as all the other `std::chrono` calendar methods, handles leap
    seconds.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Step 2* shows the use of the `year_month_day` and `year_month_day_last` methods.
    The library contains a whole set of classes similar to these two, for example, `month_day`
    and `month_day_lat`, and so on. They clearly have a different scope, but their
    principles remain the same. In this step, we''re interested in knowing the last
    day of February. We set the current date in the `today` variable with the `year_month_day{
    floor<days>(system_clock::now()) }` and then we pass `today` to the `year_month_day_last`
    method, which will return something like `2020/02/last`, which we store in the
    `ymdl` variable. We can use the `year_month_day` method again to get the last
    day of February. We can skip a few steps and call the `year_month_day_last` method
    directly. We performed this step for educational purposes.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Step 3* moves into the scope of time zones. The snippet of code in this step
    prints a list of time zones by iterating over the `zone_names` array. Here, we
    got the `localtime` first by looping over each time zone identified by a string.
    Then, we converted the `localtime` into the time zone that was identified by the
    `name` variable using the `zoned_time` method.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In *step 4*, we covered an interesting and recurrent problem: finding the time
    difference between two time zones. The principle doesn''t change; we still use
    the `zoned_time` method to get the local time of the two time zones, which in
    this case are `"America/New_York"` and `"Europe/London"`. Then, we subtract the
    two local times to get the difference.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `std::chrono` calendar offers a wide variety of methods that you are invited
    to explore. A complete list is available at [https://en.cppreference.com/w/cpp/chrono](https://en.cppreference.com/w/cpp/chrono).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*A Tour of C++, Second Edition*, by Bjarne Stroustrup, *Chapter 13.7, Time*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning the Linux timing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before C++11, the Standard Library did not contain any direct time-management support,
    so system developers had to use *external* sources. By external, we mean either
    an external library (for example, Boost ([https://www.boost.org/](https://www.boost.org/))) or
    OS-specific APIs. We believe it's necessary that a system developer understands
    the concept of time in terms of Linux. This recipe will help you master concepts
    such as **clock**, **time point**, and **duration** by using the POSIX standard.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we''ll write a program so that we can learn about the concepts
    of **clock**, **time point**, and **duration** in terms of Linux. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In a shell, create a new file named `linux_time_01.cpp` and add the following
    includes and function prototype:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we want to see the difference between `CLOCK_REALTIME` and `CLOCK_MONOTONIC`
    on the `clock_gettime` call. We need to define two `struct timespec` variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to print the contents of the `tsRealTime` and `tsMonoliticStart`
    variables to see the difference:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We need a task to monitor, so we''ll use a `for` loop to populate an `std::vector`.
    After that, we immediately get a time point in the `tsMonotonicEnd` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we want to print the task''s duration. To do this, we call `timespec_diff`
    (helper method) to calculate the difference between `tsMonotonicEnd` and `tsMonotonicStart`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to implement a helper method to calculate the time difference
    (that is, duration) between the times represented by the `start` and `stop` variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The preceding program shows how to gather time points to calculate the duration
    of an event. Now, let's deep dive into the details of this program.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First of all, let''s compile and execute the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f4a8718b-5a8b-46ac-a1d0-cd3365395fdf.png)'
  prefs: []
  type: TYPE_IMG
- en: We can immediately notice that the real-time clock (seconds) is way bigger than
    the monotonic clock (seconds). By doing some math, you'll notice that the first
    is about 49 years and the latter is about 12 hours. Why is that? The second observation
    is that our code took `1 second` and `644348500` nanoseconds to populate a vector
    of 100 million items. Let's gather some insights to explain this.
  prefs: []
  type: TYPE_NORMAL
- en: '*Step 1* just adds some includes and the prototype we''ve written to calculate
    the time difference.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Step 2* defined two variables, `struct timespec tsRealTime` and `struct timespec tsMonotonicStart`,
    that will be used to store the two time points. Then, we called the `clock_gettime()`
    method twice by passing `CLOCK_REALTIME` and the `tsRealTime` variable. We did
    this a second time by passing `CLOCK_MONOTONIC` with the `tsMonotonicStart` variable.
    `CLOCK_REALTIME` and `CLOCK_MONOTONIC` are both of the `clockid_t` type. When
    `clock_gettime()` is called with `CLOCK_REALTIME`, the time that we get will be
    the `wall-clock` time (or real time).'
  prefs: []
  type: TYPE_NORMAL
- en: This time point has the same issues that `std::chrono::SYSTEM_CLOCK` does, which
    we looked at in the *Learning about the C++ time interface* recipe. It can be
    adjusted (for example, if the system clock is synced with NTP), so this isn't
    suitable for calculating the elapsed time (or the duration) of an event. When
    `clock_gettime()` is called with the `CLOCK_MONOTONIC` parameter, the time does
    not adjust and most implementations make it start right from the boot of the system
    (that is, by counting the clock tick from the start of the machine). This is very
    suitable for event duration calculations.
  prefs: []
  type: TYPE_NORMAL
- en: '*Step 3* just prints the results of the time points, that is, `tsRealTime`
    and `tsMonotonicStart`. We can see that the first one contains the seconds since
    1^(st) January 1970 (about 49 years), while the latter contains the seconds since
    my machine has booted (about 12 hours).'
  prefs: []
  type: TYPE_NORMAL
- en: '*Step 4* just adds 100 million items in an `std::vector` and then gets another
    time point in `tsMonotonicEnd`, which will be used to calculate the duration of
    this event.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Step 5* calculates the difference between `tsMonotonicStart` and `tsMonotonicEnd`
    and stores the result in the `duration` variable by calling the `timespec_diff()` helper
    method.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Step 6* implements the `timespec_diff()` method, which logically calculates
    (`tsMonotonicEnd - tsMonotonicStart`).'
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the `clock_gettime()` method, we used POSIX as the counterpart set method: `clock_settime()`.
    The same is valid for `gettimeofday()`: `settimeofday()`.
  prefs: []
  type: TYPE_NORMAL
- en: It's worth highlighting that `gettimeofday()` is an extension of `time()` that
    returns a `struct timeval` (that is, seconds and microseconds). The issue with
    this method is that it can be adjusted. What does this mean? Let's imagine you
    use `usegettimeofday()` to get a time point before the event to measure, and then
    you get another time point after the event to measure. Here, you would calculate
    the difference between the two time points thinking everything is fine. What issues
    may occur here? Imagine that, between the two time points you've taken, the **Network
    Time Protocol** (**NTP**) server demands the local machine to adjust the local
    clock to get it in sync with the time server. The duration that's calculated won't
    be accurate since the time point that's taken after the event is affected by the
    NTP sync. NTP is just an example of this. The local clock can be adjusted in other
    ways too.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Learning about the C++ time interface* recipe for comparison with C++
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Linux System Programming, Second Edition*,* by *Robert Love'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dealing with time sleep and overruns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Time, in a system programming context, doesn't only involve the act of measuring
    the duration of an event or reading the clock. It's also possible to put a process
    to sleep for a certain amount of time. This recipe will teach you how to put a
    process to sleep by using the seconds*-*based API, the microseconds-based API,
    and the `clock_nanosleep()` method, which has nanosecond resolution. Furthermore,
    we'll see what time overruns are and how we can minimize them.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we''ll write a program to learn how to put a program to sleep
    by using the different POSIX APIs that are available. We''ll also look at the
    C++ alternative:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a shell and create a new file called `sleep.cpp`. We need to add some
    headers that we''ll need later:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll put the program to sleep for `1` second by using the `sleep()` method
    and the `std::chrono::steady_clock` class as time points to calculate the duration
    at the end:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look at how `nanosleep()` works. We still use `std::chrono::steady_clock`
    to calculate the duration, but we need a `struct timespec`. We''ll make the process
    sleep for about `100` milliseconds:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'A more advanced way of putting a process to sleep is by using `clock_nanosleep()`,
    which allows us to specify some interesting parameters (see the next section for
    more details):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s look at how we can put the current thread to sleep by using the
    C++ Standard Library (through the `std::this_thread::sleep_for` template method):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's go over these steps in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The program will be put to sleep in four different ways. Let''s take a look
    at the runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a3c3be5d-eca0-4e1b-97a5-1d4492bd48a0.png)'
  prefs: []
  type: TYPE_IMG
- en: '*Step 1* just contains the headers we need: `<iostream>` for the standard output
    and standard error (`cout` and `cerr`), `<chrono>` for the time points that will
    be used to measure the actual sleep, `<thread>` for the `sleep_for` method, `<unistd>`
    for `sleep()`, and `<time.h>` for `nanosleep()` and `clock_nanosleep()`.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Step 2* puts the process to sleep for `1` second by using the `sleep()` method.
    We use `steady_clock::now()` to get the time points and `duration_cast` to cast
    the difference and get the actual duration. To be precise, `sleep()` returns `0`
    if the process has successfully slept for at least the amount of time specified,
    but it can return a value between 0 and the seconds specified, which would represent
    the time **not** slept.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Step 3* shows how to put a process to sleep by using `nanosleep()`. We decided
    to use this method since `usleep()` has been deprecated on Linux. `nanosleep()`
    has an advantage over `sleep()` since it has nanosecond resolution and `POSIX.1b` is
    standardized. `nanosleep()` returns `0` on success and `-1` in the case of an
    error. It does this by setting the `errno` global variable to the specific error
    that occurred. The `struct timespec` variable contains `tv_sec` and `tv_nsec`
    (seconds and nanoseconds).'
  prefs: []
  type: TYPE_NORMAL
- en: '*Step 4* uses a more sophisticated `clock_nanosleep()`. This method contains
    two parameters we haven''t looked at yet. The first parameter is `clock_id` and
    accepts, among other things, `CLOCK_REALTIME` and `CLOCK_MONOTONIC`, which we
    looked at in the previous recipes. As a rule of thumb, you want to use the first
    if you''re sleeping until an absolute time (wall-clock time) and the second if
    you''re sleeping until a relative time value. This makes sense based on what we
    saw in the previous recipe.'
  prefs: []
  type: TYPE_NORMAL
- en: The second parameter is a flag; it can be `TIME_ABSTIME` or `0`. If the first
    one is passed, the `reqClockSleep` variable will be treated as absolute, but if
    `0` is passed, then it'll be treated as relative. To clarify the concept of absolute
    time further, it might come from a previous call of `clock_gettime()` that stores
    an absolute time point in a variable, say `ts`. By adding `2` seconds to it, we
    can pass `&ts` (that is, the address of the variable `ts`) to `clock_nanosleep()`,
    which will wait until that specific absolute time.
  prefs: []
  type: TYPE_NORMAL
- en: '*Step 5* puts the current thread of the process to sleep (in this case, the
    current thread is the main thread, so the whole process will sleep) for 1.5 seconds
    (1,500 milliseconds = 1.5 seconds). `std::this_thread::sleep_for` is simple and
    effective. It is a template method that takes in one parameter as input; that
    is, the `duration`, which needs the representation type and the period (`_Rep` and
    `_Period`), as we saw in the *Learning the C++ time interface* recipe. In this
    case, we only passed the period in milliseconds and left the representation in
    its default state.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is an issue we should be aware of here: the **time** **overrun**. All
    the interfaces we''ve used in this recipe guarantee that the process will sleep
    *at least as long as requested*. They''ll return an error otherwise. They might
    sleep for a time slightly longer than the time we requested for different reasons.
    One reason might be due to the scheduler that selects a different task to run.
    This problem occurs when the granularity of the timer is greater than the time
    that was requested. Think, for example, about the time that''s shown by the timer
    (`10msec`) and that the sleep time is `5 msec`. We might have a case where the
    process has to wait `5` milliseconds more than expected, which is 100% longer.
    Time overrun can be mitigated by using methods that support high-precision time
    sources, such as `clock_nanosleep()`, `nanosleep()`, and `std::this_thread::sleep_for()`.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We didn't explicitly mention the thread implications for `nanosleep()` and `clock_nanosleep()`.
    Both methods cause the current thread to sleep. Sleep on Linux means that the
    thread (or the process, if it is a single-threaded application) will enter a **Not
    Runnable** state so that the CPU can continue with other tasks (remember that
    Linux does not differentiate between threads and processes).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*The Learning the C++ time interface* recipe for a review of the `std::chrono::duration<>` template
    class'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Learning the Linux timing* recipe for a review of the concepts of **REALTIME**
    and **MONOTONIC**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
