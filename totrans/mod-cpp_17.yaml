- en: Algorithms and Data Structures
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problems
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here are the problem-solving sections for this chapter.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 45\. Priority queue
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Write a data structure that represents a priority queue that provides constant
    time lookup for the largest element, but has logarithmic time complexity for adding
    and removing elements. A queue inserts new elements at the end and removes elements
    from the top. By default, the queue should use `operator<` to compare elements,
    but it should be possible for the user to provide a comparison function object
    that returns `true` if the first argument is less than the second. The implementation
    must provide at least the following operations:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: '`push()` to add a new element'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pop()` to remove the top element'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`top()` to provide access to the top element'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`size()` to indicate the number of elements in the queue'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`empty()` to indicate whether the queue is empty'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 46\. Circular buffer
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a data structure that represents a circular buffer of a fixed size.
    A circular buffer overwrites existing elements when the buffer is being filled
    beyond its fixed size. The class you must write should:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Prohibit default construction
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support the creation of objects with a specified size
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allow checking of the buffer capacity and status (`empty()`, `full()`, `size()`, `capacity()`)
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a new element, an operation that could potentially overwrite the oldest
    element in the buffer
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remove the oldest element from the buffer
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support iteration through its elements
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 47\. Double buffer
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Write a class that represents a buffer that could be written and read at the
    same time without the two operations colliding. A read operation must provide
    access to the old data while a write operation is in progress. Newly written data
    must be available for reading upon completion of the write operation.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: 48\. The most frequent element in a range
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Write a function that, given a range, returns the most frequent element and
    the number of times it appears in the range. If more than one element appears
    the same maximum number of times then the function should return all the elements.
    For instance, for the range `{1,1,3,5,8,13,3,5,8,8,5}`, it should return `{5,
    3}` and `{8, 3}`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: 49\. Text histogram
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Write a program that, given a text, determines and prints a histogram with the
    frequency of each letter of the alphabet. The frequency is the percentage of the
    number of appearances of each letter from the total count of letters. The program
    should count only the appearances of letters and ignore digits, signs, and other
    possible characters. The frequency must be determined based on the count of letters
    and not the text size.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: 50\. Filtering a list of phone numbers
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Write a function that, given a list of phone numbers, returns only the numbers
    that are from a specified country. The country is indicated by its phone country
    code, such as 44 for Great Britain. Phone numbers may start with the country code,
    a `+` followed by the country code, or have no country code. The ones from this
    last category must be ignored.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: 51\. Transforming a list of phone numbers
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Write a function that, given a list of phone numbers, transforms them so they
    all start with a specified phone country code, preceded by the `+` sign. Any whitespaces
    from a phone number should also be removed. The following is a list of input and
    output examples:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 52\. Generating all the permutations of a string
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Write a function that, prints on the console all the possible permutations
    of a given string. You should provide two versions of this function: one that
    uses recursion, and one that does not.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: 53\. Average rating of movies
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Write a program that calculates and prints the average rating of a list of movies.
    Each movie has a list of ratings from 1 to 10 (where 1 is the lowest and 10 is
    the highest rating). In order to compute the rating, you must remove 5% of the
    highest and lowest ratings before computing their average. The result must be
    displayed with a single decimal point.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: 54\. Pairwise algorithm
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Write a general-purpose function that, given a range, returns a new range with
    pairs of consecutive elements from the input range. Should the input range have
    an odd number of elements, the last one must be ignored. For example, if the input
    range was `{1, 1, 3, 5, 8, 13, 21}`, the result must be `{ {1, 1}, {3, 5}, {8,
    13}}`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: 55\. Zip algorithm
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Write a function that, given two ranges, returns a new range with pairs of elements
    from the two ranges. Should the two ranges have different sizes, the result must
    contain as many elements as the smallest of the input ranges. For example, if
    the input ranges were `{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }` and `{ 1, 1, 3, 5, 8,
    13, 21 }`, the result should be `{{1,1}, {2,1}, {3,3}, {4,5}, {5,8}, {6,13}, {7,21}}`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: 56\. Select algorithm
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Write a function that, given a range of values and a projection function, transforms
    each value into a new one and returns a new range with the selected values. For
    instance, if you have a type book that has an `id`, `title`, and `author`, and
    have a range of such book values, it should be possible for the function to select
    only the title of the books. Here is an example of how the function should be
    used:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 57\. Sort algorithm
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Write a function that, given a pair of random-access iterators to define its
    lower and upper bounds, sorts the elements of the range using the quicksort algorithm.
    There should be two overloads of the sort function: one that uses `operator<` to
    compare the elements of the range and put them in ascending order, and one that
    uses a user-defined binary comparison function for comparing the elements.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: 58\. The shortest path between nodes
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Write a program that, given a network of nodes and the distances between them,
    computes and displays the shortest distance from a specified node to all the others,
    as well as the path between the start and end node. As input, consider the following
    undirected graph:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2fe0878c-3372-40bf-a988-81c9d47ab199.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
- en: 'The program output for this graph should be the following:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 59\. The Weasel program
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Write a program that implements Richard Dawkins'' weasel computer simulation,
    described in Dawkins'' words as follows (*The Blind Watchmaker*, chapter 3):'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: We again use our computer monkey, but with a crucial difference in its program.
    It again begins by choosing a random sequence of 28 letters, just as before ...
    it duplicates it repeatedly, but with a certain chance of random error – 'mutation'
    – in the copying. The computer examines the mutant nonsense phrases, the 'progeny'
    of the original phrase, and chooses the one which, however slightly, most resembles
    the target phrase, METHINKS IT IS LIKE A WEASEL.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: 60\. The Game of Life
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Write a program that implements the *Game of Life* cellular automaton proposed
    by *John Horton Conway*. The universe of this game is a grid of square cells that
    could have one of two states: dead or alive. Every cell interacts with its adjacent
    neighbors, with the following transactions occurring on every step:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Any live cell with fewer than two live neighbors dies, as if caused by under-population
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any live cell with two or three live neighbors lives on to the next generation
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any live cell with more than three live neighbors dies, as if by overpopulation
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any dead cell with exactly three live neighbors becomes a live cell, as if by
    reproduction
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The status of the game on each iteration should be displayed on the console,
    and for convenience, you should pick a reasonable size, such as 20 rows x 50 columns.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Solutions
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here are the solutions for the above problem-solving sections.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: 45\. Priority queue
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A priority queue is an abstract data type whose elements have a priority attached
    to them. Instead of working as a first-in-first-out container, a priority queue
    makes elements available in the order of their priority. This data structure is
    used in algorithms such as Dijkstra's shortest path, Prim's algorithm, heap sort,
    the A* search algorithm, in Huffman codes used for data compression, and others.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: A very simple approach to implement a priority queue would be to use an `std::vector` as
    the underlying container of elements and always maintain it sorted. That means
    the maximum and minimum elements are always at the two ends. However, this approach
    does not provide the most efficient operations.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: 'The most suitable data structure that can be used to implement a priority queue
    is a heap. This is a tree-based data structure that satisfies the following property:
    if *P* is a parent node of *C*, then the key (the value) of *P* is either greater
    than or equal to (in a max heap) or less than or equal to (in a min heap) the
    key of *C*.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: 'The standard library provides several operations for working with heaps:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '`std::make_heap()`: This creates a max heap for the given range, using either `operator<` or
    a user-provided comparison function to order the elements'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::push_heap()`: This inserts a new element at the end of the max heap'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std::pop_heap()`: This removes the first element of the heap (by swapping
    the values in the first and last position and making the sub-range `[first, last-1)` a
    max heap)'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A priority queue implementation, that uses `std::vector` to hold data and the
    standard functions for heaps, can look as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This class can be used as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 46\. Circular buffer
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A circular buffer is a fixed-size container that behaves as if its two ends
    were connected to form a virtual circular memory layout. Its main benefit is that
    you don't need a large amount of memory to retain data, as older entries are overwritten
    by newer ones. Circular buffers are used in I/O buffering, bounded logging (when
    you only want to retain the last messages), buffers for asynchronous processing,
    and others.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: 'We can differentiate between two situations:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: The number of elements added to the buffer has not reached its capacity (its
    user-defined fixed size). In this case, it behaves likes a regular container,
    such as a vector.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The number of elements added to the buffer has reached and exceeded its capacity.
    In this case, the buffer's memory is reused and older elements are being overwritten.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We could represent such a structure using:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: A regular container with a pre-allocated number of elements
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A head pointer to indicate the position of the last inserted element
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A size counter to indicate the number of elements in the container, which cannot
    exceed its capacity (since elements are being overwritten in this case)
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The two main operations with a circular buffer are:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: Adding a new element to the buffer. We always insert at the next position of
    the head pointer (or index). This is the `push()` method shown below.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removing an existing element from the buffer. We always remove the oldest element.
    That element is at position `head - size` (this must account for the circular
    nature of the index). This is the `pop()` method shown below.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The implementation of such a data structure is shown here:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Because of the circular nature of the indexes mapped on a contiguous memory
    layout, the iterator type for this class cannot be a pointer type. The iterators
    must be able to point elements by applying modulo operations on the index. Here
    is a possible implementation for such an iterator:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'With all these implemented, we could write code such as the following. Notice
    that in the comments, the first range shows the actual content of the internal
    vector, and the second range shows the logical content as exposed with iterator
    access:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 47\. Double buffer
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The problem described here is a typical double buffering situation. Double buffering
    is the most common case of multiple buffering, which is a technique that allows
    a reader to see a complete version of the data and not a partially updated version
    produced by a writer. This is a common technique – especially in computer graphics
    – for avoiding flickering.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to implement the requested functionality, the buffer class that we
    should write must have two internal buffers: one that contains temporary data
    being written, and another one that contains completed (or committed) data. Upon
    the completion of a write operation, the content of the temporary buffer is written
    in the primary buffer. For the internal buffers, the implementation below uses `std::vector`.
    When the write operation completes, instead of copying data from one buffer to
    the other, we just swap the content of the two, which is a much faster operation.
    Access to the completed data is provided with either the `read()` function, which
    copies the content of the read buffer into a designated output, or with direct
    element access (overloaded `operator[]`). Access to the read buffer is synchronized
    with an `std::mutex` to make it safe to read from one thread while another is
    writing to the buffer:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The following is an example of how this double buffer class can be used for
    both writing and reading by two different entities:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 48\. The most frequent element in a range
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to determine and return the most frequent element in a range you should
    do the following:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: Count the appearances of each element in an `std::map`. The key is the element
    and the value is its number of appearances.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Determine the maximum element of the map using `std::max_element()`. The result
    is a map element, that is, a pair containing the element and its number of appearances.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copy all map elements that have the value (appearance count) equal to the maximum
    element's value and return that as the final result.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An implementation of the steps described previously is shown in the following
    listing:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `find_most_frequent()` function can be used as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 49\. Text histogram
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A histogram is a representation of the distribution of numerical data. Widely
    known histograms are the color and image histograms that are used in photography
    and image processing. A text histogram, as described here, is a representation
    of the frequency of letters in a given text. This problem is partially similar
    to the previous one, except that the range elements are characters now and we
    must determine the frequency of them all. To solve this problem you should:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: Count the appearances of each letter using a map. The key is the letter and
    the value is its appearance count.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When counting, ignore all characters that are not letters. Uppercase and lowercase
    characters must be treated as identical, as they represent the same letter.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `std::accumulate()` to count the total number of appearances of all the
    letters in the given text.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `std::for_each()` or a range-based `for` loop to go through all the elements
    of the map and transform the appearance count into a frequency.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is a possible implementation of the problem:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The following program prints the frequency of the letters from a text on the
    console:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 50\. Filtering a list of phone numbers
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The solution to this problem is relatively simple: you have to iterate through
    all the phone numbers and copy to a separate container (such as an `std::vector`)
    the phone numbers that start with the country code. If the specified country code
    is, for instance, 44, then you must check for both 44 and +44\. Filtering the
    input range in this manner is possible using the `std::copy_if()` function. A
    solution to this problem is shown here:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This is how this function can be used:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 51\. Transforming a list of phone numbers
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This problem is somewhat similar in some aspects to the previous one. However,
    instead of selecting phone numbers that start with a specified country code, we
    must transform each number so that they all start with that country code preceded
    by a `+`. There are several cases that must be considered:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: The phone number starts with a 0\. That indicates a number without a country
    code. To modify the number to include the country code we must replace the 0 with
    the actual country code, preceded by `+`.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The phone number starts with the country code. In this case, we just prepend
    `+` sign to the beginning.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The phone number starts with `+` followed by the country code. In this case,
    the number is already in the expected format.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: None of these cases applies, therefore the result is obtained by concatenating
    the country code preceded by `+` and the phone number.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For simplicity, we will ignore the possibility that the number is actually prefixed
    with another country code. You can take it as a further exercise to modify the
    implementation so that it can handle phone numbers with a different country prefix.
    These numbers should be removed from the list.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: In all of the preceding cases, it is possible that the number could contain
    spaces. According to the requirements, these must be removed. The `std::remove_if()`
    and `isspace()` functions are used for this purpose.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an implementation of the described solution:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The following program normalizes a given list of phone numbers according to
    the requirement and prints them on the console:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 52\. Generating all the permutations of a string
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can solve this problem by taking advantage of some general-purpose algorithms
    from the standard library. The simplest of the two required versions is the non-recursive
    one, at least when you use `std::next_permutation()`. This function transforms
    the input range (that is required to be sorted) into the next permutation from
    the set of all possible permutations, ordered lexicographically with `operator<`
    or the specified comparison function object. If such a permutation exists then
    it returns `true`, otherwise, it transforms the range into the first permutation
    and returns `false`. Therefore, a non-recursive implementation based on `std::next_permuation()`
    looks like this:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The recursive alternative is a little bit more complex. One way to implement
    it is to have an input and output string; initially, the input string is the string
    for which we want to generate permutations and the output string is empty. We
    take one character at a time from the input string and put it in the output string.
    When the input string becomes empty, the output string represents the next permutation.
    The recursive algorithm for doing this is the following:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: If the input string is empty, then print the output string and return
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Otherwise iterate through all the characters in the input string, and for each
    element:'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Call the method recursively by removing the first character from the input string
    and concatenating it at the end of the output string
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rotate the input string so that the first character becomes the last, the second
    becomes the first, and so on
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This algorithm is visually explained in the following diagram:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bbcdafcd-a3e0-4a0c-9b79-9f465a5a4602.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
- en: 'For rotating the input string, we could use the standard library function `std::rotate()`,
    which performs a left rotation on a range of elements. An implementation of the
    described recursive algorithm looks like this:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This is how both of these implementations can be used:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 53\. Average rating of movies
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The problem requires the computing of a movie rating using a truncated mean.
    This is a statistical measure of a central tendency where the mean is calculated
    after discarding parts of a probability distribution or sample at the high and
    low ends. Typically, this is done by removing an equal amount of points at the
    two ends. For this problem, you are required to remove 5% of both the highest
    and lowest user ratings.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: 'A function that calculates a truncated mean for a given range should do the
    following:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: Sort the range so that elements are ordered (either ascending or descending)
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remove the required percentage of elements at both ends
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Count the sum of all remaining elements
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compute the average by dividing the sum to the remaining count of elements
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `truncated_mean()` function shown here implements the described algorithm:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'A program that uses this function in order to calculate and print movie average
    ratings may look like the following:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 54\. Pairwise algorithm
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The pairwise function proposed for this problem must pair adjacent elements
    of an input range and produce `std::pair` elements that are added to an output
    range. The following code listing provides two implementations:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: 'A general function template that takes iterators as arguments: a begin and
    end iterator define the input range, and an output iterator defines the position
    in the output range where the results are to be inserted'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An overload that takes an `std::vector<T>` as the input argument and returns
    an `std::vector<std::pair<T, T>>` as the result; this one simply calls the first
    overload:'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The following program pairs the elements of a vector of integers and prints
    the pairs on the console:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 55\. Zip algorithm
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This problem is relatively similar to the previous one, although there are
    two input ranges instead of just one. The result is again a range of `std::pair`.
    However, the two input ranges may hold elements of different types. Again, the
    implementation shown here contains two overloads:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: A general-purpose function with iterators as arguments. A begin and end iterator
    for each input range define its bounds, and an output iterator defines the position
    in the output range where the result must be written.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A function that takes two `std::vector` arguments, one that holds elements
    of type `T` and one that holds elements of type `U` and returns an `std::vector<std::pair<T,
    U>>`. This overload simply calls the previous one:'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In the following listing, you can see two vectors of integers zipped together
    and the result printed on the console:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 56\. Select algorithm
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `select()` function that you have to implement takes an `std::vector<T>`
    as an input argument and a function of type `F` and returns a `std::vector<R>`
    as the result, where `R` is the result of applying `F` to `T`. We could use `std::result_of()`
    to deduce the return type of an invoke expression at compile time. Internally,
    the `select()` function should use `std::transform()` to iterate over the elements
    of the input vector, apply function `f` to each element, and insert the result
    in an output vector.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: 'The following listing shows the implementation for this function:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This function can be used as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 57\. Sort algorithm
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Quicksort** is a comparison sorting algorithm for elements of an array for
    which a total order is defined. When implemented well, it is significantly faster
    than *merge sort* or *heap sort*.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: 'Although in worst-case scenarios the algorithm makes ![](img/66508cd7-1912-4285-bee6-c31db3d8d58c.png)
    comparisons (when the range is already sorted), on average the complexity is only
    ![](img/0ce17681-465d-4ac5-9b80-114f13fa5f2c.png). Quicksort is a divide and conquer
    algorithm; it partitions (divides) a large range into smaller ones and sorts them
    recursively. There are several partitioning schemes. In the implementation shown
    here, we use the original one developed by *Tony Hoare*. The algorithm for this
    scheme is described in pseudocode as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'A general-purpose implementation of the algorithm should use iterators and
    not arrays and indexes. The requirement for the following implementation is that
    the iterators are random-access (so they could be moved to any element in constant
    time):'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `quicksort()` function, shown as follows, can be used to sort various types
    of containers:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The requirement was that the sorting algorithm must allow the specifying of
    a user-defined comparison function. The only change, in this case, is the partitioning
    function, where instead of using `operator <` and `>` to compare the current element
    with the pivot, we use the user-defined comparison function:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'With this overload we could sort a range in descending order, as shown in the
    following example:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'It is possible to implement an iterative version of the quicksort algorithm
    also. The performance of the iterative version is the same as for the recursive
    version ![](img/816b6538-e697-4a62-ac80-04b85d52d611.png) for most cases, but
    degrading to ![](img/b96ce493-f107-43e9-b495-222dc77e2530.png) in the worst case
    when the range is already sorted). Converting from the recursive version of the
    algorithm to an iterative one is relatively simple; it is done by using a stack
    to emulate the recursive calls and to store the bounds of the partitions. The
    following is an iterative implementation of the version that uses `operator<`
    to compare elements:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This iterative implementation can be used just like its recursive counterpart:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 58\. The shortest path between nodes
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To solve the proposed problem you must use the Dijkstra algorithm for finding
    the shortest path in a graph. Although the original algorithm finds the shortest
    path between two given nodes, the requirement here is to find the shortest path
    between one specified node and all the others in the graph, which is another version
    of the algorithm.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: 'An efficient way to implement the algorithm is using a priority queue. The
    pseudocode for the algorithm (see [https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm](https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm))
    is the following:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'To represent the graph we could use the following data structure, which can
    be used for both directional or unidirectional graphs. The class provides support
    for adding new vertices and edges, and can return the list of vertices and the
    neighbors of a specified vertex (that is, both the nodes and the distance to them):'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The implementation of the shortest path algorithm as described in the preceding
    pseudocode could look like the following. An `std::set` (that is, a self-balancing
    binary search tree) is used instead of the priority queue. `std::set` has the
    same ![](img/aeeb1f10-1443-45f7-83fb-94ec84dfcbc1.png) complexity for adding and
    removing the top element as a binary heap (used for a priority queue). On the
    other hand, `std::set` also allows finding and removing any other element in ![](img/22931c36-91c7-4cb4-912a-7a88cf095103.png), which
    is helpful in order to implement the decrease-key step in logarithmic time by
    removing and inserting again:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The following helper functions print the results in the specified format:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The following program solves the given task:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 59\. The Weasel program
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Weasel program is a thought experiment proposed by Richard Dawkins, intended
    to demonstrate how the accumulated small improvements (mutations that bring a
    benefit to the individual so that it is chosen by natural selection) produce fast
    results as opposed to the mainstream misinterpretation that evolution happens
    in big leaps. The algorithm for the Weasel simulation, as described on Wikipedia
    (see [https://en.wikipedia.org/wiki/Weasel_program](https://en.wikipedia.org/wiki/Weasel_program)),
    is as follows:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: Start with a random string of 28 characters.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make 100 copies of this string, with a 5% chance per character of that character
    being replaced with a random character.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compare each new string with the target METHINKS IT IS LIKE A WEASEL, and give
    each a score (the number of letters in the string that are correct and in the
    correct position).
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If any of the new strings has a perfect score (28), then stop.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Otherwise, take the highest-scoring string and go to step 2.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A possible implementation is as follows. The `make_random()` function creates
    a random starting sequence of the same length as the target; the `fitness()` function
    computes the score of each mutated string (that is, resemblance with the target);
    the `mutate()` function produces a new string from a parent with a given chance
    for each character to mutate:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This is how the class can be used:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 60\. The Game of Life
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The class `universe` presented below implements the game as described. There
    are several functions of interest:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '`initialize()` generates a starting layout; although the code accompanying
    the book contains more options, only two are listed here: `random`, which generates
    a random layout, and `ten_cell_row`, which represents a line of 10 cells in the
    middle of the grid.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`initialize()` 生成一个起始布局；尽管书中的代码包含更多选项，但这里只列出了两个：`random`，生成一个随机布局，和 `ten_cell_row`，表示网格中间的
    10 个细胞的一行。'
- en: '`reset()` sets all the cells as `dead`.'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reset()` 将所有细胞设置为 `dead`。'
- en: '`count_neighbors()` returns the number of alive neighbors. It uses a helper
    variadic function template `count_alive()`. Although this could be implemented
    with fold expressions, this is not yet supported in Visual C++ and therefore I
    have opted not to use it here.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`count_neighbors()` 返回活着的邻居数量。它使用一个辅助的可变函数模板 `count_alive()`。虽然这可以用折叠表达式实现，但在
    Visual C++ 中尚不支持，因此我选择不在这里使用它。'
- en: '`next_generation()` produces a new state of the game based on the transition
    rules.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`next_generation()` 根据过渡规则产生游戏的新状态。'
- en: '`display()` shows the game status on the console; this uses a system call to
    erase the console, although you could use other means to do so, such as specific
    operating system APIs.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`display()` 在控制台上显示游戏状态；这使用系统调用来擦除控制台，尽管您可以使用其他方法来做到这一点，比如特定的操作系统 API。'
- en: '`run()` initializes the starting layout and then produces a new generation
    at a user-specified interval, for a user-specified number of iterations, or indefinitely
    (if the number of iterations was set to 0).'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`run()` 初始化起始布局，然后以用户指定的间隔产生新的一代，进行用户指定次数的迭代，或者无限期地进行（如果迭代次数设置为 0）。'
- en: '[PRE43]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This is how the game can be run for 100 iterations starting from a random state:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何从随机状态开始运行 100 次迭代的游戏：
- en: '[PRE44]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Here is an example of the program output (the screenshot represents a single
    iteration in the Game of Life''s universe):'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是程序输出的一个示例（屏幕截图表示生命游戏宇宙中的单次迭代）：
- en: '![](img/9f48c4ae-d266-4151-b814-33bf8473953b.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9f48c4ae-d266-4151-b814-33bf8473953b.png)'
