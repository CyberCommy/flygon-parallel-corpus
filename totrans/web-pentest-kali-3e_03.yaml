- en: Reconnaissance and Profiling the Web Server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Over the years, malicious attackers have found various ways to penetrate a system.
    They gather information about the target, identify vulnerabilities, and then unleash
    an attack. Once inside the target, they try to hide their tracks and remain hidden.
    The attacker may not necessarily follow the same sequence as we do, but as a penetration
    tester, following the approach suggested here will help you conduct the assessment
    in a structured way; also, the data collected at each stage will aid in preparing
    a report that is of value to your client. An attacker's aim is ultimately to own
    your system; so, they might not follow any sequential methodology to do this.
    As a penetration tester, your aim is to identify as many bugs as you can; therefore,
    following a logical methodology is really useful. Moreover, you need to be creative
    and think outside the box.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the different stages of a penetration test:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Reconnaissance**: This involves investigating publicly available information
    and getting to know the target''s underlying technologies and relationships between
    components'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scanning**: This involves finding possible openings or vulnerabilities in
    the target through manual testing or automated scanning'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Exploitation**: This involves exploiting vulnerabilities, compromising the
    target, and gaining access'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Maintaining access (post-exploitation)**: Setting up the means to escalate
    privileges on the exploited assets or access in alternative ways; installing backdoors,
    exploiting local vulnerabilities, creating users, and other methods'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Covering tracks**: This involves removing evidence of the attack; usually,
    professional penetration testing doesn''t involve this last stage, as being able
    to rebuild the path followed by the tester gives valuable information to defensive
    teams and helps build up the security level of the targets'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reconnaissance and scanning are the initial stages of a penetration test. The
    success of the penetration test depends greatly on the quality of the information
    gathered during these phases. In this chapter, you will work as a penetration
    tester and extract information using both passive and active reconnaissance techniques.
    You will then probe the target using the different tools provided with Kali Linux
    to extract further information and to find some vulnerabilities using automated
    tools.
  prefs: []
  type: TYPE_NORMAL
- en: Reconnaissance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Reconnaissance** is a term used by defense forces, and it means obtaining
    information about the enemy in a way that does not alert them. The same concept
    is applied by attackers and penetration testers to obtain information related
    to the target. Information gathering is the main goal of reconnaissance. Any information
    gathered at this initial stage is considered important. The attacker working with
    malicious content builds on the information learned during the reconnaissance
    stage and gradually moves ahead with the exploitation. A small bit of information
    that appears innocuous may help you in highlighting a severe flaw in the later
    stages of the test. A valuable skill for a penetration tester is to be able to
    chain together vulnerabilities that may be low risk by themselves, but that represent
    a high impact if assembled.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The aim of reconnaissance in a penetration test includes the following tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Identifying the IP address, domains, subdomains, and related information using
    Whois records, search engines, and DNS servers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accumulating information about the target website from publicly available resources
    such as Google, Bing, Yahoo!, and Shodan. Internet Archive ([https://archive.org/](https://archive.org/)),
    a website that acts as a digital archive for all of the web pages on the internet,
    can reveal some very useful information in the reconnaissance phase. The website
    has been archiving cached pages since 1996\. If the target website was created
    recently, however, it will take some time for Internet Archive to cache it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identifying people related to the target with the help of social networking
    sites, such as LinkedIn, Facebook, Flick, Instagram, or Twitter, as well as tools
    such as Maltego.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Determining the physical location of the target using a Geo IP database, satellite
    images from Google Maps, and Bing Maps.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manually browsing the web application and creating site maps to understand the
    flow of the application and spidering using tools such as Burp Suite, HTTP Track,
    and ZAP Proxy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In web application penetration testing, reconnaissance may not be so extensive.
    For example, in a gray box approach, most of the information that can be gathered
    at this stage is provided by the client; also, the scope may be strictly limited
    to the target application running in a testing environment. For the sake of completeness,
    in this book we will take a generalist approach.
  prefs: []
  type: TYPE_NORMAL
- en: Passive reconnaissance versus active reconnaissance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reconnaissance in the real sense should always be *passive*. This means that
    reconnaissance should never interact directly with the target, and that it should
    gather all of the information from third-party sources. In practical implementation,
    however, while doing a reconnaissance of a web application, you will often interact
    with the target to obtain the most recent changes. Passive reconnaissance depends
    on cached information, and it may not include the recent changes made on the target.
    Although you can learn a lot using the publicly available information related
    to the target, interacting with the website in a way that does not alert the firewalls
    and intrusion prevention devices should always be included in the scope of this
    stage.
  prefs: []
  type: TYPE_NORMAL
- en: Some penetration testers believe that passive reconnaissance should include
    browsing the target URL and navigating through the publicly available content;
    however, others would contend that it should not involve any network packets targeted
    to the actual website.
  prefs: []
  type: TYPE_NORMAL
- en: Information gathering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As stated earlier, the main goal of reconnaissance is to gather information
    while avoiding detection and alerts on intrusion-detection mechanisms. Passive
    reconnaissance is used to extract information related to the target from publicly
    available resources. In a web application penetration test, to begin you will
    be given a URL. You will then scope the entire website and try to connect the
    different pieces. Passive reconnaissance is also known as **Open Source Intelligence**
    (**OSINT**) gathering.
  prefs: []
  type: TYPE_NORMAL
- en: In a black box penetration test, where you have no previous information about
    the target and have to approach it like an uninformed attacker, reconnaissance
    plays a major role. The URL of a website is the only thing you have, to expand
    your knowledge about the target.
  prefs: []
  type: TYPE_NORMAL
- en: Domain registration details
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every time you register a domain, you have to provide details about your company
    or business, such as the name, phone number, mailing address, and specific email
    addresses for technical and billing purposes. The domain registrar will also store
    the IP address of your authoritative DNS servers.
  prefs: []
  type: TYPE_NORMAL
- en: An attacker who retrieves this information can use it with malicious intent.
    Contact names and numbers provided during registration can be used for social
    engineering attacks such as duping users via telephone. Mailing addresses can
    help the attacker perform wardriving and find unsecured wireless access points.
    The New York Times was attacked in 2013 when its DNS records were altered by a
    malicious attacker conducting a phishing attack against the domain reseller for
    the registrar that managed the domain. Altering DNS records has a serious effect
    on the functioning of a website as an attacker can use it to redirect web traffic
    to a different server, and rectified changes can take up to 72 hours to reach
    all of the public DNS servers spread across the globe.
  prefs: []
  type: TYPE_NORMAL
- en: Whois – extracting domain information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Whois records** are used to retrieve the registration details provided by
    the domain owner to the domain registrar. It is a protocol that is used to extract
    information about the domain and the associated contact information. You can view
    the name, address, phone number, and email address of the person/entity who registered
    the domain. Whois servers are operated by **Regional Internet Registrars** (**RIR**),
    and they can be queried directly over port `43`. In the early days of the internet,
    there was only one Whois server, but the number of existing Whois servers has
    increased with the expansion of the internet. If the information for the requested
    domain is not present on the queried server, the request is then forwarded to
    the Whois server of the domain registrar and the results are returned to the end
    client. A Whois tool is built into Kali Linux, and it can be run from Terminal.
    The information retrieved by the tool is only as accurate as the information updated
    by the domain owner, and it can be misleading at times if the updated details
    on the registrar website are incorrect. Also, domain owners can block sensitive
    information related to your domain by subscribing to additional services provided
    by the domain registrar, after which the registrar would display their details
    instead of the contact details of your domain.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `whois` command followed by the target domain name should display some
    valuable information. The output will contain the registrar name and the Whois
    server that returned the information. It will also display when the domain was
    registered and the expiration date, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00035.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'If the domain administrator fails to renew the domain before the expiration
    date, the domain registrar releases the domain, which can then be bought by anyone.
    The output also points out the DNS server for the domain, which can further be
    queried to find additional hosts in the domain:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00036.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Identifying related hosts using DNS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once you have the name of the authoritative DNS server, you can use it to identify
    additional hosts in the domain. A DNS zone may not necessarily only contain entries
    for web servers. On the internet, every technology that requires hostnames to
    identify services uses DNS. The mail server and FTP server use DNS to resolve
    hosts to IP addresses. By querying the DNS server, you can identify additional
    hosts in the target organization; it will also help you in identifying additional
    applications accessible from the internet. The records of `citrix.target-domain.com`
    or `webmail.target-domain.com` can lead you to the additional applications accessible
    from the internet.
  prefs: []
  type: TYPE_NORMAL
- en: Zone transfer using dig
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: DNS servers usually implement replication (that is, for primary and secondary
    servers) to improve availability. In order to synchronize the host resolution
    database from primary to secondary, an operation called **zone transfer** takes
    place. The secondary server requests the zone (portion of the domain for which
    that server is responsible) data from the primary, and this responds with a copy
    of the database, containing the IP address-hostname pairs that it can resolve.
  prefs: []
  type: TYPE_NORMAL
- en: A misconfiguration in DNS servers allows for anyone to ask for a zone transfer
    and obtain the full list of resolved hosts of these servers. Using the **Domain
    Internet Groper** (**dig**) command-line tool in Linux, you can try to execute
    a zone transfer to identify additional hosts in the domain. Zone transfers are
    done over TCP port `53` and not UDP port `53`, which is the standard DNS port.
  prefs: []
  type: TYPE_NORMAL
- en: The `dig` command-line tool is mainly used for querying DNS servers for hostnames.
    A simple command such as `dig google.com` reveals the IP address of the domain
    and the name of the DNS server that hosts the DNS zone for it (also known as the
    name server). There are many types of DNS records, such as **Mail Exchanger**
    (**MX**), SRV records, and PTR records. The `dig google.com mx` command displays
    information for the MX record.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the usual DNS tasks, the `dig` command can also be used to perform
    a DNS zone transfer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s request a zone transfer to `zonetransfer.me`, a vulnerable domain made
    for educational purposes by Robin Wood (DigiNinja). The request is made using
    the `dig` command, for the AXFR (zone transfer) register of the `zonetransfer.me` domain to
    the `nsztm1.digi.ninja` server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in the following screenshot, if zone transfer is enabled, the `dig`
    tool dumps all of the entries in the zone at Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00037.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Shell commands, such as `grep` or `cut`, are very useful for processing the
    output of command-line tools. In the preceding example, `cut` is used with a `|` (pipe)
    character to show only the first three elements that are separated by a `-d "
    "` (space) character from each line of the `dig` command's results. In this screenshot,
    the columns are separated by tab characters and information shown in the last
    column is separated by spaces.
  prefs: []
  type: TYPE_NORMAL
- en: You will often find that even though the primary DNS server blocks the zone
    transfer, a secondary server for that domain might allow it. The `dig google.com
    NS +noall +answer` command will display all of the name servers for that domain.
  prefs: []
  type: TYPE_NORMAL
- en: 'The attempt to perform a zone transfer from the DNS server of `facebook.com`
    failed, as the company have correctly locked down their DNS servers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00038.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Performing a DNS lookup to search for an IP address is passive reconnaissance.
    However, the moment you do a zone transfer using a tool such as `dig` or `nslookup`,
    it turns into active reconnaissance.
  prefs: []
  type: TYPE_NORMAL
- en: DNS enumeration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Finding a misconfigured server that allows anonymous zone transfers is very
    uncommon on real penetration testing projects. There are other techniques that
    can be used to discover hostnames or subdomains related to a domain, and Kali
    Linux includes a couple of useful tools to do just that.
  prefs: []
  type: TYPE_NORMAL
- en: DNSEnum
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**DNSEnum** is a command-line tool that automatically identifies basic DNS
    records such as MX, mail exchange servers, NS, domain name servers, or A—the address
    record for a domain. It also attempts zone transfers on all identified servers,
    and it has the ability to attempt reverse resolution (that is, getting the hostname
    given an IP address) and brute forcing (querying for the existence of hostnames
    in order to get their IP address) of subdomains and hostnames. Here is an example
    of a query to `zonetransfer.me`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00039.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The zone transfer results are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00040.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Fierce
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Fierce is presented by `mschwager`, in *Fierce: A DNS reconnaissance tool for
    locating non-contiguous IP space* ([https://github.com/mschwager/fierce](https://github.com/mschwager/fierce)),
    GitHub © 2018, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Fierce is a semi-lightweight scanner that helps locate non-contiguous IP space
    and hostnames against specified domains.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fierce uses zone transfer, dictionary attacks, and reverse resolution to gather
    hostnames and subdomains along with the IP addresses of a domain, and it has the
    option to search for related names (for example, `domain company.com`, `corpcompany.com`,
    or `webcompany.com`). In the following example, we will use search to identify
    hostnames of `google.com`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00041.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: DNSRecon
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**DNSRecon** is another useful tool included in Kali Linux. It lets you gather
    DNS information through a number of techniques including zone transfer, dictionary
    requests, and Google search. In the following screenshot, we will do an enumeration
    by zone transfer (`-a`), reverse analysis of the IP address space obtained by
    Whois (`-w`), and Google search (`-g`) over `zonetransfer.me`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00042.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Brute force DNS records using Nmap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Nmap** comes with a script to query the DNS server for additional hosts using
    a brute forcing technique. It makes use of the `vhosts-defaults.lst` and `vhosts-full.lst` dictionary
    files, which contain a large list of common hostnames that have been collected
    over the years by the Nmap development team. The files can be located at `/usr/share/nmap/nselib/data/`.
    Nmap sends a query to the DNS server for each entry in that file to check whether
    there are any A records available for that hostname in the DNS zone.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in the following screenshot, the brute force script returned a positive
    result. It identified a few hosts in the DNS zone by querying for their A records:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00043.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Using search engines and public sites to gather information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Modern search engines are a valuable resource for public information gathering
    and passive reconnaissance. Generalist engines such as Google, Bing, and DuckDuckGo
    allow us to use advanced search filters to look for information in a particular
    domain, certain file types, content in URLs, and specific text patterns. There
    are also specialized search engines, such as Shodan, that let you search for hostnames,
    open ports, server location, and specific response headers in a multitude of services.
  prefs: []
  type: TYPE_NORMAL
- en: Google dorks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The **Google dorks** technique, also known as *Google hacking*, started as
    an abuse of Google''s advanced search options, and it was later extended to other
    search engines that also included similar options. It searches for specific strings
    and parameters to get valuable information from an organization or target. Here
    are some examples that can be useful for a penetration tester:'
  prefs: []
  type: TYPE_NORMAL
- en: 'PDF documents in a specific site or domain can be searched for, like this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'References to email addresses of a specific domain, excluding the domain''s
    site can be searched for:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Administrative sites with the word `admin` in the title or the URL in `example.com` can
    be searched for:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also look for a specific error message indicating a possible SQL injection
    vulnerability:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'There are thousands of possible useful search combinations in Google and other
    search engines. Offensive Security, the creators of Kali Linux, also maintain
    a public database for search strings that may yield useful results for a penetration
    tester, which is available at: [https://www.exploit-db.com/google-hacking-database/](https://www.exploit-db.com/google-hacking-database/).'
  prefs: []
  type: TYPE_NORMAL
- en: Shodan
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Shodan** ([https://shodan.io](https://shodan.io)) is a different kind of
    search engine; it helps you to look for devices connected to the internet instead
    of content in web pages. Like Google, it has operators and a specific syntax to
    execute advanced and specific searches. This screenshot shows a search for all
    hostnames related to `google.com`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00044.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: A hostname search example using Shodan
  prefs: []
  type: TYPE_NORMAL
- en: 'To take advantage of Shodan''s advanced search features, one needs to first
    create an account. Free accounts yield a limited number of results, and some options
    are restricted though still very useful. Shodan can be used to find the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Servers exposed to the internet belonging to some domain can be found like
    this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Specific types of devices, such as CCTV cameras or **Industrial Control Systems**
    (**ICS**), can be found by specifying the `Server` parameter:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Specific open ports or services can be found, for example, web servers using
    common ports:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Hosts in a specific network range can be found like this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'A useful reference on Shodan search options and operators can be found at:
    [https://pen-testing.sans.org/blog/2015/12/08/effective-shodan-searches](https://pen-testing.sans.org/blog/2015/12/08/effective-shodan-searches).'
  prefs: []
  type: TYPE_NORMAL
- en: theHarvester
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**theHarvester** is a command-line tool included in Kali Linux that acts as
    a wrapper for a variety of search engines and is used to find email accounts,
    subdomain names, virtual hosts, open ports / banners, and employee names related
    to a domain from different public sources (such as search engines and PGP key
    servers). In recent versions, the authors added the capability of doing DNS brute
    force, reverse IP resolution, and **Top-Level Domain** (**TLD**) expansion.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, `theharvester` is used to gather information about
    `zonetransfer.me`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00045.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Maltego
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Maltego** is proprietary software widely used for OSINT. Kali Linux includes
    the Community Edition of Maltego, which can be used for free with some limitations
    after completing the online registration. Maltego performs *transforms* over pieces
    of data (for example, email addresses, and domain names) to obtain more information,
    and it displays all of the results as a graph showing relationships among different
    objects. A **transform** is a search of public information about a particular
    object, for example, searches for IP addresses related to a domain name or social
    media accounts related to an email address or person''s name. The following screenshot
    shows the main interface of Maltego:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00046.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Maltego interface
  prefs: []
  type: TYPE_NORMAL
- en: Recon-ng – a framework for information gathering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OSINT collection is a time-consuming, manual process. Information related to
    the target organization may be spread across several public resources, and accumulating
    and extracting the information that is relevant to the target is a difficult and
    time-consuming task. IT budgets of most organizations do not permit spending much
    time on such activities.
  prefs: []
  type: TYPE_NORMAL
- en: '**Recon-ng** is the tool that penetration testers always needed. It''s an information-gathering
    tool on steroids. Recon-ng is a very interactive tool, similar to the Metasploit
    framework. This framework uses many different sources to gather data, for example,
    on Google, Twitter, and Shodan. Some modules require an API key before querying
    the website. The key can be generated by completing the registration on the search
    engine''s website. A few of these modules use paid API keys.'
  prefs: []
  type: TYPE_NORMAL
- en: To start Recon-ng in Kali Linux, navigate to the Applications menu and click
    on the Information Gathering submenu, or just run the `recon-ng` command in Terminal.
    You will see Recon-ng listed on the pane in the right-hand side. Similar to Metasploit,
    when the framework is up and running, you can type in `show modules` to check
    out the different modules that come along with it. Some modules are passive, while
    others actively probe the target to extract the needed information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although Recon-ng has a few exploitation modules, the main task of the tool
    is to assist in reconnaissance activity, and there are a large number of modules
    within it to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00047.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Recon-ng can query multiple search engines, some of them queried via web requests;
    that is, the tool replicates the request made when a regular user enters text
    in the search box and clicks on the Search button. Another option is to use the
    engine's API. This often has better results than with automated tools. When using
    an API, the search engine may require an API key to identify who is sending those
    requests and apply a quota. The tool works faster than a human, and by assigning
    an API the usage can be tracked and can prevent someone from abusing the service.
    So, make sure that you don't overwhelm the search engine, or your query may be
    rejected.
  prefs: []
  type: TYPE_NORMAL
- en: All major search engines have an option for a registered user to hold an API
    key. For example, you can generate an API key for Bing at [https://azure.microsoft.com/en-us/try/cognitive-services/?api=bing-web-search-api.](https://datamarket.azure.com/dataset/bing/search)
  prefs: []
  type: TYPE_NORMAL
- en: 'This free subscription provides you with 5,000 queries a month. Once the key
    is generated, it needs to be added to the keys table in the Recon-ng tool using
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'To display all the API keys that you have stored in Recon-ng, enter the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Domain enumeration using Recon-ng
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Gathering information about the subdomains of the target website will help you
    identify different content and features of the website. Each product or service
    provided by the target organization may have a subdomain dedicated to it. This
    aids in organizing diverse content in a coherent manner. By identifying different
    subdomains, you can create a site map and a flowchart interconnecting the various
    pieces and understand the flow of the website better.
  prefs: []
  type: TYPE_NORMAL
- en: Sub-level and top-level domain enumeration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using the Bing Web hostname enumerator module, we will try to find additional
    subdomains on the [https://www.facebook.com/](https://www.facebook.com/) website:'
  prefs: []
  type: TYPE_NORMAL
- en: First you need to load the module using the `load recon/domains-hosts/bing_domain_web`
    command. Next, enter the `show info` command that will display the information
    describing the module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The next step is to set the target domain in the `SOURCE` option. We will set
    it to `facebook.com`, as shown in the screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00048.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'When you are ready, use the `run` command to kick-off the module. The tool
    first queries a few domains, then it uses the (`-`) directive to remove already
    queried domains. Then it searches for additional domains once again. The biggest
    advantage here is speed. In addition to speed, the output is also stored in a
    database in plaintext. This can be used as an input to other tools such as Nmap,
    Metasploit, and Nessus. The output is shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00049.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The DNS public suffix brute force module can be used to identify **Top-level
    Domains** (**TLDs**) and **Second-level Domains** (**SLDs**). Many product-based
    and service-based businesses have separate websites for each geographical region;
    you can use this brute force module to identify them. It uses the wordlist file
    from `/usr/share/recon-ng/data/suffixes.txt` to enumerate additional domains.
  prefs: []
  type: TYPE_NORMAL
- en: Reporting modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Each reconnaissance module that you run will store the output in separate tables.
    You can export these tables in several formats, such as CSV, HTML, and XML files.
    To view the different tables that the Recon-ng tool uses, you need to enter `show`
    and press *Tab* twice to list the available options for the autocomplete feature.
  prefs: []
  type: TYPE_NORMAL
- en: 'To export a table into a CSV file, load the CSV reporting module by entering
    `use reporting/csv`. (The `load` command can be used instead of `use` with no
    effect.) After loading the module, set the filename and the table to be exported
    and enter `run`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00050.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here are some additional reconnaissance modules in Recon-ng that can be of
    great help to a penetration tester:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Netcraft hostname enumerator**: Recon-ng will harvest the Netcraft website
    and accumulate all of the hosts related to the target and store them in the hosts
    table.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SSL SAN lookup**: Many SSL-enabled websites have a single certificate that
    works across multiple domains using the **Subject Alternative Names** (**SAN**)
    feature. This module uses the [http://ssltools.com/](http://ssltools.com/) website
    to retrieve the domains listed in the SAN attribute of the certificate.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**LinkedIn authenticated contact enumerator**: This will retrieve the contacts
    from a LinkedIn profile and store them in the contacts table.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**IPInfoDB GeoIP**: This will display the geolocation of a host using the IPInfoDB
    database (requires an API).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Yahoo! hostname enumerator**: This uses the Yahoo! search engine to locate
    hosts in the domains. Having modules for multiple search engines at your disposal
    can help you locate hosts and subdomains that may have not been indexed by other
    search engines.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Geocoder and reverse geocoder**: These modules obtain the address using the
    coordinates provided using the Google Map API, and they also retrieve the coordinates
    if an address is given. The information then gets stored in the locations table.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pushpin modules**: Using the Recon-ng pushpin modules, you can pull data
    from popular social-networking websites, correlate it with geolocation coordinates,
    and create maps. Two widely used modules are as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Twitter geolocation search**: This searches Twitter for media (images and
    tweets) uploaded from a specific radius of the given coordinates'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flickr geolocation search**: This tries to locate photos uploaded from the
    area around the given coordinates'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These pushpin modules can be used to map people to physical locations and to
    determine who was at the given coordinates at a specific time. The information
    accumulated and converted to a HTML file can be mapped to a satellite image at
    the exact coordinates. Using Recon-ng, you can create a huge database of hosts,
    IP addresses, physical locations, and people, all just using publicly available
    resources.
  prefs: []
  type: TYPE_NORMAL
- en: Reconnaissance should always be done with the goal of extracting information
    from various public resources and to identify sensitive data that can be used
    by an attacker to target the organization directly or indirectly.
  prefs: []
  type: TYPE_NORMAL
- en: Scanning – probing the target
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The penetration test needs to be conducted in a limited timeframe, and the reconnaissance
    phase is the one that gets the least amount of time. In a real-world penetration
    test, you share the information gathered during the reconnaissance phase with
    the client and try to reach a consensus on the targets that should be included
    in the scanning phase.
  prefs: []
  type: TYPE_NORMAL
- en: At this stage, the client may also provide you with additional targets and domains
    that were not identified during the reconnaissance phase, but they will be included
    in the actual testing and exploitation phase. This is done to gain maximum benefit
    from the test by including the methods of both black hat and white hat hackers,
    where you start the test as would a malicious attacker, and as you move forward,
    additional information is provided, which yields an exact view of the target.
  prefs: []
  type: TYPE_NORMAL
- en: Once the target server hosting the website is determined, the next step involves
    gathering additional information such as the operating system and the services
    available on that specific server. Besides hosting a website, some organizations
    also enable FTP service, and other ports may also be opened according to their
    needs. As the first step, you need to identify the additional ports open on the
    web server besides port `80` and port `443`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The scanning phase consists of the following stages:'
  prefs: []
  type: TYPE_NORMAL
- en: Port scanning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operating system fingerprinting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Web server version identification
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Underlying infrastructure analysis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application identification
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Port scanning using Nmap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Network mapper**, popularly known as Nmap, is the most widely known port
    scanner. It finds TCP and UDP open ports with a great success, and it is an important
    piece of software in the penetration tester''s toolkit. Kali Linux comes with
    Nmap preinstalled. Nmap is regularly updated, and it is maintained by an active
    group of developers contributing to this open source tool.'
  prefs: []
  type: TYPE_NORMAL
- en: By default, Nmap does not send probes to all ports. Nmap checks only the top
    1,000 frequently used ports that are specified in the `nmap-services` file. Each
    port entry has a corresponding number indicating the likeliness of that port being
    open. This increases the speed of the scan drastically, as the less important
    ports are omitted from the scan. Depending on the response by the target, Nmap
    determines if the port is open, closed, or filtered.
  prefs: []
  type: TYPE_NORMAL
- en: Different options for port scan
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The straightforward way of running an Nmap port scan is called the **TCP connect
    scan**. This option is used to scan for open TCP ports, and it is invoked using
    the `-sT` option. The connect scan performs a full three-way TCP handshake (SYN-SYN
    / ACK-ACK). It provides a more accurate state of the port, but it is more likely
    to be logged at the target machine and slower than the alternative SYN scan. A
    SYN scan, using the `-sS` option, does not complete the handshake with the target,
    and it is therefore not logged on that target machine. However, the packets generated
    by the SYN scan can alert firewalls and IPS devices, and they are sometimes blocked
    by default by such appliances.
  prefs: []
  type: TYPE_NORMAL
- en: Nmap, when invoked with the `-F` flag, will scan for the top 100 ports instead
    of the top 1,000 ports. Additionally, it also provides you with the option to
    customize your scan with the `--top-ports [N]` flag to scan for `N` most popular
    ports from the `nmap-services` file. Many organizations might have applications
    that will be listening on a port that is not part of the `nmap-services` file.
    For such instances, you can use the `-p` flag to define a port, port list, or
    a port range for Nmap to scan.
  prefs: []
  type: TYPE_NORMAL
- en: There are 65535 TCP and UDP ports and applications that could use any of the
    ports. If you want, you can test all of the ports using the `-p 1-65535` or `-p-`
    option.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the output of the preceding commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00051.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In a penetration test, it is very important that you save the results and keep
    the logs from all of the tools you run. You should save notes and records to organize
    the project better and save the logs as a preventive measure in case something
    goes wrong with the targets. You can then go back to your logs and retrieve information
    that may be crucial to reestablishing the service or identifying the source of
    the failure. Nmap has various `-o` options to save its results to different file
    formats: `-oX` for the XML format, `-oN` for the Nmap output format, `-oG` for
    greppable text, and `-oA` for all.'
  prefs: []
  type: TYPE_NORMAL
- en: Evading firewalls and IPS using Nmap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In addition to the different scans for TCP, Nmap also provides various options
    that help in circumventing firewalls when scanning for targets from outside the
    organization''s network. The following are the descriptions of these options:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ACK scan**: This option is used to circumvent the rules on some routers that
    only allow SYN packets from the internal network, thus blocking the default connect
    scan. These routers will only allow internal clients to make connections through
    the router and will block all packets originating from the external network with
    a SYN bit set. When the ACK scan option is invoked with the `-sA` flag, Nmap generates
    the packet with only the ACK bit set fooling the router into believing that the
    packet was a response to a connection made by an internal client and allows the
    packet to go through it. The ACK scan option cannot reliably tell whether a port
    at the end system is open or closed, as different systems respond to an unsolicited
    ACK in different ways. However, it can be used to identify online systems behind
    the router.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hardcoded source port in firewall rules**: Many firewall administrators configure
    firewalls with rules that allow incoming traffic from the external network, which
    originate from a specific source port such as `53`, `25`, and `80`. By default,
    Nmap randomly selects a source port, but it can be configured to use a specific
    source port in order to circumvent this rule using the `--source-port` option.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Custom packet size**: Nmap and other port scanners send packets in a specific
    size, and firewalls now have rules defined to drop such packets. In order to circumvent
    this detection, Nmap can be configured to send packets with a different size using
    the `--data-length` option.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Custom MTU**: Nmap can also be configured to send packets with smaller MTU.
    The scan will be done with a `--mtu` option along with a value of the MTU. This
    can be used to circumvent some older firewalls and intrusion-detection devices.
    New firewalls reassemble the traffic before sending it across to the target machine,
    so it is difficult to evade them. The MTU needs to be a multiple of 8\. The default
    MTU for Ethernet LAN is 1,500 bytes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fragmented packets**: A common yet effective way of bypassing IDS and IPS
    systems is to fragment the packets so that when analyzed by those defensive mechanisms,
    they don''t match malicious patterns. Nmap has the ability to do this using the
    `-f` option when performing a full TCP scan (`-sT`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MAC address spoofing**: If there are rules configured in the target environment
    only to allow network packets from certain MAC addresses, you can configure Nmap
    to set a specific MAC address to conduct the port scan. The port scanning packets
    can also be configured with a specific MAC address with the `--spoof-mac` option.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identifying the operating system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After identifying the open ports on the web server, you need to determine the
    underlying operating system. Nmap provides several options to do so. The OS scan
    is performed using the `-O` option; you can add `-v` for a verbose output to find
    out the underlying tests done to determine the operating system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00052.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: A skilled hacker does not rely on the results of a single tool. Therefore, Kali
    Linux comes with several fingerprinting tools; in addition to running your version
    scan with Nmap, you can get a second opinion using a tool such as Amap.
  prefs: []
  type: TYPE_NORMAL
- en: Profiling the server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once the underlying operating system and open ports have been determined, you
    need to identify the exact applications running on the open ports. When scanning
    web servers, you need to analyze the flavor and version of web service that is
    running on top of the operating system. Web servers basically process the HTTP
    requests from the application and distribute them to the web; Apache, IIS, and
    nginx are the most widely used web servers. Along with the version, you need to
    identify any additional software, features, and configurations enabled on the
    web server before moving ahead with the exploitation phase.
  prefs: []
  type: TYPE_NORMAL
- en: Web application development relies heavily on frameworks such as PHP and .NET,
    and each web application will require a different technique depending on the framework
    used to design it.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to version scanning of the web server, you also need to identify
    the additional components supporting the web application, such as the database
    application, encryption algorithms, and load balancers.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple websites are commonly deployed on the same physical server. You need
    to attack only the website that is within the scope of the penetration testing
    project, and a proper understanding of the virtual host is required to do this.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying virtual hosts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The websites of many organizations are hosted by service providers using shared
    resources. The sharing of IP addresses is one of the most useful and cost-effective
    techniques used by them. You will often see a number of domain names returned
    when you do a reverse DNS query for a specific IP address. These websites use
    name-based virtual hosting, and they are uniquely identified and differentiated
    from other websites hosted on the same IP address by the host header value.
  prefs: []
  type: TYPE_NORMAL
- en: This works similar to a multiplexing system. When the server receives the request,
    it identifies and routes the request to the specific host by consulting the `Host`
    field in the request header. This was discussed in [Chapter 1](part0021.html#K0RQ0-d48f8b63a8cc440fbc92835fec01cc38),
    *Introduction to Penetration Testing and Web Applications*.
  prefs: []
  type: TYPE_NORMAL
- en: When interacting and crafting an attack for a website, it is important to identify
    the type of hosting. If the IP address is hosting multiple websites, then you
    have to include the correct host header value in your attacks or you won't get
    the desired results. This could also affect the other websites hosted on that
    IP address. Directly attacking with the IP address may have undesirable results,
    and may hit out-of-scope elements. This may even have legal implications if such
    elements are not owned by the client organization.
  prefs: []
  type: TYPE_NORMAL
- en: Locating virtual hosts using search engines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can determine whether multiple websites are hosted on an IP address by analyzing
    the DNS records. If multiple names point to the same IP address, then the host
    header value is used to uniquely identify the website. DNS tools such as `dig`
    and `nslookup` can be used to identify domains returning similar IP addresses.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the [http://ipneighbour.com/](http://ipneighbour.com/) website to
    identify whether other websites are hosted on a given web server. The following
    example shows several websites related to Wikipedia hosted on the same IP address:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00053.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Identifying load balancers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: High-demand websites and applications use some form of load balancing to distribute
    load across servers and to maintain high availability. The interactive nature
    of websites makes it critical for end users to access the same server for the
    entire duration of the session for the best user experience. For example, on an
    e-commerce website, once a user adds items to the cart, it is expected that the
    user will connect to the same server again at the checkout page to complete the
    transaction. With the introduction of an intermediary, such as a load balancer,
    it becomes very important that the subsequent requests from the user are sent
    to the same server by the load balancer.
  prefs: []
  type: TYPE_NORMAL
- en: There are several techniques that can be used to load balance user connections
    between servers. DNS is the easiest to configure, but it is unreliable and does
    not provides a true load balancing experience. Hardware load balancers are the
    ones used today to route traffic to websites maintaining load across multiple
    web servers.
  prefs: []
  type: TYPE_NORMAL
- en: During a penetration test, it is necessary to identify the load balancing technique
    used in order to get a holistic view of the network infrastructure. Once identified,
    you now have to test each server behind the load balancer for vulnerabilities.
    Collaborating with the client team is also required, as different vendors of hardware
    load balancers use different techniques to maintain session affinity.
  prefs: []
  type: TYPE_NORMAL
- en: Cookie-based load balancer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A popular method used by hardware load balancers is to insert a cookie in the
    browser of the end client that ties the user to a particular server. This cookie
    is set regardless of the IP address, as many users will be behind a proxy or a
    NAT configuration, and most of them will be using the same source IP address.
  prefs: []
  type: TYPE_NORMAL
- en: Each load balancer will have its own cookie format and names. This information
    can be used to determine if a load balancer is being used and who its provider
    is. The cookie set by the load balancer can also reveal sensitive information
    related to the target that may be of use to the penetration tester.
  prefs: []
  type: TYPE_NORMAL
- en: 'Burp Proxy can be configured to intercept the connection, and you can look
    out for the cookie by analyzing the header. As shown in the following screenshot,
    the target is using an F5 load balancer. The long numerical value is actually
    the encoded value containing the pool name, web server IP address, and the port.
    So, here the load balancer cookie reveals critical server details that it should
    not be doing. The load balancer can be configured to set a customized cookie that
    does not reveal such details:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00054.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The default cookie for the F5 load balancer has the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Other ways of identifying load balancers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A few other ways to identify a device such as a load balancer are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Analyzing SSL differences between servers**: There can be minor changes in
    the SSL configuration across different web servers. The timestamp on the certificate
    issued to the web servers in the pool may vary. The difference in the SSL configuration
    can be used to determine whether multiple servers are configured behind a load
    balancer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Redirecting to a different URL**: Another method of load balancing requests
    across servers is by redirecting the client to a different URL to distribute load.
    A user may browse to a website, `www.example.com`, but gets redirected to `www2.example.com`
    instead. A request from another user gets redirected to `www1.example.com`, and
    a web page from a different server is then delivered. This is one of the easiest
    ways to identify a load balancer, but it is not often implemented as it has management
    overhead and security implications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DNS records for load balancers**: Host records in the DNS zone can be used
    to conclude if the device is a load balancer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Load balancer detector**: This is a tool included in Kali Linux. It determines
    whether a website is using a load balancer. The command to execute the tool from
    the shell is `lbd <website name>`. The tool comes with a disclaimer that it''s
    a proof of a concept tool and prone to false positives.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Web Application Firewall (WAF)**: In addition to a load balancer, the application
    might also use a WAF to thwart attacks. The WAFW00F web application firewall detection
    tool in Kali Linux is able to detect whether any WAF device exists in the path.
    The tool can be accessed by navigating to Information Gathering | IDS/IPS Identification.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application version fingerprinting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Services running on well-known ports such as port `25` and port `80` can be
    identified easily, as they are used by widely known applications such as the mail
    server and the web server. The **Internet Assigned Numbers Authority** (**IANA**)
    is responsible for maintaining the official assignments of port numbers, and the
    mapping can be identified from the port mapping file in every operating system.
    However, many organizations run applications on ports that are more suitable to
    their infrastructure. You will often see an intranet website running on port `8080`
    instead of port `80`, or port `8443` instead of port `443`.
  prefs: []
  type: TYPE_NORMAL
- en: The port mapping file is only a placeholder, and applications can run on any
    open port, as designed by the developer, defying the mapping set by IANA. This
    is exactly why you need to do a version scan to determine whether the web server
    is indeed running on port `80` and further analyze the version of that service.
  prefs: []
  type: TYPE_NORMAL
- en: The Nmap version scan
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nmap has couple of options that can be used to perform version scanning; the
    version scan can be combined along with the operating system scan, or it could
    be run separately. Nmap probes the target by sending a wide range of packets,
    and then it analyzes the response to determine the exact service and its version.
  prefs: []
  type: TYPE_NORMAL
- en: To start only the version scans, use the `-sV` option. The operating system
    scan and the version scan can be combined together using the `-A` (aggressive)
    option, which also includes route tracing and execution of some scripts. If no
    ports are defined along with the scanning options, Nmap will first perform a port
    scan on the target using the default list of the top 1,000 ports and identify
    the open ports from them.
  prefs: []
  type: TYPE_NORMAL
- en: Next, it will send a probe to the open port and analyze the response to determine
    the application running on that specific port. The response received is matched
    against a huge database of signatures found in the `nmap-service-probes` file.
    It's similar to how an IPS signature works, where the network packet is matched
    against a database containing the signatures of the malicious packets. The version
    scanning option is only as good as the quality of signatures in that file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the output of the preceding commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00055.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: You can report incorrect results and new signatures for unknown ports to the
    Nmap project. This helps to improve the quality of the signatures in the future
    releases.
  prefs: []
  type: TYPE_NORMAL
- en: The Amap version scan
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kali Linux also comes with a tool called Amap, which was created by the **The
    Hacker's Choice** (**THC**) group and works like Nmap. It probes the open ports
    by sending a number of packets, and then it analyzes the response to determine
    the service listening on that port.
  prefs: []
  type: TYPE_NORMAL
- en: The probe to be sent to the target port is defined in a file called `appdefs.trig`,
    and the response that is received is analyzed against the signatures in the `appdefs.resp`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: During a penetration test, it is important to probe the port using multiple
    tools to rule out any false positives or negatives. Relying on the signatures
    of one tool could prove to be fatal during a test, as your future exploits would
    depend on the service and its version identified during this phase.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can invoke Amap using the `-bqv` option, which will only report the open
    ports and print the response received in ASCII and some detailed information related
    to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00056.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Fingerprinting the web application framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having the knowledge about the framework used to develop a website gives you
    an advantage in identifying the vulnerabilities that may exist in the unpatched
    versions.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if the website is developed on a WordPress platform, traces of
    it can be found in the web pages of that website. Most of the web application
    frameworks have markers that can be used by an attacker to determine the framework
    used.
  prefs: []
  type: TYPE_NORMAL
- en: There are several places that can reveal details about the framework.
  prefs: []
  type: TYPE_NORMAL
- en: The HTTP header
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Along with defining the operating parameters of an HTTP transaction, the header
    may also include additional information that can be of use to an attacker.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, using the development tools in Firefox (*F12* key),
    you can determine from the `Server` field that the Apache web server is being
    used. Also, using `X-AspNet-Version` you can tell that ASP.NET version 2 is the
    development framework. This approach may not always work, as the header field
    can be disabled by proper configuration at the server end:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00057.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Application frameworks also create new cookie values that can throw some light
    on the underlying framework used, so keep an eye on the cookies too.
  prefs: []
  type: TYPE_NORMAL
- en: Comments in the HTML page source code can also indicate the framework used to
    develop the web application. Information in the page source can also help you
    identify additional web technologies used.
  prefs: []
  type: TYPE_NORMAL
- en: The WhatWeb scanner
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The WhatWeb tool is used to identify different web technologies used by the
    website. It is included in Kali Linux, and it can be accessed by going to Applications
    | 03 - Web Application Analysis | Web Vulnerability scanners. It identifies the
    different content management systems, statistic/analytics packages, and JavaScript
    libraries used to design the web application. The tool claims to have over 900
    plugins. It can be run at different aggression levels that balance speed and reliability.
    The tool may get enough information on a single web page to identify the website,
    or it may recursively query the website to identify the technologies used.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next example, we will use the tool against the OWASP BWA virtual machine
    with the `-v` verbose option enabled. This prints out some useful information
    related to the technologies identified:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00058.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Scanning web servers for vulnerabilities and misconfigurations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have dealt with the infrastructure part of the target. We now need
    to analyze the underlying software and try to understand the different technologies
    working beneath the hood. Web applications designed using the default configurations
    are vulnerable to attack, as they provide several openings for a malicious attacker
    to exploit the application.
  prefs: []
  type: TYPE_NORMAL
- en: Kali Linux provides several tools to analyze the web application for configuration
    issues. The scanning tools identify vulnerabilities by navigating through the
    entire website and seek out interesting files, folders, and configuration settings.
    Server-side scripting languages, such as PHP and CGI, which have not been implemented
    correctly and found to be running on older versions can be exploited using automated
    tools.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying HTTP methods using Nmap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the first direct requests to a web server during a web penetration test
    should be to identify what methods are supported by the web server. You can use
    Netcat to open a connection to the web server and query the web server with the
    `OPTIONS` method. You can also use Nmap to determine the supported methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the ever-increasing repository of Nmap scripts, you can find a script named
    `http-methods.nse`. When you run the script using the `--script` option along
    with the target, it will list the allowed HTTP methods on the target, and it will
    also point out the dangerous methods. In the following screenshot, you can see
    this in action where it detects several enabled methods and also points out `TRACE`
    as a risky method:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00059.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Testing web servers using auxiliary modules in Metasploit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following modules are useful for a penetration tester testing a web server
    for vulnerabilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dir_listing`: This module will connect to the target web server and determine
    whether directory browsing is enabled on it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dir_scanner`: Using this module, you can scan the target for any interesting
    web directories. You can provide the module with a custom created dictionary or
    use the default one.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`enum_wayback`: This is an interesting module that queries the Internet Archive
    website and looks out for web pages in the target domain. Old web pages that might
    have been unlinked may still be accessible and can be found using the Internet
    Archive website. You can also identify the changes that the website has undergone
    throughout the years.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`files_dir`: This module can be used to scan the server for data leakage vulnerabilities
    by locating backups of configuration files and source code files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`http_login`: If the web page has a login page that works over HTTP, you can
    try to brute force it using the Metasploit dictionary.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`robots_txt`: Robot files can contain some unexplored URLs, and you can query
    them using this module to find the URLs that are not indexed by a search engine.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`webdav_scanner`: This module can be used to find out if WebDAV is enabled
    on the server, which basically turns the web server into a file server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identifying HTTPS configuration and issues
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Any website or web application that manages any kind of sensitive or personally
    identifiable information (names, phone numbers, addresses, health; credit; or
    tax records, credit card and bank account information, and so on) needs to implement
    a mechanism to protect the information on its way from client to server and vice
    versa.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP was born as a cleartext protocol. As such, it doesn't include mechanisms
    to protect the information exchanged by the client and server from being viewed
    and/or modified by a third party that manages to intercept it. As a workaround
    to this problem, an encrypted communication channel is created between the client
    and server, and HTTP packets are sent through it. HTTPS is the implementation
    of the HTTP protocol over a secure communication channel. It was originally implemented
    over **Secure Sockets Layer** (**SSL**). SSL was deprecated in 2014 and replaced
    by **Transport Layer Security** (**TLS**), although there are still many sites
    that support SSLv3, be it for misconfiguration or for backwards compatibility.
  prefs: []
  type: TYPE_NORMAL
- en: Supporting older encryption algorithms has a major drawback. Most older cipher
    suites are found to be easily breakable by cryptanalysts, within a reasonable
    amount of time using the computing power that is available today.
  prefs: []
  type: TYPE_NORMAL
- en: A dedicated attacker can rent cheap computing power from a cloud service provider
    and use it to break older ciphers and gain access to the cleartext information.
    Thus, using older ciphers provides a false sense of security and should be disabled.
    The client and the server should only be allowed to negotiate a cipher that is
    considered secure and is very difficult to break in practice.
  prefs: []
  type: TYPE_NORMAL
- en: Kali Linux includes a number of tools that allow penetration testers to identify
    such misconfigurations in SSL/TLS implementation. In this section, we will review
    the most popular ones.
  prefs: []
  type: TYPE_NORMAL
- en: OpenSSL client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Included in almost every GNU/Linux distribution, **OpenSSL** is the basic SSL/TLS
    client and includes the functionality that will help you perform some basic test
    over an HTTPS server.
  prefs: []
  type: TYPE_NORMAL
- en: 'A basic test would be to do a connection with the server. In this example,
    we will connect to a test server on port `443` (the default HTTPS port):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see extensive information about the connection parameters and certificates
    exchanges in the result shown in the following screenshot. Something worth your
    attention is that the connection used SSLv3, which is a security issue in itself,
    as SSL is deprecated and has known vulnerabilities that could result in the full
    decryption of the information, such as **Padding Oracle On Downgraded Legacy Encryption**
    (**POODLE**), which we will discuss in later chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00060.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'You will often see cipher suites written as ECDHE-RSA-RC4-MD5\. The format
    is broken down into the following parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ECDHE**: This is a key exchange algorithm'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**RSA**: This is an authentication algorithm'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**RC4**: This is an encryption algorithm'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MD5**: This is a hashing algorithm'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A comprehensive list of SSL and TLS cipher suites can be found at: [https://www.openssl.org/docs/apps/ciphers.html](https://www.openssl.org/docs/apps/ciphers.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Some other options that you can use with OpenSSL to test your targets better, are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Disabling or using specific protocols**: Using the `-no_ssl3`, `-no_tls1`,
    `-no_tls1_1`, and `-no_tls1_2` options, you can disable the use of the corresponding
    protocols and test which ones your target accepts'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Testing one specific protocol**: The `-tls1`, `-tls1_1`, and `-tls1_2` options
    test only the specified protocol'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nowadays, accepting SSL and TLS 1.0 is not considered secure. TLS 1.1 can be
    acceptable in certain applications, but TLS 1.2 is the recommended option.
  prefs: []
  type: TYPE_NORMAL
- en: Scanning TLS/SSL configuration with SSLScan
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**SSLScan** is a command-line tool that performs a wide variety of tests over
    the specified target and returns a comprehensive list of the protocols and ciphers
    accepted by an SSL/TLS server along with some other information useful in a security
    test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00061.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: You can use SSLScan's color code to obtain a quick reference about the severity,
    in terms of security, of the displayed results. Red (allowing SSLv3 and using
    DES and RC4 ciphers) indicates an insecure configuration, while green or white
    is a recommended one.
  prefs: []
  type: TYPE_NORMAL
- en: The output of the command can be exported in an XML document using the `--xml=<filename>`
    option.
  prefs: []
  type: TYPE_NORMAL
- en: Scanning TLS/SSL configuration with SSLyze
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**SSLyze** is a Python tool that can analyze the SSL/TLS configuration of a
    server by connecting to it similarly to SSLScan. It has the ability to scan multiple
    hosts at a time, and it can also test performance and use the client certificate
    for mutual authentication. The following command runs a regular HTTPS scan (this
    includes SSL version 2, SSL version 3, and TLS 1.0, TLS 1.1, and TLS 1.2 checks,
    basic information about the certificate, and tests for compression, renegotiation,
    and Heartbleed) over your testing machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see the results in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00062.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Testing TLS/SSL configuration using Nmap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Nmap includes a script known as `ssl-enum-ciphers`, which can identify the
    cipher suites supported by the server, and it also rates them based on cryptographic
    strength. It makes multiple connections using SSLv3, TLS 1.1, and TLS 1.2\. The
    script will also highlight if it identifies that the SSL implementation is vulnerable
    to any previously released vulnerabilities, such as CRIME and POODLE:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00063.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Spidering web applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When testing a large real-world application, you need a more exhaustive approach.
    As a first step, you need to identify the size of the application, as there are
    several decisions that depend on it. The number of resources that you require,
    the estimation of effort, and the cost of the assessment depends on the size of
    the application.
  prefs: []
  type: TYPE_NORMAL
- en: A web application consists of multiple web pages linked to one another. Before
    starting the assessment of an application, you need to map it out to identify
    its size. You can manually walk through the application, clicking on each link
    and viewing the contents as a normal user would do. When manually spidering the
    application, your goal should be to identify as many web pages as possible—from
    the perspective of both the authenticated and unauthenticated user.
  prefs: []
  type: TYPE_NORMAL
- en: Manually spidering the application is both time consuming and prone to omissions.
    Kali Linux has numerous tools that can be used to automate this task. The Burp
    Spider tool in Burp Suite is well-known for spidering web applications. It automates
    the tedious task of cataloging the various web pages in the application. It works
    by requesting a web page, parsing it for links, and then sending requests to these
    new links until all of the web pages are mapped. In this way, the entire application
    can be mapped without any web pages being ignored.
  prefs: []
  type: TYPE_NORMAL
- en: 'CAUTION:'
  prefs: []
  type: TYPE_NORMAL
- en: As spidering is an automated process, one needs to be aware of the process and
    the workings of the application in order to avoid the spider having to perform
    sensitive requests, such as password resets, form submissions, and information
    deletion.
  prefs: []
  type: TYPE_NORMAL
- en: Burp Spider
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Burp Spider maps the applications using both passive and active methods.
  prefs: []
  type: TYPE_NORMAL
- en: When you start Burp Proxy, it runs by default in the passive spidering mode.
    In this mode, when the browser is configured to use Burp Proxy, it updates the
    site map with all of the contents requested through the proxy without sending
    any further requests. Passive spidering is considered safe, as you have direct
    control over what is crawled. This becomes important in critical applications
    that include administrative functionality, which you don't want to trigger.
  prefs: []
  type: TYPE_NORMAL
- en: For effective mapping, the passive spidering mode should be used along with
    the active mode. Initially, allow Burp Spider to map the application passively
    as you surf through it, and when you find a web page of interest that needs further
    mapping, you can trigger the active spidering mode. In the active mode, Burp Spider
    will recursively request web pages until it maps all of the URLs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the output of passive spidering, as one clicks
    on the various links in the application. Make sure that you have Burp set as the
    proxy in the web browser and that interception is turned off before passively
    mapping the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00064.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'When you want to spider a web page actively, right-click on the link in the
    Site map section and click on Spider this branch. As soon as you do this, the
    active spider mode kicks in. In the Spider section, you will see that requests
    have been made, and the Site map section will be populated with the new items,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00065.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'When the active spider is running, it will display the number of requests made
    and a few other details. In the Spider Scope section, you can create rules using
    a regular expression string to define the targets:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00066.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Application login
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An application may require authentication before it allows you to view contents.
    Burp Spider can be configured to authenticate to the application using reconfigured
    credentials when spidering it. In the Options tab in the Spider section, you can
    define the credentials or select the Prompt for guidance option. When you select
    the Prompt for guidance option, it will display a prompt where you can enter the
    username and password if the spider encounters a login page, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00067.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Directory brute forcing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Also known as *forced browse*, **directory brute forcing** is the process of
    requesting files and server directories to which there are no direct links in
    the application or the server's pages. This is usually done by getting the directory
    and filenames from a common names list. Kali Linux includes some tools to accomplish
    this task. We will explore two of them here.
  prefs: []
  type: TYPE_NORMAL
- en: DIRB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**DIRB** can recursively scan directories and look for files with different
    extensions in a web server. It can automatically detect the *Not Found* code when
    it''s not the standard 404\. It can then export the results to a text file, use
    session cookies in case the server requires having a valid session, and conduct
    basic HTTP authentication and upstream proxy among other features. The following
    screenshot shows a basic DIRB use, using the default dictionary and saving the
    output to a text file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00068.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: ZAP's forced browse
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'DirBuster was a directory brute forcer maintained by OWASP that is now integrated
    into OWASP ZAP as the forced browse functionality. To use it, you start OWASP-ZAP
    (in Kali''s menu, go to 03 - Web Application Analysis | owasp-zap) and configure
    the browser to use it as proxy; the same way Burp does passive spidering, ZAP
    registers all of the URLs you browse and the resources they request from the server.
    Consequently, you browse to your target and the detected files and directories
    get recorded in ZAP. Next, right-click on the directory on which you want to do
    the forced browse and go to Attack | Forced Browse site / Forced Browse directory
    / Forced Browse directory (and children). The choice between site, directory,
    or directory and children depends on what you want to scan—site indicates scanning
    from the root directory of the server, directory means only the selected directory,
    and directory and children is the selected directory recursively:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00069.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'After this, select the names list file (dictionary) and click on the Start
    button. Existing directories and files will possibly show in the same tab:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00070.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With this, we come to the end of the chapter. We worked through the reconnaissance
    phase and finished by scanning the web server. In the following diagram, you can
    view the tasks involved in the reconnaissance phase of a penetration test and
    some useful tools in Kali Linux that can be used for each task:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00071.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Reconnaissance is the first stage of a penetration test. When testing a target
    that is accessible from the internet, search engines and social networking websites
    can reveal useful information. Search engines store a wealth of information that
    is helpful when performing a black box penetration. We used these free resources
    to identify information that a malicious user might use against the target. Kali
    Linux has several tools that help you achieve your objectives, and we used a few
    of them in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we moved on to the scanning phase, which required the hacker to interact
    actively with the web application in order to identify vulnerabilities and misconfigurations.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at server-side and client-side vulnerabilities
    that affect web applications.
  prefs: []
  type: TYPE_NORMAL
