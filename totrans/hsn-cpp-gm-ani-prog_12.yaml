- en: '*Chapter 12*: Blending between Animations'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The transition from one animation to another can be jarring. Imagine if a character
    is in the middle of a punch and the player decides that they want to start running.
    If the animation just switches from the jump clip to the run clip, the transitions
    will be hard and unnatural.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Animation blending can fix this by generating intermediate frames that are an
    average of both animations. This fade is usually short—a quarter of a second or
    less. The smooth animated transition generated by this short blend provides a
    much better looking experience.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter explores how to implement animation blending and additive animation
    blending and how to set up a crossfade controller to manage a blend queue. The
    following topics will be covered:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Pose blending
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Crossfading animations
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additive blending
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pose blending
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Animation blending is a linear blend between two poses in the local space of
    each joint. Think of it as a `lerp` or `mix` function but applied to an entire
    pose. This technique does not blend animation clips; rather, it blends the poses
    that these clips have been sampled into.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: When blending two poses, the entire pose does not need to be blended. Assume
    there are two animations—a run cycle and an attack. If the player presses the
    attack button, the top half of the attack pose is blended in over a short period
    of time, maintains a weight of `1` throughout the animation, and is then blended
    out near the end of the animation.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: This is an example of using pose blending to create a running attack animation
    without having to animate the legs of the attack animation. The attack animation
    could be blended on top of a walk cycle for a walking animation. Animation blending
    can be used to transition smoothly between animations or to combine multiple animations
    into a new one.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, you will declare a `Blend` function for the `Pose`
    class. This `Blend` function will linearly interpolate between two poses, similar
    to how a vector `lerp` works. The function needs two poses and an interpolation
    value, commonly represented as `t`, which has a range of `0` to `1`
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Declaring the Blend function
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Blend` function takes two poses—a mix value and a root node—as arguments.
    When the mix value is `0`, the `Blend` function returns the first pose, and when
    it is `1`, it returns the second pose. For any values between `0` and `1`, the
    poses are blended. The root node decides which node (and its children) of the
    second animation should be blended into the first animation.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: 'To accommodate specifying a root bone to start blending from, there needs to
    be a way to check whether one node is in the hierarchy of another node. The `IsInHierarchy`
    function takes a `Pose` class, a node that is the root node, and a node that is
    the search node. If the search node is a descendant of the root node, the function
    returns `true`:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: When blending two poses, it is assumed that the poses are similar. Similar poses
    have the same number of joints, and each joint has the same parent index between
    the poses. In the following section, you will implement the `Blend` function.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Blend function
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For blending to work, it must happen in local space, which is convenient for
    blending between two poses. Loop through all the joints in the input poses and
    interpolate between the local transforms of the joint in both poses that are being
    blended. For the position and scale, use the vector `lerp` function, and for the
    rotation, use the quaternion `nlerp` function.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: 'To support an animation root, check whether the current transform is a descendant
    of the blend root. If it is, carry out the blend. If it is not, skip the blend
    and keep the transform values of the first input pose. Follow these steps to implement
    the hierarchy check and `Blend` functions:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: 'To check whether one joint is the descendant of another, follow the descendant
    joint all the way up the hierarchy until the root node. If any of the nodes encountered
    in this hierarchy are the node that you are checking against, return `true`:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To blend two poses together, loop through the joints of each pose. If the current
    joint is not in the blend root''s hierarchy, don''t blend it. Otherwise, blend
    the `Transform` objects using the `mix` function you wrote in [*Chapter 5*](B16191_05_Final_JC_ePub.xhtml#_idTextAnchor094),
    *Implementing Transforms*. The `mix` function takes quaternion neighborhooding
    into account:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If two animations are blended using the whole hierarchy, the root argument to
    `Blend` will be negative. With a negative joint for the blend root, the `Blend`
    function skips the `IsInHierarchy` check. In the following section, you will explore
    how to fade between two animations for a smooth transition.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Crossfading animations
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most common use case for blending animations is crossfading between two
    animations. A **crossfade** is a fast blend from one animation to another. The
    goal of the crossfade is to hide the transition between two animations.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: Once a crossfade is done, the active animation needs to be replaced by the animation
    that you are fading to. If you are fading to multiple animations, they are all
    evaluated. The ones that end the soonest are removed first. Animations that are
    requested are added to a list, and animations that have faded out are removed
    from the list.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, you will build a `CrossFadeController` class that
    takes care of the crossfade logic. This class provides a simple intuitive API
    that makes fading between animations simple with just one function call.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: Creating helper classes
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When fading an animation into an already-sampled pose, you need to know what
    the animation being faded is, it's current playtime, the length of the fade durations,
    and the current time of the fade. These values are used to perform the actual
    blend and contain data about the state of the blend.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file and name it `CrossFadeTarget.h` to implement the `CrossFadeTarget`
    helper class in. This helper class contains the variables described previously.
    The default constructor should set the value of everything to `0`. A convenience
    constructor that takes a clip pointer, pose reference, and duration is also provided:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `mPose`, `mClip`, and `mTime` variables of the `CrossFadeTarget` helper
    class are used in every frame to sample the animation that is being faded to.
    The `mDuration` and `mElapsed` variables are used to control how much the animation
    should be faded in.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you will implement a class that controls animation playback
    and fading.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: Declaring the cross-fade controller
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Keeping track of the currently playing clip and managing the fading is the job
    of a new `CrossFadeController` class. Create a new file, `CrossFadeController.h`,
    to declare the new class in. This class needs to contain a skeleton, a pose, the
    current playback time, and an animation clip. It also needs a vector of the `CrossFadeTarget`
    objects that control the animation blending.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Both the `CrossFadeController` and `CrossFadeTarget` classes contain pointers
    to animation clips, but they don't own these pointers. Because neither class owns
    the memory for the pointers, the generated constructor, copy constructor, assignment
    operator, and destructor should be fine to use.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: 'The `CrossFadecontroller` class needs functions to set the current skeleton,
    retrieve the current pose, and retrieve the current clip. The current animation
    can be set with the `Play` function. New animations can be blended in using the
    `FadeTo` function. Since the `CrossFadeController` class manages animation playback,
    it needs an `Update` function to sample the animation clips:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The entire `mTargets` list is evaluated with every frame. Each animation is
    evaluated and blended into the currently playing animation.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, you will implement the `CrossFadeController` class.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，您将实现`CrossFadeController`类。
- en: Implementing the cross-fade controller
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现淡出控制器
- en: 'Create a new file, `CrossFadeController.cpp`. `CrossFadeController` is implemented
    in this new file. Follow these steps to implement `CrossFadeController`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新文件，`CrossFadeController.cpp`。在这个新文件中实现`CrossFadeController`。按照以下步骤实现`CrossFadeController`：
- en: 'In the default constructor, set a default value of `0` for the current clip
    and time and mark the skeleton as not set. There is a convenience constructor
    that takes a skeleton reference. The convenience constructor should call the `SetSkeleton`
    function:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在默认构造函数中，为当前剪辑和时间设置默认值`0`，并将骨骼标记为未设置。还有一个方便的构造函数，它接受一个骨骼引用。方便的构造函数应调用`SetSkeleton`函数：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Implement the `SetSkeleton` function, which copies the provided skeleton into
    `CrossFadeController`. It marks the class as having its skeleton set and copies
    the rest pose into the internal pose of the crossfade controller:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`SetSkeleton`函数，将提供的骨骼复制到`CrossFadeController`中。它标记该类的骨骼已设置，并将静止姿势复制到交叉淡出控制器的内部姿势中：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Implement the `Play` function. This function should clear any active crossfades.
    It should set the clip and playback time, but it also needs to reset the current
    pose to the rest pose of the skeleton:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`Play`函数。此函数应清除任何活动的交叉淡出。它应设置剪辑和播放时间，但还需要将当前姿势重置为骨骼的静止姿势：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Implement the `FadeTo` function, which should check whether the requested fade
    target is valid. A fade target is only valid if it is not the first or last item
    in the fade list. Assuming these conditions are met, the `FadeTo` function adds
    the provided animation clip and duration to the fade list:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`FadeTo`函数，该函数应检查请求的淡出目标是否有效。淡出目标仅在不是淡出列表中的第一个或最后一个项目时才有效。假设满足这些条件，`FadeTo`函数将提供的动画剪辑和持续时间添加到淡出列表中：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Implement the `Update` function to play the active animation and blend in any
    other animations that are in the fade list:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`Update`函数以播放活动动画并混合任何在淡出列表中的其他动画：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Set the current animation as the target animation and remove the fade object
    if an animation has finished fading. Only one target is removed per frame. If
    you want to remove all the faded-out targets, change the loop to go backward:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将当前动画设置为目标动画，并在动画淡出完成时移除淡出对象。每帧只移除一个目标。如果要移除所有已淡出的目标，请将循环改为反向：
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Blend the fade list with the current animation. The current animation and all
    the animations in the fade list will need to be sampled:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将淡出列表与当前动画混合。需要对当前动画和淡出列表中的所有动画进行采样：
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Finish the `CrossFadeController` class implementation with the `GetCurrentPose`
    and `GetCurrentclip` helper functions. These are simple getter functions:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`GetCurrentPose`和`GetCurrentclip`辅助函数完成`CrossFadeController`类的实现。这些都是简单的getter函数：
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Instead of manually controlling what animation is playing, you can now create
    an instance of `CrossFadeController` to control animation playback. The `CrossFadeController`
    class automatically fades to new animations when you start playing them. In the
    next section, you will explore additive animation blending.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以创建`CrossFadeController`的实例来控制动画播放，而不是手动控制正在播放的动画。`CrossFadeController`类在开始播放新动画时会自动淡出到新动画。在下一部分中，您将探索加法动画混合。
- en: Additive blending
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加法混合
- en: Additive animations are used to modify an animation by adding in extra joint
    movements. A common example is leaning left. If there is a leaning-left animation
    that simply bends the character's spine, it can be added to a walking animation
    to create a leaning-left-while-walking animation, a running animation, or any
    other kind of animation.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 加法动画用于通过添加额外的关节运动来修改动画。一个常见的例子是向左倾斜。如果有一个向左倾斜的动画，它只是简单地弯曲了角色的脊柱，它可以添加到行走动画中，以创建一个边走边倾斜的动画，奔跑动画，或者任何其他类型的动画。
- en: Not all animations are a good fit for additive animations. Additive animations
    are usually specifically made. I have added a `Lean_Left` animation to the `Woman.gltf`
    file provided with the sample code for this chapter. This animation is made to
    be additive. It only bends one of the spine joints.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有动画都适合作为加法动画。加法动画通常是专门制作的。我已经在本章的示例代码中提供的`Woman.gltf`文件中添加了一个`Lean_Left`动画。这个动画是为了加法而制作的。它只弯曲了脊柱关节中的一个。
- en: Additive animations typically don't play according to time, but rather, according
    to some other input. Think of leaning left as an example—it should be controlled
    by the user's joystick. The closer the joystick is to the left, the further in
    the animation the lean should go. It's common to sync the playback of additive
    animations to something other than time.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 加法动画通常不是根据时间播放，而是根据其他输入播放。以向左倾斜为例——它应该由用户的操纵杆控制。操纵杆越靠近左侧，倾斜的动画就应该越进。将加法动画的播放与时间以外的其他内容同步是很常见的。
- en: Declaring additive animations
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明加法动画
- en: The functions for additive blending are declared in `Blending.h`. The first
    function, `MakeAditivePose`, samples the additive clip at time `0` into an output
    pose. This output pose is the reference that is used to add two poses together.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 加法混合的函数声明在`Blending.h`中。第一个函数`MakeAditivePose`在时间`0`处对加法剪辑进行采样，生成一个输出姿势。这个输出姿势是用来将两个姿势相加的参考。
- en: 'The `Add` function performs the additive blending process between two poses.
    The additive blending formula is *result pose* = *input pose* + (*additive pose
    – additive base pose*). The first two arguments, which are the output pose and
    the input pose, can point to the same pose. To apply an additive pose, both the
    additive pose and a reference for the additive pose are needed:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`Add`函数执行两个姿势之间的加法混合过程。加法混合公式为*result pose* = *input pose* + (*additive pose
    – additive base pose*)。前两个参数，即输出姿势和输入姿势，可以指向同一个姿势。要应用加法姿势，需要加法姿势和加法姿势的引用：'
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `MadeAdditivePose` helper function generates the additive base pose that
    the `Add` function takes for its fourth argument. The function is intended to
    be called during initialization time. In the next section, you will implement
    these functions.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`MadeAdditivePose`辅助函数生成`Add`函数用于其第四个参数的附加基础姿势。该函数旨在在初始化时调用。在下一节中，您将实现这些函数。'
- en: Implementing additive animations
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现附加动画
- en: 'Implement the `MakeAdditivePose` function in `Blending.cpp`. This function
    is only intended to be called during load time. It should sample the provided
    clip at the start time of the clip. The result of that sample is the additive
    base pose:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Blending.cpp`中实现`MakeAdditivePose`函数。该函数仅在加载时调用。它应在剪辑的开始时间对提供的剪辑进行采样。该采样的结果是附加基础姿势：
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The formula for additive blending is *result pose* = *input pose* + (*additive
    pose – additive base pose*). The subtraction of the additive base pose only applies
    the delta of the additive animation between the first and current frames of the
    animation. Because of this, you can only animate one bone, say, one of the spine
    bones, and achieve an effect that makes the character lean left.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 附加混合的公式为*结果姿势* = *输入姿势* + (*附加姿势 - 附加基础姿势*)。减去附加基础姿势只应用于动画的第一帧和当前帧之间的附加动画增量。因此，您只能对一个骨骼进行动画，比如脊柱骨骼之一，并实现使角色向左倾斜的效果。
- en: 'To implement additive blending, loop through every joint of the pose. As with
    regular animation blending, there is a `blendroot` parameter that needs to be
    considered. Follow the provided formula using the local transform of each joint:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现附加混合，需要循环遍历每个姿势的关节。与常规动画混合一样，需要考虑`blendroot`参数。使用每个关节的本地变换，按照提供的公式进行操作：
- en: '[PRE15]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Important information
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 重要信息
- en: Quaternions don't have a subtraction operator. To remove the rotation of quaternion
    *A* from quaternion *B*, multiply *B* by the inverse of *A*. The inverse of a
    quaternion applies the opposite of a rotation, which is why a quaternion multiplied
    by its inverse results in the identity.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 四元数没有减法运算符。要从四元数*A*中移除四元数*B*的旋转，需要将*B*乘以*A*的逆。四元数的逆应用相反的旋转，这就是为什么四元数乘以其逆的结果是单位。
- en: Additive animations are most often used to create new animation variants—for
    example, mixing a walking animation with a crouching pose to create a crouched
    walk. All animations can be additively blended with the crouched pose to create
    crouching versions of the animations programmatically.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 附加动画通常用于创建新的动画变体，例如，将行走动画与蹲姿混合以创建蹲行动画。所有动画都可以与蹲姿进行附加混合，以在程序中创建动画的蹲姿版本。
- en: Summary
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned how to blend multiple animations. Blended animations
    can blend the whole hierarchy or just a subset. You also built a system to manage
    the fading between animations when a new animation plays. We also covered additive
    animations, which can be used to create a new motion when given the joint angles
    to interpolate between.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学会了如何混合多个动画。混合动画可以混合整个层次结构或只是一个子集。您还构建了一个系统，用于管理在播放新动画时动画之间的淡入淡出。我们还介绍了附加动画，可以在给定关节角度的情况下用于创建新的运动。
- en: There are four samples included in the downloadable materials for this chapter.
    `Sample00` is all the code up to this point in the book. `Sample01` demonstrates
    how to use the `Blend` function by blending between a walk and a run animation
    on a timer. `Sample02` demonstrates the use of the cross-fade controller by crossfading
    to random animations and `Sample03` demonstrates how to use additive animation
    blending.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的可下载材料中包括四个示例。`Sample00`是本书到目前为止的所有代码。`Sample01`演示了如何使用`Blend`函数，通过定时器在行走和奔跑动画之间进行混合。`Sample02`演示了交叉淡入淡出控制器的使用，通过交叉淡入淡出到随机动画。`Sample03`演示了如何使用附加动画混合。
- en: In the next chapter, you will learn about inverse kinematics. Inverse kinematics
    allows you to figure out how the limb of a character should be bent according
    to where its ends are. Think about pinning the foot of a character onto uneven
    terrain.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将学习逆向运动学。逆向运动学允许您根据角色的末端位置来确定角色的肢体应该弯曲的方式。想象一下将角色的脚固定在不平整的地形上。
