- en: '*Chapter 12*: Blending between Animations'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The transition from one animation to another can be jarring. Imagine if a character
    is in the middle of a punch and the player decides that they want to start running.
    If the animation just switches from the jump clip to the run clip, the transitions
    will be hard and unnatural.
  prefs: []
  type: TYPE_NORMAL
- en: Animation blending can fix this by generating intermediate frames that are an
    average of both animations. This fade is usually short—a quarter of a second or
    less. The smooth animated transition generated by this short blend provides a
    much better looking experience.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter explores how to implement animation blending and additive animation
    blending and how to set up a crossfade controller to manage a blend queue. The
    following topics will be covered:'
  prefs: []
  type: TYPE_NORMAL
- en: Pose blending
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Crossfading animations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additive blending
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pose blending
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Animation blending is a linear blend between two poses in the local space of
    each joint. Think of it as a `lerp` or `mix` function but applied to an entire
    pose. This technique does not blend animation clips; rather, it blends the poses
    that these clips have been sampled into.
  prefs: []
  type: TYPE_NORMAL
- en: When blending two poses, the entire pose does not need to be blended. Assume
    there are two animations—a run cycle and an attack. If the player presses the
    attack button, the top half of the attack pose is blended in over a short period
    of time, maintains a weight of `1` throughout the animation, and is then blended
    out near the end of the animation.
  prefs: []
  type: TYPE_NORMAL
- en: This is an example of using pose blending to create a running attack animation
    without having to animate the legs of the attack animation. The attack animation
    could be blended on top of a walk cycle for a walking animation. Animation blending
    can be used to transition smoothly between animations or to combine multiple animations
    into a new one.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, you will declare a `Blend` function for the `Pose`
    class. This `Blend` function will linearly interpolate between two poses, similar
    to how a vector `lerp` works. The function needs two poses and an interpolation
    value, commonly represented as `t`, which has a range of `0` to `1`
  prefs: []
  type: TYPE_NORMAL
- en: Declaring the Blend function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Blend` function takes two poses—a mix value and a root node—as arguments.
    When the mix value is `0`, the `Blend` function returns the first pose, and when
    it is `1`, it returns the second pose. For any values between `0` and `1`, the
    poses are blended. The root node decides which node (and its children) of the
    second animation should be blended into the first animation.
  prefs: []
  type: TYPE_NORMAL
- en: 'To accommodate specifying a root bone to start blending from, there needs to
    be a way to check whether one node is in the hierarchy of another node. The `IsInHierarchy`
    function takes a `Pose` class, a node that is the root node, and a node that is
    the search node. If the search node is a descendant of the root node, the function
    returns `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: When blending two poses, it is assumed that the poses are similar. Similar poses
    have the same number of joints, and each joint has the same parent index between
    the poses. In the following section, you will implement the `Blend` function.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Blend function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For blending to work, it must happen in local space, which is convenient for
    blending between two poses. Loop through all the joints in the input poses and
    interpolate between the local transforms of the joint in both poses that are being
    blended. For the position and scale, use the vector `lerp` function, and for the
    rotation, use the quaternion `nlerp` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'To support an animation root, check whether the current transform is a descendant
    of the blend root. If it is, carry out the blend. If it is not, skip the blend
    and keep the transform values of the first input pose. Follow these steps to implement
    the hierarchy check and `Blend` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To check whether one joint is the descendant of another, follow the descendant
    joint all the way up the hierarchy until the root node. If any of the nodes encountered
    in this hierarchy are the node that you are checking against, return `true`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'To blend two poses together, loop through the joints of each pose. If the current
    joint is not in the blend root''s hierarchy, don''t blend it. Otherwise, blend
    the `Transform` objects using the `mix` function you wrote in [*Chapter 5*](B16191_05_Final_JC_ePub.xhtml#_idTextAnchor094),
    *Implementing Transforms*. The `mix` function takes quaternion neighborhooding
    into account:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: If two animations are blended using the whole hierarchy, the root argument to
    `Blend` will be negative. With a negative joint for the blend root, the `Blend`
    function skips the `IsInHierarchy` check. In the following section, you will explore
    how to fade between two animations for a smooth transition.
  prefs: []
  type: TYPE_NORMAL
- en: Crossfading animations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most common use case for blending animations is crossfading between two
    animations. A **crossfade** is a fast blend from one animation to another. The
    goal of the crossfade is to hide the transition between two animations.
  prefs: []
  type: TYPE_NORMAL
- en: Once a crossfade is done, the active animation needs to be replaced by the animation
    that you are fading to. If you are fading to multiple animations, they are all
    evaluated. The ones that end the soonest are removed first. Animations that are
    requested are added to a list, and animations that have faded out are removed
    from the list.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, you will build a `CrossFadeController` class that
    takes care of the crossfade logic. This class provides a simple intuitive API
    that makes fading between animations simple with just one function call.
  prefs: []
  type: TYPE_NORMAL
- en: Creating helper classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When fading an animation into an already-sampled pose, you need to know what
    the animation being faded is, it's current playtime, the length of the fade durations,
    and the current time of the fade. These values are used to perform the actual
    blend and contain data about the state of the blend.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file and name it `CrossFadeTarget.h` to implement the `CrossFadeTarget`
    helper class in. This helper class contains the variables described previously.
    The default constructor should set the value of everything to `0`. A convenience
    constructor that takes a clip pointer, pose reference, and duration is also provided:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `mPose`, `mClip`, and `mTime` variables of the `CrossFadeTarget` helper
    class are used in every frame to sample the animation that is being faded to.
    The `mDuration` and `mElapsed` variables are used to control how much the animation
    should be faded in.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you will implement a class that controls animation playback
    and fading.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring the cross-fade controller
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Keeping track of the currently playing clip and managing the fading is the job
    of a new `CrossFadeController` class. Create a new file, `CrossFadeController.h`,
    to declare the new class in. This class needs to contain a skeleton, a pose, the
    current playback time, and an animation clip. It also needs a vector of the `CrossFadeTarget`
    objects that control the animation blending.
  prefs: []
  type: TYPE_NORMAL
- en: Both the `CrossFadeController` and `CrossFadeTarget` classes contain pointers
    to animation clips, but they don't own these pointers. Because neither class owns
    the memory for the pointers, the generated constructor, copy constructor, assignment
    operator, and destructor should be fine to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `CrossFadecontroller` class needs functions to set the current skeleton,
    retrieve the current pose, and retrieve the current clip. The current animation
    can be set with the `Play` function. New animations can be blended in using the
    `FadeTo` function. Since the `CrossFadeController` class manages animation playback,
    it needs an `Update` function to sample the animation clips:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The entire `mTargets` list is evaluated with every frame. Each animation is
    evaluated and blended into the currently playing animation.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, you will implement the `CrossFadeController` class.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the cross-fade controller
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new file, `CrossFadeController.cpp`. `CrossFadeController` is implemented
    in this new file. Follow these steps to implement `CrossFadeController`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the default constructor, set a default value of `0` for the current clip
    and time and mark the skeleton as not set. There is a convenience constructor
    that takes a skeleton reference. The convenience constructor should call the `SetSkeleton`
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `SetSkeleton` function, which copies the provided skeleton into
    `CrossFadeController`. It marks the class as having its skeleton set and copies
    the rest pose into the internal pose of the crossfade controller:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `Play` function. This function should clear any active crossfades.
    It should set the clip and playback time, but it also needs to reset the current
    pose to the rest pose of the skeleton:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `FadeTo` function, which should check whether the requested fade
    target is valid. A fade target is only valid if it is not the first or last item
    in the fade list. Assuming these conditions are met, the `FadeTo` function adds
    the provided animation clip and duration to the fade list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `Update` function to play the active animation and blend in any
    other animations that are in the fade list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Set the current animation as the target animation and remove the fade object
    if an animation has finished fading. Only one target is removed per frame. If
    you want to remove all the faded-out targets, change the loop to go backward:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Blend the fade list with the current animation. The current animation and all
    the animations in the fade list will need to be sampled:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Finish the `CrossFadeController` class implementation with the `GetCurrentPose`
    and `GetCurrentclip` helper functions. These are simple getter functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Instead of manually controlling what animation is playing, you can now create
    an instance of `CrossFadeController` to control animation playback. The `CrossFadeController`
    class automatically fades to new animations when you start playing them. In the
    next section, you will explore additive animation blending.
  prefs: []
  type: TYPE_NORMAL
- en: Additive blending
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Additive animations are used to modify an animation by adding in extra joint
    movements. A common example is leaning left. If there is a leaning-left animation
    that simply bends the character's spine, it can be added to a walking animation
    to create a leaning-left-while-walking animation, a running animation, or any
    other kind of animation.
  prefs: []
  type: TYPE_NORMAL
- en: Not all animations are a good fit for additive animations. Additive animations
    are usually specifically made. I have added a `Lean_Left` animation to the `Woman.gltf`
    file provided with the sample code for this chapter. This animation is made to
    be additive. It only bends one of the spine joints.
  prefs: []
  type: TYPE_NORMAL
- en: Additive animations typically don't play according to time, but rather, according
    to some other input. Think of leaning left as an example—it should be controlled
    by the user's joystick. The closer the joystick is to the left, the further in
    the animation the lean should go. It's common to sync the playback of additive
    animations to something other than time.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring additive animations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The functions for additive blending are declared in `Blending.h`. The first
    function, `MakeAditivePose`, samples the additive clip at time `0` into an output
    pose. This output pose is the reference that is used to add two poses together.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Add` function performs the additive blending process between two poses.
    The additive blending formula is *result pose* = *input pose* + (*additive pose
    – additive base pose*). The first two arguments, which are the output pose and
    the input pose, can point to the same pose. To apply an additive pose, both the
    additive pose and a reference for the additive pose are needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `MadeAdditivePose` helper function generates the additive base pose that
    the `Add` function takes for its fourth argument. The function is intended to
    be called during initialization time. In the next section, you will implement
    these functions.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing additive animations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Implement the `MakeAdditivePose` function in `Blending.cpp`. This function
    is only intended to be called during load time. It should sample the provided
    clip at the start time of the clip. The result of that sample is the additive
    base pose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The formula for additive blending is *result pose* = *input pose* + (*additive
    pose – additive base pose*). The subtraction of the additive base pose only applies
    the delta of the additive animation between the first and current frames of the
    animation. Because of this, you can only animate one bone, say, one of the spine
    bones, and achieve an effect that makes the character lean left.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement additive blending, loop through every joint of the pose. As with
    regular animation blending, there is a `blendroot` parameter that needs to be
    considered. Follow the provided formula using the local transform of each joint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Important information
  prefs: []
  type: TYPE_NORMAL
- en: Quaternions don't have a subtraction operator. To remove the rotation of quaternion
    *A* from quaternion *B*, multiply *B* by the inverse of *A*. The inverse of a
    quaternion applies the opposite of a rotation, which is why a quaternion multiplied
    by its inverse results in the identity.
  prefs: []
  type: TYPE_NORMAL
- en: Additive animations are most often used to create new animation variants—for
    example, mixing a walking animation with a crouching pose to create a crouched
    walk. All animations can be additively blended with the crouched pose to create
    crouching versions of the animations programmatically.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to blend multiple animations. Blended animations
    can blend the whole hierarchy or just a subset. You also built a system to manage
    the fading between animations when a new animation plays. We also covered additive
    animations, which can be used to create a new motion when given the joint angles
    to interpolate between.
  prefs: []
  type: TYPE_NORMAL
- en: There are four samples included in the downloadable materials for this chapter.
    `Sample00` is all the code up to this point in the book. `Sample01` demonstrates
    how to use the `Blend` function by blending between a walk and a run animation
    on a timer. `Sample02` demonstrates the use of the cross-fade controller by crossfading
    to random animations and `Sample03` demonstrates how to use additive animation
    blending.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn about inverse kinematics. Inverse kinematics
    allows you to figure out how the limb of a character should be bent according
    to where its ends are. Think about pinning the foot of a character onto uneven
    terrain.
  prefs: []
  type: TYPE_NORMAL
