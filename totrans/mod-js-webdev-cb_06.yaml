- en: Developing with React
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Starting out with React
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reinstalling your tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Composing components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling life cycle events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simplifying component development with Storybook
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the last three chapters, we were developing a backend with `Node`, and now
    we''ll turn to the frontend and build a web application: in particular, a **Single
    Page Application** (**SPA**) in the modern style users have gotten used to.'
  prefs: []
  type: TYPE_NORMAL
- en: Starting out with React
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Suppose you want to build a web application. How would you go about it? Unless
    you have been hiding away somewhere, you are probably aware that there are many
    frameworks out there that can help you construct and organize your web page. However,
    you might be wondering, if you already know HTML, CSS, and JS, why use a framework
    at all, instead of just keeping with vanilla JS, and possibly some library like
    `jQuery` or `Lodash`? After all, a framework imposes some rules and ways of working
    that you could consider to be offputting or bothersome.
  prefs: []
  type: TYPE_NORMAL
- en: 'You also have to *learn* how to use the framework, of course, and you probably
    won''t benefit from it until you become proficient. So, there are several possible
    answers for the *why?* question – even including *Sure, don''t use any framework! – *which
    could be just fine for a very small, simple project:'
  prefs: []
  type: TYPE_NORMAL
- en: Frameworks provide you with a well-tested, solid way, to organize your project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Frameworks usually scale better for large size applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Frameworks let you work at a higher level of abstractions (for example, creating
    and using your own components) and deal with the nitty-gritty aspects of getting
    everything to work
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ramping up new developers is usually simpler: if they know the framework, they
    already know where things are supposed to go and how they interact with each other'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of course, as I mentioned previously, all of these advantages do not apply for
    small projects, with a few developers.
  prefs: []
  type: TYPE_NORMAL
- en: There's one extra reason, however, that can be considered even more important.
    Frameworks help you with the difficult task of keeping state (data) and view in
    sync. With large applications, a change or event that happens in one *corner*
    of your application may have implications elsewhere, in other places of the same
    application. Trying to wire things up so that all of the changes are correctly
    propagated throughout your code isn't a simple endeavor.
  prefs: []
  type: TYPE_NORMAL
- en: Most frameworks automatically generate the view from the data, and whenever
    anything changes in the state, they do whatever's needed to update the screen
    in an optimal fashion. For example, say you had a list of doodads somewhere. Then,
    you call a webservice and you get an updated list—most doodads match, but some
    are added and some are missing. You could, of course, just recreate the list from
    zero, but that wouldn't look very good, and if you decide to regenerate the whole
    screen every time something changes, performance will suffer. Usually, what will
    happen is that the framework will compute the differences between the current
    list and the new one, and will correspondingly update the HTML code, adding or
    removing DOM elements, so that the list is once again correct. Doing all of this
    by hand, extending this to your whole application, would be a tad too much to
    do!
  prefs: []
  type: TYPE_NORMAL
- en: There are several well-known frameworks such as `Angular` (by Google), `Vue`,
    `Ember`, `Backbone`, `Knockout`, and so on. (Sometimes you feel that a new framework
    is born every day!) We'll be using `React` (by Facebook) in this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'An admission: `React` is more correctly called a *library* than a framework,
    because it doesn''t include everything you need to develop your application out
    of the box. However, all of the necessary packages are out there, so that won''t
    impede us. By the way, this sort of criticism also applies to `Vue`, `Knockout`,
    and `Backbone`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`React` also extends to doing mobile applications with `React-Native`, which
    we''ll see later in this book in [Chapter 11](c6b4a41a-3937-419b-8b75-2d6e96452702.xhtml),
    *Creating Mobile Apps with React Native*.'
  prefs: []
  type: TYPE_NORMAL
- en: An interesting article, *The Ultimate Guide to JavaScript Frameworks*, at [https://javascriptreport.com/the-ultimate-guide-to-javascript-frameworks/](https://javascriptreport.com/the-ultimate-guide-to-javascript-frameworks/),
    lists over fifty frameworks! Take a look, and see what pros and cons each framework
    has.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we'll install the necessary packages and build a very basic
    first web application of our own.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's go ahead and create our basic application. If you had to set up a project
    purely by hand, you'd find yourself having to deal with many different tools,
    such as `Babel` for transpiling, `ESLint` for code checks, `Jest` for testing,
    or `Webpack` in order to pack all of your application together, instead of having
    to send dozens or hundreds of individual files over the web. However, nowadays,
    there is a much simpler tool, `create-react-app`, that can deal with this chore
    and get you set up for `React` development in a jiffy. The key selling point is
    *zero configuration*, meaning that some reasonable good choices for both development
    and production builds have been selected, and you can directly move on to writing
    code, not really caring about myriad configuration details.
  prefs: []
  type: TYPE_NORMAL
- en: For people in the know, `create-react-app` is known as CRA, and that's the name
    we'll be using. By the way, CRA is not the only possible way to create a project;
    for example, `react-boilerplate` (at [https://github.com/react-boilerplate/react-boilerplate](https://github.com/react-boilerplate/react-boilerplate))
    provides an alternate solution, but the chosen set of packages and tools are more
    suited to experienced `React` developers.
  prefs: []
  type: TYPE_NORMAL
- en: To create the basic structure (which we'll explain later on) we'll use `npx`
    to run the application creator tool, as shown in the following code. Since we
    are at Chapter 6, let's (imaginatively!) name our project `chapter06`!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are curious, `npx` is similar to `npm`, but it executes a *binary* command,
    which is either found in your `node_modules` directory, or at a central cache,
    even installing any packages it might need to run. For more information, go to
    its GitHub page at [https://github.com/zkat/npx](https://github.com/zkat/npx),
    or better yet, read an article by npx''s creator, *Introducing npx: an npm package
    runner* at [https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b](https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b).'
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Running the script will create a basic project structure, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A `package.json` file, and a corresponding `node_modules` directory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `README.md` file, essentially a copy of what you can find at [https://github.com/wmonk/create-react-app-typescript/blob/master/packages/react-scripts/template/README.md](https://github.com/wmonk/create-react-app-typescript/blob/master/packages/react-scripts/template/README.md).
    Pay particular attention to it, because it's full of tips, suggestions, and solutions
    to usual problems you may encounter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `public/` directory, with the `index.html` basic HTML code for your application,
    plus a `favicon.ico` icon file and a `manifest.json` file describing your app.
    (If you want to read more about the latter, check out [https://developer.mozilla.org/en-US/Add-ons/WebExtensions/manifest.json](https://developer.mozilla.org/en-US/Add-ons/WebExtensions/manifest.json).)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `src/` directory with the `index.js` JS basic code for your application, `index.css`
    with CSS styles, and an `App` component that shows some welcome text, plus some
    basic instructions. All of your JS and CSS files should be placed in `src/` or
    in subdirectories within it, otherwise they won't be included in the build.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Basically, you will want to edit the `index.*` and `App.*` files, and grow
    the project by expanding its structure to provide more components, styles, and
    so on. (Be careful: don''t change the names of the `index.*` files, or your project
    won''t run!) Before getting into writing code, and as shown in the preceding run,
    in the created project directory, you should try `npm start`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'By doing this, you''ll be able to see the new application, as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/edd6e9b1-b0cd-491b-b374-c8f1e4444b86.png)'
  prefs: []
  type: TYPE_IMG
- en: The created application, ready for you to start coding
  prefs: []
  type: TYPE_NORMAL
- en: If you wish, you can make any kind of minor change in `App.js`, save it, and
    notice the immediate change in the browser page. As to what features of JS you
    can use in your coding, the project is set to accept most modern options, from
    ES6 (full), ES7 (like the exponentiation operator, which you may probably never
    use!), and even newer (most interestingly, `async` and `await`), plus some *Stage
    3* proposals; check [https://github.com/facebook/create-react-app/blob/master/packages/react-scripts/template/README.md#supported-language-features-and-polyfills](https://github.com/facebook/create-react-app/blob/master/packages/react-scripts/template/README.md#supported-language-features-and-polyfills) for
    an updated list. It's noteworthy that Flow is recognized, and also JSX, which
    we'll be using in later sections.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It may happen, at some time, that you need to do some extra configuration that
    CRA hasn't considered, or that you are unable to add it otherwise. In this case,
    you can use the `npm run eject` command to move all of the configuration, scripts,
    and dependencies directly into your project so that you can start tweaking things
    in any way you want. Of course, this will be harder than using the *zero configuration*
    setup, but at least you won't be locked in, with no way out.
  prefs: []
  type: TYPE_NORMAL
- en: If you are curious to learn where all of those things are hidden away, possibly
    to study how everything is set up, the answer is "in the `node_modules/create_react_app`"
    directory; ejecting the project copies things from that directory to your project's.
  prefs: []
  type: TYPE_NORMAL
- en: Reinstalling your tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have been using `ESLint` for code quality checks, `Prettier` for formatting,
    and `Flow` for data types. In this recipe, we'll get these packages back to work,
    and we'll leave testing (`Jest`, plus more) for [Chapter 10](95a025ab-5e4e-4652-b5b2-33426fb7ec79.xhtml),
    *Testing your Application*. Doing this for two of our tools will be quite straightforward,
    but a tad more complex for the third.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With a fully manual installation, getting everything to work together will be
    quite difficult, but CRA already includes practically everything we need, so all
    you have to do is add some configuration details.
  prefs: []
  type: TYPE_NORMAL
- en: Reinstalling Flow and Prettier
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start with `Flow`. It''s quite simple to do this: I just did the same
    as for `Node`, adding the same packages, scripts, `.flowconfig` file, and so on.
    (If you need to, check out the *Adding Flow for Data Types checks* section of
    [Chapter 1](d13c6d45-6e6b-4119-9dcd-a65ee7af9f6f.xhtml), *Working with JavaScript
    Development Tools* for more information.)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s deal with `Prettier`. It also is a simple matter: I had to remove
    the following lines from `package.json` and put them in a separate `.prettierrc`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '`Flow` already *knows* about `React` and CRA, so you won''t need anything with
    regard to that. However, to use `PropTypes` (we''ll get to that very soon), you''ll
    need the appropriate flow-typed package, which is easy to install:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Reinstalling ESLint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Finally, our third tool will require a bit more work. For `ESLint`, we cannot
    use `package.json` either, and we need a `.eslintrc` file. But, even if you extract
    that part, you''ll find that the configuration doesn''t pay attention to your
    settings, and that''s because CRA has its own set of `ESLint` rules, which you
    cannot change! Unless, of course, you decide to eject the project and start doing
    configuration by yourself, which you''ll want to avoid for as long as possible. There''s
    a package, `react-app-rewired`, that lets you change the internal configurations
    without ejection. Start by installing a couple of required packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'As for rules themselves, you''ll want to have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you''ll have to change a few scripts in `package.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, create a `config-overrides.js` files, at the root of your project,
    at the same level of the `package.json` file. The  `/* global module */` comment
    is there to avoid an error that will pop up after `ESLint` gets to work, reporting
    that `module` isn''t defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You''re all set! Your `.eslintrc` file should look as follows, with some additions
    and changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: If you are wondering why I left the line for `Node`, it's because `Storybook`
    (which we'll see near the end of this chapter) uses a `module` variable, which
    would otherwise be marked as undefined.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this case, there's not too much to explain. The normal configuration of the
    project already includes all of the tools we need, so we are just configuring
    a bit instead of just going with the standard.
  prefs: []
  type: TYPE_NORMAL
- en: As for `ESLint`, when you now use `npm start`, the `ESLint` configuration will
    get *rewired* to work with your configuration instead of CRA's one. This means
    that all of your standard settings and checks will continue to run, and you'll
    apply the same quality checks for React than for other JS code—except, obviously,
    for the React-specific ones.
  prefs: []
  type: TYPE_NORMAL
- en: You can read more about `react-app-rewired` at [https://github.com/timarney/react-app-rewired](https://github.com/timarney/react-app-rewired.).
  prefs: []
  type: TYPE_NORMAL
- en: Defining components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The key idea behind working with `React` is that everything – and I mean, *everything* – is
    a component. Your whole web application will be a component, itself made of other
    components, which will themselves have smaller components, and so on. Components
    generate HTML, which is shown onscreen. The data for the HTML comes from externally
    assigned *props* (*properties*) and internally maintained *state*. Whenever there
    is a change in props or state, React takes care of refreshing the HTML so that
    the view (what the user sees) is always up to date.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an example. Imagine that you want to create a screen that will
    let the user query data about regions of the world. How could you go about designing
    it? Check out the following screenshot for details:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bc5eb0a4-0eb1-462b-8b9f-ac1b15faee08.png)'
  prefs: []
  type: TYPE_IMG
- en: Whenever the user selects a country, we'll show several cards with information
    about its regions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note: I created this sketch at http://www.wireframes.com—but don''t blame the
    tool for my poor sketching ability!'
  prefs: []
  type: TYPE_NORMAL
- en: 'Your whole view would be a component, but it''s fairly obvious that wouldn''t
    help with coding or testing. A good design principle is that *each component should
    be responsible for a single duty*, and if it needs to do more, decompose it into
    smaller components. In our case, we''d have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The whole table is a `RegionsInformationTable`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The part at the top can be the `CountryFilterBar`, with a dropdown for countries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the bottom we have a `ResultsDataTable`, which shows a collection of `ExpandableCard` components,
    each with a title, a toggle, and space for more components. We could have designed
    a specific card for this situation, but having a generic card, whose components
    may be whatever we want, is more powerful.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A first rule involves events, such as clicks on elements, data being entered,
    and so on. They should be passed up until a component is able to fully process
    them: *events flow up*. For example, when the user clicks on the button, that
    component shouldn''t (and couldn''t) fully process it, at the very least because
    it couldn''t access the table. So, the event will be passed up (by means of callbacks)
    until some component is able to deal with it. You may have options: for example,
    the `CountryFilterBar` component could handle calling a service and getting the
    data, but then it would pass the results up to the `RegionsInformationTable`,
    so that it can pass it to the `ResultsDataTable` component, which will itself
    produce the necessary `ExpandableCard` elements. Alternatives would be passing
    the `CountryFilterBar` value up to the `RegionsInformationTable`, which would
    do the search on its own, or passing it even higher, to some component to do the
    search and push the data down as props to our big table.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding explanation helps us with a second decision. You should analyze
    your components hierarchy and decide where data (props or state) should be kept.
    A key rule is: if two (or more) components share data (or if one component produces
    data that other component needs). It should belong to a component higher up, which
    will pass it down as needed: *data flows down*. In our case, we already applied
    that rule when we decided that the regions data would be owned by the `CountryFilterBar`,
    which was then to be passed to the `RegionResults` table; each `ExpandableCard` would
    only work with the props it receives.'
  prefs: []
  type: TYPE_NORMAL
- en: Even if we don't know how to handle web service requests to get the necessary
    data just yet (or, for example, to initialize the countries dropdown), we can
    build a static version of our components and see how it works.
  prefs: []
  type: TYPE_NORMAL
- en: It's better to start with these static aspects of web design, and only afterwards
    deal with the dynamic aspects, such as reacting to events or getting data. Let's
    get to that code.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We need to create several components, and that will allow us to find out how
    we can include components in other components, how to pass properties, how to
    define them, and more. Let's go component by component.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To start a `React` application, all we need is a basic HTML page, and CRA already
    provides one in `public/index.html`. Stripped down to the basics (check the book
    source code for the full version), it''s something like the following, and the
    key part is the `<div>`, in which all of the `React` generated HTML code will
    be placed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The entry point to our application will be `index.js`, which (we''re dropping
    out some lines of code that are irrelevant here) boils down to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Why do we need to define a `root` variable and `if`? The key is a `Flow` check:
    a `document.getElementById(...)` call may produce a web node, or may be null,
    and `Flow` reminds us to check for null before committing to work.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our basic scaffolding, let's get to writing some actual `React`
    components!
  prefs: []
  type: TYPE_NORMAL
- en: Creating the basic App component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start with the `App.js` file; we''ll render a simple `RegionsInformationTable`.
    We are extending a `React` class called `PureComponent`; we''ll explain what this
    implies later. Your own components should have names starting with upper case
    to distinguish them from HTML names, which should go in lower case. Every component
    should have a `.render()` method that produces whatever HTML is needed; there
    are more methods you can use for this, as we''ll see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The only method that must be specified when defining a component is `.render()`.
    Components also have many other methods, including several *life cycle* ones,
    that we'll see later in the *Handling life cycle events* section, but all of them
    are optional.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may be asking yourself: why go to the bother of creating an `<App>` component
    that doesn''t do anything but produce a `<RegionsInformationTable>` component?
    Why not use the latter directly? We''ll get to the reason why in the upcoming
    sections; we''ll want the `<App>` component to do more, such as defining routing,
    managing a store, and so on. So, even in this particular small example, it''s
    overkill – it''s a pattern we want to keep.'
  prefs: []
  type: TYPE_NORMAL
- en: You'll also want to notice that we wrote `React.PureComponent<{}>`, and this
    was to let `Flow` know that our component doesn't need either properties or state.
    In later sections we'll look at more examples that require better type definitions.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the RegionsInformationTable component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can immediately see how the `RegionsInformationTable` component is rendered:
    it just depends on two more of the components we decided that we would create.
    Note that we are returning HTML code as if it were a valid JS value: this is JSX,
    and it provides a very simple way to intermingle JS code and HTML code. We''ll
    have a list of countries (much reduced!) that supposedly comes from a web service,
    and a list of regions (also reduced, with fake data) that would come from a different
    service, after the user has selected a country. This data is the *state* of the
    component; whenever any of those lists changes, React will re-render the component
    and everything it includes. We''ll look at that further in the *Handling State*
    section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This component receives no props, but works with state, so for Flow's sake,
    we had to write `React.PureComponent<{},{countries:..., regions:...}>`, providing
    data types for the state elements. You could also define these data types in a
    separate file (see [https://flow.org/en/docs/types/modules/](https://flow.org/en/docs/types/modules/)
    for more on this), but we'll let it be.
  prefs: []
  type: TYPE_NORMAL
- en: What about the list of countries? The `CountryFilterBar` should show some countries,
    so the parent will provide the list as a prop; let's see how it will receive and
    use that list. We'll also provide a callback, `onSelect`, that the child component
    will use to inform you whenever the user selects a country. Finally, we'll pass
    the list of (fake, hardcoded) regions to the `ResultsDataTable`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A noteworthy comment: props are passed using a `name=...` syntax, as standard
    with HTML elements; your `React` elements are used in the same fashion as common,
    standard HTML ones. The only difference here is that you use braces, in template
    fashion, to include any expression.'
  prefs: []
  type: TYPE_NORMAL
- en: By the way, note that our list of regions starts out empty; the results table
    will have to deal with that. When the user selects a country, the `.update()`
    method will run and load some regions by using the `.setState()` method, which
    we'll see in the following section. Later in this book, we'll also see how to
    use a web service to get that data, but for the time being, a fixed result will
    have to do.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the CountryFilterBar component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next component we need is more complex: it receives a pair of props, and
    that starts by providing `PropTypes` definitions for them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This is our first component that receives props. We''ll have to provide a definition
    for `Flow`, which is easy: the component will receive `list`, an array of objects,
    and `onSelect`, a function with a single string parameter, that doesn''t return
    anything.'
  prefs: []
  type: TYPE_NORMAL
- en: '`React` also lets you define a runtime check for parameters. We define a `propTypes`
    class property, with an element for each actual prop that our component will receive,
    and another `defaultProps` property, for default values should actual ones not
    be provided. Defining the data types is also needed (for example, `onSelect` is
    a function) if they are required or optional (both are required, in this case).
    In development (not in production), whenever you pass props to an object, they
    will be checked against their definitions and a warning will be produced if there
    is some mismatch; this is a good debugging technique.'
  prefs: []
  type: TYPE_NORMAL
- en: Why use both `Flow` and `PropTypes` if it seems that both do the same job? Basically,
    `Flow` is a static checker, while `PropTypes` is a dynamic, runtime checker. If
    you use `Flow` everywhere throughout your application, theoretically, you could
    get by without using `PropTypes`—but since this package, in testing, will catch
    anything you missed, it's an extra "safety net" for your code. I do agree that
    writing two sets of data types is a bother, though.
  prefs: []
  type: TYPE_NORMAL
- en: 'The valid types for this are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`any`, if any type is acceptable – this is not a good practice'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`array`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`arrayOf(someType)`, to specify the values of the array elements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bool`, for Booleans'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`element`, for a React element'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func`, for functions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`instanceOf(SomeClass)`, for an object that must be an instance of a given
    class'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`node`, for anything that can be rendered as HTML, such as numbers or strings'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`number`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`object`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`objectOf(SomeType)`, to specify an object with property values of a given
    type'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`oneOf([...an array of values...])`, to verify that a prop is limited to some
    values'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`oneOfType([...an array of types...])`, to specify that a prop will be one
    of a list of types'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`shape({...an object with types...})`, to completely define an object, including
    keys and value types'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`string`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`symbol`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can go even further and define, for example, specific functions for type
    validation. For a complete explanation of all of the possibilities of `PropTypes`,
    read [https://reactjs.org/docs/typechecking-with-proptypes.html](https://reactjs.org/docs/typechecking-with-proptypes.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, how would we generate the HTML for the filter? We need several `<option>`
    elements, and we can apply `.map()` to `this.props.list` (properties are accessed
    through `this.props`) as follows. Also note how we use the `onChange` callback
    to inform the parent component whenever a different country is selected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The input properties (`this.props`) should be considered read-only, and never
    modified. On the other hand, the component's state (`this.state`) is read-write
    and can be modified, though not directly but rather through `this.setState()`,
    as we'll see.
  prefs: []
  type: TYPE_NORMAL
- en: A special explanation is needed for the `key=` attribute. Whenever you define
    a list (with `<option>` or `<li>`, for example) and React needs to re-render it,
    the key attribute is used to recognize already available elements and avoid regenerating
    them, but rather reuse them. Keep in mind that the `CountryFilterBar` component
    will be called, over time, with different lists of countries to render, so React
    will optimize its performance by avoiding the creation of already existing list
    elements.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the ResultsDataTable component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Building the results table is easy, and requires similar work to what we did
    with the countries selector. We only have to check the special case when we haven''t
    got any regions to show:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'A side comment: `React` allows us to define props as optional (meaning that
    no `isRequired` is included when defining `PropTypes`) and to provide default
    values instead. In this case, if results could be *not* provided, you would have
    written the following code, using `defaultProps` to provide the necessary default
    values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In terms of `Flow` and `PropTypes`, the definition is very much similar to the
    previous ones. The interesting part is using `.map()` to process all of the received
    objects, creating an `ExpandableCard` for each; this is a very common pattern
    with React. So, all we need now to finish our application is to provide an expandable
    card, so let's get to that.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the ExpandableCard component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For starters, let''s forget about expanding a card—even though that makes the
    name of the component a misnomer! Here, we''ll just make a component that shows
    a few strings. In the *Composing Components* section, we''ll see some interesting
    ways of achieving our original goal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Everything is ready; let's see how and why it functions!
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you start the application with `npm start`, you get our basic screen,
    showing the dropbox with the countries, and no cards, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9d19b73b-35af-41bf-8382-373c442edc67.png)'
  prefs: []
  type: TYPE_IMG
- en: Our basic application, showing fixed, non-varying cards
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, suppose you select a country; what will happen? Let''s follow that, step
    by step:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `CountryFilterBar`, the `onChange` event will fire and will execute a
    callback (`this.props.onSelect()`), providing it with the selected country code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `RegionsInformationTable`, the callback that was provided to the `CountryFilterBar`
    is `this.update()`, so that method will execute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The update method will log the country (just for reference) and use `this.setState`
    (see the next section) to load some regions in the `RegionsInformationTable` state.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The change in state will cause `React` to re-render the component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `CountryFilterBar` won't need re-rendering because neither its props nor
    its state changed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `ResultsDataTable`, on the other hand, will be re-rendered because its props
    will change, receiving a new list of regions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'So, after all this is said and done, the new view will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f5f0f845-1642-40cd-8994-40f552af1691.png)'
  prefs: []
  type: TYPE_IMG
- en: The updated view, after React handles all the necessary re-rendering
  prefs: []
  type: TYPE_NORMAL
- en: 'This is basically how your application will work: events are captured and handled,
    state is changed, props are passed, and `React` takes care of re-rendering whatever
    needs to be re-rendered.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s go back to the `CountryFilterBar` component. We used the most recent
    JS ways to define it, but in many articles and books, you may find an older style
    that you should be aware of, if only to better understand the variant:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We can sum up the differences as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The `propTypes` and `defaultProps` values are defined separately, by directly
    modifying the class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We bind `this.onSelect` in the constructor, so when this method is called, the
    value of `this` will be the `window` object, not what we need.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With modern JS features, this is not needed, but be aware that in older JS code,
    you are likely to find these patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Handling state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous section, we saw the usage of *state* for the regions; let''s
    delve a bit deeper into that. The concept of state is very similar to props, but
    with crucial differences: props are assigned from the outside and are read-only,
    and state is handled privately, and read-write. If a component needs to keep some
    information, which it can use to render itself, then using state is the solution.'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Defining state is done by using class fields, a fairly new feature of JS, that's
    enabled via `Babel` since it isn't fully official yet. (See [https://github.com/tc39/proposal-class-fields](https://github.com/tc39/proposal-class-fields)
    for the proposal, which is at Stage 3, meaning that it's one step away from being
    officially adopted.) With older JS versions, you would have had to create `this.state`
    in the class constructor, but this syntax is clearer. Let's remember what the
    code looked like, and let's drop the Flow definition.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s modify the `RegionsInformationTable` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Second, let''s see what happens when a country changes. Rendering for an object
    can depend on both its props (which it cannot change, as we said) and its state
    (which it can change), but there is an important restriction on updating state.
    You cannot simply assign a new value to the component''s state because it won''t
    be detected by `React`, and then no rendering will be done. Instead, you must
    use the `.setState()` method. This method can be called in different ways, but
    *functional* `.setState()` is the safest way to do this. With this, you must pass
    a function that will receive both state and props and return whatever parts of
    the state need to be updated. In our earlier code, we would have written the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: If you check, you'll see that we didn't include the `state` and `props` parameters
    in the actual code, but that was in order to satisfy ESLint's rule about no unused
    arguments in functions.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Why did we need to pass a function? There''s a key point to understanding this:
    *state updates are asynchronous*. Whenever you call `.setState()`, `React` will
    update the component''s state and start its reconciliation process to update the
    UI view. But what happens if there is more than one `.setState()` call? There
    lies the problem.'
  prefs: []
  type: TYPE_NORMAL
- en: '`React` is allowed to *queue* many such calls together into a single update
    to achieve better performance, and that has an important effect: state may have
    changed before `.setState()` is executed! (Even so, if batching is done, updates
    will be done in the order they are called.) So, you provide a function and `React`
    will call it with the appropriately updated `state` parameter. Don''t do anything
    depending on `this.state` because it may be wrong; always work with the `state`
    parameter.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a shortcut that you should know, in any case. If (and only if) your
    update does not depend in any way on the state or props values, you can use an
    alternative call without requiring a function. For example, our update could have
    been simply written as follows, and `this.state.regions` would be changed, leaving
    the rest of the state unchanged; the key is that the new values for the `regions`
    attribute are not dependent in any way on state or props:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Why would this work? Because in this case, even if the state had changed before,
    your update would still be the same. Be careful, though, and use this syntax only
    when your update is totally independent of state and props; otherwise, use the
    functional approach we showed first.
  prefs: []
  type: TYPE_NORMAL
- en: Once you realize that the state updates are functions, you can move that logic
    out of components, for separate, independent coding and testing, this will be
    quite similar to things we'll be doing with `Redux` in [Chapter 8](70dac9ad-13ec-4c7b-a09c-eb97f396cab1.xhtml),
    *Expanding your Application*. You would write `this.setState(someFunction)` and `someFunction()` would
    be defined separately; your code will have become more declarative in style.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With what we have done here, you may realize that you have all you could need
    to handle state, for any application size – and you would be right! You could
    set up the general state for your whole application in the `App` component (remember
    we mentioned that `App` would have more responsibilities?) and you would be able
    to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Pass it down to components by using props
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update it in answer to events that the components send
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is a perfectly valid solution, and `App.state` could have all sorts of
    data for the whole page. `App` could handle, for example, calling a web service
    to get the regions for a given country, storing the results in its state, and
    passing it to our components so that they can be rendered. In our hardcoded version, `RegionsInformationTable`
    had the list of countries (where did it get it from?) and handled the requests
    for regions (by returning hardcoded data). In reality, as we''ll see later in
    this book, getting this sort of information from a server would be handled differently,
    and at a higher level: `RegionsInformationTable` would handle rendering the table
    and leave data gathering to another part of your solution.'
  prefs: []
  type: TYPE_NORMAL
- en: Even if you passed web services handling to `App`, as your application grows
    in size, this sort of solution may become unwieldy because of the number of data
    fields you may have to keep track of. We'll find a better scalable solution for
    this in [Chapter 8](70dac9ad-13ec-4c7b-a09c-eb97f396cab1.xhtml), *Expanding your
    Application*, by adding a specific package to handle state updates in a more orderly,
    structured fashion.
  prefs: []
  type: TYPE_NORMAL
- en: Composing components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's go back to the `ExpandableCard`, which we didn't quite finish before.
    We could certainly do a regions-specific card, but it seems that the general concept
    of a card that can be expanded or condensed is useful enough that we could prefer
    a more general solution. `React` allows us to do that via *composition*, as we'll
    see in this section.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The component we want to create could have any kind of content. (The same idea
    would apply to generic dialog boxes, header sections, or sidebars, by the way.)
    Instead of creating a base class and using inheritance to create multiple derived
    classes, React allows you to pass a special children prop (`this.props.children`)
    so that you can pass children elements to the original component.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s see how our `ResultsDataTable` code would change. First, the
    `render()` method would have to change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Second, let''s define the component we are using. We are inserting an `ExpandableCard`
    component with a key and a title, and within it we are including a couple of `<div>` elements
    with data for cities and population. This content will be available as `this.prop.children`,
    as we''ll see later. We also added a `title` prop and an internal state, `open`,
    which will be toggled when you expand or condense a card via the `.toggle()` method.
    First, let''s look at the props, state, and types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: For `React`, `Flow` predefines a lot of data types. (You can read more about
    this at [https://github.com/facebook/flow/blob/master/website/en/docs/react/types.md](https://github.com/facebook/flow/blob/master/website/en/docs/react/types.md).)
  prefs: []
  type: TYPE_NORMAL
- en: 'The few more usual ones you are likely to require are as follows, but read
    the aforementioned web page for a full list:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Data Types ** | ** Explanations ** |'
  prefs: []
  type: TYPE_TB
- en: '| `React.ChildrenArray<T>` | An array of children, of type `<T>`, just as shown
    in the previous code. |'
  prefs: []
  type: TYPE_TB
- en: '| `React.Element<typeof Component>` | A node of a specific type: for example,
    `React.Element<"div">` is an element that renders a `<div>`. |'
  prefs: []
  type: TYPE_TB
- en: '| `React.Key` | The type of a prop that is used as key: essentially, either
    a number or a string. |'
  prefs: []
  type: TYPE_TB
- en: '| `React.Node` | Any node that can be rendered, including React elements, numbers,
    strings, Booleans, undefined, null, or arrays of those types. |'
  prefs: []
  type: TYPE_TB
- en: 'Finally, let''s get to the functioning part of the component. Let''s see how
    we show the children of the component when the state of the component shows that
    it should be expanded. Also of interest is looking at how clicking on the card
    calls the `.toggle()` method to change the component''s `state.open` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We're done! Let's see how this all comes together.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When this object is rendered for the first time, `this.state.open` is false,
    so the `.render()` method will just produce the title of the card, plus a triangle
    pointing down, to suggest that the card may be expanded by clicking on it. When
    the user clicks on the triangle, `this.setState()` is called with a function that
    will take the current value of `this.state.open`, and toggle it. `React` will
    decide whether the object needs to be re-rendered (because of the change in state)
    and this time, since `this.state.open` will be true, the expanded, complete version
    of the card will be rendered. In particular, the triangle will be shown pointing
    up, so the user will understand that the card will be condensed if they click
    there. Check out the following screenshot for a trial run, showing some expanded
    and condensed cards:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6ebbbdd8-b518-4165-bb85-4c37b287df5a.png)'
  prefs: []
  type: TYPE_IMG
- en: A run of our application; some cards are expanded and show their children
  prefs: []
  type: TYPE_NORMAL
- en: What's going to be the content of the expanded card? This is where `this.props.children`
    comes in. Whatever elements were provided as props will be rendered here. In this
    way, you can reuse your `ExpandableCard` with any type of content. The main characteristics
    (the title, the triangle to expand/condense the card) will always be there, but
    thanks to the use of composition, you'll be able to have as many versions of expandable
    cards as you may need.
  prefs: []
  type: TYPE_NORMAL
- en: Handling life cycle events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Components don't only have a `.render()` method – they can also implement many
    more *life cycle* events that can help you in specific situations. In this section,
    let's go over all of the available methods and provide ideas about when you will
    use them.
  prefs: []
  type: TYPE_NORMAL
- en: For a full description of all the available methods, go to [https://reactjs.org/docs/react-component.html](https://reactjs.org/docs/react-component.html)
    – but pay careful attention to some deprecated, legacy methods that should be
    avoided, and also read about the conditions and parameters for each method.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s go over the life of a component, in order from the time a component
    is created and placed into the DOM, during its life when it may be updated, up
    to the moment the component is removed from the DOM. We are going to hit only
    the main methods, and even so it''s likely that you won''t get to use all of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '`constructor()`: This method is called before the component is mounted for
    basic setup and initialization. This method is used for all kinds of initialization.
    The only key rule is that you should always start by calling `super(props)` before
    doing anything else, so `this.props` will be created and accessible.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`componentDidMount()`: This method is called after the component is mounted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`shouldComponentUpdate(nextProps, nextState)`: This method is used by React
    to decide whether a component needs to be re-rendered or not.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`render()`: This (mandatory) method produces HTML elements, ideally based only
    on `this.props` and `this.state`. If the function returns a `boolean` or `null` value,
    nothing will be rendered. The method should be pure, not attempting to modify
    the component''s state (which can lead to nasty loops) or to use anything but
    state and props.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`forceUpdate()`: This method is not really a life cycle one, and you can call
    it whenever you want to force a re-rendering to be done.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`componentDidUpdate(previousProps, previousState)`: This method is called after
    a component has been updated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`componentWillUnmount()`: This method is called just before a component is
    going to be unmounted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We went over the methods in the previous section. Now let''s go over some ideas
    about getting the less obvious of them to work:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Methods ** | **Explanations** |'
  prefs: []
  type: TYPE_TB
- en: '| `componentDidMount()` | This is the usual place to start some action to get
    data from a web service. A usual trick for that is to have a state property like
    `this.state.loading` that you initialize to true when you ask for the data and
    reset to false after the data comes in. You can then make the `.render()` method
    produce different outputs, possibly a loading icon, until the data comes, and
    real data afterwards. |'
  prefs: []
  type: TYPE_TB
- en: '| `shouldComponentUpdate(...)` | This method works as a performance optimization,
    allowing React to skip unnecessary updates. With `React.PureComponent`, this is
    implemented by a comparison between the current state and the next state, and
    the current props and the next props. For normal `React.Components` this method
    always returns `true`, forcing re-rendering. If your component is rendered based
    on anything extra (such as other than state and props), you should use a `Component`
    instead of a `PureComponent`. |'
  prefs: []
  type: TYPE_TB
- en: '| `componentDidUpdate(...)` | You could use this method to do some animation,
    or to get data from a web service—but in the latter case, you might want to compare
    the current state and props with the previous values, because if there were no
    changes, the request may not be needed, or it might have already been done. |'
  prefs: []
  type: TYPE_TB
- en: '| `componentWillUnmount()` | This is the usual place to do some cleanup tasks,
    like disabling timers or removing listeners, for example. |'
  prefs: []
  type: TYPE_TB
- en: Simplifying component development with Storybook
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you are developing components, there is a basic, important question: how
    can you try them out? Of course, you could include them somewhere, in any page,
    but then whenever you want to see how they work, you must follow the full path
    through your application so that you can get to actually see the component.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Storybook` is a UI development environment that lets you visualize your components
    in isolation, outside of your application, even making changes to them in an interactive
    way until you get them exactly right!'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, start by installing `Storybook` itself; we are going to use this version
    for `React`, but the tool can also be used with `Angular` and `Vue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add a couple of scripts to `package.json`: one will launch `Storybook`
    (as we''ll see later) and the other will build a standalone application that you
    can use to showcase your components in an independent fashion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s write a simple story for `ExpandableCard`. In the same directory
    where that component is (the final version, which actually allowed expanding and
    compressing, not the first version without that behavior), create a `ExpandableCard.story.js`
    file. What would you want to show about your component? You could display the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: An expandable card with a couple of lines within, as we used previously
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another card with many lines, to show how the card stretches
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A card containing other cards, each of them with some minimal content
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code will look quite similar in style to the tests we wrote for `Node` back
    in [Chapter 5](18752def-acd4-4b7d-9395-a1dad0864f16.xhtml), *Testing and Debugging
    your Server*. I''m assuming that you can figure out what each test does:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: So as not to have a single story, let's write a short one for the `CountryFilterBar`
    component; it will be in the same directory, named `countryFilterBar.story.js`.
    And, yes, I know this is a very simple component, but this is just for our example!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need a launcher. Create a `.storybook` directory at the root of
    the project, and a `config.js` file within, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Yes, it's sort of mysterious—but it basically says to scan the `/src` directory,
    and pick up all of the files whose names end with `.story.js`. Now we are set
    to see how this all comes together.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have written stories for just a couple of our components, but that will
    do for our purposes. To start the `Storybook` server, you''ll have to run one
    of the scripts we created earlier in this section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'After some work, you''ll get the following screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/414d3646-e57c-4fb0-8adc-7b84cecad785.png)'
  prefs: []
  type: TYPE_IMG
- en: The Storybook, showing all of the available stories. You can interact with components,
    click on them, and even test out changes in source code.
  prefs: []
  type: TYPE_NORMAL
- en: You can select any component in the left sidebar (or even use the Filter text
    box), and you'll get the individual stories for it. Clicking on a story will show
    the corresponding component on the right. You can work with the component and
    see how it looks and performs... and if you are not satisfied, you can dynamically
    change its source code, and immediately see the results!
  prefs: []
  type: TYPE_NORMAL
- en: 'To finish, let''s build a separate showcase application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'After this, in the `/out_sb` directory, we will have a full standalone version
    of our showcase. To see how it works, we can use the Web Server for Chrome application
    (search for it in the Chrome extensions) and choose the output directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d567adc8-893b-462b-9cd1-e1e3c29a06a2.png)'
  prefs: []
  type: TYPE_IMG
- en: The Web Server for Chrome application is sufficient to let us see what the standalone
    Storybook would look like
  prefs: []
  type: TYPE_NORMAL
- en: If you open the web server URL that is shown onscreen, you'll get exactly the
    same output as earlier – but now you could copy the `out_sb` directory elsewhere,
    and use it as a showcase tool, with independence from the developers.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can expand `Storybook` with *add-ons*, which allow you to enhance your
    showcase. Out of the many available ones, we will install three of them and have
    a quick look at their usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '`addon-actions` lets you see the data received by event handlers to see what
    would happen, for example, when the user clicks on a component'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`addon-notes` allows you to add notes to a component, to explain how it works
    or to give insights on its usage'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`addon-knobs` lets you dynamically tweak a component''s props to see how they
    change'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can read more about add-ons at [https://storybook.js.org/addons/introduction/](https://storybook.js.org/addons/introduction/)
    and take a look at the gallery of available add-ons at [https://storybook.js.org/addons/addon-gallery/](https://storybook.js.org/addons/addon-gallery/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Since add-ons are quite simple, let''s look at an example where all of the
    aforementioned ones are used. First, we''ll have to create an `addons.js` file
    in the `.storybook` directory, with a line for each add-on that we want to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s modify our stories so that `CountryFilterBar` will show what value
    it sends back with the onSelect event, and will also show some notes describing
    the component, so that `ExpandableCard` will let you tweak the props it receives:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'For the action, I provided an `action(...)` function, which will display its
    results in another tab, ACTION LOGGER, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/87d8f759-c6a5-4ddf-8f57-cbb7d292837f.png)'
  prefs: []
  type: TYPE_IMG
- en: Whenever you select a country, the executed callback and its parameters are
    shown in the ACTIONS tab.
  prefs: []
  type: TYPE_NORMAL
- en: I clicked on my country, Uruguay, and I can see that "UY" is being sent.
  prefs: []
  type: TYPE_NORMAL
- en: 'I also added a `withNotes(...)` call, providing the text from a markdown file
    I created. The content of this will be shown in the NOTES tab, as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4864a6f4-ebd6-45a8-a334-2032c28e1cf6.png)'
  prefs: []
  type: TYPE_IMG
- en: You can provide good documentation (not like mine!) for every component
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we can add a few "knobs" that lets the user change parameters dynamically.
    Let''s allow them to modify the card''s title and the numbers shown inside it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'When the user sees this story, the KNOBS panel lets them type in some values
    that are immediately updated on screen, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/43d12d96-4aa9-4cd5-8bae-6509eb01aec1.png)'
  prefs: []
  type: TYPE_IMG
- en: Adding knobs to a story lets users experiment with different settings. The values
    you enter in the Knobs panel are automatically reflected in the component.
  prefs: []
  type: TYPE_NORMAL
- en: We used only texts and numbers, but you can also provide knobs for Booleans,
    colors, dates, numbers within a given range, objects, string arrays, and options
    from a list.
  prefs: []
  type: TYPE_NORMAL
