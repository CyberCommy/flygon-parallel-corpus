- en: Chapter 2. The Task Time Tracker Database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter defines the **Task Time Tracker** (**3T**) database design and
    configures NetBeans as a client of MySQL server.
  prefs: []
  type: TYPE_NORMAL
- en: 'The 3T application will be used to keep track of the time spent on different
    tasks for different company projects. The main entities are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Company**: This is the entity that owns zero or more projects. A company
    is independent and can exist in its own right (it has no foreign keys).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Project**: This represents a grouping of tasks. Each project belongs to exactly
    one company and may contain zero or more tasks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tasks**: These represent activities that may be undertaken for a project.
    A task belongs to exactly one project.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Users**: They are participants who undertake tasks. Users can assign time
    spent to different tasks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Task log**: This is a record of the time spent by a user on a task. The time
    spent is stored in minutes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These entity definitions result in a very simple database design:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Task Time Tracker Database](img/5457_02_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We will prefix all of our 3T tables with `ttt_`. Large enterprise databases
    may contain hundreds of tables, and you will soon appreciate the prefixing of
    table names to group related tables.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting NetBeans with MySQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Click on the **Services** tab in the NetBeans IDE, and navigate to **Databases**
    | **Drivers**. You will see that NetBeans comes with several different database
    drivers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Connecting NetBeans with MySQL](img/5457_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Right-click on the **Databases** node, and click on **Register MySQL Server…**as
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Connecting NetBeans with MySQL](img/5457_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'For Windows users, this will open a dialog box with default settings. Enter
    the admin password used when installing MySQL server in the previous chapter,
    and check the **Remember Password** option:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Connecting NetBeans with MySQL](img/5457_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Mac users will see a different window prior to setting the connection properties.
    Select the MySQL driver before clicking on the **Next** button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Connecting NetBeans with MySQL](img/5457_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This will then allow you to specify the required database connection details:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Connecting NetBeans with MySQL](img/5457_02_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'When finished with these tasks, you will see **MySQL** **Server** listed in
    the **Databases** node. Right-click on the server, and select **Connect** to connect
    to the server (if not already connected):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Connecting NetBeans with MySQL](img/5457_02_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This will connect NetBeans to MySQL server and list the available databases.
    Right-click on the server, and select **Create Database** as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Connecting NetBeans with MySQL](img/5457_02_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Enter the database name as shown in the following screenshot, and click on
    **OK** to create the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Connecting NetBeans with MySQL](img/5457_02_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The final step is to connect to the newly created **task_time_tracker** database.
    Right-click on **task_time_tracker** and select **Connect…** as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Connecting NetBeans with MySQL](img/5457_02_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This will add a MySQL database connection entry for the **task_time_tracker**
    database, which can be opened by right-clicking on it whenever required:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Connecting NetBeans with MySQL](img/5457_02_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now you can right-click on the database connection and select the **Execute
    Command…** option to open the **SQL Command** editor in the workspace:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Connecting NetBeans with MySQL](img/5457_02_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The **SQL Command** editor is where you will type and execute commands against
    the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Connecting NetBeans with MySQL](img/5457_02_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The 3T database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following SQL statements define the MySQL tables used in 3T. It is possible
    to use any database, and MySQL-specific code is highlighted to identify differences
    with ANSI SQL.
  prefs: []
  type: TYPE_NORMAL
- en: The company table
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A company has projects for which we need to keep track of the time spent on
    different tasks. The company is, hence, the first table that needs to be defined.
    It is a very simple structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `auto_increment` keyword is used by MySQL to identify a number column that
    should automatically be incremental (the default rate of increment is by one number)
    based on the current highest value in the column. This is used to generate the
    `id_company` primary key values. Let''s add some company data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'After entering these statements into the **SQL Command** editor, you can execute
    the statements by clicking on the button in the top-right corner of the following
    screenshot (the Run SQL button is circled):'
  prefs: []
  type: TYPE_NORMAL
- en: '![The company table](img/5457_02_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The output of these statements will be shown at the bottom of the IDE:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The company table](img/5457_02_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can now view the inserted data by executing the following statement in
    the **SQL Command** editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can also right-click on the table node in the databases
    and select **View Data…**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The company table](img/5457_02_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This will result in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The company table](img/5457_02_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The projects table
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A company may have any number of projects with each project belonging to exactly
    one company. The table definition is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Once again, we can add some data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In these `insert` statements, we have provided the foreign key to the company
    table and once again allowed MySQL to generate the primary keys. Executing these
    commands and browsing the `ttt_project` table data should be displayed as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The projects table](img/5457_02_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The tasks table
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A project may have any number of tasks with each task belonging to exactly
    one project. The table and test data can now be added as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We will now add a range of tasks for some of our projects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Executing these commands and browsing the `ttt_task` table data will display
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The tasks table](img/5457_02_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The user table
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The next table in our design holds user information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the `admin_role` column will be used to identify if a user has administrative
    permissions in the 3T application. We will now add two users:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this set of commands will create the user table and then insert our
    two test users as displayed in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The user table](img/5457_02_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The task log table
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The final table will be used to enter the time spent on different tasks.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We will now add some data to this table for our user John Smith (`jsmith`).
    Note that the time spent on each task is in minutes and that the MySQL function
    `now()` is used to return the current timestamp:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In a similar way, we will insert some test data for Betty Jones (`bjones`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of these `insert` statements can now be viewed as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The task log table](img/5457_02_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Enterprise options for the 3T database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The table and column definitions provided previously are the simplest required
    for our 3T project. There are, however, several potential options that could be
    added to enhance the structure for enterprise use.
  prefs: []
  type: TYPE_NORMAL
- en: Password encryption
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Enterprise applications would require that the password field be encrypted for
    security purposes using a unidirectional algorithm. Passwords should never be
    stored in plain text, and it should never be possible to view the password in
    the database (as we can currently do). It is beyond the scope of this book to
    cover password security strategies, but a very good explanation of the core principles
    can be found at [http://www.jasypt.org/howtoencryptuserpasswords.html](http://www.jasypt.org/howtoencryptuserpasswords.html).
  prefs: []
  type: TYPE_NORMAL
- en: MySQL provides a number of password encryption functions that could be used
    for this purpose. We suggest you browse the documentation at [https://dev.mysql.com/doc/refman/5.7/en/encryption-functions.html](https://dev.mysql.com/doc/refman/5.7/en/encryption-functions.html)
    to understand the different options available.
  prefs: []
  type: TYPE_NORMAL
- en: LDAP integration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many enterprises use **LDAP** (**Lightweight Directory Access Protocol**) for
    maintaining users within their organization. LDAP is most commonly used to provide
    single sign-on, where one password for a user is shared between many services.
    The password column in the user table would, hence, not be required for such scenarios.
    If an organization spans many geographical locations, there may be several LDAP
    realms spread across different continents. Such a scenario may require a new table
    to store LDAP authorization servers. Each user may then be assigned an authorization
    LDAP server to process their logon.
  prefs: []
  type: TYPE_NORMAL
- en: Audit trails
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Enterprise systems often require extensive audit trails (when and why an action
    took place and who committed it). This is especially the case for large organizations
    that are publicly held. The **Sarbanes-Oxley Act** (**SOX**), for example, requires
    that all publicly held companies based in the United States must establish internal
    controls and procedures to reduce the possibility of corporate fraud. Such processes
    include identifying authorized and unauthorized changes or potentially suspicious
    activity over any period of time.
  prefs: []
  type: TYPE_NORMAL
- en: 'The questions "Who, When, and Why" are the basis of audit trails that need
    to be considered when designing an enterprise database. Simply adding a few additional
    columns to all tables is a very good start:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that this syntax is for MySQL, but similar functionality will be available
    for most databases. The `who_created` and `who_updated` columns will need to be
    updated programmatically. The developer will need to ensure that these fields
    are set correctly during processing of the relevant action. The `when_created`
    and `when_updated` columns do not need to be considered by the developer. They
    are automatically maintained by MySQL. The `when_created` field will be automatically
    set to the `current_timestamp` MySQL function that represents the query start
    time to establish the exact moment in time that the record is inserted into the
    database. The `when_updated` field will auto update each time the record itself
    is updated. Adding these four additional columns will ensure that a basic level
    of audit tracking is available. We now have the ability to view who created the
    record and when in addition to who performed the last update and when. The `ttt_company`
    table, for example, could be redesigned as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Logon activity audits
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This provides the ability to track basic user activity including who logged
    on, when they logged on, and from where they logged on. It is another crucial
    piece of the enterprise audit trail and should also include tracking of invalid
    logon attempts. This information will need to be maintained programmatically and
    requires a table with a structure similar to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `status` field could be used to identify the logon attempt (for example,
    **S** could represent successful and **F** could represent failed while **M**
    could represent a successful mobile device logon). The information required would
    need to be defined in the context of the compliance requirements of the enterprise.
  prefs: []
  type: TYPE_NORMAL
- en: Custom audit tables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is often the need to audit every action and data change for a particular
    table. In situations such as this, the "when" and "who" updated fields are not
    enough. This situation requires an audit (or snapshot) table that contains all
    fields in the original table. Each time a record is updated, the current snapshot
    is written to the audit table so that each change is available for auditing purposes.
    Such tables may also be called archive tables as the evolution of data is archived
    on every change. Custom audit tables such as these are usually not maintained
    programmatically and are managed by the RDBMS, either by triggers or by built-in
    logging/archiving functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter has defined a database structure that will be used to build the
    3T application. We have connected to the MySQL server and executed a series of
    SQL statements to create and populate a set of tables. Each table uses `autoincrement`
    columns to allow MySQL to automatically manage and generate primary keys. Although
    the table structures are not complex, we have also identified possible enhancements
    that could be appropriate for enterprise use.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](ch03.html "Chapter 3. Reverse Engineering the Domain Layer with
    JPA"), *Reverse Engineering the Domain Layer with JPA*, we will start our Java
    journey by reverse engineering our database to create a set of **Java Persistence
    API** (**JPA**) entities. Our JPA domain layer will become the data heart of our
    3T application.
  prefs: []
  type: TYPE_NORMAL
