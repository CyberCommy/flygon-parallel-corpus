- en: Math Problems
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problems
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here are the problem-solving sections for this chapter.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Sum of naturals divisible by 3 and 5
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Write a program that calculates and prints the sum of all the natural numbers
    divisible by either 3 or 5, up to a given limit entered by the user.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Greatest common divisor
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Write a program that, given two positive integers, will calculate and print
    the greatest common divisor of the two.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Least common multiple
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Write a program that will, given two or more positive integers, calculate and
    print the least common multiple of them all.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: 4\. Largest prime smaller than given number
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Write a program that computes and prints the largest prime number that is smaller
    than a number provided by the user, which must be a positive integer.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: 5\. Sexy prime pairs
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Write a program that prints all the sexy prime pairs up to a limit entered by
    the user.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: 6\. Abundant numbers
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Write a program that prints all abundant numbers and their abundance, up to
    a number entered by the user.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: 7\. Amicable numbers
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Write a program that prints the list of all pairs of amicable numbers smaller
    than 1,000,000.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: 8\. Armstrong numbers
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Write a program that prints all Armstrong numbers with three digits.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: 9\. Prime factors of a number
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Write a program that prints the prime factors of a number entered by the user.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: 10\. Gray code
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Write a program that displays the normal binary representations, Gray code representations,
    and decoded Gray code values for all 5-bit numbers.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: 11\. Converting numerical values to Roman
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Write a program that, given a number entered by the user, prints its Roman numeral
    equivalent.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: 12\. Largest Collatz sequence
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Write a program that determines and prints which number up to 1 million produces
    the longest Collatz sequence and what its length is.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: 13\. Computing the value of Pi
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Write a program that computes the value of Pi with a precision of two decimal
    digits.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: 14\. Validating ISBNs
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Write a program that validates that 10-digit values entered by the user, as
    a string, represent valid ISBN-10 numbers.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: Solutions
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here are the solutions for the above problem-solving sections.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Sum of naturals divisible by 3 and 5
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The solution to this problem is to iterate through all numbers from 3 (1 and
    2 are not divisible by 3 so it does not make sense to test them) up to the limit
    entered by the user. Use the modulo operation to check that the rest of the division
    of a number by 3 and 5 is 0\. However, the trick to being able to sum up to a
    larger limit is to use `long long` and not `int` or `long` for the sum, which
    would result in an overflow before summing up to 100,000:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 2\. Greatest common divisor
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The greatest common divisor (*gcd* in short) of two or more non-zero integers,
    also known as the greatest common factor (*gcf*), highest common factor (*hcf*),
    greatest common measure (*gcm*), or highest common divisor, is the greatest positive
    integer that divides all of them. There are several ways the gcd could be computed;
    an efficient method is Euclid''s algorithm. For two integers, the algorithm is:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This can be very simply implemented in C++ using a recursive function:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'A non-recursive implementation of Euclid''s algorithm should look like this:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In C++17 there is a `constexpr` function called `gcd()` in the header `<numeric>` that
    computes the greatest common divisor of two numbers.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Least common multiple
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The **least common multiple** (**lcm**) of two or more non-zero integers, also
    known as the lowest common multiple, or smallest common multiple, is the smallest
    positive integer that is divisible by all of them. A possible way to compute the
    least common multiple is by reducing the problem to computing the greatest common
    divisor. The following formula is used in this case:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'A function to compute the least common multiple may look like this:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To compute the *lcm* for more than two integers, you could use the `std::accumulate` algorithm
    from the header `<numeric>`:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In C++17 there is a `constexpr` function called `lcm()` in the header `<numeric>` that
    computes the least common multiple of two numbers.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: 4\. Largest prime smaller than given number
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A prime number is a number that has only two divisors, 1 and the number itself.
    To find the largest prime smaller than a given number you should first write a
    function that determines if a number is prime and then call this function, starting
    from the given number, towards 1 until the first prime is encountered. There are
    various algorithms for determining if a number is prime. Common implementations
    for determining the primality appear as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This function can be used as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 5\. Sexy prime pairs
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sexy prime numbers are prime numbers that differ from each other by six (for
    example 5 and 11, or 13 and 19). There are also *twin primes*, which differ by
    two, and *cousin primes*, which differ by four.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous challenge, we implemented a function that determines whether
    an integer is a prime number. We will reuse that function for this exercise. What
    you have to do is check that if a number `n` is prime, the number `n+6` is also
    prime, and in this case print the pair to the console:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You could take it as a further exercise to compute and displays the sexy prime
    triples, quadruplets, and quintuplets.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: 6\. Abundant numbers
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An abundant number, also known as an excessive number, is a number for which
    the sum of its proper divisors is greater than the number itself. The proper divisors
    of a number are the positive prime factors of the number, other than the number
    itself. The amount by which the sum of proper divisors exceeds the number itself
    is called abundance. For instance, the number 12 has the proper divisors 1, 2,
    3, 4, and 6\. Their sum is 16, which makes 12 an abundant number. Its abundance
    is 4 (that is, 16 - 12).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: 'To determine the sum of proper divisors, we try all numbers from 2 to the square
    root of the number (all prime factors are less than or equal to this value). If
    the current number, let’s call it `i`, divides the number, then `i` and `num/i` are
    both divisors. However, if they are equal (for example, if `i = 3`, and `n = 9`,
    then `i` divides 9, but `n/i = 3`), we add only `i` because proper divisors must
    only be added once. Otherwise, we add both `i` and `num/i` and continue:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Printing abundant numbers is as simple as iterating up to the specified limit,
    computing the sum of proper divisors and comparing it to the number:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 7\. Amicable numbers
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Two numbers are said to be amicable if the sum of the proper divisors of one
    number is equal to that of the other number. The proper divisors of a number are
    the positive prime factors of the number other than the number itself. Amicable
    numbers should not be confused with *friendly numbers*. For instance, the number
    220 has the proper divisors 1, 2, 4, 5, 10, 11, 20, 22, 44, 55, and 110, whose
    sum is 284\. The proper divisors of 284 are 1, 2, 4, 71, and 142; their sum is
    220\. Therefore, the numbers 220 and 284 are said to be amicable.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution to this problem is to iterate through all the numbers up to the
    given limit. For each number, compute the sum of its proper divisors. Let’s call
    this `sum1`. Repeat the process and compute the sum of the proper divisors of `sum1`.
    If the result is equal to the original number, then the number and `sum1` are
    amicable numbers:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the above sample, `sum_proper_divisors()` is the function seen in the solution
    to the abundant numbers problem.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: The above function prints pairs of numbers twice, such as 220,284 and 284,220\.
    Modify this implementation to only print each pair a single time.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: 8\. Armstrong numbers
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An Armstrong number (named so after Michael F. Armstrong), also called a narcissistic
    number, a pluperfect digital invariant, or a plus perfect number, is a number
    that is equal to the sum of its own digits when they are raised to the power of
    the number of digits. As an example, the smallest Armstrong number is 153, which
    is equal to ![](img/8a736b24-c3af-4da2-a9da-12789af4ee9e.png).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: 'To determine if a number with three digits is a narcissistic number, you must
    first determine its digits in order to sum their powers. However, this involves
    division and modulo operations, which are expensive. A much faster way to compute
    it is to rely on the fact that a number is a sum of digits multiplied by 10 at
    the power of their zero-based position. In other words, for numbers up to 1,000,
    we have `a*10^2 + b*10^2 + c`. Since you are only supposed to determine numbers
    with three digits, that means `a` would start from 1\. This would be faster than
    other approaches because multiplications are faster to compute than divisions
    and modulo operations. An implementation of such a function would look like this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You could take it as a further exercise to write a function that determines
    the narcissistic numbers up to a limit, regardless their number of digits. Such
    a function would be slower because you first have to determine the sequence of
    digits of the number, store them in a container, and then sum together the digits
    raised to the appropriate power (the number of the digits).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: 9\. Prime factors of a number
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The prime factors of a positive integer are the prime numbers that divide that
    integer exactly. For instance, the prime factors of 8 are 2 x 2 x 2, and the prime
    factors of 42 are 2 x 3 x 7\. To determine the prime factors you should use the
    following algorithm:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: While `n` is divisible by 2, 2 is a prime factor and must be added to the list,
    while `n` becomes the result of `n/2`. After completing this step, `n` is an odd
    number.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Iterate from 3 to the square root of `n`. While the current number, let’s call
    it `i`, divides `n`, `i` is a prime factor and must be added to the list, while `n` becomes
    the result of `n/i`. When `i` no longer divides `n`, increment `i` by 2 (to get
    the next odd number).
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When `n` is a prime number greater than 2, the steps above will not result in `n` becoming
    1\. Therefore, if at the end of step 2 `n` is still greater than 2, then `n` is
    a prime factor.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As a further exercise, determine the largest prime factor for the number 600,851,475,143.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: 10. Gray code
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Gray code, also known as reflected binary code or simply reflected binary,
    is a form of binary encoding where two consecutive numbers differ by only one
    bit. To perform a binary reflected Gray code encoding, we need to use the following
    formula:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This is equivalent to the following:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'For decoding a binary reflected Gray code, the following formula should be
    used:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'These can be written in C++ as follows, for 32-bit unsigned integers:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'To print the all 5-bit integers, their binary representation, the encoded Gray
    code representation, and the decoded value, we could use the following code:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 11\. Converting numerical values to Roman
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Roman numerals, as they are known today, use seven symbols: I = 1, V = 5, X
    = 10, L = 50, C = 100, D = 500, and M = 1000\. The system uses additions and subtractions
    in composing the numerical symbols. The symbols from 1 to 10 are I, II, III, IV,
    V, VI, VII, VIII, IX, and X. Romans did not have a symbol for zero and used to
    write *nulla* to represent it. In this system, the largest symbols are on the
    left, and the least significant are on the right. As an example, the Roman numeral
    for 1994 is MCMXCIV. If you are not familiar with the rules for Roman numerals,
    you should read more on the web.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: 'To determine the Roman numeral of a number, use the following algorithm:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: Check every Roman base symbol from the highest (M) to the lowest (I)
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the current value is greater than the value of the symbol, then concatenate
    the symbol to the Roman numeral and subtract its value from the current one
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat until the current value reaches zero
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For example, consider 42: the first Roman base symbol smaller than 42 is XL,
    which is 40\. We concatenate it to the numeral, resulting in XL, and subtract
    from the current number, resulting in 2\. The first Roman base symbol smaller
    than 2 is I, which is 1\. We add that to the numeral, resulting in XLI, and subtract
    1 from the number, resulting in 1\. We add one more I to the numeral, which becomes
    XLII, and subtract again 1 from the number, reaching 0 and therefore stopping:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This function can be used as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 12\. Largest Collatz sequence
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Collatz conjecture, also known as the Ulam conjecture, Kakutani''s problem,
    the Thwaites conjecture, Hasse''s algorithm, or the Syracuse problem, is an unproven
    conjecture that states that a sequence defined as explained in the following always
    reaches 1\. The series is defined as follows: start with any positive integer `n` and
    obtain each new term from the previous one: if the previous term is even, the
    next term is half the previous term, or else it is 3 times the previous term plus
    1.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem you are to solve is to generate the Collatz sequence for all positive
    integers up to one million, determine which of them is the longest, and print
    its length and the starting number that produced it. Although we could apply brute
    force to generate the sequence for each number and count the number of terms until
    reaching 1, a faster solution would be to save the length of all the sequences
    that have already been generated. When the current term of a sequence that started
    from a value `n` becomes smaller than `n`, then it is a number whose sequence
    has already been determined, so we could simply fetch its cached length and add
    it to the current length to determine the length of the sequence started from `n`.
    This approach, however, introduces a limit to the Collatz sequences that could
    be computed, because at some point the cache will exceed the amount of memory
    the system can allocate:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 13\. Computing the value of Pi
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A suitable solution for approximately determining the value of Pi is using a
    Monte Carlo simulation. This is a method that uses random samples of inputs to
    explore the behavior of complex processes or systems. The method is used in a
    large variety of applications and domains, including physics, engineering, computing,
    finance, business, and others.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this we will rely on the following idea: the area of a circle with diameter `d` is `PI
    * d^2 / 4`. The area of a square that has the length of its sides equal to `d` is `d^2`.
    If we divide the two we get `PI/4`. If we put the circle inside the square and
    generate random numbers uniformly distributed within the square, then the count
    of numbers in the circle should be directly proportional to the circle area, and
    the count of numbers inside the square should be directly proportional to the
    square’s area. That means that dividing the total number of hits in the square
    and circle should give `PI/4`. The more points generated, the more accurate the
    result shall be.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: 'For generating pseudo-random numbers we will use a Mersenne twister and a uniform
    statistical distribution:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 14\. Validating ISBNs
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **International Standard Book Number** (**ISBN**) is a unique numeric identifier
    for books. Currently, a 13-digit format is used. However, for this problem, you
    are to validate the former format that used 10 digits. The last of the 10 digits
    is a checksum. This digit is chosen so that the sum of all the ten digits, each
    multiplied by its (integer) weight, descending from 10 to 1, is a multiple of
    11.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: 'The `validate_isbn_10` function, shown as follows, takes an ISBN as a string,
    and returns `true` if the length of the string is 10, all ten elements are digits,
    and the sum of all digits multiplied by their weight (or position) is a multiple
    of 11:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: You can take it as a further exercise to improve this function to also correctly
    validate ISBN-10 numbers that include hyphens, such as `3-16-148410-0`. Also,
    you can write a function that validates ISBN-13 numbers.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以把这看作是进一步练习，以改进这个函数，使其能够正确验证包括连字符的ISBN-10号码，比如`3-16-148410-0`。另外，你也可以编写一个验证ISBN-13号码的函数。
