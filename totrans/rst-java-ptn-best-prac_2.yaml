- en: Chapter 2. Resource Design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Chapter 1](ch01.html "Chapter 1. REST – Where It Begins"), *REST – Where It
    Begins*, covered the basics of REST as well as best practices while designing
    RESTful resources. This chapter continues the discussion with an understanding
    of request response patterns, how to deal with different representations of resources,
    what are the different strategies when versioning API, and how standard HTTP codes
    can be used with REST responses. Subsections of this chapter will cover the following
    topics:'
  prefs: []
  type: TYPE_NORMAL
- en: REST response patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Content negotiation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Entity providers and different representations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API versioning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Response codes and REST patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will also cover custom entity providers for serializing and de-serializing
    request and response entities as well as other approaches such as streaming and
    chunking.
  prefs: []
  type: TYPE_NORMAL
- en: REST response patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the earlier chapter, we saw how we can work with domain-related data to create
    readable URIs, use HTTP methods for different CRUD functionality, and transfer
    data to and fro from the clients and server using standardized MIME types and
    HTTP response codes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a diagram that shows standard REST request/response patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: '![REST response patterns](img/7963OS_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As seen from the preceding diagram, the client makes a REST request, which consists
    of standard HTTP methods, MIME types, and the URI to target. The server processes
    the request and sends back a response, which comprises standard HTTP response
    codes and MIME types. We covered the HTTP methods and how to use JAX-RS annotations
    earlier. Also, we enumerated the best practices for designing Resource URIs. In
    this chapter, we will cover the commonly used HTTP response codes as well as how
    to handle the different MIME types.
  prefs: []
  type: TYPE_NORMAL
- en: Content negotiation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Content negotiation means allowing different representations of a resource in
    the same URI so that clients can make a choice on what suits them best.
  prefs: []
  type: TYPE_NORMAL
- en: '|   | *"HTTP has provisions for several mechanisms for "content negotiation"
    - the process of selecting the best representation for a given response when there
    are multiple representations available."* |   |'
  prefs: []
  type: TYPE_TB
- en: '|   | --*RFC 2616, Fielding et al.* |'
  prefs: []
  type: TYPE_TB
- en: 'There are different patterns for content negotiation. These are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Using HTTP headers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using URL patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Content negotiation using HTTP headers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the client sends requests to create or update a resource, there is some
    form of payload that should be transferred from the client to the endpoint. Also,
    when a response is generated, a payload can be sent back to the client. These
    payloads are handled by HTTP request and response entities, which are sent as
    part of the HTTP messages body.
  prefs: []
  type: TYPE_NORMAL
- en: Entities are sent via a request, usually for HTTP `POST` and `PUT` methods,
    or they are returned in a response for the HTTP methods. The Content-Type HTTP
    header is used to indicate the MIME type of the entity being sent by the server.
    Common examples of content types are `"text/plain"`, `"application/xml"`, `"text/html"`,
    `"application/json"`, `"image/gif"`, and `"image/jpeg"`.
  prefs: []
  type: TYPE_NORMAL
- en: A client can make a request to the server and specify what media types it can
    handle and what is its order of preference as part of the `"Accept"` HTTP header.
    The client can also specify in what language it wants the response as part of
    the `"Accept-Language"` header to be. If no `Accept` header is present in the
    request, the server can send the representation it chooses.
  prefs: []
  type: TYPE_NORMAL
- en: 'The JAX-RS specification provides standard annotations to support content negotiation.
    These are `javax.ws.rs.Produces` and `javax.ws.rs.Consumes` annotations. The following
    snippet shows an example of the `@Produces` annotation in a resource method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `getCoffeeList()` method returns a list of coffees and is annotated with
    `@Produces(MediaType.APPLICATION_JSON)`. The `@Produces` annotation is used to
    specify which MIME types the resource can send back to the client and match it
    up to the client's `Accept` header.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method will produce a response as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In a resource, if no methods are able to produce the MIME type requested by
    a client request, the JAX-RS runtime sends back an HTTP `406 Not Acceptable` error.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following snippet shows a resource method annotated with the `@Consumes`
    annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `@Consumes` annotation specifies which media types the resource can consume.
    When a client makes a request, JAX-RS finds all the methods that will match the
    path, and it will then invoke the method based on the content type sent by the
    client.
  prefs: []
  type: TYPE_NORMAL
- en: If a resource is unable to consume the MIME type of a client request, the JAX-RS
    runtime sends back an HTTP `415 ("Unsupported Media Type")` error.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple MIME types can be specified in the `@Produces` or `@Consumes` annotation
    as `@Produces(MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML)`.
  prefs: []
  type: TYPE_NORMAL
- en: Along with the support for static content negotiation, JAX-RS also contains
    runtime content negotiation support using the `javax.ws.rs.core.Variant` class
    and the `javax.ws.rs.core.Request` objects. A `Variant` object in a JAX-RS specification
    is a combination of media types, content-language, and content encoding as well
    as ETags, last-modified headers, and other preconditions. The `Variant` object
    defines the resource representation that is supported by the server. The `Variant.VariantListBuilder`
    class is used to build a list of representation variants.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet shows how to create a list of resource representation
    variants:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The code snippet calls the build method of the `VariantListBuilder` class.
    The `Request.selectVariant` method takes a list of `Variant` objects and chooses
    the one based on the client''s `Accept` header, as shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Content negotiation based on URL patterns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another approach for content negotiation adopted by some APIs is to send the
    resource representation based on the extension of a resource in the URL. For example,
    a client can ask for details using `http://foo.api.com/v2/library/books.xml` or
    `http://foo.api.com/v2/library/books.json`. The server has different methods,
    which can handle the two URIs. However, both of these are representations of the
    same resource.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in the preceding snippet, there are two methods defined: `getBookInXML()`
    and `getBookInJSON()`, and the response is returned based on the path of the URL.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is a good practice to use the HTTP content negotiation `Accept` header. Using
    headers for content negotiation provides a clear separation of IT concerns from
    business. The other advantage with using the `Accept` header for content negotiation
    is that there is only one resource method for all the different representations.
  prefs: []
  type: TYPE_NORMAL
- en: The following section covers how to serialize and de-serialize a resource to
    and from the different representations respectively using entity providers in
    JAX-RS.
  prefs: []
  type: TYPE_NORMAL
- en: Entity providers and different representations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous examples, we passed literal parameters picked from a URI path
    fragment as well as from the request''s query parameters to the resource method.
    However, there are cases when we want to pass a payload in the request body, for
    example a `POST` request. JAX-RS provides two interfaces that can be used: one
    for handling the inbound entity representation-to-Java de-serialization known
    as `javax.ws.rs.ext.MessageBodyReader`, and the other one for handling the outbound
    entity Java-to-representation serialization known as `javax.ws.rs.ext.MessageBodyWriter`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`MessageBodyReader` de-serializes entities from the message body representation
    into Java classes. `MessageBodyWriter` serializes a Java class to a specific representation
    format.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table shows the methods that need to be implemented:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Method of MessageBodyReader | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `isReadable()` | This is used to check if the `MessageBodyReader` class can
    support conversion from a stream to Java type |'
  prefs: []
  type: TYPE_TB
- en: '| `readFrom()` | This is used to read a type from the `InputStream` class |'
  prefs: []
  type: TYPE_TB
- en: As shown in the table, the `isReadable()` method of the `MessageBodyReader`
    implementation class is called to check if `MessageBodyReader` can handle the
    specified input. When the `readFrom()` method of the `MessageBodyReader` class
    is called, it can convert an input stream to a Java POJO.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table shows the methods of `MessageBodyWriter` that must be implemented
    along with a short description of each of its methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Method of MessageBodyWriter | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `isWritable()` | This is used to check if the `MessageBodyWriter` class can
    support the conversion from the specified Java type |'
  prefs: []
  type: TYPE_TB
- en: '| `getSize()` | This is used to check the length of bytes if the size is known
    or -1 |'
  prefs: []
  type: TYPE_TB
- en: '| `writeTo()` | This is used to write from a type to the stream |'
  prefs: []
  type: TYPE_TB
- en: The `isWritable()` method of the `MessageBodyWriter` implementation class is
    called to check if the `MessageBodyWriter` class can handle the specified input.
    When the `writeTo()` method of `MessageBodyWriter` is called, it can convert a
    Java POJO to the output stream. The samples in the download bundle of this book
    show how to use `MessageBodyReader` and `MessageBodyWriter`.
  prefs: []
  type: TYPE_NORMAL
- en: However, there are lightweight implementations such as the `StreamingOutput`
    and `ChunkingOutput` classes, and the following sections will cover how Jersey
    implementation of JAX-RS already has support for basic formats such as text, JSON,
    and XML.
  prefs: []
  type: TYPE_NORMAL
- en: StreamingOutput
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `javax.ws.rs.core.StreamingOutput` class is a callback that can be implemented
    to send the entity in the response when the application wants to stream the output.
    The `StreamingOutput` class is a lightweight alternative to the `javax.ws.rs.ext.MessageBodyWriter`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a sample code that shows how to use `StreamingOutput` as part
    of the response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the preceding snippet, the `write()` method of the `StreamingOutput`
    class has been overridden to write to the output stream. `StreamingOutput` is
    useful in case of streaming binary data in a streaming fashion. For more details,
    have a look at the samples code that are available as part of the download bundle.
  prefs: []
  type: TYPE_NORMAL
- en: ChunkedOutput
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With Jersey implementation of JAX-RS, the server can use the `org.glassfish.jersey.server.ChunkedOutput`
    class to immediately send a response to a client in chunks as soon as they become
    available, without waiting for the other chunks to become available too. The `size`
    object's value of -1 is sent in the `Content-Length` header of the response to
    indicate that the response will be chunked. On the client side, it will know that
    the response will be chunked, so it reads each chunk of the response separately
    and processes it and waits for more chunks to come on the same connection. The
    server keeps on sending response chunks until it closes the connection after sending
    the last chunk and the response processing is finished.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example code to show the use of `ChunkedOutput`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the snippet, the `chunkExample` method returns a `ChunkedOutput`
    object.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the client side, `org.glassfish.jersey.client.ChunkedInput` can be used
    to receive messages in `"typed"` chunks. This data type is useful for consuming
    partial responses from large or continuous data input streams. The following snippet
    shows how the client can read from a `ChunkedInput` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Differences between ChunkedOutput and StreamingOutput**'
  prefs: []
  type: TYPE_NORMAL
- en: '`ChunkedOutput` is an internal class provided by Jersey. It lets the server
    send *chunks* of data without closing the client connection. It uses a series
    of convenient calls to the `ChunkedOutput.write` methods that take POJO and media
    type input and then use the JAX-RS `MessageBodyWriter` class to convert the POJO
    to bytes. `ChunkedOutput` writes are non-blocking.'
  prefs: []
  type: TYPE_NORMAL
- en: '`StreamingOutput` is a low-level JAX-RS API that works with bytes directly.
    The server has to implement `StreamingOutput`, and its `write(OutputStream)` method
    will be invoked only once by JAX-RS runtime, and the call is blocking.'
  prefs: []
  type: TYPE_NORMAL
- en: Jersey and JSON support
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Jersey provides support for the following approaches when working with a JSON
    representation.
  prefs: []
  type: TYPE_NORMAL
- en: POJO-based JSON binding support
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'POJO-based JSON binding support is very generic and allows mapping from any
    Java object to JSON. This is done via a Jackson `org.codehaus.jackson.map.ObjectMapper`
    instance. For example, to read a JSON in a `Coffee` object, we use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: For more details, check [https://jersey.java.net/documentation/1.18/json.html](https://jersey.java.net/documentation/1.18/json.html).
  prefs: []
  type: TYPE_NORMAL
- en: JAXB-based JSON binding support
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'JAXB-based JSON binding support is useful if the resource can produce and consume
    XML or JSON. To implement this, you can annotate a simple POJO with `@XMLRootElement`,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the preceding JAXB bean to produce the JSON data format from the resource
    method is then as simple as using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `Produces` annotation will take care of converting into a JSON representation
    of the `Coffee` resource.
  prefs: []
  type: TYPE_NORMAL
- en: Low-level JSON parsing and processing support
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is best used to get fine-grained control over the JSON format using `JSONArray`
    and `JSONObject` to create the JSON representation. The advantage here is that
    the application developer will gain full control over the JSON format produced
    and consumed. The following is an example code to use `JSONArray`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, dealing with the data model objects will probably be a bit
    more complex. For example, the following code shows how the pull parsing programming
    model works with JSONParser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The next section covers the topic of how to version the API so that it can evolve
    over a period of time as well as how to ensure the basic functionality of a client
    application does not break with API versioning changes on the server side.
  prefs: []
  type: TYPE_NORMAL
- en: API versioning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the evolution of the application, the URI design should have some constraints
    to identify the version. It is hard to foresee all the resources, which will change
    during the life of the application. The goal with API versioning is to define
    the resource endpoints and the addressing schemes and associate a version with
    them. The API developers must ensure the HTTP verbs' semantics and status codes
    should continue to work without human intervention as the version changes. Over
    the life span of the application, the version will evolve, and the APIs may need
    to be deprecated. Requests to older versions of the API can be redirected to the
    latest code path or there can be appropriate error codes that indicate the API
    is obsolete.
  prefs: []
  type: TYPE_NORMAL
- en: 'There can be different approaches to version APIs. These are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Specify the version in the URI itself
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specify the version in the request query parameter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specify the version in the `Accept` header
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of these could work fine. The next section covers the approaches in detail
    and highlights the advantages and disadvantages of each.
  prefs: []
  type: TYPE_NORMAL
- en: Version in the URI approach
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this approach, the version is part of the URI for the resource exposed by
    the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in the following URL, there is a "v2" version exposed as part
    of the path to the resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '`http://api.foo.com/v2/coffees/1234`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, API developers can provide a path, which defaults to the latest
    version of the API. Thus, the following request URIs should behave identically:'
  prefs: []
  type: TYPE_NORMAL
- en: '`http://api.foo.com/coffees/1234`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`http://api.foo.com/v2/coffees/1234`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This indicates v2 is the latest API version. If the clients point to the older
    versions, they should be informed to use the newer versions by using the following
    HTTP code for redirection:'
  prefs: []
  type: TYPE_NORMAL
- en: '`301 Moved permanently`: This indicates that the resource with a requested
    URI is moved permanently to another URI. This status code can be used to indicate
    an old or unsupported API version, informing the API client that a versioned resource
    URI has been replaced by a resource permalink.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`302 Found`: This indicates that the requested resource is temporarily located
    at another location, while the requested URI might still be supported.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Version as part of the request query parameter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The other way to use API versioning could be to send the version in the request
    parameter. The resource method can choose the flow of code based on the version,
    which is sent with the request. For example, in the `http://api.foo.com/coffees/1234?version=v2`
    URL, v2 has been specified as part of the query parameter `?version=v2`.
  prefs: []
  type: TYPE_NORMAL
- en: The disadvantage with this format is that the responses may not be cached. Additionally,
    the source code for the resource implementation will have different flows based
    on the version in the query parameter, which is not very intuitive or maintainable.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: More details on the best practices of caching will be covered in [Chapter 4](ch04.html
    "Chapter 4. Designing for Performance"), *Designing for Performance*.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast, if the URI contains the version, it is cleaner and more readable.
    Also, there could be a standardized lifespan for a version of URI, after which
    all the requests to older versions get redirected to the latest version.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Facebook, Twitter, and Stripe API all use versions as part of the URI. The Facebook
    API makes a version unusable two years after the date on which the subsequent
    version is released. If a client makes an unversioned call, the server will default
    to the oldest available version of the Facebook API.
  prefs: []
  type: TYPE_NORMAL
- en: The Twitter API provides six months to completely transition from v1.0 to v1.1.
  prefs: []
  type: TYPE_NORMAL
- en: More details on these APIs will be found in the [Appendix](apa.html "Appendix A. Appendix").
  prefs: []
  type: TYPE_NORMAL
- en: Specifying the version in the Accept header
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Some APIs prefer to put version as part of the `Accept` header. For example,
    take a look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, `vnd` stands for vendor-specific MIME type. This removes
    the version for the URL and is preferred by some API developers.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The GitHub API recommends you send an `Accept` header explicitly, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: For more details, check [https://developer.github.com/v3/media/](https://developer.github.com/v3/media/).
  prefs: []
  type: TYPE_NORMAL
- en: The next section covers what the standard HTTP response codes that should be
    sent to the client are.
  prefs: []
  type: TYPE_NORMAL
- en: Response codes and REST patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'HTTP provides standardized response codes that can be returned for every request.
    The following table summarizes the REST response patterns based on CRUD API. There
    are subtle differences based on the operation used as well as whether the content
    is sent or not as part of the response:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Group | Response code | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Success 2XX | `200 OK` | This can be used for the `create`, `update`, or
    `delete` operations with `PUT`, `POST`, or `DELETE`. This returns content as part
    of the response. |'
  prefs: []
  type: TYPE_TB
- en: '|   | `201 Created` | This can be used when creating a resource with `PUT`.
    This must contain the `Location` header of the resource. |'
  prefs: []
  type: TYPE_TB
- en: '|   | `204 No Content` | This can be used for the `DELETE`, `POST`, or `PUT`
    operation. No content is returned as part of the response. |'
  prefs: []
  type: TYPE_TB
- en: '|   | `202 Accepted` | This sends a response later as processing has not been
    completed as yet. This is used for asynchronous operations. This should also return
    a `Location` header, which can specify where the client can monitor for the request.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Redirectional 3XX | `301 Permanent` | This can be used to show that all requests
    are directed to a new location. |'
  prefs: []
  type: TYPE_TB
- en: '|   | `302 Found` | This can be used to show the resource already exists and
    is valid. |'
  prefs: []
  type: TYPE_TB
- en: '| Client Errors 4XX | `401 Unauthorized` | This is used to show the request
    can''t be processed based on the credentials. |'
  prefs: []
  type: TYPE_TB
- en: '|   | `404 Not Found` | This is used to show the resource is not found. It
    is a good practice to return a `404 Not Found` error to the unauthenticated requests
    to prevent information leaks. |'
  prefs: []
  type: TYPE_TB
- en: '|   | `406 Not Acceptable` | This can be used when the resource cannot produce
    the MIME type specified by the client. This happens when the MIME type specified
    in the `Accept` header does not match any media type in the resource method/class
    annotated with `@Produces`. |'
  prefs: []
  type: TYPE_TB
- en: '|   | `415 Unsupported Media Type` | This can be used when the client sends
    a media type that cannot be consumed by the resource. This happens when the MIME
    type specified in the `Content-Type` header does not match any media type in the
    resource method/class annotated with `@Consumes`. |'
  prefs: []
  type: TYPE_TB
- en: '| Server Errors 5XX | `500 Internal Server error` | This internal server error
    is a generic message when no specific details are available. |'
  prefs: []
  type: TYPE_TB
- en: '|   | `503 Service Unavailable` | This can be used when the server is under
    maintenance or too busy to handle requests. |'
  prefs: []
  type: TYPE_TB
- en: 'JAX-RS defines a `javax.ws.rs.core.Response` class, which has static methods
    to create an instance using `javax.ws.rs.core.Response.ResponseBuilder`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code snippet shows a method `addCoffee()`, which returns a `201
    Created` response using the `Response.created()` method. For more details on other
    response methods, check [https://jersey.java.net/apidocs/latest/jersey/javax/ws/rs/core/Response.html](https://jersey.java.net/apidocs/latest/jersey/javax/ws/rs/core/Response.html).
  prefs: []
  type: TYPE_NORMAL
- en: Recommended reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[https://jersey.java.net/documentation/latest/representations.html](https://jersey.java.net/documentation/latest/representations.html):
    Jersey documentation for content negotiation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://docs.jboss.org/resteasy/docs/2.2.1.GA/userguide/html/JAX-RS_Content_Negotiation.html](http://docs.jboss.org/resteasy/docs/2.2.1.GA/userguide/html/JAX-RS_Content_Negotiation.html):
    RESTEasy and URL-based content negotiation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://dev.twitter.com/docs/api/1.1/overview](https://dev.twitter.com/docs/api/1.1/overview):
    Twitter REST API and versioning strategy'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://developers.facebook.com/docs/apps/versions](https://developers.facebook.com/docs/apps/versions):
    The Facebook API and versioning'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We covered topics such as content negotiation, API versioning, and REST response
    codes in this chapter. One of the primary takeaways from this chapter was to understand
    how important it is to support various representations of the same resource so
    that the client can choose the right one for their case. We covered differences
    between streaming and chunking output and how they can be used as lightweight
    options with custom entity providers such as `MessageBodyReader` and `MessageBodyWriter`.
    We saw case studies of companies that use versioning in their solutions as well
    as best practices and design principles scattered throughout the various topics.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will cover advanced details such as security, traceability,
    and validation in REST programming models.
  prefs: []
  type: TYPE_NORMAL
