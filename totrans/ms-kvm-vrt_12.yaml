- en: '*Chapter 9*: Customizing a Virtual Machine with cloud-init'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Customizing a virtual machine often seems simple enough – clone it from a template;
    start; click a couple of **Next** buttons (or text tabs); create some users, passwords,
    and groups; configure network settings... That might work for a virtual machine
    or two. But what happens if we have to deploy two or three hundred virtual machines
    and configure them? All of a sudden, we're faced with a mammoth task – and it's
    a task that will be prone to errors if we do everything manually. We're wasting
    precious time while doing that instead of configuring them in a much more streamlined,
    automated fashion. That's where cloud-init comes in handy, as it can customize
    our virtual machines, install software on them, and it can do it on first and
    subsequent virtual machine boots. So, let's discuss cloud-init and how it can
    bring value to your large-scale configuration nightmares.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What is the need for virtual machine customization?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding cloud-init
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: cloud-init architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to install and configure cloud-init at boot time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: cloud-init images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: cloud-init data sources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing metadata and user data to cloud-init
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examples on how to use the cloud-config script with cloud-init
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the need for virtual machine customization?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once you really start using virtual machines and learn how to master them,
    you will notice that one thing seems to be happening a lot: virtual machine deployment.
    Since everything is so easy to configure and deploy, you will start to create
    new instances of virtual machines for almost anything, sometimes even to just
    check whether a particular application works on a particular version of the operating
    system. This makes your life as a developer and system administrator a lot easier,
    but creates its own set of problems. One of the most difficult ones is template
    management. Even if you have a small set of different servers and a relatively
    modest number of different configurations, things will start to add up, and if
    you decide to manage templates the normal way through the KVM, the sheer number
    of combinations will soon be too big.'
  prefs: []
  type: TYPE_NORMAL
- en: Another problem that you will soon face is compatibility. When you step out
    of your Linux distribution of choice, and you have to deploy another Linux distribution
    that has its own rules and deployment strategies, things will start to get complicated.
    Usually, the biggest problem is system customization. When it comes to network
    settings and hostnames, every computer on the network should have its own unique
    identity. Having a template that uses DHCP network configuration can solve one
    of these problems, but it is not nearly enough to make things simpler. For example,
    we could use Kickstart for CentOS / RHEL and compatible Linux distributions. Kickstart
    is a way to configure systems while they are being deployed, and if you are using
    these specific distributions, this is probably the best way to quickly deploy
    physical or virtual machines. On the other hand, Kickstart will make your deployments
    slower than they should be, as it uses a configuration file that enables us to
    add software and configuration to a clean installation.
  prefs: []
  type: TYPE_NORMAL
- en: Basically, it *fills up* additional configuration prompts with settings we defined
    earlier. This means that we are basically doing a full installation and creating
    a complete system from scratch every time we need to deploy a new virtual machine.
  prefs: []
  type: TYPE_NORMAL
- en: The main problem is *other distributions do not use Kickstart*. There are similar
    systems that enable unattended installations. Debian and Ubuntu use a tool/system
    called *preseed* and are able to support Kickstart in some parts, SuSe uses AutoYaST,
    and there are even a couple of tools that offer some sort of cross-platform functionality.
    One of them, called **Fully Automated Install** ( **FAI** ) is able to automate
    installing and even the online reconfiguration of different Linux distributions.
    But that still doesn't solve all of the problems that we have. In a dynamic world
    of virtualization, the main goal is to deploy as quickly as possible and to automate
    as much as possible, since we tend to use the same agility when it comes to removing
    virtual machines from production.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine this: you need to create a single application deployment to test your
    new application with different Linux distributions. All of your future virtual
    machines will need to have a unique identifier in the form of a hostname, a deployed
    SSH identity that will enable remote management through Ansible, and of course,
    your application. Your application has three dependencies – two in the form of
    packages that can be deployed through Ansible, but one depends on the Linux distribution
    being used and has to be tailored for that particular Linux distribution. To make
    things even more realistic, you expect that you will have to periodically repeat
    this test, and every time you will need to rebuild your dependencies.'
  prefs: []
  type: TYPE_NORMAL
- en: There are a couple of ways you can create this environment. One is to simply
    manually install all the servers and create templates out of them. This means
    manually configuring everything and then creating a virtual machine template that
    will be deployed. If we intend to deploy to more than a couple of Linux distributions
    this is a lot of work. It becomes even more work once the distributions get upgraded
    since all the templates we are deploying from must be upgraded, often at different
    points in time. This means we can either manually update all the virtual machine
    templates, or perform a post-install upgrade on each of them. This is a lot of
    work and it is extremely slow. Add to that the fact that a test like this will
    probably involve running your test application on both new and old versions of
    virtual machine templates. In addition to all that, we need to solve the problem
    of customizing our network settings for each and every Linux distribution we are
    deploying. Of course, this also means that our virtual machine templates become
    far from generic. After a while, we are going to end up with tens of virtual machine
    templates for each test cycle.
  prefs: []
  type: TYPE_NORMAL
- en: Another approach to this problem can be using a system like Ansible – we deploy
    all the systems from virtual machine templates, and then do the customization
    from Ansible. This is better – Ansible is designed for a scenario just like this,
    but this means that we must first create virtual machine templates that are able
    to support Ansible deployment, with implemented SSH keys and everything else Ansible
    needs to function.
  prefs: []
  type: TYPE_NORMAL
- en: There is one problem neither of these approaches can solve, and that is the
    mass deployment of machines. This is why a framework called cloud-init was designed.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding cloud-init
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We need to get a bit more technical in order to understand what cloud-init is
    and to understand what its limitations are. Since we are talking about a way to
    fully automatically reconfigure a system using simple configuration files, it
    means that some things need to be prepared in advance to make this complex process
    user friendly.
  prefs: []
  type: TYPE_NORMAL
- en: We already mentioned virtual machine templates in [*Chapter 8*](B14834_08_Final_ASB_ePub.xhtml#_idTextAnchor143),
    *Creating and Modifying VM Disks, Templates, and Snapshots*. Here, we are talking
    about a specially configured template that has all the elements needed to read,
    understand, and deploy the configuration that we are going to provide in our files.
    This means that this particular image has to be prepared in advance, and is the
    most complicated part of the whole system.
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, cloud-init images can be downloaded already pre-configured, and the
    only thing that we need to know is which distribution we want to use. All the
    distributions we have mentioned throughout this book (CentOS 7 or 8, Debian, Ubuntu,
    and Red Hat Enterprise Linux 7 and 8) have images we can use. Some of them even
    have different versions of the base operating system available, so we can use
    those if we need to. Be aware that there may be differences between installed
    versions of cloud-init, especially on older images.
  prefs: []
  type: TYPE_NORMAL
- en: Why is this image important? Because it is prepared so that it can detect the
    cloud system it is running under, it determines whether cloud-init should be used
    or should be disabled, and after that, it reads and performs the configuration
    of the system itself.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding cloud-init architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Cloud-init works with the concept of boot stages because it needs fine and
    granular control over what happens to the system during boot. The prerequisite
    for cloud-init would, of course, be a cloud-init image. From the documentation
    available at [https://cloudinit.readthedocs.io](https://cloudinit.readthedocs.io),
    we can learn that there are five stages to a cloud-init boot:'
  prefs: []
  type: TYPE_NORMAL
- en: The `/etc/cloud/cloud-init.diabled` exists. For more information on this and
    all the other things in this chapter, please read the documentation (start at
    [https://cloudinit.readthedocs.io/en/latest/topics/boot.html](https://cloudinit.readthedocs.io/en/latest/topics/boot.html))
    since it contains much more detail about switches and different options that cloud-init
    supports and that make it tick.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `systemd` service called `cloud-init-local.service`, which will run as soon
    as possible and will block the network until it's done. The concept of blocking
    services and targets is used a lot in cloud-init initialization; the reason is
    simple – to ensure system stability. Since cloud-init procedures modify a lot
    of core settings for a system, we cannot afford to let the usual startup scripts
    run and create a parallel configuration that could overrun the one created by
    cloud-init.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `cloud-init.service`. This is the main service that will bring up the previously
    configured network and try to configure everything we scheduled in the data files.
    This will typically include grabbing all the files specified in our configuration,
    extracting them, and executing other preparation tasks. Disks will also be formatted
    and partitioned in this stage if such a configuration change is specified. Mount
    points will also get created, including those that are dynamic and specific to
    a particular cloud platform.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `yum_repos` or `apt` modules), add an SSH key (the `ssh-import-id` module),
    and perform similar tasks in preparation for the next phase, in which we can actually
    use the configuration done in this phase.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **final** stage is the part of the system boot that runs things that would
    probably belong in userland – installing the packages, the configuration management
    plugin deployment, and executing possible user scripts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After all this has been done, the system will be completely configured and up
    and running.
  prefs: []
  type: TYPE_NORMAL
- en: The main advantage of this approach, although it seems complicated, is to have
    only one image stored in the cloud, and then to create simple configuration files
    that will only cover the differences between the *vanilla* default configuration,
    and the one that we need. Images can also be relatively small since they do not
    contain too many packages geared toward an end user.
  prefs: []
  type: TYPE_NORMAL
- en: Cloud-init is often used as the first stage in deploying a lot of machines that
    are going to be managed by orchestration systems such as Puppet or Ansible since
    it provides a way to create working configurations that include ways of connecting
    to each instance separately. Every stage uses YAML as its primary data syntax,
    and almost everything is simply a list of different options and variables that
    get translated into configuration information. Since we are configuring a system,
    we can also include almost any other type of file in the configuration – once
    we can run a shell script while configuring the system, everything is possible.
  prefs: []
  type: TYPE_NORMAL
- en: '*Why is all of this so important?*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Cloud-init stems from a simple idea: create a single template that will define
    the base content of the operating system you plan to use. Then, we create a separate,
    specially formatted data file that will hold the customization data, and then
    combine those two at runtime to create a new instance when you need one. You can
    even improve things a bit by using a template as a base image and then create
    different systems as differencing images. Trading speed for convenience in this
    way can mean deploying in minutes instead of hours.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The way cloud-init was conceived was to be as multiplatform as possible and
    to encompass as many operating systems as can reasonably be done. Currently, it
    supports the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Ubuntu
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SLES/openSUSE
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RHEL/CentOS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fedora
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gentoo Linux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debian
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arch Linux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: FreeBSD
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We enumerated all the distributions, but cloud-init, as its name suggests is
    also *cloud-aware*, which means that cloud-init is able to automatically detect
    and use almost any cloud environment. Running any distribution on any hardware
    or cloud is always a possibility, even without something like cloud-init, but
    since the idea is to create a platform-independent configuration that will be
    deployable on any cloud without any reconfiguration, our system needs to automatically
    account for any differences between different cloud infrastructures. On top of
    that, cloud-init can be used for bare-metal deployment, even if it isn't specifically
    designed for it, or to be more precise, even if it is designed for a lot more
    than that.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Being cloud-aware means that cloud-init gives us tools to do post-deployment
    checks and configuration changes, another extremely useful option.
  prefs: []
  type: TYPE_NORMAL
- en: This all sounds a lot more theoretical than it should be. In practice, once
    you start using cloud-init and learn how to configure it, you will start to create
    a virtual machine infrastructure that will be almost completely independent of
    the cloud infrastructure you are using. In this book, we are using KVM as the
    main virtualization infrastructure, but cloud-init works with any other cloud
    environment, usually without any modification. Cloud-init was initially designed
    to enable easy deployment on Amazon AWS but it has long since transcended that
    limitation.
  prefs: []
  type: TYPE_NORMAL
- en: Also, cloud-init is aware of all the small differences between different distributions,
    so all the things you put in your configuration file will be translated into whatever
    a particular distribution uses to accomplish a particular task. In that sense,
    cloud-init behaves a lot like Ansible – in essence, you define what needs to be
    done, not how to do it, and cloud-init takes that and makes it happen.
  prefs: []
  type: TYPE_NORMAL
- en: Installing and configuring cloud-init at boot time
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main thing that we are covering in this chapter is how to get cloud-init
    to run, and how to get all of its parts in the right place when the machine is
    being deployed, but this only scratches the surface of how cloud-init actually
    works. What you need to understand is that cloud-init runs as a service, configures
    the system, and follows what we told it to do in a certain way. After the system
    has booted, we can connect to it and see what was done, how, and analyze the logs.
    This could seem contrary to the idea of completely automatic deployment but it
    is there for a reason – whatever we do, there is always the possibility that we
    will need to debug the system or do some post-installation tasks that can also
    be automated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using cloud-init is not specifically confined to just debugging. After the
    system has booted, there is a large amount of data created by the system about
    how the boot was done, what actual cloud configuration the system is running on,
    and what was done in regard to customization. Any of your applications and scripts
    can then rely on this data and use it to run and detect certain configuration
    and deployment parameters. Check out this example, taken from a virtual machine
    in Microsoft Azure, running Ubuntu:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ Figure 9.1 – A part of cloud-init output at boot time'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14834_09_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.1 – A part of cloud-init output at boot time
  prefs: []
  type: TYPE_NORMAL
- en: Cloud-init actually displays this at boot time (and much more, depending on
    the cloud-init configuration file), and then puts all of this output into its
    log files, as well. So, we're really well covered in terms of the additional information
    that it produces.
  prefs: []
  type: TYPE_NORMAL
- en: The next step in our cloud-init journey is discussing cloud-init images, as
    these are what we need to make cloud-init work. Let's do that now.
  prefs: []
  type: TYPE_NORMAL
- en: Cloud-init images
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to use cloud-init at boot time, we first need a cloud image. At its
    core, it is basically a semi-installed system that contains specially designed
    scripts that support cloud-init installation. On all distributions, these scripts
    are part of a package called cloud-init, but images are usually more prepared
    than that since they try to negotiate a fine line between size and convenience
    of installation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our examples, we are going to use the ones available at the following URLs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://cloud.centos.org/](https://cloud.centos.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://cloud-images.ubuntu.com/](https://cloud-images.ubuntu.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In all the examples we are going to work with, the main intention is to show
    how the system works on two completely different architectures with minimal to
    no modifications.
  prefs: []
  type: TYPE_NORMAL
- en: Under normal circumstances, getting the image is all you need to be able to
    run cloud-init. Everything else is handled by the data files.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, these are some of the available images for the CentOS distribution:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ Figure 9.2 – A wealth of available cloud-init images for CentOS'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14834_09_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.2 – A wealth of available cloud-init images for CentOS
  prefs: []
  type: TYPE_NORMAL
- en: Notice that images cover almost all of the releases of the distribution, so
    we can simply test our systems not only on the latest version but on all the other
    versions available. We can freely use all of these images, which is exactly what
    we are going to do a bit later when we start with our examples.
  prefs: []
  type: TYPE_NORMAL
- en: Cloud-init data sources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's talk a little about data files. Up to now, we have referred to them generically,
    and we had a big reason to do so. One of the things that make cloud-init stand
    out from other utilities is its ability to support different ways of getting the
    information on what to install and how to install it. We call these configuration
    files data sources, and they can be separated into two broad categories – **user
    data** and **metadata**. We will talk a lot more about each of those in this chapter,
    but as an early introduction, let's say that everything that a user creates as
    part of the configuration, including YAML files, scripts, configuration files,
    and possibly other files to be put on a system, such as applications and dependencies
    that are part of user data. Metadata usually comes directly from the cloud provider
    or serves the purpose of identifying machines.
  prefs: []
  type: TYPE_NORMAL
- en: It contains instance data, hostnames, network name, and other cloud-specific
    details that can prove useful when deploying. We can use both these types of data
    during boot and will be doing so. Everything we put in will be stored in a large
    JSON store in `/run/cloud-init/instance-data.json` at runtime, or as part of the
    actual machine configuration. A good example of this is the hostname, part of
    the metadata that will end up as the actual hostname on the individual machine.
    This file is populated by cloud-init and can be accessed through the command line
    or directly.
  prefs: []
  type: TYPE_NORMAL
- en: When creating any file in the configuration, we can use any file format available,
    and we are able to compress the files if needed – cloud-init will decompress them
    before it runs. If we need to pass the actual files into the configuration, there
    is a limitation though – files need to be encoded as text and put into variables
    in a YAML file, to be used and written later on the system we are configuring.
    Just like cloud-init, YAML syntax is declarative – this is an important thing
    to remember.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's learn how we pass metadata and user data to cloud-init.
  prefs: []
  type: TYPE_NORMAL
- en: Passing metadata and user data to cloud-init
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our examples, we are going to create a file that will essentially be an `.iso`
    image and behave like a CD-ROM connected to the booting machine. Cloud-init knows
    how to handle a situation like this, and will mount the file, extract all the
    scripts, and run them in a predetermined order, as we already mentioned when we
    explained how the boot sequence works (check the *Understanding cloud-init architecture*
    section earlier in this chapter).
  prefs: []
  type: TYPE_NORMAL
- en: 'In essence, what we have to do to get the whole thing running is to create
    an image that will get connected to the cloud template, and that will provide
    all the data files to the cloud-init scripts inside the template. This is a three-step
    process:'
  prefs: []
  type: TYPE_NORMAL
- en: We have to create the files that hold the configuration information.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have to create an image that contains the file data in the right place.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We need to associate the image with the template at boot time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The most complicated part is defining how and what we need to configure when
    booting. All of this is accomplished on a machine that is running the cloud-utils
    package for a given distribution.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we need to make a point about the two different packages that
    are used in all the distributions to enable cloud-init support:'
  prefs: []
  type: TYPE_NORMAL
- en: '`cloud-init` – Contains all that is necessary to enable a computer to reconfigure
    itself during boot if it encounters a cloud-init configuration'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cloud-utils` – Is used to create a configuration that is to be applied to
    a cloud image'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The main difference between these packages is the computer we are installing
    them on. `cloud-init` is to be installed on the computer we are configuring and
    is part of the deployment image. `cloud-utils` is the package intended to be used
    on the computer that will create the configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'In all the examples and all the configuration steps in this chapter, we are
    in fact referring to two different computers/servers: one that can be considered
    primary, and the one that we are using in this chapter – unless we state otherwise
    – is the computer that we use to create the configuration for cloud-init deployment.
    This is not the computer that is going to be configured using this configuration,
    just a computer that we use as a workstation to prepare our files.'
  prefs: []
  type: TYPE_NORMAL
- en: In this simplified environment, this is the same computer that runs the entire
    KVM virtualization and is used both to create and deploy virtual machines. In
    a normal setup, we would probably create our configuration on a workstation that
    we work on and deploy to some kind of KVM-based host or cluster. In that case,
    every step that we present in this chapter basically remains the same; the only
    difference is the place that we deploy to, and the way that the virtual machine
    is invoked for the first boot.
  prefs: []
  type: TYPE_NORMAL
- en: We will also note that some virtualization environments, such as OpenStack,
    oVirt, or RHEV-M, have direct ways to communicate with a cloud-init enabled template.
    Some of them even permit you to directly reconfigure the machine on first boot
    from a GUI, but that falls way out of the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: The next topic on our list is cloud-init modules. Cloud-init uses modules for
    a reason – to extend its range of available actions it can take in the virtual
    machine boot phase. There are dozens of cloud-init modules available – `SSH`,
    `yum`, `apt`, setting `hostname`, `password`, `locale`, and creating users and
    groups, to name a few. Let's check how we can use them.
  prefs: []
  type: TYPE_NORMAL
- en: Using cloud-init modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When creating a configuration file, in cloud-init, pretty much like in any
    other software abstraction layer, we are dealing with modules that are going to
    translate our more-or-less universal configuration demands, such as *this package
    needs to be installed* into actual shell commands on a particular system. The
    way this is done is through **modules**. Modules are logical units that break
    down different functionalities into smaller groups and enable us to use different
    commands. You can check the list of all available modules at the following link:
    [https://cloudinit.readthedocs.io/en/latest/topics/modules.html](https://cloudinit.readthedocs.io/en/latest/topics/modules.html).
    It''s quite a list, which will just further show you how well developed cloud-init
    is.'
  prefs: []
  type: TYPE_NORMAL
- en: As we can see from the list, some of the modules, such as, for example, `Disk
    setup` or `Locale`, are completely platform-independent while some, for example,
    `Puppet`, are designed to be used with a specific software solution and its configuration,
    and some are specific to a particular distribution or a group of distributions,
    like `Yum Add Repo` or `Apt Configure`.
  prefs: []
  type: TYPE_NORMAL
- en: This can seem to break the idea of a completely distribution-agnostic way to
    deploy everything, but you must remember two things – cloud-init is first and
    foremost cloud-agnostic, not distribution-agnostic, and distributions sometimes
    have things that are way too different to be solved with any simple solution.
    So, instead of trying to be everything at once, cloud-init solves enough problems
    to be useful, and at the same time tries not to create new ones.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: We are not going to deal with particular modules one by one since it would make
    this chapter too long and possibly turn it into a book on its own. If you plan
    on working with cloud-init, consult the module documentation since it will provide
    all the up-to-date information you need.
  prefs: []
  type: TYPE_NORMAL
- en: Examples on how to use a cloud-config script with cloud-init
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, you need to download the cloud images and resize them in order to make
    sure that the disk size after everything is installed is large enough to accommodate
    all the files you plan to put in the machine you created. In these examples, we
    are going to use two images, one for CentOS, and another for Ubuntu Server. We
    can see that the CentOS image we are using is 8 GB in size, and we will enlarge
    it to 10 GB. Note that the actual size on the disk is not going to be 10 GB; we
    are just allowing the image to grow to this size.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to do the same with the Ubuntu image, after we get it from the
    internet. Ubuntu also publishes cloud versions of their distribution daily, for
    all supported versions. The main difference is that Ubuntu creates images that
    are designed to be 2.2 GB when full. We downloaded an image from [https://cloud.centos.org](https://cloud.centos.org);
    let''s now get some information about it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ Figure 9.3 – Cloud-init image sizes'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14834_09_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.3 – Cloud-init image sizes
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the actual size on the disk is different – `qemu-img` gives us 679
    MB and 2.2 GB versus roughly 330 MB and 680 MB of actual disk usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ Figure 9.4 – Image size via qemu-img differs from the real virtual image
    size'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14834_09_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.4 – Image size via qemu-img differs from the real virtual image size
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now do a couple of everyday administration tasks on these images – grow
    them, move them to the correct directory for KVM, use them as a base image, and
    then customize them via cloud-init:'
  prefs: []
  type: TYPE_NORMAL
- en: Let's make these images bigger, just so that we can have them ready for future
    capacity needs (and practice):![Figure 9.5 – Growing the Ubuntu and CentOS maximum
    image size to 10 GB via qemu-img
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B14834_09_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.5 – Growing the Ubuntu and CentOS maximum image size to 10 GB via qemu-img
  prefs: []
  type: TYPE_NORMAL
- en: 'After growing our images, note that the size on the disk hasn''t changed much:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ Figure 9.6 – The real disk usage has changed only slightly'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14834_09_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.6 – The real disk usage has changed only slightly
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to prepare our environment for the cloud-image procedure so
    that we can enable cloud-init to do its magic.
  prefs: []
  type: TYPE_NORMAL
- en: The images that we are going to use are going to be stored in `/var/lib/libvirt/images`:![
    Figure 9.7 – Moving images to the KVM default system directory
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B14834_09_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.7 – Moving images to the KVM default system directory
  prefs: []
  type: TYPE_NORMAL
- en: We are going to create our first cloud-enabled deployment in the simplest way
    possible, by only repartitioning the disk and creating a single user with a single
    SSH key. The key belongs to the root of the host machine, so we can directly log
    in to the deployed machine after cloud-init is done.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, we are going to use our images as base images by running the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.8 – Creating an image disk for deployment'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14834_09_08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.8 – Creating an image disk for deployment
  prefs: []
  type: TYPE_NORMAL
- en: The images are now ready. The next step is to start the cloud-init configuration.
  prefs: []
  type: TYPE_NORMAL
- en: First, create a local metadata file and put the new virtual machine name in
    it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The file will be named `meta-data` and we are going to use `local-hostname`
    to set the name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We have three files in our directory: a hard disk that uses a base file with
    the cloud template, a `meta-data` file that contains just minimal information
    that is essential for our deployment, and `user-data`, which contains our definitions
    for our user. We didn''t even try to install or copy anything; this install is
    as minimal as it gets, but in a normal environment this is a regular starting
    point, as a lot of deployments are intended only to bring our machine online,
    and then do the rest of the installation by using other tools. Let''s move to
    the next step.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We need a way to connect the files we just created, the configuration, with
    the virtual machine. Usually, this is done in a couple of ways. The simplest way
    is usually to generate a `.iso` file that contains the files. Then we just mount
    the file as a virtual CD-ROM when we create the machine. On boot, cloud-init will
    look for the files automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way is to host the files somewhere on the network and grab them when
    we need them. It is also possible to combine these two strategies. We will discuss
    this a little bit later, but let''s finish our deployment first. The local `.iso`
    image is the way we are going to go on this deployment. There is a tool called
    `genisoimage` (provided by the package with the same name) that is extremely useful
    for this (the following command is a one-line command):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'What we are doing here is creating an emulated CD-ROM image that will follow
    the ISO9660/Joliet standard with Rock Ridge extensions. If you have no idea what
    we just said, ignore all this and think about it this way – we are creating a
    file that will hold our metadata and user data and present itself as a CD-ROM:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ Figure 9.11 – Creating an ISO image'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14834_09_11.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.11 – Creating an ISO image
  prefs: []
  type: TYPE_NORMAL
- en: 'In the end, we are going to get something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.12 – ISO is created and we are ready to start a cloud-init deployment'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14834_09_12.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.12 – ISO is created and we are ready to start a cloud-init deployment
  prefs: []
  type: TYPE_NORMAL
- en: Please note that images are taken post deployment, so the size of disk can vary
    wildly based on your configuration. This was all that was needed in the form of
    preparations. All that's left is to spin up our virtual machine.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's start with our deployments.
  prefs: []
  type: TYPE_NORMAL
- en: The first deployment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are going to deploy our virtual machine by using a command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Although it may look complicated, if you came to this part of the book after
    reading its previous chapters, there should be nothing you haven''t seen yet.
    We are using KVM, creating a name for our domain (virtual machine), we are going
    to give it 1 CPU and 2 GB of RAM. We are also telling KVM we are installing a
    generic Linux system. We already created our hard disk, so we are mounting it
    as our primary drive, and we are also mounting our `.iso` file to serve as a CD-ROM.
    Lastly, we will connect our virtual machine to the default network:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B14834_09_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.13 – Deploying and testing a cloud-init customized virtual machine
  prefs: []
  type: TYPE_NORMAL
- en: The deployment will probably take a minute or two. As soon as the machine boots,
    it will get the IP address and we can SSH to it using our predefined key. The
    only thing that was not automated is accepting the fingerprint of the newly booted
    machine automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the time has come to see what happened when we booted the machine. Cloud-init
    generated a log at `/var/log` named `cloud-init.log`. The file will be fairly
    large, and the first thing you will notice is that the log is set to provide debug
    information, so almost everything will be logged:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.14 – The cloud-init.log file, used to check what cloud-init did
    to the operating system'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14834_09_14.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.14 – The cloud-init.log file, used to check what cloud-init did to
    the operating system
  prefs: []
  type: TYPE_NORMAL
- en: Another thing is how much actually happens below the surface completely automatically.
    Since this is CentOS, cloud-init has to deal with the SELinux security contexts
    in real time, so a lot of the information is simply that. There are also a lot
    of probes and tests going on. Cloud-init has to establish what the running environment
    is and what type of cloud it is running under. If something happens during the
    boot process and it in any way involves cloud-init, this is the first place to
    look.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now deploy our second virtual machine by using a second (Ubuntu) image.
    This is where cloud-init really shines – it works with various Linux (and *BSD)
    distributions, whatever they might be. We can put that to the test now.
  prefs: []
  type: TYPE_NORMAL
- en: The second deployment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The next obvious step is to create another virtual machine, but to prove a
    point, we are going to use Ubuntu Server (Bionic) as our image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ Figure 9.15 – Preparing our environment for another cloud-init-based virtual
    machine deployment'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14834_09_15.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.15 – Preparing our environment for another cloud-init-based virtual
    machine deployment
  prefs: []
  type: TYPE_NORMAL
- en: 'What do we need to do? We need to copy both `meta-data` and `user-data` to
    the new folder. We need to edit the metadata file since it has the hostname inside
    it, and we want our new machine to have a different hostname. As for `user-data`,
    it is going to be completely the same as on our first virtual machine. Then we
    need to create a new disk and resize it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ Figure 9.16 – Growing our virtual machine image for deployment purposes'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14834_09_16.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.16 – Growing our virtual machine image for deployment purposes
  prefs: []
  type: TYPE_NORMAL
- en: 'We are creating a virtual machine from our downloaded image, and just allowing
    for more space as the image is run. The last step is to start the machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.17 – Deploying our second virtual machine with cloud-init'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14834_09_17.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.17 – Deploying our second virtual machine with cloud-init
  prefs: []
  type: TYPE_NORMAL
- en: 'The command line is almost exactly the same, only the names change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s check the IP addresses:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.18 – Check the virtual machine IP addresses'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14834_09_18.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.18 – Check the virtual machine IP addresses
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see both of the machines are up and running. Now for the big test –
    can we connect? Let''s use the `SSH` command to try:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ Figure 9.19 – Using SSH to verify whether we can connect to our virtual
    machine'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14834_09_19.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.19 – Using SSH to verify whether we can connect to our virtual machine
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, the connection to our virtual machine works without any problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'One more thing is to check the deployment log. Note that there is no mention
    of configuring SELinux since we are running on Ubuntu:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ Figure 9.20 – The Ubuntu cloud-init log file has no mention of SELinux'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14834_09_20.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.20 – The Ubuntu cloud-init log file has no mention of SELinux
  prefs: []
  type: TYPE_NORMAL
- en: Just for fun, let's do another deployment with a twist – let's use a module
    to deploy a software package.
  prefs: []
  type: TYPE_NORMAL
- en: The third deployment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s deploy another image. In this instance, we are creating another CentOS
    7 but this time we are *installing* (not *starting*) `httpd` in order to show
    how this type of configuration works. Once again, the steps are simple enough:
    create a directory, copy the metadata and user data files, modify the files, create
    the `.iso` file, create the disk, and run the machine.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This time we are adding another section (`packages`) to the configuration,
    so that we can *tell* cloud-init that we need a package to be installed (`httpd`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![ Figure 9.21 – Cloud-init configuration file for the third virtual machine
    deployment'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14834_09_21.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.21 – Cloud-init configuration file for the third virtual machine deployment
  prefs: []
  type: TYPE_NORMAL
- en: 'Since all the steps are more or less the same, we get the same result – success:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ Figure 9.22 – Repeating the deployment process for the third virtual machine'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14834_09_22.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.22 – Repeating the deployment process for the third virtual machine
  prefs: []
  type: TYPE_NORMAL
- en: We should wait for a while so that the VM gets deployed. After that, let's log
    in and check whether the image deployed correctly. We asked for `httpd` to be
    installed during the deployment. Was it?
  prefs: []
  type: TYPE_NORMAL
- en: '![ Figure 9.23 – Checking whether httpd is installed but not started'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14834_09_23.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.23 – Checking whether httpd is installed but not started
  prefs: []
  type: TYPE_NORMAL
- en: We can see that everything was done as expected. We haven't asked for the service
    to start, so it is installed with the default settings and is disabled and stopped
    by default.
  prefs: []
  type: TYPE_NORMAL
- en: After the installation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The intended use of cloud-init is to configure machines and create an environment
    that will enable further configuration or straight deployment into production.
    But to enable that, cloud-init has a lot of options that we haven't even mentioned
    yet. Since we have an instance running, we can go through the most important and
    the most useful things you can find in the newly booted virtual machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing to check is the `/run/cloud-init` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ Figure 9.24 – /run/cloud-init folder contents'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14834_09_24.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.24 – /run/cloud-init folder contents
  prefs: []
  type: TYPE_NORMAL
- en: Everything that is created at runtime is written here, and available for users.
    Our demo machine was run under the local KVM hypervisor so cloud-init is not detecting
    a cloud, and consequently is unable to provide more data about the cloud, but
    we can see some interesting details. The first one is two files named `enabled`
    and `network-config-ready`. Both of them are empty but very important. The fact
    that they exist signifies that cloud-init is enabled, and that network has been
    configured and is working. If the files are not there, something went wrong and
    we need to go back and debug. More about debugging can be found at [https://cloudinit.readthedocs.io/en/latest/topics/debugging.html](https://cloudinit.readthedocs.io/en/latest/topics/debugging.html).
  prefs: []
  type: TYPE_NORMAL
- en: The `results.json` file holds this particular instance metadata. `status.json`
    is more concentrated on what happened when the whole process was running, and
    it provides info on possible errors, the time it took to configure different parts
    of the system, and whether everything was done.
  prefs: []
  type: TYPE_NORMAL
- en: Both those files are intended to help with the configuration and orchestration,
    and, while some things inside these files are important only to cloud-init, the
    ability to detect and interact with different cloud environments is something
    that other orchestration tools can use. Files are just a part of it.
  prefs: []
  type: TYPE_NORMAL
- en: Another big part of this scheme is the command-line utility called `cloud-init`.
    To get information from it, we first need to log in to the machine that we created.
    We are going to show the differences between machines that were created by the
    same file, and at the same time demonstrate similarities and differences between
    distributions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we start talking about this, be aware that cloud-init, as with all Linux
    software, comes in different versions. CentOS 7 images use an old version, 0.7.9:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.25 – CentOS cloud-init version – quite old'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14834_09_25.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.25 – CentOS cloud-init version – quite old
  prefs: []
  type: TYPE_NORMAL
- en: 'Ubuntu comes with a much fresher version, 19.3:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.26 – Ubuntu cloud-init version – up to date'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14834_09_26.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.26 – Ubuntu cloud-init version – up to date
  prefs: []
  type: TYPE_NORMAL
- en: 'Before you freak out, this is not as bad as it seems. Cloud-init decided to
    switch its versioning system a couple of years ago, so after 0.7.9 came 17.1\.
    There were many changes and most of them are directly connected to the cloud-init
    command and configuration files. This means that the deployment will work, but
    a lot of things after we deploy will not. Probably the most visible difference
    is when we run `cloud-init --help`. For Ubuntu, this is what it looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.27 – Cloud-init features on Ubuntu'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14834_09_27.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.27 – Cloud-init features on Ubuntu
  prefs: []
  type: TYPE_NORMAL
- en: 'Realistically, a lot of things are missing for CentOS, some of them completely:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ Figure 9.28 – Cloud-init features on CentOS'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14834_09_28.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.28 – Cloud-init features on CentOS
  prefs: []
  type: TYPE_NORMAL
- en: 'Since our example has a total of three running instances – one Ubuntu and two
    CentOS virtual machines – let''s try to manually upgrade to the latest stable
    version of cloud-init available on CentOS. We can use our regular `yum update`
    command to achieve that, and the result will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ Figure 9.29 – After a bit of yum update, an up-to-date list of cloud-init
    features'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14834_09_29.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.29 – After a bit of yum update, an up-to-date list of cloud-init features
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, this will make things a lot easier to work with.
  prefs: []
  type: TYPE_NORMAL
- en: We are not going to go into too much detail about the cloud-init CLI tool, since
    there is simply too much information available for a book like this, and as we
    can see, new features are being added quickly. You can freely check additional
    options by browsing at [https://cloudinit.readthedocs.io/en/latest/topics/cli.html](https://cloudinit.readthedocs.io/en/latest/topics/cli.html).
    In fact, they are being added so quickly that there is a `devel` option that holds
    new features while they are in active development. Once they are finished, they
    become commands of their own.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two commands that you need to know about, both of which give an enormous
    amount of information about the boot process and the state of the booted system.
    The first one is `cloud-init analyze`. It has two extremely useful subcommands:
    `blame` and `show`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The aptly named `blame` is actually a tool that returns how much time was spent
    on things that happened during different procedures cloud-init did during boot.
    For example, we can see that configuring `grub` and working with the filesystem
    was the slowest operation on Ubuntu:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ Figure 9.30 – Checking time consumption for cloud-init procedures'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14834_09_30.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.30 – Checking time consumption for cloud-init procedures
  prefs: []
  type: TYPE_NORMAL
- en: 'The third virtual machine that we deployed uses CentOS image and we added `httpd`
    to it. By extension, it was by far the slowest thing that happened during the
    cloud-init process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ Figure 9.31 – Checking time consumption – it took quite a bit of time for'
  prefs: []
  type: TYPE_NORMAL
- en: cloud-init to deploy the necessary httpd packages
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14834_09_31.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.31 – Checking time consumption – it took quite a bit of time for cloud-init
    to deploy the necessary httpd packages
  prefs: []
  type: TYPE_NORMAL
- en: A tool like this makes it easier to optimize deployments. In our particular
    case, almost none of this makes sense, since we deployed simple machines with
    almost no changes to the default configuration, but being able to understand why
    the deployment is slow is a useful, if not essential, thing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another useful thing is being able to see how much time it took to actually
    boot the virtual machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ Figure 9.32 – Checking the boot time'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14834_09_32.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.32 – Checking the boot time
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to end this part with a query – `cloud-init query` enables you
    to request information from the service, and get it in a useable structured format
    that you can then parse:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.33 – Querying cloud-init for information'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14834_09_33.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.33 – Querying cloud-init for information
  prefs: []
  type: TYPE_NORMAL
- en: After working with it for even a few hours, cloud-init becomes one of those
    indispensable tools for a system administrator. Of course, its very essence means
    it will be much more suited to those of us who have to work in the cloud environment,
    because the thing it does best is the quick and painless deployment of machines
    from scripts. But even if you are not working with cloud technologies, the ability
    to quickly create instances that you can use for testing, and then to remove them
    without any pain, is something that every administrator needs.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered cloud-init, its architecture, and the benefits in
    larger deployment scenarios, where configuration consistency and agility are of
    utmost importance. Pair that with the paradigm change in which we don't do everything
    manually – we have a tool that does it for us – and it's an excellent addition
    to our deployment processes. Make sure that you try to use it as it will make
    your life a lot easier, while preparing you for using cloud virtual machines,
    where cloud-init is extensively used.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we're going to learn how to expand this usage model to
    Windows virtual machines by using cloudbase-init.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Recreate our setup using CentOS 7 and Ubuntu base cloud-init images.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create one Ubuntu and two CentOS instances using the same base image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a fourth virtual machine using Ubuntu as a base image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Try using some other distribution as a base image without changing any of the
    configuration files. Give FreeBSD a try.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Instead of using SSH keys, use predefined passwords. Is this more or less secure?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a script that will create 10 identical instances of a machine using cloud-init
    and a base image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can you find any reason why it would be more beneficial to use a distribution-native
    way of installing machines instead of using cloud-init?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Please refer to the following links for more information regarding what was
    covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Cloud-init documentation hub: [https://cloudinit.readthedocs.io/en/latest/](https://cloudinit.readthedocs.io/en/latest/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Project home page for cloud-init: [https://cloud-init.io/](https://cloud-init.io/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Source code: [https://code.launchpad.net/cloud-init](https://code.launchpad.net/cloud-init)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Particularly good examples of config files: [https://cloudinit.readthedocs.io/en/latest/topics/examples.html](https://cloudinit.readthedocs.io/en/latest/topics/examples.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
