- en: '*Chapter 12*: Network Monitoring Using Linux'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we'll be discussing various network monitoring and management
    protocols, tools, and approaches. We'll cover logging using syslog, which can
    be used to log events of interest on various hosts. This will be extended to a
    cloud-based collection of syslog events, allowing you to both summarize firewall
    traffic and compare your traffic patterns against those across the internet.
  prefs: []
  type: TYPE_NORMAL
- en: We'll discuss using SNMP to collect performance statistics of your various network
    devices and hosts, which can be useful in both troubleshooting and capacity planning.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we'll use NetFlow and other flow-collection protocols to look for traffic
    anomalies – we'll use NetFlow to follow a typical incident investigation, uncovering
    a large data exfiltration event.
  prefs: []
  type: TYPE_NORMAL
- en: 'In particular, we''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Logging using Syslog
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Dshield project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collecting NetFlow data on Linux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we'll be discussing several facets of network management. While
    you can certainly recreate the example builds in this chapter, just be aware that
    your data will be different. So, while the methodology of using the various data
    types for monitoring or troubleshooting will remain the same, to use your data
    (and any issues you find that need resolution) in your environment, you will need
    different search terms.
  prefs: []
  type: TYPE_NORMAL
- en: That being said, your existing Linux Host or VM can be used to build any or
    all of the example systems described in this chapter. However, in production,
    you would separate these functions across one, two, or even more dedicated servers.
    If you are using a VM for your lab, my best suggestion would be to start from
    a new, clean image and build forward from there – that way, if you find any of
    the various **Network Management Systems** (**NMSes**) we work with useful, you
    can move forward with them directly into production.
  prefs: []
  type: TYPE_NORMAL
- en: The NMS section focuses on the LibreNMS application. The suggestion for that
    set of examples is to download and install the pre-built Linux VM image (in OVA
    format) for that application.
  prefs: []
  type: TYPE_NORMAL
- en: Logging using Syslog
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Logging** is a key facet of managing any system, and central logging is almost
    universally recommended. Logging centrally allows you to combine the logs from
    several servers or services – for instance, your firewall, load balancer, and
    web server – into one file in chronological order. This can often speed up any
    troubleshooting or diagnosis as you see an even move from one platform to the
    next. From a security point of view, this is especially important in **Incident
    Response** (**IR**). In responding to an incident, you might see malware arrive
    in an email, then execute as a process, then move laterally (often called "east/west")
    to other workstation hosts, or move "north" toward your servers. Add to this that
    after regular (often hourly) updates, the current versions of your tools may very
    well be able to pick malware out of your logs that might have sailed by unnoticed
    yesterday.'
  prefs: []
  type: TYPE_NORMAL
- en: Also, from a security point of view, logging to a central location takes a copy
    of those log entries off the source host. If that source host is compromised,
    this can give you a "more trusted" version of the truth. After an initial compromise,
    your attacker has to expend more effort to find and compromise a central log server.
    In a lot of cases, this delay can be used to your advantage to identify and alert
    that the attack has occurred. Often, defenses are all about delaying the attacker
    and providing as much detail to the defenders as possible during this delay. Central
    logging, along with close to real-time analysis or triggers against log entries,
    is a great example of this.
  prefs: []
  type: TYPE_NORMAL
- en: So, what design and usability considerations should we think about when deploying
    and using central logging?
  prefs: []
  type: TYPE_NORMAL
- en: Log size, rotation, and databases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first thing you'll notice about logs is that they grow very quickly. If
    you are doing full logging on a firewall, even in a small organization, just those
    logs can grow into GBs per day very quickly. Add to that logs from routers, switches,
    servers, and the services on those servers, and logs can become very complex and
    difficult to search.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing people often do is separate logs out. It's always wise to keep
    an "everything log", but it can be handy to take copies of each device or service
    log and break those out to separate, smaller logs. While firewall logs might be
    gigabytes in size, router logs for that same period are most likely to be kilobytes
    in size, often in single digits. Log size can often be an indicator of a problem
    – for instance, if you have a log that's typically 3-5 KB per day, which suddenly
    grows to 2-3 MB per day, that's often an indication that something is wrong. Or,
    if you have 15 branch offices that are supposed to be identical, but one has a
    router or firewall log that's 3x or 10x the size of the others, that's also a
    great big arrow saying "look here!"
  prefs: []
  type: TYPE_NORMAL
- en: Often, people will take a hybrid approach – keep that monolithic log that contains
    everything, have separate logs for everything, but then consolidate those things
    that aren't as "chatty" – for instance, just removing firewall logs as well as
    Linux and Hypervisor main syslog logs can dramatically reduce the log size but
    still retain a reasonably consolidated log file.
  prefs: []
  type: TYPE_NORMAL
- en: All of this takes up disk space, and every time you slice the data differently,
    it's likely to dramatically increase that space requirement again. Keep an eye
    on the overall size of data and the volumes that you have it on – you never want
    to be in a position where an attack can fill the log volume. This situation can
    stall the logging process altogether, so you don't know where the attacker has
    gone. It can also overwrite the initial set of events in the incident, so you
    won't know how the attacker got their foothold in the first place. In the worst
    case, it can do both.
  prefs: []
  type: TYPE_NORMAL
- en: One way to deal with this space issue is to archive your logs – keep 1-5-7-10
    days of logs in an easily searchable format, but beyond that, maybe archive and
    compress the main log and delete the rest. This can keep the traditional text
    files, along with the traditional `grep`/`cut`/`sort`/`uniq search` approach,
    but keep the size manageable.
  prefs: []
  type: TYPE_NORMAL
- en: A more modern approach might be to keep that monolithic "everything" log file,
    with periodic offline storage, which makes it easy to keep logs for months or
    years – whatever is required by your policy, procedures, or compliance requirements.
    You can then re-forward traffic to your SIEM as needed from this central location.
    These logs all remain searchable using command-line tools.
  prefs: []
  type: TYPE_NORMAL
- en: For troubleshooting day-to-day issues, parse the log data and store it in a
    database. This allows for much faster searches, especially after applying strategic
    indices, and also allows you to manage the overall size of the data much easier.
    The key thing in this approach isn't to manage the disk space but to (as much
    as possible) manage the log volumes by a target time interval that will facilitate
    predictable, repeatable troubleshooting and reporting windows.
  prefs: []
  type: TYPE_NORMAL
- en: Let's dig into how you can add search terms iteratively to find a final answer
    when troubleshooting.
  prefs: []
  type: TYPE_NORMAL
- en: Log analysis – finding "the thing"
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The main challenge that people face once they have logs on disk is how to use
    them. Specifically, when troubleshooting or working through a security incident,
    you know that there is good information in the logs, but knowing where to search,
    how to search, and what tools to use is a daunting task if you're just starting
    in log analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Where to look
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Often, it makes sense to determine where on the OSI stack you are looking for
    your problem. Things such as duplicate IP addresses are Layer 3 issues – you'll
    look on router or switch logs for them. However, that same problem might start
    with end user reports stating that "the web server is erratic", so you might start
    the application logs for the web server – it might take you some time to work
    that issue down the stack through the various server and device logs to find the
    root problem. In one recent example, I worked with the helpdesk to deploy a new
    printer, and I accidentally used one of the web server cluster addresses in the
    printer configuration by mistake.
  prefs: []
  type: TYPE_NORMAL
- en: While finding these issues might be quicker in a larger log, searching a multi-GB
    text log can easily take 5-10-15 minutes per "try" as you interactively get to
    a final set of search terms. Again, in the case of text logs, you will often start
    your search in "the most likely" log rather than the "search here, it has everything"
    log.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we're looking in the right place, how can we narrow down all these
    log entries to find "the answer"?
  prefs: []
  type: TYPE_NORMAL
- en: How to search
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In most cases, searching logs will consist of a series of `find this` and `exclude
    that` clauses. If you are searching a text log, this will usually be `grep –i
    "include text"` or `grep –i –v "exclude text"`. Note that using `–i` makes your
    searches case-insensitive. If you string enough of these together in the right
    order, this is usually enough.
  prefs: []
  type: TYPE_NORMAL
- en: However, if you want to then "count" specific events, `uniq -c` can be helpful,
    which will count unique events. Then, you can use `sort –r` to sort them into
    descending order.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, to find DNS queries to external DNS servers, you''ll want to
    search your firewall logs. If the firewall is a Cisco ASA, the query might look
    similar to this sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16336_12_Table_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Our final command? Let''s take a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This looks complex, but keep in mind that this is done iteratively – we work
    out each "clause" in the request separately and string them together sequentially.
    Also, in many cases, we might spend several minutes or even hours getting a query
    "just perfect," but then use that query in an automated way for years going forward,
    so it's time well spent!
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, while we showed this query using Linux command-line text processing commands,
    the same methodology can be used for a database log repository, or even for querying
    against a different firewall. No matter what the target device, log repository
    type, or problem we''re solving, the approach is most often to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Use some broad-brush queries or selections (either includes or excludes) to
    whittle the data down to a more manageable volume.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do whatever is needed to massage that data so that it can be queried more specifically.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use some more specific queries to narrow it down more.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we're looking for counts or most common occurrences, summarize the data to
    match what's needed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test the final query/selection criteria.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Plug the final search terms into whatever automation is needed so that this
    information is summarized or reported on at whatever frequency is needed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This covers how to search through logs of past events to diagnose an issue in
    the past, but can't we use logs to tell us immediately when known problems have
    occurred? The short answer is "yes, absolutely." Let's explore how this is done.
  prefs: []
  type: TYPE_NORMAL
- en: Alerts on specific events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is an extension of the "finding the thing" conversation – maybe alongside
    the topic of "when to look." Of course, the best time to find a problem is the
    instant it happens – or maybe even before it happens, so that you can fix it as
    soon as possible.
  prefs: []
  type: TYPE_NORMAL
- en: To that end, it's very common to have simple text strings defined that might
    indicate a problem and alert the right people when that occurs. You might send
    them an email alert or SMS message the instant such an alert happens, or maybe
    collect alerts for a day and send a daily summary – your approach will likely
    depend on your environment and the severity of the alerts that are seen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Common search terms to hunt for include the following (case-insensitive searches
    are almost always recommended):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16336_12_Table_02a.jpg)![](img/B16336_12_Table_02b.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In all of these cases, you'll likely want to add a `not` clause to filter out
    users who might be browsing or searching for these terms – for instance, "batter"
    will find all battery incidents, but it will also find users searching for cake
    recipes and baseball news stories. If you exclude "http" from the search terms,
    that will often get you just what you need.
  prefs: []
  type: TYPE_NORMAL
- en: With triggers like these in play, you can head off a pile of problems, often
    before they become problems – this is always a good thing.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've discussed searches and triggers, let's build a log server and
    try out these methods for real!
  prefs: []
  type: TYPE_NORMAL
- en: Syslog server example – Syslog
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To run basic syslog services on a Linux host, we'll be configuring the `rsyslog`
    service. By default, this service listens on port `514/udp`, though both the port
    and the protocol are configurable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Log events come in various priority or severity levels, which are normally
    set by the sending device:'
  prefs: []
  type: TYPE_NORMAL
- en: '`emerg, panic` (Emergency) – Level `0`: This is the lowest log level. The system
    is unusable. Often these, are the last messages that you will see before a system
    crash.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`alert` (Alerts): Level `1`: Action must be taken immediately. These usually
    impact the operation of the overall system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`crit` (Critical): Level `2`: As with alerts, action must be taken immediately.
    The primary functions of the system are likely not operating.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`err` (Errors): Level `3`: Important errors, but the system is still up. The
    primary functions of the system are likely affected.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`warn` (Warnings): Level `4`: Warning conditions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`notice` (Notification): Level `5`: Normal but significant conditions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`info` (Information): Level `6`: Informational messages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`debug` (Debugging): Level `7`: This is the highest level – debug-level messages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Usually, when you configure one logging level, all the lower logging levels
    are included. So, if you configure a level 4 syslog on a host, that includes 0,
    1, 2, and 3 as well. This explains why, in most situations, you only configure
    one logging level for any given host.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s likely that `rsyslog` is already installed and running on your Linux
    host. Let''s check:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If you don''t have this service installed, it''s as simple as running the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: With the service installed and running, let's get on with the configuration.
    Edit the `/etc/rsyslog.conf` file, ensuring you do so with `sudo` rights.
  prefs: []
  type: TYPE_NORMAL
- en: 'You''ll find that the lines that control the listening ports are as follows.
    Uncomment the lines for UDP, as shown (the two lines with `imudp` in them). If
    you''d also like to accept syslog on `514/tcp`, feel free to uncomment this as
    well (both are shown uncommented here):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'If you''d like to restrict syslog clients to a particular set of subnets or
    DNS domains, you can do that by adding an `AllowedSender` line to this file, as
    shown here, below either of the "input" lines we just uncommented (be sure to
    use the right protocol depending on the section you''re adding this line to):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''ll scroll down to the `GLOBAL DIRECTIVES` section of this same file.
    Just before that line, we''ll add a line as a "template" to name the incoming
    files and identify their locations. We can use several `"%"` delimited variables
    for this, with the most common being as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16336_12_Table_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In our configuration, we''ll use the host IP for a filename and then break
    logs out by date:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Check the file syntax with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Other variable names that can be used to template the syslog file include the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16336_12_Table_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, save the file and restart the `rsyslog` service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now, all we have to do is configure all of our various servers and devices to
    forward logs to this server, right?
  prefs: []
  type: TYPE_NORMAL
- en: 'Sort of – what that gets us is a really expensive (in terms of disk space)
    pile of logs. What we actually want is some method of getting some real-time alerts
    out of these logs. We''ll do this by using a process called `tail` command, which
    will echo lines as they are added to a text file with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This echos the text but doesn''t get us any alerting. For that, we must install
    a package called `swatch` (for "syslog watch"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Once installed, we''ll make a config file to tell the tool what to look for.
    Referring back to our list of common alerts, something such as the `swatch.conf`
    file, shown here, might be a good start:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: There are a few things to note here – the text that we're looking for is in
    that `watchfor` clause. Note that in each case, the text being watched for is
    a "regular expression," or `regex`. The `regex` syntax is extremely flexible and
    can be both very simple (as shown previously) or so complex as to be difficult
    to understand. I've included a few regex references at the end of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In our example, the first regex ends in `/I`, which tells the `watchfor` command
    that this is a case-insensitive search. Note that this is fairly CPU-intensive,
    so if you know the case in the matched text, you are best off putting it in the
    regex correctly.
  prefs: []
  type: TYPE_NORMAL
- en: In the second clause, note that we have three different search terms, separated
    with the `|` character, which is a logical OR – so, in other words, "temperature
    OR fan OR water."
  prefs: []
  type: TYPE_NORMAL
- en: The last two examples are linked. The first one looks for failed logins and
    alerts you for each one. But then it has a `continue` command, telling swatch
    to proceed. The next clause matches for the same text, but with a threshold –
    if swatch sees five failed login attempts within 5 minutes, it identifies a possible
    password stuffing attack.
  prefs: []
  type: TYPE_NORMAL
- en: You can also have a matched log statement trigger a script using the `exec`
    command instead of `mail`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we''ll want to start the swatch process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This command brings up two points:'
  prefs: []
  type: TYPE_NORMAL
- en: We've already mentioned log sizes as a concern, and for that reason, the current
    path that we're storing logs in shouldn't be in the same partition as `/var/log`,
    which is sized for local logs only. It definitely shouldn't be in the same partition
    as the boot or any other system partition. Filling up a syslog partition will
    result in loss of logs, but can crash your server or prevent it from booting as
    well! We'll want our logs in a separate, dedicated partition, well sized to store
    what we need. Archived logs can be in that same partition or on a second one,
    dedicated to archived (and likely ZIP-compressed) logs only.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The current configuration that we have for `rsyslog` needs sudo permissions
    to see the logs. So, either we''ll need to modify the file and directory permissions,
    or we''ll need to run our `swatchdog` using sudo. Both come with some level of
    risk, but to facilitate using the logs for troubleshooting, let''s change the
    file permissions. This can be done in the `/etc/rsyslog.conf` file by modifying
    these lines:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In most cases, you can change the `FileGroup` command to a different group and
    put your various admin folks into that group, as well as whatever account you
    run your "swatch" setup from.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, you might change the File and Dir `CreateMode` lines, maybe all
    the way to include "everyone" with `0777`. Since log entries always contain sensitive
    information, I wouldn't recommend this – speaking as a penetration tester, it's
    fairly common to find passwords in log files – it's surprising how often folks
    type their password in the `userid` field, then try again with the right information!
  prefs: []
  type: TYPE_NORMAL
- en: You can still use the date in the directory name, but often, it's easier to
    keep a consistent set of file and directory names for the live file. This makes
    it easier for log monitoring tools and people troubleshooting issues to find "today."
    Using the date values in your archiving scripts means that historic log files
    will either be in a "dated" directory or have a "dated" ZIP filename.
  prefs: []
  type: TYPE_NORMAL
- en: 'That being said, our revised swatch command will look similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Note that we added `–d` to the command – once everything has been debugged and
    working correctly, you'll want this parameter to run the command in the background
    (as a daemon).
  prefs: []
  type: TYPE_NORMAL
- en: There is likely more that you will need to do to get swatch working in production
    – for instance, getting those permissions "just so" for your environment, going
    through your network inventory, and ensuring that you have central logging for
    all of your gear, getting that log partition sized, and getting your log rotation
    working. What we've covered should be enough to get you on your way, though; much
    of this other work will be specific to your environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'With our organization''s logs covered, other questions now arise: how do our
    events stack up against other organizations? Do we see the same attacks as others,
    or maybe we''re a target for specific things? How can we get this information?
    We''ll look at this in the next section.'
  prefs: []
  type: TYPE_NORMAL
- en: The Dshield project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Dshield project is maintained by the folks at the Internet Storm Center
    ([https://isc.sans.edu](https://isc.sans.edu)) and allows participants to forward
    their (anonymized) logs to a central repository where they are aggregated to provide
    a good picture of "what's happening on the internet."
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, the information that is forwarded is the connection attempts
    that are blocked by your firewall. There is also a dedicated Dshield sensor that
    can be used if you don''t want to use your actual firewall logs. Instructions
    for participation can be found here: [https://isc.sans.edu/howto.html](https://isc.sans.edu/howto.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'This aggregated data gives us a view of what ports malicious actors are looking
    for, intending to exploit them. The participant''s addresses are the information
    that is anonymized. The various high-level reports can be viewed here: [https://isc.sans.edu/reports.html](https://isc.sans.edu/reports.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In particular, you can drill down into any of the "top 10 ports" on that page
    to see activity over time on the most popular ports being scanned for. For instance,
    you can go to [https://isc.sans.edu/port.html?port=2222](https://isc.sans.edu/port.html?port=2222),
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.1 – Dshield data for one port](img/B16336_12_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.1 – Dshield data for one port
  prefs: []
  type: TYPE_NORMAL
- en: From this pattern, you can see how to query any port if you have specific traffic
    you might be doing forensics on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Furthermore, this aggregated information can be queried by an API, if you''d
    rather consume this using a script or application. The Dshield API is documented
    here: [https://isc.sans.edu/api/](https://isc.sans.edu/api/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, to collect the summary information for port `2222`, we can use
    `curl` (just as an example):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Because the data is returned in XML in this example, you can consume it using
    standard libraries or language components. You can also change the returned formatting
    to JSON, text, or PHP. In some cases, the data lends itself toward comma- or tab-delimited
    formats (CSV, tab).
  prefs: []
  type: TYPE_NORMAL
- en: To change formats, simply add `?format_type` to the query, where `format_type`
    can be JSON, text, PHP, or in some cases, CSV or tab.
  prefs: []
  type: TYPE_NORMAL
- en: Each user has their own web portal, which shows these same stats for their own
    device(s) – this data can be valuable in troubleshooting, or to contrast it against
    the aggregate data to see if your organization might be targeted by one attack
    or another. But the strength of this approach is in the aggregated data, which
    gives a good picture of the internet "weather" on any particular day, as well
    as overall "climate" trends.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've got local logging configured and our firewall logs aggregated
    for better internet traffic analysis, let's consider other network management
    protocols and approaches, starting with the **Simple Network Management Protocol**
    (**SNMP**) management/performance and uptime.
  prefs: []
  type: TYPE_NORMAL
- en: Network device management using SNMP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At its heart, SNMP is a way to collect information from target network devices.
    Most often, this is done by a server-based application, but you can certainly
    query SNMP from the command line There are several versions of SNMP, with two
    of them in common use today.
  prefs: []
  type: TYPE_NORMAL
- en: SNMPv2c (version 2c) is a slight improvement over the initial v1 protocol, but
    is still an "old-school" approach to data collection – both the SNMP queries and
    responses are transferred in clear text over UDP. It is secured using a passphrase
    (called a *community string*), but this is also sent in clear text, so tools such
    as Ettercap can easily collect these – even the often-recommended "long and complex"
    strings do not protect you if your attacker can simply cut and paste them for
    reuse. In addition, the default community strings (public for read-only access
    and private for read-write access) are often left in place, so just querying using
    those can often yield good results for an attacker. It's often recommended that
    the access to SNMP be protected by an ACL at the target device. However, given
    how easy it is to perform ARP poisoning attacks, a well-positioned attacker can
    easily bypass these ACLs as well.
  prefs: []
  type: TYPE_NORMAL
- en: SNMPv3 is the most recent version of the protocol and adds a most welcome encryption
    feature. It also has a much more nuanced approach to access controls, as opposed
    to the "either read or read/write" access controls that SNMPv2c offers.
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned previously, SNMP (either version) can be used to "poll" a target
    device for information. In addition, that device can send an unsolicited SNMP
    "trap" to an SNMP server or log collector. SNMP polls use `161/udp`, and SNMP
    traps are sent to `162/udp` (though TCP can be configured).
  prefs: []
  type: TYPE_NORMAL
- en: With some of the background covered, let's make a few example queries.
  prefs: []
  type: TYPE_NORMAL
- en: Basic SNMP queries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before you can make command-line queries in Linux, you likely need to install
    the `snmp` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can make an example query. In our first example, I''m collecting the
    IOS version of a lab switch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'To collect the system uptime, in both seconds and in a human-readable timestamp,
    use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'What about the stats for an interface? Let''s start with the name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can get packets in and out (unicast):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: You get the idea – there's an OID for just about every common parameter. But
    how do we keep them all straight?
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, this is standardized in RFC 1213, with MIB-2 being the latest
    set of definitions that most vendors support as a "lowest common denominator"
    implementation. Secondly, the definition is hierarchal. This shows the "top" of
    the basic tree, with the OID for **mib-2** highlighted:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.2 – SNMP OID tree, showing mib-2](img/B16336_12_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.2 – SNMP OID tree, showing mib-2
  prefs: []
  type: TYPE_NORMAL
- en: 'When there are a group of interfaces, there''ll be a count, then a table for
    each interface statistic (by interface index). If you use `snmpwalk` instead of
    `snmpget`, you can collect the entire list, along with all the sub-parameters
    for each entry. This shows the beginning of the `ifTable` (Interface Table) part
    of mib-2:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.3 – SNMP OID tree, showing interface information (ifTable)](img/B16336_12_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.3 – SNMP OID tree, showing interface information (ifTable)
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, they maintain a list of the "starting points" of the OIDs that
    each vendor has their custom tree of items under. The top of the **private** branch
    of the OID tree is shown here. Note that toward the top of the tree, you will
    tend to find several organizations that may have either been acquired or are not
    commonly seen anymore in enterprise environments for one reason or another:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.4 – SNMP OID tree, showing the Vendor OID section](img/B16336_12_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.4 – SNMP OID tree, showing the Vendor OID section
  prefs: []
  type: TYPE_NORMAL
- en: This model all hangs together more or less nicely, with the various devices
    maintaining their various counters, waiting on a valid server to query for those
    values.
  prefs: []
  type: TYPE_NORMAL
- en: If you have a starting point, you can use the `snmpwalk` command to traverse
    the tree of OIDs from that point down (see the *SNMPv3* section for an example).
    Needless to say, this can turn into a messy business of "find me the number I
    really want," spread across hundreds of lines of text.
  prefs: []
  type: TYPE_NORMAL
- en: Also, as you can see, each "node" in the SNMP tree is named. If you have the
    appropriate definitions, you can query by name rather than OID. You likely already
    have the MIB-2 definitions installed on your Linux host, so you can import and
    manage vendor MIB definitions as well. An easy way to install or manage the various
    MIB definitions is to use the `snmp-mibs-downloader` package (install this using
    our familiar `apt-get install` approach).
  prefs: []
  type: TYPE_NORMAL
- en: 'To install a vendor''s MIBs, we can use Cisco (as an example). After installing
    `snmp-mibs-downloader`, edit the `/etc/snmp-mibs-downloader/snmp-mibs-downloader.conf`
    file and add the `cisco` designator to the `AUTOLOAD` line . This line should
    now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The definitions of where and how to collect the cisco MIBs are in `/etc/snmp-mibs-downloader/cisco.conf`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The individual MIB definitions are in `/etc/snmp-mibs-downloader/ciscolist`
    – as you can see, this file is too long to list here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you''ve updated the `snmp-mibs-downloader.conf` file, simply run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: You'll see each MIB file get downloaded (all 1,431 files).
  prefs: []
  type: TYPE_NORMAL
- en: 'With the MIB text descriptions now loaded (the defaults are loaded after installing
    `snmp-mibs-downloader`), you can now query SNMP using text descriptions – in this
    case, we''ll query the `sysDescr` (System Description) field of a lab switch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Even using the descriptive field names, this process gets very complicated very
    quickly – this is where a **Network Management System** (**NMS**) comes in. Most
    NMS systems have a point-and-click web interface, where you start with the IP
    and can drill down by interface or other statistics to get the information you
    want. It then presents that information graphically, usually over time. Most of
    the better NMSes will figure out what the device is and create all the graphs
    you'll typically want, without further prompting.
  prefs: []
  type: TYPE_NORMAL
- en: '**Where does this break down?**'
  prefs: []
  type: TYPE_NORMAL
- en: The clear-text nature of SNMPv2 is an ongoing problem – many organizations simply
    have not moved on to SNMPv3, with its more secure transport.
  prefs: []
  type: TYPE_NORMAL
- en: Even worse, many organizations have simply continued using the default SNMP
    community strings; that is, "public" and "private." In almost all cases, there
    is no need for read-write access to SNMP, but people configure it anyway. This
    situation is made worse by the fact that not only can you shut down interfaces
    or reboot a device if you have read/write access, but you can generally retrieve
    a full device configuration with that access – there's even a nmap script to retrieve
    a Cisco IOS running configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Operationally, if you query every interface and statistic on a device, you will
    often impact the CPU of that device. Historically, especially on switches, if
    you query every interface, you will (on one version or the other of the operating
    system) find memory leak bugs. These can be so bad that you can graph the memory
    utilization and see a straight line increase where these queries don't return
    a few bytes per query, eventually to the point where there isn't enough memory
    left for the device to run.
  prefs: []
  type: TYPE_NORMAL
- en: So, these were the obvious recommendations. Use SNMPv3, restrict SNMP access
    to known servers, and only query interfaces that you need. On firewalls and routers,
    this may include all interfaces, but on switches, you will often only query uplinks
    and interfaces for critical servers – hypervisors, in particular.
  prefs: []
  type: TYPE_NORMAL
- en: With some of the theory covered, let's build a popular Linux-based NMS – LibreNMS.
  prefs: []
  type: TYPE_NORMAL
- en: SNMP NMS deployment example – LibreNMS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: LibreNMS is an NMS that has been forked from the Nagios NMS (which is now a
    mostly commercial product) and is fairly full-featured for a free NMS application.
    More importantly, the learning curve to get your devices enrolled is pretty simple,
    and the installation can be simplified tremendously.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, the installation documentation for LibreNMS is very complete and
    covers all of the various database, website, and other dependent components. We
    won't cover those instructions here since they change from version to version;
    the best source is the vendor download page.
  prefs: []
  type: TYPE_NORMAL
- en: But rather than installing from scratch, often, it's much simpler to use any
    one of the pre-installed images and start from there. VMware and Hyper-V are both
    very widespread hypervisors and are the main compute platforms in many enterprises.
    For these, LibreNMS has a complete Ubuntu install in a pre-packaged **Open Virtualization
    Format** (**OVA**) file. In fact, as the name suggests, that file type is almost
    universally supported to deploy pre-built VM images.
  prefs: []
  type: TYPE_NORMAL
- en: For the examples in this chapter, you can download and import the OVA file for
    LibreNMS. The gear you have to query will be different than the examples, depending
    on what is in your environment, but the core concepts will remain the same. A
    great side effect of deploying an NMS is that, like logging and log alerting,
    you are likely to find problems you didn't know you had – everything from an overheating
    CPU to an interface operating at maximum or "too close to maximum" capacity.
  prefs: []
  type: TYPE_NORMAL
- en: Hypervisor specifics
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Be sure that the network you deploy your LibreNMS VM on has access to the devices
    that you will be monitoring.
  prefs: []
  type: TYPE_NORMAL
- en: In VMware, the default disk format for this VM is "thin provisioned." This means
    that the virtual disk will start by being just big enough to hold the files that
    it has on it, and will grow as the file storage needs more. This is fine for a
    lab/test VM, but in production, you will almost always want a "thick provisioned"
    disk – you don't want a server "growing" unexpectedly and maxing out your storage.
    This never ends well, especially if you have multiple servers thin-provisioned
    in the same datastore!
  prefs: []
  type: TYPE_NORMAL
- en: Once deployed, you'll need to log in using the `librenms` account – the password
    for this does change from version to version, so be sure to refer to the documentation
    for your download. Once logged in, note that this account has root privileges,
    so change the password for `librenms` using the `passwd` command.
  prefs: []
  type: TYPE_NORMAL
- en: Get your current IP address using the `ip address` command (see [*Chapter 2*](B16336_02_Final_NM_ePub.xhtml#_idTextAnchor035),
    *Basic Linux Network Configuration and Operations – Working with Local Interfaces*).
    Consider that this host will be monitoring critical devices using SNMP and that
    you will likely want to add an ACL to each of these devices to restrict access
    to SNMP – given that you will want to manually set your IP address, subnet mask,
    gateway, and DNS server to static values. You can do this using a static DHCP
    reservation or you can assign it statically on the server – choose whichever approach
    is your organization's standard.
  prefs: []
  type: TYPE_NORMAL
- en: Once this is done, browse to that address using HTTP, not HTTPS. Given the sensitivity
    of the information on this server, I'd recommend installing a certificate and
    forcing the use of HTTPS, but we won't cover that in this chapter (the LibreNMS
    documentation does a great job of walking through this, though). The web login
    is also `librenms`, but the default password for this will be different; consult
    the documentation for your download for this as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should now have an **Edit Dashboard** splash screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.5 – LibreNMS Edit Dashboard startup screen](img/B16336_12_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.5 – LibreNMS Edit Dashboard startup screen
  prefs: []
  type: TYPE_NORMAL
- en: 'Before you go any further, click on the `librenms` account icon in the upper
    right of your screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.6 – LibreNMS "Account" and "System" icons](img/B16336_12_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.6 – LibreNMS "Account" and "System" icons
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, update the password for the web account as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.7 – Changing default passwords in LibreNMS](img/B16336_12_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.7 – Changing default passwords in LibreNMS
  prefs: []
  type: TYPE_NORMAL
- en: With the server up and running, let's take a look at adding some devices to
    manage.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a basic SNMPv2 device
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To add the most basic of devices, you''ll want to go to that device. You''ll
    want to enable SNMP (version 2, in this case), and then add a community string
    and hopefully also an ACL to restrict access. On a typical Cisco switch, for instance,
    this would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: That's it! Note that we used `ROSNMP` for the SNMP Community string – that's
    much too simple for a production environment. Also, note that the `RO` parameter
    ensures that this is string allows only read-only permissions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, back in LibreNMS, from the main dashboard, choose **Devices** > **Add
    Device**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.8 – Adding a device to LibreNMS](img/B16336_12_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.8 – Adding a device to LibreNMS
  prefs: []
  type: TYPE_NORMAL
- en: 'Fill in the IP address of your device, as well as the community string. Your
    screen should look something like this (with your own device''s IP address, of
    course):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.9 – Adding device details in LibreNMS](img/B16336_12_009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.9 – Adding device details in LibreNMS
  prefs: []
  type: TYPE_NORMAL
- en: Now, you can browse to the device you just added by selecting **Devices** >
    **All Devices** and then clicking your device.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that LibreNMS has already started graphing CPU and memory utilization,
    as well as traffic for both the overall device and each interface that is up.
    The default page for a network device (in this case, a firewall) is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.10 – Device statistics collected in LibreNMS](img/B16336_12_010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.10 – Device statistics collected in LibreNMS
  prefs: []
  type: TYPE_NORMAL
- en: 'As you drill down into any particular clickable link or graph, further details
    on collected statistics will be shown. Often, even mousing over a link will flash
    up the details – in this case, by mousing over the `vmx0` link, details about
    that specific interface are shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.11 – Mousing over an interface for interface details in LibreNMS](img/B16336_12_011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.11 – Mousing over an interface for interface details in LibreNMS
  prefs: []
  type: TYPE_NORMAL
- en: We've already talked about how deploying SNMPv2 is risky, due to its clear-text
    nature and simple authentication. Let's look at fixing that by using SNMPv3 instead.
  prefs: []
  type: TYPE_NORMAL
- en: SNMPv3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'SNMP version 3 is not much more complex to configure. In most cases, we take
    the default "read-only" SNMP views and just add a passphrase to use for authentication
    and an encryption key. On the device side, this is an example Cisco IOS configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The key parameters are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16336_12_Table_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can test this with the `snmpwalk` or `snmpget` commands. For instance, the
    `snmpwalk` command pulls the system description values (note that we''ll need
    the calling station''s IP in the ACL-SNMP access list):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'On the NMS side, it''s as simple as matching the various configuration passwords
    and parameters that we used on the device:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.12 – Adding a device to the LibreNMS inventory using SNMPv3](img/B16336_12_012.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.12 – Adding a device to the LibreNMS inventory using SNMPv3
  prefs: []
  type: TYPE_NORMAL
- en: After enrollment, we can fix the device's name by editing the device, then changing
    the device's name to something that's more easily remembered, and adding an IP
    overwrite (which the NMS will use for access). Of course, if the device has a
    DNS name, then enrolling it using its FQDN would work too. Relying on DNS can
    become a problem though if you need the NMS for troubleshooting when DNS might
    not be available – in fact, you might be troubleshooting DNS!
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.13 – Changing the device''s name and adding an "Overwrite IP" in
    LibreNMS](img/B16336_12_013.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.13 – Changing the device's name and adding an "Overwrite IP" in LibreNMS
  prefs: []
  type: TYPE_NORMAL
- en: Note that even though we have added true authentication (using a hashed password
    in transit) and authorization to the mix (by adding authorizing to the access
    level), as well as encryption of the actual data, we're still adding a plain old
    access list to protect the SNMP service on the router. The mantra of "Defense
    in Depth" has us thinking that it's always best to assume that one or more protection
    layers might be compromised at some point, so adding more defensive layers to
    any target service will protect it that much better.
  prefs: []
  type: TYPE_NORMAL
- en: We can expand SNMPv3 usage by using it to send SNMP trap messages, which are
    encrypted, to replace plain-text syslog logging. This complicates our log services
    somewhat, but is well worth it!
  prefs: []
  type: TYPE_NORMAL
- en: Additional security configurations are available for SNMPv3; the CIS Benchmark
    for your platform is normally a good reference for this. The CIS Benchmark for
    Cisco IOS makes a good starting point if you just want to dig deeper, or if your
    router or switch doesn't have a Benchmark or good security guidance from the vendor.
  prefs: []
  type: TYPE_NORMAL
- en: Aside from the additional protection provided, the underlying SNMP capabilities
    remain almost the same between SNMP versions 2 and 3\. Once enrolled in the NMS,
    devices using SNMPv2 and SNMPv3 do not operate or appear different in the system
    in any significant way.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we're monitoring all of our various network-connected devices and servers
    using SNMP, can we use the polling engine of our NMS to add alerts to monitor
    for devices or services that go down?
  prefs: []
  type: TYPE_NORMAL
- en: Alerts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One of the main things you''ll want to do is add some alerts to go with your
    stats. For instance, if you go to **Alerts** > **Alert Rules** and click **Create
    rule from collection**, you''ll see this screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.14 – Default alert collection in LibreNMS'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16336_12_014.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.14 – Default alert collection in LibreNMS
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add an alert that will trigger on any interface at over 80% utilization.
    To see if there is something like this in the default collection, type `utili`
    into the *Search* field – as you type, the search will be narrowed down:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.15 – Adding an alert in LibreNMS'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16336_12_015.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.15 – Adding an alert in LibreNMS
  prefs: []
  type: TYPE_NORMAL
- en: 'Select the rule; we''ll get some options:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.16 – Alert rule options in LibreNMS'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16336_12_016.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.16 – Alert rule options in LibreNMS
  prefs: []
  type: TYPE_NORMAL
- en: Starting from the top, you should rename the rule. If you decide to import the
    default ruleset, you don't want to have things failing because you tried to have
    duplicate rule names. Often, I'll name custom rules so that they start with an
    underscore character; this ensures that they are always at the top of the rule
    list when sorted. Since we're taking a copy of what's in the collection, we can
    easily also change the percentage that triggers the alert.
  prefs: []
  type: TYPE_NORMAL
- en: 'Regarding **Match devices, groups and locations list**, things get tricky.
    As it stands, there''s nothing in the match list, and **All devices except in
    the list** is set to **OFF**, so this rule won''t match anything. Let''s select
    our device:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.17 – Matching devices and groups within an alert rule in LibreNMS'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16336_12_017.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.17 – Matching devices and groups within an alert rule in LibreNMS
  prefs: []
  type: TYPE_NORMAL
- en: Now, save the rule. Yes, it is that easy!
  prefs: []
  type: TYPE_NORMAL
- en: Did you happen to notice the **Groups** pick in the preceding menu? Using device
    groups is a great way to assign one rule to all similar devices – for instance,
    you might have a different port threshold for a router or a switch port. The reason
    for this is that increasing a router's WAN link speed might take weeks, as opposed
    to changing a switch port, which might involve just moving the cable from a 1G
    port to a 10G port (for instance). So, in that case, it makes good sense to have
    one rule for all routers (maybe at 60%) and a different rule for all switches
    (set at some higher number).
  prefs: []
  type: TYPE_NORMAL
- en: 'Explore the rules – you''ll see many that you likely want to enable – alerts
    for device or service down, CPU, memory or interface utilization, and temperature
    or fan alerts. Some of these alerts depend on syslog – and yes, LibreNMS does
    have a syslog server built into it. You can explore this at **Overview** > **Syslog**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.18 – Syslog display in LibreNMS'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16336_12_018.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.18 – Syslog display in LibreNMS
  prefs: []
  type: TYPE_NORMAL
- en: Note that there is some simple searching available to you, but it is pretty
    simple. This syslog server is a good thing to use so that the alerts can monitor
    it – this will be much simpler than the alerting we set up earlier in this chapter.
    However, you'll still want to keep those text logs we set up, both for better
    searching and for longer-term storage.
  prefs: []
  type: TYPE_NORMAL
- en: As we add devices to our NMS, or for that matter as we deploy devices and name
    them, there are some things we should keep in mind.
  prefs: []
  type: TYPE_NORMAL
- en: Some things to keep in mind as you add devices
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you add devices and groups, be sure to name them, especially the devices,
    so that they sort logically. Naming conventions will often use the device's type
    (FW, SW, or RT, for instance) a standard for location name (branch number, for
    instance), or a short form of the city name – (CHI, TOR, and NYC for Chicago,
    Toronto, and New York City, for instance). The important things are consistency,
    planning out how things will sort, and keeping the various terms in the name short
    – remember, you'll be typing these things, and they'll also end up in spreadsheet
    columns eventually.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we've focused on using SNMP to monitor statistics. Now, let's monitor
    a running service on a device.
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring services
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Keep in mind that services on hosts are key things to monitor. It's common to
    monitor ports for database access, APIs, and web and VPN services using a nmap-like
    function in the NMS. A more advanced monitor will poll a service and ensure that
    the data coming back from the poll is correct.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we can monitor for services, we''ll need to enable service checks. SSH
    to your LibreNMS host and edit the `/opt/librenms/config.php` file. Add the following
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'You may also wish to uncomment some or all of these `$config` lines (so that
    you can scan subnets rather than add devices one at a time):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we''ll update the cron scheduler for the application by adding the following
    line to the `/etc/cron.d/librenms` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, not all the plugins are installed – in fact, in my install, none
    were. Install them like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we should be able to add a service. Choose `22`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.19 – Monitoring a basic service in LibreNMS'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16336_12_019.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.19 – Monitoring a basic service in LibreNMS
  prefs: []
  type: TYPE_NORMAL
- en: 'You can expand on this – did you notice how many service checks there were
    in the list when you added the first service? Let''s add a monitor for an HTTP
    service. In this case, we''ll watch it on our firewall. This is a handy check
    for watching an SSL VPN service as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.20 – Monitoring an HTTPS service in LibreNMS using parameters'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16336_12_020.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.20 – Monitoring an HTTPS service in LibreNMS using parameters
  prefs: []
  type: TYPE_NORMAL
- en: Note that the parameters here are important. `-S` indicates that the check should
    use SSL (or more specifically, TLS). `–p 443` indicates the port to poll.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, when we navigate to the **Services** page, we''ll see the two services
    we just added. You may need to give it a few minutes for LibreNMS to get around
    to polling both of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.21 – Services display in LibreNMS'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16336_12_021.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.21 – Services display in LibreNMS
  prefs: []
  type: TYPE_NORMAL
- en: 'The full list of available plugins can be seen directly from the dropdown on
    the **Service configuration** page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.22 – Service checks available in LibreNMS'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16336_12_022.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.22 – Service checks available in LibreNMS
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the commonly used checks include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B16336_12_Table_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The documentation for all the parameters for each of these checks is located
    at [https://www.monitoring-plugins.org/doc/man/index.html](https://www.monitoring-plugins.org/doc/man/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: That about covers the basic operation of the LibreNMS system. Now, let's move
    on to collecting and analyzing traffic. We won't be using packet captures, but
    rather aggregating the high-level traffic information into "flows" using the family
    of NetFlow protocols.
  prefs: []
  type: TYPE_NORMAL
- en: Collecting NetFlow data on Linux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What do you do when looking at interface throughput isn't enough? Quite often,
    those SNMP throughput graphs will tell you that you have a problem, but won't
    take you to that next step – what protocol or which people are eating up all that
    bandwidth? Is this something I can fix with configuration, or do I need to work
    on policies to help control the video habits of the people in my organization,
    or do I truly need more bandwidth?
  prefs: []
  type: TYPE_NORMAL
- en: How can we get this information? It's not as easy as SNMP, but NetFlow collects
    all the information you might need to help be a "bandwidth detective." Let's discuss
    how this works, and what protocols are involved.
  prefs: []
  type: TYPE_NORMAL
- en: What is NetFlow and its "cousins" SFLOW, J-Flow, and IPFIX?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you recall back in [*Chapter 3*](B16336_03_Final_NM_ePub.xhtml#_idTextAnchor053),
    *Using Linux and Linux Tools for Network Diagnostics*, and again in [*Chapter
    11*](B16336_11_Final_NM_ePub.xhtml#_idTextAnchor192), *Packet Capture and Analysis
    in Linux*, where we discussed packet "tuples," this is where we use that concept
    for just about everything. NetFlow is a service that collects traffic from an
    identified interface, usually on a router, switch, or firewall, and summarizes
    it. The information that it collects to summarize almost always includes the core
    tuple values that we discussed earlier in this book:'
  prefs: []
  type: TYPE_NORMAL
- en: Source IP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Destination IP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Protocol (TCP, UDP, ICMP, or whatever other protocol)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Source port
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Destination port
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'However, as we''ll see later, modern NetFlow configurations can expand on the
    standard tuple values by adding the following:'
  prefs: []
  type: TYPE_NORMAL
- en: QOS information (TOS or DSCP bits)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: BGP **Autonomous System** (**AS**) numbers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TCP Flags (SYN, ACK, and so on)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The TCP flags are critical, as the first packet (which has just a SYN flag set)
    defines which host is the client and which is the server in any conversation.
  prefs: []
  type: TYPE_NORMAL
- en: 'NetFlow was originally developed by Cisco but was developed under the RFC process
    to allow more widespread adoption in the industry, and many vendors other than
    Cisco support NetFlow. There are two commonly seen versions of NetFlow – 5 and
    9 – with the main difference being the number of fields that are supported. There
    are a few "cousin" protocols that are frequently seen:'
  prefs: []
  type: TYPE_NORMAL
- en: '**sFlow** was developed by InMon as an open standard, and also has a supporting
    RFC. It''s common to see networking gear that supports both NetFlow and sFlow.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**IPFIX** (**IP Flow Information eXport**) is yet another open standard, which
    is built on and is (more or less) a superset of NetFlow v9.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**J-Flow** is the NetFlow equivalent of Juniper gear, though in its most recent
    version (J-Flow v9), it appears identical to IPFIX and is documented that way
    in Juniper''s device-specific documentation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No matter what protocol you are using to export flow information, the systems
    that receive this information will usually ingest any or all of them. The export
    is usually on a UDP port. While in some cases the port will be defined in the
    specification, it can always be changed, and will often vary from one vendor to
    the next. NetFlow, for instance, is often seen on ports `2055`, `2056`, `4432`,
    `9995`, or `9996`. sFlow is officially defined to be on port `6343`, but is often
    deployed on other ports. IPFIX is not widely seen yet (other than as J-Flow v9)
    but is specified to be on `4739`.
  prefs: []
  type: TYPE_NORMAL
- en: 'While there are minor differences (sFlow, in particular, has some differences
    in how the data is collected and summarized), the result is the same. After being
    summarized, the data is sent to a backend server, where it is queryable. In these
    data repositories, network administrators look for the same things as police detectives:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Who** sent the data, and to **Where**? (source and destination IP)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**What** was the data (source and, in particular, the destination port)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**When** was it sent?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Why** is often extrapolated by defining the application that was used to
    send the data – Cisco''s **Network-Based Application Recognition** (**NBAR**)
    add-on can be helpful in this, or you can often infer the application just from
    the destination port (on the server side of the flow).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**How** much data was sent in each time interval.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's dig a bit deeper into how collecting, aggregating, and sending flow data
    works, and how that might affect your design and implementation within your organization's
    network.
  prefs: []
  type: TYPE_NORMAL
- en: Flow collection implementation concepts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A key concept in all of these flow collection protocols is sampling. All of
    these protocols have a "sample x packets for every y packet" property in their
    configuration, with various vendors and platforms having different default values.
    Newer routers, for instance, will often default to a 100% sampling rate as they're
    usually lower bandwidth platforms (often under 100 Mbps) and have the CPU to back
    up that collection rate. This rate is often not practical on 1G, 10G, or faster
    switches – sampling at a reasonable rate becomes critical in those cases.
  prefs: []
  type: TYPE_NORMAL
- en: Picking interfaces is also key in terms of the implementation. As in SNMP, collecting
    flow information on all ports of a large switch will likely severely affect the
    switch's CPU (and its overall throughput). Your mileage may vary on this, though,
    as higher-end switches will offload telemetry functions to dedicated silicon to
    use the main chassis CPU that much less.
  prefs: []
  type: TYPE_NORMAL
- en: Picking the collection topology is also important. For instance, in a data center/head
    office/branch office scenario, if the majority of the traffic is "hub and spoke"
    (that is, branch to branch communication is minimal), you will likely only collect
    flow data at the central location and put your flow collector in that same central
    location. In this scenario, the branch traffic would simply be the inverse of
    the head office traffic, so sending that a second time, over a WAN that presumably
    costs you money for bandwidth, is usually not wise.
  prefs: []
  type: TYPE_NORMAL
- en: The exception to this is **Voice over IP** (**VoIP**). If you recall from [*Chapter
    11*](B16336_11_Final_NM_ePub.xhtml#_idTextAnchor192), *Packet Capture and Analysis
    in Linux*, call setup uses the SIP protocol and is between the phone handset and
    the PBX. The call itself though uses RTP and is directly from one handset to the
    other. If there's a significant amount of branch-to-branch VoIP communication,
    you may choose to monitor the WAN interfaces of your branch routers as well.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, keep in mind that while this data is sampled and aggregated, eventually,
    it will get to the server and have to be stored on disk, where it tends to add
    up pretty quickly. You may find that as you "find your way" regarding how much
    information you need to keep to create meaningful reports, you might have to increase
    your partition or database sizes fairly frequently (always up, unfortunately).
  prefs: []
  type: TYPE_NORMAL
- en: In a similar vein, as your data volume grows, so will the demands on memory
    and CPU. You may find that you benefit from adding indexes here or there in your
    database to speed up reporting or the web interface itself. Adding indexes will
    unfortunately usually cost you additional disk and often memory requirements,
    so keep that in mind as well. As your dig deeper into this see-saw set of requirements,
    you'll find that your database administration skills will grow over time, and
    may end up helping you optimize other database-centric applications.
  prefs: []
  type: TYPE_NORMAL
- en: There will always be a temptation to combine syslog, SNMP, and flow collection
    on one single network management server. While combining syslog and SNMP is a
    common thing, if the NMS uses a database for log information, you'll likely want
    a separate, text-based log repository – if only to keep your long-term log storage
    process simple. Regarding flow collection, you'll almost always put this on a
    separate server. You might get away with an "all-in-one" approach in a smaller
    environment, but even many small environments will find that the resources for
    flow collection far outweigh the other two functions. In addition, the dependence
    on the backend database and the high rates of inbound data means this can make
    your flow collection server abnormally "fragile" – you may find that you'll need
    to rebuild this server once or twice per year to fix "unexplainable" problems.
    Also, because of this, you'll find that it's fairly common to see organizations
    switch to a different application or database platform when this happens (unless
    there are commercial licenses involved), only because by then, they'll know what
    they don't like about the previous build, and since there's a rebuild, it's a
    low barrier to test that next solution.
  prefs: []
  type: TYPE_NORMAL
- en: With all this basic flow information covered, let's build a NetFlow solution
    for real, starting with a typical router.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring a router or switch for flow collection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we''ll define what we want to collect. To start with, we want our standard
    tuple information – source and destination IP, protocol, and port information.
    We''ll also add QoS information (the `ipv4 tos` line), as well as direction and
    routing information if possible (the `as` information is BGP Autonomous System
    information). We also have `application name` in this definition. This is mainly
    used if you are also running Cisco''s NBAR add-on. NBAR is set on the interface
    (you''ll see this on the next page) and helps identify applications by name from
    its constituent network traffic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''ll define the flow exporter. This tells the system where to send
    the flow information, and from which interface. The flow source is important because
    if that should change, it will look like another device on the NetFlow server.
    Also, note that we''ve defined an interface table in this section, which will
    send enough interface information to help in defining the host and interface characteristics
    on the server. Note that the flow destination port is almost always UDP, but the
    port number is not standardized. Vendors often have their own default value, and
    in all the implementations I''ve seen, that port number is configurable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in the definition, the flow monitor ties the exporter and flow
    records together so that it can all be applied as one "thing" to the interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: On the interface, you'll see that we've defined a flow monitor that's both inbound
    and outbound. Note that you can define multiple recorders and monitors. Normally,
    there is only one flow exporter (as there is usually only one flow destination
    for any given device).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `bandwidth` statement is often used to help define router metrics in the
    OSPF or EIGRP routing protocols, for instance. In the case of flow collection,
    though, defining a bandwidth will usually auto-configure the total bandwidth per
    interface for the various flow graphs. Defining the total bandwidth per physical
    interface is key so that each graph has an accurate upper bound, and will then
    show accurate percentages for both aggregate and specific tuple statistics:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Layer 2 flow collection – on an individual switch port, for instance – is usually
    much simpler. For instance, on an HP switch, collecting sFlow data on one switch
    port might look something like the following example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the port number is `6343`. In contrast to NetFlow, sFlow has `6343/udp`
    assigned as its default port. It is, of course, configurable for other values
    on both the client and server side:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Note the sampling rate and polling intervals that are defined. Also, note that
    since you are collecting flow data at Layer 2 in this instance, your tuple might
    be limited, depending on your switch model. This also helps explain why the configuration
    is so much simpler – unless the switch deconstructs the sampled frames to get
    the L3/L4 information of each packet, there's less information to collect.
  prefs: []
  type: TYPE_NORMAL
- en: With the router configuration built, let's move on and build and configure the
    server side of this equation.
  prefs: []
  type: TYPE_NORMAL
- en: An example NetFlow server using NFDump and NFSen
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: NFDump and **NetFlow Sensor** (**NFSen**) make for a nice entry level to the
    world of flow collection. Of particular interest is that NFDump uses its own file
    format, and that the command-line tools are very similar in terms of operation
    to tcpdump (which we covered in [*Chapter 11*](B16336_11_Final_NM_ePub.xhtml#_idTextAnchor192),
    *Packet Capture and Analysis in Linux*). So, if you enjoyed our filtering discussions
    and examples in that chapter, using the NFDump tools for "top n" type statistics
    and reports will be right up your alley!
  prefs: []
  type: TYPE_NORMAL
- en: NFCapd is a flow collector application. We'll run it in the foreground and also
    in the background.
  prefs: []
  type: TYPE_NORMAL
- en: NFSen is a simple web frontend to NFDump.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll run this on a standalone Linux host; you can use the Ubuntu VM or physical
    host that we''ve been using throughout this book. Let''s start by installing the
    `nfdump` package (which gets us several NetFlow-related commands):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, edit the `/etc/nfdump/.default.conf` file and change the `options` line
    at the top:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'This puts the data where our NFSen server will expect it to be later. The `-S`
    parameter tells the NFCapd process (which we''ll run as a daemon) to append a
    datestamp to the path. So, for June 23, 2021, all of our captured NetFlow data
    will be in the directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: As you'd expect, this data will tend to accumulate quickly, which can be risky
    as `/var` is also where logs and other vital system data is stored. In production,
    I'd recommend that you have a separate partition for this, and have the root of
    the path be something different, maybe `/netflow`. This way, if your NetFlow volume
    fills up, other system services won't be directly affected.
  prefs: []
  type: TYPE_NORMAL
- en: The `–p` parameter defines the port that our `nfcapd` process will listen on
    – the default of `2055` should work well in most situations, but change it as
    required.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can start directing NetFlow traffic to this collector IP using port
    `2055/udp`. After a few minutes, we can look at the NetFlow data using `nfdump`.
    The data files are collected in `/var/cache/nfdump/live/source1/` (follow the
    tree to today's date from there).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the first few lines of one file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that each line wraps. Let''s just look at the tuple information and the
    amount of data that was moved for each sample interval. We''ll take out the column
    headers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have what''s starting to look like information! Let''s aggregate the
    traffic in both directions by adding `-b`. We''ll also read from all the files
    available in the directory. The columns are now `Protocol`, `Src IP:Port`, `Dst
    IP:Port`, `Out Pkt`, `In Pkt`, `Out Byte`, `In Byte`, and `Flows`. Note that in
    some cases, we have an active flow for that time period, but no data in or out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look at the traffic from just one IP address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The data is wrapped, but you can see how this is becoming more and more useful.
    It's not a full packet capture, but on many days, it's all the packet capture
    information you might need!
  prefs: []
  type: TYPE_NORMAL
- en: The `–s` (statistics) parameter is very useful as you can query on any possible
    NetFlow-collected information in the extended tuple. `-A` allows you to aggregate
    on that same extended information, while `–a` aggregates just on the basic 5-tuple.
    Note that you can't aggregate on the source or destination IP when you have `–b`
    set (because `–b` already aggregates those two).
  prefs: []
  type: TYPE_NORMAL
- en: 'Usually, you need to collect information for a given time window; that is,
    when a problem or symptom has occurred. In those cases, `-t` (timewin) is your
    friend – let''s look between 21:31 and 21:32, still for just that IP address.
    Note again that you''ll want to modify this for your date and traffic patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: In one command line, we've summarized all the traffic that's comes in and goes
    out of one host for a 2-minute period!
  prefs: []
  type: TYPE_NORMAL
- en: With our basic functionality working, let's install the web interface for our
    collector. This is how NetFlow data is most often consumed – anomalies in protocol
    patterns are often very easy to see by eye.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following instructions are from [https://github.com/mbolli/nfsen-ng](https://github.com/mbolli/nfsen-ng)(`nfsen-ng`
    is the application being installed):'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s elevate our privileges to root – almost everything here requires
    those rights:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Install all the packages we''ll need:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Enable the Apache modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Install the `rrd` library for PHP:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Configure the RRD library and PHP:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Configure the virtual host so that it can read `.htaccess` files. Edit the
    `/etc/apache2/apache2.conf` file and edit the `Allow Override` line in the `/var/www`
    section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, restart the Apache server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we''re ready to install `nfsen-ng` and set the file/directory flags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Still working with root privileges, copy the default settings to the settings
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Edit the resulting `settings.php` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `nfdump` section, update the following lines to match:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Note that you can change this, especially if you plan to do log rotation by
    the date of your `nfdump` files, but that's not in our scope at the moment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s test our configuration (still as root):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: If this processes without error, your configuration will look good!
  prefs: []
  type: TYPE_NORMAL
- en: Now, point your various network devices to send their NetFlow results to this
    host's IP address, on port `2055/udp` (note that you can change this listening
    port by editing `/etc/nfdump/default.conf`).
  prefs: []
  type: TYPE_NORMAL
- en: Let's collect some data. You can verify that it's working by watching the file
    sizes in the target directory. An "empty" file is 276 bytes, but once you start
    receiving data, you should start seeing larger files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, browse to your server. Since we haven''t done anything fancy in apache,
    your URL will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's look at the graphical side of things. Browse to your server IP address
    – the URL should look something like [http://192.168.122.113/nfsen-ng/frontend/](http://192.168.122.113/nfsen-ng/frontend/).
    You can, of course, simplify this URL by configuring Apache to repoint to the
    home page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your display should now look something like this (your data values will differ):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.23 – Basic flow data in the graph display with display/filter controls
    in NFSen'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16336_12_023.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.23 – Basic flow data in the graph display with display/filter controls
    in NFSen
  prefs: []
  type: TYPE_NORMAL
- en: A good approach is to pick a reasonable time scale and then use the sliders
    to either grow or shrink the window as needed. In this case, we started with a
    24-hour graph, with a final display of 6-ish hours.
  prefs: []
  type: TYPE_NORMAL
- en: This display will often highlight times that might be of concern – you can "zoom"
    this graph in on those times for more details.
  prefs: []
  type: TYPE_NORMAL
- en: The next stop would be to the **Flows** button (in the top right of your display).
    A good set of selections here will be a reasonable starting window. Next, select
    the various aggregations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Normally, you will want protocol aggregation with a destination port aggregation.
    Next, you''ll often want the IP to be aggregated by both the source and destination
    IP. Adding in an NFDUMP filter for the exact time window is also often helpful.
    If you can limit your displays to be as short as possible – a few minutes, if
    possible – you will gain the most value from these displays:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.24 – Flow display controls for aggregation and filtering in NFSen'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16336_12_024.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.24 – Flow display controls for aggregation and filtering in NFSen
  prefs: []
  type: TYPE_NORMAL
- en: The final selections will be dictated by what you are trying to solve, and it
    may take a few tries to get the display you need for a final diagnosis.
  prefs: []
  type: TYPE_NORMAL
- en: 'When your selections are complete, pick **Process data** to get your results
    in the lower part of the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.25 – Filter results in NFSen'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16336_12_025.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.25 – Filter results in NFSen
  prefs: []
  type: TYPE_NORMAL
- en: You may wish to export this to CSV to manipulate your data further in a spreadsheet.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a real incident, what does this look like? Let''s open the default window,
    where we will notice a "spike" in traffic that might be suspicious. We might also
    get this timeframe from the helpdesk or desktop team, who might have forensic
    information, an IPS event (see [*Chapter 13*](B16336_13_Final_NM_ePub.xhtml#_idTextAnchor236),
    *Intrusion Prevention Systems on Linux*), or an event from the desktop protection
    application or anti-malware application. In this daily view, we can see a suspicious
    spike just before 2:30 P.M. Note that we used the sliders to zoom into the time
    window of interest. Also, note that we''re looking at either the "traffic" or
    "bytes" view – data exfiltration will often occur as one or two flows only, so
    those attacks will often stand out in the default display:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.26 – Unusual traffic "peak" discovered'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16336_12_026.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.26 – Unusual traffic "peak" discovered
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s change to the protocol display and poke around a bit. In this display,
    we''ve trimmed things down to only show UDP, and we can see something suspicious
    – this volume of UDP traffic isn''t normal for this organization:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.27 – Display adjustments in the protocol display, showing UDP only'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16336_12_027.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.27 – Display adjustments in the protocol display, showing UDP only
  prefs: []
  type: TYPE_NORMAL
- en: 'With that suspicious traffic spike at 14:20, let''s dig a bit deeper. Let''s
    add a nfdump filter to look at UDP, but pull out all the requests to the DNS forwarders
    that we have configured on the internal DNS server:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.28 – UDP search results – removing legitimate DNS traffic'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16336_12_028.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.28 – UDP search results – removing legitimate DNS traffic
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, digging deeper, let''s look at just that suspect IP address:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.29 – Filtering for a suspect IP address'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16336_12_029.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.29 – Filtering for a suspect IP address
  prefs: []
  type: TYPE_NORMAL
- en: 'This gives us the following result, showing the same transfer before and after
    NAT on the firewall, with no other traffic than this one large transfer of data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.30 – Suspect traffic before and after NAT on the firewall'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16336_12_030.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.30 – Suspect traffic before and after NAT on the firewall
  prefs: []
  type: TYPE_NORMAL
- en: Looking at the totals in the `53/udp`, which we know is normally used for DNS.
  prefs: []
  type: TYPE_NORMAL
- en: Using DNS, you can even exfiltrate data using valid queries – first, encode
    your data using base64, then make sequential "A" record queries of the resulting
    text in known "chunk" sizes. The receiving server then reassembles that data and
    decodes it to its original binary format. If there is concern about out-of-order
    packets, you can even encode a sequence number into the transfer.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've found that attack, how would we defend against this at a network
    level?
  prefs: []
  type: TYPE_NORMAL
- en: 'A good starting point would be a reasonable access list for outbound traffic,
    commonly called an egress filter. It would work something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: Permit `53/udp` and `tcp` from our DNS servers to their known forwarder IPs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deny all other `53/udp` and `tcp`, and log that traffic as an alert.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Permit `ssh`, `scp`, `ftp`, and other known traffic by protocol and ports to
    known target hosts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deny those protocols to all other hosts and log this as an alert.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Permit HTTP and HTTPS to any IP (but layer on another protection, perhaps reputation
    filtering or content controls).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deny all other traffic and log that traffic as an alert.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The key thing is that there will always be a "next attack" – but logging and
    alerting on attacks you know about will generally give you at least some warning
    at the beginning of an attack, often enough for you to act and prevent the attacker
    from succeeding in their final goals.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you have some familiarity with using NFDUMP and NFSEN combination.
    But what other open source NetFlow Collector applications are available to you?
  prefs: []
  type: TYPE_NORMAL
- en: Other open source NetFlow alternatives
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: nProbe is written by the fine folks who brought us ntop and is hosted at [https://www.ntop.org/products/netflow/nprobe/#](https://www.ntop.org/products/netflow/nprobe/#).
    This allows you to install a NetFlow collector on any host. The ntop tool ([https://www.ntop.org/products/traffic-analysis/ntop/](https://www.ntop.org/products/traffic-analysis/ntop/))
    is their collector, which gave us many of the benefits of NetFlow well before
    NetFlow was popular, but using a packet capture and analysis approach. It has
    since been expanded to include support for all versions of NetFlow and IPFIX.
    The most attractive factor in choosing ntop is that it's a single install with
    everything packaged in – most of the fiddly configuration is taken care of. It
    also breaks the data out with more detail on underlying applications, even on
    the initial graphical screens. On the downside, there is no command-line set of
    tools; it's an "all-in-one" application that presents a web/graphical interface.
    The ntop suite of tools is free to download. At this free level, it enjoys "community
    support" via forums and "best efforts" mailing lists.
  prefs: []
  type: TYPE_NORMAL
- en: '**System for Internet Level Knowledge** (**SILK**) is one of the oldest flow
    collection tools out there, but it still supports all of the newer protocols.
    It is developed by the Network Situational Awareness Group at CERT, with the documentation
    and downloads hosted here: [https://tools.netsa.cert.org/silk/](https://tools.netsa.cert.org/silk/).
    SILK is a free tool, with no commercial offering.'
  prefs: []
  type: TYPE_NORMAL
- en: Speaking of which, what about commercial products in this field?
  prefs: []
  type: TYPE_NORMAL
- en: Commercial offerings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Almost every vendor that has a commercial NMS will have a flow collection module
    to that NMS. However, as you dig into their documentation, almost all of them
    will only recommend that you deploy the flow collection on the same server as
    the SNMP and syslog functions. As we discussed earlier, as the volume of flow
    data grows and the length of data retention grows, the flow collection service
    will tend to overwhelm an already busy system. Also, given the database-intensive
    nature of most flow collection services, it's common to see people have to clear
    that data periodically as a "when all other troubleshooting fails" step in fixing
    a broken flow collection server. These factors tend to quickly see NetFlow or
    its related services moved to their own server and database in most organizations.
  prefs: []
  type: TYPE_NORMAL
- en: That being said, in commercial offerings, you'll often see more work on the
    "look and feel" of the application. For instance, when a device interface is added
    for NetFlow, the interface name will often be read from the interface's `description`
    value, and the maximum bandwidth for graphs will be initially set from either
    the interface's throughput value or the router's "bandwidth" metric (if set).
    Graphs will often include application names and workstation names, or even user
    IDs. Graphs will also drill down to the destination port values and data rates
    right from the start – since that's where you typically want to end up. Overall,
    most commercial products tend to be much easier to set up, both for the initial
    application and when adding devices.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, you should be aware of the huge volumes of useful data that can
    be collected from the logs of various systems, as well as how to use command-line
    tools to "mine" this data to find information that can help you solve specific
    problems as they arise. The use of log alerting should also be familiar ground,
    allowing you to proactively send alerts in the early stages of a problem.
  prefs: []
  type: TYPE_NORMAL
- en: Then, the Dshield project was introduced. We welcome your participation, but
    even if you don't contribute data, it can be a valuable resource for a quick "internet
    weather report," as well as trends that help define the "internet climate" as
    far as malicious traffic (by port and protocol) goes.
  prefs: []
  type: TYPE_NORMAL
- en: You should now be familiar with how SNMP works, as well as how to use an SNMP-based
    NMS to manage performance metrics on your network devices and even Linux or Windows
    servers. We used LibreNMS in our examples, but the approaches and even the implementation
    will be very similar on almost any NMS you might find yourself using.
  prefs: []
  type: TYPE_NORMAL
- en: At a more advanced level, you should be well acquainted with the NetFlow protocol,
    both configuring it on a network device and a Linux collector. In this chapter,
    we used NetFlow as a detective tool, performing high-level forensics on network
    traffic to find suspicious traffic and, eventually, a malicious data exfiltration
    event.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll explore **intrusion prevention systems** (**IPS**),
    which will build on the material from several chapters in this book to look for
    and often stop malicious network activity.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we conclude, here is a list of questions for you to test your knowledge
    regarding this chapter''s material. You will find the answers in the *Assessments*
    section of the *Appendix*:'
  prefs: []
  type: TYPE_NORMAL
- en: Why is it a bad idea to enable read-write community access for SNMP?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the risks of using Syslog?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: NetFlow is also a clear text protocol. What are the risks with that?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For more information regarding what was covered in this chapter, please take
    a look at the following resources:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Approaches to working with Syslog Data:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://isc.sans.edu/diary/Syslog+Skeet+Shooting+-+Targetting+Real+Problems+in+Event+Logs/19449](https://isc.sans.edu/diary/Syslog+Skeet+Shooting+-+Targetting+Real+Problems+in+Event+Logs/19449)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://isc.sans.edu/forums/diary/Finding+the+Clowns+on+the+Syslog+Carousel/18373/](https://isc.sans.edu/forums/diary/Finding+the+Clowns+on+the+Syslog+Carousel/18373/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Swatch Man Pages:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://manpages.ubuntu.com/manpages/bionic/man1/swatchdog.1p.html](http://manpages.ubuntu.com/manpages/bionic/man1/swatchdog.1p.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://linux.die.net/man/1/swatch](https://linux.die.net/man/1/swatch)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Swatch Home Pages:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/ToddAtkins/swatchdog](https://github.com/ToddAtkins/swatchdog)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://sourceforge.net/projects/swatch/](https://sourceforge.net/projects/swatch/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Various Regular Expressions Cheat Sheets:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.rexegg.com/regex-quickstart.html](https://www.rexegg.com/regex-quickstart.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Cheatsheet](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Cheatsheet)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.sans.org/security-resources/posters/dfir/hex-regex-forensics-cheat-sheet-345](https://www.sans.org/security-resources/posters/dfir/hex-regex-forensics-cheat-sheet-345)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Online Regex "builders":'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://regexr.com/](https://regexr.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: https://gchq.github.io/CyberChef/#recipe=Regular_expression('User%20defined','',true,true,false,false,false,false,'Highlight%20matches')&input=Ig
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Egress Filters: [https://isc.sans.edu/forums/diary/Egress+Filtering+What+do+we+have+a+bird+problem/18379/](https://isc.sans.edu/forums/diary/Egress+Filtering+What+do+we+have+a+bird+problem/18379/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Relevant RFCs:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Syslog**: [https://datatracker.ietf.org/doc/html/rfc5424](https://datatracker.ietf.org/doc/html/rfc5424)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SNMP**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://datatracker.ietf.org/doc/html/rfc3411](https://datatracker.ietf.org/doc/html/rfc3411)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[https://datatracker.ietf.org/doc/html/rfc3412](https://datatracker.ietf.org/doc/html/rfc3412)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[https://datatracker.ietf.org/doc/html/rfc3413](https://datatracker.ietf.org/doc/html/rfc3413)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[https://datatracker.ietf.org/doc/html/rfc3415](https://datatracker.ietf.org/doc/html/rfc3415)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[https://datatracker.ietf.org/doc/html/rfc3416](https://datatracker.ietf.org/doc/html/rfc3416)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[https://datatracker.ietf.org/doc/html/rfc3417](https://datatracker.ietf.org/doc/html/rfc3417)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[https://datatracker.ietf.org/doc/html/rfc3418](https://datatracker.ietf.org/doc/html/rfc3418)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**SNMP MIB II**: [https://datatracker.ietf.org/doc/html/rfc1213](https://datatracker.ietf.org/doc/html/rfc1213)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SNMPv3:**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://datatracker.ietf.org/doc/html/rfc3414](https://datatracker.ietf.org/doc/html/rfc3414)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[https://datatracker.ietf.org/doc/html/rfc6353](https://datatracker.ietf.org/doc/html/rfc6353)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**NetFlow**: [https://datatracker.ietf.org/doc/html/rfc3954.html](https://datatracker.ietf.org/doc/html/rfc3954.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**sFlow**: [https://datatracker.ietf.org/doc/html/rfc3176](https://datatracker.ietf.org/doc/html/rfc3176)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**IPFIX**: [https://datatracker.ietf.org/doc/html/rfc7011](https://datatracker.ietf.org/doc/html/rfc7011)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SNMP OIDs for various vendors**: Consult your vendor documentation; some
    of the OIDs that you''ll commonly see are listed here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Commonly used SNMP OIDs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Monitoring CPU on routers: `1.3.6.1.4.1.9.2.1.58.0`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Monitoring memory on routers: `1.3.6.1.4.1.9.9.48.1.1.1.6.1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`1.3.6.1.2.1.1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Interfaces: `1.3.6.1.2.1.2`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'IP: `1.3.6.1.2.1.4`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Memory: `1.3.6.1.2.1.4.1.9.9.48`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'CPU: `1.3.6.1.2.1.4.1.9.9.109`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Firewall: `1.3.6.1.2.1.4.1.9.9.147`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Buffers: `1.3.6.1.2.1.4.1.9.9.147.1.2.2.1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Connections: `1.3.6.1.2.1.4.1.9.9.147.1.2.2.2`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'SSL Stats: `1.3.6.1.4.1.3076.2.2.26`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'IPSec Stats: `1.3.6.1.2.1.4.1.9.9.171`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Remote Access Stats: `1.3.6.1.2.1.4.1.9.9.392`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'FIPS Stats: `1.3.6.1.2.1.4.1.9.9.999999`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Active connections in PIX/ASA firewall: `1.3.6.1.4.1.9.9.147.1.2.2.2.1.5.40.7`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The total number of currently active IPsec Phase-2 tunnels: `1.3.6.1.4.1.9.9.171.1.3.1.1.0`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You will need the following MIBs:'
  prefs: []
  type: TYPE_NORMAL
- en: IF-MIB, RFC1213-MIB, CISCO-MEMORY-POOLMIB, CISCO-PROCESS-MIB, ENTITY-MIB, CISCO-SMI,
    CISCO-FIREWALL-MIB. ASA also adds CISCO-IPSEC-FLOW-MONITOR-MIB, CISCO-FIPS-STAT-MIB,
    and ALTIGA-SSL-STATS-MIB.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Serial number for stackable switches: `1.3.6.1.2.1.47.1.1.1.1.11.1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'IOS version for stackable switches: `1.3.6.1.2.1.47.1.1.1.1.9.1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ARP cache on a router: `1.3.6.1.2.1.3.1.1.2`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Last state change of an interface: `1.3.6.1.2.1.2.2.1.9`.[interface number]'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
