- en: Persisting Data with MongoDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With almost any application written for the web nowadays, a highly interactive
    application is of limited value if the interaction between its users isn't permanently
    saved. You have to integrate your application with a proper database to solve
    this issue. Imagine a case where all of the data for your application (registered
    users, order transactions, and social interactions) was stored within the temporary
    memory of the server the application is running on. The moment that server was
    turned off or rebooted, all of your application data would be lost. Relying on
    a database to store this data permanently is crucial to any dynamic application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, the following topics will be covered:'
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to MongoDB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An introduction to Mongoose
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Schemas and models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding CRUD to our controllers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the previous chapter, we wrote and accounted for the actual logic of our
    application. The next step in building our application is to connect it to a database
    so that our users' interactions and data can be permanently saved and retrieved.
    Technically, we can get around this by storing data in the memory, but the moment
    our web server restarts or crashes, all of that data will be lost. Without connecting
    our application to a database server to persist data, every input interacted by
    a visitor will be obsolete. Without some kind of database server to store our
    data, most of the websites we interact with on a daily basis wouldn't even exist.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a general breakdown of how our data is going to be persisted for every
    visitor interaction in our app:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/845592b3-7634-4f2f-a19c-6cb969bd0649.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Consider the preceding diagram, which reflects the typical life cycle of a
    web application request:'
  prefs: []
  type: TYPE_NORMAL
- en: A visitor submits a request to view a page on our application via their web
    browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Node.js server receives this request and queries a MongoDB server for any
    data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The MongoDB server returns the queried data back to our Node.js server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Node.js server takes that data, builds it into the view model, and then
    sends the rendered HTML page back to the browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The web browser receives the response from our Node.js server and renders the
    HTML.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This cycle typically repeats for every interaction by every visitor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For the purposes of this book, we are using MongoDB as our primary data store,
    but the reality is that we can use any of the following to store data: MySQL,
    PostgreSQL, MS SQL, the filesystem, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: Using MongoDB with Node.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we officially implement MongoDB into our actual application, let's first
    take a look at some basic examples of connecting to a MongoDB server from within
    Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new project folder to store some sample code to experiment with. I'll
    call my folder `mongotest`. Inside this folder, create a new file called `test.js`.
    In this file, we will play around with some code to test how to connect to MongoDB
    and how to insert and retrieve some data. The first thing we need to do in order
    to connect to a MongoDB server from Node.js is to require a `mongodb` module.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started, change directories into the new `mongotest` folder and install
    the `mongodb` module using `npm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Don't be confused by the module's name. The `mongodb` npm module isn't MongoDB
    itself, but rather a third-party npm module that facilitates communicating to
    a MongoDB server from within Node.js. Also, because this is just a sample project
    to experiment with, we don't require the `--save` flag with `npm install`, since
    we aren't maintaining a `package.json` file.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to MongoDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that the `mongodb` module is installed, we can use it in our experimentation
    file. Boot up your editor and create a file named `test.js`. Insert the following
    block of code into it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Executing the preceding code should log Connected to MongoDB! to your screen.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing you'll notice is that we require the `mongodb` module, but we
    specifically use the `MongoClient` component of the module. This component is
    the actual interface we use to actively open a connection to a MongoDB server.
    Using `MongoClient`, we pass the `mongodb://localhost:27017/mongotest` string
    URL to our local server as the first parameter. Notice that the path in the URL
    points to the server and then the name of the database itself.
  prefs: []
  type: TYPE_NORMAL
- en: Remember to make sure you have your local MongoDB server instance running in
    another terminal for the duration of this chapter. To do so, open a command-line
    terminal window and execute `$ mongod`. Your server should launch and log information
    to the screen, ending with `[initandlisten] waiting for connections on port 27017`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might find that when you run your application, you receive a stack trace
    error with something like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`events.js:72`'
  prefs: []
  type: TYPE_NORMAL
- en: '`thrower; // Unhandled ''error'' event`'
  prefs: []
  type: TYPE_NORMAL
- en: '`^Error: failed to connect to [localhost:27017]`If this happens, you should
    realize that it failed to connect to the `localhost` on port `27017`, which is
    the port that our local `mongod` server runs under.'
  prefs: []
  type: TYPE_NORMAL
- en: Once we have an active connection to our database server, it's as if we are
    running the Mongo shell command. The MongoClient callback function returns a database
    connection object (that we named `db` in our code, but could have named anything),
    which is exactly the same object we work with in the Mongo shell when we execute
    `use <databasename>`. Knowing this, at this point, we can use the `db` object
    to do anything we can do via the Mongo shell. The syntax is slightly different,
    but the idea is generally the same.
  prefs: []
  type: TYPE_NORMAL
- en: Inserting a document
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s test out our new `db` object by inserting a record into a collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we establish a connection to the database and execute
    a `callback` once the connection is complete. That `callback` receives two parameters,
    the second of which is the `db` object itself. Using the `db` object, we can get
    a collection we want to work with. In this case, we save that collection as a
    variable so that we can work with it throughout the rest of our code more easily.
    Using the `collection` variable, we execute a simple `insert` command and pass
    the JSON object we want to insert into the database as the first parameter.
  prefs: []
  type: TYPE_NORMAL
- en: The `callback` function executes after `insert` accepts two parameters, the
    second of which is an array of documents affected by the command; in this case,
    it is an array of documents that we inserted. Once `insert` is complete and we
    are inside the `callback` function, we log some data. You can see that the length
    of the `docs.ops` array is `1`, as we only inserted a single document. Furthermore,
    you can see that the single document in the array is the document we inserted,
    although now it has an extra `_id` field since MongoDB handles that automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving a document
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s prove our code a little bit more by adding the `findOne` function call
    to look up the document we just inserted. Change the code in `test.js` to match
    the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In this code, we insert a record in exactly the same way as before; only this
    time,
  prefs: []
  type: TYPE_NORMAL
- en: we perform `findOne` on `title`. The `findOne` function accepts a `JSON` object
    to match against (this can be as precise or loose as you want) as its first parameter.
    The `callback` function that executes after `findOne` will contain the single
    document that was found as its second parameter. If we executed a `find` operation,
    we would have received an array of matching documents based on the search criteria.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of the last mentioned code should be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In your output, you might notice that the `_id` parameter being reported on
    `insert` doesn't match the one from `findOne`. This is likely the result of running
    the code multiple times, which results in multiple records with the same title
    being inserted. The `findOne` function will return the first document found in
    no particular order, so chances are the document returned might not be the last
    one inserted.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have a basic understanding of how to easily connect and communicate
    with a MongoDB server from Node.js, let's take a look at how we can work with
    MongoDB in a way that's a little less raw.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Mongoose
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While working directly with the `mongodb` module is great, it's also a bit raw
    and lacks any sense of the developer friendliness that we've come to expect when
    working with frameworks such as Express in Node.js. **Mongoose** is a great third-party
    framework that makes working with MongoDB a breeze. It is an elegant `mongodb`
    object modeling for Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: What that basically means is that Mongoose gives us the power to organize our
    database using schemas (also known as model definitions) and provides powerful
    features to our models, such as validation, virtual properties, and more. Mongoose
    is a great tool, as it makes working with collections and documents in MongoDB
    feel much more elegant. The original `mongodb` module is a dependency of Mongoose,
    so you can think of Mongoose as being a wrapper on top of `mongodb`, much like
    Express is a wrapper on top of Node.js--both abstract away a lot of the raw feeling
    and give you easier tools to work with directly.
  prefs: []
  type: TYPE_NORMAL
- en: It's important to note that Mongoose is still MongoDB, so everything you're
    familiar with and used to will work pretty much the same way; only the syntax
    will change slightly. This means that the queries, inserts, and updates that we
    know and love from MongoDB work perfectly fine with Mongoose.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we need to do is install Mongoose so that it''s available to
    use within our `mongotest` project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: After installation, let's take a look at some of the features that Mongoose
    has to offer and that we'll take advantage of to make our lives easier when developing
    apps that rely heavily on a MongoDB database.
  prefs: []
  type: TYPE_NORMAL
- en: Schemas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Mongoose, schemas are what we use to define our models. Visualize the schemas
    as the blueprints which are used to create the models. Using schemas, you can
    define much more than the simple blueprint of a MongoDB model. You can also take
    advantage of the built-in validation that Mongoose provides by default, adding
    static methods, virtual properties, and more.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we do while defining a schema for a model is build a list of
    every field we think we will need for a particular document. The fields are defined
    by type, and the standard data types you would expect are available, as well as
    a few others:'
  prefs: []
  type: TYPE_NORMAL
- en: '*String*: This type stores a string value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Number*: This type stores a number value, with restrictions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Date*: This type holds a `date` and `time` object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Buffer*: This type provides the storage for binary data. For instance, it
    can include images or any other files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Boolean*: This type is used to store a Boolean (true/ false) value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Mixed*: This is basically an unstructured object that can contain anything.
    Consider this when storing JSON type data or data that is arbitrary and'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: can literally be any JSON representation. It doesn't need to be predefined.
  prefs: []
  type: TYPE_NORMAL
- en: '*ObjectID*: This is typically used when you want to store the ObjectID of another
    document in a field, for example, when defining a relationship.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Array*: This is a collection of other schemas (models).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is an example of a basic Mongoose schema definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Here, we define our schema for an `Account` collection. The first thing we do
    is `require` Mongoose and then define a `Schema` object using `mongoose.Schema`
    in our module. We define a schema by creating a new `Schema` instance with a constructor
    object that defines the schema. Each field in the definition is a basic JavaScript
    object with its type and then an optional default value.
  prefs: []
  type: TYPE_NORMAL
- en: Models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A model in Mongoose is a class that can be instantiated (defined by a schema).
  prefs: []
  type: TYPE_NORMAL
- en: Using schemas, we define `models` and then use them as regular JavaScript objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The benefit is that the `model` object has the added bonus of being backed
    by Mongoose, so it also includes features such as saving, finding, creating, and
    removing. Let''s take a look at defining a model using a schema and then instantiating
    a model and working with it. Add another file called `test2.js` to your experimentation
    folder, `mongotest/test2.js`, and include the following block in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the preceding code should result in something similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Creating a new model is great when you''re working with new documents and you
    want a way to create a new instance, populate its values, and then save it to
    the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Calling `.save` on a `mongoose` model will trigger a command to MongoDB that
  prefs: []
  type: TYPE_NORMAL
- en: 'will perform the necessary `insert` or `update` statements to update the server.
    When you switch over to your mongo shell, you can see that the new user was indeed
    saved to the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Without calling `.save()` on the model, the changes to the model won't actually
    be persisted to the database. Working with Mongoose models in your Node code is
    just that--code. You have to execute MongoDB functions on a model for any actual
    communication to occur with the database server.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use `AccountModel` to perform a `find` operation and return an array
    of `AccountModel` objects, based on some search criteria that retrieves results
    from the MongoDB database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Here, we use the standard MongoDB commands `$gt` and `$lt` for the value of
    age when passing in our query parameter to find documents (that is, find any document
    where the age is above 18 and below 30). The callback function that executes after
    `find` references an `accounts` array, which is a collection of `AccountModel`
    objects returned from the query to MongoDB. As a general means of good housekeeping,
    we close the connection to the MongoDB server after we are finished.
  prefs: []
  type: TYPE_NORMAL
- en: Built-in validation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the core concepts of Mongoose is that it enforces a schema on top of
    a
  prefs: []
  type: TYPE_NORMAL
- en: 'schema-less design, such as MongoDB. In doing so, we gain a number of new features,
    including built-in validation. By default, every schema type has a built-in required
    validator available. Furthermore, numbers have both `min` and `max` validators,
    and strings have enumeration and matching validators. Custom validators can also
    be defined via your schemas. Let''s take a brief look at some validation added
    to our example schema from earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The validation we added to our schema is that the `username` parameter is now
    required, and we included a new field called `age`, which is a number that must
    be between `13` and `120` (years). If either value doesn't match the validation
    requirements (that is, the `username` is blank or the `age` is less than `13`
    or greater than `120`), an error will be thrown.
  prefs: []
  type: TYPE_NORMAL
- en: 'Validation will fire automatically whenever a model''s `.save()` function is
    called; however, you can also manually validate by calling a model''s `.validate()`
    function with a `callback` to handle the response. Building on the example, add
    the following code, which will create a new `mongoose` model from the schema defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the preceding code should log the following error to the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: You can see that the `error` object that is returned from `validate` is pretty
    useful and provides a lot of information that can help when validating your model
    and returning error messages back to the user.
  prefs: []
  type: TYPE_NORMAL
- en: Validation is a very good example of why it's so important to always accept
    an `error` object as the first parameter to any `callback` function in Node. It's
    equally important that you check the `error` object and handle it appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: Static methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Schema`s are flexible enough so that you can easily add your own custom static
    methods to them, which will then become available to all of your models that are
    defined by that `Schema`. Static methods are great for adding helper utilities
    and functions that you know you''re going to want to use with most of your models.
    Let''s take our simple age query from earlier and refactor it so that it''s a
    static method and a little more flexible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Static methods are pretty easy to implement and will make your models much more
    powerful once you start taking full advantage of them!
  prefs: []
  type: TYPE_NORMAL
- en: Virtual properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Virtual properties are exactly what they sound like--fake properties that don''t
    actually exist in your MongoDB documents, but that you can fake by combining other,
    real properties. The most obvious example of a `virtual` property would be a field
    for `fullname`, when only `firstname` and `lastname` are actual fields in the
    MongoDB collection. For `fullname`, you simply want to say, return the model''s
    first and last name combined as a single string and label it as `fullname`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We call the `.get()` and `.set()` functions. It's not required to provide both,
    although it's fairly common.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, our `get()` function simply performs basic string concatenation
    and returns a new value. Our `.set()` function performs the reverse splitting
    of a string on a space and then assigning the model's `firstname` and `lastname`
    field values with each result. You can see that the `.set()` implementation is
    a little flaky if someone attempts to set a model's `fullname` with a value of,
    say, Dr. Kenneth Noisewater.
  prefs: []
  type: TYPE_NORMAL
- en: It's important to note that virtual properties are not persisted to MongoDB,
    since they are not real fields in the document or collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s a lot more you can do with Mongoose, and we only just barely scratched
    the surface. Fortunately, it has a fairly in-depth guide that you can refer to
    at the following link: [http://mongoosejs.com/docs/guide.html](http://mongoosejs.com/docs/guide.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Definitely spend some time reviewing the Mongoose documentation so that you
    are familiar with all of the powerful tools and options available.
  prefs: []
  type: TYPE_NORMAL
- en: That concludes our introduction to Mongoose's models, schemas, and validation.
    Next up, let's dive back into our main application and write the schemas and models
    that we will be using to replace our existing sample `ViewModels` and for connecting
    with Mongoose.
  prefs: []
  type: TYPE_NORMAL
- en: Context of method (this)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before getting started with our next sections, the readers may have noticed
    that we have not used a fat arrow function as a replacement for the `callbacks`
    in all cases. This is because we will be using the context of a function `(this)`
    widely. There is a difference in implementation between flat arrow functions and
    regular functions when it comes to context. The differential statement is that
    the context of function `(this)` doesn''t depend on where it is declared, but
    from where it is called. To understand this, let''s consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: On running the preceding snippet, we will get the output `'world'`; this is
    because the foo function is called in a global scope, hence the context is global
    and we receive the value of the global variable. To restrict this behavior, we
    can use the `bind` method or es6 arrow functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we convert the preceding `get virtual` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The context inside the preceding `arrow` function won''t refer to the `Account`
    schema, and will thus get undefined. To avoid this behavior, we will continue
    with regular functions. Get to know more about the lexical scoping mechanism of
    the `arrow` function in the following link: [https://goo.gl/bXvFRM](https://goo.gl/bXvFRM).
    More details on how to handle this issue with different methods are posted in
    the following link: [https://github.com/Automattic/mongoose/issues/5057](https://github.com/Automattic/mongoose/issues/5057).'
  prefs: []
  type: TYPE_NORMAL
- en: Connecting with Mongoose
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The act of connecting to a MongoDB server with Mongoose is almost identical
    to the method we used earlier when we used the `mongodb` module.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to ensure that Mongoose is installed. At this point, we are
    going to be using Mongoose in our main app, so we want to install it in the main
    project directory and also update the `package.json` file. Using your command-line
    terminal program, change locations to your `projects` folder, and install Mongoose
    via `npm`, making sure to use the `--save` flag so that the `package.json` file
    is updated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: With Mongoose installed and the `package.json` file updated for the project,
    we're ready to open a connection to our MongoDB server. For our app, we are going
    to open a connection to the MongoDB server once the app itself boots up and maintains
    an open connection to the database server for the duration of the app's lifetime.
    Let's edit the `server.js` file to include the connection code we need.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, include Mongoose in the app by requiring it at the very top of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, insert the following code right after the `app = config(app);` line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: That's it! Those few simple lines of code are all it takes to open a connection
    to a MongoDB server, and our app is ready to start communicating with the database.
    The parameter we pass to the `connect` function of Mongoose is a URL string to
    our locally running MongoDB server with a path to the collection we want to use.
    The ``useMongoClient`` is used to opt the new connection method as the default
    method but will be deprecated once we start using Mongo version 4.11.0 and above.
    Further, we add an event listener to the `open` event of the `mongoose.connection`
    object, and when that fires, we simply log an output message that the database
    server has connected.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the schemas and models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For the purposes of the application we are building, we''re going to have only
    two different, unique schemas and associated models: an `Image` model and a `Comment`
    model. If we were to take this application to production and really build it out
    with all of the necessary features, we would expect to have many more models as
    well.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create a new directory labeled `models` in your project, and we will
    store the Node.js modules for each of our models here. Create three files named
    `image.js`, `comment.js`, and `index.js` in this directory. Let''s take a look
    at the `Image` model first. Copy the following block of code into the `models/image.js`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we define our `ImageSchema` with the various fields that we are going
    to store in MongoDB for each of the images. We created a `virtual` property of
    `uniqueId`, which is just the filename with the file extension removed. As we
    want our `Image` model to be available throughout the rest of our app, we export
    it using `module.exports`. Note that we are exporting the model, not the schema
    (as the schema itself is fairly useless to us). Let''s set up a similar model
    for comments. Copy the following block of code into the `models/comment.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: There are a few important things to take note of with this model. First, we
    have
  prefs: []
  type: TYPE_NORMAL
- en: a field labeled `image_id`, which has an `ObjectId` type. We're going to use
    this
  prefs: []
  type: TYPE_NORMAL
- en: field to store the relationship between the `comment` and `image` that it was
    posted to.
  prefs: []
  type: TYPE_NORMAL
- en: The `ObjectId` that gets stored in this field is the `_id` of the related image
    document from MongoDB.
  prefs: []
  type: TYPE_NORMAL
- en: We also define `virtual` on the `comment` schema labeled `image`, which we provide
    a getter and setter for. The `image` virtual property will be how we attach the
    related image when we retrieve comments later in our controllers. For every comment,
    we are going to iterate through and look up its associated image and attach that
    `image` object as a property of the comment.
  prefs: []
  type: TYPE_NORMAL
- en: Handling the name of collections
  prefs: []
  type: TYPE_NORMAL
- en: You name your models using singular terms, and Mongoose will recognize this
    and create your collections using pluralized model names. So, a model defined
    as `Image` will have a collection in MongoDB named `images`. Mongoose tries to
    be smart about this; however, a model defined as `Person` will have a corresponding
    collection named `people`, and so on. (And yes, octopus will result in octopi!)
  prefs: []
  type: TYPE_NORMAL
- en: The models index file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There's one last file in the `models` folder that we haven't yet touched on
    in our project. The `index.js` file within any folder in Node.js acts as an `index`
    file for the modules within it. This is by convention, so you don't have to adhere
    to this if you don't want to.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since our `models` folder will contain a number of different files, each a
    unique module for one of our models, it would be nice if we could just include
    all of our models in a single `require` statement. Using the `index.js` file,
    we can do so pretty easily too. Copy the following block of code into the `models/index.js`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The `index.js` file inside the `models` directory simply defines a JavaScript
    object that consists of a name-value pair for each module in our directory. We
    manually maintain this object, but this is the simplest implementation of the
    concept. Now, thanks to this basic file, we can perform `require('./models')`
    anywhere in our application and know that we have a dictionary of each of our
    models via that module. To reference a specific model in that module, we simply
    refer to the specific model as a property of the module. If we only wanted to
    require a specific model somewhere in our app instead, we could perform `require('./models/image')`
    just as easily! You will see more of this a little later, and it will become much
    clearer.
  prefs: []
  type: TYPE_NORMAL
- en: Because our two models are so closely related, we are typically always going
    to require the `models` dictionary using `require('./models')` throughout our
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Adding CRUD to the controllers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**CRUD** stands for Create, Read, Update, and Delete. Now that our schemas
    are defined and our models are ready, we need to start using them throughout our
    application by updating our controllers with various CRUD methods where necessary.
    Up until this point, our controllers have consisted of only fixture, or fake,
    data, so we can prove that our controllers are working and our view models were
    wired up to our templates. The next logical step in our development is to populate
    our View models with data directly from MongoDB. It would be even better if we
    could just pass our Mongoose models right to our templates as `viewModel` itself.'
  prefs: []
  type: TYPE_NORMAL
- en: The home controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you recall from the *Updating the home controller* section of [Chapter 6](f6aebdd0-b566-4ea8-ac24-9d73cb7ee761.xhtml),
    *Controllers and View Models*, we originally created `viewModel`, which consisted
    of an array of JavaScript objects that were just placeholder fixture data in our
    home controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We are going to replace that `viewModel` with a very stripped-down version
    that we will then populate with real data from our Mongoose models:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we can populate that `viewModel` with real data, we need to first make
    sure our home controller can use our models. To do so, we must require the `models`
    module. Include this at the very top of the `controllers/home.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We could have required the full `models` module and had access to both the
    `Comment` model and the `Image` model; however, for the home page, we really only
    need to use the `Image` model. Now, our `mongoose` model for `Image` is available
    to our home controller, and we can perform a `find` operation to retrieve a list
    of the newest images to display on the home page. Replace the existing `sidebar()`
    call in your home controller with this updated version of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Using `ImageModel`, we execute a MongoDB `find` query, but we provide no specifics
    for the actual query (a blank JavaScript object), which means it will return every
    document. The second parameter is also a blank JavaScript object, which means
    we aren't specifying how to map the results, so the full schema will be returned.
    The third parameter is an `options` object, where we can specify things such as
    the `sort` field and order. In this particular query, we are retrieving every
    single image in the images collection sorted by `timestamp` in descending order
    (ascending order would have a value of `1` instead of `-1`).
  prefs: []
  type: TYPE_NORMAL
- en: The `callback` function that executes after a successful `find` query to the
    MongoDB database server will return both an `error` object and an `images` array
    of matching models; in our case, it is with every image in the database. Using
    the array that's returned from the query, we simply attach it to our `viewModel`
    via its `images` property. Then, we call our `sidebar` function exactly as we
    did previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we are no longer populating `viewModel` with fixture data, but
    are instead populating it with exactly what is returned from the database when
    we perform a basic `find` query using our Mongoose `Image` model. The home page
    for the application is officially data driven. Here is a recap of the entire `controllers/home.js`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: If you were to run the app and open it in a browser, you wouldn't actually see
    anything on the home page. That's because we haven't actually inserted any data
    yet. That's coming up next. However, note that the page itself still works and
    you don't get any errors. This is because MongoDB is simply returning an empty
    array from the `find` on `ImageModel`, which the Handlebars home page template
    is handling fine because it's performing an `each` operation against an empty
    array, so it's displaying zero images on the home page.
  prefs: []
  type: TYPE_NORMAL
- en: The image controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `image` controller is by far the biggest component of our application. It
    contains most, if not all, of the logic that's powering our app. This includes
    displaying all of the details for an image, handling the uploading of images,
    and handling likes and comments. There's a lot to cover in this controller, so
    let's break it down by each section.
  prefs: []
  type: TYPE_NORMAL
- en: Index - retrieving an image model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The primary responsibility of the `index` function in our `image` controller
    is to retrieve the details for a single, specific image, and display that via
    its `viewModel`. In addition to the details for the actual image, the comments
    for an image are also displayed on the page in the form of a list. Whenever an
    image is viewed, we also need to update the view count for the image and increment
    it by one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Begin by editing the `controllers/image.js` file and updating the list of required
    modules at the top, to include our `models` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We also want to strip `viewModel` down to its most basic form, exactly as we
    did in the home controller. Replace the existing `viewModel` object variable with
    this new, lighter version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'After defining a blank `viewModel`, let''s include a `find` call on the `Image`
    model so that we can look up an image specifically by its `filename`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we are using the `Models` module's `Image` model and
    performing `findOne`, which is identical to `find`, except it will only ever return
    a single document (matching or not), instead of an array like `find` returns.
    By convention, we use a singular variable name in our callback's second parameter
    versus a plural one, just so we, as developers, can easily tell whether we are
    working with a single object or an array/collection of objects.
  prefs: []
  type: TYPE_NORMAL
- en: The `query` object we provide as the first parameter matches the `filename`
    field of an image document using MongoDB's `regex` filter and compares this to
    `req.params.image_id`, which is the value of the parameter in the URL as defined
    in our `routes` file. The URL for an image page will always be `http://localhost:3300/images/abcdefg`,
    where `abcdefg` will be the value of `req.params.image_id`. If you recall, we
    are randomly generating this value in the `create` function when an image is uploaded.
  prefs: []
  type: TYPE_NORMAL
- en: After checking to make sure our `err` object isn't null, we then check to make
    sure our `image` object is also not null. If it's not null, that means a model
    was returned from MongoDB; so, we found our image, and we're good to go. If an
    `image` model wasn't returned, because we tried searching for an image by a filename
    that doesn't exist, we simply redirect the user back to the home page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now populate our `viewModel` by inserting the following lines into the
    area where we have the `// to do...` placeholder comment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: We attach the `image` model that was returned from `findOne` to our `viewModel.image`
    property, but not before incrementing the `views` property of that model by `1`
    (so that we represent our actual plus one view as we load the page). Since we
    modified the model (by incrementing its view count), we need to ensure that it's
    saved back to MongoDB, so we call the model's `save` function.
  prefs: []
  type: TYPE_NORMAL
- en: Now that `viewModel` has been updated with the `image` model and the view
  prefs: []
  type: TYPE_NORMAL
- en: 'count has been incremented and saved, we need to retrieve a list of comments
    associated with the image. Let''s include a little bit more code to query the
    `Comment` model and find any comments that belong to the image. Insert the following
    block of code immediately after `image.save();` from earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Using `find` on our `Comment` model, we can pass in an object that contains
    our query as the first parameter; in this case, we are specifying that we want
    all comments where the `image_id` field is equal to the `_id` property of the
    main `image` model
  prefs: []
  type: TYPE_NORMAL
- en: we attached to our `viewModel` earlier.
  prefs: []
  type: TYPE_NORMAL
- en: That code might look a little odd, so let's elaborate. Remember that the `image`
    object that is returned from the original `Models.Image.findOne()` call is available
    throughout the entire scope of that `callback` function. No matter how deep we
    get nesting `callback` functions, we will always have access to that original
    `image` model. Therefore, we can access it and its properties inside the `callback`
    function that fires when our `Model.Comment.find()` has executed.
  prefs: []
  type: TYPE_NORMAL
- en: Once inside the `find` callback of `Comment`, we attach the `comments` array
    that was returned to our `viewModel` and then call our `sidebar` function exactly
    as we did when we first opened the controller and started editing this `index`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a review, here is the entire `index` function inside the `controllers/image.js`
    file after it''s been completely updated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s quickly recall all of the `index` controller''s responsibilities and
    tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new empty `viewModel` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the `findOne imagefindOneimage` model, where the filename is a regex
    match to the URL `image_id` parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Increment the found views of the `image` by one.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Attach the found `image` model to `viewModel`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the `image` model since its `view`s have been updated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find all comments with the `image_id` property equal to the `_id` of
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: the original `image` model.
  prefs: []
  type: TYPE_NORMAL
- en: Attach the array of found `comments` to `viewModel`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Render the page using `sidebar`, passing in the `viewModel`, and the
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`callback` function.'
  prefs: []
  type: TYPE_NORMAL
- en: Create - inserting an image model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We already have the functionality in place in our `create` function to handle
    randomly naming and uploading an image file. Now, we need to save that information
    to MongoDB for the uploaded image.
  prefs: []
  type: TYPE_NORMAL
- en: Let's update the original `saveImage` function inside `controllers/images.js:create`
    and include the functionality to tie it into the database.
  prefs: []
  type: TYPE_NORMAL
- en: Our goal with the `saveImage` function is twofold. First, we want to make sure
  prefs: []
  type: TYPE_NORMAL
- en: that we never save an image with the same randomly generated filename as an
    already existing image to the database. Second, we want to ensure that we only
    insert the image into the database after it has been successfully uploaded, renamed,
    and saved to the filesystem. We are going to make two modifications to the existing
    code to achieve this.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first modification is to wrap the bulk of the logic with `find` against
    the randomly generated filename, and if any documents are returned as a match
    from MongoDB, to start the process over and repeat this as many times as necessary
    until we achieve a truly unique filename. The code to perform the search is as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: If an `images` array that is returned from `find` has a length greater than
    zero, it means at least one image was found to have the same filename as was generated
    with our random `for` loop. If that's the case, we want to call `saveImage` again,
    which will repeat the whole process (randomly generate a new name and perform
    a `find` on the database for that new name). We do this by previously defining
    the `saveImage` function as a variable, so that within the `saveImage` function
    itself, we can execute it again by calling the original variable as the function.
  prefs: []
  type: TYPE_NORMAL
- en: A function that calls itself is called a **recursive** function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Originally, the last step of the `create` function was to redirect the visitor
    to the image''s page within the `callback` that fired when the filesystem rename
    was finished. This is where we''re going to want to create a new Mongoose `image`
    model. We should redirect only when the database server has finished saving the
    image (again relying on a `callback` function). Consider the following line in
    the original function: assuming no images were returned from `find`, it means
    we have generated a truly unique filename for our image and we are safe to rename
    the file and upload it to the server, as well as save a record to the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace this with this new block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Here, we create a brand new `Image` model and pass in the default values via
    its constructor. The `title` and `description` fields get set right from the values
    passed in via the HTML form using `req.body` and the form field names (`.title`
    and `.description`). The `filename` parameter is built the same way as when we
    originally we set its destination for renaming it, except we don't include the
    path and directory names, just the randomly generated filename and the image's
    original extension.
  prefs: []
  type: TYPE_NORMAL
- en: We call the model's `.save()` function (just as we did earlier, when we updated
    the image's `views` property in the `index controller` function). The `save` function
    accepts a second parameter in its `callback`, which will be the updated version
    of itself. Once the `save` is completed and the image has been inserted into the
    MongoDB database, we then redirect to the image's page. The reason the `callback`
    returns the updated version of itself is because MongoDB automatically includes
    additional information, such as `_id`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a review and sanity check, here is the complete code for the `saveImage`
    function in `controllers/image.js:create`, with the new lines of code clearly
    highlighted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Don't forget to initially execute `saveImage()` right after the function is
    defined; otherwise, nothing will happen!
  prefs: []
  type: TYPE_NORMAL
- en: Testing everything out so far
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At this point, we have most of the key functionalities wrapped with MongoDB
    integration, and our app should really feel like it''s coming together. Let''s
    give it a test run and make sure all of our endpoints are working so far. Launch
    the app and open it in a browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Open up a browser, point it to `http://localhost:3300`, and you should see
    your application up and running, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0795cd31-1061-425e-88db-ba6224ae6075.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Go ahead and use the form on the home page to search for an image file on your
    computer and select it. Provide an input for Title and Description and click on
    the Upload Image button. You should be taken directly to the image page, with
    the details for your uploaded image displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fd3e15ab-44ab-4fe7-991c-ecfb302073f4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Go back to the home page, and you should now see your new image displayed under
    the Newest Images section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1dbedcae-ec77-47d3-838f-74f191d7b6a5.png)'
  prefs: []
  type: TYPE_IMG
- en: The like button and updating an image model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Next, let's add support for the Like button. Remember that our Like button works
    a little differently. It uses AJAX with jQuery so that data can be sent and received
    in real time without reloading the entire page. The experience for the user is
    seamless and enjoyable, as they don't lose their scroll place on the page or experience
    any other jarring UI-related issues.
  prefs: []
  type: TYPE_NORMAL
- en: The endpoint that the Like button hits is `/images/:image_id/like`, so we are
    going to use the value in the URL for `image_id` to find and retrieve the image
    in MongoDB, increment its `likes` value by `1`, and then return the new total
    number of `likes` for the image (so that the UI can update with the new value).
  prefs: []
  type: TYPE_NORMAL
- en: 'Currently, the `like` function in `controllers/image.js` only does a simple
    JSON response with a hardcoded value of `1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s replace that original code with new code that will use the Mongoose
    `Image` model to find an image with a filename that matches the `image_id` passed
    in via the URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Assuming the `callback` function receives a valid `image` model response from
    the query, we'll then increment its `likes` property, and since the model is then
    modified, we need to execute its `save` function. Inside the `save` function's
    `callback`, we send a JSON response with the real current value of the image's
    likes back to the browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, we will use shorthand in JavaScript and write something similar
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`if (!err && image)`'
  prefs: []
  type: TYPE_NORMAL
- en: In the `if` statement in the preceding example, we are saying, if the `err`
    object is `false` (that is `null`) and the `image` object is `true` (that is not
    `null`), then we're good to go!
  prefs: []
  type: TYPE_NORMAL
- en: With this code in place, you can run the app again and test out the Like button
    by viewing the image that you uploaded earlier and simply clicking on Like. If
    it worked, the counter next to the button should increase by one. Refresh the
    page, and the likes count should remain as the new value.
  prefs: []
  type: TYPE_NORMAL
- en: Comment - inserting a comment model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Inserting comments will work almost exactly the same way as the likes for an
    image. The only difference is that we are creating a new `comment` model, instead
    of updating an `image` model. The original code we had in our `comment` function
    was:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s replace this with some code that will find the image by `image_id` in
    the URL again, but this time, instead of updating its likes, we are going to create
    a new comment and assign the comment''s `image_id` value with the `_id` of the
    image we are currently viewing (this is to attach a relationship to the comment
    so that it actually belongs to an image). Replace the entire `comment` function
    in `controllers/image.js` with the following block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Here, you can see that we are using the same code from the `like` function to
    query MongoDB and find the image with the matching `filename` from the URL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming a valid image is returned as a match, we create a new `comment` object
    called `newComment` and actually pass the entire HTML form body into the constructor.
    This is a bit of a cheat, as it''s a coincidence that our HTML form uses `form`
    fields that have the same name and structure as that of a `comment` model. If
    you were to perform the `console.log` operation on the `req.body` object, you
    would see something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: That's identical to what we would have built manually anyway, so we just take
    a shortcut and pass the whole thing in as it is! After that, we update a few more
    properties on the `newComment` model. First, we manually set a `gravatar` property,
    which is where we will store the MD5 hash value of the commenter's email address
    so that we can retrieve their Gravatar profile picture. Gravatar is a universal
    avatar service that stores profile pictures based on a user's email address. However,
    the unique ID they use for each profile is an MD5 hash value, which is why we
    have to store that value.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we are relying on the third-party MD5 module, we need to ensure that it''s
    installed in our project and saved to our `package.json` file as a dependency.
    From your project''s root folder, execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: In addition, we need to require the module in the `controllers/image.js` file
    at
  prefs: []
  type: TYPE_NORMAL
- en: 'the very top, along with the other modules we are requiring:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we set the `image_id` property of `newComment` to the `_id` property
    of the image we found at the beginning of the function. Then, we call the `comment`
    model's `.save()` function and redirect the user back to the image page. For convenience,
    we append a bookmark to the new comment's `_id` to the URL so that when the page
    loads it will automatically scroll down to the users' comments that have just
    been posted.
  prefs: []
  type: TYPE_NORMAL
- en: 'With that functionality in place, go ahead and fire up the app and open it
    in your browser. Visit the image page for any images you''ve uploaded, and post
    a comment. Once the comment posts and the page reloads, you should see something
    like the following screenshot under an image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5b816d54-4b12-487e-bc74-9de5ccae1af6.png)'
  prefs: []
  type: TYPE_IMG
- en: We could have chosen to handle comments using jQuery and AJAX, the same way
    we handled the Like button. However, this introduces a bit more complexity, because
    if we were to do that, we would have needed a slightly more sophisticated way
    to display that inserted comment to the screen. This would have involved relying
    heavily on jQuery to do some advanced DOM manipulation to display the comment
    after it was posted using AJAX.
  prefs: []
  type: TYPE_NORMAL
- en: In a later chapter, when we review Single Page Applications, we will take a
    brief look at some JavaScript frameworks that perform this kind of functionality
    and a lot of other advanced features that concludes the code and functionality
    for the `image` controller.
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping it up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s do a quick recap of all of the changes we''ve made to this controller:'
  prefs: []
  type: TYPE_NORMAL
- en: We updated the `index` function to retrieve an image from MongoDB and populate
    `viewModel` with the details of the `image` model. We also found
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: all the comments related to that image and attached an array of those to `viewModel`
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: We tweaked the `create` function to insert a new `image` model into the database
    once it has been successfully renamed and saved to the filesystem.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `like` function was updated to actually increment the value of an image's
    `likes` property and save that value to the database, as well as to return the
    new value via a JSON response.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comments are now inserted for a particular image via the `comment` function.
    Not only is a `comment` model inserted into the database, but its corresponding
    image is also found and the `image` model's `_id` value is attached to the comment
    to solidify a relationship.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Helpers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last piece of the puzzle, and the last area we need to tie into MongoDB
    is the sidebar. To do this, we are going to need to update each of the helpers
    we created previously . Most of the helpers that we write code for will be using
    the concepts and functionality that we've already covered in this chapter. However,
    there is the addition of one new concept that I want to focus on before we take
    a look at the code.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the async module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As JavaScript is asynchronous by its very nature, there will undoubtedly come
    a time when we will need a way to handle executing a number of different asynchronous
    functions at the same time. The big issue here is that if we try to perform three
    different queries on a MongoDB server, for example, how will we know when all
    three are finished before we move on and do work with the results? Up until this
    point, we've simply been relying on a single `callback` function, which works
    great for a single call. How can we assign a single `callback` function to multiple
    asynchronous calls?
  prefs: []
  type: TYPE_NORMAL
- en: The answer is, we can not directly anyway. You can use a lot of nested `callbacks`
    to achieve this, but that is generally considered bad practice and will significantly
    reduce the readability of your code. You can use a third-party module, however,
    that was designed very specifically for this exact need. `async` is a powerful
    node module that can be downloaded and installed via `npm` and which provides
    a number of extremely useful utility functions, all designed to help when working
    with a series of asynchronous functions. Two functions that we are going to work
    with in this chapter are `series` and `parallel`. The `series` function allows
    us to execute asynchronous functions sequentially, each waiting until the previous
    function finishes before executing a single `callback` function at the end. The
    `parallel` function allows us to do the opposite--execute a number of asynchronous
    functions simultaneously, waiting until they are all complete, then executing
    a single `callback` function when the last function is finished.
  prefs: []
  type: TYPE_NORMAL
- en: 'How does a single `callback` function handle the responses of a number of different
    asynchronous functions, you ask? The answer is:'
  prefs: []
  type: TYPE_NORMAL
- en: by accepting an array of the responses of each function as a parameter!
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we are going to use `async` for our project, let''s install it via `npm`
    and make sure our `package.json` file is updated as well. Within the root of your
    `project` folder, execute the following from the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The comments helper
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's take a look at the first use of `async` in one of our helpers, the `comments`
    helper. Originally, `helpers/comments.js` was a module that had a `newest` function
    that returned an array of fixture data with some sample comments.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to completely remove this code and instead query MongoDB for the
    `newest` comments and return those as an array. Start by clearing the `comment`
    helper module and starting from scratch (note that we included a new `callback`
    parameter to the `newest` function):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that we added the additional `require` statements at the top of the
    file for our `models` and `async`. Within the `newest` function, let''s replace
    the `// to do...` comment with code to query MongoDB and find the five most recent
    comments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Note that the first parameter in the `find` query is an empty JavaScript object,
    meaning we will retrieve every comment in the database. For the third parameter,
    however, we're using `limit` and `sort` so that we limit the number of records
    returned to five, and we sort the query by `timestamp` in descending order.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have an array of comments, we'd ideally like for the image that
    each comment belongs to to be returned as well. Typically, this would be accomplished
    by using an `aggregate` query in MongoDB to join different collections together
    (such as a `JOIN` in SQL). We will see `aggregate` in more detail in the next
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: For the purposes of our code, we're going to instead query MongoDB separately
    for each comment and retrieve the image associated with the comment's `image_id`
    value.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s define a function that will query MongoDB and retrieve and attach
    an `image` model to a `comment` model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: This function will accept a `comment` model as the first parameter and a `callback`
    function (named `next`) as the second parameter . Having the `next` callback as
    the second parameter is important, because it's the key to how `async` is able
    to function. Imagine that the next `callback` acts as a chain link. Since the
    same function is going to be called for every item in a collection, there needs
    to be a way to daisy-chain the calls together. This is performed via the `callback`.
  prefs: []
  type: TYPE_NORMAL
- en: Basically, every time the `callback` is called for an item in the array, it
    performs its work and then executes the same `callback` with the next item in
    the array, and so on and so forth, which is why we named the callback function
    parameter `next`.
  prefs: []
  type: TYPE_NORMAL
- en: Another important element to point out with this function is that when we attach
    the `image` model to the comment's `image` property, we are using the `virtual`
    property we set up earlier in the main comment's schema. If you recall, when we
    set the `image` property, we were actually setting the private `_image` property.
    Likewise, when we get the `image` property, we are actually retrieving the private
    `_image` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'After we define the `attachImage` function, we need to use the `each` function
    of `async` to apply that function to every item in the `comments` collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The `each` function of `async` will loop through every item in the collection
    in the first parameter, and send each item as a parameter to a `callback` function
    in the second parameter. The third parameter is the `final callback` function
    that is executed once the entire series is finished with the collection. In this
    case, every comment in the comment''s array will be passed individually to the
    `attachImage` function. When the entire collection has been iterated through,
    the `final callback` will execute, which basically fires the very first `callback`
    function that was passed into the `newest` function as its only parameter. Boy,
    that was a mouthful! Let''s try to break this down a little further, so it makes
    a bit more sense:'
  prefs: []
  type: TYPE_NORMAL
- en: The `newest` function of the `comment` helper module accepts a single parameter
    named `callback`- -this is the function that will be called
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: once all of the work in this entire function is finished.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing the `newest` function does is find the latest five comments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: and return them as an array to an anonymously defined inline function.
  prefs: []
  type: TYPE_NORMAL
- en: First, we define a function and store it in a variable named `attachImage`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `attachImage` function accepts two parameters: an individual comment model,
    and a callback function that we named `next`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `attachImage` function will query MongoDB to find an image with
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: an `_id` value that is the same as the `image_id` property of the `comment`
  prefs: []
  type: TYPE_NORMAL
- en: that was passed into it as the first parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Once that image is found, it is attached to the comment via its `image` property
    and then the next `callback` function is executed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We use `async.each` to loop through every comment in the `comments` array that
    was passed as the first parameter to `each`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pass the `attachImage` function as the second parameter, which is the function
    that will be called for every comment in the comment's array.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, define an inline anonymous function that will be executed once the
    last item in the comments collection has been iterated on. This inline function
    itself only accepts an `error` object as its parameter. Assuming every iteration
    of the `comments` collection was successful, this function will be executed with
    no error. Inside this function, we execute the original function named `callback`
    that was the only parameter to the `newest` function, and `callback` is called
    with the newly updated comment's array as its second parameter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Okay, the hardest part is over! You survived a crash course on the `async`
    module and came out, hopefully unscathed! Just to be safe, here is the code for
    the `helpers/comments.js` module file in its entirety:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Callbacks, callbacks, callbacks everywhere!
  prefs: []
  type: TYPE_NORMAL
- en: At this point, it's probably getting a little confusing with the number of `callbacks`
    we've been dealing with. A part of the problem is the terminology we've been using.
    Any function that is passed as a parameter and only executed after certain conditions
    are met, typically as the end result of the original function, is referred to
    as a `callback`. The popular convention with JavaScript is to label a `callback`
    function in a parameter literally with the variable name `callback`, so that it's
    obvious. This works great when you are reading code, but not so much when you
    are explaining code and referring to a function named `callback` that's also known
    as the `callback`!
  prefs: []
  type: TYPE_NORMAL
- en: The sidebar helper
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Okay! So of course, there's a catch, right!? Well, kind of. Since we introduced
    `async` in our `Comments` helper module, we now need to introduce it in our `sidebar`
    helper. This is because of the simple fact that our `Comments` helper is now really
    asynchronous, so anything that uses our `Comments` module needs to deal with that.
    As our `sidebar` module currently stands, it's just expecting the `comments` helper
    module to return an array instantly; so, it's not expecting to have to wait around
    for the actual data. Because of this, if we ran our code as is, our `comments`
    sidebar would remain blank (because the sidebar would have rendered the page before
    the MongoDB calls were even finished thinking within the `comments` module). Let's
    fix this by updating our `sidebar` helper module to use `async` as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s edit the `helpers/sidebar.js` file and replace its entire contents
    with this slightly modified version that uses `async.parallel`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The first thing we did was make sure `async` was included as a required module
    at the top of the file. Inside the primary `exports` function, we basically wrapped
    our existing code and integrated it into `async.parallel` so that we could easily
    tweak it a little later as we updated each section of the `sidebar` helpers. Since
    we've only completed the `comments` helper module so far, that's the only one
    that's actually been changed. The other `Stats` and `Images.popular` calls are
    being forcibly used with `async.parallel`, even though it doesn't quite make sense
    to do that right now. It will once those two sections become more asynchronous
    in the next sections.
  prefs: []
  type: TYPE_NORMAL
- en: The `parallel` function of `async` works in a similar way to its `each` function
    that we used earlier. The main difference is that `parallel` isn't performing
    the same function in a loop through a collection, but is instead performing a
    series of unique functions all at the same time. If you look closely, you can
    see that the first parameter to `parallel` is actually an array, and each item
    in the array is a unique function. Every function in the array accepts a `next`
    callback parameter function, which is executed at the conclusion of each of the
    functions. The second parameter in the `next` callback is the result of the work
    that was performed within the function itself. In the case of `Stats` and `Images.popular`,
    those two functions simply return values instantly, with no asynchronous calls
    to anything else, so we just expect the results to be returned by executing them
    directly.
  prefs: []
  type: TYPE_NORMAL
- en: However, as you can see with the `Comments.newest` section, we are passing in
    the `next` callback function as a parameter because we want its execution to be
    deferred until the last second (until `Comments.newest` has completed all of its
    work). Once that `next` callback function is called, it is passed the results
    of all of its work.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last parameter to the `parallel` function is an inline function that accepts
    a results array as its second parameter. This array is a collection of the results
    that were returned from each of the functions in the array in the first parameter.
    You can see that when we build `viewModel` now, we are referring to indexes in
    the `results` array. The index order is the order that the functions were defined
    in the original array. We know that the first function was to retrieve `Stats`,
    the second function was to retrieve `Images.popular`, and the third function was
    to retrieve `Comments.newest`. So, we can reliably assign `results[0]` to `viewModel.Stats`,
    and so on. As a reference, here is what the `viewModel` definition originally
    looked like in the `sidebar` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'You can compare this with the updated version that uses `async`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Now that the sidebar is set up to properly handle the helper modules that are
    (and eventually will be) asynchronous, we can run the application and test it
    to ensure that our sidebar is properly displaying the top five most recent comments
    on the website. Run the application and launch it in a browser. If you haven't
    already posted any comments to an image, do so now, so that you can see those
    comments appearing in the sidebar along with a thumbnail of the image they belong
    to.
  prefs: []
  type: TYPE_NORMAL
- en: Troubleshooting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At this point, we''ve covered and implemented a large number of changes to
    our application. It''s understandable that something might be broken for you,
    so let''s run through a quick checklist to make sure we haven''t missed any trouble
    spots that might be preventing your app from running properly:'
  prefs: []
  type: TYPE_NORMAL
- en: Make sure you've installed all of the required modules for this chapter and
    that they are saved to your `package.json` file. This includes `mongoose`, `async`,
    and `md5`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make sure the appropriate dependency modules are being required at the top of
    each of the module files they are used in.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make sure you remember to launch `mongod` in another terminal instance whenever
    you run the application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When in doubt, pay attention to the stack trace output that Node is giving you
    in your terminal when it fails, as it is typically pretty obvious what's wrong.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It will also give you the filename and line number of the offending module.
  prefs: []
  type: TYPE_NORMAL
- en: When all else fails, execute `console.log` everywhere!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next up, let's update the `stats` helper module to use it parallel as well,
    so we can get some real stats for the application.
  prefs: []
  type: TYPE_NORMAL
- en: The stats helper
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The primary responsibility of the `stats` helper module is to gather some totals
    for our application. These `stats` are for things such as the total number of
    images uploaded, the total number of comments, the total views for all the images
    combined, and the total likes for all the images combined. Your first inclination
    might be to assume that we are going to query MongoDB for all the images and loop
    through every image to track all of the views and totals. That's one way to do
    it, but it's pretty inefficient. Fortunately, MongoDB has some built-in functionalities
    which make generating these kinds of values a snap.
  prefs: []
  type: TYPE_NORMAL
- en: As we are going to be making a number of calls to MongoDB, we are going to rely
  prefs: []
  type: TYPE_NORMAL
- en: 'on the `async.parallel` function again, much like we did in the `sidebar` module.
    The original `helpers/stats.js` file was very bare bones, so let''s completely
    replace that file with this new version, which uses `parallel`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'This code does exactly what the module originally did, only it''s a little
    more verbose! I''m pretty sure we don''t want to just return `0` for all of our
    stats forever, though, as that''d be pretty useless and unimpressive, to say the
    least! Let''s update the `each` function to properly query MongoDB and get some
    stats. Looking at the object returned in the callback in the last function, we
    can see that we already defined the order of the functions that are being executed
    in parallel. Let''s start with images. Replace the `next(null, 0);` line in the
    first function with the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Easy! Just use MongoDB''s `count` method to find the total number of documents
    in the images collection matching any criteria (the first parameter). Then, we
    just pass the `next` function as the `callback`, because coincidentally enough,
    the parameter signatures match. If we didn''t want to use shorthand here, we could
    write this the long way, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'However, who feels like typing all that when you don''t have to! Let''s do
    the same thing for the second function in the parallel array for total comments.
    Replace the `next(null, 0);` line in the second function with the following line
    of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Again, this was a piece of cake!
  prefs: []
  type: TYPE_NORMAL
- en: Now, the next two functions are going to be a little different, but they are
    almost identical to each other. What we want to do with `next` is get the total
    `views` and `likes` for every image. We can't use MongoDB's `count` method, because
    that only counts individual documents in a collection. We need to use MongoDB's
    `aggregate` functionality instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using `aggregate`, we can perform a mathematical operation, such as `$sum`,
    to tally results for us. Replace the `next(null, 0);` line in the third function
    with the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Using MongoDB's `aggregate` function, we are telling MongoDB to group every
    document together and sum up all of their views into a single new field called
    `viewsTotal`. The resulting collection that is returned to the `callback` function
    is an array of documents with the `_id` and `viewsTotal` fields. In this case,
    the results array will only contain a single document with the grand total, because
    we weren't that tricky with our `aggregate` functionality. If there aren't any
    images in the collection at all, we need to handle that and check accordingly.
    Finally, the `next` callback function is called with the actual value for `viewsTotal`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use the same exact functionality to total up the `likes` for all images.
    Replace the `next(null, 0)`; line of code in the fourth and final function in
    parallel with the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that the `sidebar` helper module has been updated and is complete with
    the `async.parallel` functionality, let''s make a minor tweak to our `sidebar`
    module to ensure we are calling the `Stats` module correctly so that it''s properly
    asynchronous. The original line in `helpers/sidebar.js` was:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace that line of code with this slightly different version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Last but not least, let's take care of the most popular helper module for the
    images sidebar.
  prefs: []
  type: TYPE_NORMAL
- en: The popular images helper
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Again, the original `helpers/images.js` file was mostly filled with fixture
    data and placeholder code that''s fairly useless. Let''s replace the entire file
    with this new version that''s actually pretty tame in comparison to all of the
    other helper modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: At this point, this code should be pretty familiar to you. We just query MongoDB
    and find the top nine most liked images by sorting the images by total, such as
    by count in descending order, and then limiting the results to nine documents.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s edit the `helpers/sidebar.js` file again to include the updated call
    to the `Images.popular` function. Consider the original code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace this with the following slightly newer version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Now the sidebar is completely finished and completely dynamic. With no more
    fixture data or placeholder variables anywhere. Running the application should
    yield a fully functional website with all of the features we set out to implement
    working perfectly! Give it a spin and make sure it's working correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Iterating by adding an image removal capability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, I think our application is pretty awesome, but there's something
    missing that's nagging me. During testing, I've been creating all kinds of new
    images and uploading them to the application, but it's starting to get a bit cluttered
    and messy.
  prefs: []
  type: TYPE_NORMAL
- en: It dawned on me that the most obvious thing that's missing is the ability to
    delete an image!
  prefs: []
  type: TYPE_NORMAL
- en: 'In reality, I left out this feature on purpose so that we could use this opportunity
    to incorporate a completely new functionality that touches almost every area of
    the application. This seemingly simple addition is actually going to require the
    following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: Update `routes.js` to include a new route to handle `Delete` requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update `controllers/image.js` to include a new function for the route
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This should not only remove the image from the database, but also delete the
    file and all related comments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update the `image.handlebars` HTML template to include a Remove button
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update the `public/js/scripts.js` file with an AJAX handler for the Remove button
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a route
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first thing we need to update in order to add this new functionality is
    the main `routes` list. Here, we will add a new endpoint that handles the `delete`
    function and points to a function within the `image` controller. Edit the `server/routes.js`
    file and insert the following new line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Adding a controller handler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have added a new route, we need to create the controller function
    that it''s using as its `callback` (`image.remove`). Edit `controllers/image.js`
    and add the following new function code after the existing `comment: function(req,
    res){}` operation (don''t forget to add a trailing comma after the `comment` function,
    since you are adding a new function):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: This function performs four primary functions (and as such, nests four layers
    deep with `callbacks`--we could have used the async's `series` method here to
    prevent the crazy amount of nesting). The first task is to find the image that
    we are attempting to remove. Once that image is found, the file associated with
    the image should be deleted. Next, find the comments associated with the image
    and remove them. Once they have been removed, the last step is to remove the image
    itself. Assuming all of that was a success, simply send a `true` Boolean JSON
    response back to the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the Handlebars image page template
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have a `route` and `controller` function to support deleting an
    image, we need a way for the UI to send the request. The most obvious solution
    is to add a Delete button somewhere on the page. Edit the `views/image.handlebars`
    file and, after the existing HTML, where we had the Like button, add new HTML
    for a Delete button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Here, we just include a new `div` that's set to four right aligned columns using
    Bootstrap. The UI here is that the Like button and the stats are the leftmost
    portion of the row, and the Delete button (an X icon from Font Awesome) is all
    the way to the right of the same row (and red since we use Bootstrap's danger
    color class).
  prefs: []
  type: TYPE_NORMAL
- en: Updating jQuery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Finally, we are going to tie it all together by implementing code similar to
    the Like button, where we send an AJAX `delete` method with the URL and the image
    ID to the server when the button is clicked on. To be safe, we display a standard
    JavaScript confirmation dialog to ensure the button wasn't clicked on by accident.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming the server responds with a `true` value, we will turn the button green
    and change the icon to a checkmark with the word Deleted! in place. Edit `public/js/scripts.js`
    and insert the following block of code after the existing code (be sure to insert
    the new code inside the `$(function(){ ... })` jQuery function):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Let's test this brand new functionality by launching the application, loading
    it up in a browser, finding an image we no longer want, and viewing its image
    page.
  prefs: []
  type: TYPE_NORMAL
- en: The Delete button should now show up in place.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring and improvements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At this point, the application that we''ve been building is pretty much complete!
    Before we iterate anymore on the project and continue to build it out and make
    it ready for production, we should probably consider some refactoring and/or general
    improvements. Some areas that I would personally take a look at to refactor and/or
    rewrite to improve the application''s performance and overall sanity are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: I might rethink working directly with models within the controllers so much,
    and instead create a utility that I can wrap a lot of that noise in, and rely
    on more basic CRUD calls to my models and provide only a `callback` to each. This
    is most visible in the `image` controller, with `like`, `comment`, and `remove`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is literally no validation in the project that we wrote, and that's mostly
    for brevity. In reality, we should have included validation on any input fields
    a user interfaces with. Validation should be provided on both the frontend via
    jQuery or plain old vanilla JavaScript and on the backend with Node. The validation
    should protect users from submitting invalid and/or malicious code (that is, XSS
    or Cross-Site Scripting).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Right now, our application is open to the general public, which means any visitor
    that comes along can upload images as well as delete them! It would be fairly
    simple to include a user authentication process within our application. Passport.js
    is a great third-party module to integrate user authentication into Node.js applications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instead of attaching images to comments for the purposes of the sidebar (the
    `newest` comments), we should consider creating a more robust aggregate query
    using MongoDB to retrieve a hybrid collection of comments that includes the image
    provided directly from MongoDB.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter was a monster, but was also the last piece of the puzzle to complete
    our app and have a fully dynamic, database-driven Node.js app that uses MongoDB.
    Congratulations on making it this far and sticking with it! You're well on your
    way to being a true full-stack JavaScript developer.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll step away from our application for a bit as we take
    a look at working with REST APIs using Node.js.
  prefs: []
  type: TYPE_NORMAL
