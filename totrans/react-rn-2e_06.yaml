- en: The React Component Lifecycle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The goal of this chapter is for you to learn about the lifecycle of React components
    and how to write code that responds to lifecycle events. You'll learn why components
    need a lifecycle in the first place. Then, you'll implement several components
    that initialize their properties and state using these methods.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you'll learn about how to optimize the rendering efficiency of your components
    by avoiding rendering when it isn't necessary. Then, you'll see how to encapsulate
    imperative code in React components and how to clean up when components are unmounted.
    Finally, you'll learn how to capture and handle errors using new React 16 lifecycle
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: Why components need a lifecycle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: React components go through a lifecycle. In fact, the `render()` method that
    you've implemented in your components so far in this book is actually a lifecycle
    method. Rendering is just one lifecycle event in a React component.
  prefs: []
  type: TYPE_NORMAL
- en: For example, there are lifecycle events for when the component is mounted to
    the DOM, when the component is updated, and so on. Lifecycle events are yet another
    moving part, so you'll want to keep them to a minimum. As you'll learn in this
    chapter, some components do need to respond to lifecycle events to perform initialization,
    render heuristics, clean up after the component when it's unmounted from the DOM,
    or to handle errors thrown by the component.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram gives you an idea of how a component flows through its
    lifecycle, calling the corresponding methods in turn:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/d221b7fd-e25f-492e-a4bb-dc37f6939493.png)'
  prefs: []
  type: TYPE_IMG
- en: 'These are the two main lifecycle flows of a React component. The first happens
    when the component is initially rendered. The second happens whenever the component
    is updated. Here''s a rough overview of each of the methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`getDerivedStateFromProps()`: This method allows you to update the state of
    the component based on property values of the component. This method is called
    when the component is initially rendered and when it receives new property values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`render()`: Returns the content to be rendered by the component. This is called
    when the component is first mounted to the DOM, when it receives new property
    values, and when `setState()` is called.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`componentDidMount()`: This is called after the component is mounted to the
    DOM. This is where you can perform component initialization work, such as fetching
    data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`shouldComponentUpdate()`: You can use this method to compare new state or
    props with current state or props. Then, you can return false if there''s no need
    to re-render the component. This method is used to to make your components more
    efficient.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getSnapshotBeforeUpdate()`: This method lets you perform operations directly
    on DOM elements of your component before they''re actually committed to the DOM.
    The difference between this method and `render()` is that `getSnapshotBeforeUpdate()`
    isn''t asynchronous. With `render()`, there''s a good chance that the DOM structure
    could change between when it''s called and when the changes are actually made
    in the DOM.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`componentDidUpdate()`: This is called when the component is updated. It''s
    rare that you''ll have to use this method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The other lifecycle method that isn't included in this diagram is `componentWillUnmount()`.
    This is the only lifecycle method that's called when a component is about to be
    removed. We'll see an example of how to use this method at the end of the chapter.
    On that note, let's get coding.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing properties and state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you'll see how to implement initialization code in React components.
    This involves using lifecycle methods that are called when the component is first
    created. First, you'll implement a basic example that sets the component up with
    data from the API. Then, you'll see how state can be initialized from properties,
    and also how state can be updated as properties change.
  prefs: []
  type: TYPE_NORMAL
- en: Fetching component data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When your components are initialized you''ll want to populate their state or
    properties. Otherwise, the component won''t have anything to render other than
    its skeleton markup. For instance, let''s say you want to render the following
    user list component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'There are three pieces of data that this JSX relies on:'
  prefs: []
  type: TYPE_NORMAL
- en: '`loading`: This message is displayed while fetching API data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`error`: This message is displayed if something goes wrong'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`users`: Data fetched from the API'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are two helper components used here: `ErrorMessage` and `LoadingMessage`.
    They''re used to format the `error` and the `loading` state, respectively. However,
    if `error` or `loading` are null, you don''t want to have to introduce imperative
    logic into your component to handle this scenario. This is why you''re using a
    cool little trick with `Immutable.js` maps:'
  prefs: []
  type: TYPE_NORMAL
- en: You create a map that has a single **key-value pair**. The key is null, and
    the value is null.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You call `get()` with either an `error` or a `loading` property. If the `error`
    or `loading` property is null, then the key is found and nothing is rendered.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`get()` accepts a second parameter that''s returned if no key is found. This
    is where you pass in your *truthy* value and avoid imperative logic altogether.
    This specific component is simple, but the technique is especially powerful when
    there are more than two possibilities.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'How should you go about making the API call and using the response to populate
    the `users` collection? The answer is to use a container component that makes
    the API call and then renders the `UserList` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Let's take a look at the `render()` method. It's job is to render the `<UserList>`
    component, passing in `this.state` as properties. The actual API call happens
    in the `componentDidMount()` method. This method is called after the component
    is mounted into the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: Due to the naming of `componentDidMount()`, React developers think that it's
    bad to wait until the component is mounted to the DOM before issuing requests
    for component data. In other words, the user experience might suffer if React
    has to perform a lot of work before the request is even sent. In reality, fetching
    data is an asynchronous task and initiating it before or after `render()` makes
    no real difference as far as your application is concerned.
  prefs: []
  type: TYPE_NORMAL
- en: You can read more about this here: [https://reactjs.org/blog/2018/03/27/update-on-async-rendering.html](https://reactjs.org/blog/2018/03/27/update-on-async-rendering.html)
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the API call returns with data, the `users` collection is populated, causing
    the `UserList` to re-render itself, only this time, it has the data it needs. Let''s
    take a look at the `users()` mock API function call used here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: It returns a promise that's resolved with an array after 2 seconds. Promises
    are a good tool for mocking things like API calls because they enable you to use
    more than HTTP calls as a data source in your React components. For example, you
    might be reading from a local file or using a library that returns promises that
    resolve data from various sources.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s what the `UserList` component renders when the `loading` state is a
    string, and the `users` state is an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/96766a75-d06b-4aa7-bd38-854a10e61098.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here''s what it renders when `loading` is `null` and `users` is non-empty:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/e2a88063-51bf-4331-b5cc-544e7d75ea7b.png)'
  prefs: []
  type: TYPE_IMG
- en: I want to reiterate the separation of responsibilities between the `UserListContainer`
    and the `UserList` components. Because the container component handles the lifecycle
    management and the actual API communication, you can create a generic user list
    component. In fact, it's a functional component that doesn't require any state,
    which means you can reuse it in other container components throughout your application.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing state with properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The preceding example showed you how to initialize the state of a container
    component by making an API call in the `componentDidMount()` lifecycle method.
    However, the only populated part of the component state is the `users` collection.
    You might want to populate other pieces of state that don't come from API endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the `error` and `loading` state messages have default values set
    when the state is initialized. This is great, but what if the code that is rendering
    `UserListContainer` wants to use a different loading message? You can achieve
    this by allowing properties to override the default state. Let''s build on the
    `UserListContainer` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `loading` property no longer has a default string value. Instead, `defaultProps` provides
    default values for properties. The new lifecycle method is `getDerivedStateFromProps()`.
    It uses the `loading` property to set the `loading` state the state. Since the
    `loading` property has a default value, it's safe to just change the state. The
    method is called before the component mounts and on subsequent re-renders of the
    component.
  prefs: []
  type: TYPE_NORMAL
- en: This method is static because of internal changes in React 16\. The expectation
    is that this method behaves like a pure function and has no side-effects. If this
    method were an instance method, you would have access to the component context
    and side-effects would be commonplace.
  prefs: []
  type: TYPE_NORMAL
- en: The challenge with this new React 16 method is that it's called on initial render
    and on subsequent re-renders. Prior to React 16, you could use the `componentWillMount()`
    method for code that you only want to run prior to the initial render. In this
    example, you have to check whether there are values in the `users` collection
    before setting the `loading` state to null – you don't know if this is the initial
    render or the 40th render.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how we can pass state data to `UserListContainer` now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s what the initial loading message looks like when `UserList` is first
    rendered:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/70f311e6-6a6c-4c1f-8d6c-dcd3eb3496c3.png)'
  prefs: []
  type: TYPE_IMG
- en: Just because the component has state doesn't mean that you can't allow for customization.
    Next, you'll learn a variation on this concept—updating component state with properties.
  prefs: []
  type: TYPE_NORMAL
- en: Updating state with properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You've seen how the `componentDidMount()` and `getDerivedStateFromProps()` lifecycle
    methods help get your component the data it needs. There's one more scenario that
    you need to consider—re-rendering the component container.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at a simple `button` component that tracks the number of
    times it''s been clicked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s implement a container component for this feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The same approach as the preceding example is used here. The `getDerivedStateFromProps()`
    method is called before every render and this is where you can use prop values
    to figure out if and how the component state should be updated. Let''s see how
    to re-render this component and whether or not the state behaves as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Sure enough, everything goes as planned. Whenever the button is clicked, the
    click counter is updated. `<MyFeature>` is re-rendered every 3 seconds, toggling
    the `disabled` state of the button. When the button is re-enabled and clicking
    resumes, the counter continues from where it left off.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is what the `MyButton` component looks like when first rendered:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/81a1ef60-a155-482b-aa83-29f6abb95d2b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here''s what it looks like after it has been clicked a few times and the button
    has moved into a disabled state:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/da9f9124-eb36-41c7-b4bb-beb8438a46c6.png)'
  prefs: []
  type: TYPE_IMG
- en: Optimize rendering efficiency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next lifecycle method you're going to learn about is used to implement heuristics
    that improve component rendering performance. You'll see that if the state of
    a component hasn't changed, then there's no need to render. Then, you'll implement
    a component that uses specific metadata from the API to determine whether or not
    the component needs to be re-rendered.
  prefs: []
  type: TYPE_NORMAL
- en: To render or not to render
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `shouldComponentUpdate()` lifecycle method is used to determine whether
    or not the component will render when asked to. For example, if this method were
    implemented, and returned false, the entire lifecycle of the component is short-circuited,
    and no render happens. This can be an important check to have in place if the
    component is rendering a lot of data and is re-rendered frequently. The trick
    is knowing whether or not the component state has changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the beauty of immutable data—you can easily check if it has changed.
    This is especially true if you''re using a library such as `Immutable.js` to control
    the state of the component. Let''s take a look at a simple list component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `items` state is initialized to an `Immutable.js` `List` with `5000` items
    in it. This is a fairly large collection, so you don't want the virtual DOM inside
    React to constantly diff this list. The virtual DOM is efficient at what it does,
    but not nearly as efficient as code that can perform a simple should or shouldn't
    render check. The `shouldComponentRender()` method that you've implemented here
    does exactly that. It compares the new state with the current state; if they're
    the same object, completely sidestep the virtual DOM.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s put this component to work and see what kind of efficiency gains
    you get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'You''re rendering `<MyList>`, over and over, in a loop. Each iteration has
    5,000 list items to render. Since the state doesn''t change, the call to `shouldComponentUpdate()`
    returns `false` on every one of these iterations. This is important for performance
    reasons, because there are a lot of them. You''re not going to have code that
    re-renders a component in a tight loop, in a real application. This code is meant
    to stress the rendering capabilities of React. If you were to comment out the
    `shouldComponentUpdate()` method, you''d see what I mean. Here''s what the performance
    profile looks like for this component:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/1ade8d3e-1c1c-4b04-80df-f819ab16b356.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The initial render takes the longest—a few hundred milliseconds. But then you
    have all of these tiny time slices that are completely imperceptible to the user
    experience. These are the result of `shouldComponentUpdate()` returning false.
    Let''s comment out this method now and see how this profile changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/703a99d7-f415-4b53-9187-3dac6cf212be.png)'
  prefs: []
  type: TYPE_IMG
- en: Without `shouldComponentUpdate()`, the end result is much larger time slices
    with a drastically negative impact on user experience.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may notice that we''re actually changing state using `setIn()` on the `Immutable.js` map.
    This should result in a state change, right? This will actually return the same
    `Immutable.js` instance for the simple reason that the value we''ve set is the
    same as the current value: `0`. When no change happens, `Immutable.js` methods
    return the same object, since it didn''t mutate.'
  prefs: []
  type: TYPE_NORMAL
- en: Using metadata to optimize rendering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, you''ll learn how to use metadata that''s part of the API
    response to determine whether or not the component should re-render itself. Here''s
    a simple user details component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `shouldComponentUpdate()` method is comparing the new `modified` state to
    the old `modified` state. This code makes the assumption that the `modified` value
    is a date that reflects when the data returned from the API was actually modified.
    The main downside to this approach is that the `shouldComponentUpdate()` method
    is now tightly coupled with the API data. The advantage is that you get a performance
    boost in the same way that you would with immutable data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how this heuristic looks in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `MyUser` component is now entirely dependent on the `modified` state. If
    it's not greater than the previous `modified` value, no render happens.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s what the component looks like after it''s been rendered twice:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/3d9f4de2-3f1b-4acf-87f7-dac82c2e2a53.png)In this example, I didn''t
    use immutable state data. Throughout this book, I''ll use plain JavaScript objects
    as state for simple examples. `Immutable.js` is a great tool for this job, so
    I''ll be using it a lot. At the same time, I want to make it clear that `Immutable.js`
    doesn''t need to be used in every situation.'
  prefs: []
  type: TYPE_NORMAL
- en: Rendering imperative components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Everything you''ve rendered so far in this book has been straightforward declarative
    HTML. Life is never so simple: sometimes your React components need to implement
    some imperative code under the covers.'
  prefs: []
  type: TYPE_NORMAL
- en: This is the key—hiding the imperative operations so that the code that renders
    your component doesn't have to touch it. In this section, you'll implement a simple
    jQuery UI button React component so that you can see how the relevant lifecycle
    methods help you to encapsulate imperative code.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering jQuery UI widgets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The jQuery UI widget library implements several widgets on top of standard HTML.
    It uses a progressive enhancement technique whereby the basic HTML is enhanced
    in browsers that support newer features. To make these widgets work, you first
    need to render HTML into the DOM somehow; then, make imperative function calls
    to create and interact with the widgets.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, you''ll create a React button component that acts as a wrapper
    around the jQuery UI widget. Anyone using the React component shouldn''t need
    to know that behind the scenes, it''s making imperative calls to control the widget.
    Let''s see what the button component looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The jQuery UI button widget expects a `<button>` element, so this is what's
    rendered by the component. An `onClick()` handler from the component props is
    assigned as well. There's also a `ref` property used here, which assigns the `button`
    argument to `this.button`. The reason this is done is so that the component has
    direct access to the underlying DOM element of the component. Generally, components
    don't need access to any DOM elements, but here, you need to issue imperative
    commands to the element.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in the `componentDidMount()` method,  the `button()` function
    is called and passes it properties from the component. The `componentDidUpdate()`
    method does something similar, which is called when property values change. Now,
    let''s take a look at the button container component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: You have a container component that controls the state, which is then passed
    to `<MyButton>` as properties.
  prefs: []
  type: TYPE_NORMAL
- en: The `{...data}` syntax is called JSX spread attributes. This allows you to pass
    objects to elements as attributes. You can read more about this feature here.
  prefs: []
  type: TYPE_NORMAL
- en: 'The component has a default `onClick()` handler function. But, you can pass
    a different click handler in as a property. Additionally, it''s automatically
    bound to the component context, which is useful if the handler needs to change
    the button state. Let''s look at an example of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, you have three jQuery UI button widgets, each controlled by a React component
    with no imperative code in sight. Here''s how the buttons look:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/3ef4d930-c2a8-4938-ba32-055e764f300d.png)'
  prefs: []
  type: TYPE_IMG
- en: Cleaning up after components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you'll learn how to clean up after components. You don't have
    to explicitly unmount components from the DOM—React handles that for you. There
    are some things that React doesn't know about and therefore cannot clean up for
    you after the component is removed.
  prefs: []
  type: TYPE_NORMAL
- en: It's for these types of cleanup tasks that the `componentWillUnmount()` lifecycle
    method exists. One use case for cleaning up after React components is asynchronous
    code.
  prefs: []
  type: TYPE_NORMAL
- en: For example, imagine a component that issues an API call to fetch some data
    when the component is first mounted. Now, imagine that this component is removed
    from the DOM before the API response arrives.
  prefs: []
  type: TYPE_NORMAL
- en: Cleaning up asynchronous calls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If your asynchronous code tries to set the state of a component that has been
    unmounted, nothing will happen. A warning will be logged, and the state isn't
    set. It's actually very important that this warning is logged; otherwise, you
    would have a hard time trying to solve subtle race condition bugs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The correct approach is to create cancellable asynchronous actions. Here''s
    a modified version of the `users()` API function that you implemented earlier
    in the chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The trick is the `cancellable()` function, which wraps a promise with a new
    promise. The new promise has a `cancel()` method, which rejects the promise if
    called. It doesn't alter the actual asynchronous behavior that the promise is
    synchronizing. However, it does provide a generic and consistent interface for
    use within React components.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s take a look at a container component that has the ability to cancel
    asynchronous behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `onClickCancel()` handler actually replaces the user list. This calls the
    `componentWillUnmount()` method, where you can cancel `this.job`. It's also worth
    noting that when the API call is made in `componentDidMount()`, a reference to
    the promise is stored in the component. This is necessary otherwise you would
    have no way to cancel the async call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s what the component looks like when rendered during a pending API call:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/98f270e9-d5a8-4163-8080-aba152c213eb.png)'
  prefs: []
  type: TYPE_IMG
- en: Containing errors with error boundaries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A new feature of React 16 – **error boundaries** – lets you handle unexpected
    component failures. Rather than have every component of your application know
    how to deal with any errors that it might encounter, **error boundaries** are
    a mechanism that you can use to wrap components with error-handling behavior.
    The best way to think of error boundaries is as `try`/`catch` syntax for JSX.
  prefs: []
  type: TYPE_NORMAL
- en: Let's revisit the first example from this chapter where you fetched component
    data using an API function. The `users()` function accepts a Boolean argument,
    which, when true, causes the promise to reject. This is something that you'll
    want to handle, but not necessarily in the component that made the API call. In
    fact, the `UserListContainer` and `UserList` components are already set up to
    handle API errors like this. The challenge is that if you have lots of components,
    this is a lot of error handling code. Further, the error handling is specific
    to that one API call – what if something else goes wrong?
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the modified source for `UserListContainer` that you can use for this
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This component is mostly the same as it was in the first example. The first
    difference is the call to `users()` where it''s now passing true:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This call will fail, resulting in the error state being set. The second difference
    is in the `render()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Instead of forwarding the error state onto the `UserList` component, it's passing
    the error back to the component tree by throwing an error instead of attempting
    to render more components. The key design change here is that this component is
    now making the assumption that there is some sort of error boundary in place further
    up in the component tree that will handle these errors accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: You might be wondering why the error is thrown in render instead of being thrown
    when the promise is rejected in `componentDidMount()`. The problem is that fetching
    data asynchronously like this means that there's no way for the React internals
    to actually catch exceptions that are thrown from within async promise handlers.
    The easiest solution for asynchronous actions that could cause a component to
    fail is to store the error in the component state, but to throw the error before
    actually rendering anything if it's there.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s create the error boundary itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This is where the `componentDidCatch()` lifecycle method is utilized by setting
    the error state of this component when it catches an error. When it's rendered,
    an error message is rendered if the `error` state is set. Otherwise, render the
    child components as usual.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how you can use this `ErrorBoundary` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Any errors that are thrown by `UserListContainer` or any of its children will
    be caught and handled by `ErrorBoundary`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/cba62616-0a38-4e25-93ca-d2bc108b927f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now you can remove the argument that''s passed to `users()` in `UserListContainer`
    to stop it from failing. In the `UserList` component, let''s say that you have
    an error that tries to call `toUpperCase()` on a number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ll get a different error thrown, but since it''s under the same boundary
    as the previous error, it''ll be handled the same way:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/6a30a766-067f-4b42-a24a-d7bdb6cfb950.png)If you''re running your
    project with `create-react-app` and `react-scripts`, you might notice an error
    overlay for every error in your application, even those that are handled by error
    boundaries. If you close the overlay using the **x** in the top right, you can
    see how your component handles the error in your app.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned a lot about the lifecycle of React components.
    We started things off with a discussion on why React components need a lifecycle
    in the first place. It turns out that React can't do everything automatically
    for us, so we need to write some code that's run at the appropriate time during
    the components' lifecycles.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you implemented several components that were able to fetch their initial
    data and initialize their state from JSX properties. Then, you learned how to
    implement more efficient React components by providing a `shouldComponentRender()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: You learned how to hide the imperative code that some components need to implement
    and how to clean up after asynchronous behavior. Finally, you learned how to use
    the new error boundary functionality from React 16.
  prefs: []
  type: TYPE_NORMAL
- en: In the following chapter, you'll learn techniques that help to ensure that your
    components are being passed the right properties.
  prefs: []
  type: TYPE_NORMAL
- en: Test your knowledge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Is `render()` a lifecycle method?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Yes, `render()` is no different from any other lifecycle method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: No, `render()` is simply called to get the content of the component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following is a valid use of the `componentWillUnmount()` method?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do delete DOM elements that were added by the component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To cancel an asynchronous action that will fail if the component us unmounted.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To log that the component is about to unmount.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which lifecycle method is used by an error boundary component?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`componentDidCatch()`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`componentWillCatch()`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`componentError()`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further Reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can visit following links for more information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://reactjs.org/docs/react-component.html](https://reactjs.org/docs/react-component.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://reactjs.org/docs/state-and-lifecycle.html](https://reactjs.org/docs/state-and-lifecycle.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
