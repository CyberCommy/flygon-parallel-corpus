- en: Functional and Nonfunctional Requirements
  prefs: []
  type: TYPE_NORMAL
- en: As an architect, it is important for you to recognize which requirements are
    significant for the architecture and why. This chapter will teach you about the
    various requirements of a solution—functional and nonfunctional. Functional requirements
    are those that tell you what your solution should do. On the other hand, nonfunctional
    ones are those that tell you how your solution should be*.*
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the types of requirements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recognizing architecturally significant requirements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gathering requirements from various sources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documenting requirements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documenting architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choosing the right views to document
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating documentation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have learned how to recognize and categorize
    both types of requirements and how to create documentation that describes them
    in a clear manner.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements documentation from sources, you must have
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To replicate our steps to generate documentation from sources, you must have
    CMake, Doxygen, Sphinx, m2r2 and Breathe installed. We're using the ReadTheDocs
    Sphinx theme, so please install it as well. Feel free to use the latest versions
    of the tools mentioned.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the related code at [https://github.com/PacktPublishing/Software-Architecture-with-Cpp/tree/master/Chapter03](https://github.com/PacktPublishing/Software-Architecture-with-Cpp/tree/master/Chapter03).
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the types of requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While creating a software system, you should constantly ask yourself whether
    what you''re making is what your customers need. Many times, they won''t even
    know what requirement fulfills their needs best. It''s the role of a successful
    architect to discover the requirements of the product and to make sure they are
    being met. There are three distinct types of requirements that you need to consider:
    functional requirements, quality attributes, and constraints. Let''s have a look
    at each of these.'
  prefs: []
  type: TYPE_NORMAL
- en: Functional requirements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first group is the functional requirements. These are the ones that define
    what your system should do, or what functionality it should offer.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that functionality does not always influence architecture, so you'll
    have to keep an eye on which of those requirements will actually dictate what
    your solution will look like.
  prefs: []
  type: TYPE_NORMAL
- en: 'Often, if a functional requirement has some qualities that must be met, it
    can become architecturally significant. Consider an app for merchants and visitors
    of the Dominican Fair, an annual event with music, various arts, and shops, happening
    in the city of Gdańsk. A few examples of functional requirements for it could
    be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*As a shopkeeper, I want to filter orders that contain a specific product.*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Clicking the Subscribe button adds the customer to a list of notified watchers
    of a selected merchant.*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first of those requirements tells us we'll have to have a component for
    tracking orders and products with search capabilities. Depending on how exactly
    the UI should appear and what scale our app should be, we could just add a simple
    page to our app, or it could require features such as Lucene or Elasticsearch.
    This means that we could be looking at an **Architecturally Significant Requirement**
    (**ASR**), one that can influence our architecture.
  prefs: []
  type: TYPE_NORMAL
- en: The second example is even more straightforward; now we know we need to have
    a service for subscribing and sending notifications. This is definitely an architecturally
    significant functional requirement. Let's now look at some **Non-Functional Requirements**
    (**NFRs**) that can also be ASRs.
  prefs: []
  type: TYPE_NORMAL
- en: 'By the way, the first requirement is actually given as a user story. User stories
    are requirements given in the following format: "*As a <role>, I can/want to <capability>,
    so that <benefit>*." This is a common way to phrase requirements and can help
    stakeholders and developers find common ground and communicate better.'
  prefs: []
  type: TYPE_NORMAL
- en: Nonfunctional requirements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Instead of focusing on what functionality your system should have, nonfunctional
    requirements focus on how well and under which conditions the system should perform
    said functionality. This group consists of two main subgroups: **Quality Attributes**
    (**QAs**) and **constraints**.'
  prefs: []
  type: TYPE_NORMAL
- en: Quality attributes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Quality** **attributes** (**QAs**) are the traits of your solution, such
    as performance, maintainability, and user-friendliness. There are dozens, if not
    hundreds, of different qualities your software can have. Try to focus just on
    the important ones instead of listing all that come to your mind when choosing
    which ones your software should have. Examples of quality attribute requirements
    include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The system will respond in under 500 ms for 99.9% of all requests under usual
    load (don't forget to specify what the usual load is or will be).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The website will not store customer credit card data used in the payment process
    (an example of confidentiality).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When updating the system, if updating any component fails, the system will be
    rolled back to a state prior to the update (survivability).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a user of Windows, macOS, and Android, I want to be able to use the system
    from all of them (portability; try to understand whether it's needed to support
    platforms such as desktop, mobile, and/or web).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'While catching functional requirements in a backlog is pretty straightforward,
    we cannot say the same regarding quality attribute requirements. Fortunately,
    there are a few ways you could approach this:'
  prefs: []
  type: TYPE_NORMAL
- en: Some of them can be expressed in the **Definition of done** or **Acceptance
    criteria** for your tasks, stories, and releases.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Others can be expressed directly as user stories, as shown in the last example
    previously.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can also check them as part of design and code reviews and create automated
    tests for some of them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constraints
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Constraints are the non-negotiable decisions that you must follow while delivering
    the project. Those can be design decisions, technological ones, or even political
    (regarding people or organizational matters). Two other common constraints are
    **time** and **budget**. Examples of constraints could be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*The team will never grow beyond four developers, one QA engineer, and one
    sysadmin.*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Since our company leverages Oracle DB in all its current products, the new
    product must use it too so we can make the most of our expertise.*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: nonfunctional requirements are always going to influence your architecture.
    It's essential not to over-specify them, as having *false positives* will be a
    constant burden during product development. It's equally important to not under-specify
    them as this can later come out in missed sales opportunities or failing to comply
    with regulatory bodies' requirements.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you will learn how to strike a balance between those two
    extremes and to focus on just those requirements that really matter in your specific
    case.
  prefs: []
  type: TYPE_NORMAL
- en: Recognizing architecturally significant requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When designing a software system, it's common to deal with dozens or hundreds
    of various requirements. In order to make sense of them and come up with a good
    design, you need to know which of them are important and which could be implemented
    regardless of your design decisions, or even dismissed. You should learn how to
    recognize the most important ones so you can focus on them first and deliver the
    most value in the shortest possible time.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should prioritize requirements using two metrics: the business value and
    the impact on architecture. Those that will be high on both scales are most important
    and should be dealt with as a matter of priority. If you come up with too many
    such requirements, you should revisit your prioritization scheme. If it doesn''t
    help, it might be that the system just isn''t achievable.'
  prefs: []
  type: TYPE_NORMAL
- en: ASRs are those that have a measurable impact on your system's architecture.
    They can be both functional and nonfunctional. How can you identify which ones
    are actually significant? If the absence of a specific requirement were to allow
    you to create a different architecture, you are looking at an ASR. Late discovery
    of such requirements will often cost you both time and money, as you'll need to
    redesign some part of your system, if not the whole solution. You can only hope
    it won't cost you other resources and your reputation, too.
  prefs: []
  type: TYPE_NORMAL
- en: It's a common mistake to start by applying concrete technologies to your architecture
    from the very beginning of your architectural work. We strongly suggest that you
    first gather all the requirements, focus on the ones significant for the architecture,
    and only then decide what technologies and technology stacks to build your project
    on.
  prefs: []
  type: TYPE_NORMAL
- en: Since it's that important to recognize ASRs, let's talk about a few patterns
    that can help you with this.
  prefs: []
  type: TYPE_NORMAL
- en: Indicators of architectural significance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you have a requirement to integrate with any external system, this is most
    likely going to influence your architecture. Let''s go through some common indicators
    that a requirement is an ASR:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Needing to create a software component to handle it**: Examples include sending
    emails, pushing notifications, exchanging data with the company''s SAP server,
    or using a specific data storage.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Having a significant impact on the system**: Core functionality often defines
    what your system should look like. Cross-cutting concerns, such as authorization,
    auditability, or having transactional behavior, are other good examples.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Being hard to achieve**: Having low latency is a great example: unless you
    think of it early in development, it can be a long battle to achieve it, especially
    if you suddenly realize you can''t really afford to have garbage collections when
    you''re on your hot path.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Forcing trade-offs when satisfying certain architectures**: Perhaps your
    design decision will even need to compromise some requirements in favor of other,
    more important ones if the cost is too high. It''s a good practice to log such
    decisions somewhere and to notice that you''re dealing with ASRs here. If any
    requirement constrains you or limits the product in any way, it''s very likely
    significant for the architecture. If you want to come up with the best architecture
    given many trade-offs, then be sure to read about the **Architecture Trade-off
    Analysis Method** (**ATAM**), which you can read about under one of the links
    in the *Further reading* section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constraints and the environment your application will run in can also impact
    your architecture. Embedded apps need to be designed in a different way to those
    running in the cloud, and apps being developed by less-experienced developers
    should probably use a simple and safe framework instead of using one with a steep
    learning curve or developing their own.
  prefs: []
  type: TYPE_NORMAL
- en: Hindrances in recognizing ASRs and how to deal with them
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Contrary to intuition, many architecturally significant requirements are difficult
    to spot at first glance. This is caused by two factors: they can be hard to define
    and even if they''re described, this can be done vaguely. Your customers might
    not yet be clear about what they need, but you should still be proactive in asking
    questions to steer clear of any assumptions. If your system is to send notifications,
    you must know whether those are real time or whether a daily email will suffice,
    as the former could require you to create a publisher-subscriber architecture.'
  prefs: []
  type: TYPE_NORMAL
- en: In most cases, you'll need to make some assumptions since not everything is
    known upfront. If you discover a requirement that challenges your assumptions,
    it might be an ASR. If you assume you can maintain your service between 3 a.m.
    and 4 a.m. and you realize your customers from a different time zone will still
    need to use it, it will challenge your assumption and likely change the product's
    architecture.
  prefs: []
  type: TYPE_NORMAL
- en: What's more, people often tend to treat quality attributes vaguely during the
    earlier phases of projects, especially less-experienced or less-technical individuals.
    On the other hand, that's the best moment to address such ASRs, as the cost of
    implementing them in the system is the lowest.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s worth noting, however, that many people, when specifying requirements,
    like to use vague phrases without actually thinking it through. If you were designing
    a service similar to Uber, some examples could be: *when receiving a DriverSearchRequest,
    the system must reply with an AvailableDrivers message fast*, or *the system must
    be available 24/7*.'
  prefs: []
  type: TYPE_NORMAL
- en: Upon asking questions, it often turns out that 99.9% monthly availability is
    perfectly fine, and *fast* is actually a few seconds. Such phrases always require
    clarification, and it's often valuable to know the rationale behind them. Perhaps
    it is just someone's subjective opinion, not backed by any data or business needs.
    Also, note that in the request and response case, the quality attribute is hidden
    inside another requirement, making it even harder to catch.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, requirements being architecturally significant for one system aren't
    necessarily of the same importance to another, even if those systems serve similar
    purposes. Some will become more important over time, once the system grows and
    starts to communicate with more and more other systems. Others may become important
    once the needs for the product change. This is why there's no silver bullet in
    telling which of your requirements will be ASRs, and which won't.
  prefs: []
  type: TYPE_NORMAL
- en: Equipped with all this knowledge on how to distinguish the important requirements
    from the rest, you know *what* to look for. Let's now say a few words about *where*
    to look.
  prefs: []
  type: TYPE_NORMAL
- en: Gathering requirements from various sources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you know what requirements to focus on, let's discuss a few techniques
    for gathering these requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing the context
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When mining requirements, you should take into account the broader context.
    You must identify what potential problems may have a negative impact on your product
    in the future. Those risks often come from the outside. Let''s revisit our Uber-like
    service scenario. An example risk for your service could be a potential change
    in legislation: you should be aware that some countries may try to change the
    law to remove you from their market. Uber''s way to mitigate those risks is to
    have local partners cope with regional limitations.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Future risks aside, you must also be aware of current issues, such as the lack
    of subject matter experts in the company, or heavy competition on the market.
    Here''s what you can do:'
  prefs: []
  type: TYPE_NORMAL
- en: Be aware of and note any assumptions being made. It's best to have a dedicated
    document for tracking those.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ask questions to clarify or eliminate your assumptions, if possible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You need to consider the dependencies inside your project, as they can influence
    the development schedule. Other useful areas are the business rules that shape
    the day-to-day behavior of the company, as your product will likely need to adhere
    to and possibly enhance those.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moreover, if there's enough data relating to the users or the business, you
    should try to mine it to get insights and find useful patterns that can help with
    making decisions regarding the future product and its architecture. If you already
    have some users but are unable to mine data, it's often useful to just observe
    how they behave.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ideally, you could record them when they perform their daily tasks using the
    currently deployed systems. This way, you could not only automate parts of their
    work but also change their workflow to a more efficient one entirely. However,
    remember that users don't like changing their habits, so it's better to introduce
    changes gradually where possible.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing existing documentation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Existing documents can be a great source of information, even though they can
    also have their issues. You should reserve some time to at least get familiar
    with all the existing documents related to your work. Chances are that there are
    some requirements hidden in them. On the other hand, keep in mind that the documentation
    is never perfect; highly likely it will lack some significant information. You
    should also be prepared for it to be outdated. There is never one source of truth
    when it comes to architecture, so aside from reading documents, you should have
    lots of discussions with the people involved. Nonetheless, reading documents can
    be a great way of preparing yourself for such discussions.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing your stakeholders
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To be a successful architect, you must learn to communicate with business people
    as requirements come, directly or indirectly, from them. Whether they''re from
    your company or a customer, you should get to know the context of their business.
    For instance, you must know the following:'
  prefs: []
  type: TYPE_NORMAL
- en: What drives the business?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What goals does the company have?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What specific objectives will your product help to achieve?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once you are aware of this, it will be much easier to establish a common ground
    with many people coming from management or executives, as well as gathering more
    specific requirements regarding your software. If the company cares about the
    privacy of its users, for instance, it can have a requirement to store as little
    data about its users as possible and to encrypt it using a key stored only on
    a user's device. Often, if such requirements come from the company culture, it
    will be too obvious for some employees to even articulate them. Knowing the context
    of the business can help you to ask proper questions and help the company in return.
  prefs: []
  type: TYPE_NORMAL
- en: Having said that, remember that your stakeholders can, and will, have needs
    that aren't necessarily directly reflected in the company's objectives. They can
    have their own ideas for functionality to provide or metrics that the software
    should achieve. Perhaps a manager promised his employees a chance to learn a new
    technology or work with a specific one. If this project is important for their
    career, they can be a strong ally and even convince others as to your decisions.
  prefs: []
  type: TYPE_NORMAL
- en: Another important group of stakeholders is the people responsible for deploying
    your software. They can come with their own subgroup of needs, called transition
    requirements. Examples of those include user and database migration, infrastructure
    transition, or data conversion, so don't forget to reach out to them to gather
    these as well.
  prefs: []
  type: TYPE_NORMAL
- en: Gathering requirements from stakeholders
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At this point, you should have a list of stakeholders with their roles and
    contact information. Now it''s time to make use of it: be sure to make time to
    talk with each stakeholder about what they need from the system and how they envision
    it. You can hold interviews such as 1:1 meetings or group ones. When talking with
    your stakeholders, help them to make informed decisions – show the potential outcomes
    of their answers on the end product.'
  prefs: []
  type: TYPE_NORMAL
- en: It's common for stakeholders to say that all of their requirements are equally
    important. Try to persuade them to prioritize their requirements according to
    the value they bring to their business. Certainly, there will be some mission-critical
    requirements, but most probably, the project won't fail if a bunch of others won't
    be delivered, not to mention any nice-to-haves that will land on your requirements
    wish list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Aside from interviews, you can also organize workshops for them, which could
    work like brainstorming sessions. In such workshops, once the common ground is
    established and everybody knows why they''re taking part in such a venture, you
    can start asking everyone for as many usage scenarios as they can think of. Once
    these have been established, you can proceed with consolidating similar ones,
    after which you should prioritize and, finally, refine all the stories. Workshops
    are not just about functional requirements; each usage scenario can have a quality
    attribute assigned as well. After refining, all the quality attributes should
    be measurable. The final thing to note is this: you don''t need to bring all stakeholders
    into such events, as they can sometimes take more than a day, depending on the
    size of the system.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know how to mine for requirements using various techniques and
    sources, let's discuss how to pour your findings into well-crafted documents.
  prefs: []
  type: TYPE_NORMAL
- en: Documenting requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once you're done with the steps described previously, it's time to put all the
    requirements you've gathered and refine them together in a single document. It
    doesn't matter what form the document will take and how you will manage it. What
    matters is that you have a document that puts all the stakeholders on the same
    page with regard to what is required from the product and what value each requirement
    brings.
  prefs: []
  type: TYPE_NORMAL
- en: Requirements are produced and consumed by all stakeholders, and a broad set
    of them will need to read your document. This means that you should write it so
    that it brings value for people of various technical skills from customers, salespeople,
    and marketers, through designers and project managers, to software architects,
    developers, and testers.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes it makes sense to prepare two versions of the document, one for the
    people closest to the business side of the project, and another, a more technical
    one, for the development team. However, usually, it's enough to just have one
    document written to be understandable by everyone, with sections (sometimes single
    paragraphs) or whole chapters meant to cover the more technical details.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now take a tour of what sections could go into your requirements document.
  prefs: []
  type: TYPE_NORMAL
- en: Documenting the context
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A requirements document should act as one of the entry points for people getting
    on board with your project: it should outline the purpose of your product, who
    will use it, and how it can be used. Before design and development, the product
    team members should read it to have a clear idea of what they''ll actually work
    on.'
  prefs: []
  type: TYPE_NORMAL
- en: The context section should provide an overview of the system – why it's being
    built, what business goals is it trying to accomplish, and what key functionality
    it will deliver.
  prefs: []
  type: TYPE_NORMAL
- en: You can describe a few typical user personas, such as *John the CTO*, or *Ann
    the driver*, to give the readers a better chance to think about the users of the
    system as actual human beings and know what to expect from them.
  prefs: []
  type: TYPE_NORMAL
- en: All those things described in the *Knowing the context* section should also
    be summarized as parts of this context section, or sometimes even given separate
    sections in the document. The context and scope sections should provide all the
    information required by most non-project stakeholders. They should be concise
    and precise.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same goes for any open questions you may want to research and decide on
    later. For each decision you make, it''s best to note the following:'
  prefs: []
  type: TYPE_NORMAL
- en: What the decision itself was
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Who made it and when
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What rationale stands behind it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that you know how to document the context of your project, let's learn how
    to properly describe its scope too.
  prefs: []
  type: TYPE_NORMAL
- en: Documenting the scope
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This section should define what's in the scope of the project, as well as what
    is beyond the scope. You should provide a rationale for why the scope is defined
    in a particular way, especially when writing about things that won't make the
    cut.
  prefs: []
  type: TYPE_NORMAL
- en: This section should also cover the high-level functional and nonfunctional requirements,
    but details should go into the subsequent sections of the document. If you're
    familiar with Agile practices, just describe epics and bigger user stories here.
  prefs: []
  type: TYPE_NORMAL
- en: If you or your stakeholders have any assumptions regarding the scope, you should
    mention those here. If the scope is subject to change due to any issues or risks,
    you should also write some words about it, and similarly for any trade-offs you
    had to make.
  prefs: []
  type: TYPE_NORMAL
- en: Documenting functional requirements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Each requirement should be precise and testable. Consider this example: "The
    system will have a ranking system for the drivers." How would you create tests
    against it? It''s better to create a section for the ranking system and specify
    the precise requirements for it there.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this other example: If there''s a free driver close to the rider,
    they should be notified of the incoming ride request. What if there''s more than
    one driver available? What maximum distance can we still describe as being *close*?'
  prefs: []
  type: TYPE_NORMAL
- en: This requirement is both imprecise and lacking parts of the business logic.
    We can only hope that the case where there are no free drivers is covered by another
    requirement.
  prefs: []
  type: TYPE_NORMAL
- en: 'In 2009, Rolls Royce developed its **Easy Approach to Requirements Syntax**
    (**EARS**), to help cope with this. In EARS, there are five basic types of requirements,
    which should be written in a different way and serve different purposes. They
    can be later combined to create more complex requirements. Those basic ones are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ubiquitous requirement**: "The `$SYSTEM` shall `$REQUIREMENT`," for example,
    the application will be developed in C++.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Event-driven**: "When `$TRIGGER $OPTIONAL\_PRECONDITION` the `$SYSTEM` shall
    `$REQUIREMENT`," for example, "When an order arrives, the gateway will produce
    a NewOrderEvent.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Unwanted behavior**: "If `$CONDITION`, then the `$SYSTEM` shall `$REQUIREMENT`,"
    for example if the processing of the request takes longer than 1 second, the tool
    will display a progress bar.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**State-driven**: "While `$STATE`, the `$SYSTEM` shall `$REQUIREMENT`," for
    example, while a ride is taking place, the app will display a map to help the
    driver navigate to the destination.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Optional feature**: "Where `$FEATURE`, the `$SYSTEM` shall `$REQUIREMENT`,"
    for example, where A/C is present, the app will let the user set the temperature
    through the mobile application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An example of a more complex requirement would be: When using a dual-server
    setup, if the backup server doesn''t hear from the primary one for 5 seconds,
    it should try to register itself as a new primary server.'
  prefs: []
  type: TYPE_NORMAL
- en: You don't need to use EARS, but it can help if you struggle with ambiguous,
    vague, overly complex, untestable, omissive, or otherwise badly worded requirements.
    Whatever way or wording you choose, be sure to use a concise model, which is based
    on common syntax and uses predefined keywords. It's also good practice to assign
    an identificator for each requirement you list, so you'll have an easy way to
    refer to them.
  prefs: []
  type: TYPE_NORMAL
- en: 'When it comes to more detailed requirements formats, it should have the following
    fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ID or Index**: To easily identify a specific requirement.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Title**: You can use the EARS template here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Detailed Description**: You can put whatever information you find relevant
    here, for example, user stories.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Owner**: Who this requirement serves. This can be the product owner, the
    sales team, legal, IT, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Priority**: Pretty self-explanatory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deliver By**: If this requirement is needed for any key date, you can note
    it here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we know how to document functional requirements, let's discuss how
    you should approach documenting the nonfunctional ones.
  prefs: []
  type: TYPE_NORMAL
- en: Documenting nonfunctional requirements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each quality attribute, such as performance or scalability, should have its
    own section in your document, with specific, testable requirements listed. Most
    of the QAs are measurable, so having specific metrics can do a world of good to
    resolve future questions. You can also have a separate section about the constraints
    that your project has.
  prefs: []
  type: TYPE_NORMAL
- en: With regard to wording, you can use the same EARS template to document your
    NFRs. Alternatively, you can also specify them as user stories using the personas
    that you defined in the context of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Managing the version history of your documentation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can take one of the two following approaches: either create a version log
    inside the document or use an external versioning tool. Both have their pros and
    cons, but we recommend going with the latter approach. Just like you use a version
    control system for your code, you can use it for your documentation. We''re not
    saying you must use a Markdown document stored in a Git repo, but that''s a perfectly
    valid approach as long as you''re also generating a **business people-readable**
    version of it, be it a web page or a PDF file. Alternatively, you can just use
    online tools, such as RedmineWikis, or Confluence pages, which allow you to put
    a meaningful comment describing what''s been changed on each edit you publish
    and to view the differences between versions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you decided to take a revision log approach, it''s usually a table that
    includes the following fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Revision**: A number identifying which iteration of the document the changes
    were introduced at. You can also add tags for special revisions, such as *the
    first draft*, if you so wish.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Updated by**: Who made the change.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reviewed by**: Who reviewed the change.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Change description**: A *commit message* for this revision. It states what
    changes have taken place.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documenting requirements in Agile projects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Many proponents of Agile would claim that documenting all the requirements
    is simply a waste of time as they will probably change anyway. However, a good
    approach is to treat them similarly to items in your backlog: the ones that will
    be developed in the upcoming sprints should be defined in more detail than the
    ones that you wish to implement later. Just like you won''t split your epics into
    stories and stories into tasks before it''s necessary, you can get away with having
    just roughly described, less granular requirements until you''re certain that
    you need them implemented.'
  prefs: []
  type: TYPE_NORMAL
- en: Note who or what was the source of a given requirement so that you'll know how
    who can provide you with necessary input for refining it in the future.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take our Dominican Fair, for example. Say in the next sprint, we''ll
    be building the shop page for a visitor to view, and in the sprint after that
    one, we''ll be adding a subscription mechanism. Our requirements could look like
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **ID** | **Priority** | **Description** | **Stakeholders** |'
  prefs: []
  type: TYPE_TB
- en: '| DF-42 | P1 | The shop''s page must show the shop''s inventory, with a photo
    and price for each item. | Josh, Rick |'
  prefs: []
  type: TYPE_TB
- en: '| DF-43 | P2 | The shop''s page must feature a map with the shop''s location.
    | Josh, Candice |'
  prefs: []
  type: TYPE_TB
- en: '| DF-44 | P2 | Customers must be able to subscribe to shops. | Steven |'
  prefs: []
  type: TYPE_TB
- en: As you can see, the first two items relate to the feature we'll be doing next.
    so they are described in more detail. Who knows, maybe before the next sprint,
    the requirement about subscriptions will be dropped, so it doesn't make sense
    to think about every detail of it.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are cases, on the other hand, that would still require you to have a
    complete list of requirements. If you need to deal with external regulators or
    internal teams such as auditing, legal, or compliance, chances are they''ll still
    require a well-written physical document from you. Sometimes just handing them
    a document containing work items extracted from your backlog is OK. It''s best
    to communicate with such stakeholders just like with any other ones: gather their
    expectations to know the minimum viable documentation that satisfies their needs.'
  prefs: []
  type: TYPE_NORMAL
- en: What's important about documenting requirements is to have an understanding
    between you and the parties proposing specific requirements. How can this be achieved?
    Once you have a draft ready to go, you should show your documentation to them
    and gather feedback. This way, you'll know what was ambiguous, unclear, or missing.
    Even if it takes a few iterations, it will help you have a common ground with
    your stakeholders, so you'll gain more confidence that you're building the right
    thing.
  prefs: []
  type: TYPE_NORMAL
- en: Other sections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It's a good idea to have a links and resources section in which you point to
    stuff such as the issue tracker boards, artifacts, CI, the source repo, and whatever
    else you'll find handy. Architectural, marketing, and other kinds of documents
    can also be listed here.
  prefs: []
  type: TYPE_NORMAL
- en: If needed, you can also include a glossary.
  prefs: []
  type: TYPE_NORMAL
- en: You now know how to document your requirements and related information. Let's
    now say a few words about documenting the designed system.
  prefs: []
  type: TYPE_NORMAL
- en: Documenting architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Just as you should document your requirements, you should also document the
    emerging architecture. It''s certainly not just for the sake of having documentation:
    it should help each person involved in the project to be more productive by making
    them better understand what''s required from them and from the final product.
    Not all diagrams you''ll make will be useful for everyone, but you should create
    them from the perspective of their future readers.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s a multitude of frameworks to document your vision and many of them
    serve specific fields, project types, or architectural scopes. If you''re interested
    in documenting enterprise architecture, for instance, you could be interested
    in TOGAF. This is an acronym for *The Open Group Architecture Framework*. It relies
    on four domains, namely the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Business architecture (strategy, organization, key processes, and governance)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data architecture (logical and physical data management)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application architecture (blueprints for individual systems)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical architecture (hardware, software, and network infrastructure)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Such grouping is useful if you document your software in the scope of the whole
    company or even broader ones. Other similar-scale frameworks include those developed
    by the **British Ministry of Defence** (**MODAF**) and the **American equivalent**
    (**DoDAF**).
  prefs: []
  type: TYPE_NORMAL
- en: If you're not documenting enterprise architectures, and especially if you're
    just starting on your architectural self-development path, you'll probably be
    more interested in other frameworks, such as the 4+1 and C4 models.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the 4+1 model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The 4+1 view model was created by Philippe Kruchten in 1995\. The author then
    claimed it is intended for "describing the architecture of software-intensive
    systems, based on the use of multiple, concurrent views." Its name comes from
    the views it consists of.
  prefs: []
  type: TYPE_NORMAL
- en: This model is widely known since it has been on the market for so long and does
    its job. It's well suited for bigger projects and while it can be used for small-
    and medium-sized ones as well, it can also turn out too complex for their needs
    (especially if they're written in an Agile way). If that's your case, you should
    try out the C4 model described in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: A downside to the 4+1 model is that it uses a fixed set of views, while a pragmatic
    approach to document architecture would be to choose views based on the specifics
    of your project (more on that later).
  prefs: []
  type: TYPE_NORMAL
- en: 'A nice upside, on the other hand, is how the views link together, especially
    when it comes to scenarios. At the same time, each stakeholder can easily get
    the parts of the model relevant to them. This brings us to how the model appears:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c00a75c2-c3b7-4b1e-a6dc-f0ed40f39339.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1 – An overview of the 4+1 model
  prefs: []
  type: TYPE_NORMAL
- en: 'Actors in the preceding diagram are the ones most interested in their corresponding
    views. All the views can be represented using different kinds of **Unified Modeling
    Language** (**UML**) diagrams. Let''s now discuss each view:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The logical view** shows how functionality is provided to users. It shows
    the system''s components (objects) and how they interact with each other. Most
    commonly, it consists of class and state diagrams. If you have thousands of classes
    or just want to better show the interactions between them, you should also have
    communication or sequence diagrams, both being parts of our next view:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/f5752842-53db-436d-9519-f63a178633c4.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.2 – Class diagrams can be used to show what types we plan to have,
    along with their relations
  prefs: []
  type: TYPE_NORMAL
- en: '**The process view** revolves around the system''s runtime behavior. It shows
    processes, the communication between them, and interactions with external systems.
    It''s represented by activity and interaction diagrams. This view addresses many
    NFRs, including concurrency, performance, availability, and scalability:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/3104e8d9-3c79-43e3-9c54-fc0f9afbdead.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.3 – Activity diagrams are graphical representations of workflows and
    processes
  prefs: []
  type: TYPE_NORMAL
- en: '**The development view** is for decomposing into subsystems and revolves around
    software organization. Reuse, tooling constraints, layering, modularization, packaging,
    execution environments – this view can represent them by showing a building-block
    decomposition of the system. It does so by using components and package diagrams:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/431900b8-0b52-46b0-9021-4e0e28341238.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.4 – Package diagrams can show the parts of a system from a higher perspective,
    as well as dependencies or relations between specific components
  prefs: []
  type: TYPE_NORMAL
- en: '**The physical view** is used to map software to hardware using deployment
    diagrams. Aimed at system engineers, it can cover a subset of NFRs concerned with
    the hardware, for example, communication:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/693cdedc-e843-429f-b544-d6d783b884c7.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.5 – Deployment diagrams demonstrate the hardware on which each software
    component will run. It can also be used to pass on information regarding the network
  prefs: []
  type: TYPE_NORMAL
- en: '**The scenarios** are gluing all the other views together. Represented by use
    case diagrams, these can be useful for all stakeholders. This view shows whether
    the system does what it should and that it is consistent. When all other views
    are finished, the scenario view can be redundant. However, all the other views
    wouldn''t be possible without usage scenarios. This view shows the system from
    a high level, while the other views go into the details:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/0b88b24d-e5b2-4655-a29c-c04eae0d2447.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.6 – Use case diagrams show how specific actors interact with the system
    and how the interactions relate to each other
  prefs: []
  type: TYPE_NORMAL
- en: 'Each of those views is interconnected with the others and often they must coexist
    to show the full picture. Let''s think about expressing concurrency. It can''t
    be done using only the logical view, as it''s more expressive to map them to tasks
    and processes; we need the process view. On the other hand, the processes will
    be mapped to physical, often distributed, nodes. This means we''ll need to effectively
    document it in three views, each of which will be relevant for a specific group
    of stakeholders. Other connections between the views include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Both logical and process views are used in analysis and design to conceptualize
    the product.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Development and deployment in conjunction describe how the software is packaged
    and when each package will get deployed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The logical and development views show how the functionality is reflected in
    the source code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The process and deployment views are meant to collectively describe NFRs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that you''re familiar with the 4+1 model, let''s discuss another one, which
    is simple, yet extremely effective: the C4 model. We hope using it will be a blast
    (pun intended).'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the C4 model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The C4 model is a great fit for small- to medium-sized projects. It's easy to
    apply, as it's quite simple and it doesn't rely on any predefined notation. If
    you want to start diagramming using it, you can try out Tobias Shochguertel's
    c4-draw.io plugin ([https://github.com/tobiashochguertel/c4-draw.io](https://github.com/tobiashochguertel/c4-draw.io))
    for the free online drawing tool – draw.io ([https://www.draw.io/](https://www.draw.io/)).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the C4 model, there are four main types of diagram, namely the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Context
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Just like zooming in and out using a map, you can use those four types to show
    more details of a particular code region or "zoom out" to show more about the
    interactions and surroundings of either a specific module or even the whole system.
  prefs: []
  type: TYPE_NORMAL
- en: 'The system context is a great starting point for looking at the architecture,
    as it shows the system as a whole, surrounded by its users and other systems that
    it interacts with. You can take a look at an example C4 context diagram here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a823121c-a913-44b9-a2fd-360ea2e9d2f0.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.7 – A C4 context diagram
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, it shows the "big picture," so it shouldn't focus on specific
    technologies or protocols. Instead, think of it as a diagram that could also be
    shown to non-technical stakeholders. Just by looking at the diagram, it should
    be clear that there's one actor involved (the human-shaped depiction of the customer),
    who interacts with one of the components of our solution, namely, the customer
    service system. This system, on the other hand, interacts with two more, with
    each of the interactions described along with the arrows.
  prefs: []
  type: TYPE_NORMAL
- en: 'The context diagram we described is used to provide an overview of the system
    with few details. Let''s now look at the other diagrams one by one:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Container diagram**: This one is for showing the overview of the system internals.
    If your system uses a database, offers services, or just consists of certain applications,
    this diagram will show it. It can also show the major technology choices for the
    containers. Note that containers don''t mean Docker containers; although each
    is a separately runnable and deployable unit, this diagram type is not about deployment
    scenarios. The container view is meant for technical people but isn''t limited
    to the development team only. Architects, as well as operations and support, are
    the intended audience, too.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Component diagram**: If you want more details about a specific container,
    this is where the component diagram comes into play. It shows how the components
    inside a selected container interact with each other, as well as with elements
    and actors outside the container. By looking at this diagram, you can learn about
    the responsibilities of each component and what technology it''s being built with.
    The intended audience for component diagrams is mostly focused around a specific
    container and consists of the development team and the architect.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Code diagrams**: We finally come to code diagrams, which emerge when you
    zoom in to a specific component. This view consists mostly of UML diagrams, including
    class, entity-relationship, and others, and ideally should be created automatically
    from source code by standalone tools and IDEs. You should definitely not make
    such diagrams for each component in your system; instead, focus on making them
    for the most important ones in a way that allows them to actually tell the reader
    what you wanted to tell. This means that less can be more in such diagrams, so
    you should omit unnecessary elements from code diagrams. In many systems, especially
    smaller ones, this class of diagram is omitted. The target audience is the same
    as in the case of component diagrams.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You may find the C4 model lacking some specific views. If you''re wondering
    how to demonstrate how your system should be deployed, for instance, you might
    be interested to learn that aside from the main diagrams, there are also a few
    supplementary ones. One of them is the deployment diagram, which you can see next.
    It shows how containers in your system are mapped to nodes in your infrastructure.
    In general, it''s a simpler version of UML''s deployment diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9f6c6238-84f2-4e82-b39c-d8852099b930.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.8 – A C4 deployment diagram
  prefs: []
  type: TYPE_NORMAL
- en: Speaking of UML diagrams with regard to the C4 model, you might also wonder
    why it puts such little effort into presenting the system's use cases. If that's
    your case, then you should think about supplementing the preceding models with
    either the use case diagram from UML or perhaps think about introducing some sequence
    diagrams.
  prefs: []
  type: TYPE_NORMAL
- en: When documenting architecture, it's more important what you document and what
    knowledge you share than to follow a specific hard set of rules. Choose whatever
    tools suit your needs the best.
  prefs: []
  type: TYPE_NORMAL
- en: Documenting architecture in Agile projects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Agile environments, your approach to documenting architecture should be similar
    to the one about documenting requirements. First and foremost, consider who will
    be reading the materials you prepare to be sure you're describing the right things
    in the right way. Your documentation doesn't need to be a lengthy Word document.
    You can use presentations, wiki pages, single diagrams, or even recordings from
    meetings when someone describes the architecture.
  prefs: []
  type: TYPE_NORMAL
- en: What is important is to gather feedback on the documented architecture. Again,
    in the same way, as with the documented requirements, it's important to reiterate
    the documents with your stakeholders to know where to improve them. Even though
    this may seem like you're wasting time, if done properly, it should save you some
    time in terms of delivering the product. Good enough documentation should help
    newcomers to start being productive faster and guide more familiar stakeholders
    down the road. If you just discuss the architecture at some meetings, chances
    are, a quarter later, no one will remember why you made the decisions you made
    and whether they will remain valid in the ever-changing, Agile landscape.
  prefs: []
  type: TYPE_NORMAL
- en: Reiteration is important when creating documentation because most probably there
    will be some misunderstanding of an important detail or two. Other times, you
    or your stakeholders will gain more knowledge and decide to change things. Be
    prepared to go through the document at least a few times before it will be considered
    mature and done. Often, a few conversations over IM, phone, or in-person will
    help you finish it quicker and address any follow-ups that could arise, so prefer
    those to emails or other asynchronous ways of communication.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing the right views to document
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Architecture is way too complex a topic to be described by a single big diagram.
    Imagine you''re the architect of a building. To design the whole thing, you''d
    need separate diagrams for different aspects: one for plumbing, another one for
    electricity and other cables, and so on. Each of those diagrams would show a different
    view of the project. The same goes for software architecture: you need to present
    the software from different perspectives, aimed at different stakeholders.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Moreover, if you were building a smart house, chances are you would draw some
    plan of the devices you want to place around. Although not all projects will require
    such views, since it plays a role in your project, it may be worth adding it.
    The same approach is also valid for architecture: if you find a different view
    valuable to the document, you should do it. So, how do you know which views could
    be valuable? You can try to perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Start with the views from either the 4+1 model or the C4 model.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ask your stakeholders what is essential for them to have documented and think
    about modifying your set of views.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose views that will help you to evaluate whether the architecture meets its
    objectives and that all the ASRs are satisfied. Read the first paragraph of each
    of the views from the next sections to check whether they suit your needs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you''re still not sure which views to document, here''s a set of tips:'
  prefs: []
  type: TYPE_NORMAL
- en: Try to just pick the most important views, because when there are too many of
    them, the architecture will become too hard to follow. A good set of views should
    not only showcase the architecture but also expose the technical risks to the
    project.
  prefs: []
  type: TYPE_NORMAL
- en: There are a few things you should think about when choosing what views you should
    describe in your documentation. We'll describe them shortly here, but if you're
    interested, you should grab *Rozanski and Woods*' book mentioned in the *Further
    reading* section.
  prefs: []
  type: TYPE_NORMAL
- en: Functional view
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If your software is being developed as part of a bigger system, especially with
    teams that don't communicate on a daily basis, you should include a functional
    view (as in the 4+1 model).
  prefs: []
  type: TYPE_NORMAL
- en: One important and often overlooked aspect of documenting your architecture is
    the definition of the interfaces you provide, despite it being one of the most
    important things to describe. Whether it's an interface between two of your components
    or an entry point for the outside world, you should take the time to document
    it clearly, describing the semantics of objects and calls, as well as usage examples
    (which you can sometimes reuse as tests).
  prefs: []
  type: TYPE_NORMAL
- en: Another great benefit of including a functional view in your documentation is
    that it clarifies the responsibilities between components of your system. Each
    team developing the system should understand where the boundaries are and who's
    responsible for developing which functionality. All requirements should be explicitly
    mapped to components to eliminate gaps and duplicated work.
  prefs: []
  type: TYPE_NORMAL
- en: An important thing to note here is to avoid overloading your functional view.
    If it gets messy, no one will want to read it. If you're starting to describe
    infrastructure on it, consider adding a deployment view. If you end up having
    a *God object* in your models, try to rethink the design and split it into smaller,
    more cohesive pieces.
  prefs: []
  type: TYPE_NORMAL
- en: 'One last important note about the functional view: try to keep each diagram
    you include on one level of abstraction. On the other hand, don''t make it too
    vague by choosing an overly abstract level; ensure that every element is properly
    defined and understood by the interested parties.'
  prefs: []
  type: TYPE_NORMAL
- en: Information view
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If your system has non-straightforward needs with regard to information, its
    processing flow, management process, or storage, perhaps it's a good idea to include
    this kind of view.
  prefs: []
  type: TYPE_NORMAL
- en: Take the most important, data-rich entities and demonstrate how they flow through
    the system, who owns them, and who the producers and consumers are. It may be
    useful to mark how long certain data remains "fresh" and when it can be safely
    discarded, what the expected latency for it to arrive at certain points of the
    system is, or how to deal with identifiers if your system works in a distributed
    environment. If your system manages transactions, this process, along with any
    rollbacks, should also be clear to your stakeholders. Techniques for transforming,
    sending, and persisting data can also be important for some of them. If you are
    operating in the financial domain or have to deal with personal data, you most
    probably must obey some regulations, so describe how your system plans to tackle
    this.
  prefs: []
  type: TYPE_NORMAL
- en: The structure of your data can be diagrammed using UML class models. Remember
    to be clear about the format of your data, especially if it flows between two
    different systems. NASA lost the $125 million-worth Mars Climate Orbiter, which
    it co-developed with Lockheed Martin, because they used different units unknowingly,
    so keep an eye out for data inconsistencies between systems.
  prefs: []
  type: TYPE_NORMAL
- en: The processing flow of your data can use UML's activity model, and to show the
    life cycle of information, a state diagram can be used.
  prefs: []
  type: TYPE_NORMAL
- en: Concurrency view
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If running many concurrent units of execution is an important aspect of your
    product, consider adding a concurrency view. It can show what issues and bottlenecks
    you may have (unless that sounds too detailed). Other good reasons to include
    it are the reliance on interprocess communication, having a non-straightforward
    task structure, concurrent state management, synchronization, or task failure
    handling logic.
  prefs: []
  type: TYPE_NORMAL
- en: Use whatever notation you want for this view, as long as it captures the units
    of execution and their communication. Assign priorities to your processes and
    threads, if necessary, and then analyze any potential issues, such as deadlocks
    or contention. You can use state diagrams to show the possible states and their
    transitions for important units of execution (waiting for queries, executing a
    query, distributing results, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: If you're not sure about the need to introduce concurrency to your system, a
    good rule of thumb is *don't*. And if you must, strive for a simple design. Debugging
    concurrency issues is never easy and always long, so if possible, try to optimize
    what you have first instead of just throwing more threads at the problem at hand.
  prefs: []
  type: TYPE_NORMAL
- en: If, by looking at your diagram, you're worried about resource contention, try
    to replace locks on big objects with more locks, but finer-grained, use lightweight
    synchronization (sometimes atomics are enough), introduce optimistic locking,
    or reduce what's shared (creating an additional copy of some data in a thread
    and processing it can be faster than sharing access to the only copy).
  prefs: []
  type: TYPE_NORMAL
- en: Development view
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you're building a big system with lots of modules, and you need to structure
    your code, have system-wide design constraints, or if you want to share some common
    aspects between parts of your system, presenting the solution from a development
    viewpoint should benefit you, along with software developers and testers.
  prefs: []
  type: TYPE_NORMAL
- en: A package diagram of the development view can be handy to show where different
    modules in your system are located, what their dependencies are, and other related
    modules (for example, residing in the same software layer). It doesn't need to
    be a UML diagram – even boxes and lines would do. If you plan for a module to
    be replaceable, this kind of diagram can show you what other software packages
    can be affected.
  prefs: []
  type: TYPE_NORMAL
- en: Tactics to increase reuse in your system, such as creating your own runtime
    framework for components, or tactics for increasing the coherence of your systems,
    such as a common approach to authentication, logging, internationalization, or
    other kinds of processing, are all part of the development view. If you see any
    common parts of the system, document it to be sure that all developers see them
    too.
  prefs: []
  type: TYPE_NORMAL
- en: A common approach to code organization, building, and configuration management
    should also go into this section of your documentation. If all this sounds like
    a lot to document, then focus on the most important parts and cover the rest just
    briefly, if at all.
  prefs: []
  type: TYPE_NORMAL
- en: Deployment and operational views
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you have a non-standard or complex deployment environment, such as specific
    needs with regard to hardware, third-party software or networking requirements,
    consider documenting it in a separate deployment section, aimed at system administrators,
    developers, and testers.
  prefs: []
  type: TYPE_NORMAL
- en: 'If necessary, cover the following things:'
  prefs: []
  type: TYPE_NORMAL
- en: The amount of memory required
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The CPU thread count (with or without hyperthreading)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pinning and affinity with regard to NUMA nodes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specialist networking equipment requirements, such as switches that mark packages
    to measure latency and throughput in a black-box manner
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The networking topology
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The estimated bandwidth required
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storage requirements for your app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any third-party software that you plan to use
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once you have the requirements, you can map them to specific hardware and put
    them into a runtime platform model. You can use a UML deployment diagram with
    stereotypes if you desire formal modeling. This should show your processing nodes
    and client nodes, online and offline storage, network links, specialized hardware,
    such as firewalls or FPGA or ASIC devices, and a mapping between functional elements
    and the nodes they'll run on.
  prefs: []
  type: TYPE_NORMAL
- en: If you have non-straightforward networking needs, you can add another diagram
    showing the networking nodes and the connections between them.
  prefs: []
  type: TYPE_NORMAL
- en: If you depend on specific technologies (including specific versions of software),
    it's a good idea to list them to see whether there are any compatibility issues
    between the software you use. Sometimes, two third-party components will require
    the same dependency, but in different versions.
  prefs: []
  type: TYPE_NORMAL
- en: If you have a specific installation and upgrade plan in your head, it might
    be a good idea to write a few words about it. Things such as A/B testing, blue-green
    deployments, or any particular container magic that your solution will rely on
    should be clear to everyone involved. Data migration plans should also be covered,
    if needed, including how long the migration can take and when it could be scheduled.
  prefs: []
  type: TYPE_NORMAL
- en: Any plans for configuration management, performance monitoring, operational
    monitoring, and control, as well as backup strategies, can all be things worth
    describing. You'll probably want to create a few groups, identify the dependencies
    of each, and define the approach for each such group. If you can think about any
    probable errors that may occur, have a plan to detect and recover from them.
  prefs: []
  type: TYPE_NORMAL
- en: 'A few notes to the support team can also go into this section: what support
    is required by which stakeholder group, what classes of incidents you plan to
    have, how to escalate, and what each level of support will be responsible for.'
  prefs: []
  type: TYPE_NORMAL
- en: It's best to engage early with the operational staff and create diagrams specifically
    for them in order to keep them engaged.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've discussed how to create documentation about your system and its
    requirements manually, let's switch to documenting your APIs in an automated manner.
  prefs: []
  type: TYPE_NORMAL
- en: Generating documentation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As engineers, we don't like manual labor. This is why, if something can be automated
    and save us work, it most likely will be. With all this effort to create good
    enough documentation, having the possibility to automate at least parts of the
    work can actually be bliss.
  prefs: []
  type: TYPE_NORMAL
- en: Generating requirements documentation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you're creating a project from scratch, it can be hard to generate documentation
    out of thin air. However, sometimes it's possible to generate documentation if
    you have nothing but the requirements in an appropriate tool. If you're using
    JIRA, for instance, a starting point would be to just export all items from an
    issue navigator view. You can use whatever filter you like and get printouts just
    for those items. If you don't like the default set of fields or just feel this
    is not what you're looking for, you can try out one of JIRA's plugins for requirements
    management. They allow a whole lot more than to just export requirements; for
    example, **R4J** (**Requirements for Jira**) allows you to create whole hierarchies
    of requirements, trace them, manage changes and propagate them through your whole
    project, perform impact analyses of any requirements changes, and, of course,
    export using user-defined templates. Many such tools will also aid you in creating
    test suites for your requirements, but none that we saw were free.
  prefs: []
  type: TYPE_NORMAL
- en: Generating diagrams from code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you want to get to know your code structure without taking an initial deep
    dive into the sources, you might be interested in tools that generate diagrams
    from code.
  prefs: []
  type: TYPE_NORMAL
- en: One such tool is CppDepend. It enables you to create various dependency diagrams
    between different parts of your sources. What's more, it allows you to query and
    filter the code based on various parameters. Whether you want to just grasp how
    the code is structured, discover what the dependencies are between different software
    components and how tightly they're coupled, or want to quickly locate parts with
    the most technical debt, you might be interested in this tool. It's proprietary,
    but offers a fully functional trial.
  prefs: []
  type: TYPE_NORMAL
- en: Some diagramming tools allow you to create code from class diagrams and class
    diagrams from code. Enterprise Architect enables you to take your class and interface
    diagrams and generate code in multiple languages. C++ is one of these, and allows
    UML class diagrams to be generated directly from source code. Another tool that
    can do that is Visual Paradigm.
  prefs: []
  type: TYPE_NORMAL
- en: Generating (API) documentation from code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To help others navigate your existing code and use the APIs you provide, a good
    idea is to provide documentation generated from the comments in your code. There's
    no better place for such documentation than just right next to the functions and
    data types it describes, and this helps a lot in keeping them in sync.
  prefs: []
  type: TYPE_NORMAL
- en: A de facto standard tool for writing such documentation is Doxygen. Its positives
    are that it's fast (especially for big projects and HTML document generation),
    the generator has some built-in correctness checks (for example, for partially
    documented parameters in a function – a good marker to check whether the documentation
    is still up to date), and it allows the navigation of class and file hierarchies.
    Its disadvantages include not being able to do a full-text search, less than ideal
    PDF generation, and an interface some may find cumbersome.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, the usability flaws can be remediated by using another popular
    tool for documentation. If you've ever read any Python documentation, you have
    probably stumbled upon Sphinx. It has a fresh-looking and usable interface and
    uses reStructuredText as a markup language. The good news is that there's a bridge
    between those two, so you can take XML generated from Doxygen and use it in Sphinx.
    This bridging software is called Breathe.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now see how to set it up in your project. Let''s assume we keep our
    sources in `src`, public headers in `include,` and documentation in `doc`. First,
    let''s create a `CMakeLists.txt` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We've set requirements on the CMake version supported by our project, specified
    its name, version, and the languages used (in our case, it's just C++), and added
    the `cmake` directory to the path under which CMake looks for its include files.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `cmake` subdirectory, we''ll create one file, `FindSphinx.cmake`, which
    we''ll use just as the name suggests, since Sphinx doesn''t offer one already:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, CMake will look for our Sphinx build tool and, if found, will set appropriate
    CMake variables to mark the Sphinx package as found. Next, let''s create our sources
    to generate the documentation. Let''s have an `include/breathe_demo/demo.h` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note the comment syntax. Doxygen recognizes it while parsing our header file
    so that it knows what to put in the generated documentation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s add a corresponding `src/demo.cpp` implementation for our header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: No Doxygen comments here. We prefer to document our types and functions in the
    header files since they're the interface to our library. The source files are
    just implementation and they don't add anything new to the interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Aside from the preceding files, we also need a simple `CMakeLists.txt` file
    in `src`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here, we specify the source files for our target, the directory with the header
    files for it, and the required C++ standard to compile against.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s move to the `doc` folder, where the magic happens; first, its `CMakeLists.txt`
    file, beginning with a check to establish whether Doxygen is available and omitting
    generation if so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: If Doxygen is not installed, we'll just skip documentation generation. Note
    also the `return()` call, which will exit the current CMake list file, a not-that-widely-known,
    but nevertheless useful, trick.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, assuming Doxygen was found, we need to set some variables to steer the
    generation. We want just the XML output for Breathe, so let''s set the following
    variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'To force relative paths, use `set(DOXYGEN_STRIP_FROM_PATH ${PROJECT_SOURCE_DIR}/include)`.
    If you have any implementation details to hide, you can do this using `set(DOXYGEN_EXCLUDE_PATTERNS
    "*/detail/*")`. OK, since we have all the variables set, let''s now generate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Here, we call a CMake function specifically written for using Doxygen. We define
    a target, `doxygen-doc`, which we'll need to explicitly invoke to generate our
    docs on demand, just like the comment says.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need to create a Breathe target to consume what we got from Doxygen.
    We can use our `FindSphinx` module to this end:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: First, we invoke our module. Then, we fill in a Python configuration file with
    variables from our project for Sphinx to use. We create a `sphinx-doc` target
    that will generate HTML files as its output and will print a line in the build's
    output when doing so.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s force CMake to call Doxygen each time we generate Sphinx docs:
    `add_dependencies(sphinx-doc doxygen-doc)`.'
  prefs: []
  type: TYPE_NORMAL
- en: If you wish to have more targets for documentation, it may be useful to introduce
    some CMake functions that will handle documentation-related targets for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now see what lies inside our `conf.py.in` file, used to steer our feline
    tool. Let''s create it and let it point Sphinx to Breathe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the preceding listing, we set the extensions for Sphinx
    to use, the name of the documented project, and a few other related variables.
    Note `@NOTATION@`, used by CMake to fill in the output file with the value of
    appropriate CMake variables. Finally, we tell Sphinx to use our ReadTheDocs theme
    (`sphinx_rtd_theme`).
  prefs: []
  type: TYPE_NORMAL
- en: 'The final pieces of the puzzle are reStructuredText files, which define what
    to include where in the docs. First, let''s create an `index.rst` file, containing
    a table of contents and a few links:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The first link points to this page, so we can get back to it from other ones.
    We''ll display `Introduction` as the label. Other names point to other files with
    the `.rst` extension. Since we''re including the M2R2 Sphinx extension, we can
    include our `README.md` file in the docs, which can save you some duplication.
    The contents of the `readme.rst` file are simply `.. mdinclude:: ../README.md`.
    Now for the last part: merging Doxygen''s output. This is done in the `api_reference.rst`
    file using just the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'So we just named the reference page as we liked and specified that the Doxygen-generated
    docs should be listed here, and that''s all! Just build the `sphinx-doc` target
    and you''ll get a page looking like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b4d742ab-7431-49b9-9c2f-cae386dde9cd.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.9 – The main page of our documentation, consolidating both the generated
    and manually written parts
  prefs: []
  type: TYPE_NORMAL
- en: 'And when we look at the API docs page, it should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cb4eb5a0-f0a3-4ff6-95f9-039a846faf30.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.10 – The automatically generated API documentation
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the documentation was automatically generated for our `Payload`
    type with each of its members, as well as for the free `perform_work` function,
    including each of its parameters, and was grouped based on the file that defines
    them. Neat!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you got to know all the essentials regarding requirements and
    documentation. You learned how to gather requirements successfully and how to
    identify the most important ones. You can now prepare lean and useful documentation
    that shows only what's important in a view-oriented manner. You are able to distinguish
    between different types and styles of diagrams and use the one that suits your
    needs the best. Last, but not least, you are now able to automatically generate
    aesthetic documentation.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you'll learn about useful architectural design patterns
    that will help you fulfill your system's requirements. We'll discuss various patterns
    and how to apply them to provide many important quality attributes, both on a
    single-component scale in distributed systems.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are quality attributes?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What sources should be used when gathering requirements?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you tell whether a requirement is architecturally significant?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When is development view documentation useful?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you automatically check whether your code's API documentation is out
    of date?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you indicate on a diagram that a given process is handled by different
    components of the system?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Evaluate the Software Architecture using ATAM,* JC Olamendy, blog post: [https://johnolamendy.wordpress.com/2011/08/12/evaluate-the-software-architecture-using-atam/](https://johnolamendy.wordpress.com/2011/08/12/evaluate-the-software-architecture-using-atam/)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**EARS**: *The Easy Approach to Requirements Syntax*, John Terzakis, Intel
    Corporation, conference talk from the ICCGI conference: [https://www.iaria.org/conferences2013/filesICCGI13/ICCGI_2013_Tutorial_Terzakis.pdf](https://www.iaria.org/conferences2013/filesICCGI13/ICCGI_2013_Tutorial_Terzakis.pdf)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Eoin Woods and Nick Rozanski, *Software Systems Architecture: Working With
    Stakeholders Using Viewpoints and Perspectives*'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
