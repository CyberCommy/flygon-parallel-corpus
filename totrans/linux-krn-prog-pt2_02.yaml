- en: Writing a Simple misc Character Device Driver
  prefs: []
  type: TYPE_NORMAL
- en: No doubt, device drivers are a vast and interesting topic. Not only that, they
    are perhaps the most common use of the **Loadable Kernel Module** (**LKM**) framework
    that we have been using. Here, we shall introduce you to writing a few simple
    yet complete Linux character device drivers, within a class called `misc`; yes,
    that's short for miscellaneous. We wish to emphasize that this chapter is limited
    in its scope and coverage - here, we do not attempt to delve into the deep details
    regarding the Linux driver model and its many frameworks; instead, we refer you
    to several excellent books and tutorials on this topic via the *Further reading *section
    for this chapter. Our aim here is to quickly get you familiar with the overall
    concepts behind writing a simple character device driver.
  prefs: []
  type: TYPE_NORMAL
- en: Having said that, this book indeed has several chapters that are dedicated to
    what a driver author needs to know. Besides this introductory chapter, we cover
    (in detail) how a driver author works with hardware I/O memory, hardware interrupt
    handling (and its many sub-topics), and kernel mechanisms such as delays, timers,
    kernel threads, and work queues. Use of various user-kernel communication pathways
    or interfaces is covered in detail as well. The final two chapters of this book
    then focus on something very important for any kernel development, including drivers
    – kernel synchronization.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other reasons we''d prefer to write a simple Linux *character* *device
    driver* and not just our "usual" kernel module are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Until now, our kernel modules have been quite simplistic, having only `init` and `cleanup` functions,
    nothing more. A device driver provides *several* entry points into the kernel;
    these are the file-related system calls, known as the *driver's methods*. So,
    we can have an `open()` method, a `read()` method, a `write()` method, an `llseek()` method,
    an `[unlocked|compat]_ioctl()` method, a `release()` method, and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: FYI, all possible "methods" (functions) the driver author can hook into are
    in this key kernel data structure: `include/linux/fs.h:file_operations` (more
    on this in the *Understanding the connection between the process, the driver,
    and the kernel *section).
  prefs: []
  type: TYPE_NORMAL
- en: This situation is simply more realistic, and more interesting.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with writing a simple misc character device driver
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copying data from kernel to user space and vice versa
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A misc driver with a secret
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Issues and security concerns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I assume that you have gone through the *Preface* section *To get the most out
    of this book*, and have appropriately prepared a guest VM running Ubuntu 18.04
    LTS (or a later stable release) and installed all the required packages. If not,
    I highly recommend you do this first. To get the most out of this book, I strongly
    recommend you first set up the workspace environment, including cloning this book's
    GitHub repository for the code, and work on it in a hands-on fashion. The repository
    can be found here:[ https://github.com/PacktPublishing/Linux-Kernel-Programming-Part-2](https://github.com/PacktPublishing/Linux-Kernel-Programming-Part-2/tree/main/ch1).
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with writing a simple misc character device driver
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you will first learn the required background material – understanding
    the basics of the device file (or node) and its hierarchy. After that, you will
    learn – by actually writing the code of a very simple `misc` character driver
    – the kernel framework behind the raw character device driver. Along the way,
    we shall cover how to create the device node(s) and test the driver via a user
    space app. Let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the device basics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some quick background is in order.
  prefs: []
  type: TYPE_NORMAL
- en: A **device driver** is the interface between the OS and a peripheral hardware
    device. It can be written inline – that is, compiledwithin the kernel image file
    – or, more commonly, written outside of the kernel source tree as a kernel module
    (we covered the LKM framework in detail in the companion guide *Linux Kernel Programming,* *Chapter
    4*, *Writing Your First Kernel Module – LKMs Part 1*, and *Chapter 5*, *Writing
    Your First Kernel Module – LKMs Part 2*). Either way, the driver code certainly
    runs at OS privilege, in kernel space (user space device drivers do exist, but
    can suffer performance issues; while useful in many circumstances, we don't cover
    them here. Take a look at the *Further reading *section).
  prefs: []
  type: TYPE_NORMAL
- en: In order for a user space application to gain access to the underlying device
    driver within the kernel, some I/O mechanism is required. The Unix (and thus Linux)
    design is to have the process open a special type of file – a **device file**,
    or **device node**. These files typically live in the `/dev` directory, and on
    modern systems are dynamic and auto-populated. The device node serves as an entry
    point into the device driver.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order for the kernel to distinguish between device files, it uses two attributes
    within their inode data structure:'
  prefs: []
  type: TYPE_NORMAL
- en: The type of file – either character (char) or block
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The major and minor number
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You will see that the **namespace** – the device type and the `{major#, minor#}`
    pair – form a **hierarchy**. Devices (and thus their drivers) are organized within
    a tree-like hierarchy within the kernel (the driver core code within the kernel
    takes care of this). The hierarchy is first divided based on device type – block
    or char. Within that, we have some *n* major numbers for each type, and each major
    number is further classified via some *m* minor numbers; *Figure 1.1* shows this
    hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the key difference between block and character devices is that block devices
    have the (kernel-level) capability to be mountedand thus become part of the user-accessible
    filesystem. Character devices cannot be mounted; thus, storage devices tend to
    be block-based. Think of it this way (a bit simplistic but useful): if the (hardware)
    device is not storage, nor a network device, then it''s a character device. A
    huge number of devices fall into the ''character'' class, including your typical
    I2C/SPI (Inter Integrated Circuit / Serial Peripheral Interface) sensor chips
    (temperature, pressure, humidity, and so on), touchscreens, **Real-Time Clock** (**RTC**),
    media (video, camera, audio), keyboards, mice, and so on. USB forms a class within
    the kernel for infrastructure support. USB devices can be block devices (pen drives,
    USB disks), character devices (mice, keyboard, camera) or network (USB dongles)
    devices.'
  prefs: []
  type: TYPE_NORMAL
- en: 'From 2.6 Linux onward, the `{major:minor}` pair is a single unsigned 32-bit
    quantity within the inode, a bitmask (it''s the `dev_t i_rdev` member). Of these
    32 bits, the MSB 12 bits represent the major number and the remaining LSB 20 bits
    represent the minor number. A quick calculation shows that there can therefore
    be up to 2^(12) = 4,096 major numbers and 2^(20), which is one million, minor
    numbers per major number. So, glance at *Figure 1.1*; within the block hierarchy,
    there are a possible 4,096 majors, each of which can have up to 1 million minors.
    Similarly, within the character hierarchy, there are a possible 4,096 majors,
    each of which can have up to 1 million minors:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8443be53-6cc9-4d81-9522-26c8b89e34cc.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.1 – The device namespace or hierarchy
  prefs: []
  type: TYPE_NORMAL
- en: 'You may be wondering: what exactly does this *major:minor* number pair really
    mean? Think of the major number as representing the **class**of the device (is
    it a SCSI disk, a keyboard, a **teletype terminal** (**tty**) or **pseudo-terminal**
    (**pty**) device, a loopback device (yes, these are pseudo-hardware devices),
    a joystick, a tape device, a framebuffer, a sensor chip, a touchscreen, and so
    on?). There''s indeed an enormous range of devices; to get a sense of just how
    many, we urge you to check out the kernel documentation here: [https://www.kernel.org/doc/Documentation/admin-guide/devices.txt](https://www.kernel.org/doc/Documentation/admin-guide/devices.txt)
    (it''s literally the official registry of all available devices for the Linux
    OS. It''s formally called the **LANANA** – the **Linux Assigned Names And Numbers
    Authority**! Only these folks can officially assign the device node – the type
    and *major:minor* numbers – to devices).'
  prefs: []
  type: TYPE_NORMAL
- en: The minor number's meaning (interpretation) is left completely to the driver
    author; the kernel does not interfere. Typically, the driver interprets the device's
    minor number to represent either a physical or logical instance of the device,
    or to represent a certain functionality. (For example, the **Small Computer System
    Interface** (**SCSI**) driver – of type block, major `#8` – uses minor numbers
    to represent logical disk partitions for up to 16 disks. On the other hand, character
    major `#119` is used by VMware's virtual network control driver. Here, the minors
    are interpreted as the first virtual network, second virtual network, and so on.)
    Similarly, all drivers themselves assign meaning to their minor numbers. But every
    good rule has an exception. Here, the exception to the rule - that the kernel
    doesn't interpret the minor number – is the `misc` class (type character, major
    `#10`). It uses the minor numbers as second-level majors. This will be covered
    in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: A common problem is that of the namespace getting exhausted. A decision taken
    years back "collects" various miscellaneous character devices - a lot of mice
    (no, not of the animal kingdom variety), sensors, touchscreens, and so on - into
    one class called the `misc` or '**miscellaneous**' class, which is assigned character
    major number `10`. Within the `misc` class live a lot of devices and their corresponding
    drivers. In effect, they share the same major number and rely on a unique minor
    number to identify themselves. We shall write a few drivers using precisely this
    class and leveraging the kernel's 'misc' framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'Many devices have already been assigned via the **LANANA (Linux Assigned Names
    And Numbers Authority)** into the `misc` character device class. *Figure 1.2*
    shows a partial screenshot from [https://www.kernel.org/doc/Documentation/admin-guide/devices.txt](https://www.kernel.org/doc/Documentation/admin-guide/devices.txt)
    showing the first few `misc` devices, their assigned minor numbers, and a brief
    description. Do see the reference link for the full list:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a7dd011e-66e6-48a7-be40-7e7a4bd61a5e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.2 – Partial screenshot of misc devices: char type, major # 10'
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 1.2*, the leftmost column has `10 char`, specifying that it's assigned
    major `# 10` under the character type of the device hierarchy (*Figure 1.1*).
    The columns to the right are in the form `minor# = /dev/<foo>     <description>`;
    quite obviously, this is the minor number assigned followed by (after the `=`
    sign) the device node and a one-line description.
  prefs: []
  type: TYPE_NORMAL
- en: A quick note on the Linux Device Model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Without going into great detail, a quick overview of the modern unified **Linux
    Device Model** (**LDM**) is important. Modern Linux, from the 2.6 kernel onward,
    has a fantastic feature, the LDM, which achieves many goals to do with the system
    and the devices on it in one broad and bold stroke. Among its many features, it
    creates a complex hierarchical tree unifying system components, all peripheral
    devices, and their drivers. This very tree is exposed to user space via the sysfs
    pseudo-filesystem (analogous to how procfs exposes some kernel and process/thread
    internal details to user space) and is typically mounted under `/sys`. Within
    `/sys`, you will find several directories – you can consider them to be "viewports"
    into the LDM. On our x86_64 Ubuntu VM, we show the sysfs filesystem mounted under `/sys`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Furthermore, take a peek inside:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Think of these directories as viewports into the LDM – different ways of viewing
    the devices on the system. Of course, as things evolve, more tends to get in than
    get out (the bloat aspect!). Several non-obvious directories have now made their
    way in here. Though (as with procfs) sysfs is officially documented as an **Application
    Binary Interface** (**ABI**) interface, that's subject to change/deprecation at
    any time; the reality is that this system is there to stay – and evolve, of course
    – over time.
  prefs: []
  type: TYPE_NORMAL
- en: 'The LDM, a bit simplistically, can be thought of as having – and tying together
    – these major components:'
  prefs: []
  type: TYPE_NORMAL
- en: The **buses** on the system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **devices** on them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **device drivers** that drive the devices (also often referred to as **client**
    drivers).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A fundamental LDM tenet is that ***every single device must reside on a bus***.
    This might seem obvious: USB devices will be on the USB bus, PCI devices on the
    PCI bus, I2C devices on the I2C bus, and so on. Thus, under the `/sys/bus` hierarchy,
    you will be able to literally "see" all the devices via the buses that they reside
    on:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/52912a35-54ca-415f-8d53-6e566e2f2054.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.3 – The different buses or bus driver infrastructure on modern Linux
    (on an x86_64)
  prefs: []
  type: TYPE_NORMAL
- en: 'The kernel''s driver core provides bus drivers (that are (typically) either
    part of the kernel image itself or auto-loaded at boot as required), which, of
    course, makes the buses do their job. What is their job? Critically, they organize
    and recognize the devices on them. If a new device surfaces (perhaps you plugged
    in a pen drive), the USB bus driver will recognize the fact and bind it to its
    (USB mass storage) device driver! Once successfully bound (many terms are used
    to describe this: bound, enumerated, discovered), the kernel driver framework
    invokes the registered `probe()` method (function) of the driver. This probe method
    now sets up the device, allocating resources, IRQs, memory setup, registering
    it as required, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another key aspect to understand regarding the LDM is that the modern LDM-based
    driver should typically do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Register itself to a (specialized) kernel framework.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Register itself to a bus.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The kernel framework it registers itself to depends on the type of device you
    are working with; for example, a driver for an RTC chip that resides on the I2C
    bus will register itself to the kernel's RTC framework (via the `rtc_register_device()`
    API) and to the I2C bus (internally via the `i2c_register_driver()` API). On the
    other hand, a driver for a network adapter (a NIC) on the PCI bus will typically
    register itself to the kernel's network infrastructure (via the `register_netdev()`
    API) and the PCI bus (via the `pci_register_driver()` API). Registering with a
    specialized kernel framework makes your job as a driver author a lot easier –
    the kernel will often provide helper routines (and even data structures) to take
    care of I/O details, and so on. For example, take the previously mentioned RTC
    chip driver.
  prefs: []
  type: TYPE_NORMAL
- en: You needn't know the details of how to communicate with the chip over the I2C
    bus, bit banging out data on the **Serial Clock** (**SCL**)/**Serial Data** (**SDA**)
    lines as the I2C protocol demands. The kernel I2C bus framework provides you with
    convenience routines (such as the typically used `i2c_smbus_*()` APIs) that let
    you quite effortlessly communicate over the bus to the chip in question!
  prefs: []
  type: TYPE_NORMAL
- en: 'If you''re wondering how to get more information on these driver APIs, here''s
    the good news: the official kernel documentation has plenty to offer. Do look
    up *The Linux driver implementer’s API guide* here: [https://www.kernel.org/doc/html/latest/driver-api/index.html](https://www.kernel.org/doc/html/latest/driver-api/index.html).'
  prefs: []
  type: TYPE_NORMAL
- en: (We do show some examples of the `probe()` method of a driver in the following
    two chapters; until then, patience, please.) Conversely, when the device is detached
    from the bus or the kernel module is unloaded (or the system is shutting down),
    the detach causes the driver's `remove()` (or `disconnect()`) method to be invoked.
    Between these, the work of the device via its drivers (both bus and client) is
    carried out!
  prefs: []
  type: TYPE_NORMAL
- en: Please note that we are glossing over a lot of the inner details here, as they
    are beyond the scope of this book. The point is to give you a conceptual understanding
    of the LDM. Do refer to the articles and links in the *Further reading *section
    for more detailed information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we wish to keep our driver coverage very simple and minimal, focusing
    more on the underlying basics. Hence we have chosen to write a driver that uses
    perhaps the simplest kernel framework – the `misc` or *miscellaneous* kernel framework.
    In this case, the driver doesn''t even need to explicitly register with any bus
    (driver). In fact, it''s more like this: our driver works *directly on the hardware*
    without the need for any particular bus infrastructure support.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In our particular example using the `misc`kernel framework, since we don''t
    explicitly register with any bus (driver), we don''t even require the `probe()`/`remove()` methods.
    This keeps things simple. On the other hand, once you have understood this simplest
    of drivers, I encourage you to go further and look at writing device drivers with
    the typical kernel framework registration plus bus driver registration, thus employing
    the `probe()`/`remove()` methods. A good way to get started is to learn how to
    write a simple **platform driver**, registering it with the kernel''s `misc`framework
    and the *platform bus*, a pseudo-bus infrastructure that supports devices that
    do not physically reside on any physical bus (this is more common than you might
    at first imagine; several peripherals built into a modern **System on Chip** (**SoC**)
    are not on any physical bus, and thus their drivers are typically platform drivers).
    To get started, look under the kernel source tree in `drivers/` for code invoking
    the `platform_driver_register()` API. The official kernel documentation here covers
    platform devices and drivers: [https://www.kernel.org/doc/html/latest/driver-api/driver-model/platform.html#platform-devices-and-drivers](https://www.kernel.org/doc/html/latest/driver-api/driver-model/platform.html#platform-devices-and-drivers).'
  prefs: []
  type: TYPE_NORMAL
- en: 'As additional help, note the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '- Do refer to [Chapter 2](4042025e-27a1-40f4-a2f7-223f601107dc.xhtml), *User-Kernel
    Communication Pathways*, particularly the *Creating a simple platform device* and *Platform
    devices* sections.'
  prefs: []
  type: TYPE_NORMAL
- en: '- An exercise (see the *Questions *section) for this chapter is to write such
    a driver. I have provided a sample (and very simple) implementation here: `solutions_to_assgn/ch12/misc_plat/`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We do, however, require the kernel''s `misc` framework support, and thus we
    register ourselves with it. Next, it''s also key to understand this: our driver
    is a logical one, in the sense that there''s no actual physical device or chip
    that it''s driving. This is quite often the case (of course, you could say that
    here, the hardware being worked upon is RAM).'
  prefs: []
  type: TYPE_NORMAL
- en: So, if we are to write a Linux character device driver belonging to this `misc` class,
    we will first need to register ourselves to it. Next, we will be in need of a
    unique (unused) minor number. Again, there is a way to have the kernel dynamically
    assign a free minor number to us. The following section covers these aspects and
    more.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the misc driver code – part 1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Without further ado, let's look at the code to write a simple skeleton character
    `misc` device driver! (Well, snippets of the actual code; as always, I strongly
    advise you to `git clone` the book's GitHub repository, view it in detail, and
    try out the code yourself.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go through it step by step: in the `init` code of our first device driver
    (using the LKM framework), we must first **register**ourdriver with the appropriate
    Linux kernel''s framework; in this case, with the `misc`framework. This is done
    via the `misc_register()` API. It takes one parameter, a pointer to a data structure
    of type `miscdevice`, which describes the miscellaneous device we are setting
    up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `miscdevice` structure instance, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: We set the `minor` field to `MISC_DYNAMIC_MINOR`. This has the effect of requesting
    the kernel to dynamically assign us an available minor number (once registration
    is successful, this `minor` field gets populated with the actual minor number
    assigned).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We initialize the `name` field. On successful registration, this has the kernel
    framework automatically create a device node (of the form `/dev/<name>`) on our
    behalf! As expected, the type will be character, the major number will be `10`,
    and the minor number will be a dynamically assigned value. This is (part of) the
    advantage of using a kernel framework;  else, we might have had to devise a way
    to create the device node ourselves; by the way, the `mknod(1)` utility can create
    a device file when invoked with root privilege (or you have the `CAP_MKNOD` capability);
    it works by invoking the `mknod(2)` system call!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The permissions of the device node will be set to whatever you initialize the
    `mode` field to (here, we've deliberately kept it permissive and readable-writeable
    by all via the `0666` octal value).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We shall postpone the discussion of the file operations (`fops`) structure member
    to the section following this one.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All `misc` drivers are of the character type and use the same major number (`10`),
    but of course require unique minor numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the connection between the process, the driver, and the kernel
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here, we will delve into just a bit of the kernel internals surrounding the
    successful registration of a character device driver on Linux. In effect, you
    will come to understand the workings of the underlying raw character driver framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `file_operations` structure, or the **fops**(pronounced *eff-opps*), as
    it''s commonly referred to, is of critical importance to driver authors; the majority
    of the members of the fops structure are function pointers – think of them as **virtual
    methods***.* They represent all possible file-related system calls that could
    be issued on a (device) file. So, it has `open`*, *`read`*,* `write`*,* `poll`*,*
    `mmap`*,* `release`*,* and several more members (most of which are function pointers). A
    few of the members of this critical data structure are shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: A key job of the driver author (or the underlying kernel framework) is to populate
    these function pointers, thus linking them to actual code within the driver. You
    needn't implement every single function, of course; please refer to the *Handling
    unsupported methods* section for details.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s assume you have written your driver to set up functions for some
    of the `f_op` methods. Once your driver is registered with the kernel, typically
    via a kernel framework, when any user space process (or thread) opens a device
    file registered to this driver, the kernel **Virtual Filesystem Switch** (**VFS**) layer
    will take over. Without going into deep detail, suffice it to say that the VFS
    allocates and initializes that process''s open filedata structure (`struct file`)
    for the device file. Now, recall the last line in our `struct miscdevice` initialization;
    it''s this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This line of code has a key effect: it ties the process''s file operations
    pointer (which is within the process'' open file structure) to the device driver''s
    file operations structure. The *functionality – what the driver will do –* is
    now set up for this device file!'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s flesh this out. Now (after your driver has initialized itself),  a user-mode
    process opens your driver''s device file, by issuing the `open(2)` system call
    on it. Assuming all goes well (and it should), the process is now connected to
    your driver via the `file_operations` structure pointers deep inside the kernel. Here''s
    a critical point: after the `open(2)` system call returns successfully, and the
    process issues any file-related system call `foo()` on that (device) file, the
    kernel VFS layer will, be having in an object-oriented fashion (we have pointed
    this out before in this book!), blindly and trustingly invoke the registered **`fops->foo()`** method!The
    file opened by the user space process, typically a device file in `/dev`, is internally
    represented by the `struct file` metadata structure (a pointer to this, `struct
    file *filp`, is passed along to the driver). So, in terms of pseudo-code, when
    user space issues a file-related system call `foo()`, this is what the kernel
    VFS layer effectively does:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Thus, if the user space process that opened a device file invokes the `read(2)`
    system call upon it, the kernel VFS will invoke `filp->f_op->read(...)`, in effect,
    redirecting control to the device driver. Your job as the device driver author
    is to provide the functionality of `read(2)`! The same goes for all other file-related
    system calls. This, essentially, is how Unix and Linux implement the well-known
    *if it's not a process, it's a file design* principle.
  prefs: []
  type: TYPE_NORMAL
- en: Handling unsupported methods
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You don't have to populate every member of the `f_ops` structure, only those
    that your driver supports. If that's the case, and you have populated a few methods
    but left out, say, the `poll` method, and a user space process invokes `poll(2)`
    on your device (perhaps you've documented the fact that it's not supposed to,
    but what if it does?), then what will happen? In cases like this, the kernel VFS,
    detecting that the `foo` pointer (in this example, `poll`) is `NULL`, returns
    an appropriate negative integer (in effect, following the same `0`/`-E` protocol).
    The `glibc` code will multiply this by `-1` and set the calling process's `errno` variable
    to that value, signaling that the system call failed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Two points to be aware of:'
  prefs: []
  type: TYPE_NORMAL
- en: Quite often, the negative `errno` value returned by the VFS isn't very intuitive.
    (For example, if you've set the `read()` function pointer of `f_op` to `NULL`,
    the VFS causes the `EINVAL` value to be sent back. This has the user space process
    think that `read(2)` failed because of an `"Invalid argument"` error, which simply
    isn't the case at all!)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `lseek(2)` system call has the driver seek to a prescribed location in
    the file – here, of course, we mean in the device. The kernel deliberately names
    the `f_op` function pointer as `llseek` (notice the two ''`l`''s). This is simply
    to remind you that the return value from `lseek` can be a 64-bit (long long) quantity.
    Now, for the majority of hardware devices, the `lseek` value is not meaningful,
    thus most drivers do not need to implement it (unlike filesystems). Now, the issue
    is this: even if you do not support `lseek` (you''ve set the `llseek` member of
    `f_op` to `NULL`), it still returns a random positive value, thus causing the
    user-mode app to incorrectly conclude that it succeeded. Hence, if you aren''t
    implementing `lseek`, you are to do the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explicitly set `llseek` to the special `no_llseek` value, which will cause a
    failure value (`-ESPIPE`; `illegal seek`) to be returned.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In such cases, you are to also invoke the `nonseekable_open()` function in your
    driver's `open()` method, specifying that the file is non-seekable (this is often
    called like this in the `open()` method: `return nonseekable_open(struct inode
    *inode, struct file *filp);`. The details, and more, are covered in the LWN articles
    here: [https://lwn.net/Articles/97154/](https://lwn.net/Articles/97154/). You
    can see the changes this wrought to many drivers here: [https://lwn.net/Articles/97180/](https://lwn.net/Articles/97180/)).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An appropriate value to return if you aren't supporting a function is `-ENOSYS`,
    which will have the user-mode process see the error `Function not implemented` (when
    it invokes the `perror(3)` or `strerror(3)` library APIs). This is clear, unambiguous;
    the user space developer will now understand that your driver does not support
    this function. Thus, one way to implement your driver is to set up pointers to
    all the file operation methods, and write a routine for all file-related system
    calls (the `f_op` methods) in your driver. For the ones you do support, write
    the code; for the ones you do not implement, just return the value `-ENOSYS`.
    Though a bit painstaking to do, it will result in unambiguous return values to
    user space.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the misc driver code – part 2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Armed with this knowledge, look again at the `init` code of `ch1/miscdrv/miscdrv.c`.
    You will see that, just as described in the previous section, we have initialized
    the `fops` member of the `miscdev` struct to a `file_operations` structure, thus
    setting up the functionality of the driver. The relevant code snippet (from our
    driver) is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'So, now you can see it: when a user space process (or thread) that has opened
    our device file invokes, say, a `read(2)` system call, the kernel VFS layer will
    follow the pointers (generically, `filp->f_op->foo()`) and invoke the function, `read_miscdrv()`,
    in effect handing over control to the device driver! How exactly the read method
    is written is covered in the next section.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Continuing with the `init`code of our simple `misc` driver:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Our driver retrieves a pointer to the `device` structure – it's something required
    by every driver. Within the `misc` kernel framework, it's available within the `this_device` member
    of our `miscdevice` structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, `pr_info()` shows the minor number dynamically obtained. The `dev_info()`
    helper routine is more interesting: as a driver author, you are **expected to
    use these `dev_xxx()` helpers** when emitting `printk`; it will also prefix useful
    information about the device. The only difference in syntax between the `dev_xxx()`
    and `pr_xxx()` helpers is that the first parameter to the former is the pointer
    to the device structure.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, let''s get our hands dirty! We build the driver and `insmod` it into
    kernel space (we use our `lkm` helper script to do so):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eef5c47b-24ea-480d-9ca9-c520c1f96fb0.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.4 – Screenshot of building and loading our miscdrv.ko skeleton misc
    driver on an x86_64 Ubuntu VM
  prefs: []
  type: TYPE_NORMAL
- en: '(By the way, as you can see in *Figure 1.4*, I tried out this `misc` driver
    on a more recent distro: Ubuntu 20.04.1 LTS running the 5.4.0-58-generic kernel.)
    Notice the two prints toward the bottom of *Figure 1.4*; the first is emitted
    via the `pr_info()` (prefixed with the `pr_fmt()` macro content, as explained
    in the companion guide *Linux Kernel Programming -* *Chapter 4, Writing Your First
    Kernel Module - LKMs Part 1* section *Standardizing printk output via the pr_fmt
    macro*). The second print is emitted via the `dev_info()` helper routine – it''s
    prefixed with the words `misc llkd_miscdrv`, indicating that it originated from
    the kernel''s `misc` framework, and specifically from the `llkd_miscdrv` device!
    (The `dev_xxx()` routines are versatile; depending on the bus they''re on, they
    will display various details. This is useful for debugging and logging purposes.
    We repeat: you''re recommended to use the `dev_*()` routines when writing drivers.)
    You can also see that the `/dev/llkd_miscdrv` device node is indeed created, with
    the expected type (character) and major and minor pair (10 and 56 here).'
  prefs: []
  type: TYPE_NORMAL
- en: Writing the misc driver code – part 3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, the `init` code is done, the driver functionality has been set up via the
    file operations structure, and the driver is registered to the kernel `misc` framework. So,
    what happens next? Well, nothing really, until a process opens the device file
    (associated with your driver) and performs I/O (Input/Output, i.e., reads/writes)
    of some sort.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s assume that a user-mode process (or thread) issues the `open(2)`
    system call on your driver''s device node (recall, the device node has been auto-created
    when the driver registered itself to the kernel''s `misc` framework). Most important,
    as you learned in the *Understanding the connection between the process, the driver,
    and the kernel* section, for any file-related system calls issued upon your device
    node, the VFS will essentially invoke the driver''s (`f_op`) registered method.
    So, here, the VFS will do this: `filp->f-op->open()`, thus invoking our driver''s
    `open` method within our `file_operations` structure, which is the `open_miscdrv()` function!'
  prefs: []
  type: TYPE_NORMAL
- en: 'But how should you, the driver author, implement this code of the `open` method
    of your driver? The key point is this: the signature of your `open` function **should
    be identical** to that of the `file_operation` structure `open`; in fact, this
    is true of any function. Thus, we implement the `open_miscdrv()` function like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Notice how the signature of our `open` routine, the `open_miscdrv()` function,
    precisely matches that of the `f_op` structure's `open` function pointer (you
    can always lookup the `file_operations` structure for 5.4 Linux here at [https://elixir.bootlin.com/linux/v5.4/source/include/linux/fs.h#L1814](https://elixir.bootlin.com/linux/v5.4/source/include/linux/fs.h#L1814)).
  prefs: []
  type: TYPE_NORMAL
- en: In this simple driver, in our `open` method, we don't really have much to do.
    We allocate some memory for a buffer (to hold the pathname of our device) via
    `kzalloc()`, issue our `PRINT_CTX()` macro (it's in the `convenient.h` header)
    to show the current context – the process that is currently opening the device.
    We then emit a `printk` (via `pr_info()`) showing a few VFS layer details (the
    pathname and open flags value); you can get the path name of a file by using the
    convenience API `file_path()`, as we do here (to do so, we need to allocate and,
    after usage, free a kernel memory buffer). Then, as we don't support seeking in
    this driver, we invoke the `nonseekable_open()` API (as discussed in the *Handling
    unsupported methods* section).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `open(2)` system call on the device file should succeed. The user-mode
    process will now have a valid file descriptor – a handle to the open file (which,
    here, is actually a device node). Now, let''s say the user-mode process wants
    to read data from the hardware; it therefore issues the `read(2)` system call.
    As explained already, the kernel VFS will now auto-invoke our driver''s read method,
    `read_miscdrv()`. Again, its signature exactly imitates the read function signature
    from the `file_operations` data structure. Here''s the simple code of our driver''s
    read method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The preceding comment is self-explanatory. Within it, we emit `pr_info()`, showing
    the number of bytes the user space process wants to read. Then, we simply return
    the number of bytes read, implying success! In reality, we have done (essentially)
    nothing. The remaining driver methods are quite similar.
  prefs: []
  type: TYPE_NORMAL
- en: Testing our simple misc driver
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s test our really simple skeleton `misc` character driver (in the `ch1/miscdrv`
    directory; we assume you have built and inserted it as shown in *Figure 1.4*).
    We test it by issuing `open(2)`, `read(2)`, `write(2)`, and `close(2)` system
    calls upon it; how exactly can we do so? We can always write a small C program
    to do precisely this, but an easier way is to use the useful  `dd(1)` "disk duplicator"
    utility. We use it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Internally `dd` opens the file we pass it as a parameter (`/dev/llkd_miscdrv`)
    via `if=` (here, it''s the first parameter to `dd`; `if=` specifies the input
    file), it will read from it (via the `read(2)` system call, of course). The output
    is to be written to the file specified by the parameter `of=` (the second parameter
    to `dd`, and is a regular file named `readtest`); the `bs` specifies the block
    size to perform I/O in and `count` is the number of times to perform I/O). After
    performing the required I/O, the `dd` process will `close(2)` the files. This
    sequence is reflected in the kernel log (*Figure 1.5*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9c0a7520-4795-4889-b8c2-6117c7f1b00f.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.5 – Screenshot showing us minimally testing our miscdrv driver's read
    method via dd(1)
  prefs: []
  type: TYPE_NORMAL
- en: After verifying that our driver (LKM) is inserted, we issue the `dd(1)` command,
    having it read 4,096 bytes from our device (as the block size (`bs`) is set to
    `4k` and `count` to `1`). We have it write the output (via the `of=` option switch)
    to a file named `readtest`. Looking up the kernel log, you can see (*Figure 1.5*)
    that the `dd` process has indeed opened our device (our `PRINT_CTX()` macro's
    output shows that it's the process context currently running the code of our driver!).
    Next, we can see (via the output from `pr_fmt()`) that control goes to our driver's
    read method, within which we emit a simple `printk` and return the value 4096
    signifying success (though we really didn't read anything!). The device is then
    closed by `dd`. Furthermore, a quick check with the `hexdump(1)` utility reveals
    that we did indeed receive `0x1000` (4,096) nulls (as expected) from the driver
    (in the file `readtest`; do realize that this is the case because `dd` initialized
    it's read buffer to `NULL`s).
  prefs: []
  type: TYPE_NORMAL
- en: The `PRINT_CTX()` macro we have used within the code lives within our `convenient.h` header.
    Do take a look; it's quite instructive (we try and emulate the kernel `Ftrace` infrastructure's latency
    output format, which reveals a lot of detail in a small space, a single line of
    output). This is explained in detail in [Chapter 4](cfd1ca5d-cd0b-451d-8a35-31e65a09d2e4.xhtml),
    *Handling Hardware Interrupts*, in the *Fully figuring out the context* section.
    Don't worry about all the details for now...
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 1.6* shows how we (minimally) test writing to our driver, again via
    `dd(1)`. This time we read `4k` of random data (by leveraging the kernel''s built-in `mem`
    driver''s `/dev/urandom` facility), and write the random data to our device node;
    in effect, to our ''device'':'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3bf0f7e7-4cc3-49a7-a935-1bc099c22e46.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.6 – Screenshot showing us minimally testing our miscdrv driver's write
    method via dd(1)
  prefs: []
  type: TYPE_NORMAL
- en: '(By the way, I have also included a simple user space test app for the driver;
    it can be found here: `ch1/miscdrv/rdwr_test.c`. I will leave it to you to read
    its code and try out.)'
  prefs: []
  type: TYPE_NORMAL
- en: 'You might be thinking: we did apparently succeed in reading and writing data
    to and from user space to our driver, but, hang on, we never actually saw any data
    transfer taking place within the driver code. Yes, this is the topic of the next
    section: how you will actually copy the data from the user space process buffer
    into your kernel driver''s buffer, and vice versa. Read on!'
  prefs: []
  type: TYPE_NORMAL
- en: Copying data from kernel to user space and vice versa
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A primary job of the device driver is to enable user space applications to transparently
    both read and write data to the peripheral hardware device (typically a chip of
    some sort; it may not be hardware at all though), treating the device as though
    it were simply a regular file. Thus, to read data from the device, the application
    opens the device file corresponding to that device, thus obtaining a file descriptor,
    and then simply issues a `read(2)` system call using that `fd` (*step 1* in *Figure
    1.7)*! The kernel VFS intercepts the read, and, as we have seen, has control flow
    to the underlying device driver's read method (which is a C function, of course).
    The driver code now "talks" to the hardware device, actually performing the I/O,
    the read operation. (The specifics of how exactly the hardware read (or write)
    is performed depends very much on the type of hardware – is it a memory-mapped
    device, a port, a network chip, and so on? We will not delve further into this
    here; the next chapter does.) The driver, having read data from the device, now
    places this data into a kernel buffer, `kbuf` (*step 2* in the following diagram.
    Of course, we assume the driver author allocated memory for it via `[k|v]malloc()`
    or another suitable kernel API).
  prefs: []
  type: TYPE_NORMAL
- en: We now have the hardware device data in a kernel space buffer. How should we
    transfer it to the user space process's memory buffer? We shall exploit kernel
    APIs that make it easy to do so; this is covered next.
  prefs: []
  type: TYPE_NORMAL
- en: Leveraging kernel APIs to perform the data transfer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, as mentioned previously, let''s assume your driver has read in the hardware
    data, and that it''s now present in a kernel memory buffer. How do we transfer
    it to user space? A naive approach would be to simply try and perform this via
    `memcpy()`, but *no, *that does not work (why? one, it''s insecure and two, it''s
    very arch-dependent; it works on some architectures and not on others). So, a
    key point: the kernel provides a couple of inline functions to transfer data from
    kernel to user space and vice versa. They are `copy_to_user()` and `copy_from_user()`,
    respectively, and are indeed very commonly used.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using them is simple. Both take three parameters: the `to`pointer (destination
    buffer), the `from`pointer (source buffer), and `n`, the number of bytes to copy
    (think of it as you would for a `memcpy` operation):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The return value is the number of *uncopied* bytes; in other words, a return
    value of `0` indicates success and a non-zero return value indicates that the
    given number of bytes were not copied. If a non-zero return occurs, you should
    (following the usual `0/-E` return convention) return an error indicating an I/O
    fault by returning `-EIO` or `-EFAULT` (which thus sets `errno` in user space
    to the positive counterpart). The following (pseudo) code illustrates how a device
    driver can use the `copy_to_user()` function to copy some data from kernel to
    user space:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, of course, we assume you have a valid allocated kernel memory buffer, `kbuf`,
    and a valid device pointer (`struct device *dev`). *Figure 1.7* illustrates what
    the preceding (pseudo) code is trying to achieve:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2ddabab1-d742-40ea-992e-89083c8e7fdd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.7 – Read: copy_to_user(): copying data from the hardware to a kernel
    buffer and from there to a user space buffer'
  prefs: []
  type: TYPE_NORMAL
- en: The same semantics apply to using the `copy_from_user()` inline function. It
    is typically used in the context of the driver's write method, pulling in the
    data written by the user space process context to a kernel space buffer. We will
    leave it to you to visualize this.
  prefs: []
  type: TYPE_NORMAL
- en: It is also important to realize that both routines (`copy_[from|to]_user()`)
    might, during their run, cause the process context to (page) fault and thus sleep;
    in other words, to invoke the scheduler. Hence, **they can only be used in a process
    context where it's safe to sleep and never in any kind of atomic or interrupt
    context** (we explain more on the `might_sleep()` helper – a debug aid – in [Chapter
    4](cfd1ca5d-cd0b-451d-8a35-31e65a09d2e4.xhtml), *Handling Hardware Interrupts*,
    in the *Don't block – spotting possibly blocking code** paths* section).
  prefs: []
  type: TYPE_NORMAL
- en: 'For the curious reader (I hope you are one!), here are some links with a bit
    more of a detailed explanation on why you cannot just use a simple `memcpy()` but
    must use the `copy_[from|to]_user()` inline functions to copy data from and to
    the kernel and user spaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[ht](https://stackoverflow.com/questions/14970698/copy-to-user-vs-memcpy)[tps://stackoverflow.com/questions/14970698/copy-to-user-vs-memcpy](https://stackoverflow.com/questions/14970698/copy-to-user-vs-memcpy)
    [](https://stackoverflow.com/questions/14970698/copy-to-user-vs-memcpy)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https:](https://www.quora.com/Why-we-need-copy_from_user-as-the-kernel-can-access-all-the-memory-If-we-see-the-copy_from_user-implementation-again-we-are-copying-data-to-the-kernel-memory-using-memcpy-Doesnt-it-an-extra-overhead)[//www.quora.com/Why-we-need-copy_from_user-as-the-kernel-can-access-all-the-memory-If-we-see-the-copy_from_user-implementation-again-we-are-copying-data-to-the-kernel-memory-using-memcpy-Doesnt-it-an-extra-overhead](https://www.quora.com/Why-we-need-copy_from_user-as-the-kernel-can-access-all-the-memory-If-we-see-the-copy_from_user-implementation-again-we-are-copying-data-to-the-kernel-memory-using-memcpy-Doesnt-it-an-extra-overhead).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the following section, we shall write a more complete `misc` framework character
    device driver, which will actually perform some I/O, reading and writing data.
  prefs: []
  type: TYPE_NORMAL
- en: A misc driver with a secret
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you understand how to copy data between user and kernel space (and
    the reverse), let's write another device driver (`ch1/miscdrv_rdwr`) based on
    our previous skeleton (`ch1/miscdrv/`) miscellaneous driver. The key difference
    is that we use a few global data items (within a structure) throughout, and actually
    perform some I/O in the form of reads and writes. Here, let's introduce the notion
    of a **driver context or private driver data structure**; the idea is to have
    a conveniently accessible data structure that contains all relevant information
    in one place. Here, we name this structure `struct drv_ctx` (see it in the code
    listing that follows). On driver initialization, we allocate memory to and initialize
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, there''s no real secret here, it just makes it sound interesting. One
    of the members within this driver context data structure of ours is a so-called
    secret message (it''s the `drv_ctx.oursecret` member, along with some (fake) statistics
    and config words). This is the simple "driver context" or private data structure
    we propose using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Great; now let's move on to seeing and understanding the code.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the 'secret' misc device driver's code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ve divided this discussion on the implementation details of our secret
    misc character device driver into five parts: driver initialization, the read
    method, the write method functionality implementation, the driver cleanup, and
    finally, the userspace application that will use our device driver.'
  prefs: []
  type: TYPE_NORMAL
- en: Our secret driver – the init code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the `init` code of our secret device driver (a kernel module, of course,
    thus invoked upon `insmod(8)`), we first register the driver as a `misc` character
    driver with the kernel (via the `misc_register()` API, as seen in the *Writing
    the misc driver code – part 1* section earlier; we won't repeat this code here).
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we allocate kernel memory for our driver''s "context" structure – via
    the useful managed allocation  `devm_kzalloc()` API (as you learned in the companion
    guide *Linux Kernel Programming,* Chapter 8, *Kernel Memory Allocation for Module
    Authors – Part 1*, in the *Using the kernel''s resource-managed memory allocation
    APIs* section) – and initialize it. Notice that you must ensure you first get
    the device pointer `dev` before you can use this API; we retrieve it from our
    `miscdevice` structure''s `this_device` member (as seen):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Okay, clearly, we have initialized the `dev` member of our `ctx` private structure
    instance as well as the 'secret' string to the `'initmsg'`  string (not a very
    convincing secret, but let's leave it at that). The idea here is that when a user
    space process (or thread) opens our device file and issues `read(2)` upon it,
    we pass back (copy) the secret to it; we do so by invoking the `copy_to_user()` helper
    function! Similarly, when the user-mode app writes data to us (yes, via the `write(2)` system
    call), we consider that data written to be the new secret. So, we fetch it from
    its user space buffer – via the `copy_from_user()` helper function – and update
    it in driver memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Why not simply use the `strcpy()` (or `strncpy()`) API to initialize the `ctx->oursecret` member?
    This is very important: they aren''t safe enough security-wise. Also, the `strlcpy()` API
    has been marked as **deprecated** by the kernel community ([https://www.kernel.org/doc/html/latest/process/deprecated.html#strlcpy](https://www.kernel.org/doc/html/latest/process/deprecated.html#strlcpy)). In
    general, always avoid using deprecated stuff, as documented in the kernel documentation
    here: [https://www.kernel.org/doc/html/latest/process/deprecated.html#deprecated-interfaces-language-features-attributes-and-conventions](https://www.kernel.org/doc/html/latest/process/deprecated.html#deprecated-interfaces-language-features-attributes-and-conventions).'
  prefs: []
  type: TYPE_NORMAL
- en: Quite clearly, the interesting parts of this new driver are the I/O functionality
    – the *read* and *write* methods; on with it!
  prefs: []
  type: TYPE_NORMAL
- en: Our secret driver – the read method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We will first show the relevant code for the read method – this is how a user
    space process (or thread) can read in the secret information housed within our
    driver (in its context structure):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `copy_to_user()` routine does its job – it copies the `ctx->oursecret` source
    buffer to the destination pointer, the `ubuf` user space buffer, for `secret_len`
    bytes, thus transferring the secret to the user space app. Now, let's check out
    the driver's write method.
  prefs: []
  type: TYPE_NORMAL
- en: Our secret driver – the write method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The end user can change the secret by writing a new secret into the driver,
    via a `write(2)` system call to the driver''s device node. The kernel redirects the
    write (via the VFS layer) to our driver''s write method (as you learned in the *Understanding
    the connection between the process, the driver, and the kernel* section):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We employ the `kvmalloc()` API to allocate memory for a buffer to hold the
    user data that we will copy in. The actual copying is done via the `copy_from_user()`
    routine, of course. Here, we use it to copy the data passed by the user space
    app to our kernel buffer, `kbuf`. We then (via the `strscpy()` routine) update
    our driver''s context structure''s `oursecret` member to this value, thus updating
    the secret! (A subsequent read on the driver will now reveal the new secret.)
    Also, do notice the following:'
  prefs: []
  type: TYPE_NORMAL
- en: How we now consistently use the `dev_xxx()` helpers in place of the usual `printk`
    routines. This is recommended for device drivers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The (now typical) usage of `goto` to perform optimal error handling.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This covers the meat of the driver.
  prefs: []
  type: TYPE_NORMAL
- en: Our secret driver – cleanup
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It''s important to realize that we must free any buffers we have allocated.
    Here, however, as we performed a managed allocation in the `init` code (`devm_kzalloc()`),
    we have the benefit of not needing to worry about cleanup; the kernel handles
    it. Of course, in the driver''s cleanup code path (invoked upon `rmmod(8)`), we
    deregister the `misc` driver with the kernel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: You will notice that we also, seemingly uselessly, use two global integers, `ga` and `gb`, in
    places in this version of the driver. Indeed, they have no real meaning here;
    the reason we have them at all becomes clear only in the last two chapters of
    this book, on kernel synchronization. Please ignore them for now.
  prefs: []
  type: TYPE_NORMAL
- en: On this note, you'll perhaps realize that the way we have arbitrarily accessed
    global data in this driver **can cause concurrency issue (*data races!*)**; yes
    indeed; we shall set aside the deep and crucial coverage of kernel concurrency
    and synchronization to the book's last two chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Our secret driver – the user space test app
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Writing just the kernel component, the device driver, isn't quite enough; you
    also have to write a user space application that will actually make use of the
    driver. We will do so here. (Again, you could simply use `dd(1)` as well.)
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to use the device driver, the user space app must first, of course,
    openthe device file corresponding to it. (Here, to save space, we don''t show
    the app code in its entirety, just the most relevant portions of it. We expect
    you to have cloned the book''s Git repository and to work on the code.) The code
    to open the device file is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The second argument to this app is the device file to open. In order to read
    or write, the process will require memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Moving along, let''s see the block of code to have the app invoke a read or
    write (depending on the first parameter being `r` or `w`) on the (pseudo)device
    (for conciseness, we don''t show the error handling code):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '(Before you try out this driver, do ensure the previous `miscdrv`driver''s
    kernel module is unloaded.) Now, ensure that this  driver is built and inserted,
    of course, else it will result in the `open(2)` system call failing. We have shown
    a couple of trial runs. First, let''s build the user-mode app, insert the driver
    (not shown in *Figure 1.8*), and read from our just-created device node:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b40b7ebe-f9d3-4ec2-b1c0-199633935f2c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.8 – miscdrv_rdwr: (minimally) testing the read; the original secret
    is revealed'
  prefs: []
  type: TYPE_NORMAL
- en: The user-mode app successfully receives 7 bytes from the driver; it's the (initial)
    secret value, which it displays. The kernel log reflects the driver initialization,
    and a few seconds later, you can see (via the `dev_xxx()` instances of `printk` we
    emitted) that the `rdwr_test_secret` app runs the drivers' code in process context.
    The opening of the device, the running of the subsequent read, and the close methods
    are clearly seen. (Notice how the process name is truncated to `rdwr_test_secre`;
    this is as the task structure's `comm` member is the process name truncated to
    16 characters.)
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Figure 1.9*, we show the complementary act of writing to our device node,
    changing the secret value; a subsequent read indeed reveals that it has worked:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/821a37e0-9a8b-4b33-93b0-eb4f40dc8639.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.9 – miscdrv_rdwr: (minimally) testing the write; a new, excellent
    secret is written'
  prefs: []
  type: TYPE_NORMAL
- en: The portion of the kernel log where the write takes place is highlighted in
    *Figure 1.9*. It works; I definitely encourage you to try this out yourself, looking
    up the kernel log as you go along.
  prefs: []
  type: TYPE_NORMAL
- en: Now, it's time to dig a little deeper. The reality is that as a driver author,
    you have to learn to be really careful regarding *security*, else all kinds of
    nasty surprises lie in wait. The next section gives you an understanding of this
    key area.
  prefs: []
  type: TYPE_NORMAL
- en: Issues and security concerns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An important consideration, for the budding driver author, is security. The
    trouble is, naive usage of even the very common `copy_[from|to]_user()` functions
    within your driver can let a malicious user quite easily – and illegally – overwrite
    memory to their advantage in both user and kernel spaces. How? The following section
    explains this in some detail; then, we will even show you a (bit contrived, but
    nevertheless, working) hack.
  prefs: []
  type: TYPE_NORMAL
- en: Hacking the secret driver
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Think about this: we have the `copy_to_user()` helper routine; the first parameter
    is the destination `to` address, which should be a user space virtual address
    (a UVA), of course. Regular usage will comply with this and provide a legal and
    valid user space virtual address as the destination address, and all will be well.'
  prefs: []
  type: TYPE_NORMAL
- en: But what if we don't? What if we pass another user space address, or, check
    this out – a *kernel *virtual address (a KVA) – in its place? The `copy_to_user()`
    code will now, running with kernel privileges, overwrite the destination with
    whatever data is in the source address (the second parameter) for the number of
    bytes in the third parameter! Indeed, hackers often attempt techniques such as
    this, to insert code posing as data into a user space buffer and execute it with
    kernel privilege, leading to a quite deadly **privilege escalation** (privesc) scenario.
  prefs: []
  type: TYPE_NORMAL
- en: To clearly demonstrate the adverse effects of not carefully designing and implementing
    a driver, we deliberately introduce errors (bugs, really!) into both the read
    and write methods of a 'bad' version of our previous driver (although here, we
    only consider the scenario with respect to the very common `copy_[from|to]_user()`
    routines and nothing else).
  prefs: []
  type: TYPE_NORMAL
- en: 'To get a more hands-on feel for this, we will write a "bad" version of our `ch1/miscdrv_rdwr` driver.
    We''ll call it (ever so cleverly) `ch1/bad_miscdrv`. In this version, we deliberately
    have two buggy code paths built into it:'
  prefs: []
  type: TYPE_NORMAL
- en: One within the driver's read method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The other, the more exciting one, as you shall soon see, within the write method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's check both out. We'll begin with the buggy read.
  prefs: []
  type: TYPE_NORMAL
- en: Bad driver – buggy read()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To help you see what''s changed in the code, we first perform a `diff(1)` of
    this (deliberately) bad driver code with our previous (good) version, yielding
    the differences, of course (in the following snippet, we curtail the output to
    only what''s most relevant):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'So, it should be quite clear: in our ''bad'' driver''s read method, if the
    `READ_BUG` macro is defined, we alter the user space destination pointer to point
    to an illegal location (512 KB beyond the location we should actually copy the
    data to!). This demonstrates the point here: we can do arbitrary stuff like this
    because we are running with kernel privileges*. *That it will cause issues and
    bugs is a separate matter.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try it: first, do ensure that you''ve built and loaded the `bad_miscdrv`
    kernel module (you can use our `lkm` convenience script to do so). Our trial run,
    issuing a `read(2)` system call via our `ch1/bad_miscdrv/rdwr_test_hackit` user-mode
    app, results in failure (see the following screenshot):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7beb9fad-e2d5-495f-8d72-951812ac41e1.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.10 – Screenshot showing our bad_miscdrv misc driver performing a "bad"
    read
  prefs: []
  type: TYPE_NORMAL
- en: Ah, this is interesting; our test application's (`rdwr_test_hackit`) `read(2)` system
    call does indeed fail, with the `perror(3)` routine indicating the cause of failure
    as `Bad address`. But why? Why didn't the driver, running with kernel privileges,
    actually write to the destination address (here, `0x5597245d46b0` , the wrong
    one; as we know, it's attempting to write 512 KB *ahead* of the correct destination
    address. We deliberately wrote the driver's read method code to do so).
  prefs: []
  type: TYPE_NORMAL
- en: 'This is because kernel  ensures that the `copy_[from|to]_user()` routines will
    (ideally) fail when attempting to read or write illegal addresses! Internally,
    several checks are done: `access_ok()` is a simple one merely ensuring that I/O
    is performed within the expected segment (user or kernel). Modern Linux kernels
    have superior checking; besides the simple `access_ok()` check, the kernel then
    wades through – if enabled – the **KASAN** (**Kernel Address Sanitizer**, a compiler
    instrumentation feature; KASAN is indeed very useful, a *must-do* during development
    and test!), checks on object sizes (including overflow checks), and only then
    does it invoke the worker routine that performs the actual copy, `raw_copy_[from|to]_user()`.'
  prefs: []
  type: TYPE_NORMAL
- en: Okay, that's good; now, let's move on to the more interesting case, the buggy
    write, which we shall arrange (in a contrived manner though) to make into an attack!
    Read on...
  prefs: []
  type: TYPE_NORMAL
- en: Bad driver – buggy write() – a privesc!
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What does the malicious hacker really want, their holy grail? A root shell on
    the system, of course (*got root?*). With a good deal of contrived code within
    our driver's write method (thus making this hack not a really good one; it's quite
    academic), let's go get it! To do so, we modify both the user-mode app as well
    as the device driver. Let's look at the user-mode app's changes first.
  prefs: []
  type: TYPE_NORMAL
- en: User space test app modifications
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We slightly modify the user space application – our process context, in effect. This
    particular version of the user-mode test app differs from the earlier one in one
    regard: we now have a macro called `HACKIT`. If it''s defined (it is by default),
    this process will deliberately write only zeroes into the user space buffer and
    send that to our bad driver''s write method. If the driver has the `DANGER_GETROOT_BUG`
    macro defined (it is by default), then it will write the zeroes into the process''s
    UID member, thus making the user-mode process obtain root privileges!'
  prefs: []
  type: TYPE_NORMAL
- en: In the traditional Unix/Linux paradigm, if the **Real User ID** (**RUID**) and/or
    **Effective User ID** (**EUID**) (they're within the task structure, in `struct
    cred`) are set to the special value zero (`0`), it implies that the process has
    superuser (root) powers. Nowadays, the POSIX Capabilities model is considered
    a superior way to work with privileges, as it allows assigning fine-grained permissions
    – *capabilities* – on a thread, as opposed to giving a process or thread complete
    control over the system as root.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a quick `diff` of the user space test app from the previous version,
    allowing you to see the changes made to the code (again, we curtail the output
    to only what''s most relevant):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This does imply that the (so-called) secret never gets written; that's okay.
    Now, let's look at the modifications made to the driver.
  prefs: []
  type: TYPE_NORMAL
- en: Device driver modifications
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To see how our bad `misc` driver''s write method changes, we will continue
    looking at the same `diff` (of our bad versus good drivers) that we did in the *Bad
    driver – buggy read()* section. The comments in the code from the following `diff` operation
    are quite self-explanatory. Check it out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The key point from the preceding code is that when the `DANGER_GETROOT_BUG` macro is
    defined (it is by default), we set the `new_dest` pointer to the address of the
    (real) UID member within the credential structure, which is itself within the
    task structure (referenced by `current`) for this process context! (If all of
    this sounds foreign, please read the companion guide *Linux Kernel Programming,* Chapter
    6, *Kernel Internals Essentials – Processes and Threads*). This way, when we invoke
    the `copy_to_user()` routine to perform the write to user space, it's going to
    actually write zeroes to the process UID member within `current->cred`. A UID
    of zero is what (traditionally) defines root. Also, notice how we restrict the
    write to 4 bytes (as we're just writing a 32-bit quantity).
  prefs: []
  type: TYPE_NORMAL
- en: '(By the way, the build on our "bad" driver does issue a warning; here, with
    it being intentional, we merely ignore it):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the `copy_from_user()` code invocation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Clearly, the preceding `copy_to_user()` routine will write the user-supplied
    buffer, `ubuf`, into the `new_dest` destination buffer – which, crucially, we
    have made point to `current->cred->uid` – for `count` bytes.
  prefs: []
  type: TYPE_NORMAL
- en: Let's get root now
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Of course, the proof of the pudding is in the eating, yes? So, let''s give
    our hack a spin; here, we assume that you''ve first unloaded any previous version
    of our ''misc'' drivers, and built and loaded the `bad_miscdrv` kernel module
    into memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b3477088-14a9-4ae5-9f29-8fdca1ffd939.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.11 – Screenshot showing our bad_miscdrv misc driver performing a "bad"
    write, resulting in root – a privesc!
  prefs: []
  type: TYPE_NORMAL
- en: 'Check it out; **we indeed got root!** Our `rdwr_test_hackit` app, detecting
    that we do have root (via a simple `getuid(2)`system call), then does the logical
    thing: it execs a root shell (via an `execl(3)` API), and voilà, we land up in
    a root shell. We show the kernel log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see how it''s worked: the original user-mode buffer `ubuf` kernel virtual
    address is `0x55648b8f36b0`. In the hack, we modify it to the new destination
    address (kernel virtual address), `0xffff9f67765c3b44`, which is (in this case)
    the kernel virtual address of the UID member of `struct cred` (within the process''s
    task structure). Not only that, but our driver also modifies the number of bytes
    to write (`count`) to `4` (bytes), as we''re updating a 32-bit quantity.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Do note: these hacks are just that – hacks. They could certainly cause your
    system to become unstable (when run on our "debug" kernel, KASAN, in fact, detected
    a null pointer dereference!).'
  prefs: []
  type: TYPE_NORMAL
- en: These demos prove nothing but the fact that you as a kernel and/or driver author
    must be alert to programming issues, security, and more at all times. With this,
    we complete this section and indeed the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This concludes this chapter on writing a simple `misc` class character device
    driver on the Linux OS; so, awesome, you now know the basics of writing a device
    driver on Linux!
  prefs: []
  type: TYPE_NORMAL
- en: The chapter began with an introduction to device basics, and importantly, the
    very brief essentials of the modern LDM. You then learned how to write a simple
    first character device driver, registering with the kernel's `misc`framework.
    Along the way, you also understood the connection between the process, the driver,
    and the kernel VFS. Copying data between user and kernel address spaces is essential;
    we saw how to do so. A more comprehensive demo `misc` driver (our 'secret' driver)
    showed you how to perform I/O – reads and writes – ferrying data between user
    and kernel space. A key part of this chapter is the last section, where you learned
    (well, made a start at least) about security and the driver; a "hack" even demonstrated
    a *privesc* attack!
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned before, there's much more to this vast topic of writing drivers
    on Linux; indeed, whole books are devoted to it! Do check out the *Further reading *section
    for this chapter to find relevant books and online references.
  prefs: []
  type: TYPE_NORMAL
- en: In the following chapter you will learn a key task for a driver author - how
    exactly can you efficiently interface your device driver with user space processes;
    several useful approaches are covered in detail and contrasted. Do ensure you're
    clear on this chapter's material, work on the exercises given, review the *Further
    reading *resources and then dive into the next one.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Load up the first `miscdrv`skeleton `misc` driver kernel module and issue `lseek(2)`
    on it; what happens? (Does it succeed? What's the return value from `lseek`?)
    If not, okay, how will you fix this?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write a `misc` class character driver that behaves as a simple converter program (assume
    its path name is `/dev/convert`). For example, writing the temperature in Fahrenheit
    units, it should return (write to the kernel log) the temperature in Celsius.
    Thus, doing `echo 98.6 > /dev/convert` should result in the value `37 C` being
    written to the kernel log. Additionally, do the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Validate that the data passed to your driver is a numeric value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How will you handle floating-point values? (Tip: refer to the section *Floating
    point not allowed in the kernel* in *Linux Kernel Programming*, *Chapter 5*, *Writing
    Your First Kernel Module LKMs – Part 2.*)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a "task display" driver; here, we'd like a user space process to write
    a thread (or process) PID to it. When you now read from the driver's device node
    (assume its path name is `/dev/task_display`), you should receive details regarding
    the task (which is pulled from its task structure, of course). For example, doing `echo
    1 > /dev/task_display` followed by `cat /dev/task_display` should have the driver
    emit task details of PID 1 to the kernel log. Don't forget to add validity checks
    (check the PID is valid, and so on).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: (A bit more advanced:) Write a "proper" LDM-based driver; the `misc` drivers
    covered here did register with the kernel's `misc` framework, but simply, implicitly,
    used the raw character interface as the bus. The LDM prefers that a driver must register
    with a kernel framework and a bus driver. Hence, write a "demo" driver that registers
    itself with the kernel's `misc` framework and the platform bus. This will involve
    creating a fake platform device as well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '(*Note the following t**ips*:'
  prefs: []
  type: TYPE_NORMAL
- en: a) Do refer to [Chapter 2](4042025e-27a1-40f4-a2f7-223f601107dc.xhtml), *User-Kernel
    Communication Pathways*, particularly the *Creating a simple platform device* and *Platform
    devices* sections.
  prefs: []
  type: TYPE_NORMAL
- en: b) A possible solution to this driver can be found here: `solutions_to_assgn/ch12/misc_plat/`.)
  prefs: []
  type: TYPE_NORMAL
- en: 'You will find some of the questions answered in the book''s GitHub repo: [https://github.com/PacktPublishing/Linux-Kernel-Programming-Part-2/tree/main/solutions_to_assgn](https://github.com/PacktPublishing/Linux-Kernel-Programming-Part-2/tree/main/solutions_to_assgn).'
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Linux device drivers books:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Linux Device Drivers Development*, John Madieu, Packt, Oct 2017: [https://www.amazon.in/Linux-Device-Drivers-Development-Madieu/dp/1785280007/ref=sr_1_2?keywords=linux+device+driver&qid=1555486515&s=books&sr=1-2](https://www.amazon.in/Linux-Device-Drivers-Development-Madieu/dp/1785280007/ref=sr_1_2?keywords=linux+device+driver&qid=1555486515&s=books&sr=1-2) ;
    excellent coverage, as well as very recent (as of this writing; it covers the
    4.13 kernel)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Linux Driver Development for Embedded Processors - Second Edition: Learn to
    develop embedded Linux drivers with kernel 4.9 LTS*, Alberto Liberal de los Rios:
    [https://www.amazon.in/Linux-Driver-Development-Embedded-Processors-ebook/dp/B07L512BHG/ref=sr_1_6?crid=3RLFFZQXGAMF4&keywords=linux+driver+development+embedded&qid=1555486342&s=books&sprefix=linux+driver+%2Cstripbooks%2C270&sr=1-6-catcorr](https://www.amazon.in/Linux-Driver-Development-Embedded-Processors-ebook/dp/B07L512BHG/ref=sr_1_6?crid=3RLFFZQXGAMF4&keywords=linux+driver+development+embedded&qid=1555486342&s=books&sprefix=linux+driver+%2Cstripbooks%2C270&sr=1-6-catcorr)
    ; very good, as well as recent (4.9 kernel)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Essential Linux Device Drivers*, Sreekrishnan Venkateswaran, Pearson: [https://www.amazon.in/Essential-Drivers-Prentice-Software-Development/dp/0132396556/ref=tmm_hrd_swatch_0?_encoding=UTF8&qid=&sr=](https://www.amazon.in/Essential-Drivers-Prentice-Software-Development/dp/0132396556/ref=tmm_hrd_swatch_0?_encoding=UTF8&qid=&sr=) ;
    simply excellent, wide coverage'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Linux Device Drivers*, Rubini, Hartmann, Corbet, 3rd Edition: [https://www.amazon.in/Linux-Device-Drivers-Kernel-Hardware/dp/8173668493/ref=sr_1_1?keywords=linux+device+driver&qid=1555486515&s=books&sr=1-1](https://www.amazon.in/Linux-Device-Drivers-Kernel-Hardware/dp/8173668493/ref=sr_1_1?keywords=linux+device+driver&qid=1555486515&s=books&sr=1-1)
    ; venerable (but) old – the famous LDD3 book'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Official kernel documentation:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Linux Kernel Device Model: [https://www.kernel.org/doc/html/latest/driver-api/driver-model/overview.html#the-linux-kernel-device-model](https://www.kernel.org/doc/html/latest/driver-api/driver-model/overview.html#the-linux-kernel-device-model).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The kernel driver API manual; this is one of the PDF documents generated by
    doing `make pdfdocs` within a recent Linux kernel source tree.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deprecated Interfaces, Language Features, Attributes, and Conventions: [https://www.kernel.org/doc/html/latest/process/deprecated.html#deprecated-interfaces-language-features-attributes-and-conventions](https://www.kernel.org/doc/html/latest/process/deprecated.html#deprecated-interfaces-language-features-attributes-and-conventions).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Practical tutorials:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Device Drivers, Part 8: Accessing x86-Specific I/O-Mapped Hardware*, Anil
    K Pugalia, OpenSourceForU, July 2011: [https://opensourceforu.com/2011/07/accessing-x86-specific-io-mapped-hardware-in-linux/](https://opensourceforu.com/2011/07/accessing-x86-specific-io-mapped-hardware-in-linux/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'User space device drivers; check out this interesting video presentation by
    Chris Simmonds: *How to Avoid Writing Device Drivers for Embedded Linux*: [https://www.youtube.com/watch?v=QIO2pJqMxjE&t=909s](https://www.youtube.com/watch?v=QIO2pJqMxjE&t=909s)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
