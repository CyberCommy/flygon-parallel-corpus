- en: Connecting the Network
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter contains the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Resolving local IP addresses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting to the remote server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resolving the domain by IP address and vice versa
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting to the HTTP server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parsing and building a URL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an HTTP request
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading and writing HTTP headers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling HTTP redirects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consuming the RESTful API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending a simple email
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calling the JSON-RPC service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is all about networking. Most of the recipes in this chapter are
    focused on the client side. We will go through how to resolve basic information
    about the network on the machine, domain names and IP resolution, and connecting
    through TCP-related protocols such as HTTP and SMTP. Finally, we will make a remote
    procedure call via JSON-RCP 1.0 with the use of the standard library.
  prefs: []
  type: TYPE_NORMAL
- en: Check whether Go is properly installed. The *Getting ready* section from the *Retrieving
    Golang version* recipe from [Chapter 1](acf67248-0aa9-4150-a43b-d13eb9de89f2.xhtml), *Interacting
    With Environment,* will help you. Verify if any other application blocks the `7070` port.
  prefs: []
  type: TYPE_NORMAL
- en: Resolving local IP addresses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe explains how to retrieve IP addresses from available local interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the console and create the folder `chapter07/recipe01`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the `interfaces.go` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Execute the code by running `go run interfaces.go` in the main Terminal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will see the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ddce79d8-a358-413f-8c89-f021731934eb.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The net package contains the `Interfaces` function, which lists the network
    interfaces as a slice of the `Interface` struct. The `Interface` struct has the `Addrs` method,
    which lists the available network addresses. This way, you can list the addresses
    by their interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Another option is to use the `InterfaceAddrs` function of the `net` package,
    which provides the slice of structs that implement the `Addr` interface. This
    provides you with methods to obtain the information you want.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to the remote server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: TCP-based protocols are the most significant protocols used in network communication.
    Just as a reminder, HTTP, FTP, SMTP, and other protocols are part of this group. This
    recipe gives you an insight on how to connect to the TCP server in general.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the console and create the folder `chapter07/recipe02`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the `tcpclient.go` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Execute the code by running `go run tcpclient.go` in the main Terminal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will see the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/bccd624a-a108-4726-9e67-e477ed5af73a.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The net package contains the `Dial` function, which consumes the network type
    and address. In the previous example, the network is `tcp` and the address is
    `localhost:8080`.
  prefs: []
  type: TYPE_NORMAL
- en: Once the `Dial` function is successful, the `Conn` type is returned, which serves
    as a reference to the opened socket. The `Conn` interface also defines the `Read`
    and `Write` functions, so they can be used as `Writer` and `Reader` functions
    for writing and reading from the socket. Finally, the sample code uses `Scanner`
    to obtain the response. Note that the `Scanner`, in this case, works because of
    the brake lines. Otherwise, the more generic `Read` method should be used. In
    the example, the `Read` deadline is set via the `SetReadDeadline` method. The
    important thing about this is that the deadline is not a duration, but a `Time`.
    This means the deadline is set as a time point in the future. If you are reading
    the data from a socket in a loop and need to set the read timeout to 10 seconds,
    each iteration should contain code such as `conn.SetReadDeadline(time.Now().Add(10*time.Second))`.
  prefs: []
  type: TYPE_NORMAL
- en: Just to enlighten the whole code sample, the HTTP server from the `HTTP` standard
    package is used as a counterpart to the client. This part is covered in a separate
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Resolving the domain by IP address and vice versa
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will introduce you to how you can translate IP addresses into host
    addresses and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the console and create the folder `chapter07/recipe03`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the `lookup.go` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Execute the code by running `go run lookup.go` in the main Terminal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will see the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5e731d6f-2943-4a89-9c3c-b4758c812f9d.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The resolution of the domain name from the IP address can be done with the `LookupAddr`
    function from the `net` package. To find out the `IP` address from the domain
    name, the `LookupIP` function is applied.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to the HTTP server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous recipe, *Connecting to the remote server,* gave us an insight into
    how to connect the TCP server at a lower level. In this recipe, communication
    with the HTTP server at a higher level will be shown.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the console and create the folder `chapter07/recipe04`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the `http.go` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Execute the code by running `go run http.go` in the main Terminal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will see the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5b70d6e0-fa81-4aa0-ab14-68185d52291e.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Connecting to the HTTP server can be done with help of the `net/http` package.
    Naturally, there are more ways you can achieve this, but the code above illustrates
    two of the most common approaches. The first option implemented the `simplePost` function,
    and illustrates the use of a default client. The POST method is chosen here as
    it is more complex than GET. The `Post` method accepts the URL, content type,
    and body in the form of `Reader`. Invoking the `Post` function immediately requests
    the server and returns the result.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the `Post` method is just wrapping a function that uses the `http.DefaultClient`
    in its implementation. The `net/http` package also contains the `Get` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `useRequest` function implements the same functionality, but with the use
    of a more customizable API and its own instance of `Client`. The implementation
    utilizes the `NewRequest` function to create the request based on these given
    arguments: method, URL, and request body. The content type must be set separately
    to the `Header` property. The request is executed with the `Do` method, which
    is created on the `Client`.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Creating an HTTP request* recipe that will help you assemble a request
    in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Parsing and building a URL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In many cases, it is better to manipulate a URL with the use of handy tools
    than trying to handle it as a simple string. Go standard libraries naturally contain
    the utilities to manipulate a URL. This recipe will go through some of these major
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the console and create the folder `chapter07/recipe05`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the `url.go` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Execute the code by running `go run url.go` in the main Terminal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will see the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c373cc32-7a41-4cad-b4e1-f4f39a2f4d57.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `net/url` package is designed to help you with the manipulation and parsing
    of a URL. The `URL` struct contains the necessary fields to put a URL together.
    With the `String` method of the `URL` struct, the transformation to a simple string
    can be easily done.
  prefs: []
  type: TYPE_NORMAL
- en: When the string representation is available and additional manipulation is needed,
    the `Parse` function of `net/url` can be utilized. This way, the string can be
    transformed to a `URL` struct, and the underlying URL can be modified.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an HTTP request
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will show you how to construct a HTTP request with specific parameters.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the console and create the folder `chapter07/recipe06`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the `request.go` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Execute the code by running `go run request.go` in the main Terminal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will see the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/1dd93ab3-741d-4210-9731-15401233a43c.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The more complex way to construct the request is presented in the sample code.
    With the `NewRequest` method of the `net/http` package, the pointer to the `Request`
    struct is returned. The function consumes the method's request, URL, and body
    of the request. Notice the way the form is built. Instead of using the plain string,
    the `url.Values` struct is used. Finally, the `Encode` method is called to encode
    the given form values. The headers are set via the `http.Header` property of the
    request.
  prefs: []
  type: TYPE_NORMAL
- en: Reading and writing HTTP headers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous recipe describes how you can create a HTTP request in general.
    This recipe will go into detail on how to read and write request headers.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the console and create the folder `chapter07/recipe07`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the `headers.go` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Execute the code by running `go run headers.go` in the main Terminal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will see the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c967698b-5d62-4f82-bca4-24abeb3a84a2.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The headers in the `http` package are, in fact, represented as `map[string][]string`,
    and this way, the `Header` type must be handled. The preceding code shows how
    to set and read the header values. The important thing about the header is that
    the value of the header key is the `string` slice. So, each key in a header can
    contain multiple values.
  prefs: []
  type: TYPE_NORMAL
- en: The `Set` method of the `Header` type sets the one-item slice under the given
    key. On the other hand, the `Add` method appends the values to the slice.
  prefs: []
  type: TYPE_NORMAL
- en: Using the `Get` method will retrieve the first value from the slice under the
    given key. If the whole slice is needed, the `Header` needs to be handled as a
    map. The whole header key can be removed by using the `Del` method.
  prefs: []
  type: TYPE_NORMAL
- en: Both the server and client use the `Request` and `Header` type of `http` package
    so that handling is the same on the server side and on the client side.
  prefs: []
  type: TYPE_NORMAL
- en: Handling HTTP redirects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In some cases, you need more control over how redirects are handled. This recipe
    will show you the mechanism which the Go client implements so that you have more
    control over handling HTTP redirects.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the console and create the folder `chapter07/recipe08`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the `redirects.go` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Execute the code by running `go run redirects.go` in the main Terminal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will see the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/16caaadf-4b4a-439c-bf90-621f97acd7af.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Client` of the `http` package contains the `CheckRedirect` field. The field
    is a function that has the `req` and `via` parameters. `req` is the upcoming request
    and `via` refers to the previous requests. This way, you can modify the request
    after the redirect. In the previous example, the `Known-redirects` header is modified.
  prefs: []
  type: TYPE_NORMAL
- en: In case the `CheckRedirect` function returns the error, the last response with
    a closed body accompanied with a wrapped error is returned. In case the `http.ErrUseLastResponse`
    is returned, the last response is returned, but the body is not closed so it is
    possible to read it.
  prefs: []
  type: TYPE_NORMAL
- en: By default, the `CheckRedirect` property is nil. In this case, it has a limit
    of 10 redirects. After this count, redirecting is stopped.
  prefs: []
  type: TYPE_NORMAL
- en: Consuming the RESTful API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The RESTful API is the most common way applications and servers provide access
    to their services. This recipe will show you how it can be consumed with the help
    of a HTTP client from the standard library.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the console and create the folder `chapter07/recipe09`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the `rest.go` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Execute the code by running `go run rest.go` in the main Terminal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will see the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/026dbca2-62a0-4b65-8374-3237366a0446.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The preceding sample code shows what the REST API could look like and how it
    could be consumed. Note that the `decodeCity` and `decodeCities` functions benefit
    from the fact that the `Body` of the request implements the `Reader` interface.
    The deserialization of the structures is done via `json.Decoder`.
  prefs: []
  type: TYPE_NORMAL
- en: Sending a simple email
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will give you a brief description on how to use the standard library
    to connect to the SMTP server and send an email.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will use a Google Gmail account to send the email message.
    With a few configurations, this recipe will be useful for other SMTP servers as
    well.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the console and create the folder `chapter07/recipe10`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the `smtp.go` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Execute the code by running `go run smtp.go` in the main Terminal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter the account's email (Google account) and hit *Enter*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter the password for the account and hit *Enter*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will see the following output before checking your email box:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d25ce8a3-09ac-4b00-b46b-f4fbe10e3cbc.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `smtp` package provides the basic functionality to interact with the SMTP
    server. The `Dial` function provides the client. The most significant methods
    of the client are `Mail`, which sets the sender mail, `Rcpt`, which sets the recipients
    mail, and `Data`, which provides the `Writer`, where the content of the mail can
    be written. Finally, the `Quit` method sends QUIT and closes the connection to
    the server.
  prefs: []
  type: TYPE_NORMAL
- en: The previous example uses a secured connection to the SMTP server so the `Auth`
    method of the client is utilized to set the authentication, and the `StartTLS`
    method is called to start a secured connection to the server.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the `Auth` structure is created separately with the `PlainAuth` function
    of the `smtp` package.
  prefs: []
  type: TYPE_NORMAL
- en: Calling the JSON-RPC service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe will illustrate how procedures via the JSON-RPC protocol can be
    called with use of the standard library.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the console and create the folder `chapter07/recipe11`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the `jsonrpc.go` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Execute the code by running `go run jsonrpc.go` in the main Terminal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will see the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b08751bc-986a-4834-a877-7b3691ec84ab.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go's standard library implements JSON-RPC 1.0 as part of its built-in packages.
    The `jsonrpc` package implements the function `Dial`, which produces the client
    for calling remote procedures. The client itself contains the `Call` method, which
    accepts the procedure call, arguments, and the pointer where the result is stored.
  prefs: []
  type: TYPE_NORMAL
- en: The `createServer` will create a sample server to test the client call.
  prefs: []
  type: TYPE_NORMAL
- en: The HTTP protocol can be used as a transport layer for JSON-RPC. The `net/rpc` package
    contains the `DialHTTP` function, which is able to create the client and call
    the remote procedures.
  prefs: []
  type: TYPE_NORMAL
