- en: Themed Widgets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Replacing basic widget classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an editable drop-down with Combobox
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Treeview widget
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Populating nested items in a Treeview
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying tabbable panes with Notebook
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying Ttk styling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a datepicker widget
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tk-themed widgets are a separate collection of Tk widgets, which have a native
    look and feel, and their style can be highly customized using a specific API.
  prefs: []
  type: TYPE_NORMAL
- en: These classes are defined in the `tkinter.ttk` module. Apart from defining new
    widgets such as Treeview and Notebook, this module redefines the implementation
    of classic Tk widgets such as Button, Label, and Frame.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will cover not only how to change our application Tk widgets
    for themed widgets, but also how to style them and use the new widget classes.
  prefs: []
  type: TYPE_NORMAL
- en: The themed Tk widget set was introduced in Tk 8.5, which should not be a problem
    since Python 3.6 installers let you include version 8.6 of the Tcl/Tk interpreter.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, you can verify it on any platform by running `python -m tkinter` from
    the command line, which starts the following program that outputs the Tcl/Tk version:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/5e1aac09-b958-416e-aaaa-3a752a2ff65f.png)'
  prefs: []
  type: TYPE_IMG
- en: Replacing basic widget classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a first approach to themed Tkinter classes, we will take a look at how to
    use the same widgets (Buttons, Labels, Entries, and so on) from this different
    module, keeping the same behavior in our application.
  prefs: []
  type: TYPE_NORMAL
- en: Although this will not give us the full potential of their styling capabilities,
    we can easily appreciate the visual variations that bring the native look and
    feel of themed widgets.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the following screenshot, you can note the differences between a GUI with
    themed widgets and the same window using standard Tkinter widgets:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/64a181c4-fef7-4ef4-ab23-4d4a70afe4ed.png)'
  prefs: []
  type: TYPE_IMG
- en: We will build the application shown in the first window, but we will also learn
    how to easily switch between both styles.
  prefs: []
  type: TYPE_NORMAL
- en: Note that this is highly platform dependent. In this case, the themed variation
    corresponds to how themed widgets look on Windows 10.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To start using themed widgets, all you need is to import the `tkinter.ttk`
    module and use the widgets defined there in your Tkinter application as usual:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In case you want to run the same program with regular Tkinter widgets, replace
    allÂ `ttk.` occurrences with `tk.`.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A common way to start using themed widgets is to import the `tkinter.ttk` module
    using the `import ... as` syntax. Thus, we can easily identify standard widgets
    with the `tk` name and themed widget with the `ttk` name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'As you might have noticed in the preceding code, replacing widgets from the
    `tkinter` module with their equivalents from `tkinter.ttk` is as easy as changing
    the alias name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In our example, we did so for the `ttk.Frame`, `ttk.Label`, `ttk.Entry`, `ttk.LabelFrame`,
    and `ttk.Radiobutton` widgets. These classes accept almost the same basic options
    as their standard Tkinter equivalents; indeed, they actually are their subclasses.
  prefs: []
  type: TYPE_NORMAL
- en: However, this translation is simple because we are not porting any styling options,
    such as `foreground` or `background`. In themed widgets, these keywords are used
    separately through the `ttk.Style` class, which we will cover in another recipe.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Applying Ttk styling* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an editable drop-down with Combobox
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Drop-down lists are a succinct way of choosing a value by vertically displaying
    a list of values only when needed. This is also common to let users input another
    option that is not present in the list.
  prefs: []
  type: TYPE_NORMAL
- en: This functionality is combined in the `ttk.Combobox` class, which takes the
    native look and feel of your platform drop-downs.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our next application will consist of a simple drop-down entry with a couple
    of buttons to confirm the selection or clear its contents.
  prefs: []
  type: TYPE_NORMAL
- en: 'If one of the predefined values is selected or the Submit button is clicked,
    the current Combobox value is printed in the standard output, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/90f6db52-c463-4a4c-bde6-1aeaf09dff48.png)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our application creates a `ttk.Combobox` instance during its initialization,
    passing a predefined sequence of values that can be selected in the drop-down
    list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As usual, the `ttk.Combobox` widget is added to our application by passing the
    `Tk` instance as the first parameter to its constructor. The `values` option specifies
    the list of selectable choices that are displayed when the drop-down arrow is
    clicked.
  prefs: []
  type: TYPE_NORMAL
- en: 'We bind the `"<<ComboboxSelected>>"` virtual event that is generated when one
    of the choices from the list of values is selected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The same method is invoked when you click on the `Submit` button, so it receives
    a value input by the user.
  prefs: []
  type: TYPE_NORMAL
- en: We defined that `display_color()` takes a variable list of arguments using the
    `*` syntax to safely handle optional arguments. This happens because an event
    is passed to it when invoked through event binding, but it does not receive any
    parameters when invoked from the button callback.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within this method, we retrieve the current Combobox value via its `get()`
    method and print it in the standard output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, `clear_color()` clears the contents of the Combobox by calling its
    `set()` method with the empty string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: With these methods, we have explored how to interact with the current selection
    of a Combobox instance.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `ttk.Combobox` class extends `ttk.Entry`, which in turn extends the `Entry`
    class from the `tkinter` module.
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that we could also use the methods that we have already covered
    from the `Entry` class if needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code is more straightforward than `combobox.set("Add this at
    the beginning: " + combobox.get())`.'
  prefs: []
  type: TYPE_NORMAL
- en: Using the Treeview widget
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will introduce the `ttk.Treeview` class, a versatile widget
    that lets us display information in both tabular and hierarchical structures.
  prefs: []
  type: TYPE_NORMAL
- en: Each item added to the `ttk.Treeview` class is divided into one or more columns,
    where the first one may contain text and an icon and serves to indicate whether
    the item can be expanded and show more nested items. The rest of the columns contain
    the values that we want to display for each row.
  prefs: []
  type: TYPE_NORMAL
- en: The first row of the `ttk.Treeview` class is composed of headings that identify
    each column by its name and can be optionally hidden.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using `ttk.Treeview`, we will tabulate the information of a list of contacts
    stored in a CSV file, similar to what we previously did in [Chapter 5](89c88c96-63a6-42bf-ad7a-ed1dd71e0865.xhtml),
    *Object-Oriented Programming and MVC*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/5d623144-43ad-44ef-b852-aa63a1428d0b.png)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will create a `ttk.Treeview` widget with three columns that hold the fields
    of each contact: one for its last name, another one for its first name, and the
    last one for its email address.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Contacts are loaded from a CSV file using the `csv` module, and then we add
    the binding for the `"<<TreeviewSelect>>"` virtual element, which is generated
    when one or more items are selected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: If you run this program, each time you select a contact, its details will be
    printed in the standard output as a way to illustrate how to retrieve the data
    of a selected row.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To create a `ttk.Treeview` with multiple columns, we need to indicate the identifiers
    of each one with the `columns` option. Then, we can configure the header text
    by calling the `heading()` method.
  prefs: []
  type: TYPE_NORMAL
- en: We used identifiers `#1`, `#2`, and `#3` since the first column, which contains
    the expandable icon and text, is always generated with the `#0` identifier.
  prefs: []
  type: TYPE_NORMAL
- en: Also we passed the `"headings"` value to the `show` option to indicate that
    we want to hide the `#0` column, because there will not be nested items.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following values are valid for the `show` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '`"tree"`: Displays column `#0`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"headings"`: Displays the header row'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"tree headings"`: Displays both column `#0` and the header rowâthis is the
    default value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`""`: Does not display column `#0`Â or the header row'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After this, we attached a vertical scroll bar to our `ttk.Treeview` widget:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: To load the contacts into the table, we process the file with the `reader()`
    function from the `csv` module, and the row read in each iteration is added to
    `ttk.Treeview`.
  prefs: []
  type: TYPE_NORMAL
- en: This is done by calling the `insert()` method, which receives the parent node
    and the position to place the item.
  prefs: []
  type: TYPE_NORMAL
- en: Since all contacts are shown as top-level items, we pass an empty string as
    the first parameter and theÂ `END` constant to indicate that each new item is inserted
    at the last position.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can optionally provide some keyword arguments to the `insert()` method.
    Here, we specified the `values` option, which takes the sequence of values that
    is displayed in each column of the Treeview:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The `<<TreeviewSelect>>` event is the virtual event generated when the user
    selects one or more items from the table. Within the `print_selection()` handler,
    we retrieve the current selection by calling the `selection()` method, and for
    each result, we will perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: With the `item()` method, we get the dictionary of options and values of the
    selected item
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We retrieve the first three values from the `item` dictionary, which correspond
    to the last name, first name, and email of the contact
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The values are formatted and printed into the standard output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have covered some basic aspects of the `ttk.Treeview` class since
    we are using it as a regular table. However, it is also possible to extend our
    existing application with more advanced features.
  prefs: []
  type: TYPE_NORMAL
- en: Using tags in Treeview items
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tags are available for `ttk.Treeview` items, so it is possible to bind event
    sequences for specific rows of our `contacts` table.
  prefs: []
  type: TYPE_NORMAL
- en: Let's suppose that we want to open a new window to write an email to a contact
    when we double-click on it; however, this should only work for records where the
    email field is filled in.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can easily implement this by conditionally adding a tag to the items while
    inserting them, and then calling `tag_bind()` on the widget instance with the
    `"<Double-Button-1>"` sequenceâhere we simply refer to the implementation of the
    `send_email_to_contact()` handler function by its name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Similar to what happens when binding events to `Canvas` items, always remember
    to add the tagged items to `ttk.Treeview` before calling `tag_bind()`, because
    the bindings are only added to existing matching items.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Populating nested items in a Treeview* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Populating nested items in a Treeview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While `ttk.Treeview` can be used as a regular table, it may also contain hierarchical
    structures. This is shown as a tree where items can be expanded to see more nodes
    of the hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: This is useful to display the results of recursive calls and several levels
    of nested items. In this recipe, we will take a look at a common scenario that
    fits with this kind of structure.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To illustrate how to recursively add items in a `ttk.Treeview` widget, we will
    create a basic filesystem browser. Expandable nodes will represent folders, and
    once opened, they will show the files and folders that they contain:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/9bd56ff2-7170-4c16-821d-af9d1f31e0ca.png)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The tree will be initially populated by the `populate_node()` method, which
    lists the entries in the current directory. If an entry is a directory, it also
    adds an empty child to show it as an expandable node.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a node that represents a directory is opened, it lazily loads the contents
    of the directory by calling `populate_node()` again. This time, instead of adding
    the items as top-level nodes, they are nested inside the opened node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: When you run the preceding example, it will display the filesystem hierarchy
    from the directory where the script is located, but you can explicitly set the
    directory you want via the `path` argument of the `App` constructor.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this example, we will use the `os` module, which is part of the Python Standard
    Library and provides a portable way of performing operating system calls.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first use of the `os` module is the translation of the initial path of
    the tree to an absolute path, as well as initializing the `nodes` dictionary,
    which will store the correspondence between expandable items and the path of the
    directories they represent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: For instance, `os.path.abspath(".")` will return the absolute version of the
    pathname you run the script from. We prefer this approach to using relative paths,
    because this saves us from any confusion when working with paths in our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we initialize the `ttk.Treeview` instance with a vertical and horizontal
    scroll bar. The `text` of the icon heading will be the absolute path we calculated
    earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Then, we place the widgets using the Grid geometry manager and also make the
    `ttk.Treeview` instance automatically resizable both horizontally and vertically.
  prefs: []
  type: TYPE_NORMAL
- en: 'After this, we bind the `"<<TreeviewOpen>>"` virtual event, which is generated
    when an expandable item is opened to the `open_node()` handler and call `populate_node()`
    to load the entries of the specified directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Note that the first call to this method is made with the empty string as the
    parent directory, which means that they do not have any parent and are displayed
    as top-level items.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the `populate_node()` method, we list the names of the directory entries
    by invoking `os.listdir()`. For each entry name, we perform the following actions:'
  prefs: []
  type: TYPE_NORMAL
- en: We calculate the absolute path of the entry. On UNIX-like systems, this is achieved
    by concatenating the strings with a slash, but Windows uses backslashes instead.
    Thanks to the `os.path.join()` method, we can safely join the paths without worrying
    about platform-dependent details.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We insert the `entry` string as the last child of the indicated `parent` node.
    We always set that nodes to be initially closed, because we want to lazy load
    the nested items only when needed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If the entry absolute path is a directory, we add the correspondence between
    the node and the path in the `nodes` attribute and insert an empty child that
    allows the item to be expanded:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: When an expandable item is clicked, the `open_node()` handler retrieves the
    selected item by calling the `focus()` method of the `ttk.Treeview` instance.
  prefs: []
  type: TYPE_NORMAL
- en: This item identifier is used to get the absolute path previously added to the
    `nodes` attribute. To avoid raising `KeyError` if the node does not exist within
    the dictionary, we used its `pop()` method, which returns the second parameter
    as a default valueâin our case, `False`.
  prefs: []
  type: TYPE_NORMAL
- en: If the node exists, we clear the "fake" item of the expandable node. Calling
    `self.tree.get_children(item)` returns the identifiers of the children for `item`,
    and then they are deleted by invoking `self.tree.delete(children)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the item is cleared, we add the "real" children entries by calling `populate_node()`
    with `item` as their parent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Displaying tabbable panes with Notebook
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `ttk.Notebook` class is another of the new widget types introduced in the
    `ttk` module. It allows you to add many views of your application in the same
    window area, letting you choose the one that should be displayed by clicking on
    the tab associated to each view.
  prefs: []
  type: TYPE_NORMAL
- en: Tabbed panels are a good way to reuse the same portion of your GUI if the contents
    of multiple regions do not need to be shown at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following application shows some to-do lists divided into tabs by categoryâlists
    are displayed with read-only data to simplify the example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/de95909e-d3ee-4c23-9283-94af0b2928d9.png)'
  prefs: []
  type: TYPE_IMG
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We instantiate the `ttk.Notebook` with a fixed size, and then loop over a dictionary
    with some predefined data that will serve to create the tabs and add some labels
    to each region:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Every time you click on a tab, the label at the bottom of the window updates
    its contents, showing the name of the current tab.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our `ttk.Notebook` widget is created with a specific width and height, as well
    as an external padding.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each key from the `todos` dictionary is used as the name of a tab, and the
    list of values is added as labels to `ttk.Frame`, which represents the window
    region:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: After this, we call `enable_traversal()` on the `ttk.Notebook` widget. This
    allows users to switch tabs back and forth between tab panels using *Ctrl* + *Shift*
    + *Tab* and *Ctrl* + *Tab*, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: It also enables switching into a specific tab by pressing *Alt* and the underlined
    character, that is, *Alt* + *H* for the `Home` tab, *Alt* + *W* for the `Work`
    tab, and *Alt* + *V* for the `Vacation` tab.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `"<<NotebookTabChanged>>"` virtual event is generated when the tab selection
    changes, and we bind it to the `select_tab()` method. Note that this event is
    automatically raised when Tkinter adds a tab to `ttk.Notebook`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'When we pack the items, it is not necessary to place the `ttk.Notebook` child
    windows since it is internally done by the `ttk.Notebook` call to the geometry
    manager:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you want to retrieve the current displayed child of the `ttk.Notebook`, you
    do not need to use any extra data structures to map the tab index with the widget
    window.
  prefs: []
  type: TYPE_NORMAL
- en: 'Tkinter''s `nametowidget()` method is available from all widget classes, so
    you can easily get the widget object that corresponds to a widget name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Applying Ttk styling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we mentioned in the first recipe of this chapter, themed widgets have a specific
    API to customize their appearance. We cannot directly set options, such as the
    foreground color or the internal padding, because these values are set via the
    `ttk.Style` class.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will cover how to modify the widgets from the first recipe
    to add some styling options.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To add some default settings, we will simply need a `ttk.Style` object, which
    offers the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`configure(style, opts)`: Changes the appearance `opts` for a widget `style`.
    Here is where we set options such as the foreground color, padding, and relief.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`map(style, query)`: Changes the dynamic appearance for a widget `style`. The
    argument `query` is a keywords argument where each key is a styling option, and
    values are lists of tuples of the `(state, value)` form, meaning that the value
    of the option is determined by its current state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For instance, we have marked the following examples of both situations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, every `ttk.Label` is displayed with a padding of `10`, and the `ttk.Button`
    has a dynamic styling: gray foreground and white background when the state is
    `pressed`, and white foreground and gray background if the state is `active`.'
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building `ttk.Style` for our applications is quite straightforwardâwe only need
    to create an instance with our parent widget as its first parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we can set the default styling options for our themed widgets, using
    an uppercase `T` plus the widget name: `TButton` for `ttk.Button`, `TLabel` for
    `ttk.Label`, and so on. However, there are some exceptions, so it is recommended
    that you check on the Python interpreter the classname by calling the `winfo_class()`
    method on the widget instance.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also add a prefix to identify a style that we do not want to use by
    default, but explicitly set it to some specific widgets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Creating a datepicker widget
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we want to let users input a date into our application, we might add a text
    entry that forces them to write a string with a valid date format. Another solution
    would be adding several numeric entries for the day, month, and year, but this
    would also require some validations.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike other GUI frameworks, Tkinter does not include a class for this purpose;
    however, we can opt to apply our knowledge of themed widgets to build a Calendar
    widget.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we will explain a step-by-step implementation of a datepicker
    widget made with Ttk widgets and features:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/2af6aa0e-0480-4c96-b406-d51e96c7d0f1.png)'
  prefs: []
  type: TYPE_IMG
- en: This is a refactored version of [http://svn.python.org/projects/sandbox/trunk/ttk-gsoc/samples/ttkcalendar.py](http://svn.python.org/projects/sandbox/trunk/ttk-gsoc/samples/ttkcalendar.py)
    and does not require any external packages.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Apart from the `tkinter` modules, we will also need the `calendar` and `datetime`
    modules from the Standard Library. They will help us to model and interact with
    the data held by the widget.
  prefs: []
  type: TYPE_NORMAL
- en: 'The widget header displays a couple of arrows to move the current month back
    and forth, based on Ttk styling options. The main body of the widget consists
    of a `ttk.Treeview` table, with a `Canvas` instance that highlights the selected
    date cell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our `TtkCalendar` class can be customized by passing some options as keyword
    arguments. They are retrieved during its initialization, with some default values
    in case they are not present; for example, if the current date is used for initial
    year and month of our calendar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we define some attributes to store date information:'
  prefs: []
  type: TYPE_NORMAL
- en: '`selected`: Holds the value of the selected date'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`date`: The date that represents the current month displayed on the calendar'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`calendar`: A Gregorian calendar with information on weeks and month names'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The visual parts of the widget are internally instantiated in the `create_header()`
    and `create_table()` methods, which we will cover later.
  prefs: []
  type: TYPE_NORMAL
- en: We also used a `tkfont.Font` instance to help us to measure the font size.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once these attributes are initialized, the visual parts of the calendar are
    arranged by calling the `build_calendar()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The `create_header()` method uses `ttk.Style` to display the arrows to move
    the month back and forth. It returns the label that shows the name of the current
    month:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The `move_month()` callback hides the current selection highlighted with the
    canvas field and adds the specified `offset` to the current month to set the `date`
    attribute with the previous or next month. Then, the calendar is redrawn again,
    showing the days of the new month:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The calendar body is created within `create_table()` using a `ttk.Treeview`
    widget, which displays each week of the current month in a row:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The canvas that highlights the selection is instantiated within the `create_canvas()`
    method. Since it adjusts its size depending on the selected item dimensions, it
    also hides itself if the window is resized:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The calendar is built by iterating over the weeks and item positions of the
    `ttk.Treeview` table. With the `zip_longest()` function from the `itertools` module,
    we iterate over the collection that contains most items and leave the missing
    days with an empty string:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](images/92fb9a31-6eb8-431c-8244-13316aa52fde.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This behavior is important for the first and last week of each month, because
    this is where we usually find these empty spots:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'When you click on a table item, the `pressed()` event handler sets the selection
    if the item exists, and redisplays the canvas to highlight the selection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The `show_selection()` method places the canvas on the bounding box that contains
    the selection, measuring the text size so it fits on top of it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the `selection` property makes it possible to get the selected date
    as a `datetime.date` object. It is not directly used in our example, but it forms
    part of the API to work with the `TtkCalendar` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Using the Treeview widget* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Applying Ttk styling* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
