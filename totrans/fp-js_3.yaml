- en: Chapter 3. Setting Up the Functional Programming Environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Do we need to know advanced math—category theory, Lambda calculus, polymorphisms—just
    to write applications with functional programming? Do we need to reinvent the
    wheel? The short answer to both these questions is *no*.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will do our best to survey everything that can impact the
    way we write our functional applications in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Toolkits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Development environments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functional language that compiles to JavaScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And more
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Please understand that the current landscape of functional libraries for JavaScript
    is a very fluid one. Like all aspects of computer programming, the community can
    change in a heartbeat; new libraries can be adopted and old ones can be abandoned.
    For instance, during the writing process of this very book, the popular and stable
    `Node.js` platform for I/O has been forked by its open source community. Its future
    is vague.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, the most important concept to be gained from this chapter is not
    how to use the current libraries for functional programming, but how to use any
    library that enhances JavaScript's functional programming method. This chapter
    will not focus on just one or two libraries, but will explore as many as possible
    with the goal of surveying all the many styles of functional programming that
    exist within JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Functional libraries for JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's been said that every functional programmer writes their own library of
    functions, and functional JavaScript programmers are no exception. With today's
    open source code-sharing platforms such as GitHub, Bower, and NPM, it's easier
    to share, collaborate, and grow these libraries. Many libraries exist for functional
    programming with JavaScript, ranging from tiny toolkits to monolithic module libraries.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each library promotes its own style of functional programming. From a rigid,
    math-based style to a relaxed, informal style, each library is different but they
    all share one common feature: they all have abstract JavaScript functional capabilities
    to increase code re-use, readability, and robustness.'
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing, however, a single library has not established itself
    as the de-facto standard. Some might argue that `underscore.js` is the one but,
    as you'll see in the following section, it might be advisable to avoid `underscore.js`.
  prefs: []
  type: TYPE_NORMAL
- en: Underscore.js
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Underscore has become the standard functional JavaScript library in the eyes
    of many. It is mature, stable, and was created by *Jeremy Ashkenas*, the man behind
    the `Backbone.js` and `CoffeeScript` libraries. Underscore is actually a reimplementation
    of Ruby's `Enumerable` module, which explains why CoffeeScript was also influenced
    by Ruby.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to jQuery, Underscore doesn''t modify native JavaScript objects and
    instead uses a symbol to define its own object: the underscore character "`_`".
    So, using Underscore would work like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve already seen JavaScrip''s native `map()` method for the `Array` object,
    which works like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The difference is that, in Underscore, both the `Array` object and the `callback()`
    function are passed as parameters to the Underscore object's `map()` method (`_.map`),
    as opposed to passing only the callback to the array's native `map()` method (`Array.prototype.map`).
  prefs: []
  type: TYPE_NORMAL
- en: But there's way more than just `map()` and other built-in functions to Underscore.
    It's full of super handy functions such as `find()`, `invoke()`, `pluck()`, `sortyBy()`,
    `groupBy()`, and more.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'And it provides a way of chaining methods together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `_.chain()` method returns a wrapped object that holds all the Underscore
    functions. The `_.value` method is then used to extract the value of the wrapped
    object. Wrapped objects are also very useful for mixing Underscore with object-oriented
    programming.
  prefs: []
  type: TYPE_NORMAL
- en: Despite its ease of use and adaptation by the community, the `underscore.js`
    library has been criticized for forcing you to write overly verbose code and for
    encouraging the wrong patterns. Underscore's structure may not be ideal or even
    function!
  prefs: []
  type: TYPE_NORMAL
- en: Until version 1.7.0, released shortly after Brian Lonsdorf's talk entitled *Hey
    Underscore, you're doing it wrong!*, landed on YouTube, Underscore explicitly
    prevented us from extending functions such as `map()`, `reduce()`, `filter()`,
    and more.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can watch the video of Brian Lonsdorf's talk at [www.youtube.com/watch?v=m3svKOdZij](http://www.youtube.com/watch?v=m3svKOdZij).
  prefs: []
  type: TYPE_NORMAL
- en: Map, in terms of category theory, is a homomorphic functor interface (more on
    this in [Chapter 5](part0032_split_000.html#page "Chapter 5. Category Theory"),
    *Category Theory*). And we should be able to define `map` as a functor for whatever
    we need it for. So that's not very functional of Underscore.
  prefs: []
  type: TYPE_NORMAL
- en: And because JavaScript doesn't have built-in immutable data, a functional library
    should be careful to not allow its helper functions to mutate the objects passed
    to it. A good example of this problem is shown below. The intention of the snippet
    is to return a new `selected` list with one option set as the default. But what
    actually happens is that the `selected` list is mutated in place.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We would have to insert the line `opt = opt.cloneNode();` to the `callback()`
    function to make a copy of each object within the list being passed to the function.
    Underscore's `map()` function cheats to boost performance, but it is at the cost
    of functional *feng shui*. The native `Array.prototype.map()` function wouldn't
    require this because it makes a copy, but it also doesn't work on `nodelist` collections.
  prefs: []
  type: TYPE_NORMAL
- en: Underscore may be less than ideal for mathematically-correct, functional programming,
    but it was never intended to extend or transform JavaScript into a pure functional
    language. It defines itself as *a JavaScript library that provides a whole mess
    of useful functional programming helpers*. It may be a little more than a spurious
    collection of functional-like helpers, but it's no serious functional library
    either.
  prefs: []
  type: TYPE_NORMAL
- en: Is there a better library out there? Perhaps one that is based on mathematics?
  prefs: []
  type: TYPE_NORMAL
- en: Fantasy Land
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes, the truth is stranger than fiction.
  prefs: []
  type: TYPE_NORMAL
- en: '**Fantasy Land** is a collection of functional base libraries and a formal
    specification for how to implement "algebraic structures" in JavaScript. More
    specifically, Fantasy Land specifies the interoperability of common algebraic
    structures, or algebras for short: monads, monoids, setoids, functors, chains,
    and more. Their names may sound scary, but they''re just a set of values, a set
    of operators, and some laws it must obey. In other words, they''re just objects.'
  prefs: []
  type: TYPE_NORMAL
- en: Here's how it works. Each algebra is a separate Fantasy Land specification and
    may have dependencies on other algebras that need to be implemented.
  prefs: []
  type: TYPE_NORMAL
- en: '![Fantasy Land](../images/00002.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Some of the algebra specifications are:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Setoids:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement the reflexivity, symmetry and transitivity laws
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define the `equals()` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Semigroups
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement the associativity law
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define the `concat()` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monoid
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement right identity and left identity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define the `empty()` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement the identity and composition laws
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define the `map()` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The list goes on and on.
  prefs: []
  type: TYPE_NORMAL
- en: We don't necessarily need to know exactly what each algebra is for but it certainly
    helps, especially if you're writing your own library that conforms to the specifications.
    It's not just abstract nonsense, it outlines a means of implementing a high-level
    abstraction called category theory. A full explanation of category theory can
    be found in [Chapter 5](part0032_split_000.html#page "Chapter 5. Category Theory"),
    *Category Theory*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fantasy Land doesn''t just tell us how to implement functional programming,
    it does provide a set of functional modules for JavaScript. However, many are
    incomplete and documentation is pretty sparse. But Fantasy Land isn''t the only
    library out there to implement its open source specifications. Others have too,
    namely: **Bilby.js**.'
  prefs: []
  type: TYPE_NORMAL
- en: Bilby.js
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What the heck is a bilby? No, it's not a mythical creature that might exist
    in Fantasy Land. It exists here on Earth as a freaky/cute cross between a mouse
    and a rabbit. Nonetheless, `bibly.js` library is compliant with Fantasy Land specifications.
  prefs: []
  type: TYPE_NORMAL
- en: 'In fact, `bilby.js` is a serious functional library. As its documentation states,
    it is, *Serious, meaning it applies category theory to enable highly abstract
    code. Functional, meaning it enables referentially transparent programs*. Wow,
    that is pretty serious. The documentation located at [http://bilby.brianmckenna.org/](http://bilby.brianmckenna.org/)
    goes on to say that it provides:'
  prefs: []
  type: TYPE_NORMAL
- en: Immutable multi-methods for ad-hoc polymorphism
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functional data structures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operator overloading for functional syntax
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automated specification testing (**ScalaCheck**, **QuickCheck**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By far the most mature library that conforms to the Fantasy Land specifications
    for algebraic structures, `Bilby.js` is a great resource for fully committing
    to the functional style.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This is category theory and ad-hoc polymorphism in action. Again, category theory
    will be covered in full in [Chapter 5](part0032_split_000.html#page "Chapter 5. Category
    Theory"), *Category Theory*.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Category theory is a recently invigorated branch of mathematics that functional
    programmers use to maximize the abstraction and usefulness of their code. *But
    there is a major drawback: it''s difficult to conceptualize and quickly get started
    with.*'
  prefs: []
  type: TYPE_NORMAL
- en: The truth is that Bilby and Fantasy Land are really stretching the possibilities
    of functional programming in JavaScript. Although it's exciting to see the evolution
    of computer science, the world may just not be ready for the kind of hard-core
    functional style that Bibly and Fantasy Land are pushing.
  prefs: []
  type: TYPE_NORMAL
- en: Maybe such a grandiose library on the bleeding-edge of functional JavaScript
    is not our thing. After all, we set out to explore the functional techniques that
    complement JavaScript, not to build functional programming dogma. Let's turn our
    attention to another new library, `Lazy.js`.
  prefs: []
  type: TYPE_NORMAL
- en: Lazy.js
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Lazy is a utility library more along the lines of the `underscore.js` library
    but with a lazy evaluation strategy. Because of this, Lazy makes the impossible
    possible by functionally computing results of series that won't be available with
    immediate interpretation. It also boasts a significant performance boost.
  prefs: []
  type: TYPE_NORMAL
- en: The `Lazy.js` library is still very young. But it has a lot of momentum and
    community enthusiasm behind it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The idea is that, in Lazy, everything is a sequence that we can iterate over.
    Owing to the way the library controls the order in which methods are applied,
    many really cool things can be achieved: asynchronous iteration (parallel programming),
    infinite sequences, functional reactive programming, and more.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following examples show off a bit of everything:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: More examples and use-cases are covered in [Chapter 4](part0027_split_000.html#page
    "Chapter 4. Implementing Functional Programming Techniques in JavaScript"), *Implementing
    Functional Programming Techniques in JavaScript*.
  prefs: []
  type: TYPE_NORMAL
- en: But its not entirely correct to fully credit the `Lazy.js` library with this
    idea. One of its predecessors, the `Bacon.js` library, works in much the same
    way.
  prefs: []
  type: TYPE_NORMAL
- en: Bacon.js
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The logo of `Bacon.js` library is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Bacon.js](../images/00003.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The mustachioed hipster of functional programming libraries, `Bacon.js` is itself
    a library for *functional reactive programming*. Functional reactive programming
    just means that functional design patterns are used to represent values that are
    reactive and always changing, like the position of the mouse on the screen, or
    the price of a company's stock. In the same way that Lazy can get away with creating
    infinite sequences by not calculating the value until it's needed, Bacon can avoid
    having to calculate ever-changing values until the very last second.
  prefs: []
  type: TYPE_NORMAL
- en: What are called sequences in Lazy are known as EventStreams and Properties in
    Bacon because they're more suited for working with events (`onmouseover`, `onkeydown`,
    and so on) and reactive properties (scroll position, mouse position, toggles,
    and so on).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Bacon is a little bit older than Lazy but its feature set is about half the
    size and its community enthusiasm is about equal.
  prefs: []
  type: TYPE_NORMAL
- en: Honorable mentions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are simply too many libraries out there to do them all justice within
    the scope of this book. Let's look at a few more libraries for functional programming
    in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: '`Functional`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Possibly the first library for functional programming in JavaScript, `Functional`
    is a library that includes comprehensive higher-order function support as well
    as `string` lambdas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`wu.js`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Especially prized for its `curryable()` function, `wu.js` library is a very
    nice Library for functional programming. It was the first library (that I know
    of) to implement lazy evaluation, getting the ball rolling for `Bacon.js`, `Lazy.js`
    and other libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Yes, it is named after the infamous rap group *Wu Tang Clan*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sloth.js`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Very similar to the `Lazy.js` libraries, but much smaller
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stream.js`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `stream.js` library supports infinite streams and not much else
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Absolutely tiny in size
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Lo-Dash.js`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As the name might imply, the `lo-dash.js` library was inspired by the `underscore.js`
    library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Highly optimized
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Sugar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Sugar` is a support library for functional programming techniques in JavaScript,
    like Underscore, but with some key differences in how it''s implemented.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instead of doing `_.pluck(myObjs, 'value')` in Underscore, it's just `myObjs.map('value')`
    in Sugar. This means that it modifies native JavaScript objects, so there is a
    small risk of it not playing nicely with other libraries that do the same such
    as Prototype.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Very good documentation, unit tests, analyzers, and more.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`from.js`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A new functional library and **LINQ** (**Language Integrated Query**) engine
    for JavaScript that supports most of the same LINQ functions that .NET provides
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 100% lazy evaluation and supports lambda expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Very young but documentation is excellent
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JSLINQ
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another functional LINQ engine for JavaScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Much older and more mature than `from.js` library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Boiler.js`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Another utility library that extends JavaScript''s functional methods to more
    primitives: strings, numbers, objects, collections and arrays'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Folktale**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Like the `Bilby.js` library, Folktale is another new library that implements
    the Fantasy Land specifications. And like its forefather, Folktale is also a collection
    of libraries for functional programming in JavaScript. It's very young but could
    have a bright future.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**jQuery**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Surprised to see jQuery mentioned here? Although jQuery is not a tool used to
    perform functional programming, it nevertheless is functional itself. jQuery might
    be one of the most widely used libraries that has its roots in functional programming.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The jQuery object is actually a monad. jQuery uses the monadic laws to enable
    method chaining:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: A full explanation of this can be found in [Chapter 7](part0041_split_000.html#page
    "Chapter 7. Functional and Object-oriented Programming in JavaScript"), *Functional
    and Object-oriented Programming in JavaScript*.
  prefs: []
  type: TYPE_NORMAL
- en: 'And some of its methods are higher-order:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As of jQuery 1.8, the `deferred.then` parameter implements a functional concept
    known as Promises.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: jQuery is an abstraction layer, mainly for the DOM. It's not a framework or
    a toolkit, just a way to use abstraction to increase code-reuse and reduce ugly
    code. And isn't that what functional programming is all about?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Development and production environments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It does not matter in terms of programming style what type of environment the
    application is being developed in and will be deployed in. But it does matter
    to the libraries a lot.
  prefs: []
  type: TYPE_NORMAL
- en: Browsers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The majority of JavaScript applications are designed to run on the client side,
    that is, in the client's browser. Browser-based environments are excellent for
    development because browsers are ubiquitous, you can work on the code right on
    your local machine, the interpreter is the browser's JavaScript engine, and all
    browsers have a developer console. Firefox's FireBug provides very useful error
    messages and allows for break-points and more, but it's often helpful to run the
    same code in Chrome and Safari to cross-reference the error output. Even Internet
    Explorer contains developer tools.
  prefs: []
  type: TYPE_NORMAL
- en: The problem with browsers is that they evaluate JavaScript differently! Though
    it's not common, it is possible to write code that returns very different results
    in different browsers. But usually the differences are in the way they treat the
    document object model and not how prototypes and functions work. Obviously, `Math.sqrt(4)`
    method returns `2` to all browsers and shells. But the `scrollLeft` method depends
    on the browser's layout policies.
  prefs: []
  type: TYPE_NORMAL
- en: Writing browser-specific code is a waste of time, and that's another reason
    why libraries should be used.
  prefs: []
  type: TYPE_NORMAL
- en: Server-side JavaScript
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Node.js` library has become the standard platform for creating server-side
    and network-based applications. Can functional programming be used for server-side
    application programming? Yes! Ok, but do there exist any functional libraries
    that are designed for this performance-critical environment? The answer to that
    is also: yes.'
  prefs: []
  type: TYPE_NORMAL
- en: All the functional libraries outlined in this chapter will work in the `Node.js`
    library, and many depend on the `browserify.js` module to work with browser elements.
  prefs: []
  type: TYPE_NORMAL
- en: A functional use case in the server-side environment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In our brave new world of network systems, server-side application developers
    are often concerned with concurrency, and rightly so. The classic example is an
    application that allows multiple users to modify the same file. But if they try
    to modify it at the same time, you will get into an ugly mess. This is the *maintenance
    of state* problem that has plagued programmers for decades.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assume the following scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: One morning, Adam opens a report for editing but he doesn't save it before leaving
    for lunch.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Billy opens the same report, adds his notes, and then saves it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adam comes back from lunch, adds his notes to the report, and then saves it,
    unknowingly overwriting Billy's notes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next day, Billy finds out that his notes are missing. His boss yells at
    him; everybody gets mad and they gang up on the misguided application developer
    who unfairly loses his job.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For a long time, the solution to this problem was to create a state about the
    file. Toggle a lock status to *on* when someone begins editing it, which prevents
    others from being able to edit it, and then toggle it to *off* once they save
    it. In our scenario, Billy would not be able to do his work until Adam gets back
    from lunch. And if it's never saved (if, say, Adam decided to quit his job in
    the middle of the lunch break), then no one will ever be able to edit it.
  prefs: []
  type: TYPE_NORMAL
- en: This is where functional programming's ideas about immutable data and state
    (or lack thereof) can really be put to work. Instead of having users modify the
    file directly, with a functional approach they would modify a copy of the file,
    which is a new revision. If they go to save the revision and a new revision already
    exists, then we know that someone else has already modified the old one. Crisis
    averted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now the scenario from before would unfold like this:'
  prefs: []
  type: TYPE_NORMAL
- en: One morning, Adam opens a report for editing. But he doesn't save it before
    going to lunch.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Billy opens the same report, adds his notes, and saves it as a new revision.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adam returns from lunch to add his notes. When he attempts to save the new revision,
    the application tells him that a newer revision now exists.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adam opens the new revisions, adds his notes to it, and saves another new revision.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By looking at the revision history, the boss sees that everything is working
    smoothly. Everyone is happy and the application developer gets a promotion and
    a raise.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is known as *event sourcing*. There is no explicit state to be maintained,
    only events. The process is much cleaner and there is a clear history of events
    that can be reviewed.
  prefs: []
  type: TYPE_NORMAL
- en: This idea and many others are why functional programming in server-side environments
    is on the rise.
  prefs: []
  type: TYPE_NORMAL
- en: CLI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although web and the `node.js` library are the two main JavaScript environments,
    some pragmatic and adventurous users are finding ways to use JavaScript in the
    command line.
  prefs: []
  type: TYPE_NORMAL
- en: Using JavaScript as a **Command Line Interface** (**CLI**) scripting language
    might be one of the best opportunities to apply function programming. Imagine
    being able to use lazy evaluation when searching for local files or to rewrite
    an entire bash script into a functional JavaScript one-liner.
  prefs: []
  type: TYPE_NORMAL
- en: Using functional libraries with other JavaScript modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Web applications are made up of all sorts of things: frameworks, libraries,
    APIs and more. They can work along side each other as dependents, plugins, or
    just as coexisting objects.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Backbone.js`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An **MVP** (**model-view-provider**) framework with a RESTful JSON interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Requires the `underscore.js` library, Backbone's only hard dependency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: jQuery
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Bacon.js` library has bindings for mixing with jQuery
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Underscore and jQuery complement each other very well
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prototype JavaScript Framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provides JavaScript with collection functions in the manner closest to Ruby's
    Enumerable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Sugar.js`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modifies native objects and their methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Must be careful when mixing with other libraries, especially Prototype
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functional languages that compile into JavaScript
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes the thick veneer of C-like syntax over JavaScript's inner functionality
    can be enough to make you want to switch to another functional language. Well,
    you can!
  prefs: []
  type: TYPE_NORMAL
- en: Clojure and ClojureScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Closure is a modern Lisp implementation and a full-featured functional language
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ClojureScript trans-compiles Clojure into JavaScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CoffeeScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CoffeeScript is the name of both a functional language and a compiler for trans-compiling
    the language into JavaScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1-to-1 mapping between expressions in CoffeeScript and expression in JavaScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are many more out there, including **Pyjs**, **Roy**, **TypeScript**,
    **UHC** and more.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Which library you choose to use depends on what your needs are. Need functional
    reactive programming to handle events and dynamic values? Use the `Bacon.js` library.
    Only need infinite streams and nothing else? Use the `stream.js` library. Want
    to complement jQuery with functional helpers? Try the `underscore.js` library.
    Need a structured environment for serious ad hoc polymorphism? Check out the `bilby.js`
    library. Need a well-rounded tool for functional programming? Use the `Lazy.js`
    library. Not happy with any of these options? Write your own!
  prefs: []
  type: TYPE_NORMAL
- en: Any library is only as good as the way it's used. Although a few of the libraries
    outlined in this chapter have a few flaws, most faults occur somewhere between
    the keyboard and the chair. It's up to you to use the libraries correctly and
    to suit your needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'And if we''re importing code libraries into our JavaScript environment, then
    maybe we can import ideas and principles too. Maybe we can channel *The Zen of
    Python*, by *Tim Peter*:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Beautiful is better than ugly*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '>'
  prefs: []
  type: TYPE_NORMAL
- en: '*Explicit is better than implicit.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '>'
  prefs: []
  type: TYPE_NORMAL
- en: '*Simple is better than complex.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '>'
  prefs: []
  type: TYPE_NORMAL
- en: '*Complex is better than complicated.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '>'
  prefs: []
  type: TYPE_NORMAL
- en: '*Flat is better than nested.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '>'
  prefs: []
  type: TYPE_NORMAL
- en: '*Sparse is better than dense.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '>'
  prefs: []
  type: TYPE_NORMAL
- en: '*Readability counts.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '>'
  prefs: []
  type: TYPE_NORMAL
- en: '*Special cases aren''t special enough to break the rules.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '>'
  prefs: []
  type: TYPE_NORMAL
- en: '*Although practicality beats purity.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '>'
  prefs: []
  type: TYPE_NORMAL
- en: '*Errors should never pass silently.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '>'
  prefs: []
  type: TYPE_NORMAL
- en: '*Unless explicitly silenced.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '>'
  prefs: []
  type: TYPE_NORMAL
- en: '*In the face of ambiguity, refuse the temptation to guess.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '>'
  prefs: []
  type: TYPE_NORMAL
- en: '*There should be one—and preferably only one—obvious way to do it.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '>'
  prefs: []
  type: TYPE_NORMAL
- en: '*Although that way may not be obvious at first unless you''re Dutch.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '>'
  prefs: []
  type: TYPE_NORMAL
- en: '*Now is better than never.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '>'
  prefs: []
  type: TYPE_NORMAL
- en: '*Although never is often better than "right" now.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '>'
  prefs: []
  type: TYPE_NORMAL
- en: '*If the implementation is hard to explain, it''s a bad idea.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '>'
  prefs: []
  type: TYPE_NORMAL
- en: '*If the implementation is easy to explain, it may be a good idea.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '>'
  prefs: []
  type: TYPE_NORMAL
- en: '*Namespaces are one honking great idea—let''s do more of those!*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
