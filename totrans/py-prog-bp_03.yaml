- en: Casting Votes on Twitter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we implemented a Terminal application that serves as
    a remote control for the popular music service Spotify. In this application, we
    could search for artists, browse albums, and browse the tracks in each album.
    Lastly, we could even request the track to be played on the user's active device.
  prefs: []
  type: TYPE_NORMAL
- en: This time, we are going to develop an application that will integrate with Twitter,
    making use of its REST API. Twitter is a social network that has been around since
    2006 and there are over 300 million active users. Private users, companies, artists,
    soccer clubs, you can find almost everything on Twitter. But what makes Twitter
    so popular, I believe, is its simplicity.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike blog posts, Twitter posts or *tweets* have to be short and get right
    to the point, and it doesn't require too much time to prepare something to post.
    Another point that makes Twitter so popular is the fact that the service is a
    great news source. If you want to keep updated with what's going on in the world,
    politics, sports, technology, you name it, Twitter is the place to be.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from all that, Twitter has a fairly decent API for us developers and,
    to take advantage of that, we are going to develop an application where users
    can cast votes using hashtags. In our application, we are going to configure which
    hashtags we are going to monitor and it will automatically, from time to time,
    fetch the latest tweets matching that hashtag, count them, and display them in
    a user interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn how to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a tweet application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the `OAuth` library and implement a three-legged authentication flow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Search for the latest tweets using the Twitter API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build a simple user interface using `Tkinter`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn the basics of multiprocessing and reactive programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first thing we have to do is, as usual, set up our development environment
    and the first step is to create a virtual environment for our application. Our
    application will be called `twittervotes`, so let''s go ahead and create a virtual
    environment called `twittervotes`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/9cf0dbeb-8a22-4726-930f-c0869b9b0dbf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When the `virtualenv` environment has been created, you can activate it with
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Great! Now let''s set up the project''s directory structure. It should look
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s dive into the structure a bit:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `twittervotes` | The application''s root directory. Here, we will create
    the application''s entry point as well as a small helper application to perform
    the Twitter authentication. |'
  prefs: []
  type: TYPE_TB
- en: '| `twittervotes/core` | This will contain all the core functionality of our
    project. It will contain the code to authenticate, read config files, send requests
    to the Twitter API, and so on. |'
  prefs: []
  type: TYPE_TB
- en: '| `twittervotes/core/models` | Directory in which to keep the application''s
    data models. |'
  prefs: []
  type: TYPE_TB
- en: '| `twittervotes/core/twitter` | In the `twitter` directory, we are going to
    keep `helper` functions to interact with the Twitter API. |'
  prefs: []
  type: TYPE_TB
- en: '| `twittervotes/templates` | Here, we are going to keep all the HTML templates
    that will be used by our application. |'
  prefs: []
  type: TYPE_TB
- en: 'Next, it is time to add our project''s dependencies. Go ahead and create a
    file called `requirements.txt` in the `twittervotes` directory with the following
    content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The following table explains what the preceding dependencies mean:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `Flask` | We are going to use Flask here to create a simple web application
    to perform the authentication with Twitter. |'
  prefs: []
  type: TYPE_TB
- en: '| `oauth2` | This is a great package that will abstract a lot of the complexity
    when performing `OAuth` authentication. |'
  prefs: []
  type: TYPE_TB
- en: '| `PyYAML` | We are going to use this package to create and read config files
    in YAML format. |'
  prefs: []
  type: TYPE_TB
- en: '| `Requests` | Allow us to access the Twitter API over HTTP. |'
  prefs: []
  type: TYPE_TB
- en: '| `Rx` | Finally, we are going to use Reactive Extensions for Python so we
    can reactively update our UI soon as a new tweet count arrives. |'
  prefs: []
  type: TYPE_TB
- en: 'When the file has been created, run the command `pip install -r requirements.txt`,
    and you should see an output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/40df8c49-f4b0-4320-bef0-833905edb509.png)If you run the command
    `pip freeze`, you will get a list of dependencies in pip format and you will notice
    that the output lists more dependencies that we actually added to the `requirements`
    file. The reason for that is that the packages that our project requires also
    have dependencies and they will also be installed. So do not worry if you have
    more packages installed than you specified in your `requirements` file.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that our environment is set up, we can start creating our Twitter application.
    As usual, before you start coding, make sure that you have your code under a source
    control system such as Git; there are plenty of online services that will host
    your repositories for free.
  prefs: []
  type: TYPE_NORMAL
- en: In this way, you can roll back different versions of your projects and you don't
    have the risk of losing your work if you have problems with your computers. With
    that said, let's create our Twitter application.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Twitter application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to create our first Twitter application so we
    can consume the Twitter REST API. You will need to create an account if you don't
    already have one. If you are not using Twitter, I would strongly recommend it;
    it is a great way of getting up-to-date with all the news and what is going on
    in the development world, and it is a great way of making new friends in the Python
    community.
  prefs: []
  type: TYPE_NORMAL
- en: 'After you create an account, head over to [https://apps.twitter.com/](https://apps.twitter.com/),
    sign in with your login credentials, and you will land on a page where you can
    see a list of apps that you have already created (the first time, you will probably
    have an empty list of apps), and on the same page you will have the possibility
    of creating new apps. Click on the Create new app button in the top-right corner
    and it will open up the following page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/4599e1a6-0846-42c4-9920-11341efa9cec.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In this form, there are three fields that are required—name, description, and
    website:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Name**: This is the name of your application; it is also the name that will
    be presented to the users of your application when performing authorization. The
    name doesn''t need to follow any specific naming convention, you can have anything
    you want.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Description**: As the name suggests, this is the description of your application.
    This field will also be presented to the users of your application, so it is good
    to have nice text describing your application. In this case, here we don''t need
    much text. Let''s add `Application to cast votes on Twitter using hashtags`**.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Website**: Specify your application''s website; it is also going to be presented
    to the users during authorization and it is the site where your users can go to
    download or get more information about your application. Since we are in the development
    phase, we can just add a placeholder such as [http://www.example.com](http://www.example.com)*.*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Callback URL**: This works the same way as the callback URL in the previous
    application (the Spotify Terminal app) in the previous chapter. It is a URL that
    Twitter will call to send the authorization code. It is not a required field but
    we are going to need it, so let''s go ahead and add ;`http://localhost:3000/callback`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After filling in all the fields, you just need to check the Twitter Developer
    Agreement and click the Create your Twitter application button.
  prefs: []
  type: TYPE_NORMAL
- en: 'If everything went well, you will be directed to another page where you can
    see more details of your newly created application. Just below the name of the
    application, you will see an area with tabs that shows settings and different
    pieces of information about the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/469924a4-645a-46fc-837d-bd1517bc4733.png)'
  prefs: []
  type: TYPE_IMG
- en: On the first tab, Details, we want to copy all the URLs that we are going to
    use to perform the authentication. Scroll down to Application settings, and copy
    Request token URL, *Authorize URL*, and *Access token URL:*
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/e709f442-79ec-4474-8cfc-d18c21a0b195.png)'
  prefs: []
  type: TYPE_IMG
- en: Great! Now let's head over to the Keys and Access Tokens tab and copy Consumer
    Key and Consumer Secret*:*
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/30c5220e-277f-4cc8-b2b4-db7c7bb37429.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that we have copied all the necessary information, we can create a configuration
    file that is going to be used by our application. It is always good practice to
    keep all this in a configuration file so we don't need to hardcode those URLs
    in our code.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to add the *consumer key* and *consumer secret* to a configuration
    file in our project; as the name suggests, this key is *secret* so if you are
    planning to create a repository for your code in a service such as GitHub, make
    sure to add the configuration file to the `.gitignore` file so the keys are not
    pushed to the cloud repository. Never share these keys with anyone; if you suspect
    that someone has the keys, you can generate new keys for your application on the
    Twitter app's website.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the configuration file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to create the configuration file for our application;
    the configuration file will be in YAML format. If you would like to know more
    about YAML, you can check the site [http://yaml.org/](http://yaml.org/), where
    you will find examples, the specification, and also a list of libraries in different
    programming languages that can be used to manipulate YAML files.
  prefs: []
  type: TYPE_NORMAL
- en: For our application, we are going to use PyYAML, which will allow us to read
    and write YAML files in a very simple manner. Our configuration file is quite
    simple so we will not need to use any advanced features of the library, we just
    want to read the content and write, and the data that we are going to add is quite
    flat; we will not have any nested objects or lists of any kind.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s get the information that we obtained from Twitter when we created our
    app and add it to the configuration file. Create a file called `config.yaml` in
    the application''s `twittervotes` directory with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Great! Now we are going to create the first Python code in our project. If
    you have followed the previous chapters, the functions to read the configuration
    file will be familiar to you. The idea is simple: we are going to read the configuration
    file, parse it, and create a model that we can easily use to access the data we
    added to the config. First, we need to create the configuration model.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file called `models.py` in `twittervotes/core/models/` with the following
    content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: There was a more extensive introduction to `namedtuple` in the previous chapter,
    so I will not go into as much  detail about it again; if you haven't been going
    through the second chapter, it will suffice to know that `namedtuple` is a kind
    of class and this code will define a `namedtuple` called `Config` with the fields
    specified in the array in the second argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'Great, now let''s create another file called `__init__.py` in `twittervotes/core/models` and
    import the `namedtuple` that we just created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now it is time to create the functions that will do the actual work of reading
    the YAML file and returning it to us. Create a file called `config.py` in `twittervotes/core/`. Let''s get
    started by adding the import statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We are going to use the `os` package to easily obtain the user's current directory
    and manipulate paths. We also import PyYAML so we can read the YAML files and,
    lastly, from the `models` module, we import the `Config` model that we just created.
  prefs: []
  type: TYPE_NORMAL
- en: Then we define two functions, starting with the `_read_yaml_file` function.
    This function gets two arguments—the `filename`, which is the name of the config
    file that we want to read, and also `cls`, which can be a `class` or `namedtuple`
    that we will use to store the configuration data.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, we are going to pass the `Config`—`namedtuple`, which has the
    same properties as the YAML configuration file that we are going to read:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: First, we use the `os.path.abspath` function, passing as an argument the special
    variable `__file__`. When a module is loaded, the variable `__file__` will be
    set to the same name as the module. That will allow us to easily find where to
    load the configuration file. So the following snippet will return the path of
    the core module
  prefs: []
  type: TYPE_NORMAL
- en: '`/projects/twittervotes/core`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We know that the configuration file will live in `/projects/twittervotes/`
    so we need to join `..` to the path to go up one level in the directory structure
    so we can read the file. That''s why we build the complete configuration file''s
    path as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`file_path = os.path.join(core_dir, ''..'', filename)`'
  prefs: []
  type: TYPE_NORMAL
- en: That will give us the flexibility of running this code from any location in
    our system.
  prefs: []
  type: TYPE_NORMAL
- en: We open the file in the reading mode using UTF-8 encoding and pass it to the
    `yaml.load` function, assigning the results to the `config` variable. The `config`
    variable will be a dictionary with all the data we have in the `config` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last line of this function is the interesting part: if you recall, the
    `cls` argument was a `class` or a `namedtuple` so we spread the values of the
    config dictionary as an argument. Here, we are going to use the `Config`—`namedtuple`
    so `cls(**config)` is the same as `Config`, `(**config)` and passing the arguments
    with `**` will be the same as passing all the arguments one by one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we are going to add the second function we are going to need, the `read_config` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This function is pretty straightforward; it just makes use of the `_read_yaml_file` function
    that we just created, passing the `config.yaml` file in the first argument and
    also the `Config`, `namedtuple` in the second argument.
  prefs: []
  type: TYPE_NORMAL
- en: We catch the `IOError` exception that will be thrown if the file doesn't exist
    in the application's  directory; in that case, we throw a help message showing
    the users of your application how the config file should be structured.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final touch is to import it into the `__init__.py` in the `twittervotes/core` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s try this out in the Python REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/614acd5c-35c0-47b3-93aa-ad1c894123e2.png)'
  prefs: []
  type: TYPE_IMG
- en: Great, it worked just like we wanted! In the next section, we can start creating
    the code that will perform the authentication.
  prefs: []
  type: TYPE_NORMAL
- en: Performing authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to create the program that will perform authentication
    for us so we can use the Twitter API. We are going to do that using a simple Flask
    application that will expose two routes. The first is the root `/`, which will
    just load and render a simple HTML template with a button that will redirect us
    to the Twitter authentication dialog.
  prefs: []
  type: TYPE_NORMAL
- en: The second route that we are going to create is `/callback`. Remember when we
    specified the callback URL in the Twitter app configuration? This is the route
    that will be called after we authorize the app. It will return an authorization
    token that will be used to perform requests to the Twitter API. So let's get right
    into it!
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we start implementing the Flask app, we need to add another model to
    our model''s module. This model will represent the request authorization data.
    Open the `models.py` file in `twittervotes/core/models` and add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This will create a `namedtuple` called `RequestToken` with the fields `oauth_token`,
    `oauth_token_secret`, and `outh_callback_confirmed`; this data will be necessary
    for us to perform the second step of the authentication.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, open the `__init__.py` file in the `twittervotes/core/models` directory
    and let''s import the `RequestToken` `namedtuple` that we just created, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have the model in place, let's start creating the Flask application.
    Let's add a very simple template to show a button that will start the authentication
    process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new directory in the `twittervotes` directory called `templates` and
    create a file called `index.html` with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Creating the Flask application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Perfect, now let''s add another file called `twitter_auth.py` in the `twittervotes`
    directory. We are going to create three functions in it but, first, let''s add
    some imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: First, we import the `parser_qls` from the `urllib.parse` module to parse the
    returned query string, and the `yaml` module so we can read and write `YAML` configuration
    files. Then we import everything we need to build our Flask application. The last
    third-party module that we are going to import here is the `oauth2` module, which
    will help us to perform the `OAuth` authentication.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we import our function `read_config` and the `RequestToken` `namedtuple`
    that we just created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we create our Flask app and a few global variables that will hold values
    for the client, consumer, and the `RequestToken` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The first function that we are going to create is a function called `get_req_token`
    with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This function gets as argument an instance to the configuration and the global
    statements say to the interpreter that the consumer, client, and `req_token` used
    in the function will be referencing the global variables.
  prefs: []
  type: TYPE_NORMAL
- en: We create a consumer object using the consumer key and the consumer secret that
    we obtained when the Twitter app was created. When the consumer is created, we
    can pass it to the client function to create the client, then we call the function
    request, which, as the name suggests, will perform the request to Twitter, passing
    the request token URL.
  prefs: []
  type: TYPE_NORMAL
- en: When the request is complete, the response and the content will be stored in
    the variables `resp` and `content`. Right after that, we test whether the response
    status is not `200` or `HTTP.OK`; in that case, we raise an exception, otherwise
    we parse the query string to get the values that have been sent back to us and
    create a `RequestToken` instance.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the application routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we can start creating the routes. First, we are going to add the root route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We read the configuration file and pass it the `get_oauth_token` function. This
    function will populate the global variable `req_token` with the `oauth_token`
    value; we need this token to start the authorization process. Then we build the
    authorization URL with the values of `authorize_url` obtained from the configuration
    file and the `OAuth` request token.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we use the `render_template` to render the `index.html` template that
    we created and we also pass to the function a second argument, which is the context.
    In this case, we are creating an item called `link` with the value set to `url`.
    If you remember the `index.html` template, there is an `"{{url}}"` placeholder.
    This placeholder will be replaced by the value that we assigned to `link` in the
    `render_template` function.
  prefs: []
  type: TYPE_NORMAL
- en: By default, Flask uses Jinja2 as a template engine but that can be changed to
    the engine of your preference; we are not going into the details of how to do
    this in this book because it is beyond our scope.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last route that we are going to add is the `/callback` route and that will
    be the route that will be called by Twitter after the authorization:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The implementation of the callback route starts off by using global statements
    so we can use the global variables `req_token` and `consumer`.
  prefs: []
  type: TYPE_NORMAL
- en: Now we get to the interesting part. After the authorization, Twitter will return
    an `outh_verifier` so we get it from the request arguments and set it to the variable
    `oauth_verifier`; we create a `Token` instance using the `oauth_token` and `oauth_token_secret`
    that we obtained in the first part of our authorization process.
  prefs: []
  type: TYPE_NORMAL
- en: And we set the `oauth_verifier` in the `Token` object and finally create a new
    client that we are going to use to perform a new request with.
  prefs: []
  type: TYPE_NORMAL
- en: We decode the data received from the request and add it to the access token
    variable and, to wrap things up, we write the content of `access_token` to a file
    `.twitterauth` in the `twittervotes` directory. This file is also in YAML format
    so we are going to add another model and one more function in the `config.py`
    file to read the new settings.
  prefs: []
  type: TYPE_NORMAL
- en: Note that this process needs to be done just once. That is the reason that we
    store the data in the `.twitterauth` file. Further requests need only to use the
    data contained in this file.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you check the contents of the `.twitterauth` file, you should have something
    similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'To finish the Flask application, we need to add the following code at the end
    of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s add a new model to the `models.py` file in `twittervotes/core/models/` with
    the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Great! One more thing—we need to import the new model in the `__init__.py`
    file in the `twittervotes/core/models` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, let''s add a function to read the `.twittervotes` file in `config.py` in
    `twittervotes/core`. First, we need to import the `RequestAuth`—`namedtuple` that
    we just created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we create a function called `read_reqauth` shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This function is very straightforward: we just call the `_read_yaml_file`,
    passing as arguments the `.twitterauth` file and the new `namedtuple`, `RequestAuth`,
    that we just created. Again, if some error occurs, we raise an exception and show
    a help message.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can try the authentication. In the `twittervotes` directory, execute
    the script `twitter_auth.py`. You should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a1052ea8-4738-468c-8caf-a568a927ddb4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Great! The server is up and running so we can open a browser and go to `http://localhost:3000`.
    You should see a very simple page with a link to perform the authentication:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/f28c4eee-25af-45b5-9e14-5393bcf250dd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you inspect the link with the browser development tools, you will see that
    the link is pointing to the authorize endpoint and it is passing the `oauth_token`
    that we created:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a23ce439-f6f8-4e4d-ac05-2552bf452cf7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Go ahead and click on the link and you will be sent to the authorization page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/8d73d3dc-f1c8-409d-b33a-f7833b594ba1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you click on the Authorize app button, you will be redirected back to localhost
    and a success message will be displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ce6bc11b-7601-4b60-847b-4bdbb247c79a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you pay attention to the URL Twitter has sent back to us, you will find
    some information. The important point here is the `oauth_verifier` that we will
    set to the request token and we perform one last request to get the access token.
    Now you can close the browser, stop the Flask app, and see the results in the
    file `.twitterauth` in the `twittervotes` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Now, all the functionality that we implemented here is very useful if other
    users are going to use our application; however, there's an easier way to obtain
    the access token if you are authorizing your own Twitter app. Let's have a look
    at how that is done.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go back to the Twitter application settings in [https://apps.twitter.com/](https://apps.twitter.com/);
    select the Keys and Access Tokens tab and scroll all the way down. If you have
    already authorized this application, you will see the same information we have
    now in the file `.twitterauth` but if you haven''t authorized the application
    yet, you will see a Your Access Token section looking like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a155fb51-8b1d-443a-bb29-9eebada375ce.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you click on Create my access token, Twitter will generate the access token
    for you:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/48983a7f-97bd-4851-a5a1-45ddc1151e89.png)'
  prefs: []
  type: TYPE_IMG
- en: After the access token is created, you can just copy the data into the `.twitterauth`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Building the Twitter voting application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we have our environment set up and we have seen how to create an app on
    Twitter and perform three-legged authentication, it is time to get right into
    building the actual application that will count the Twitter votes.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start off by creating a model class that will represent a hashtag. Create
    a file called `hashtag.py` in the `twittervotes/core/twitter` directory with the
    following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a very simple class. We can pass a name as an argument to the initializer;
    the name is the hashtag without the hash sign (`#`). In the initializer, we define
    a few properties: the name, which will be set to the argument that we pass to
    the initializer, then a property called `total` that will keep the hashtag usage
    count for us.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we set the `refresh_url`. The `refresh_url` is going to be used to
    perform queries to the Twitter API, and the interesting part here is that the
    `refresh_url` already contains the `id` of the latest tweet that has been returned,
    so we can use that to fetch only tweets that we haven't already fetched, to avoid
    counting the same tweet multiple times.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `refresh_url` looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can open the file `__init__.py` in the `twittervotes/core/twitter` directory
    and import the class that we just created, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Perfect! Now go ahead and create a file called `request.py` in the `twittervotes/core/`
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'As usual, we start adding some imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: First, we import the `oauth2` package that we are going to use to perform authentication;
    we prepare the request, signing it with the `SHA1` key. We also import `time`
    to set the `OAuth` timestamp setting. We import the function `parse_qsl`, which
    we are going to use to parse a query string so we can prepare a new request to
    search for the latest tweets, and the `json` module so we can deserialize the
    JSON data that the Twitter API sends back to us.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we import our own functions, `read_config` and `read_req_auth`, so we
    can read both configuration files. Lastly, we import the `json` package to parse
    the results and the `requests` package to perform the actual request to the Twitter
    search endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This function will read both configuration files—the `config.org` configuration
    file contains all the endpoint URLs that we need, and also the consumer keys.
    The `.twitterauth` file contains the `oauth_token` and `oauth_token_secret` that
    we will use to create a `Token` object that we will pass along with our request.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we define some parameters. `oauth_version` should, according to
    the Twitter API documentation, always be set to `1.0`. We also send `oauth_nonce`,
    which is a unique token that we must generate for every request, and lastly, `oauth_timestamp`,
    which is the time at which the request was created. Twitter will reject a request
    that was created too long before sending the request.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing that we attach to the parameters is `oauth_token`, which is the
    token that is stored in the `.twitterath` file, and the consumer key, which is
    the key that was stored in the `config.yaml` file.
  prefs: []
  type: TYPE_NORMAL
- en: We perform a request to get an authorization and if everything goes right, we
    sign the request with an SHA1 key and return the URL of the request.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we are going to add the function that will perform a request to search
    for a specific hashtag and return the results to us. Let''s go ahead and add another
    function called `execute_request`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This function will get a `Hashtag` object as an argument and the first thing
    we do in this function is to read the configuration file. Then we check whether
    the `Hashtag` object has a value in the `refresh_url` property; in that case,
    we are going remove the `?` sign in the front of the `refresh_url` string.
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, we use the function `parse_qsl` to parse the query string and return
    a list of tuples where the first item in the tuple is the name of the parameter
    and the second is its value. For example, let''s say we have a query string that
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'If we use the `parse_qsl`, passing as an argument this query string, we will
    get the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'And then if we pass this result to the `dict` function, we will get a dictionary
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'As I showed before, the `refresh_url` has the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: And after parsing and transforming it into a dictionary, we can use it to get
    refreshed data for the underlying hashtag.
  prefs: []
  type: TYPE_NORMAL
- en: If the `Hashtag` object does not have the property `refresh_url` set, then we
    simply define a dictionary where the `q` is the hashtag name and the result type
    is set to `mixed` to tell the Twitter API that it should return popular, recent,
    and real-time tweets.
  prefs: []
  type: TYPE_NORMAL
- en: After defining the search parameters, we use the `prepare_request` function
    that we created above to authorize the request and sign it; when we get the URL
    back, we perform the request using the URL we get back from the `prepare_request`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: We make use of the `json.loads` function to parse the JSON data and return a
    tuple containing the first item, the hashtag itself; the second item will be the
    results we get back from the request.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final touch, as usual, is to import the `execute_request` function in the
    `__init__.py` file in the core module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see how that works in the Python REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/4df954cf-1c1b-40f6-951d-3c6d7acaa55d.png)'
  prefs: []
  type: TYPE_IMG
- en: The output above is much bigger than this but a lot of it has been omitted;
    I just wanted to demonstrate how the function works.
  prefs: []
  type: TYPE_NORMAL
- en: Enhancing our code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We also want to give our users a good experience so we are going to add a command-line
    parser so the users of our application can specify some parameters before starting
    the voting process. There will be only one argument that we are going to implement
    and that is `--hashtags`, where users can pass a space-separated list of hashtags.
  prefs: []
  type: TYPE_NORMAL
- en: With that said, we are going to define some rules for these arguments. First,
    we will limit the maximum number of hashtags that we are going to monitor, so
    we are going to add a rule that no more than four hashtags can be used.
  prefs: []
  type: TYPE_NORMAL
- en: If the user specifies more than four hashtags, we will simply display a warning
    on the Terminal and pick the first four hashtags. We also want to remove the duplicated
    hashtags.
  prefs: []
  type: TYPE_NORMAL
- en: When showing these warning messages that we talked about, we could simply print
    them on the Terminal and it would definitely work; however, we want to make things
    more interesting, so we are going to use the logging package to do it. Apart from
    that, implementing a proper logging will give us much more control over what kind
    of log we want to have and also how we want to present it to the users.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we start implementing the command-line parser, let''s add the logger.
    Create a file called `app_logger.py` in the `twittervotes/core` directory with
    the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This function doesn't do much but first we import the `os` module, then we import
    the logging package, and lastly, we import the function `fileConfig`, which reads
    the logging configuration from a config file. This configuration file has to be
    in the `configparser` format and you can get more information about this format
    at [https://docs.python.org/3.6/library/logging.config.html#logging-config-fileformat](https://docs.python.org/3.6/library/logging.config.html#logging-config-fileformat).
  prefs: []
  type: TYPE_NORMAL
- en: After we read the configuration file, we just return a logger called `twitterVotesLogger`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see what the configuration file for our application looks like. Create
    a file called `logconfig.ini` in the `twittervotes` directory with the following
    content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: So here we define two loggers, `root` and `twitterVotesLogger`; the loggers
    are responsible for exposing methods that we can use at runtime to log messages.
    It is also through the loggers that we can set the level of severity, for example,
    `INFO`, `DEBUG` and so on. Lastly, the logger passes the log messages along to
    the appropriated handler.
  prefs: []
  type: TYPE_NORMAL
- en: In the definition of our `twitterVotesLogger`, we set the level of severity
    to `INFO`, we set the handler to `consoleHandler` (we are going to describe this
    very soon), and we also set a qualified name that will be used when we want to
    get hold of the `twitterVotesLogger`.
  prefs: []
  type: TYPE_NORMAL
- en: The last option for `twitterVotesLoggers` is `propagate`. Since the `twitterVotesLogger`
    is a child logger, we don't want the log message sent through the `twittersVotesLogger`
    to propagate to its ancestors. Without `propagate` set to `0`, every log message
    would be shown twice since the `twitterVotesLogger`'s ancestor is the `root` logger.
  prefs: []
  type: TYPE_NORMAL
- en: The next component in the logging configuration is the handler. Handlers are
    the component that sends the log messages of a specific logger to a destination.
    We defined a handler called `consoleHandler` of type `StreamHandler`, which is
    a built-in handler of the logging module. The `StreamHandler` sends out log messages
    to streams such as `sys.stdout`, `sys.stderr`, or a file. This is perfect for
    us because we want to send messages to the Terminal.
  prefs: []
  type: TYPE_NORMAL
- en: In the `consoleHandler`, we also set the severity level to `INFO` and also we
    set the formatter which is set to the `customFormatter`; then we set the value
    for args to `(sys.stdout, )`. Args specify where the log messages will be sent
    to; in this case, we set only `sys.stdout` but you can add multiple output streams
    if you need.
  prefs: []
  type: TYPE_NORMAL
- en: The last component of this configuration is the formatter `customFormatter`.
    Formatters simply define how the log message should be displayed. In our `customFormatter`,
    we just define how the message should be displayed and show the date format.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the logging in place, let''s add the functions that will parse
    the command line. Create a file `cmdline_parser.py` in `twittervotes/core` and
    add some imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we will need to add a function that will validate the command-line arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '`validate_args` functions have only one parameter and it is the arguments that
    have been parsed by the `ArgumentParser.` The first thing we do in this function
    is to get hold of the logger that we just created, so we can send log messages
    to inform the user about possible problems in the command-line arguments that
    have been passed to the application.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we transform the list of hashtags into a set so all the duplicated hashtags
    are removed and then we transform it back to a list. After that, we check whether
    the number of unique hashtags is less than the original number of hashtags that
    have been passed on the command line. That means that we had duplication and we
    log a message to inform the user about that.
  prefs: []
  type: TYPE_NORMAL
- en: The last verification we do is to make sure that a maximum of four hashtags
    will be monitored by our application. If the number of items in the hashtag list
    is greater than four, then we slice the array, getting only the first four items,
    and we also log a message to inform the user that only four hashtags will be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add another function, `parse_commandline_args`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: We saw how the `ArgumentParser` works when we were developing the application
    in the first chapter, the weather application. However, we can still go through
    what this function does.
  prefs: []
  type: TYPE_NORMAL
- en: First, we define an `ArgumentParser` object, defining a name and a description,
    and we create a subgroup called `required` that, as the name suggests, will have
    all the required fields.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we don't really need to create this extra group; however, I find that
    it helps to keep the code more organized and easier to maintain in case it is
    necessary to add new options in the future.
  prefs: []
  type: TYPE_NORMAL
- en: 'We define only one argument, `hashtags`. In the definition of the `hashtags`
    argument, there is an argument called `nargs` and we have set it to `+`; this
    means that I can pass an unlimited number of items separated by spaces, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The last thing we do in this function is to parse the arguments with the `parse_args`
    function and run the arguments through the `validate_args` function that has been
    shown previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s import the `parse_commandline_args` function in the `__init__.py` file
    in the `twittervotes/core` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need to create a class that will help us to manage hashtags and perform
    tasks such as keeping the score count of hashtags, updating its value after every
    request. So let''s go ahead and create a class called `HashtagStatsManager`. Create
    a file called `hashtagstats_manager.py` in `twittervotes/core/twitter` with the
    following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'This class is also very simple: in the constructor, we get a list of hashtags
    and initialize a property, `_hashtags`, which will be a dictionary where the key
    is the name of the hashtag and the value is an instance of the `Hashtag` class.'
  prefs: []
  type: TYPE_NORMAL
- en: The update method gets a tuple containing a `Hashtag` object and the results
    are returned by the Twitter API.  First, we unpack the tuple values and set it
    to the `hashtag` and `results` variables. The `results` dictionary has two items
    that are interesting to us. The first is the `search_metadata`; in this item,
    we will find the `refresh_url` and the statuses contain a list of all tweets that
    used the hashtag that we were searching for.
  prefs: []
  type: TYPE_NORMAL
- en: So we get the values for the `search_metadata`, the `refresh_url`, and lastly
    the `statuses`. Then we count how many items there are in the `statuses` list.
    If the number of items on the statuses list is greater than `0`, we update the
    total count for the underlying hashtag as well as its `refresh_url`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we import the `HashtagStatsManager` class that we just created in the
    `__init__.py` file in the `twittervotes/core/twitter` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The heart of this application is the class `Runner`. This class will perform
    the execution of a function and queue it in the process pool. Every function will
    be executed in parallel in a different process, which will make the program much
    faster than if I executed these functions one by one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at how the `Runner` class is implemented:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The class `Runner` has an initializer taking three arguments; they are all functions
    that will be called in different statuses of the execution. `on_success` will
    be called when the execution of the item has been successful, `on_error` when
    the execution of one function has failed for some reason, and finally `on_complete` will
    be called when all the functions in the queue have been executed.
  prefs: []
  type: TYPE_NORMAL
- en: There is also a method called `exec` that takes a function as the first argument,
    which is the function that will be executed, and the second argument is a list
    of `Hashtag` instances.
  prefs: []
  type: TYPE_NORMAL
- en: There are a few interesting things in the `Runner` class. First, we are using
    the `concurrent.futures` module, which is a really nice addition to Python and
    has been around since Python 3.2; this module provides ways of executing callables
    asynchronously.
  prefs: []
  type: TYPE_NORMAL
- en: The `concurrent.futures` module also provides the `ThreadPoolExecutor`, which
    will perform asynchronous executions using threads, and the `ProcessPollExecutor`,
    which uses a process. You can easily switch between these execution strategies
    according to your needs.
  prefs: []
  type: TYPE_NORMAL
- en: The rule of thumb is if your function is CPU-bound, it is a good idea to use
    `ProcessPollExecutor`, otherwise, you will suffer big performances issues because
    of the Python **Global Interpreter Lock** (**GIL**). For I/O-bound operations,
    I prefer using `ThreadPoolExecutor`.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to read more about the GIL, you can check out the following wiki
    page: [https://wiki.python.org/moin/GlobalInterpreterLock](https://wiki.python.org/moin/GlobalInterpreterLock).
  prefs: []
  type: TYPE_NORMAL
- en: Since we are not doing any I/O-bound operations, we use `ProcessPoolExecutor`.
    Then, we loop through the values of the items, which is a dictionary containing
    all the hashtags that our application is monitoring. And for every hashtag, we
    pass it to the `submit` function of the `ProcessPollExecutor` along with the function
    that we want to execute; in our case, it will be the `execute_request` function
    defined in the core module of our application.
  prefs: []
  type: TYPE_NORMAL
- en: The `submit` function, instead of returning the value returned by the `execute_request`
    function, will return a `future` object, which encapsulates the asynchronous execution
    of the `execute_request` function. The `future` object provides methods to cancel
    an execution, check the status of the execution, get the results of the execution,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we want a way to be notified when the executions change state or when they
    finish. That is where reactive programming comes in handy.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we get the `future` object and create an `Observable`. `Observables` are
    the core of reactive programming. An `Observable` is an object that can be observed
    and emit events at any given time. When an `Observable` emits an event, all observers
    that subscribed to that `Observable` will be notified and react to those changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is exactly what we are trying to achieve here: we have an array of future
    executions and we want to be notified when those executions change state. These
    states will be handled by the functions that we passed as an argument to the `Runner`
    initializer—`_on_sucess`, `_on_error`, and `_on_complete`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Perfect! Let''s import the `Runner` class into `__init__.py` in the `twittervotes/core`
    directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The last piece of our project is to add the entry point of our application.
    We are going to add the user interface using the `Tkinter` package from the standard
    library. So let''s start implementing it. Create a file called `app.py` in the
    `twittervotes` directory, and let''s start by adding some imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Here, we import the command-line argument parser that we created, `execute_request` to
    perform the requests to the Twitter API, and also the `Runner` class that will
    help us execute the requests to the Twitter API  in parallel.
  prefs: []
  type: TYPE_NORMAL
- en: We also import the `HashtagStatsManager` to manage the hashtag voting results
    for us.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we have all the imports related to `tkinter`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the same file, let''s create a class called `Application` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'So here, we create a class, `Application`, that inherits from `Frame`. The
    initializer takes two arguments: hashtags, which are the hashtags that we are
    going to monitor, and the master argument, which is an object of type `Tk`.'
  prefs: []
  type: TYPE_NORMAL
- en: Then we create an instance of `HashtagStatsManager`, passing the list of hashtags;
    we also create an instance of the `Runner` class passing three arguments. These
    arguments are functions that will be called when one execution finishes successfully,
    when the execution fails, and when all the executions are complete.
  prefs: []
  type: TYPE_NORMAL
- en: Then we have a dictionary comprehension that will create a dictionary where
    the keys are the hashtags and the values are a `Tkinter` variable of type string,
    which in the `Tkinter` world is called `StringVar`. We do that so it will be easier
    to update the labels with the results later on.
  prefs: []
  type: TYPE_NORMAL
- en: We call the methods `set_header `and `create_labels` that we are going to implement
    shortly and finally we call `pack`. The `pack` function will organize widgets
    such as buttons and labels and place them in the parent widget, in this case,
    the `Application`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we define a button that will execute the function `_fetch_data` when clicked
    and we use `pack` to place the button at the bottom of the frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Here's the `set_header` method that I mentioned earlier; it simply creates `Label` objects
    and places them at the top of the frame.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can add the `create_labels` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The `create_labels` method loops through `self._items`, which, if you remember,
    is a dictionary where the key is the name of the hashtag and the value is a `Tkinter`
    variable of type string.
  prefs: []
  type: TYPE_NORMAL
- en: First, we create a `Label`, and the interesting part is the `textvariable` argument;
    we set it to `value`, which is a `Tkinter` variable related to a specific hashtag.
    Then we place the `Label` in the frame and, lastly, we set the value of the label
    using the function `set`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we need to add a method that will update the `Labels` for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The `_update_label`, as the name suggests, updates the label of a specific hashtag.
    The data argument is the results returned by the Twitter API and we get the total
    number of the hashtags from the manager. Finally, we use the `set` function again
    to update the label.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add another function that will actually do the work of sending the requests
    to the Twitter API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: This method will call the method `exec` of the `Runner` to execute the function
    that performs the requests to the Twitter API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we need to define the methods that will handle the events emitted by the
    `Observable`s created in the `Runner` class; we start by adding the method that
    will handle execution errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: This is a `helper` method just to raise an exception in case something goes
    wrong with the execution of the requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we add another method that handles when the execution of an `Observable`
    has been successful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: The `_on_success` method is going to be called when one execution from the `Runner`
    finished successfully, and it will just update the manager with the new data and
    also update the label in the UI.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, we define a method that will handle when all the executions have been
    completed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The `_on_complete` will be called when all the executions of the `Runner` finish.
    We are not going to be using it so we just use the `pass` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now it is time to implement the function that will set up the application and
    initialize the UI—the function `start_app`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: This function creates the root application, sets the title, defines its dimensions,
    and also calls the `mainloop` function so the application keeps running.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last piece is to define the `main` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The `main` function is pretty simple. First, we parse the command-line arguments,
    then we start the application, passing the command-line arguments to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see the application in action! Run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c3d0e26c-fbeb-405e-9809-f6a8547098ef.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s say we want the voting process to run for 3 minutes and it will monitor
    the hashtags `#debian`, `#ubuntu`, and `#arch`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Then you should see the following UI:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/0b4368f8-3691-4d0c-b79d-48b2dcfb5bd2.png)'
  prefs: []
  type: TYPE_IMG
- en: And if you click the Update button, the count for every hashtag will be updated.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we developed an application to cast votes on Twitter and we
    learned the different concepts and paradigms of the Python programming language.
  prefs: []
  type: TYPE_NORMAL
- en: By creating the hashtag voting application, you have learned how to create and
    configure a Twitter app and also how to implement a three-legged `OAuth` authentication
    to consume data from the Twitter API.
  prefs: []
  type: TYPE_NORMAL
- en: We also learned how to use the logging module to show informational messages
    to the users of our application. Like the previous modules, we also created a
    command-line parser using the `ArgumentParser` module in the standard library.
  prefs: []
  type: TYPE_NORMAL
- en: We also had an introduction to reactive programming using the `Rx` (Reactive
    Extensions for Python) module. Then we used the `concurrent.futures` module to
    enhance the performance of our application, running multiple requests to the Twitter
    API in parallel.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we built a user interface using the `Tkinter` module.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to build an application that will fetch exchange
    rate data from the site [http://fixer.io](http://fixer.io) to perform currency
    conversion.
  prefs: []
  type: TYPE_NORMAL
