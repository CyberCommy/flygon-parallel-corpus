- en: '*Chapter 8*: Administering Systems Remotely'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When working with systems, once the server has been installed, and many times,
    even during the installation itself, administration can be performed remotely.
    Once a machine has been installed, the tasks that need to be performed during
    its life cycle are not that different to the ones that have already been performed.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will cover, from a connection point of view, how to connect
    to remote systems, transfer files, and how to automate the connection so that
    it can be scripted and make it resilient if issues arise with the network link.
    Administration tasks that can be performed on the system are the same as the ones
    we described in previous chapters, such as installing software, configuring additional
    networking settings, and even managing users.
  prefs: []
  type: TYPE_NORMAL
- en: Since administering a system requires privileged credentials, we will focus
    on the available tools that are considered to be secure to perform such connections,
    as well as how to use them to encapsulate other traffic.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: SSH and OpenSSH overview and base configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing remote systems with SSH
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Key-based authentication with SSH
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remote file management with SCP/rsync
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advanced remote management – SSH tunnels and SSH redirections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remote terminals with tmux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By covering these topics, we will be able to master remote system access and
    bring our administration skills to the next level.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start by talking about the SSH protocol and the OpenSSH client and server
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can continue using the virtual machine that we created at the beginning
    of this book in [*Chapter 1*](B16799_01_Final_SK_ePub.xhtml#_idTextAnchor014),
    *Installing RHEL8*. Any additional packages that are required will be indicated
    in the text. Any additional files that are required for this chapter can be downloaded
    from [https://github.com/PacktPublishing/Red-Hat-Enterprise-Linux-8-Administration](https://github.com/PacktPublishing/Red-Hat-Enterprise-Linux-8-Administration).
  prefs: []
  type: TYPE_NORMAL
- en: SSH and OpenSSH overview and base configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**SSH** is an acronym for **Secure Shell Host**. It started to spread by replacing
    traditional telnet usage, which was a remote login protocol that used no encryption
    for connecting to hosts, so the credentials that were used for logging in were
    transmitted in plain text. This means that anyone who had a system between the
    user terminal and the remote server could intercept the username and password
    and use that information to connect to remote systems. This is similar to what
    happens when credentials are transmitted to a web server via HTTP and not HTTPS.'
  prefs: []
  type: TYPE_NORMAL
- en: With SSH, a secure channel is created between the client and the target host,
    even if the connection is performed over untrusted or insecure networks. Here,
    the SSH channel that's created is secure and no information is leaked.
  prefs: []
  type: TYPE_NORMAL
- en: OpenSSH provides both a server and a client (the `openssh-server` and `openssh-clients`
    packages in **Red Hat Enterprise Linux** (**RHEL**) that can be used to connect
    to and allow connections from remote hosts.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Knowing everything is not possible, so it is really important for `rpm –ql package`
    to review the list of files provided by a package if you cannot remember which
    one to use.
  prefs: []
  type: TYPE_NORMAL
- en: The default configuration for both the client and server allows connections,
    but there are many options that can be tuned.
  prefs: []
  type: TYPE_NORMAL
- en: OpenSSH server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: OpenSSH is a free implementation based on the last free SSH version that was
    created by OpenBSD members and updated with all the relevant security and features.
    It has become a standard in many operating systems, both as a server and as a
    client, to make secure connections between them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main configuration file for the OpenSSH server is located at `/etc/ssh/sshd_config`
    (and you can use `man sshd_config` to get detailed information about the different
    options). Some of the most used options are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AcceptEnv`: Defines which environment variables that have been set by the
    client will be used on the remote host (for example, locale, terminal type, and
    so on).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AllowGroups`: A list of groups a user should be a member of to get access
    to the system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AllowTcpForwarding`: Allows us to forward ports using the SSH connection (we
    will discuss this later in this chapter, in the *SSH tunnels and SSH redirections*
    section).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DisableForwarding`: This takes precedence over other forwarding options, making
    it easier to restrict the service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AuthenticationMethods`: Defines which authentication methods can be used,
    such as disabling password-based access.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Banner`: Files to send to the connecting user before authentication is allowed.
    This defaults to no banner, which might also reveal who is running the service
    that might be providing too much data to possible attackers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Ciphers`: A list of valid ciphers to use when you''re interacting with the
    server. You can use `+` or `–` to enable or disable them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ListenAddress`: The hostname or address and port where the `sshd` daemon should
    be listening for incoming connections.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PasswordAuthentication`: This defaults to yes and can be disabled to block
    users from interactively connecting to the system unless a public/private keypair
    is used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PermitEmptyPasswords`: Allows accounts with no password to access the system
    (the default is no).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PermitRootLogin`: Defines how login works for the root user, for example,
    to avoid the root user from connecting remotely with a password.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Port`: Related to `ListenAddress`, this defaults to `22`. It''s the port number
    where the `sshd` daemon listens for incoming connections.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Subsystem`: Configures the command for the external subsystem. For example,
    it is used with `sftp` for file transfers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`X11Forwarding`: This defines whether `X11` forwarding is permitted so that
    remote users can open graphical programs on their local display by tunneling the
    connection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following screenshot shows the options that are installed by our system
    while we''re removing comments:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1 – Default values at installation time defined in /etc/ssh/sshd_config'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_08_001.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.1 – Default values at installation time defined in /etc/ssh/sshd_config
  prefs: []
  type: TYPE_NORMAL
- en: We'll check the client part of the configuration in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: OpenSSH client
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The client part of OpenSSH is configured system-wide via the `/etc/ssh/ssh_config`
    file and the files in the `/etc/ssh/ssh_config.d/` folder. They are also configured
    via each user `~/.ssh/config` file.
  prefs: []
  type: TYPE_NORMAL
- en: Usually, the system-wide file just contains some comments, not actual settings,
    so we will be focusing on the per-user configuration file and command-line parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'One example entry in our `~/.ssh/config` file could be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the previous example, we defined an entry named `jump` (that we can use with
    `ssh jump`) that will connect the `root` username to the `jump.example.com` host.
  prefs: []
  type: TYPE_NORMAL
- en: This is a basic setting, but we're also defining that we'll be using a helper
    program in `ProxyCommand` that will make use of a proxy server on `squid.example.com`
    on port `3128` to connect to the `%h` host and `%p` port to reach our target system.
    Additionally, we're making use of `Compression` and using `ControlMaster` with
    additional `GSSAPI` authentication.
  prefs: []
  type: TYPE_NORMAL
- en: One feature that has security implications is `StrictHostKeyChecking`. When
    we connect to a host for the first time, keys are exchanged between the client
    and the host, and the server identifies itself with the keys that are used. If
    they're accepted, they will be stored in the `.ssh/known_hosts` file at the user's
    home.
  prefs: []
  type: TYPE_NORMAL
- en: If the remote host key is changed, a warning will be printed on the `ssh` client's
    terminal and the connection will be refused, but when we set `StrictHostKeyChecking`
    to `no`, we will accept any key that's sent by the server, which might be useful
    if we're using a test system that gets redeployed frequently (and thus, generating
    a new host key). It is not recommended to be used in general, since it protects
    us from a server being replaced and also someone impersonating the server we want
    to connect to with a server that, for example, logs usernames and passwords to
    access our system later.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will learn about accessing remote systems with `ssh`.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing remote systems with SSH
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SSH, as we mentioned earlier in this chapter, is a protocol that's used to connect
    to remote systems. In general, the syntax, in its most basic form, is just executing
    `ssh host` within a terminal.
  prefs: []
  type: TYPE_NORMAL
- en: The `ssh` client will then initiate a connection to the `ssh` server on the
    target host, using the username of the currently logged-in user by default, and
    will try to reach the remote server on port `22/tcp`, which is the default for
    the SSH service.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following screenshot, we can see the closest server to our `localhost`
    system, which means we will be connecting to our own server:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2 – Initiating a SSH connection to localhost'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_08_002.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.2 – Initiating a SSH connection to localhost
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding screenshot, we can see how the first interaction with the server
    prints the fingerprint of the server to authenticate it. This is what was discussed
    in the previous section; that is, `StrictHostKeyChecking`. Once accepted, if the
    host key changes, the connection will be denied until we manually remove the older
    key to confirm that we're aware of the server change.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add the key and try again, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.3 – Initiating an SSH connection to localhost denied'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_08_003.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.3 – Initiating an SSH connection to localhost denied
  prefs: []
  type: TYPE_NORMAL
- en: On our second attempt, the connection failed, but let's examine the output;
    that is, `Permission denied (publickey,gssapi-keyex,gssapi-with-mic)`. What does
    it mean? If we pay attention, `password` isn't listed, which means that we cannot
    connect to this host via a password prompt (which comes from setting `PasswordAuthentication`
    to `no`, which we defined in the `/etc/ssh/sshd_config` file).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following screenshot, we can see that once we set `PasswordAuthentication`
    to `yes`, the system asks for the password, which is not echoed on screen. Once
    validated, we get a shell prompt so that we can start typing in commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.4 – SSH connection completed'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_08_004.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.4 – SSH connection completed
  prefs: []
  type: TYPE_NORMAL
- en: In general, password authentication can be a security risk as the keyboard might
    be intercepted, someone might be looking over your shoulder, a brute-force attack
    might be used against the accounts, and so on. Due to this, it's common practice
    to at least disable it for the `root` user, meaning that someone trying to log
    into the system should know the username and password for a user, and from there,
    use the system tools to become `root`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's learn how to log into remote systems that have passwords disabled by using
    authentication keys.
  prefs: []
  type: TYPE_NORMAL
- en: Key-based authentication with SSH
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One big advantage of SSH connections is that commands can be given to be executed
    on remote hosts, for example, to grab updated data that can be used for monitoring
    without requiring a specific agent on the host.
  prefs: []
  type: TYPE_NORMAL
- en: Having to provide login details on each connection is not something that we
    could consider an improvement to the user experience, but SSH also allows us to
    create a keypair that can be used for authentication to remote systems so that
    no password or credential input is required.
  prefs: []
  type: TYPE_NORMAL
- en: 'The keys contain two parts: one that is public and must be configured in each
    host we want to connect to, and one that is private and must be secured as it
    will be used to identify us while we''re trying to connect to remote hosts.'
  prefs: []
  type: TYPE_NORMAL
- en: It is not necessary to say that this entire process happens over the encrypted
    connection created by SSH. So, using SSH and compression will also make our connections
    faster versus other legacy methods such as telnet, which is unencrypted.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, let's create one keypair for authentication.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: 'It is recommended to have at least one keypair per user so that each user can
    have keys based on the roles when they''re connecting to servers. Even if the
    keys can be shared for users in a role, it''s better to have each user have its
    own set so that keys can be revoked individually. For example, we can keep several
    `ssh` keypairs to be used in different roles, such as personal systems, production
    systems, lab systems, and so on. Having to specify the keypair for connecting
    is also an extra security measure: we cannot connect to production systems unless
    we use the production keypair.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a keypair, we can use the `ssh-keygen` tool, which has several options
    for the key we are creating, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.5 – ssh-keygen options'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_08_005.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.5 – ssh-keygen options
  prefs: []
  type: TYPE_NORMAL
- en: 'When no arguments are provided, by default, it will create a key for the current
    user and ask for a password for the key. When we use the defaults and provide
    no values, we get an output similar to the one shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.6 – ssh-keygen execution creating an RSA keypair under ~/.ssh/{id_rsa,id_rsa.pub}'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_08_006.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.6 – ssh-keygen execution creating an RSA keypair under ~/.ssh/{id_rsa,id_rsa.pub}
  prefs: []
  type: TYPE_NORMAL
- en: From this point on, this system has created a keypair for the root user, and
    it has stored the two pieces of it in the same folder, which is `.ssh` by default.
    The public one contains the`.pub` suffix, while the other contains the private
    key.
  prefs: []
  type: TYPE_NORMAL
- en: 'How do we use them? If we look inside the `.ssh` folder in our home directory,
    we can see several files: we have an `authorized_keys` file and a `known_hosts`
    file, in addition to the keypair we have just created. The `authorized_keys` file
    will contain one entry per line. This contains the public keys that can be used
    to log into this system for this user.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: The vast range of options that can be used with `authorized_keys` goes further
    than adding just regular keys – you can also define commands to execute, expiry
    times for keys, remote hosts that can be used to connect so that only those hosts
    will be able to use that key successfully, and many more. Again, `man sshd` is
    your friend, so check out the `AUTHORIZED_KEYS FILE FORMAT` section there to learn
    about more complex setups.
  prefs: []
  type: TYPE_NORMAL
- en: To simplify how keys are set up on remote systems, we have the `ssh-copy-id`
    utility, which connects via `ssh` to the remote host. This will ask for the `ssh`
    password and install the available public keys on our system. However, this requires
    the system to have password authentication enabled.
  prefs: []
  type: TYPE_NORMAL
- en: 'The alternate method consists of manually appending our public key to that
    file (`.ssh/autorized_keys`), as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.7 – ssh-copy-id failure and manual authorization of the private
    key'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_08_007.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.7 – ssh-copy-id failure and manual authorization of the private key
  prefs: []
  type: TYPE_NORMAL
- en: The first line has attempted to use `ssh-copy-id`, but since we had password
    authentication enabled, it tried to copy our public key and failed. Then, we appended
    the public key using `>>` to the `authorized_keys` file. Finally, we demonstrated
    how to connect to `localhost` with `ssh` and execute a command without a password.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: The permissions for the `.ssh` folder and the `authorized_keys` file must not
    be too wide open (for example, 777). If they are, the `ssh` daemon will reject
    them as someone could have appended new keys and tried to gain access without
    really being a legit user of the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'What has just happened opens a new world of automation. Using the keys being
    exchanged between our system and the remote hosts, we can now connect remotely
    to them to run commands interactively or to script commands to be executed on
    remote hosts. We can check the results in our terminal. Let''s consider this simple
    script, for a system load average check, which is available at [https://github.com/PacktPublishing/Red-Hat-Enterprise-Linux-8-Administration/blob/main/chapter-08-remote-systems-administration/loadaverage-check.sh](https://github.com/PacktPublishing/Red-Hat-Enterprise-Linux-8-Administration/blob/main/chapter-08-remote-systems-administration/loadaverage-check.sh):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we''re running a loop to connect to four systems and then
    outputting the name and the load average of that system, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.8 – Password-less login to four hosts to check their load average'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_08_008.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.8 – Password-less login to four hosts to check their load average
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, we quickly grabbed the information from four hosts over `ssh`.
    If you want to test this in your environment, you might want to put into practice
    what we learned about creating entries in the `/etc/hosts` file, which points
    to `127.0.0.1` for the host names we want to try, so that the connection goes
    to your own practice system, as we explained in [*Chapter 6*](B16799_06_Final_SK_ePub.xhtml#_idTextAnchor096),
    *Enabling Network Connectivity*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, think about the different options we have for administering our systems
    remotely:'
  prefs: []
  type: TYPE_NORMAL
- en: Check IPs for a range of hosts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Install updates or add/remove one package.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check the local time in case the system has drifted.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Restart one service after adding a new user to the system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many more options exist, but these are the main ones.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, there are more suitable tools for remotely administering systems
    and ensuring that errors are detected and handled properly, such as using Ansible,
    but in this case, for simple tasks, we are good to go.
  prefs: []
  type: TYPE_NORMAL
- en: Previously, we created a key and replied with `<ENTER>` when we were asked for
    a password. What if we had typed one in? We'll look at this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: SSH agent
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If we have decided to create an SSH key with a password to protect it (good
    choice), we will need to input the passphrase each time we want to use the key,
    so in the end, it might be as insecure as having to type in the password as someone
    might be checking over our shoulder. To overcome this, we can use a program called
    `ssh-agent` that temporarily keeps the passphrase in memory. This is convenient
    and reduces the chances of someone watching while you type in your key.
  prefs: []
  type: TYPE_NORMAL
- en: When you're using a graphical desktop, such as `ssh-agent`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When `ssh-agent` is executed, it will output some variables that must be set
    in our environment so that we can make use of it, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.9 – ssh-agent being used to set the required variables'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_08_009.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.9 – ssh-agent being used to set the required variables
  prefs: []
  type: TYPE_NORMAL
- en: As shown in the preceding screenshot, before being executed, or just while we're
    executing the agent, the variables are undefined. However, if we were to execute
    `eval $(ssh-agent)`, we would accomplish the goal of having the variables defined
    and ready to use.
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to add the keys to the agent. This can be accomplished with
    the `ssh-add` command, which can be used without parameters or by specifying the
    key to be added. If the key requires a password, it will prompt you for it. Once
    we're done, we might be able to use that key to log into the systems with the
    passphrase that's being cached until we exit the session that executed the agent,
    thus clearing the passphrase from memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the command that was used to generate a new
    keypair with a password. Here, we can see that the only difference is that we''re
    storing it in a file named `withpass` versus what we did earlier in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.10 – Creating an additional ssh keypair with a password'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_08_010.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.10 – Creating an additional ssh keypair with a password
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see how to connect to our localhost (which we added the key for with
    the password public part of our `.ssh/authorized_keys` while removing the one
    without a password) and how the connection behaves in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.11 – Using ssh-agent to remember our passphrase'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_08_011.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.11 – Using ssh-agent to remember our passphrase
  prefs: []
  type: TYPE_NORMAL
- en: 'To make this clearer, let''s analyze what''s happening:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we `ssh` to the host. Permission is denied as the default key we used
    was removed from `authorized_keys`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We `ssh` again but while defining the identity file (the keypair) to connect
    to, as we can see, we're asked for the passphrase for the key, not for logging
    into the system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we log out and the connection is closed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we try to add the key, and we get an error because we have not set the
    environment variables for the agent.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As instructed when we introduced the agent, we execute the command for loading
    the environment variables for the agent in the current shell.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When we retry adding the key with `ssh-add withpass`, the agent asks for our
    passphrase.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When we finally `ssh` to the host, we can connect without a password as the
    key is in memory for our keypair.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here, we have achieved two things: we now have an automated/disattended method
    to connect to systems and have ensured that only authorized users will know the
    passphrase to unlock them.'
  prefs: []
  type: TYPE_NORMAL
- en: We'll learn how to do remote file management in the next section!
  prefs: []
  type: TYPE_NORMAL
- en: SCP/rsync – remote file management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Similar to `telnet`, which was replaced with `ssh` on many devices and systems,
    using insecure solutions for file transfer is being reduced. By default, the `21`,
    but since communication happened in plain text, it was a perfect target for intercepting
    credentials. FTP is still used today, mostly for serving file on servers that
    only allow anonymous access and wish to move to more secure options.
  prefs: []
  type: TYPE_NORMAL
- en: 'SSH usually enables two interfaces for copying files: `scp` and `sftp`. The
    first one is used in a similar way to the regular `cp` command, but here, we''re
    accepting remote hosts as our target or source, while `sftp` uses a client approach
    similar to the traditional `ftp` command that interacts with FTP servers. Just
    remember that in both cases, the connection is encrypted and happens over port
    `22/tcp` on the target host.'
  prefs: []
  type: TYPE_NORMAL
- en: We'll dig into SCP in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Transferring files with an OpenSSH secure file copy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `scp` command, which is part of the `openssh-clients` package, allows us
    to copy files between systems using the `ssh` layer for the whole process. This
    allows us to securely transfer a file's contents, plus all the automation capabilities
    that were introduced by keypair login, to various systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'To set up this example, we will create a new user in our sample system that
    will be used to copy over files using the tools described in this section, as
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.12 – Preparing our system with an additional user to practice file
    transfers'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_08_012.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.12 – Preparing our system with an additional user to practice file
    transfers
  prefs: []
  type: TYPE_NORMAL
- en: You can find the preceding commands in a script available at [https://github.com/PacktPublishing/Red-Hat-Enterprise-Linux-8-Administration/blob/main/chapter-08-remote-systems-administration/create-kys-user.sh](https://github.com/PacktPublishing/Red-Hat-Enterprise-Linux-8-Administration/blob/main/chapter-08-remote-systems-administration/create-kys-user.sh).
  prefs: []
  type: TYPE_NORMAL
- en: Once the user has been created and the key has been copied, we can start testing!
  prefs: []
  type: TYPE_NORMAL
- en: 'Earlier in this chapter, we created a key named `withpass` with a public counterpart
    at `withpass.pub`. To provide the key to the newly created user, we can copy both
    files to the `kys` user via the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s analyze each part of the command using this template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In our case, `origin` is indicated with `withpass.*`, which means that it will
    select all the files starting with the `withpass` string.
  prefs: []
  type: TYPE_NORMAL
- en: Our `target` value is a remote host. Here, the username is `kys`, the host is
    `localhost`, and the folder you should store the files in is the default one,
    usually the home folder of the user indicated (the one with an empty path after
    the`:` symbol).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following screenshot, we can see the output of the command and the validation
    we can perform later via remote execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.13 – Copying SCP files to a remote path and validating the files
    that have been copied'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_08_013.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.13 – Copying SCP files to a remote path and validating the files that
    have been copied
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding screenshot, you can also check that the files that were owned
    by the root user are copied. The copied ones are owned by the `kys` user, so the
    file's contents are the same, but since the creator on the target is the `kys`
    user, files have their ownership.
  prefs: []
  type: TYPE_NORMAL
- en: We can also make more complex copies by indicating remote files first and local
    paths as targets so that we download files to our system, or even copy files across
    remote locations for both the origin and target (unless we specify the`–3` option,
    they will go directly from `origin` to `target`).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Time for a reminder! `man scp` will show you all the available options for the
    `scp` command, but since it is based on `ssh`, most of the options we use with
    `ssh` are available, as well as the host definitions we made in the `.ssh/config`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: We'll explore the `sftp` client in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Transferring files with sftp
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Compared to `scp`, which can be scripted in the same way we can script with
    the regular `cp` command, `sftp` has an interactive client for navigating a remote
    system. However, it can also automatically retrieve files when a path containing
    files is specified.
  prefs: []
  type: TYPE_NORMAL
- en: 'To learn about the different commands that are available, you can invoke the
    `help` command, which will list the available options, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.14 – Available sftp interactive mode commands'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_08_014.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.14 – Available sftp interactive mode commands
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an example of this with the help of the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.15 – Both modes of operation with sftp – automated transfer or interactive
    transfer'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_08_015.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.15 – Both modes of operation with sftp – automated transfer or interactive
    transfer
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we've created a local folder to be our work folder, called
    `getfilesback`. First, we have invoked `sftp` with a remote path with the files
    we've identified. Here, `sftp` has automatically transferred the files and has
    stopped executing. The files we have received are now the property of our user.
  prefs: []
  type: TYPE_NORMAL
- en: In the second command, when we invoke `sftp` with the user and host and we enter
    interactive mode, we can execute several commands, similar to what we can do on
    a remote shell session. Finally, using the `mget` command with the `*` wildcard
    character, we transferred the files to our local system.
  prefs: []
  type: TYPE_NORMAL
- en: In both cases, the files have been transferred from the remote system to our
    local system, so our goal has been accomplished. However, using `scp` requires
    knowing the exact path of the files you want to transfer. On the other hand, it
    might be a bit more user-friendly to navigate the system using the `ls` and `cd`
    commands within the `sftp` interactive client until we reach the files we want
    to transfer if we can't remember it.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's learn how to quickly transfers files and trees with `rsync`.
  prefs: []
  type: TYPE_NORMAL
- en: Transferring files with rsync
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although we can use the `–r` option of `scp` to transfer files recursively,
    `scp` only handles the full copy of the file, which is not ideal if we are just
    keeping some folders in sync across systems.
  prefs: []
  type: TYPE_NORMAL
- en: In 1996, `rsync` was launched, and many systems implemented it by using a dedicated
    server that was listening to client connections. This was to allow trees to be
    synchronized with files. This was done by copying over the differences between
    the files. Here, parts of the source and destination were compared to see whether
    there were differences that should be copied over.
  prefs: []
  type: TYPE_NORMAL
- en: With `ssh`, and with the `rsync` package installed on both the client and the
    server, we can take advantage of the secure channel that's created by `ssh` and
    the faster synchronization provided by `rsync`.
  prefs: []
  type: TYPE_NORMAL
- en: The difference between using the `rsync` daemon and using `ssh` is the syntax
    for the source or destination, which either uses the `rsync://` protocol or `::`
    after the hostname. In other cases, it will use `ssh` or even the local filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows us mentioning the schema for URLs via the `rsync
    –help` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.16 – The rsync command''s help output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_08_016.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.16 – The rsync command's help output
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s review some of the useful options we can use with `rsync`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-v` : Provides more verbose output during the transfer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-r`: Recurses into directories.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-u`: Update – only copies files that are newer than the ones at the target.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-a`: Archive (this includes several options, such as `–rlptgoD`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-X`: Preserves extended attributes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-A`: Preserves ACLs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-S`: Sparse – sequences of nulls will be converted into sparse blocks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--preallocate`: Claims the space that''s required for files before transferring
    them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--delete-during`: Deletes files on the target that are not hosted during the
    copy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--delete-before`: Deletes files on the target that are not hosted before the
    copy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--progress`: Shows progress information on the copy (copied files versus total
    files).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `r``sync` algorithm breaks the file into chunks and calculates checksums
    for each chunk that's transmitted to source. They are then compared to the ones
    for local files. We are only allowed to share the differences between the source
    and the target. `rsync` doesn't check the modification file date and size by default,
    so if the file has changed without changes being left in both, the change might
    not be detected unless a checksum check is forced for each file candidate to be
    transferred.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at some basic examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '`rsync –avr getfilesback/ newfolder/` will copy the files in the local `getfilesback/`
    folder to `newfolder/` by showing a progress update, but only for the updated
    files, as shown in the following screenshot:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 8.17 – The rsync operation being used on the same source/destination,'
  prefs: []
  type: TYPE_NORMAL
- en: repeated to illustrate transfer optimization
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_08_017.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.17 – The rsync operation being used on the same source/destination,
    repeated to illustrate transfer optimization
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, the second operation just sent 85 bytes and received 12 bytes.
    This is because there was a little checksum operation happening internally to
    validate across the folders because the files hadn't been changed. The same output
    can be obtained if we use the remote target approach with `rsync -avr --progress
    getfilesback/ root@localhost:newfolder/`, but in this case, `ssh` transport will
    be used.
  prefs: []
  type: TYPE_NORMAL
- en: Let's get some bigger sample files and compare them by checking out a Git repository
    at some point in time, transferring the files, then updating to the latest version
    to simulate work on the repository. Then, we will synchronize again.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s install `git` if it''s not installed and check out a sample repository
    by executing the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: At this point, we have a folder with files ready for transfer. Once we've done
    this, we'll execute `git pull` to sync with the latest changes and use `rsync`
    again to copy the differences. Later, we'll use `--delete` to remove any files
    that no longer exist on the source.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s check out the sequence shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.18 – Synchronizing the git folder to a new folder with rsync'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_08_018.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.18 – Synchronizing the git folder to a new folder with rsync
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding screenshot, pay attention to the speedup that's reported in
    the latest line of the command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s execute `git pull` to get the 400 changes we were missing and repeat
    `rsync` again. We will get an output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.19 – Using rsync again to copy over the differences'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_08_019.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.19 – Using rsync again to copy over the differences
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding screenshot, pay attention to the speedup reported in the last
    line so that you can compare it with the previous one.
  prefs: []
  type: TYPE_NORMAL
- en: From this sequence of screenshots, we can check the last numbers for the total
    bytes that were sent to see the improvement in transfer, along with some of the
    files that were received (because we added the `–v` modifier to get verbose output
    and `--progress`).
  prefs: []
  type: TYPE_NORMAL
- en: The biggest advantage comes when a copy is performed over slower network links
    and it's performed periodically, for example, as a way to copy to an offsite copy
    for backup purposes. This is because `rsync` will only copy the changes, update
    the newer files that have been modified on the source, and allow us to use compression
    over the `ssh` channel. For example, the Linux kernel at [https://www.kernel.org/](https://www.kernel.org/)
    can be mirrored using `rsync`.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will dig into a very interesting feature of SSH to make
    connecting to servers with no direct access easy.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced remote management – SSH tunnels and SSH redirections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SSH has two really powerful features; that is, SSH tunnels and SSH redirections.
    When an SSH connection is established, it can not only be used to send commands
    to the remote host and let us work on them as if they were our local system, but
    we can also create tunnels that interconnect our systems.
  prefs: []
  type: TYPE_NORMAL
- en: Let's try to imagine a scenario that is common in many companies, where a VPN
    is used to reach the internal network with all the services and servers, but with
    SSH instead of a regular VPN.
  prefs: []
  type: TYPE_NORMAL
- en: So, let's put some context into this imaginary scenario.
  prefs: []
  type: TYPE_NORMAL
- en: We can use a host that gets external traffic for `ssh` redirected from our internet
    router to the `ssh` service in that system. So, in brief, our router gets connections
    on port `22` via TCP and the connection is forwarded to our server. We will be
    naming this server bastion in this exercise.
  prefs: []
  type: TYPE_NORMAL
- en: With this in place, our common sense tells us that we will be able to reach
    that bastion host via SSH, even if we can use other tools or even `ssh` it to
    connect to other systems later.
  prefs: []
  type: TYPE_NORMAL
- en: Can we connect directly to other hosts in the internal network? The answer is
    YES, because, by default, SSH allows us to use TCP forwarding (`sshd_config` setting
    `AllowTcpForwarding`), which empowers us, as remote login users, to create port
    redirections and even a **SOCKS** proxy to be used for our connections.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can create a tunnel using that bastion host to reach our internal
    mail server via the **Internet Message Access Protocol** (**IMAP**) and **Simple
    Mail Transfer Protocol** (**SMTP**) protocols by just executing the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This command will listen on local ports `10993` and `10025`. All the connections
    that are performed there will be tunneled until `bastionhost` connects those to
    `imap.example.com` at port `993` and `smtp.example.com` at port `25`. This allows
    our local system to configure our email account using those custom ports and use
    `localhost` as the server, and still be able to reach those services.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Ports under `1024` are considered privileged ports and usually, only the root
    user can bind services to those ports. That's why we use them for our redirection
    ports, `10025` and `10093`, so that those can be used by a regular user instead
    of requiring the root user to perform the `ssh` connection. Pay attention to `ssh`
    messages when you're trying to bind to local ports in case those are in use, as
    the connections might fail.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, from the target server's point of view, the connections will appear
    as if they originated in the bastion server as it's the one effectively performing
    the connections.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the list of open ports starts to grow, it is better to go back to what
    we explained at the beginning of this chapter: the `~/.ssh/config` file can hold
    the host definition, along with the redirections we want to create, as shown in
    this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In this example, when we are connecting to our bastion host (via `ssh bastion`),
    we are automatically enabling `mybastion.example.com` at port `330`, and defining
    port forwarding for our `imap`, `smtp`, and `ldap` servers and one dynamic forward
    (SOCKS proxy) at port `9999`. If we have different identities (keypairs), we can
    also define the one we wish to use via the `IdentityFile` configuration directive
    for each host, or even use wildcards such as `Host *.example.com` to automatically
    apply those options to hosts ending in that domain that have no specific configuration
    stanza.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, while using `ssh`, `scp`, or `sftp`, the goal is to reach a system
    that is accessible from a bastion host. Other port forwarding is not needed here
    – only reaching those systems is required. In this case, you can use the handy
    `–J` command-line option (equivalent to defining a `ProxyJump` directive) to use
    that host as a jump host to the final target you want to reach. For example, `ssh
    –J bastion mywebsiteserver.example.com` will transparently connect to `bastion`
    and jump from there to `mywebsiteserver.example.com`.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will learn how to protect ourselves from network issues
    with our remote connections and get the most out of our remote terminal connection.
  prefs: []
  type: TYPE_NORMAL
- en: Remote terminals with tmux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`tmux` is a terminal multiplexer, which means that it allows us to open and
    access several terminals within a single screen. A good similitude would be a
    window manager in a graphical desktop, which allows us to open several windows
    so that we can switch context while using only one monitor.'
  prefs: []
  type: TYPE_NORMAL
- en: '`tmux` also allows us to detach and reattach to the sessions, so it''s the
    perfect tool in case our connection drops. Think, for example, about performing
    a software upgrade on a server. If, for whatever reason, the connection drops,
    it will be equivalent to abruptly stopping the upgrade process in whatever status
    it was at that moment, which can lead to bad consequences. However, if the upgrade
    was launched inside `tmux`, the command will continue executing, and once the
    connection is restored, the session can be reattached and the output will be available
    to be examined.'
  prefs: []
  type: TYPE_NORMAL
- en: First of all, let's install it on our system via `dnf –y install tmux`. This
    line will download the package and make the `tmux` command available. Bear in
    mind that the goal of `tmux` is not to install it on our system (even if this
    is useful), but for it to be available on the servers we connect to, to get that
    extra layer of protection in case a disconnection happens. So, it's a good habit
    to get used to installing it on all the servers we connect to.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: In versions prior to `RHEL8`, the tool that was used for creating virtual multiplexed
    terminals was `screen`, which has been marked as deprecated and is only available
    via `EPEL` repositories. If you were used to its key bindings (`CTRL-A + <key`>),
    most of them are equivalent in `tmux` via (`CTRL-B + <key>`).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following screenshot, we can see what `tmux` looks like with the default
    configuration after executing `tmux` on a command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.20 – tmux default layout after execution'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_08_020.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.20 – tmux default layout after execution
  prefs: []
  type: TYPE_NORMAL
- en: As shown in the preceding screenshot, it hasn't changed a lot of the view of
    our terminal except for the status bar in the lower part of the window. This shows
    some information about the host, such as its name, time, date, and the list of
    open windows, with `0:bash` being the active one, as denoted by the asterisk (`*`)
    symbol.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are lots of combinations for using `tmux`, so let''s get familiar with
    some of them that will cover the initial use case:'
  prefs: []
  type: TYPE_NORMAL
- en: Run `tmux` to create a new session.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run `tmux at` to attach to a previous session (for example, after reconnecting
    to a host).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run `tmux at –d` to attach to a previous session and detach other connections
    from it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once we''re inside `tmux`, there is a whole world of commands we can use that
    are preceded by the `CTRL+B` keys. Let''s view some important ones (remember that
    *Ctrl + B* must be pressed before you use the next item in the list):'
  prefs: []
  type: TYPE_NORMAL
- en: '`?`: Displays inline help about the shortcuts to use.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`c`: Creates a new window.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`n`/`p`: Go to the next/previous window.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`d`: Detaches the `tmux` session.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0-9`: Go to the window numbered with the pressed number.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`,`: Renames windows.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"`: Splits the pane horizontally.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%`: Splits the pane vertically.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`space`: Switches to the next layout.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`&`: Kills the window.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Pg down`/`pg up`: Go higher or lower in the window history.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Arrow keys: Select the pane in the direction of the pressed key.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s look at an example in action in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.21 – tmux with four panes running different commands inside the
    same window'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_08_021.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.21 – tmux with four panes running different commands inside the same
    window
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, there are several commands running at the same time – `top`,
    `journalctl –f`, `iostat –x`, and `ping` – so this is a good way to monitor a
    system while operations are being performed on it.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, one of the advantages is that `tmux` can be scripted, so if we
    are using one layout while administering systems, we can copy that script and
    execute it as soon as we connect to them so that we can enjoy the same layout
    and even the commands being executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the following code with extra comments and descriptions at [https://github.com/PacktPublishing/Red-Hat-Enterprise-Linux-8-Administration/blob/main/chapter-08-remote-systems-administration/term.sh](https://github.com/PacktPublishing/Red-Hat-Enterprise-Linux-8-Administration/blob/main/chapter-08-remote-systems-administration/term.sh)
    if you want to try it on your system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Once the session with `tmux` has been set, we can attach the session we've just
    created and configured by executing `tmux`, which will show a layout similar to
    the one shown in the preceding screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered SSH and how to use it to connect to remote systems,
    how to use keys to authenticate with or without a password, and how to take advantage
    of it for automation, transferring files, and even making services accessible
    or reachable via port redirection. With `tmux`, we learned how to make our administration
    sessions survive network interruptions and at the same time, show important information
    at a glance by automating the layouts for it.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll be digging into securing our system network via firewalld
    to only expose the services that are required for operation.
  prefs: []
  type: TYPE_NORMAL
