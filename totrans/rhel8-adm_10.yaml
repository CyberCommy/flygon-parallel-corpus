- en: '*Chapter 8*: Administering Systems Remotely'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第8章*：远程管理系统'
- en: When working with systems, once the server has been installed, and many times,
    even during the installation itself, administration can be performed remotely.
    Once a machine has been installed, the tasks that need to be performed during
    its life cycle are not that different to the ones that have already been performed.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理系统时，一旦安装了服务器，甚至在安装过程中，管理可以远程执行。一旦安装了一台机器，其生命周期中需要执行的任务与已经执行的任务并没有太大不同。
- en: In this chapter, we will cover, from a connection point of view, how to connect
    to remote systems, transfer files, and how to automate the connection so that
    it can be scripted and make it resilient if issues arise with the network link.
    Administration tasks that can be performed on the system are the same as the ones
    we described in previous chapters, such as installing software, configuring additional
    networking settings, and even managing users.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将从连接的角度讨论如何连接到远程系统，传输文件，以及如何自动化连接，使其可以被脚本化，并在网络链接出现问题时使其具有弹性。可以在系统上执行的管理任务与我们在前几章中描述的相同，例如安装软件，配置额外的网络设置，甚至管理用户。
- en: Since administering a system requires privileged credentials, we will focus
    on the available tools that are considered to be secure to perform such connections,
    as well as how to use them to encapsulate other traffic.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 由于管理系统需要特权凭据，我们将重点关注可被认为是安全的可用工具，以执行此类连接，以及如何使用它们来封装其他流量。
- en: 'We will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下主题：
- en: SSH and OpenSSH overview and base configuration
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SSH和OpenSSH概述和基本配置
- en: Accessing remote systems with SSH
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用SSH访问远程系统
- en: Key-based authentication with SSH
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用SSH进行基于密钥的身份验证
- en: Remote file management with SCP/rsync
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用SCP/rsync进行远程文件管理
- en: Advanced remote management – SSH tunnels and SSH redirections
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级远程管理 – SSH隧道和SSH重定向
- en: Remote terminals with tmux
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用tmux进行远程终端管理
- en: By covering these topics, we will be able to master remote system access and
    bring our administration skills to the next level.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 通过涵盖这些主题，我们将能够掌握远程系统访问，并将我们的管理技能提升到下一个水平。
- en: Let's start by talking about the SSH protocol and the OpenSSH client and server
    in the next section.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从下一节开始讨论SSH协议和OpenSSH客户端和服务器。
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can continue using the virtual machine that we created at the beginning
    of this book in [*Chapter 1*](B16799_01_Final_SK_ePub.xhtml#_idTextAnchor014),
    *Installing RHEL8*. Any additional packages that are required will be indicated
    in the text. Any additional files that are required for this chapter can be downloaded
    from [https://github.com/PacktPublishing/Red-Hat-Enterprise-Linux-8-Administration](https://github.com/PacktPublishing/Red-Hat-Enterprise-Linux-8-Administration).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以继续使用我们在本书开头创建的虚拟机，在[*第1章*](B16799_01_Final_SK_ePub.xhtml#_idTextAnchor014)
    *安装RHEL8*中。所需的任何额外软件包将在文本中指示。本章所需的任何额外文件可以从[https://github.com/PacktPublishing/Red-Hat-Enterprise-Linux-8-Administration](https://github.com/PacktPublishing/Red-Hat-Enterprise-Linux-8-Administration)下载。
- en: SSH and OpenSSH overview and base configuration
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SSH和OpenSSH概述和基本配置
- en: '**SSH** is an acronym for **Secure Shell Host**. It started to spread by replacing
    traditional telnet usage, which was a remote login protocol that used no encryption
    for connecting to hosts, so the credentials that were used for logging in were
    transmitted in plain text. This means that anyone who had a system between the
    user terminal and the remote server could intercept the username and password
    and use that information to connect to remote systems. This is similar to what
    happens when credentials are transmitted to a web server via HTTP and not HTTPS.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**SSH**是**Secure Shell Host**的缩写。它开始取代传统的telnet使用，telnet是一种远程登录协议，用于连接主机时不使用加密，因此用于登录的凭据以明文形式传输。这意味着在用户终端和远程服务器之间有系统的任何人都可以拦截用户名和密码，并使用该信息连接到远程系统。这类似于通过HTTP而不是HTTPS将凭据传输到Web服务器时发生的情况。'
- en: With SSH, a secure channel is created between the client and the target host,
    even if the connection is performed over untrusted or insecure networks. Here,
    the SSH channel that's created is secure and no information is leaked.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 使用SSH，即使在不受信任或不安全的网络上进行连接，也会在客户端和目标主机之间创建安全通道。在这里，创建的SSH通道是安全的，不会泄漏任何信息。
- en: OpenSSH provides both a server and a client (the `openssh-server` and `openssh-clients`
    packages in **Red Hat Enterprise Linux** (**RHEL**) that can be used to connect
    to and allow connections from remote hosts.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: OpenSSH提供了服务器和客户端（在**Red Hat Enterprise Linux** (**RHEL**)中的`openssh-server`和`openssh-clients`软件包），可用于连接到远程主机并允许远程主机连接。
- en: Tip
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Knowing everything is not possible, so it is really important for `rpm –ql package`
    to review the list of files provided by a package if you cannot remember which
    one to use.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 知道一切是不可能的，所以对于`rpm –ql package`来说，如果您记不住要使用哪个文件，审查软件包提供的文件列表非常重要。
- en: The default configuration for both the client and server allows connections,
    but there are many options that can be tuned.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，客户端和服务器都允许连接，但有许多可以调整的选项。
- en: OpenSSH server
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OpenSSH服务器
- en: OpenSSH is a free implementation based on the last free SSH version that was
    created by OpenBSD members and updated with all the relevant security and features.
    It has become a standard in many operating systems, both as a server and as a
    client, to make secure connections between them.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: OpenSSH是基于OpenBSD成员创建的最后一个免费SSH版本的免费实现，并更新了所有相关的安全和功能。它已成为许多操作系统的标准，既作为服务器又作为客户端，以在它们之间建立安全连接。
- en: 'The main configuration file for the OpenSSH server is located at `/etc/ssh/sshd_config`
    (and you can use `man sshd_config` to get detailed information about the different
    options). Some of the most used options are as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: OpenSSH服务器的主要配置文件位于`/etc/ssh/sshd_config`（您可以使用`man sshd_config`获取有关不同选项的详细信息）。一些最常用的选项如下：
- en: '`AcceptEnv`: Defines which environment variables that have been set by the
    client will be used on the remote host (for example, locale, terminal type, and
    so on).'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AllowGroups`: A list of groups a user should be a member of to get access
    to the system.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AllowTcpForwarding`: Allows us to forward ports using the SSH connection (we
    will discuss this later in this chapter, in the *SSH tunnels and SSH redirections*
    section).'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DisableForwarding`: This takes precedence over other forwarding options, making
    it easier to restrict the service.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AuthenticationMethods`: Defines which authentication methods can be used,
    such as disabling password-based access.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Banner`: Files to send to the connecting user before authentication is allowed.
    This defaults to no banner, which might also reveal who is running the service
    that might be providing too much data to possible attackers.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Ciphers`: A list of valid ciphers to use when you''re interacting with the
    server. You can use `+` or `–` to enable or disable them.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ListenAddress`: The hostname or address and port where the `sshd` daemon should
    be listening for incoming connections.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PasswordAuthentication`: This defaults to yes and can be disabled to block
    users from interactively connecting to the system unless a public/private keypair
    is used.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PermitEmptyPasswords`: Allows accounts with no password to access the system
    (the default is no).'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PermitRootLogin`: Defines how login works for the root user, for example,
    to avoid the root user from connecting remotely with a password.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Port`: Related to `ListenAddress`, this defaults to `22`. It''s the port number
    where the `sshd` daemon listens for incoming connections.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Subsystem`: Configures the command for the external subsystem. For example,
    it is used with `sftp` for file transfers.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`X11Forwarding`: This defines whether `X11` forwarding is permitted so that
    remote users can open graphical programs on their local display by tunneling the
    connection.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following screenshot shows the options that are installed by our system
    while we''re removing comments:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1 – Default values at installation time defined in /etc/ssh/sshd_config'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_08_001.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.1 – Default values at installation time defined in /etc/ssh/sshd_config
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: We'll check the client part of the configuration in the next section.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: OpenSSH client
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The client part of OpenSSH is configured system-wide via the `/etc/ssh/ssh_config`
    file and the files in the `/etc/ssh/ssh_config.d/` folder. They are also configured
    via each user `~/.ssh/config` file.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Usually, the system-wide file just contains some comments, not actual settings,
    so we will be focusing on the per-user configuration file and command-line parameters.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: 'One example entry in our `~/.ssh/config` file could be as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the previous example, we defined an entry named `jump` (that we can use with
    `ssh jump`) that will connect the `root` username to the `jump.example.com` host.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: This is a basic setting, but we're also defining that we'll be using a helper
    program in `ProxyCommand` that will make use of a proxy server on `squid.example.com`
    on port `3128` to connect to the `%h` host and `%p` port to reach our target system.
    Additionally, we're making use of `Compression` and using `ControlMaster` with
    additional `GSSAPI` authentication.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: One feature that has security implications is `StrictHostKeyChecking`. When
    we connect to a host for the first time, keys are exchanged between the client
    and the host, and the server identifies itself with the keys that are used. If
    they're accepted, they will be stored in the `.ssh/known_hosts` file at the user's
    home.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: If the remote host key is changed, a warning will be printed on the `ssh` client's
    terminal and the connection will be refused, but when we set `StrictHostKeyChecking`
    to `no`, we will accept any key that's sent by the server, which might be useful
    if we're using a test system that gets redeployed frequently (and thus, generating
    a new host key). It is not recommended to be used in general, since it protects
    us from a server being replaced and also someone impersonating the server we want
    to connect to with a server that, for example, logs usernames and passwords to
    access our system later.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will learn about accessing remote systems with `ssh`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: Accessing remote systems with SSH
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SSH, as we mentioned earlier in this chapter, is a protocol that's used to connect
    to remote systems. In general, the syntax, in its most basic form, is just executing
    `ssh host` within a terminal.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: The `ssh` client will then initiate a connection to the `ssh` server on the
    target host, using the username of the currently logged-in user by default, and
    will try to reach the remote server on port `22/tcp`, which is the default for
    the SSH service.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following screenshot, we can see the closest server to our `localhost`
    system, which means we will be connecting to our own server:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2 – Initiating a SSH connection to localhost'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_08_002.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.2 – Initiating a SSH connection to localhost
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding screenshot, we can see how the first interaction with the server
    prints the fingerprint of the server to authenticate it. This is what was discussed
    in the previous section; that is, `StrictHostKeyChecking`. Once accepted, if the
    host key changes, the connection will be denied until we manually remove the older
    key to confirm that we're aware of the server change.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add the key and try again, as shown in the following screenshot:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.3 – Initiating an SSH connection to localhost denied'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_08_003.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.3 – Initiating an SSH connection to localhost denied
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: On our second attempt, the connection failed, but let's examine the output;
    that is, `Permission denied (publickey,gssapi-keyex,gssapi-with-mic)`. What does
    it mean? If we pay attention, `password` isn't listed, which means that we cannot
    connect to this host via a password prompt (which comes from setting `PasswordAuthentication`
    to `no`, which we defined in the `/etc/ssh/sshd_config` file).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following screenshot, we can see that once we set `PasswordAuthentication`
    to `yes`, the system asks for the password, which is not echoed on screen. Once
    validated, we get a shell prompt so that we can start typing in commands:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.4 – SSH connection completed'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_08_004.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.4 – SSH connection completed
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: In general, password authentication can be a security risk as the keyboard might
    be intercepted, someone might be looking over your shoulder, a brute-force attack
    might be used against the accounts, and so on. Due to this, it's common practice
    to at least disable it for the `root` user, meaning that someone trying to log
    into the system should know the username and password for a user, and from there,
    use the system tools to become `root`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: Let's learn how to log into remote systems that have passwords disabled by using
    authentication keys.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: Key-based authentication with SSH
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One big advantage of SSH connections is that commands can be given to be executed
    on remote hosts, for example, to grab updated data that can be used for monitoring
    without requiring a specific agent on the host.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: Having to provide login details on each connection is not something that we
    could consider an improvement to the user experience, but SSH also allows us to
    create a keypair that can be used for authentication to remote systems so that
    no password or credential input is required.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: 'The keys contain two parts: one that is public and must be configured in each
    host we want to connect to, and one that is private and must be secured as it
    will be used to identify us while we''re trying to connect to remote hosts.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: It is not necessary to say that this entire process happens over the encrypted
    connection created by SSH. So, using SSH and compression will also make our connections
    faster versus other legacy methods such as telnet, which is unencrypted.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: First of all, let's create one keypair for authentication.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: 'It is recommended to have at least one keypair per user so that each user can
    have keys based on the roles when they''re connecting to servers. Even if the
    keys can be shared for users in a role, it''s better to have each user have its
    own set so that keys can be revoked individually. For example, we can keep several
    `ssh` keypairs to be used in different roles, such as personal systems, production
    systems, lab systems, and so on. Having to specify the keypair for connecting
    is also an extra security measure: we cannot connect to production systems unless
    we use the production keypair.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a keypair, we can use the `ssh-keygen` tool, which has several options
    for the key we are creating, as shown in the following screenshot:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.5 – ssh-keygen options'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_08_005.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.5 – ssh-keygen options
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: 'When no arguments are provided, by default, it will create a key for the current
    user and ask for a password for the key. When we use the defaults and provide
    no values, we get an output similar to the one shown in the following screenshot:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.6 – ssh-keygen execution creating an RSA keypair under ~/.ssh/{id_rsa,id_rsa.pub}'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_08_006.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.6 – ssh-keygen execution creating an RSA keypair under ~/.ssh/{id_rsa,id_rsa.pub}
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: From this point on, this system has created a keypair for the root user, and
    it has stored the two pieces of it in the same folder, which is `.ssh` by default.
    The public one contains the`.pub` suffix, while the other contains the private
    key.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: 'How do we use them? If we look inside the `.ssh` folder in our home directory,
    we can see several files: we have an `authorized_keys` file and a `known_hosts`
    file, in addition to the keypair we have just created. The `authorized_keys` file
    will contain one entry per line. This contains the public keys that can be used
    to log into this system for this user.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: The vast range of options that can be used with `authorized_keys` goes further
    than adding just regular keys – you can also define commands to execute, expiry
    times for keys, remote hosts that can be used to connect so that only those hosts
    will be able to use that key successfully, and many more. Again, `man sshd` is
    your friend, so check out the `AUTHORIZED_KEYS FILE FORMAT` section there to learn
    about more complex setups.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: To simplify how keys are set up on remote systems, we have the `ssh-copy-id`
    utility, which connects via `ssh` to the remote host. This will ask for the `ssh`
    password and install the available public keys on our system. However, this requires
    the system to have password authentication enabled.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: 'The alternate method consists of manually appending our public key to that
    file (`.ssh/autorized_keys`), as shown in the following screenshot:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.7 – ssh-copy-id failure and manual authorization of the private
    key'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_08_007.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.7 – ssh-copy-id failure and manual authorization of the private key
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: The first line has attempted to use `ssh-copy-id`, but since we had password
    authentication enabled, it tried to copy our public key and failed. Then, we appended
    the public key using `>>` to the `authorized_keys` file. Finally, we demonstrated
    how to connect to `localhost` with `ssh` and execute a command without a password.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: The permissions for the `.ssh` folder and the `authorized_keys` file must not
    be too wide open (for example, 777). If they are, the `ssh` daemon will reject
    them as someone could have appended new keys and tried to gain access without
    really being a legit user of the system.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`.ssh`文件夹和`authorized_keys`文件的权限不能太开放（例如，777）。如果是这样，`ssh`守护程序将拒绝它们，因为有人可能已经添加了新的密钥，并试图在没有真正成为系统合法用户的情况下获得访问权限。'
- en: 'What has just happened opens a new world of automation. Using the keys being
    exchanged between our system and the remote hosts, we can now connect remotely
    to them to run commands interactively or to script commands to be executed on
    remote hosts. We can check the results in our terminal. Let''s consider this simple
    script, for a system load average check, which is available at [https://github.com/PacktPublishing/Red-Hat-Enterprise-Linux-8-Administration/blob/main/chapter-08-remote-systems-administration/loadaverage-check.sh](https://github.com/PacktPublishing/Red-Hat-Enterprise-Linux-8-Administration/blob/main/chapter-08-remote-systems-administration/loadaverage-check.sh):'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 刚刚发生的事情打开了一个新的自动化世界。使用我们的系统和远程主机之间交换的密钥，我们现在可以远程连接到它们，以交互方式运行命令或对要在远程主机上执行的命令进行脚本化。我们可以在我们的终端中检查结果。让我们考虑这个简单的脚本，用于系统负载平均值检查，可以在[https://github.com/PacktPublishing/Red-Hat-Enterprise-Linux-8-Administration/blob/main/chapter-08-remote-systems-administration/loadaverage-check.sh](https://github.com/PacktPublishing/Red-Hat-Enterprise-Linux-8-Administration/blob/main/chapter-08-remote-systems-administration/loadaverage-check.sh)找到：
- en: '[PRE1]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In this example, we''re running a loop to connect to four systems and then
    outputting the name and the load average of that system, as shown in the following
    screenshot:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们正在运行一个循环来连接四个系统，然后输出该系统的名称和负载平均值，如下面的屏幕截图所示：
- en: '![Figure 8.8 – Password-less login to four hosts to check their load average'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.8-无密码登录到四个主机以检查其负载平均值'
- en: '](img/B16799_08_008.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16799_08_008.jpg)'
- en: Figure 8.8 – Password-less login to four hosts to check their load average
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.8-无密码登录到四个主机以检查其负载平均值
- en: As we can see, we quickly grabbed the information from four hosts over `ssh`.
    If you want to test this in your environment, you might want to put into practice
    what we learned about creating entries in the `/etc/hosts` file, which points
    to `127.0.0.1` for the host names we want to try, so that the connection goes
    to your own practice system, as we explained in [*Chapter 6*](B16799_06_Final_SK_ePub.xhtml#_idTextAnchor096),
    *Enabling Network Connectivity*.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，我们迅速从四个主机上获取了信息。如果您想在您的环境中测试这一点，您可能想要实践一下我们在[*第6章*](B16799_06_Final_SK_ePub.xhtml#_idTextAnchor096)中学到的关于在`/etc/hosts`文件中创建条目的内容，该文件指向我们想要尝试的主机名的`127.0.0.1`，以便连接到您自己的练习系统，正如我们在[*第6章*](B16799_06_Final_SK_ePub.xhtml#_idTextAnchor096)中解释的那样，*启用网络连接*。
- en: 'Now, think about the different options we have for administering our systems
    remotely:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，想想我们远程管理系统的不同选项：
- en: Check IPs for a range of hosts.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查一系列主机的IP。
- en: Install updates or add/remove one package.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装更新或添加/删除一个软件包。
- en: Check the local time in case the system has drifted.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查本地时间以防系统偏离。
- en: Restart one service after adding a new user to the system.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在向系统添加新用户后重新启动一个服务。
- en: Many more options exist, but these are the main ones.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 还有更多选项，但这些是主要选项。
- en: Of course, there are more suitable tools for remotely administering systems
    and ensuring that errors are detected and handled properly, such as using Ansible,
    but in this case, for simple tasks, we are good to go.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，还有更适合远程管理系统并确保错误被正确检测和处理的工具，比如使用Ansible，但在这种情况下，对于简单的任务，我们可以继续进行。
- en: Previously, we created a key and replied with `<ENTER>` when we were asked for
    a password. What if we had typed one in? We'll look at this in the next section.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，我们创建了一个密钥，并在要求输入密码时回复了`<ENTER>`。如果我们输入了密码会怎样？我们将在下一节中讨论这个问题。
- en: SSH agent
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SSH代理
- en: If we have decided to create an SSH key with a password to protect it (good
    choice), we will need to input the passphrase each time we want to use the key,
    so in the end, it might be as insecure as having to type in the password as someone
    might be checking over our shoulder. To overcome this, we can use a program called
    `ssh-agent` that temporarily keeps the passphrase in memory. This is convenient
    and reduces the chances of someone watching while you type in your key.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们决定创建一个带有密码保护的SSH密钥（明智的选择），我们将需要在每次使用密钥时输入密码，因此最终它可能与输入密码一样不安全，因为有人可能在我们的肩膀上观察。为了克服这一点，我们可以使用一个名为`ssh-agent`的程序，它可以临时将密码保留在内存中。这很方便，可以减少在输入密钥时有人观察的机会。
- en: When you're using a graphical desktop, such as `ssh-agent`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用图形桌面时，比如`ssh-agent`。
- en: 'When `ssh-agent` is executed, it will output some variables that must be set
    in our environment so that we can make use of it, as shown in the following screenshot:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行`ssh-agent`时，它将输出一些变量，必须在我们的环境中设置这些变量，以便我们可以利用它，如下面的屏幕截图所示：
- en: '![Figure 8.9 – ssh-agent being used to set the required variables'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.9-使用ssh-agent设置所需的变量'
- en: '](img/B16799_08_009.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16799_08_009.jpg)'
- en: Figure 8.9 – ssh-agent being used to set the required variables
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.9-使用ssh-agent设置所需的变量
- en: As shown in the preceding screenshot, before being executed, or just while we're
    executing the agent, the variables are undefined. However, if we were to execute
    `eval $(ssh-agent)`, we would accomplish the goal of having the variables defined
    and ready to use.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的屏幕截图所示，在被执行之前，或者在我们执行代理时，这些变量是未定义的。但是，如果我们执行`eval $(ssh-agent)`，我们将实现目标，即使这些变量被定义并准备好使用。
- en: The next step is to add the keys to the agent. This can be accomplished with
    the `ssh-add` command, which can be used without parameters or by specifying the
    key to be added. If the key requires a password, it will prompt you for it. Once
    we're done, we might be able to use that key to log into the systems with the
    passphrase that's being cached until we exit the session that executed the agent,
    thus clearing the passphrase from memory.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将密钥添加到代理。这可以通过`ssh-add`命令来完成，该命令可以在不带参数的情况下使用，也可以通过指定要添加的密钥来使用。如果密钥需要密码，它将提示您输入密码。完成后，我们可能能够使用该密钥以缓存的密码登录到系统，直到我们退出执行代理的会话，从而将密码从内存中清除。
- en: 'The following screenshot shows the command that was used to generate a new
    keypair with a password. Here, we can see that the only difference is that we''re
    storing it in a file named `withpass` versus what we did earlier in this chapter:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的屏幕截图显示了用于生成带密码的新密钥对的命令。在这里，我们可以看到唯一的区别是我们将其存储在名为`withpass`的文件中，而不是我们在本章早些时候所做的：
- en: '![Figure 8.10 – Creating an additional ssh keypair with a password'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.10 - 使用密码创建额外的ssh密钥对'
- en: '](img/B16799_08_010.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16799_08_010.jpg)'
- en: Figure 8.10 – Creating an additional ssh keypair with a password
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.10 - 使用密码创建额外的ssh密钥对
- en: 'We can see how to connect to our localhost (which we added the key for with
    the password public part of our `.ssh/authorized_keys` while removing the one
    without a password) and how the connection behaves in the following screenshot:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到如何连接到我们的本地主机（我们已经为其添加了带密码的公共部分到我们的`.ssh/authorized_keys`，同时删除了没有密码的部分），以及连接在下面的屏幕截图中的行为：
- en: '![Figure 8.11 – Using ssh-agent to remember our passphrase'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.11 - 使用ssh-agent记住我们的密码'
- en: '](img/B16799_08_011.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16799_08_011.jpg)'
- en: Figure 8.11 – Using ssh-agent to remember our passphrase
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.11 - 使用ssh-agent记住我们的密码
- en: 'To make this clearer, let''s analyze what''s happening:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更清楚地说明这一点，让我们分析一下正在发生的事情：
- en: First, we `ssh` to the host. Permission is denied as the default key we used
    was removed from `authorized_keys`.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们`ssh`到主机。由于我们使用的默认密钥已从`authorized_keys`中删除，因此权限被拒绝。
- en: We `ssh` again but while defining the identity file (the keypair) to connect
    to, as we can see, we're asked for the passphrase for the key, not for logging
    into the system.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们再次`ssh`，但在定义身份文件（密钥对）以连接时，我们可以看到，我们被要求输入密钥的密码，而不是登录到系统。
- en: Then, we log out and the connection is closed.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们注销并关闭连接。
- en: Next, we try to add the key, and we get an error because we have not set the
    environment variables for the agent.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们尝试添加密钥，但由于我们尚未为代理设置环境变量，因此出现错误。
- en: As instructed when we introduced the agent, we execute the command for loading
    the environment variables for the agent in the current shell.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照我们介绍代理时的指示，我们在当前shell中执行加载代理环境变量的命令。
- en: When we retry adding the key with `ssh-add withpass`, the agent asks for our
    passphrase.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们尝试使用`ssh-add withpass`添加密钥时，代理会要求输入我们的密码。
- en: When we finally `ssh` to the host, we can connect without a password as the
    key is in memory for our keypair.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们最终`ssh`到主机时，我们可以连接而无需密码，因为密钥已经在我们的密钥对的内存中。
- en: 'Here, we have achieved two things: we now have an automated/disattended method
    to connect to systems and have ensured that only authorized users will know the
    passphrase to unlock them.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们已经实现了两件事：我们现在有了一个自动化/无人参与的连接系统的方法，并确保只有授权用户才能知道解锁它们的密码。
- en: We'll learn how to do remote file management in the next section!
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节学习如何进行远程文件管理！
- en: SCP/rsync – remote file management
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SCP/rsync - 远程文件管理
- en: Similar to `telnet`, which was replaced with `ssh` on many devices and systems,
    using insecure solutions for file transfer is being reduced. By default, the `21`,
    but since communication happened in plain text, it was a perfect target for intercepting
    credentials. FTP is still used today, mostly for serving file on servers that
    only allow anonymous access and wish to move to more secure options.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 与`telnet`类似，许多设备和系统上已经用`ssh`替换了它，使用不安全的文件传输解决方案正在减少。默认情况下是`21`，但由于通信是明文的，因此很容易被拦截凭据。FTP仍然被广泛使用，主要用于在只允许匿名访问并希望转移到更安全选项的服务器上提供文件。
- en: 'SSH usually enables two interfaces for copying files: `scp` and `sftp`. The
    first one is used in a similar way to the regular `cp` command, but here, we''re
    accepting remote hosts as our target or source, while `sftp` uses a client approach
    similar to the traditional `ftp` command that interacts with FTP servers. Just
    remember that in both cases, the connection is encrypted and happens over port
    `22/tcp` on the target host.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: SSH通常启用两个接口来复制文件：`scp`和`sftp`。第一个用法类似于常规的`cp`命令，但在这里，我们接受远程主机作为我们的目标或源，而`sftp`使用了类似于与FTP服务器交互的传统`ftp`命令的客户端方法。只需记住，在这两种情况下，连接都是加密的，并且在目标主机上通过`22/tcp`端口进行。
- en: We'll dig into SCP in the next section.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节深入研究SCP。
- en: Transferring files with an OpenSSH secure file copy
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用OpenSSH安全文件传输传输文件
- en: The `scp` command, which is part of the `openssh-clients` package, allows us
    to copy files between systems using the `ssh` layer for the whole process. This
    allows us to securely transfer a file's contents, plus all the automation capabilities
    that were introduced by keypair login, to various systems.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`scp`命令是`openssh-clients`软件包的一部分，允许我们使用整个过程的`ssh`层在系统之间复制文件。这使我们能够安全地传输文件内容，以及通过密钥对登录引入的所有自动化功能，到各种系统。'
- en: 'To set up this example, we will create a new user in our sample system that
    will be used to copy over files using the tools described in this section, as
    shown in the following screenshot:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设置这个例子，我们将在我们的示例系统中创建一个新用户，该用户将用于使用本节描述的工具复制文件，如下面的屏幕截图所示：
- en: '![Figure 8.12 – Preparing our system with an additional user to practice file
    transfers'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.12 - 准备我们的系统，添加额外用户以练习文件传输'
- en: '](img/B16799_08_012.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16799_08_012.jpg)'
- en: Figure 8.12 – Preparing our system with an additional user to practice file
    transfers
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.12 - 准备我们的系统，添加额外用户以练习文件传输
- en: You can find the preceding commands in a script available at [https://github.com/PacktPublishing/Red-Hat-Enterprise-Linux-8-Administration/blob/main/chapter-08-remote-systems-administration/create-kys-user.sh](https://github.com/PacktPublishing/Red-Hat-Enterprise-Linux-8-Administration/blob/main/chapter-08-remote-systems-administration/create-kys-user.sh).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://github.com/PacktPublishing/Red-Hat-Enterprise-Linux-8-Administration/blob/main/chapter-08-remote-systems-administration/create-kys-user.sh](https://github.com/PacktPublishing/Red-Hat-Enterprise-Linux-8-Administration/blob/main/chapter-08-remote-systems-administration/create-kys-user.sh)中找到前面的命令的脚本。
- en: Once the user has been created and the key has been copied, we can start testing!
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦用户已创建并且密钥已复制，我们就可以开始测试了！
- en: 'Earlier in this chapter, we created a key named `withpass` with a public counterpart
    at `withpass.pub`. To provide the key to the newly created user, we can copy both
    files to the `kys` user via the following command:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的前面，我们创建了一个名为`withpass`的密钥，其公共对应物为`withpass.pub`。为了将密钥提供给新创建的用户，我们可以通过以下命令将两个文件都复制到`kys`用户：
- en: '[PRE2]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let''s analyze each part of the command using this template:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用这个模板来分析命令的每个部分：
- en: '[PRE3]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In our case, `origin` is indicated with `withpass.*`, which means that it will
    select all the files starting with the `withpass` string.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，`origin`用`withpass.*`表示，这意味着它将选择以`withpass`字符串开头的所有文件。
- en: Our `target` value is a remote host. Here, the username is `kys`, the host is
    `localhost`, and the folder you should store the files in is the default one,
    usually the home folder of the user indicated (the one with an empty path after
    the`:` symbol).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`target`值是一个远程主机。在这里，用户名是`kys`，主机是`localhost`，应该存储文件的文件夹是默认文件夹，通常是指定用户的主文件夹（在`:`符号后的空路径的用户）。
- en: 'In the following screenshot, we can see the output of the command and the validation
    we can perform later via remote execution:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的截图中，我们可以看到命令的输出以及我们稍后可以通过远程执行进行的验证：
- en: '![Figure 8.13 – Copying SCP files to a remote path and validating the files
    that have been copied'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.13 - 将SCP文件复制到远程路径并验证已复制的文件'
- en: '](img/B16799_08_013.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16799_08_013.jpg)'
- en: Figure 8.13 – Copying SCP files to a remote path and validating the files that
    have been copied
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.13 - 将SCP文件复制到远程路径并验证已复制的文件
- en: In the preceding screenshot, you can also check that the files that were owned
    by the root user are copied. The copied ones are owned by the `kys` user, so the
    file's contents are the same, but since the creator on the target is the `kys`
    user, files have their ownership.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中，您还可以检查由root用户拥有的文件是否已复制。复制的文件由`kys`用户拥有，因此文件内容相同，但由于目标上的创建者是`kys`用户，文件具有其所有权。
- en: We can also make more complex copies by indicating remote files first and local
    paths as targets so that we download files to our system, or even copy files across
    remote locations for both the origin and target (unless we specify the`–3` option,
    they will go directly from `origin` to `target`).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过首先指定远程文件然后将本地路径作为目标来进行更复杂的复制，以便将文件下载到我们的系统，或者甚至在远程位置之间复制文件（除非我们指定`-3`选项，否则它们将直接从`origin`到`target`）。
- en: Tip
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Time for a reminder! `man scp` will show you all the available options for the
    `scp` command, but since it is based on `ssh`, most of the options we use with
    `ssh` are available, as well as the host definitions we made in the `.ssh/config`
    file.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 提醒时间！`man scp`将向您显示`scp`命令的所有可用选项，但由于它基于`ssh`，我们使用`ssh`的大多数选项也可用，以及我们在`.ssh/config`文件中定义的主机定义。
- en: We'll explore the `sftp` client in the next section.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节中探索`sftp`客户端。
- en: Transferring files with sftp
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用sftp传输文件
- en: Compared to `scp`, which can be scripted in the same way we can script with
    the regular `cp` command, `sftp` has an interactive client for navigating a remote
    system. However, it can also automatically retrieve files when a path containing
    files is specified.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 与`scp`相比，可以像使用常规`cp`命令一样编写脚本，`sftp`具有用于浏览远程系统的交互式客户端。但是，当指定包含文件的路径时，它也可以自动检索文件。
- en: 'To learn about the different commands that are available, you can invoke the
    `help` command, which will list the available options, as shown in the following
    screenshot:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解可用的不同命令，可以调用`help`命令，它将列出可用的选项，如下面的截图所示：
- en: '![Figure 8.14 – Available sftp interactive mode commands'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.14 - 可用的sftp交互模式命令'
- en: '](img/B16799_08_014.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16799_08_014.jpg)'
- en: Figure 8.14 – Available sftp interactive mode commands
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.14 - 可用的sftp交互模式命令
- en: 'Let''s look at an example of this with the help of the following screenshot:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下截图来看一个例子：
- en: '![Figure 8.15 – Both modes of operation with sftp – automated transfer or interactive
    transfer'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.15 - sftp的两种操作模式 - 自动传输或交互传输'
- en: '](img/B16799_08_015.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16799_08_015.jpg)'
- en: Figure 8.15 – Both modes of operation with sftp – automated transfer or interactive
    transfer
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.15 - sftp的两种操作模式 - 自动传输或交互传输
- en: In this example, we've created a local folder to be our work folder, called
    `getfilesback`. First, we have invoked `sftp` with a remote path with the files
    we've identified. Here, `sftp` has automatically transferred the files and has
    stopped executing. The files we have received are now the property of our user.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个本地文件夹作为我们的工作文件夹，名为`getfilesback`。首先，我们使用远程路径和我们识别的文件调用了`sftp`。在这里，`sftp`已自动传输了文件并停止执行。我们收到的文件现在属于我们的用户。
- en: In the second command, when we invoke `sftp` with the user and host and we enter
    interactive mode, we can execute several commands, similar to what we can do on
    a remote shell session. Finally, using the `mget` command with the `*` wildcard
    character, we transferred the files to our local system.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个命令中，当我们使用用户和主机调用`sftp`并进入交互模式时，我们可以执行多个命令，类似于在远程shell会话上可以执行的操作。最后，使用带有`*`通配符字符的`mget`命令，我们将文件传输到我们的本地系统。
- en: In both cases, the files have been transferred from the remote system to our
    local system, so our goal has been accomplished. However, using `scp` requires
    knowing the exact path of the files you want to transfer. On the other hand, it
    might be a bit more user-friendly to navigate the system using the `ls` and `cd`
    commands within the `sftp` interactive client until we reach the files we want
    to transfer if we can't remember it.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's learn how to quickly transfers files and trees with `rsync`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Transferring files with rsync
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although we can use the `–r` option of `scp` to transfer files recursively,
    `scp` only handles the full copy of the file, which is not ideal if we are just
    keeping some folders in sync across systems.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: In 1996, `rsync` was launched, and many systems implemented it by using a dedicated
    server that was listening to client connections. This was to allow trees to be
    synchronized with files. This was done by copying over the differences between
    the files. Here, parts of the source and destination were compared to see whether
    there were differences that should be copied over.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: With `ssh`, and with the `rsync` package installed on both the client and the
    server, we can take advantage of the secure channel that's created by `ssh` and
    the faster synchronization provided by `rsync`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: The difference between using the `rsync` daemon and using `ssh` is the syntax
    for the source or destination, which either uses the `rsync://` protocol or `::`
    after the hostname. In other cases, it will use `ssh` or even the local filesystem.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows us mentioning the schema for URLs via the `rsync
    –help` command:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.16 – The rsync command''s help output'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_08_016.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.16 – The rsync command's help output
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s review some of the useful options we can use with `rsync`:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '`-v` : Provides more verbose output during the transfer.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-r`: Recurses into directories.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-u`: Update – only copies files that are newer than the ones at the target.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-a`: Archive (this includes several options, such as `–rlptgoD`).'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-X`: Preserves extended attributes.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-A`: Preserves ACLs.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-S`: Sparse – sequences of nulls will be converted into sparse blocks.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--preallocate`: Claims the space that''s required for files before transferring
    them.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--delete-during`: Deletes files on the target that are not hosted during the
    copy.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--delete-before`: Deletes files on the target that are not hosted before the
    copy.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--progress`: Shows progress information on the copy (copied files versus total
    files).'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `r``sync` algorithm breaks the file into chunks and calculates checksums
    for each chunk that's transmitted to source. They are then compared to the ones
    for local files. We are only allowed to share the differences between the source
    and the target. `rsync` doesn't check the modification file date and size by default,
    so if the file has changed without changes being left in both, the change might
    not be detected unless a checksum check is forced for each file candidate to be
    transferred.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at some basic examples:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '`rsync –avr getfilesback/ newfolder/` will copy the files in the local `getfilesback/`
    folder to `newfolder/` by showing a progress update, but only for the updated
    files, as shown in the following screenshot:'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 8.17 – The rsync operation being used on the same source/destination,'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: repeated to illustrate transfer optimization
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_08_017.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.17 – The rsync operation being used on the same source/destination,
    repeated to illustrate transfer optimization
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, the second operation just sent 85 bytes and received 12 bytes.
    This is because there was a little checksum operation happening internally to
    validate across the folders because the files hadn't been changed. The same output
    can be obtained if we use the remote target approach with `rsync -avr --progress
    getfilesback/ root@localhost:newfolder/`, but in this case, `ssh` transport will
    be used.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: Let's get some bigger sample files and compare them by checking out a Git repository
    at some point in time, transferring the files, then updating to the latest version
    to simulate work on the repository. Then, we will synchronize again.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们获取一些更大的示例文件，并通过在某个时间点检出Git存储库，传输文件，然后更新到最新版本来比较它们，以模拟对存储库的工作。然后，我们将再次进行同步。
- en: 'First, let''s install `git` if it''s not installed and check out a sample repository
    by executing the following code:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，如果尚未安装，请安装`git`并执行以下代码检出一个示例存储库：
- en: '[PRE4]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: At this point, we have a folder with files ready for transfer. Once we've done
    this, we'll execute `git pull` to sync with the latest changes and use `rsync`
    again to copy the differences. Later, we'll use `--delete` to remove any files
    that no longer exist on the source.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们有一个准备好进行传输的文件夹。完成后，我们将执行`git pull`以与最新更改同步，并再次使用`rsync`复制差异。稍后，我们将使用`--delete`删除源上不再存在的任何文件。
- en: 'Let''s check out the sequence shown in the following screenshot:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们查看以下截图中显示的顺序：
- en: '![Figure 8.18 – Synchronizing the git folder to a new folder with rsync'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.18 - 使用rsync将git文件夹同步到新文件夹'
- en: '](img/B16799_08_018.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16799_08_018.jpg)'
- en: Figure 8.18 – Synchronizing the git folder to a new folder with rsync
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.18 - 使用rsync将git文件夹同步到新文件夹
- en: In the preceding screenshot, pay attention to the speedup that's reported in
    the latest line of the command.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中，注意命令的最后一行报告的加速情况。
- en: 'Now, let''s execute `git pull` to get the 400 changes we were missing and repeat
    `rsync` again. We will get an output similar to the following:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们执行`git pull`以获取我们缺少的400个更改，并再次执行`rsync`。我们将得到类似以下的输出：
- en: '![Figure 8.19 – Using rsync again to copy over the differences'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.19 - 再次使用rsync复制差异'
- en: '](img/B16799_08_019.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16799_08_019.jpg)'
- en: Figure 8.19 – Using rsync again to copy over the differences
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.19 - 再次使用rsync复制差异
- en: In the preceding screenshot, pay attention to the speedup reported in the last
    line so that you can compare it with the previous one.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中，注意最后一行报告的加速情况，以便与之前的进行比较。
- en: From this sequence of screenshots, we can check the last numbers for the total
    bytes that were sent to see the improvement in transfer, along with some of the
    files that were received (because we added the `–v` modifier to get verbose output
    and `--progress`).
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这一系列截图，我们可以检查发送的总字节数的最后数字，以查看传输的改进，以及一些已接收的文件（因为我们添加了`-v`修饰符以获取详细输出和`--progress`）。
- en: The biggest advantage comes when a copy is performed over slower network links
    and it's performed periodically, for example, as a way to copy to an offsite copy
    for backup purposes. This is because `rsync` will only copy the changes, update
    the newer files that have been modified on the source, and allow us to use compression
    over the `ssh` channel. For example, the Linux kernel at [https://www.kernel.org/](https://www.kernel.org/)
    can be mirrored using `rsync`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 最大的优势在于在较慢的网络链接上执行复制，并且定期执行，例如，作为备份目的的远程复制。这是因为`rsync`只会复制更改，更新源上已修改的更新文件，并允许我们在`ssh`通道上使用压缩。例如，可以使用`rsync`镜像[https://www.kernel.org/](https://www.kernel.org/)上的Linux内核。
- en: In the next section, we will dig into a very interesting feature of SSH to make
    connecting to servers with no direct access easy.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我们将深入探讨SSH的一个非常有趣的功能，使得连接到没有直接访问权限的服务器变得容易。
- en: Advanced remote management – SSH tunnels and SSH redirections
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级远程管理 - SSH隧道和SSH重定向
- en: SSH has two really powerful features; that is, SSH tunnels and SSH redirections.
    When an SSH connection is established, it can not only be used to send commands
    to the remote host and let us work on them as if they were our local system, but
    we can also create tunnels that interconnect our systems.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: SSH有两个非常强大的功能，即SSH隧道和SSH重定向。当建立SSH连接时，不仅可以用来向远程主机发送命令并让我们像在本地系统上一样工作，还可以创建相互连接我们系统的隧道。
- en: Let's try to imagine a scenario that is common in many companies, where a VPN
    is used to reach the internal network with all the services and servers, but with
    SSH instead of a regular VPN.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试想象一个在许多公司中很常见的场景，即使用VPN来访问内部网络和所有服务和服务器，但使用SSH而不是常规VPN。
- en: So, let's put some context into this imaginary scenario.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们在这个想象的场景中加入一些背景。
- en: We can use a host that gets external traffic for `ssh` redirected from our internet
    router to the `ssh` service in that system. So, in brief, our router gets connections
    on port `22` via TCP and the connection is forwarded to our server. We will be
    naming this server bastion in this exercise.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用一个接收外部流量的主机，将来自我们的互联网路由器的`ssh`重定向到该系统中的`ssh`服务。因此，简而言之，我们的路由器通过TCP在端口`22`上接收连接，并将连接转发到我们的服务器。在本练习中，我们将为这个服务器命名为堡垒。
- en: With this in place, our common sense tells us that we will be able to reach
    that bastion host via SSH, even if we can use other tools or even `ssh` it to
    connect to other systems later.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们的常识告诉我们，即使我们可以使用其他工具或甚至`ssh`连接到其他系统，我们也可以通过SSH到达那个堡垒主机。
- en: Can we connect directly to other hosts in the internal network? The answer is
    YES, because, by default, SSH allows us to use TCP forwarding (`sshd_config` setting
    `AllowTcpForwarding`), which empowers us, as remote login users, to create port
    redirections and even a **SOCKS** proxy to be used for our connections.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能直接连接到内部网络中的其他主机吗？答案是肯定的，因为默认情况下，SSH允许我们使用TCP转发（`sshd_config`设置`AllowTcpForwarding`），这使我们作为远程登录用户能够创建端口重定向，甚至是用于我们的连接的**SOCKS**代理。
- en: 'For example, we can create a tunnel using that bastion host to reach our internal
    mail server via the **Internet Message Access Protocol** (**IMAP**) and **Simple
    Mail Transfer Protocol** (**SMTP**) protocols by just executing the following
    code:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以使用那个堡垒主机创建一个隧道，通过**Internet Message Access Protocol**（**IMAP**）和**Simple
    Mail Transfer Protocol**（**SMTP**）协议到达我们的内部邮件服务器，只需执行以下代码：
- en: '[PRE5]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This command will listen on local ports `10993` and `10025`. All the connections
    that are performed there will be tunneled until `bastionhost` connects those to
    `imap.example.com` at port `993` and `smtp.example.com` at port `25`. This allows
    our local system to configure our email account using those custom ports and use
    `localhost` as the server, and still be able to reach those services.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令将监听本地端口`10993`和`10025`。所有在那里执行的连接将被隧道传输，直到`bastionhost`将它们连接到端口`993`的`imap.example.com`和端口`25`的`smtp.example.com`。这允许我们的本地系统使用这些自定义端口配置我们的电子邮件帐户，并使用`localhost`作为服务器，仍然能够访问这些服务。
- en: Tip
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Ports under `1024` are considered privileged ports and usually, only the root
    user can bind services to those ports. That's why we use them for our redirection
    ports, `10025` and `10093`, so that those can be used by a regular user instead
    of requiring the root user to perform the `ssh` connection. Pay attention to `ssh`
    messages when you're trying to bind to local ports in case those are in use, as
    the connections might fail.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`1024`以下的端口被视为特权端口，通常只有root用户才能将服务绑定到这些端口。这就是为什么我们将它们用于我们的重定向端口`10025`和`10093`，这样普通用户就可以使用它们，而不需要root用户执行`ssh`连接。当您尝试绑定到本地端口时，请注意`ssh`消息，以防这些端口正在使用中，因为连接可能会失败。'
- en: Additionally, from the target server's point of view, the connections will appear
    as if they originated in the bastion server as it's the one effectively performing
    the connections.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，从目标服务器的角度来看，连接将看起来好像是从堡垒服务器发起的，因为它实际上是执行连接的服务器。
- en: 'When the list of open ports starts to grow, it is better to go back to what
    we explained at the beginning of this chapter: the `~/.ssh/config` file can hold
    the host definition, along with the redirections we want to create, as shown in
    this example:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 当打开端口列表开始增长时，最好回到本章开头所解释的内容：`~/.ssh/config`文件可以保存主机定义，以及我们想要创建的重定向，就像这个例子中所示的那样。
- en: '[PRE6]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this example, when we are connecting to our bastion host (via `ssh bastion`),
    we are automatically enabling `mybastion.example.com` at port `330`, and defining
    port forwarding for our `imap`, `smtp`, and `ldap` servers and one dynamic forward
    (SOCKS proxy) at port `9999`. If we have different identities (keypairs), we can
    also define the one we wish to use via the `IdentityFile` configuration directive
    for each host, or even use wildcards such as `Host *.example.com` to automatically
    apply those options to hosts ending in that domain that have no specific configuration
    stanza.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，当我们连接到我们的堡垒主机（通过`ssh bastion`）时，我们会自动启用`mybastion.example.com`的`330`端口，并为我们的`imap`，`smtp`和`ldap`服务器以及`9999`端口的动态转发（SOCKS代理）定义端口转发。如果我们有不同的身份（密钥对），我们还可以通过`IdentityFile`配置指令为每个主机定义我们希望使用的身份，甚至可以使用通配符，如`Host
    *.example.com`，自动将这些选项应用于以该域结尾且没有特定配置段的主机。
- en: Note
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Sometimes, while using `ssh`, `scp`, or `sftp`, the goal is to reach a system
    that is accessible from a bastion host. Other port forwarding is not needed here
    – only reaching those systems is required. In this case, you can use the handy
    `–J` command-line option (equivalent to defining a `ProxyJump` directive) to use
    that host as a jump host to the final target you want to reach. For example, `ssh
    –J bastion mywebsiteserver.example.com` will transparently connect to `bastion`
    and jump from there to `mywebsiteserver.example.com`.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，在使用`ssh`，`scp`或`sftp`时，目标是要到达一个可以从堡垒主机访问的系统。这里不需要其他端口转发 - 只需要到达这些系统。在这种情况下，您可以使用方便的`-J`命令行选项（相当于定义`ProxyJump`指令）将该主机用作跳转主机，以便到达您想要到达的最终目标。例如，`ssh
    -J bastion mywebsiteserver.example.com`将透明地连接到`bastion`，然后从那里跳转到`mywebsiteserver.example.com`。
- en: In the next section, we will learn how to protect ourselves from network issues
    with our remote connections and get the most out of our remote terminal connection.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何保护自己免受远程连接的网络问题，并充分利用我们的远程终端连接。
- en: Remote terminals with tmux
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用tmux的远程终端
- en: '`tmux` is a terminal multiplexer, which means that it allows us to open and
    access several terminals within a single screen. A good similitude would be a
    window manager in a graphical desktop, which allows us to open several windows
    so that we can switch context while using only one monitor.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`tmux`是一个终端复用器，这意味着它允许我们在单个屏幕内打开和访问多个终端。一个很好的类比是图形桌面中的窗口管理器，它允许我们打开多个窗口，这样我们就可以在只使用一个监视器的情况下切换上下文。'
- en: '`tmux` also allows us to detach and reattach to the sessions, so it''s the
    perfect tool in case our connection drops. Think, for example, about performing
    a software upgrade on a server. If, for whatever reason, the connection drops,
    it will be equivalent to abruptly stopping the upgrade process in whatever status
    it was at that moment, which can lead to bad consequences. However, if the upgrade
    was launched inside `tmux`, the command will continue executing, and once the
    connection is restored, the session can be reattached and the output will be available
    to be examined.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`tmux`还允许我们分离和重新连接会话，因此在连接中断的情况下，它是完美的工具。例如，想象一下在服务器上执行软件升级。如果由于某种原因连接中断，那么相当于突然停止了升级过程，无论它当时处于什么状态，都可能导致不良后果。但是，如果升级是在`tmux`中启动的，命令将继续执行，一旦连接恢复，会话可以重新连接，并且输出将可供检查。'
- en: First of all, let's install it on our system via `dnf –y install tmux`. This
    line will download the package and make the `tmux` command available. Bear in
    mind that the goal of `tmux` is not to install it on our system (even if this
    is useful), but for it to be available on the servers we connect to, to get that
    extra layer of protection in case a disconnection happens. So, it's a good habit
    to get used to installing it on all the servers we connect to.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们通过`dnf -y install tmux`在我们的系统上安装它。这行将下载软件包并使`tmux`命令可用。请记住，`tmux`的目标不是在我们的系统上安装它（即使这很有用），而是让它在我们连接的服务器上可用，以便在发生断开连接时获得额外的保护层。因此，习惯于在我们连接的所有服务器上安装它是一个好习惯。
- en: Tip
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: In versions prior to `RHEL8`, the tool that was used for creating virtual multiplexed
    terminals was `screen`, which has been marked as deprecated and is only available
    via `EPEL` repositories. If you were used to its key bindings (`CTRL-A + <key`>),
    most of them are equivalent in `tmux` via (`CTRL-B + <key>`).
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在`RHEL8`之前的版本中，用于创建虚拟多路复用终端的工具是`screen`，它已被标记为不推荐使用，并且只能通过`EPEL`存储库获得。如果您习惯于它的键绑定（`CTRL-A
    + <key`>），那么在`tmux`中大多数都是等效的（`CTRL-B + <key>`）。
- en: 'In the following screenshot, we can see what `tmux` looks like with the default
    configuration after executing `tmux` on a command line:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的截图中，我们可以看到在命令行上执行`tmux`后`tmux`的默认配置是什么样子的：
- en: '![Figure 8.20 – tmux default layout after execution'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.20 – 执行后的tmux默认布局'
- en: '](img/B16799_08_020.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16799_08_020.jpg)'
- en: Figure 8.20 – tmux default layout after execution
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.20 – 执行后的tmux默认布局
- en: As shown in the preceding screenshot, it hasn't changed a lot of the view of
    our terminal except for the status bar in the lower part of the window. This shows
    some information about the host, such as its name, time, date, and the list of
    open windows, with `0:bash` being the active one, as denoted by the asterisk (`*`)
    symbol.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的截图所示，我们的终端的视图并没有改变太多，除了窗口下部的状态栏。这显示了有关主机的一些信息，例如其名称，时间，日期以及打开窗口的列表，其中`0:bash`是活动窗口，如星号（`*`）符号所示。
- en: 'There are lots of combinations for using `tmux`, so let''s get familiar with
    some of them that will cover the initial use case:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多组合可以使用`tmux`，让我们熟悉一些最初的用例：
- en: Run `tmux` to create a new session.
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行`tmux`以创建一个新会话。
- en: Run `tmux at` to attach to a previous session (for example, after reconnecting
    to a host).
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行`tmux at`以附加到先前的会话（例如，在重新连接到主机后）。
- en: Run `tmux at –d` to attach to a previous session and detach other connections
    from it.
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行`tmux at –d`以附加到先前的会话并从中分离其他连接。
- en: 'Once we''re inside `tmux`, there is a whole world of commands we can use that
    are preceded by the `CTRL+B` keys. Let''s view some important ones (remember that
    *Ctrl + B* must be pressed before you use the next item in the list):'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们进入`tmux`，就有一整套命令可以使用，这些命令都是以`CTRL+B`键为前缀的。让我们查看一些重要的命令（请记住在使用列表中的下一个项目之前必须先按下*Ctrl
    + B*）：
- en: '`?`: Displays inline help about the shortcuts to use.'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`?`：显示有关要使用的快捷键的内联帮助。'
- en: '`c`: Creates a new window.'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`c`：创建一个新窗口。'
- en: '`n`/`p`: Go to the next/previous window.'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`n`/`p`：转到下一个/上一个窗口。'
- en: '`d`: Detaches the `tmux` session.'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`d`：分离`tmux`会话。'
- en: '`0-9`: Go to the window numbered with the pressed number.'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0-9`：转到按下数字编号的窗口。'
- en: '`,`: Renames windows.'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`,`：重命名窗口。'
- en: '`"`: Splits the pane horizontally.'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"`：水平分割窗格。'
- en: '`%`: Splits the pane vertically.'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`%`：垂直分割窗格。'
- en: '`space`: Switches to the next layout.'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`space`：切换到下一个布局。'
- en: '`&`: Kills the window.'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`&`：关闭窗口。'
- en: '`Pg down`/`pg up`: Go higher or lower in the window history.'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Pg down`/`pg up`：在窗口历史记录中向上或向下移动。'
- en: 'Arrow keys: Select the pane in the direction of the pressed key.'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 箭头键：选择按下的方向中的窗格。
- en: 'Let''s look at an example in action in the following screenshot:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下面的截图中看一个示例：
- en: '![Figure 8.21 – tmux with four panes running different commands inside the
    same window'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.21 – tmux中有四个窗格，在同一个窗口内运行不同的命令'
- en: '](img/B16799_08_021.jpg)'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16799_08_021.jpg)'
- en: Figure 8.21 – tmux with four panes running different commands inside the same
    window
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.21 – tmux中有四个窗格，在同一个窗口内运行不同的命令
- en: As we can see, there are several commands running at the same time – `top`,
    `journalctl –f`, `iostat –x`, and `ping` – so this is a good way to monitor a
    system while operations are being performed on it.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，有几个命令同时运行 – `top`，`journalctl –f`，`iostat –x`和`ping` – 因此这是在执行操作时监视系统的好方法。
- en: Additionally, one of the advantages is that `tmux` can be scripted, so if we
    are using one layout while administering systems, we can copy that script and
    execute it as soon as we connect to them so that we can enjoy the same layout
    and even the commands being executed.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`tmux`的一个优点是可以进行脚本化，因此如果我们在管理系统时使用一个布局，我们可以复制该脚本，并在连接到它们时立即执行它，这样我们就可以享受相同的布局甚至正在执行的命令。
- en: 'You can find the following code with extra comments and descriptions at [https://github.com/PacktPublishing/Red-Hat-Enterprise-Linux-8-Administration/blob/main/chapter-08-remote-systems-administration/term.sh](https://github.com/PacktPublishing/Red-Hat-Enterprise-Linux-8-Administration/blob/main/chapter-08-remote-systems-administration/term.sh)
    if you want to try it on your system:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想在您的系统上尝试，可以在[https://github.com/PacktPublishing/Red-Hat-Enterprise-Linux-8-Administration/blob/main/chapter-08-remote-systems-administration/term.sh](https://github.com/PacktPublishing/Red-Hat-Enterprise-Linux-8-Administration/blob/main/chapter-08-remote-systems-administration/term.sh)找到带有额外注释和描述的以下代码：
- en: '[PRE7]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Once the session with `tmux` has been set, we can attach the session we've just
    created and configured by executing `tmux`, which will show a layout similar to
    the one shown in the preceding screenshot.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设置了带有`tmux`的会话，我们可以通过执行`tmux`附加到刚刚创建和配置的会话，这将显示类似于前面截图中显示的布局。
- en: Summary
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we covered SSH and how to use it to connect to remote systems,
    how to use keys to authenticate with or without a password, and how to take advantage
    of it for automation, transferring files, and even making services accessible
    or reachable via port redirection. With `tmux`, we learned how to make our administration
    sessions survive network interruptions and at the same time, show important information
    at a glance by automating the layouts for it.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了SSH以及如何使用它连接到远程系统，如何使用密钥进行身份验证，无论是否需要密码，以及如何利用它进行自动化，传输文件，甚至通过端口重定向使服务可访问或可达。通过`tmux`，我们学会了如何使我们的管理会话在网络中断时保持存活，并且通过自动化布局一目了然地显示重要信息。
- en: In the next chapter, we'll be digging into securing our system network via firewalld
    to only expose the services that are required for operation.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入探讨通过firewalld来保护我们的系统网络，以仅暴露所需的服务。
