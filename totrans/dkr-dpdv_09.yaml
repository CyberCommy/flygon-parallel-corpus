- en: '7: Containers'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we know a bit about images, it’s time to get into containers. As this
    is a book about Docker, we’ll be talking specifically about Docker containers.
    However, Docker has been hard at work implementing the image and container specs
    published by the Open Container Initiative (OCI) at https://www.opencontainers.org.
    This means a lot of what you learn here will apply to other container runtimes
    that are OCI compliant.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll split this chapter into the usual three parts:'
  prefs: []
  type: TYPE_NORMAL
- en: The TLDR
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The deep dive
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The commands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s go and learn about containers!
  prefs: []
  type: TYPE_NORMAL
- en: Docker containers - The TLDR
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A container is the runtime instance of an image. In the same way that we can
    start a virtual machine (VM) from a virtual machine template, we start one or
    more containers from a single image. The big difference between a VM and a container
    is that containers are faster and more lightweight — instead of running a full-blown
    OS like a VM, containers share the OS/kernel with the host they’re running on.
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.1 shows a single Docker image being used to start multiple Docker containers.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1](images/figure7-1.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.1
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest way to start a container is with the `docker container run` command.
    The command can take a lot of arguments, but in its most basic form you tell it
    an image to use and a app to run: `docker container run <image> <app>`. This next
    command will start an Ubuntu Linux container running the Bash shell as its app:
    `docker container run -it ubuntu /bin/bash`. To start a Windows container running
    the PowerShell app, you could do `docker container run -it microsoft/powershell:nanoserver
    pwsh.exe`.'
  prefs: []
  type: TYPE_NORMAL
- en: The `-it` flags will connect your current terminal window to the container’s
    shell.
  prefs: []
  type: TYPE_NORMAL
- en: Containers run until the app they are executing exits. In the two examples above,
    the Linux container will exit when the Bash shell exits, and the Windows container
    will exit when the PowerShell process terminates.
  prefs: []
  type: TYPE_NORMAL
- en: 'A really simple way to demonstrate this is to start a new container and tell
    it to run the sleep command for 10 seconds. The container will start, run for
    10 seconds and exit. If you run the following command from a Linux host (or Windows
    host running in Linux containers mode) your shell will attach to the container’s
    shell for 10 seconds and then exit: `docker container run alpine:latest sleep
    10`. You can do the same with a Windows container with the following command `docker
    container run microsoft/powershell:nanoserver Start-Sleep -s 10`.'
  prefs: []
  type: TYPE_NORMAL
- en: You can manually stop a container with the `docker container stop` command,
    and then restart it with `docker container start`. To get rid of a container forever
    you have to explicitly delete it using `docker container rm`.
  prefs: []
  type: TYPE_NORMAL
- en: That’s the elevator pitch! Now let’s get into the detail…
  prefs: []
  type: TYPE_NORMAL
- en: Docker containers - The deep dive
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first things we’ll cover here are the fundamental differences between a
    container and a VM. It’s mainly theory at this stage, but it’s important stuff.
    Along the way, we’ll point out where the container model has potential advantages
    over the VM model.
  prefs: []
  type: TYPE_NORMAL
- en: '**Heads-up:** As the author, I’m going to say this before we go any further.
    A lot of us get passionate about the things we do and the skills we have. I remember
    *big Unix* people resisting the rise of Linux. You might remember the same. You
    might also remember people attempting to resist VMware and the VM juggernaut.
    In both cases “resistance was futile”. In this section I’m going to highlight
    what I consider some of the advantages the container model has over the VM model.
    But I’m guessing a lot of you will be VM experts with a lot invested in the VM
    ecosystem. And I’m guessing that one or two of you might want to fight me over
    some of the things I say. So let me be clear… I’m a big guy and I’d beat you down
    in hand-to-hand combat :-D Just kidding. But I’m not trying to destroy your empire
    or call your baby ugly! I’m trying to help. The whole reason for me writing this
    book is to help you get started with Docker and containers!'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Here we go.
  prefs: []
  type: TYPE_NORMAL
- en: Containers vs VMs
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Containers and VMs both need a host to run on. This can be anything from your
    laptop, a bare metal server in your data center, all the way up to an instance
    the public cloud. In this example we’ll assume a single physical server that we
    need to run 4 business applications on.
  prefs: []
  type: TYPE_NORMAL
- en: In the VM model, the physical server is powered on and the hypervisor boots
    (we’re skipping the BIOS and bootloader code etc.). Once the hypervisor boots,
    it lays claim to all physical resources on the system such as CPU, RAM, storage,
    and NICs. The hypervisor then carves these hardware resources into virtual versions
    that look smell and feel exactly like the real thing. It then packages them into
    a software construct called a virtual machine (VM). We then take those VMs and
    install an operating system and application on each one. We said we had a single
    physical server and needed to run 4 applications, so we’d create 4 VMs, install
    4 operating systems, and then install the 4 applications. When it’s all done it
    looks a bit like Figure 7.2.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2](images/figure7-2.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.2
  prefs: []
  type: TYPE_NORMAL
- en: Things are a bit different in the container model.
  prefs: []
  type: TYPE_NORMAL
- en: When the server is powered on, your chosen OS boots. In the Docker world this
    can be Linux, or a modern version of Windows that has support for the container
    primitives in its kernel. Similar to the VM model, the OS claims all hardware
    resources. On top of the OS, we install a container engine such as Docker. The
    container engine then takes **OS resources** such as the *process tree*, the *filesystem*,
    and the *network stack*, and carves them up into secure isolated constructs called
    *containers*. Each container looks smells and feels just like a real OS. Inside
    of each *container* we can run an application. Like before, we’re assuming a single
    physical server with 4 applications. Therefore, we’d carve out 4 containers and
    run a single application inside of each. This is shown in Figure 7.3.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.3](images/figure7-3.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.3
  prefs: []
  type: TYPE_NORMAL
- en: At a high level, we can say that hypervisors perform **hardware virtualization**
    — they carve up physical hardware resources into virtual versions. On the other
    hand, containers perform **OS virtualization** — they carve up OS resources into
    virtual versions.
  prefs: []
  type: TYPE_NORMAL
- en: The VM tax
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s build on what we just covered and drill into one of the main problems
    with the hypervisor model.
  prefs: []
  type: TYPE_NORMAL
- en: We started out with a single physical server and the requirement to run 4 business
    applications. In both models we installed either an OS or a hypervisor (a type
    of OS that is highly tuned for VMs). So far the models are almost identical. But
    this is where the similarities stop.
  prefs: []
  type: TYPE_NORMAL
- en: The VM model then carves **low-level hardware resources** into VMs. Each VM
    is a software construct containing virtual CPU, virtual RAM, virtual disk etc.
    As such, every VM needs its own OS to claim, initialize, and manage all of those
    virtual resources. And sadly, every OS comes with its own set of baggage and overheads.
    For example, every OS consumes a slice of CPU, a slice of RAM, a slice of storage
    etc. Most need their own licenses as well as people and infrastructure to patch
    and upgrade them. Each OS also presents a sizable attack surface. We often refer
    to all of this as the ***OS tax***, or ***VM tax*** — every OS you install consumes
    resources!
  prefs: []
  type: TYPE_NORMAL
- en: The container model has a single kernel running in the host OS. It’s possible
    to run tens or hundreds of containers on a single host with every container sharing
    that single OS/kernel. That means a single OS consuming CPU, RAM, and storage.
    A single OS that needs licensing. A single OS that needs upgrading and patching.
    And a single OS kernel presenting an attack surface. All in all, a single OS tax
    bill!
  prefs: []
  type: TYPE_NORMAL
- en: That might not seem a lot in our example of a single server needing to run 4
    business applications. But when we’re talking about hundreds or thousands of apps,
    this can be game changing.
  prefs: []
  type: TYPE_NORMAL
- en: Another thing to consider is start times. Because a container isn’t a full-blown
    OS, it starts **much faster** than a VM. Remember, there’s no kernel inside of
    a container that needs locating, decompressing, and initializing — not to mention
    all of the hardware enumerating and initializing associated with a normal kernel
    bootstrap. None of that is needed when starting a container! The single shared
    kernel, down at the OS level, is already started! Net result, containers can start
    in less than a second. The only thing that has an impact on container start time
    is the time it takes to start the application it’s running.
  prefs: []
  type: TYPE_NORMAL
- en: This all amounts to the container model being leaner and more efficient than
    the VM model. We can pack more applications onto less resources, start them faster,
    and pay less in licensing and admin costs, as well as present less of an attack
    surface to the dark side. What’s not to like about that!
  prefs: []
  type: TYPE_NORMAL
- en: With that theory out of the way, let’s have a play around with some containers.
  prefs: []
  type: TYPE_NORMAL
- en: Running containers
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To follow along with these examples, you’ll need a working Docker host. For
    most of the commands it won’t make a difference if it’s Linux or Windows.
  prefs: []
  type: TYPE_NORMAL
- en: Checking the Docker daemon
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The first thing I always do when I log on to a Docker host is check that Docker
    is running.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '`As long as you get a response back in the `Client` and `Server` sections you
    should be good to go. If you get an error code in the `Server` section there’s
    a good chance that the docker daemon (server) isn’t running, or that your user
    account doesn’t have permission to access it.'
  prefs: []
  type: TYPE_NORMAL
- en: If you’re running Linux, and your user account doesn’t have permission to access
    the daemon, you need to make sure it’s a member of the local `docker` Unix group.
    If it isn’t, you can add it with `usermod -aG docker <user>` and then you’ll have
    to logout and log back in to your shell for the changes to take effect.
  prefs: []
  type: TYPE_NORMAL
- en: If your user account is already a member of the local `docker` group, the problem
    might be that the Docker daemon isn’t running. To check the status of the Docker
    daemon, run one of the following commands depending on your Docker host’s operating
    system.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '`If the Docker daemon is running, you’re fine to continue.'
  prefs: []
  type: TYPE_NORMAL
- en: Starting a simple container
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The simplest way to start a container is with the `docker container run` command.
  prefs: []
  type: TYPE_NORMAL
- en: The following command starts a simple container that will run a containerized
    version of Ubuntu Linux.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '`A Windows example could be'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '`The format of the command is essentially `docker container run <options> <image>:<tag>
    <app>`.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s break the command down.
  prefs: []
  type: TYPE_NORMAL
- en: We started with `docker container run`, this is the standard command to start
    a new container. We then used the `-it` flags to make the container interactive
    and attach it to our terminal. Next, we told it to use the `ubuntu:latest` or
    `microsoft/powershell:nanoserver` image. Finally, we told it to run the Bash shell
    in the Linux example, and the PowerShell app in the Windows example.
  prefs: []
  type: TYPE_NORMAL
- en: When we hit `Return`, the Docker client made the appropriate API calls to the
    Docker daemon. The Docker daemon accepted the command and searched the Docker
    host’s local cache to see if it already had a copy of the requested image. In
    the example cited, it didn’t, so it went to Docker Hub to see if it could find
    it there. It could, so it *pulled* it locally and stored it in its local cache.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note:** In a standard, out-of-the-box Linux installation, the Docker daemon
    implements the Docker Remote API on a local IPC/Unix socket at `/var/run/docker.sock`.
    On Windows, it listens on a named pipe at `npipe:////./pipe/docker_engine`. It’s
    also possible to configure the Docker client and daemon to communicate over the
    network. The default non-TLS network port for Docker is 2375, the default TLS
    port is 2376.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Once the image was pulled, the daemon created the container and executed the
    specified app inside of it.
  prefs: []
  type: TYPE_NORMAL
- en: If you look closely, you’ll see that your shell prompt has changed and you’re
    now inside of the container. In the example cited, the shell prompt has changed
    to `root@3027eb644874:/#`. The long number after the `@` is the first 12 characters
    of the container’s unique ID.
  prefs: []
  type: TYPE_NORMAL
- en: Try executing some basic commands inside of the container. You might notice
    that some commands do not work. This is because the images we used, like almost
    all container images, are highly optimized for containers. This means they don’t
    have all of the normal commands and packages installed. The following example
    shows a couple of commands — one succeeds and the other one fails.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '`As shown in the output above, the `ping` utility is not included as part of
    the official Ubuntu image.'
  prefs: []
  type: TYPE_NORMAL
- en: Container processes
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When we started the Ubuntu container in the previous section, we told it to
    run the Bash shell (`/bin/bash`). This makes the Bash shell the **one and only
    process running inside of the container**. You can see this by running `ps -elf`
    from inside the container.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '`Although it might look like there are two processes running in the output
    above, there aren’t. The first process in the list, with PID 1, is the Bash shell
    we told the container to run. The second process is the `ps -elf` command we ran
    to produce the list. This is a short-lived process that has already exited by
    the time the output is displayed. Long story short, this container is running
    a single process — `/bin/bash`.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Note:** Windows containers are slightly different and tend to run quite a
    few processes.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This means that if you type `exit`, to exit the Bash shell, the container will
    also exit (terminate). The reason for this is that a container cannot exist without
    a running process — killing the Bash shell kills the container’s only process,
    resulting in the container also being killed. This is also true of Windows containers
    — **killing the main process in the container will also kill the container**.
  prefs: []
  type: TYPE_NORMAL
- en: Press `Ctrl-PQ` to exit the container without terminating it. Doing this will
    place you back in the shell of your Docker host and leave the container running
    in the background. You can use the `docker container ls` command to view the list
    of running containers on your system.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '`It’s important to understand that this container is still running and you
    can re-attach your terminal to it with the `docker container exec` command.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '`The command to re-attach to the Windows Nano Server PowerShell container would
    be `docker container exec -it <container-name-or-ID> pwsh.exe`.'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the shell prompt has changed back to the container. If you run
    the `ps` command again you will now see **two** Bash or PowerShell processes.
    This is because the `docker container exec` command created a new Bash or PowerShell
    process and attached to that. This means that typing `exit` in this shell will
    not terminate the container, because the original Bash or PowerShell process will
    continue running.
  prefs: []
  type: TYPE_NORMAL
- en: Type `exit` to leave the container and verify it’s still running with a `docker
    container ps`. It will still be running.
  prefs: []
  type: TYPE_NORMAL
- en: If you are following along with the examples on your own Docker host, you should
    stop and delete the container with the following two commands (you will need to
    substitute the ID of your container).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '`The containers started in the previous examples will no longer be present
    on your system.'
  prefs: []
  type: TYPE_NORMAL
- en: Container lifecycle
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: It’s a common myth that containers can’t persist data. They can!
  prefs: []
  type: TYPE_NORMAL
- en: A big part of the reason people think containers aren’t good for persistent
    workloads, or persisting data, is because they’re so good at non-persistent stuff.
    But being good at one thing doesn’t mean you can’t do other things. A lot of VM
    admins out there will remember companies like Microsoft and Oracle telling you
    that you couldn’t run their applications inside of VMs — or at least they wouldn’t
    support you if you did. I wonder if we’re seeing something similar with the move
    to containerization — are there people out there trying to protect their empires
    of persistent workloads from what they perceive as the threat of containers?
  prefs: []
  type: TYPE_NORMAL
- en: In this section we’ll look at the lifecycle of a container — from birth, through
    work and vacations, to eventual death.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve already seen how to start containers with the `docker container run` command.
    Let’s start another one so we can walk it through its entire lifecycle. The following
    examples will be from a Linux Docker host running an Ubuntu container. However,
    all of the examples will work with the Windows PowerShell container we’ve used
    in previous examples — though you’ll have to substitute Linux commands with their
    equivalent Windows commands.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '`That’s our container created, and we named it “percy” for persistent :-S'
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s put it to work by writing some data to it.
  prefs: []
  type: TYPE_NORMAL
- en: From within the shell of your new container, follow the procedure below to write
    some data to a new file in the `tmp` directory and verify that the write operation
    succeeded.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '`Press `Ctrl-PQ` to exit the container without killing it.'
  prefs: []
  type: TYPE_NORMAL
- en: Now use the `docker container stop` command to stop the container and put in
    on *vacation*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '`You can use the container’s name or ID with the `docker container stop` command.
    The format is `docker container stop <container-id or container-name>`.'
  prefs: []
  type: TYPE_NORMAL
- en: Now run a `docker container ls` command to list all running containers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`The container is not listed in the output above because you put it in the
    stopped state with the `docker container stop` command. Run the same command again,
    only this time add the `-a` flag to show all containers, including those that
    are stopped.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '`Now we can see the container showing as `Exited (0)`. Stopping a container
    is like stopping a virtual machine. Although it’s not currently running, its entire
    configuration and contents still exist on the filesystem of the Docker host, and
    it can be restarted at any time.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s use the `docker container start` command to bring it back from vacation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '`The stopped container is now restarted. Time to verify that the file we created
    earlier still exists. Connect to the restarted container with the `docker container
    exec` command.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '`Your shell prompt will change to show that you are now operating within the
    namespace of the container.'
  prefs: []
  type: TYPE_NORMAL
- en: Verify that the file you created earlier is still there and contains the data
    you wrote to it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '`As if by magic, the file you created is still there and the data it contains
    is exactly how you left it! This proves that stopping a container does not destroy
    the container or the data inside of it.'
  prefs: []
  type: TYPE_NORMAL
- en: While this example illustrates the persistent nature of containers, I should
    point out that *volumes* are the preferred way to store persistent data in containers.
    But at this stage of our journey I think this is an effective example of the persistent
    nature of containers.
  prefs: []
  type: TYPE_NORMAL
- en: So far I think you’d be hard pressed to draw a major difference in the behavior
    of a container vs a VM.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s kill the container and delete it from our system.
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to delete a *running* container with a single command by passing
    the `-f` flag to `docker container rm`. However, it’s considered a best practice
    to take the two-step approach of stopping the container first and then deleting
    it. This gives the application/process that the container is running a fighting
    chance of stopping cleanly. More on this in a second.
  prefs: []
  type: TYPE_NORMAL
- en: The next example will stop the `percy` container, delete it, and verify the
    operation. If your terminal is still attached to the percy container, you will
    need to get back to your Docker host’s terminal by pressing `Ctrl-PQ`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '`The container is now deleted — literally wiped off the face of the planet.
    If it was a good container, it becomes a *serverless function* in the afterlife.
    If it was a naughty container, it becomes a dumb terminal :-D'
  prefs: []
  type: TYPE_NORMAL
- en: To summarize the lifecycle of a container… You can stop, start, pause, and restart
    a container as many times as you want. And it’ll all happen really fast. But the
    container and its data will always be safe. It’s not until you explicitly delete
    a container that you run any chance of losing its data. And even then, if you’re
    storing container data in a *volume*, that data’s going to persist even after
    the container has gone.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s quickly mention why we recommended a two-stage approach of stopping the
    container before deleting it.
  prefs: []
  type: TYPE_NORMAL
- en: Stopping containers gracefully
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Most containers in the Linux world will run a single process. In the Windows
    world they run a few processes, but the following rules still apply.
  prefs: []
  type: TYPE_NORMAL
- en: In our previous example the container was running the `/bin/bash` app. When
    you kill a running container with `docker container rm <container> -f`, the container
    will be killed without warning. The procedure is quite violent — a bit like sneaking
    up behind the container and shooting it in the back of the head. You’re literally
    giving the container, and the app it’s running, no chance to straighten its affairs
    before being killed.
  prefs: []
  type: TYPE_NORMAL
- en: However, the `docker container stop` command is far more polite (like pointing
    a gun to the containers head and saying “you’ve got 10 seconds to say any final
    words”). It gives the process inside of the container a heads-up that it’s about
    to be stopped, giving it a chance to get things in order before the end comes.
    Once the `docker stop` command returns, you can then delete the container with
    `docker container rm`.
  prefs: []
  type: TYPE_NORMAL
- en: The magic behind the scenes here can be explained with Linux/POSIX *signals*.
    `docker container stop` sends a **SIGTERM** signal to the PID 1 process inside
    of the container. As we just said, this gives the process a chance to clean things
    up and gracefully shut itself down. If it doesn’t exit within 10 seconds, it will
    receive a **SIGKILL**. This is effectively the bullet to the head. But hey, it
    got 10 seconds to sort itself out first!
  prefs: []
  type: TYPE_NORMAL
- en: '`docker container rm <container> -f` doesn’t bother asking nicely with a **SIGTERM**,
    it goes straight to the **SIGKILL**. Like we said a second ago, this is like creeping
    up from behind and smashing it over the head. I’m not a violent person by the
    way!'
  prefs: []
  type: TYPE_NORMAL
- en: Self-healing containers with restart policies
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: It’s often a good idea to run containers with a restart policy. It’s a form
    of self-healing that enables Docker to automatically restart them after certain
    events or failures have occurred.
  prefs: []
  type: TYPE_NORMAL
- en: Restart policies are applied per-container, and can be configured imperatively
    on the command line as part of `docker-container run` commands, or declaratively
    in Compose files for use with Docker Compose and Docker Stacks.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the time of writing, the following restart policies exist:'
  prefs: []
  type: TYPE_NORMAL
- en: '`always`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unless-stopped`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`on-failed`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **always** policy is the simplest. It will always restart a stopped container
    unless it has been explicitly stopped, such as via a `docker container stop` command.
    An easy way to demonstrate this is to start a new interactive container with the
    `--restart always` policy, and tell it to run a shell process. When the container
    starts you will be attached to its shell. Typing exit from the shell will kill
    the container’s PID 1 process and therefore kill the container. However, Docker
    will automatically restart it because it was started with the `--restart always`
    policy. If you issue a `docker container ls` command, you will see that the container’s
    uptime will be less than the time since it was created. We show this in the following
    example.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’re following a long with Windows, substitute the `docker container run`
    command in the example with this one: `docker container run --name neversaydie
    -it --restart always microsoft/powershell:nanoserver`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]`exit[PRE19][PRE20]`'
  prefs: []
  type: TYPE_NORMAL
