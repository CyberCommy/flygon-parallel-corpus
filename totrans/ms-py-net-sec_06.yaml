- en: Gathering Information from Servers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this chapter, we will look at the main modules that allow us to extract
    information that the servers expose in a public way. With the tools we have discussed,
    we can get information that may be useful for later phases of our pentesting or
    audit process. We will see tools such as Shodan and Banner Grabbing, getting information
    for DNS servers with the `DNSPython` module, and Fuzzing processing with the `pywebfuzz`
    module.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to gathering information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Shodan` package as a tool to extract information from servers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Shodan` package as a tool for applying filters and searching in Shodan
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to extract banner information from servers through the `socket` module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `DNSPython` module as a tool for extracting information from DNS servers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `pywebfuzz` module as a tool for obtaining possible vulnerable addresses
    on specific servers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Examples and source code for this chapter are available in GitHub repository
    in the `chapter 6` folder: [https://github.com/PacktPublishing/Mastering-Python-for-Networking-and-Security](https://github.com/PacktPublishing/Mastering-Python-for-Networking-and-Security).
  prefs: []
  type: TYPE_NORMAL
- en: You will need to install Python on your local machine, and some basic knowledge
    about TCP protocol and requests is required.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to gathering information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The process of collecting information can be automated using both modules that
    are installed by default in the Python distribution and external modules that
    are installed in a simple way. Some of the modules that we will see allow us to
    extract information from servers and services that are running – information such
    as domain names and banners.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many ways to gather information from servers:'
  prefs: []
  type: TYPE_NORMAL
- en: We can use Shodan to extract information from public servers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can use the `socket` module to extract banner information from public and
    private servers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can use the `DNSPython` module to extract information from DNS servers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can use the `pywebfuzz` module to obtain possible vulnerabilities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extracting information from servers with Shodan
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you will learn the basics of Shodan for obtaining information
    from port scanning, banner servers, and operating system versions. Instead of
    indexing the web content, it indexes information about headers, banners, and operating
    system versions.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Shodan
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Shodan is an acronym for Sentient Hyper-Optimized Data Access Network. Unlike
    traditional search engines that crawl the web to display results, Shodan attempts
    to grab data from ports. The free version provides 50 results. If you know how
    to use it creatively, you can discover the vulnerabilities of a web server.
  prefs: []
  type: TYPE_NORMAL
- en: Shodan is a search engine that lets you find specific information from routers,
    servers, and any device with an IP address. All the information that we can extract
    from this service is public.
  prefs: []
  type: TYPE_NORMAL
- en: Shodan indexes a large amount of data, which is really helpful when searching
    for specific devices that happen to be connected to the internet. All information
    that we can extract from this service is public.
  prefs: []
  type: TYPE_NORMAL
- en: With Shodan, we also have available a REST API for making searches, scans, and
    queries: [https://developer.shodan.io/api](https://developer.shodan.io/api).
  prefs: []
  type: TYPE_NORMAL
- en: Accessing Shodan services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Shodan is a search engine that is responsible for tracking servers and various
    types of devices on the internet (for example, IP cameras), and extracting useful
    information about services that are running on those targets.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike other search engines, Shodan does not search for web content, it searches
    for information about the server from the headers of HTTP requests, such as operating
    system, banners, server type, and versions.
  prefs: []
  type: TYPE_NORMAL
- en: Shodan works in a very similar way to the search engines on the internet, with
    the difference being that it does not index the contents of the found servers,
    but the headers and banners returned by the services.
  prefs: []
  type: TYPE_NORMAL
- en: It is known as the "Google of hackers," because it allows us to perform searches
    by applying different types of filters to recover servers that use a specific
    protocol.
  prefs: []
  type: TYPE_NORMAL
- en: To use Shodan from Python programmatically, it is necessary to have an account
    in Shodan with a Developer Shodan Key, in this way, it allows Python developers
    to automate the searches in their services through its API. If we register as
    developers, we obtain `SHODAN_API_KEY`, which we will use from our scripts in
    Python to perform the same searches that can be done through the [https://developer.shodan.io](https://developer.shodan.io) service.
    If we register as developers, in addition to being able to obtain the `API_KEY`,
    we have other advantages, such as obtaining more results or using search filters.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also have some options for developers that allow us to discover Shodan services:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/64c53d0e-3b41-4761-a549-b76241dadd99.png)'
  prefs: []
  type: TYPE_IMG
- en: To install the `Python` module, we can run the `pip install shodan` command.
  prefs: []
  type: TYPE_NORMAL
- en: Shodan also has a REST API to make requests to its services, which you can find
    at [https://developer.shodan.io/api](https://developer.shodan.io/api).
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/e0b54dc4-0fae-482c-aa4d-f7d9a68dd32d.png)'
  prefs: []
  type: TYPE_IMG
- en: For example, if we want to perform a search, we can use the `/shodan/host/` endpoint
    search.To make the requests correctly, it is necessary to indicate the `API_KEY`
    that we obtained when we registered.
  prefs: []
  type: TYPE_NORMAL
- en: For example, with this request, we obtain the search results with the "apache"
    search, which returns a response in JSON format: [https://api.shodan.io/shodan/host/search?key=<your_api_key>&query=apache](https://api.shodan.io/shodan/host/search?key=v4YpsPUJ3wjDxEqywwu6aF5OZKWj8kik&query=apache).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find more information in the official documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/cce092a9-3099-4371-91b9-0d940c6855e0.png)'
  prefs: []
  type: TYPE_IMG
- en: Shodan filters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Shodan has a series of special filters that allow us to optimize search results.
    Among the filters, we can highlight:'
  prefs: []
  type: TYPE_NORMAL
- en: '**after/before**: Filters the results by date'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**country**: Filters the results by two-digit country code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**city**: Filters the results by city'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**geo**: Filters the results by latitude/longitude'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**hostname**: Filters the results by host or domain name'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**net**: Filters the results by a specific range of IPs or a network segment'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**os**: Performs a search for a specific operating system'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**port**: Allows us to filter by port number'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find more information about shodan filters at [http://www.shodanhq.com/help/filters](http://www.shodanhq.com/help/filters).
  prefs: []
  type: TYPE_NORMAL
- en: Shodan search with python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the `search` function offered by the Python API, you can search in the
    same way that you can with the web interface. If we execute the following example
    from the Python interpreter, we see that if we look for the "apache" string, we
    get 15,684,960 results.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we can see the total results and the execution of the `Shodan` module
    from the interpreter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/1d719031-9e79-4c2e-94a7-5dc5972ab966.png)'
  prefs: []
  type: TYPE_IMG
- en: We can also create our own class (**ShodanSearch**), which has the `__init__` method
    to initialize the Shodan object from `API_KEY` that we obtained when we registered.
    We can also have a method to search for the search string by parameter and call
    the search method of shodan's API.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the following code in the `ShodanSearch.py` file in the shodan
    folder on the github repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Performing searches by a given host
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this example, executed from the Python interpreter, we can see that with
    the `shodan.host()` method, it is possible to obtain information from a certain
    IP, such as country, city, service provider, servers, or versions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/64355c0a-012a-4927-abfc-6a9980492d62.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can go in details with **data array** where we can get more information
    about **ISP**, **location, latitude, and longitude**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/f89dfd7f-41eb-436a-af00-0cc0c66bf1c2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the previously defined `ShodanSearch` class, we could define a method that
    is passed by the IP parameter of the host and call the `host ()` method of the
    shodan API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ShodanSearch` script accepts a search string and the IP address of the
    host:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ddf0845c-4e96-4e66-a02d-7f13067e2c86.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In this example execution, we are testing the IP address 22.253.135.79 to obtain
    all public information from this server:'
  prefs: []
  type: TYPE_NORMAL
- en: '**`python .\ShodanSearch.py -h 23.253.135.79`**'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c0ab91b6-103b-4a65-abb4-cf9c4c2194e1.png)'
  prefs: []
  type: TYPE_IMG
- en: Searching for FTP servers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can perform a search for servers that have an FTP access with an anonymous
    user and can be accessed without a username and password.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we perform the search with the "**port: 21 Anonymous user logged in**" string,
    we obtain those vulnerable FTP servers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/81811d2e-2261-434f-b97b-ab5d020a7767.png)'
  prefs: []
  type: TYPE_IMG
- en: This script allows you to obtain a list of IP addresses in servers that allow
    FTP access anonymously.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the following code in the`ShodanSearch_FTP_Vulnerable.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'With the execution of the previous script, we obtain an IP address list with
    servers that are vulnerable to anonymous login in ftp service:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/fa6007ba-a01f-4818-ac2a-5b62be918960.png)'
  prefs: []
  type: TYPE_IMG
- en: Using python to obtain server information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you will learn the basics of obtaining banners and whois information
    from servers with socket and `python-whois` modules.
  prefs: []
  type: TYPE_NORMAL
- en: Extracting servers banners with python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Banners expose information related with the name of the web server and the version
    that is running on the server. Some expose the backend technology (PHP, Java,
    Python) used and its version. The production version could have public or non-public
    failures, so it is always a good practice to test the banners that return the
    servers that we have publicly exposed, to see whether they expose some type of
    information that we do not want to be public.
  prefs: []
  type: TYPE_NORMAL
- en: Using the standard Python libraries, it is possible to create a simple program
    that connects to a server and captures the banner of the service included in the
    response to the request. The simplest way to obtain the banner of a server is
    by using the `socket` module**.** We can send a get request and get the response
    through the `recvfrom()` method, which would return a tuple with the result.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the following code in the `BannerServer.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous script accepts the **target** and the **port** as **parameters**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/b52f0624-d259-4b14-9aa8-08109c1110ea.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In this case, we obtain the web server version on port 80:'
  prefs: []
  type: TYPE_NORMAL
- en: '`**python .\BannerServer.py -target www.google.com -port 80**`'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/9a3bcd8a-75d9-4f68-82eb-90a05b492014.png)'
  prefs: []
  type: TYPE_IMG
- en: Finding whois information about a server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can use the WHOIS protocol to see who is the registered owner of the domain
    name. There is a `Python` module, called python-whois, for this protocol, documented
    at [https://pypi.python.org/pypi/python-whois](https://pypi.python.org/pypi/python-whois),
    which can be installed via pip using the `pip install python-whois` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if we want to query the names of servers and the owner of a certain
    domain, we can do them through the `get_whois()` method. This method returns a
    dictionary structure (`key-> value`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'With the `pythonwhois.net.get_root_server()` method, it is possible to recover
    the root server for a given domain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'With the `pythonwhois.net.get_whois_raw()` method, it is possible to retrieve
    all the information for a given domain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the following script we see a complete example where we pass the domain as
    parameter from which we are going to extract information.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the following code in the`PythonWhoisExample.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Getting information on dns servers with DNSPython
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will create a DNS client in Python, and see how this client
    will obtain information about name servers, mail servers, and IPV4/IPV6 addresses.
  prefs: []
  type: TYPE_NORMAL
- en: DNS protocol
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: DNS stands for Domain Name Server, the domain name service used to link IP addresses
    with domain names. DNS is a globally-distributed database of mappings between
    hostnames and IP addresses. It is an open and hierarchical system with many organizations
    choosing to run their own DNS servers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The DNS protocol is used for different purposes. The most common are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Names resolution:** Given the complete name of a host, it can obtain its
    IP address.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reverse address resolution:** It is the reverse mechanism to the previous
    one. It can, given an IP address, obtain the name associated with it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mail servers resolution:** Given a mail server domain name (for example,
    gmail.com), it can obtain the server through which communication is performed (for
    example, gmail-smtp-in.l.google.com).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'DNS is also a protocol that devices use to query DNS servers for resolving
    hostnames to IP addresses (and vice-versa). The `nslookup` tool comes with most
    Linux and Windows systems, and it lets us query DNS on the command line. Here,
    we determined that the python.org host has the IPv4 address `23.253.135.79`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$ nslookup python.org`'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the address resolution for the python.org domain:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/bc740de9-7a55-40d3-accb-1884f928fb65.png)'
  prefs: []
  type: TYPE_IMG
- en: DNS servers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Humans are much better at remembering names to relate to objects than long sequences
    of numbers. It is much easier to remember the google.com domain than the IP. In
    addition, the IP address can change by movements in the network infrastructure,
    while the domain name remains the same.
  prefs: []
  type: TYPE_NORMAL
- en: Its operation is based on the use of a distributed and hierarchical database
    in which domain names and IP addresses are stored, as well as the ability to provide
    mail-server location services.
  prefs: []
  type: TYPE_NORMAL
- en: 'DNS servers are located in the application layer and usually use port 53 (UDP).
    When a client sends a DNS packet to perform some type of query, you must send
    the type of record you want to query. Some of the most-used records are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**A: **Allows you to consult the IPv4 address'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**AAAA:** Allows you to consult the IPv6 address'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MX:** Allows you to consult the mail servers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**NS: **Allows you to consult the name of the server (Name Server)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**TXT:** Allows you to consult information in text format'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The DNSPython module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: DnsPython is an open source library written in Python that allows operations
    to query records against DNS servers. It allows access to high and low level.
    At high level allows queries to DNS records and at low level allows the direct
    manipulation of zones, names, and registers.
  prefs: []
  type: TYPE_NORMAL
- en: A few DNS client libraries are available from PyPI. We will focus on the `dnspython`
    library, which is available at [http://www.dnspython.org](http://www.dnspython.org).
  prefs: []
  type: TYPE_NORMAL
- en: The installation can be done either using the python repository or by downloading
    the github source code ([https://github.com/rthalley/dnspython](https://github.com/rthalley/dnspython))
    and running the `setup.py` install file.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can install this library by using either the `easy_install` command or
    the `pip` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The main packages for this module are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The information that we can obtain from a specific domain is:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Records for mail servers**: ansMX = dns.resolver.query(‘domain’,’MX’)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Records for name servers** :ansNS = dns.resolver.query(‘domain’,’NS’)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Records for IPV4 addresses** :ansipv4 = dns.resolver.query(‘domain’,’A’)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Records for IPV6 addresses** :ansipv6 = dns.resolver.query(‘domain’,’AAAA’)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this example, we are making a simple query regarding the IP address of a
    host with the `dns.resolver` submodule:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We can check whether one domain is the **subdomain** of another with the `is_subdomain()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Obtain a domain name from an IP address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Obtain an IP from a domain name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to make a **reverse look-up**, you need to use the `dns.reversename`
    submodule, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the following code in the`DNSPython-reverse-lookup.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In this complete example, we pass as a parameter the domain from which we want
    to extract information.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the following code in the `DNSPythonServer_info.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: For example, if we try to get information from the python.org domain, we get
    the following results.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the previous script, we can get NameServers from the python.org domain:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/1924876b-2efb-4126-a3e6-06b75175d6e1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In this screenshot we can see **IPV4 and IPV6 addresses** resolution from python.org:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/948e0d86-308e-4b28-a7e9-581c5a719d3b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In this screenshot we can see **Mailservers** resolution from `python.org`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/546541b0-aea9-4f57-a64d-21422822a1f7.png)'
  prefs: []
  type: TYPE_IMG
- en: Getting vulnerable addresses in servers with Fuzzing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will learn about the fuzzing process and how we can use
    this practice with python projects to obtain URLs and addresses vulnerable to
    attackers.
  prefs: []
  type: TYPE_NORMAL
- en: The Fuzzing process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A fuzzer is a program where we have a file that contains URLs that can be predictable
    for a specific application or servers. Basically, we do a request for each predictable
    URL, and if we see that the response is OK, it means that we have found a URL
    that is not public or is hidden, but later we see that we can access it.
  prefs: []
  type: TYPE_NORMAL
- en: Like most exploitable conditions, the fuzzing process is only useful against
    systems that improperly sanitize input, or that take more data than they can handle.
  prefs: []
  type: TYPE_NORMAL
- en: 'In general, the fuzzing process consists of the following **phases**:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Identifying the target**: To fuzz an application, we have to identify the
    target application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Identifying inputs**: The vulnerability exists because the target application
    accepts a malformed input and processes it without sanitizing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Creating fuzz data**: After getting all the input parameters, we have to
    create invalid input data to send to the target application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fuzzing**: After creating the fuzz data, we have to send it to the target
    application. We can use the fuzz data for monitoring exceptions when calling services.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Determining exploitability**: After fuzzing, we have to check the input that
    caused a crash.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The FuzzDB project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: FuzzDB is a project where we find a set of folders that contain patterns of
    known attacks that have been collected in multiple tests of pentesting, mainly
    in web environments: [https://github.com/fuzzdb-project/fuzzdb](https://github.com/fuzzdb-project/fuzzdb).
  prefs: []
  type: TYPE_NORMAL
- en: 'The FuzzDB categories are separated into different directories that contain
    predictable resource-location patterns, patterns to detect vulnerabilities with
    malicious payloads or vulnerable routes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/f74dd986-38d2-4cda-9888-b16e47fa734f.png)'
  prefs: []
  type: TYPE_IMG
- en: Fuzzing with python with pywebfuzz
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: pywebfuzz is a Python module to assist in the identification of vulnerabilities
    in web applications through brute-force methods, and provides resources for testing
    vulnerabilities in servers and web applications such as apache server, jboss,
    and databases.
  prefs: []
  type: TYPE_NORMAL
- en: One of the objectives of the project is to facilitate the testing of web applications.
    The pywebfuzz project provides values and logic to test users, passwords, and
    codes against web applications.
  prefs: []
  type: TYPE_NORMAL
- en: In Python, we find the `pywebfuzz` module, where we have a set of classes that
    allow access to the FuzzDB directories and use their payloads.The structure of
    classes created in PyWebFuzz is organized by different attack schemes; these schemes
    represent the different payloads available in FuzzDB.
  prefs: []
  type: TYPE_NORMAL
- en: It has a class structure that is responsible for reading the files available
    in FuzzDB, so that later, we can use them from Python in our scripts.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to import the `fuzzdb` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, if we want to search for login pages on a server we can use the `fuzzdb.Discovery.PredictableRes.Logins`
    module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This returns a list of predictable resources, where each element corresponds
    to a URL that, if it exists in the web server, can be vulnerable:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/67c1c29f-5f68-4ad9-852d-a763e089e12c.png)'
  prefs: []
  type: TYPE_IMG
- en: We can make a script in Python where, given a URL that we are analyzing, we
    can test the connection to each of the login routes, and if the request returns
    a code `200`, the pages has been found in the server.
  prefs: []
  type: TYPE_NORMAL
- en: In this script, we can obtain predictable URLs, such as login, admin, administrator,
    and default page, and for each combination domain + predictable URL we verify
    the status code returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the following code in the `demofuzzdb.py` fileinside `pywebfuzz_folder`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also obtain the HTTP methods supported by the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the previous command from the python interpreter shows the available
    HTTP methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/8674b58d-92e1-4f44-b6a2-27eaae40d3fa.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can find the following code in the `demofuzzdb2.py`file inside `pywebfuzz_folder`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'There is a module that allows you to search for predictable resources on an
    Apache tomcat server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This submodule allows you to obtain strings to detect SQL injection vulnerabilities
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In this screen capture, we can see the execution of the `fuzzdb sql_injection`
    module:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/97ebbc4b-840a-4b52-84a1-eda6490ebeba.png)'
  prefs: []
  type: TYPE_IMG
- en: The information returned in this case matches that found in the GitHub repository
    of the project. [https://github.com/fuzzdb-project/fuzzdb/tree/master/attack/sql-injection/detect](https://github.com/fuzzdb-project/fuzzdb/tree/master/attack/sql-injection/detect)
    contains many files for detecting situations of SQL injection, for example, we
    can find the **GenericBlind.txt** file, which contains the same strings that the
    module returns from Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the GitHub repository, we see some files depending the SQL attack and the
    database type we are testing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/1107a246-1469-4197-8a84-cdf0fe899375.png)'
  prefs: []
  type: TYPE_IMG
- en: We can also find other files for testing SQL injection in MySQL databases: [https://github.com/fuzzdb-project/fuzzdb/blob/master/attack/sql-injection/detect/MySQL.txt](https://github.com/fuzzdb-project/fuzzdb/blob/master/attack/sql-injection/detect/MySQL.txt).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `Mysql.txt` file, we can see all available attack vectors to discover
    an SQL injection vulnerability:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/f3866661-f9d6-4654-b485-30ff8e20c8af.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can use the previous file to detect a SQL injection vulnerability in a specific
    site: testphp.vulnweb.com.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the following code in the `demofuzz_sql.py` file inside pywebfuzz_folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The execution of the previous script shows the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/5035d6a0-6ff4-41a0-ad90-2cc3ada3e8bf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following example would create a Python list that contains all of the values
    from fuzzdb for LDAP Injection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Now the `ldap_values` variable would be a Python dictionary containing the values
    from fuzzdb’s `ldap_injection` file. You could then iterate over the top of this
    variable with your tests.
  prefs: []
  type: TYPE_NORMAL
- en: We can find ldap folder inside the fuzzbd project: [https://github.com/fuzzdb-project/fuzzdb/tree/master/attack/ldap](https://github.com/fuzzdb-project/fuzzdb/tree/master/attack/ldap).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the objectives of this chapter has been to learn about the modules that
    allow us to extract information that the servers expose in a public way. With
    the tools we have discussed, we can get enough information that may be useful
    for later phases of our pentesting or audit process.
  prefs: []
  type: TYPE_NORMAL
- en: In the next [chapter](321a63e9-bf32-449a-9673-4991ab97234f.xhtml), we will explore
    the python programming packages that interact with the FTP, SSH, and SNMP servers.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What do we need to access the Shodan developer API?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which method should be called in the shodan API to obtain information about
    a given host and what data structure does that method return?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which module can be used to obtain the banner of a server?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which method should be called and what parameters should be passed to obtain
    the IPv6 address records with the `DNSPython` module?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which method should be called and what parameters should be passed to obtain
    the records for mail servers with the `DNSPython` module?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which method should be called and what parameters should be passed to obtain
    the records for name servers with the `DNSPython` module?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which project contains files and folders that contain patterns of known attacks
    that have been collected in various pentesting tests on web applications?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which module should be used to look for login pages on a server that may be
    vulnerable?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which `FuzzDB` project module allows us to obtain strings to detect SQL injection-type
    vulnerabilities?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What port do DNS servers use to resolve requests for mail server names?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In these links, you will find more information about the mentioned tools and
    official python documentation for some of the commented modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://developer.shodan.io/api](https://developer.shodan.io/api)'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.dnspython.org](http://www.dnspython.org)'
  prefs: []
  type: TYPE_NORMAL
- en: You can create your own DNS server with the python `dnslib` module: [https://pypi.org/project/dnslib/](https://pypi.org/project/dnslib/)
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/fuzzdb-project/fuzzdb](https://github.com/fuzzdb-project/fuzzdb).'
  prefs: []
  type: TYPE_NORMAL
- en: In the Python ecosystem, we can find other fuzzers, such as **wfuzz**.
  prefs: []
  type: TYPE_NORMAL
- en: Wfuzz is a web-application security-fuzzer tool that you can use from the command
    line or programmatically with the Python library: [https://github.com/xmendez/wfuzz](https://github.com/xmendez/wfuzz).
  prefs: []
  type: TYPE_NORMAL
- en: Official documentation is available at [http://wfuzz.readthedocs.io](http://wfuzz.readthedocs.io/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Projects examples that use the `python Shodan` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.programcreek.com/python/example/107467/shodan.Shodan](https://www.programcreek.com/python/example/107467/shodan.Shodan)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/NullArray/Shogun](https://github.com/NullArray/Shogun)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/RussianOtter/networking/blob/master/8oScanner.py](https://github.com/RussianOtter/networking/blob/master/8oScanner.py)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/Va5c0/Shodan_cmd](https://github.com/Va5c0/Shodan_cmd)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/sjorsng/osint-combinerhttps://github.com/carnal0wnage/pentesty_scripts](https://github.com/sjorsng/osint-combinerhttps://github.com/carnal0wnage/pentesty_scripts)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/ffmancera/pentesting-multitool](https://github.com/ffmancera/pentesting-multitool)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/ninj4c0d3r/ShodanCli](https://github.com/ninj4c0d3r/ShodanCli)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we are interested in find web directories without bruteforce process, we
    can use this tool called `dirhunt`, basically is a web crawler optimized for search
    and analyze directories in a website.
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/Nekmo/dirhunt](https://github.com/Nekmo/dirhunt)'
  prefs: []
  type: TYPE_NORMAL
- en: You can install it with command `**pip install dirhunt**`
  prefs: []
  type: TYPE_NORMAL
- en: This tool supports Python version 2.7 & 3.x but Python 3.x is recommended
  prefs: []
  type: TYPE_NORMAL
