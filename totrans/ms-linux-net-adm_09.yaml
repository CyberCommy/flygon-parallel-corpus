- en: Chapter 9. Securing Your Network
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Security vulnerabilities and the miscreants who take advantage of them are everywhere.
    With the millions of lines of code contained within software running on a typical
    network, it's statistically impossible to ever be 100 percent secure from all
    possible threats. However, a good network administrator pays attention to current
    trends in network security and takes all the possible precautions to help ensure
    the network is as secure as it possibly can be. In this chapter, we will take
    a look at some of the things that can be done to increase the security of your
    network.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Limiting the attack surface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Securing SSH
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring the iptables firewall
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Protecting system services with fail2ban
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding SELinux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring Apache to utilize SSL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying security updates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Limiting the attack surface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most important rule of network security is limiting your attack surface.
    In a nutshell, this means that the less software you have installed and/or the
    less services you have running, the less it can be used against you. If that wasn't
    bad enough, in some cases an unpatched flaw in server software could allow a miscreant
    to use your server to attack someone else. By limiting the number of packages
    in use on your system, you're lowering the possibility of something bad happening.
  prefs: []
  type: TYPE_NORMAL
- en: This sounds simple enough, and it is, but it's important to keep in mind that
    this isn't just a matter of installing only what you need. Many Linux distributions
    ship with software that you may never need to use. This isn't just true for servers
    either. Even your end-user workstations could have unnecessary services running
    that would be a treasure trove for an attacker to use. One common example of this
    is having a **Mail Transfer Agent** (**MTA**) running on your system. It's surprising
    that many Linux distributions ship with an MTA running by default. Unless you
    specifically need an MTA (for example, you have scripts installed that need to
    send e-mail messages to administrators), you should remove these packages from
    your systems.
  prefs: []
  type: TYPE_NORMAL
- en: When rolling out Linux on any network, the first thing you should do is find
    out what is installed and what is running, and then decide what to turn off and/or
    uninstall. This is what is referred to as limiting your attack surface. It is
    true that Linux is one of most secure systems there are, but nothing will help
    you if you aren't keeping an eye on what is running and listening for connections
    on your network. For the remainder of this section, I'll go over a few ways in
    which you can limit your attack surface.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s print out a list of all the packages installed on our system.
    This will allow us to see what is installed, and then we can remove anything that
    stands out that we''re sure we don''t need. This list will likely be huge, as
    it will include everything; I do mean everything—even the libraries and various
    packages that allow our system to function. You definitely won''t understand what
    each of them packages are for, but as you learn more about Linux, you''ll make
    more sense of these and know what needs to be removed. For example, I know to
    remove `exim` or `postfix` packages from all of my installations, as I don''t
    personally need them anywhere. Since you won''t understand the purpose of all
    of the packages installed on your system, I recommend you to take a quick look
    and remove the ones you know for sure you don''t need. To print a list of installed
    packages, run one of the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For Debian-based sytems, execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'For CentOS systems, execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In either case, you'll end up with a text file called `installed_packages.txt`
    in your current working directory. This text file will contain a list of all the
    packages installed on your system. Feel free to check it and see if anything stands
    out as something that you can remove. In addition, this file serves as a handy
    backup as well. If you ever need to decommission a server and set up a new one
    with a similar purpose, you can compare the packages from one server to another
    to ensure the proper packages are installed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another neat trick to find out what is running on your system is with the `netstat`
    command. While we''ll discuss this command further in [Chapter 10](ch10.html "Chapter 10. Troubleshooting
    Network Issues"), *Troubleshooting Network Issues*, let''s try this out now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: You should see a list of services running on the local computer that are actually
    listening for network connections. These should be given major attention, as anything
    listening for outside connections is a possible point of entry into your system.
    If you see something here that's listening for connections and you don't need
    it to be, remove the package. You can always disable a service, but removing the
    underlying package is better as they can't be accidentally started. Packages can
    always be reinstalled if you find that you actually did need them.
  prefs: []
  type: TYPE_NORMAL
- en: '![Limiting the attack surface](img/B03919_09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The netstat command, listing running and listening services
  prefs: []
  type: TYPE_NORMAL
- en: In my case, I can see that I have Syncthing and Chrome listening for outside
    connections. This is expected. But in a production environment, such as a server,
    some things to watch out for would be the Apache web server (which would be a
    concern if the server is not actually a web server), postfix, or any file transfer
    utilities that shouldn't be installed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another useful tool is **ShieldsUP**, it is a service available on the Internet
    by GRC. This is not a Linux-specific tool by any means, but if you''re using Linux
    on your router and want to ensure that you have it configured to be as stealthy
    as possible, this tool can be useful for testing. You can access this tool at
    the following URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.grc.com/shieldsup](https://www.grc.com/shieldsup)'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Please keep in mind that ShieldsUP is an online tool that is not under the control
    or management of the author or publisher. As a result, it's subject to change
    at any time. That being said, this site hasn't changed in quite some time and
    it's a very useful tool.
  prefs: []
  type: TYPE_NORMAL
- en: To use it, click on **Proceed** and then click on **All Service Ports**. This
    service works by checking to see which ports answer to outside requests. If a
    port is open, it will show red, and you should be able to click on it to find
    out more information on what the port is typically used for. This will provide
    you clues on what to disable. In the event that the service doesn't contain information
    regarding a specific port, simply search on Google to look for clues.
  prefs: []
  type: TYPE_NORMAL
- en: '![Limiting the attack surface](img/B03919_09_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Using ShieldsUP! to see which ports answer from outside requests
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the `systemctl` command can also be used to see what services are
    currently installed on your machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Using the list the previous command will print to your terminal, you'll be able
    to see which unit files are currently installed, and their state.
  prefs: []
  type: TYPE_NORMAL
- en: That pretty much sums up how to interrogate your system to find out what is
    running. As you learn the typical names of services you may need to do a bit of
    Google search in order to learn the purpose of each service, but it gets easier
    with time. If you're at all unsure about what can be disabled or not, do your
    research first before you actually work on tweaking your running services. In
    the worst case, if you disable a necessary service, your server may not start
    the next time. As always, ensure you have good backups before altering system
    services.
  prefs: []
  type: TYPE_NORMAL
- en: Securing OpenSSH
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OpenSSH is a wonderful tool; it's the Linux administrator's best friend. It
    saves you the trouble of having to walk into the server room and attach a monitor
    and keyboard in order to perform work on your network. Using any computer connected
    to the same network, you can pretty much do anything you want to as if you were
    standing right in front of the machine. The problem is that an unsecured SSH implementation
    gives miscreants the exact same luxury. Of all the things running on your network,
    SSH is definitely the one you want to give some major attention to.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first and most common security tweak for SSH is to use only Version 2 of
    the protocol. To determine which version your Linux installation is using, `grep`
    the `/etc/ssh/sshd_config` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: If the answer is 1, you should edit this file and change the line that reads
    **Protocol 1** to **Protocol 2**, and restart SSH. The reason this is important
    is because Protocol 1 has considerably weaker security than Protocol 2\. Thankfully,
    SSH Version 7 and later, now default to Protocol 2, so this isn't as common as
    it used to be. But at the time of this writing, Version 7 was just released and
    hasn't made its way into many distributions yet. Hopefully, by the time you read
    this, your distribution has upgraded to Version 7\. But if not, it's important
    that you ensure all of your servers utilize only Protocol 2 for SSH. You can achieve
    this by changing the relevant line in your `sshd_conf` file and then restarting
    the SSH service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another worthwhile change to SSH is changing the port it listens on. By default,
    SSH is listening on **Port 22**. You can confirm this with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Unless you changed it, the answer will be 22\. Since 22 is the default port
    for SSH, that's the port everyone (including the bad guys) expects it to be on.
    In the `/etc/ssh/sshd_config` file, there will be an option for the port near
    the top. If you change it to something else, it will be less obvious to outsiders.
    However, I don't want to lure you into a false sense of security here. Changing
    the port for SSH isn't a magical barrier against intrusion via SSH. In a targeted
    attack, a miscreant will scan every port on your server, so if they are determined,
    they'll figure out what port you changed it to. The reason why I recommend this
    change is because it's a very easy change to make. It requires only a few seconds
    to change your SSH port, and anything you can do to make your network less obvious
    to outsiders is a welcome change. The only time changing the SSH port can become
    a potential problem is if users of your network expect it to be on port 22\. As
    long as you communicate this change to everyone, it should be a non-issue.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to connect to a server with a non-standard SSH port, use the `-p`
    flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also designate the port while using `scp` as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note the `-P` parameter is uppercase in `scp` but not in the `ssh` command.
    This was intentional. The reason for this is because the lowercase `-p` option
    in `scp` was already taken, and it's used for preserving modification times when
    transferring files.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you can''t seem to get into the habit of requesting a different port for
    SSH, create an alias for it. However, this can be a problem if some of your hosts
    are still using port 22, so you would only use this alias if everything you connect
    to is on the same port. In the following example, we can set an alias to `ssh`
    to force it to always use port `63456`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Another very important change to your SSH configuration is to not allow root
    login. Under no circumstances should root login be allowed on any Linux server
    for any reason. If your configuration requires you to log in to a server as root
    via SSH, correct your configuration. To check to see if root login is enabled
    via SSH, run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If root login is enabled, disable it by correcting the following configuration
    line in `/etc/ssh/sshd_config`. However, make sure you are able to access the
    server via SSH with a normal user account first; otherwise, you''ll be locked
    out. The following configuration line in `sshd_config` will disallow root login:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As always, restart `ssh` after you make any changes to its configuration. Don't
    worry about restarting SSH while you are using it, current connections will not
    be disrupted.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Debian systems, execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'For CentOS systems, execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Another practice worth implementing is locking SSH down to only allow connections
    via specific users and/or groups. By default, any user with an account on the
    system is available via SSH. To change this, add the following line to the very
    bottom of the configuration file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If you have more than one user, you can add multiple users on the same line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also allow specific groups. First, create a group that you''ll use
    for SSH access:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, add one or more users to the group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Finally, add the following line to the bottom of your SSH configuration file.
    After you restart SSH, access will be restricted to those that are a member of
    this group. Each time you need to grant SSH access to someone, all you'll need
    to do is add their user ID to this group and you won't have to restart the `sshd_config`
    configuration file each time.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the most secure option for SSH is to not allow password-based authentication
    at all. Instead, users can use a public/private key pair for access. With this
    method, passwords are not transmitted over the network and those without a private
    key that matches an accepted public key are not allowed access. This is the practice
    that I recommend to everyone. On the down-side, it also comes with the most administrative
    overhead. To implement this change, each user will need to generate a key pair
    for SSH with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: You'll be asked several questions, most of which you can leave as the default.
    For the passphrase, come up with something unique and ensure it's not the same
    as your password. You can leave it blank if you don't want to be asked for a passphrase
    while making connections, but I recommend creating one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, the easiest way to configure a server to allow you to connect via a key
    is to import that key into the server, *before* you disable password authentication.
    To do that, use a variation of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: At this point, you'll be asked to log in to the server via your normal password.
    Then, the next time you connect to it, you will default to using the key pair
    you came up with and you'll be asked for your passphrase if you created one.
  prefs: []
  type: TYPE_NORMAL
- en: 'After all of your users have generated their key and imported it into the server,
    you can implement this change. Look for the line in the SSH configuration file
    that looks similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Simply change that option to no, restart SSH, and you should be all set. The
    reason that this works is because when you copy over your SSH key using the `ssh-copy-id`
    command, what it's actually doing is copying the contents of your public key (`~/.ssh/id_rsa.pub`)
    on your local machine to the end of the `~/.ssh/authorized_keys` file on the remote
    machine. With password authentication disabled, SSH will check that the key listed
    there matches your private key (`~/.ssh/id_rsa`) and then allow you access.
  prefs: []
  type: TYPE_NORMAL
- en: With these tweaks, your SSH implementation should be reasonably secure. It certainly
    won't help you if you use weak passwords or passphrases, but these are the general
    steps you should take on all servers.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the iptables firewall
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By default, Linux includes a firewall, **iptables**. This firewall should automatically
    be available on most (if not all) flavors of Linux. In this little activity, we'll
    set up a firewall on our Linux system. This should work fine regardless of which
    of the major distributions you use, but I'll call out anything that may be distribution
    specific. Before we get started though, I'll recommend that you play with this
    on a test machine, such as a VM or something you have physical access to. If you're
    using SSH, you may get disconnected when we enable the firewall, though I'll provide
    these steps in an order that hopefully, shouldn't drop your connection. Having
    a dedicated test machine to play around with is a good idea anyway.
  prefs: []
  type: TYPE_NORMAL
- en: 'With that out of the way, let''s get started. Unfortunately, by default, `iptables`
    is wide open. It''s so open, in fact, that it blocks nothing. To see this for
    yourself, issue `iptables -L` as root. Your output will probably look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'What you''re seeing here are three **chains** of `iptables`, each corresponding
    to input, output, and forwarding. If you haven''t configured this yet (and your
    distribution doesn''t offer any default configuration), you''ll likely see the
    default policy for each being `ACCEPT`, which means exactly what it sounds like:
    it allows everything.'
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the first rules I like to implement is to allow for SSH:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'With this command, we''re appending a new rule (`-A`) to our `INPUT` chain
    on the interface `eth0` using TCP and accepting traffic from `dport` (destination
    port) `22`. If you changed your SSH port earlier, be sure to adjust this command
    accordingly. Also, if your interface is not `eth0`, change that too. Of course,
    our firewall allows anything anyway, since we''ve never changed the default policy.
    If you recall, it accepts everything by default. Let''s change that with the following
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Now, if we view the output of `iptables -L`, we should see the default policy
    is `DROP` on everything and SSH is allowed.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there''s one problem—we can''t do anything else. We''re no longer
    able to install packages. Actually, we''re unable to do anything on the Internet
    at all. For example, try pinging Google. You won''t be able to. If you''ve followed
    along, we set our default policy to `DROP` and it really does mean `DROP`. No
    traffic is currently allowed to or from the server unless it''s SSH. In order
    to restore networking, we''ll need to allow a few more things. First, let''s allow
    DNS, which utilizes port `53`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Here, we're allowing port `53`, but only for our internal `10.10.96.0/22` network.
    Note that DNS uses UDP, so we included `-p udp` into our command. It goes without
    saying, but adjust the `10.10.96.0/22` portion for whatever your network scheme
    is.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we're still a bit more locked down on our system than we would
    like. For example, we have DNS now, but we wouldn't be able to browse the Internet
    without allowing ports `80` and `443`. Let's take care of that next.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'From this point forward, you should be able to browse the Internet on this
    machine and access it via SSH, though other ports and services shouldn''t be accessible.
    If the machine in question is a router, you might want to configure port forwarding
    as well. Here''s an example of port forwarding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we're forwarding traffic received on port `65254` to `10.10.96.10`.
    This example is useful if you have something like SSH available on a port other
    than `22` and would like to be able to access a computer (in this case, `10.10.96.10`)
    using that port. The server will now forward traffic it receives on that port
    to that computer. This uses the concept of `PREROUTING`, which handles incoming
    packets and is able to reassign them via NAT. In this case, we're using the firewall
    to create a NAT rule to send this traffic to the appropriate place.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the server you''re setting up this firewall on is destined to become a router,
    you''ll want to enable routing between interfaces as well. We took care of that
    from a Linux level in the last chapter, but since we configured the firewall to
    `DROP` everything by default, we can no longer do that. To continue to route between
    interfaces, we''ll need to enable routing within our firewall as well. To do that,
    we can use the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In the previous command, we're allowing routing between interfaces `eth0` and
    `eth1`. Adjust the previous commands to fit your distribution's network interface
    naming scheme so that it will fit your environment. We're also using `POSTROUTING`,
    which in terms of `iptables` is another word for outgoing traffic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another change that may be useful is allowing ping. With our configuration
    so far, ICMP ping packets are blocked. If you ping your server, you won''t get
    a response. We can re-enable ping responses via the following commands. Be sure
    to change the IP address to match that of your server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'If for some reason you''ve made a mistake or if you''d like to start this activity
    again, issue the following commands to flush (reset) the `iptables` firewall:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that this won''t undo your default policy, which you can explicitly set
    to `ACCEPT` if you''d like to undo everything we''ve done so far. We can set each
    table to it''s default (`ACCEPT`) with the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We choose `DROP` for our default policy because in this mode, the firewall does
    not respond to the sending host with a status when rejecting traffic. In a sense,
    it's almost as if packets are sent to an endless black hole when a policy is set
    to `DROP`. This is a good thing, because miscreants can use the response they
    get back from the server to better target their attacks. It's best for them to
    get no response at all.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, feel free to play around with `iptables` until you''ve gotten to a point
    where you are able to perform all the tasks that you normally were able to perform.
    Once you have a working and well-tested firewall, it''s time to save the configuration.
    Otherwise, all this hard work would be lost when you reboot. Use the following
    command to save your firewall configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'To import these rules, we can use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: You'll probably want these changes restored automatically every time the system
    boots. Both Debian and CentOS have their own ways to accomplish this. Here are
    the methods in which to save the rules.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Debian, first save the rules as we did before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create the following file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside that file, place the following text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'In CentOS, execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: From this point onwards, your firewall rules should persist each time you reboot
    the server.
  prefs: []
  type: TYPE_NORMAL
- en: Protecting system services with fail2ban
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A firewall is a great thing to have but it doesn't do much to protect services
    that are allowed. A firewall only goes as far as to allow or disallow access.
    But once access is allowed to a service, its security depends on its configuration
    and whether or not there are any security vulnerabilities. A service worth installing
    is **fail2ban**, which is a neat little tool that runs in the background and watches
    your logs for anything out of the ordinary, such as multiple failures to access
    a service. The most popular use of `fail2ban` is to protect SSH from those attempting
    to brute force it. In a lot of ways, `fail2ban` is the successor to **denyhosts**,
    which pretty much did the same thing. But `fail2ban` is able to protect more services
    than just SSH, another example being Apache.
  prefs: []
  type: TYPE_NORMAL
- en: 'When `fail2ban` sees that a source is attempting to access a service and is
    failing, it will set up a firewall rule on the fly to block that service from
    your server. To begin, install the `fail2ban` package on your server. In Debian
    systems, this is available in the default repositories. CentOS systems will find
    this package in the `epel` repository that we''ve set up in the past. Once installed,
    enable and start it with `systemctl` if it isn''t already using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `/etc/fail2ban` directory, you should see the main configuration
    file, `jail.conf`. It''s a good idea to copy this configuration to a local copy,
    because if you edit `jail.conf`, it''s always possible a package upgrade could
    overwrite it. The `fail2ban` service will read `jail.local` if it finds it and
    will not overwrite it if it were to be upgraded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have a local copy, we can now configure it to protect our services.
    Let''s start with SSH. To do so, open `/etc/fail2ban/jail.local` in a text editor
    and look for the `[ssh]` section. On my system, this section looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the configuration is fairly self-explanatory. The first line
    enables the SSH jail, it filters for traffic using `sshd`, and it looks in `/var/log/auth.log`
    for messages related to SSH. Although you've probably already noticed, we need
    to call out the SSH port in this file. If you stick with port 22, you can leave
    the relevant portions of the file as they are in your configuration. But if you
    changed your SSH port to something else, be sure to adjust accordingly. There
    are two places to place the port for SSH, the first on line three and the second
    on line five.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have our configuration in place, we can restart `fail2ban` in order
    to start securing SSH for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Take a look at the configuration file for other services that we may want to
    enable. An example could be Apache for our web server or even NGINX if you have
    that set up. The default configuration file contains a great deal of examples
    you can use. To use one, simply change `enabled = false` to `enable = true` and
    then restart `fail2ban`.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding SELinux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Security Enhanced Linux** (**SELinux**) is a kernel module intended to increase
    security by enforcing the **Mandatory Access Control**. This concept gives you
    the control to ensure that users and applications are only able to access the
    things that they absolutely need to in order to complete the tasks they are designated
    to perform. While firewalls help protect the system against intrusion from the
    outside, SELinux helps prevent resources on the inside from doing things that
    they aren''t supposed to be doing. This may sound vague, because it is how SELinux
    is used, and how you can benefit from it depends solely on how you implement it.
    Want to prevent a user from making a very private file world-readable? Sure, you
    can do that. Perhaps ensure Apache cannot access files outside of `/var/www`?
    You can do that too. Without SELinux, you would be relying solely on group and
    user permissions. SELinux helps you put more granular security restrictions in
    place by adding an additional layer of security to the mix.'
  prefs: []
  type: TYPE_NORMAL
- en: 'SELinux is not exclusive to any one distribution, though you''ll most commonly
    find it installed on Red Hat, Fedora, and CentOS systems. In a system such as
    Debian, you would need to install `selinux` if you wish to utilize it. Unfortunately,
    at the time of this writing, SELinux doesn''t function properly in Debian due
    to the fact that a required package (`selinux-policy-default`) contained bugs
    that weren''t fixed in time for Jessie''s release, so this package was omitted
    in the official Debian 8.x "Jessie" repositories. However, the process for installing
    SELinux in Debian (should this package become available after publication) comes
    down to installing that package along with `selinux-basics`. After those packages
    are installed, you should be able to finish your SELinux installations by running
    the following commands and rebooting the system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: SELinux works with policies to determine whether or not an action is allowed.
    Policies are created with tools that exist in something known as the **SELinux
    userspace**, and the actual checking is done at the kernel layer. Each distribution
    that implements SELinux by default, will typically ship with a tested and supported
    set of policies, such that all the services you would reasonably expect to work
    will function as they should. Without a default set of policies, configuring SELinux
    by hand can be a real pain (if it even starts). As mentioned earlier, Debian's
    policies package is currently not a part of the main repository, so enabling SELinux
    in Debian may be chaotic at this time. In the case of CentOS though, everything
    you need to utilize SELinux will be working out of the box. In fact, unless you've
    disabled it, you're already using it!
  prefs: []
  type: TYPE_NORMAL
- en: There are three modes of operation for SELinux and those are **enforcing**,
    **permissive**, and **disabled**. By default, most installations I've seen lately
    are set to `enforcing`, but you can see which of these three yours is set to,
    by executing `sestatus`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding SELinux](img/B03919_09_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Output from sestatus on CentOS
  prefs: []
  type: TYPE_NORMAL
- en: With `enforcing`, SELinux is configured with its policy enabled and will act
    on anything that goes against that policy. If a violation occurs, SELinux will
    prevent the action and log it. In `permissive` mode, actions are not blocked but
    everything is still logged so you can audit your server yourself later. The `disabled`
    state is self-explanatory; in that mode, SELinux will not block or log anything
    while it is disabled. It's quite common that administrators will simply disable
    SELinux, assuming it to be too much of a burden if it gets in the way of a legitimate
    use case. But disabling SELinux isn't recommended unless you absolutely have to,
    as it's another layer of security that you could otherwise be benefiting from.
    At the very least, you may want to benefit from the `permissive` mode so that
    you would have more information available within your logs should something suspicious
    start to happen on your server.
  prefs: []
  type: TYPE_NORMAL
- en: To change the mode of operation for SELinux on the fly, use the `setenforce`
    command. For example, use `setenforce Enforcing` to change the mode to `enforcing`.
    Changes made via `setenforce` are not permanent. Once you reboot your machine,
    the mode will switch back to its default or whatever you have configured in its
    configuration file. The configuration file to change the mode permanently is the
    /`etc/sysconfig/selinux` file in Red Hat style distributions, or `/etc/selinux/config`
    in Debian. This file allows you to configure the two main settings to determine
    how SELinux is configured, the **mode** and the **type**. To change either permanently,
    update this file and restart the server. We already discussed the mode (it can
    be set to `enforcing`, `permissive`, or `disabled`), and the type is where we
    configure which policy we would like SELinux to use. This can be set to `targeted`,
    `minimum`, or multi-level security (`mls`).
  prefs: []
  type: TYPE_NORMAL
- en: In regards to updating the policy, `targeted` is the process that is in use
    by default on new installations (at least when it comes to Red Hat/CentOS), and
    it is fully supported by Red Hat. With this policy, every process runs in a type
    called `unconfined_t`, which is actually not restricted at all. Instead, processes
    will run under the Linux native **DAC** (short for **Discretionary Access Control**),
    which sandboxes them from other processes to help contain anything that may have
    been compromised. **MLS**, or **Multi-Level Security**, applies a sensitivity
    rating to objects, designated by `s0`, when it's enabled. (By executing `sestatus`,
    you can see whether or not MLS is enabled). We'll see some examples of context
    output shortly. With the minimum type, only processes we explicitly select will
    be safeguarded.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every resource in a SELinux-enabled system contains a **label**, which is how
    SELinux identifies a resource and understands how to police it. You can see these
    labels (also known as contexts) yourself by using the `-Z` parameter with one
    or more commands, such as `ls`, `id`, or `ps`. This special parameter is available
    to these commands only when a system is configured to utilize SELinux, and it
    allows you to view the context as part of the normal output. For example, you
    can use the `-Z` parameter with the `ls` command on a SELinux system and you would
    see an output like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Normally, the output of the `ls` command would contain fields such as the modification
    date and size when viewing output of a command such as `ls`. But again, the `-Z`
    parameter is special. It implies that you would like to see the output of the
    command as it pertains to SELinux, rather than the output you would normally get.
    You can also try it with `id` (`id -Z`), and `ps` (`ps auxZ`) to have the output
    of those commands show you their SELinux context as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'The label contains multiple fields. In the output from the `ls` command I pasted,
    we can see the fields `unconfined_u`, `object_r`, `admin_home_t`, and `s0`. To
    better understand this, look at the last few characters of each. The `_u` designates
    the user, `_r` designates the role, and `_t` represents the type. Therefore, we
    can see from the previous output that the file called `myfile` has a user context
    of `unconfined_u`; it''s assigned the role of `object_r` and a type of `admin_home_t`.
    Let''s look at another example. In the output of `ps auxZ` on my CentOS system,
    I see the following line for my SSH session:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Looking at the beginning of the line, we again have context for user, role,
    and type. In this case, each are named unconfined, but we can tell which is what
    by the last two characters.
  prefs: []
  type: TYPE_NORMAL
- en: The type is the most important part of the output, because this is how SELinux
    does its enforcing. Given the type, SELinux knows how to restrict (or not to restrict)
    the object. In the first example, we have `admin_home_t`, and we have `unconfined_t`
    in the second example. From this, we can gather that SELinux isn't enforcing anything
    with my SSH session (`unconfined_t`) but has a specific policy in place for my
    home directory, which is where the output of the file came from. Another context
    we have seen in the example output is the role, designated by a suffix `_r`. When
    applying a role, SELinux is able to group together various contexts and apply
    them to a user object with one call. This makes it easier to designate what users
    are able to do and how they're allowed to interact with other objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several commands that can be used to relabel the context information
    of an object. To begin, there''s the `chcon` command. The `chcon` command is used
    with the `-t` parameter, which designates the type you would like to change the
    object to, followed by the name of the object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Using `-R`, we tell the `chcon` command to make the changes recursively, which
    is great if you're changing the context of a directory. In addition, you can also
    use `-r` if you'd like to change the role instead of the type. If you make a mistake
    or you'd like to revert your changes, `restorecon` does exactly that. The `restorecon`
    command will revert an object to its default state, as defined in its policy.
    Another command for managing SELinux is `semanage`. With this command, we can
    make permanent changes to how objects are treated and labeled. It's important
    to note that changes via `chcon` might not always persist. While changes via `chcon`
    will likely survive a reboot, they persist if the filesystem gets relabeled. The
    `semanage` command allows us to make these changes more permanent. Using `semanage`,
    we can make changes to file contexts, user mappings, as well as user contexts.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, an example of mapping user `jdoe` to the `sysadm_u` SELinux user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, here''s an example of using `fcontext` along with `semanage`, we can
    change what types file objects belong to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: See the man pages for `semanage` for even more examples. SELinux is a large
    subject matter for which entire books have been written. A complete walkthrough
    of SELinux would take multiple chapters, but the information given here should
    serve as an adequate primer. When implemented properly, it can greatly enhance
    security on your servers.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Apache to utilize SSL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The [Chapter 7](ch07.html "Chapter 7. Hosting HTTP Content via Apache"), *Hosting
    HTTP Content via Apache* was all about Apache. There, we walked through how to
    get it running and configured in order to host a site on our network. But if we
    were to create a site that would potentially host personally identifiable information,
    we would want to make sure that we use proper security measures in order to protect
    that information. Using **SSL** certificates for our site allows it to be accessed
    over secure port 443, thus enhancing security. Utilizing SSL isn't the only measure
    we can make in order to increase security of our web server, but it's definitely
    a start.
  prefs: []
  type: TYPE_NORMAL
- en: There are two kinds of certificates we can use. We can create a self-signed
    certificate, or we can register a certificate with a **Certificate Authority**
    (**CA**). The latter is preferred, though if you are only creating a site for
    internal use, it may be too much overhead. The difference is a self-signed certificate
    isn't trusted by any browser, since it wouldn't have come from a known CA. When
    you visit a site with such a certificate, it will complain that the certificate
    of the site isn't valid. This isn't necessarily true, because a self-signed certificate
    can certainly be valid; it's just that the browser has no way of knowing for sure.
    Getting a certificate registered with a CA would alleviate this, but at a cost.
    Registered certificates can be expensive, depending on the scope. The choice is
    yours.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'On Debian systems, make sure you enable SSL with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: To begin, you would first choose a location on the filesystem of your webserver
    that will host the certificate files. There's no hard rule here, the only requirement
    is that Apache can access it (and preferably, no one else can!). Some good candidates
    include `/etc/apache2/ssl` in Debian and `/etc/httpd/ssl` in CentOS. I put mine
    in `/etc/certs`. Whichever path you choose, change into that directory and then
    we will continue.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you''ve decided to create a self-signed certificate, you can do so with
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'As your certificate gets generated, you will be asked for some information
    pertaining to your organization, contact information, and domain. Here''s an example
    of the questions you''ll be asked and some example answers:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Country name: US`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`State or Province Name: Michigan`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Locality Name (City): White Lake`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Organization Name: My Company`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Organizational Unit Name: IT Dept`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Common Name (Fully Qualified Domain Name): myserver.mydomain.com`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Email Address: webmaster@mycompany.com`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This will create two files for you in your current working directory, `server.key`
    and `server.crt`. The filenames for those files is arbitrary, you can name them
    whatever you like. Now, we would need to make sure that our web server is able
    to find and use these files.
  prefs: []
  type: TYPE_NORMAL
- en: 'On Debian web servers, we can do this by editing `/etc/apache2/sites-available/default-ssl.conf`.
    In that file, there will be a section for us to add our directives that will enable
    our keys. Look for a section that has some comments regarding SSL. Within that
    section, add the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'In CentOS, we would add the same lines to the `/etc/httpd/conf/httpd.conf`
    file, but with the `SSLEngine on` directive as well. This should go in it''s own
    `VirtualHost` directive, similar to the example that follows. Just be sure to
    change the paths to match how your web server has been set up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Setting up a signed SSL certificate is similar, but the difference is in how
    you request it. The process entails creating a **Certificate Request** (**CSR**)
    that you will submit to your provider, which will in turn provide you with a signed
    certificate. The end result is the same—the files will end up in the same place.
    You''ll just use the files given to you by your provider after submitting the
    CSR. Let''s begin by creating a CSR, which we will use the `openssl` command to
    generate for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: You'll be asked the same question as before, but notice that we're telling `openssl`
    to give us a `.csr`, so we will have a `server.csr` file in our working directory
    we will use to request a key from our CA. After you receive the files from your
    certificate provider, you would just update Apache as we have done earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying security updates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While it may seem like common sense to those of you more seasoned in security,
    updates for your distribution are released for a reason. In some cases, updates
    serve only to add new features or update software to the latest version. But in
    the case of Enterprise distributions such as CentOS and Debian, these are even
    more important.
  prefs: []
  type: TYPE_NORMAL
- en: This is one of the ways consumer-based distributions and Enterprise distributions
    differ. Distributions such as Ubuntu's non-LTS releases, Linux Mint, and Fedora
    receive more bleeding-edge packages than Enterprise distributions such as CentOS,
    Debian, and Red Hat. This is because the end user typically wants the latest versions
    of their web browser, e-mail client, word processor, or games. This doesn't matter
    much when it comes to the Enterprise. In the Enterprise, security updates are
    critical. While consumer-oriented distributions surely keep up to date with security
    patches on almost an equal level in most cases, these are intermixed with feature
    updates that may impair stability more than help it.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of Debian, both styles are actually offered. The main distribution,
    which is known as **Debian stable**, receives little more than security patches.
    Even the default web browser (Iceweasel) isn't updated as often as Firefox would
    be on other platforms. The idea here is that change represents potential breakage.
    Quite a bit of work goes into ensuring that the packages you get in stable are
    tried and true, rather than the latest and greatest. This concept is similar to
    CentOS as well, though its packages generally tend to be older than those in Debian.
    To give you an idea of this, at the time of my writing this chapter, the latest
    Linux kernel is 4.1\. Debian Jessie (the latest "Stable") includes kernel 3.16,
    while CentOS 7 is even older at 3.10\. Not that there's nothing wrong with the
    kernel being old, I just mentioned it to give you an example. Both Red Hat and
    Debian have more bleeding-edge distributions available. **Fedora** is sponsored
    by Red Hat and includes more up to date packages. It's geared toward users who
    prefer to have the latest software. **Debian testing** also includes more up to
    date packages, though it's not nearly as stable as Fedora, facing package breakages
    from time to time. Debian testing is targeted toward those who would like to test
    the next release of Debian, as Debian testing eventually becomes the new Debian
    stable as it matures.
  prefs: []
  type: TYPE_NORMAL
- en: For security purposes, installing the latest security updates is critical. It's
    true that Linux is more secure and stable than many other platforms, but regardless
    of how secure the operating system is, at the end of the day, it's only as secure
    as how it's managed. An installation of a Linux distribution that's behind in
    updates is a sitting duck in the case of an exploitable vulnerability being discovered.
  prefs: []
  type: TYPE_NORMAL
- en: Given the existence of end-user and Enterprise distributions, managing their
    security updates can be a challenge. If your organization uses Linux on both servers
    as well as end-user machines, you may very well employ both types of distributions.
    This is because while CentOS is secure and stable, you're unlikely to be successful
    deploying it to end-user machines. Since the CentOS kernel is a bit older, it
    won't support all the new hardware that's available for end-user workstations
    today. In addition, there aren't as many customizations in place to make it reasonable
    for desktop or laptop use. While it can be done (and many people do), installing
    CentOS on an end-user device is typically an exercise in frustration. For end-user
    machines, you might opt for Ubuntu, Linux Mint, or Fedora instead. But with those,
    you would need to spend more time focusing on which updates are for security and
    which updates are for new features in applications. Depending on the nature of
    the update, you may choose to roll it out differently.
  prefs: []
  type: TYPE_NORMAL
- en: Ideally, in a perfect server room, all updates for servers would be installed
    immediately upon their release, there would never be any issues and everything
    would always go smooth. But in reality, there are challenges in keeping security
    updates current. Perhaps a regression may be present that stops an important application
    from running. Alternatively, perhaps an error in packaging actually breaks the
    RPM database (which is an extremely frustrating experience!), so while updates
    are important, some exercise in caution is needed as well.
  prefs: []
  type: TYPE_NORMAL
- en: The best policy, or at least one I've found that works well for me, is creating
    testing servers that can be used to test changes before you roll them out into
    production. In the case of virtual machine servers, you can even clone production
    servers and test updates or other changes on them to see how they will react if
    they were rolled out into production. Then, you can be reasonably confident that
    new updates won't break production servers. To be fair, these types of situations
    rarely happen. But given the flexibility of Linux and the fact that Linux servers
    are easy to clone, there's no reason not to do testing.
  prefs: []
  type: TYPE_NORMAL
- en: In CentOS systems, you can use the `yum update` command to update all the packages
    on your server. You can use `yum update` along with the name of a package to update
    just that package. In Debian systems, you can use `apt-get update` to refresh
    your sources, and then you can use `apt-get install` with a package name to update
    a package. To update everything, you would update your sources and then run `apt-get
    dist-upgrade`.
  prefs: []
  type: TYPE_NORMAL
- en: In real-world installations, you would probably not update all available packages
    on your server. Instead, one method is to update packages as needed. This requires
    a great deal of research on the part of the administrator, in order to pay attention
    to current security trends and then pick the security updates that impact services
    that are currently being used in production. For Debian and Red Hat based systems,
    there are two handy web sites pertaining to **Common Vulnerabilities and Exposures**
    (**CVE**) that you should have bookmarked.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Red Hat use the following URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://access.redhat.com/security/cve/](https://access.redhat.com/security/cve/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'For Debian use the following URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://security-tracker.debian.org/tracker](https://security-tracker.debian.org/tracker)'
  prefs: []
  type: TYPE_NORMAL
- en: Both sites allow you to view individual CVE reports, which will inform you about
    vulnerable packages and whether or not they were patched. In some cases, a CVE
    may not even be exploitable in your particular distribution, in which case you
    wouldn't need to do anything. But by following these reports, you can make an
    informed decision regarding what potential vulnerabilities may affect your organization.
    This will allow you to create a plan to roll out the necessary patches onto your
    servers.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Security is a very complex subject. So complex that no one person can become
    an all-knowing expert, as even the top people in the industry are continually
    learning. Likewise, it's statistically impossible to create a bulletproof server
    that cannot be compromised. But as a network administrator, you have a role in
    doing the best you can to keep your nodes as secure as you're able to. Security
    is often reactionary, which requires you to be on your toes. In this chapter,
    we took a look at some of the ways you can help safeguard your network from risks.
    We covered concepts such as securing SSH, limiting your attack surface, securing
    Apache with SSL, fail2ban, and deploying security updates.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll look into things you can do to troubleshoot issues
    when things go wrong.
  prefs: []
  type: TYPE_NORMAL
