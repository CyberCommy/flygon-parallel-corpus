- en: Designing World-Ready Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using a programming language in production-ready projects is a whole new step
    in learning the language itself. Sometimes, the simple examples in this book may
    take a different approach or face many difficulties in real-world programs. When
    theory meets practice is when you learn the language. C++ is not an exception.
    It's different to learn syntax, solve some book problems, or understand somewhat
    simple examples in books. When creating real-world applications, we face a different
    range of challenges, and sometimes books lack the theory to back the practical
    issues on the road.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will try to cover the basics of practical programming with
    C++ that will help you to tackle real-world applications better. Complex projects
    require a lot of thinking and designing. Sometimes, programmers have to completely
    rewrite the project and start from scratch just because they have made bad design
    choices at the beginning of development. This chapter tries its best to illuminate
    the process of designing software. You will learn the steps to better architecture
    for your projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the project development life cycle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design patterns and their applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Domain-driven design
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing an Amazon clone as an example of a real-world project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The g++ compiler with the `-std=c++2a` option is used to compile the examples
    throughout this chapter. You can find the source files used in this chapter at [https://github.com/PacktPublishing/Expert-CPP](https://github.com/PacktPublishing/Expert-CPP)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Project development life cycle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whenever you approach a problem, you should carefully consider the process of
    the requirements analysis. One of the biggest mistakes in project development
    is starting coding without a thorough analysis of the problem itself.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine a situation where you are tasked with creating a calculator, a simple
    tool that allows users to make arithmetic calculations on numbers. Let's say you
    have magically completed the project on time and released the program. Now, users
    are starting to use your calculator and sooner or later they find out that the
    result of their calculations doesn't exceed the maximum size of an integer. When
    they complain about this issue, you are ready to defend yourself (and your creation)
    with solid coding-backed arguments such as it's because of using the `int` data
    type in calculations. It's totally understandable for you and your fellow programmers,
    but end users just can't take your arguments. They want a tool that allows summing
    some big enough numbers, otherwise, they won't use your program at all. You start
    working on the next version of your calculator and this time, you use longs or
    even custom implemented big numbers. You proudly ship your program to users waiting
    for their applause when you suddenly realize that the same users complain of not
    having the functionality to find logarithms or exponents of numbers. This seems
    daunting because there might be more and more feature requests and more and more
    complaints.
  prefs: []
  type: TYPE_NORMAL
- en: Though this example is somewhat simple, it totally covers what usually happens
    in the real world. Even when you implement all of the features for your program
    and are thinking about taking a long-deserved vacation, users will start complaining
    about the bugs in the program. It turns out that there are several cases when
    your calculator behaves unexpectedly and gives no or wrong results. Sooner or
    later, you realize that proper testing is what you actually need before releasing
    the program to the masses.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will touch on the subjects that should be considered when working on real-world
    projects. Whenever you are starting a new project, the following steps should
    be taken into account:'
  prefs: []
  type: TYPE_NORMAL
- en: Requirements gathering and analysis
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Specification creation
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Design and test planning
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Coding
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Testing and stabilization
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Release and maintenance
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The preceding steps are not hardcoded for every project, though it might be
    considered as the bare minimum that every software development team should complete
    to achieve a successful product release. In reality, most of the steps are omitted
    due to the single thing everyone in the IT field lacks the most— time. However,
    it is strongly recommended to follow the preceding steps because, eventually,
    it will save more time in the long- term.
  prefs: []
  type: TYPE_NORMAL
- en: Requirements gathering and analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is the most crucial step in creating a stable product. One of the most
    popular reasons that programmers fail to complete their tasks on time or leave
    a lot of bugs in code is the lack of a complete understanding of the project.
  prefs: []
  type: TYPE_NORMAL
- en: The domain knowledge is so important that it shouldn't be omitted in any circumstance.
    You might be lucky to develop projects that are related to something you know
    very well. However, you should take into account that not everyone is as lucky
    as you (well, you might be that unlucky, too).
  prefs: []
  type: TYPE_NORMAL
- en: Imagine that you are working on a project that automates the analysis and reporting
    of the stock trading in some company. Now imagine that you know nothing about
    stocks and the stock trading at all. You don't know about the bear or bull markets,
    the limitations in trading transactions, and so on. How would you complete the
    project successfully?
  prefs: []
  type: TYPE_NORMAL
- en: Even if you know about the stock markets and trading, you might be unaware of
    your next big project domain. What if you are tasked with designing and implementing
    (with or without a team) a project that controls the weather stations of your
    city? What you are going to do first when starting the project?
  prefs: []
  type: TYPE_NORMAL
- en: You should definitely start with requirements gathering and analysis. It's just
    a process that involves communicating with the client and asking a lot of questions
    about the project. If you are not dealing with any client but work in a product
    company, the project manager should be treated as the client. Even if the project
    is your idea and you are working alone, you should treat yourself as the client
    and, though it might sound ridiculous, ask yourself a lot of questions (about
    the project).
  prefs: []
  type: TYPE_NORMAL
- en: Let's suppose we are going to conquer e-commerce and want to release a product
    that will eventually beat the market sharks in their own business. Popular and
    successful e-commerce marketplaces are Amazon, eBay, Alibaba, and some others.
    We should state the problem as *writing our own Amazon clone*. What should we
    do to gather the requirements for the project?
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we should list all of the features that we should implement and
    then we''ll prioritize. For example, for the Amazon clone project, we might come
    up with the following list of features:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a product.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: List products.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Buy a product.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Edit product details.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remove a product.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Search for products by name, price range, and weight.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Alert the user on product availability once in a while via email.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Features should be described in detail as much as possible; that will sort things
    out for the developer (you, in this case). For example, creating a product should
    be done either by the project administrator or any user. If a user can create
    a product, it should have limitations, if any. There might be cases that a user
    will mistakenly create hundreds of products in our system to increase the visibility
    of their only product.
  prefs: []
  type: TYPE_NORMAL
- en: Details should be stated, discussed, and finalized during communications with
    the client. If you are alone in the project and you are the client of your project,
    the communication is the process of *thinking for yourself* on the project requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 'When finished getting requirements, we suggest prioritizing each feature and
    classifying them into one of the following categories:'
  prefs: []
  type: TYPE_NORMAL
- en: Must have
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Should have
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nice to have
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After thinking a little bit more and categorizing the preceding features, we
    could come up with the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a product [must have].
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: List products [must have].
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Buy a product [must have].
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Edit product details [should have].
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remove a product [must have].
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Search for products by name [must have].
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Search for products by price range [should have].
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Search for products by weight [nice to have].
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Alert the user on product availability once in a while via email [nice to have].
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The classification will give you a basic idea of where to start first. Programmers
    are greedy people; they want to implement every possible feature out there for
    their products. It's a sure way toward failure. You should start from the most
    essential features first—that's why we have a couple of nice-to-have features.
    Some jokingly insist that nice-to-have features should be renamed to never-have
    features because, in practice, they never get implemented.
  prefs: []
  type: TYPE_NORMAL
- en: Specification creation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Not everyone likes creating specifications. Well, most programmers hate this
    step because it's not coding—it's writing.
  prefs: []
  type: TYPE_NORMAL
- en: After gathering project requirements, you should create a document that includes
    every detail that describes your project. There are many names and types for this
    specification. It might be called a **Project Requirements Document** (**PRD**),
    a** functional specification**, a** development specification**, and so on. Serious
    programmers and serious teams produce a PRD as a result of the requirements analysis.
    The next step of these serious guys is creating the functional specification along
    with the development specification and so on. We combine all of the documentation
    in a single step named **specification creation. **
  prefs: []
  type: TYPE_NORMAL
- en: It's up to you and your team to decide whether you need any of the sub-documents
    mentioned previously. It is even better to have a visual representation of the
    product rather than a text document. Whatever the form your document takes, it
    should carefully represent what you've achieved in the requirements gathering
    step. To have a basic understanding of this, let's try to document some of the
    features that we've collected earlier (we will refer to our project as *the platform)*
  prefs: []
  type: TYPE_NORMAL
- en: Create a product. A user of the platform having administrator privileges can
    create a product.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The platform must allow creating users with defined privileges. At this point,
    there should be two types of users, namely regular and administrator users.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any user using the platform must be able to see the list of available products.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A product should have images, a price, name, weight, and description.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To buy a product, the user provides their card details to cash out and details
    for the product shipment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each registered user should provide a delivery address, credit card details,
    and an email account.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The list might go long and it actually should go long because the longer the
    list, the more the developers understand the project.
  prefs: []
  type: TYPE_NORMAL
- en: Design and test planning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Though we insisted on the requirement gathering step as the most crucial in
    software development, the designing and test planning can be considered an equally
    crucial step as well. If you have ever started a project without designing it
    first, you already have the idea of its impossibility. Though motivational quotes
    insist that nothing is impossible, programmers are sure that at least one thing
    is impossible and that is finishing a project successfully without designing it
    first.
  prefs: []
  type: TYPE_NORMAL
- en: 'The process of designing is the most interesting step; it forces us to think,
    draw, think again, clear everything, and start over. Many features of the project
    are discovered while designing it. To design a project, you should start from
    the top. First of all, list all of the entities and processes that are somehow
    involved in the project. For the Amazon clone example, we can list the following
    entities and processes:'
  prefs: []
  type: TYPE_NORMAL
- en: Users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Registration and authorization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Products
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transactions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Warehouses (containing products)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shipment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is a high-level design—a starting point to move through the final design.
    In this chapter, we will mostly concentrate on the design of the project.
  prefs: []
  type: TYPE_NORMAL
- en: Decomposing entities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After listing key entities and processes, we move to decompose them into more
    detailed entities that will be transformed into classes later. It''s even better
    to sketch the design of the project. Just draw rectangles containing names of
    entities and connect them with arrows if they are somehow connected together or
    are parts of the same process. You can start an arrow from entity A to entity
    B if there is a process that includes or is started by the entity A and is finished
    at or results in entity B. It doesn''t matter how good the drawing is, it''s a
    necessary step toward a better understanding of the project. For example, look
    at the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/747174ee-fe32-4e39-930e-9add32033617.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Decomposing entities and processes into classes and their intercommunication
    is a subtle art requiring patience and consistency. For example, let''s try to
    add details for the **User** entity. As stated in the specification creation step,
    a registered user should provide a delivery address, an email address, and credit
    card details. Let''s draw a class diagram that represents a user:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/62615d23-0f68-42b3-914a-380356d7ba16.png)'
  prefs: []
  type: TYPE_IMG
- en: 'And here comes the interesting question: what should we do with complex types
    contained within the entity? For example, the delivery address of a user is a
    complex type. It couldn''t be just `string`, because sooner or later we might
    need to sort users by their delivery addresses to make optimal shipments. For
    example, a shipment company might cost us (or the user) a fortune if the delivery
    address of the user is in a different country than the address of the warehouse
    that contains the purchased product. This is a great scenario because it introduces
    a new problem and updates our understanding of the project. It turns out that
    we should handle situations when a user orders a product that is assigned to a
    specific warehouse physically located far from the user. If we have many warehouses,
    we should choose the nearest one to the user that contains the required product.
    These are questions that couldn''t be answered right away, but that is the quality
    result of designing the project. Otherwise, these questions would have risen during
    the coding and we would have been stuck at them longer than we thought we would.
    The initial estimation of the project wouldn''t meet its completion date in any
    known universe.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, how would you store the user address in the `User` class? A simple `std::string`
    would be fine as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'An address is a complex object in terms of its components. An address might
    consist of the country name, country code, city name, and street name, and it
    might even contain latitude and longitude. The latter is great if you need to
    find the nearest warehouse to the user. It''s totally fine to make more types
    that would make the design more intuitive for programmers. For example, the following
    struct might be a good fit to express the address of a user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, storing a user address becomes even simpler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We will get back to this example later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The process of designing the project might require to go back a couple of steps
    to restate project requirements. After clarifying the design step with the previous
    steps, we can move forward to decompose the project into smaller components. It's
    better to create interaction diagrams, too.
  prefs: []
  type: TYPE_NORMAL
- en: 'An interaction diagram like the following would depict operations such as a
    transaction made by a **user** to **purchase** a product:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0fc423b9-d3fb-4643-abb0-aadd1f55632b.png)'
  prefs: []
  type: TYPE_IMG
- en: Test planning can also be considered as part of the design. It includes planning
    how the final application will be tested. For example, the steps before this include
    a concept for an address and as it turned out, the address can contain a country,
    city, and so on. A proper test should include checking whether a value for the
    country can be set successfully in the user address. Though test planning is not
    considered a programmer task in general, it is still a good practice to do it
    for your projects. A proper test plan would produce more useful information while
    designing the project. Most of the input data processing and security checks are
    discovered at test planning. For instance, setting a strict limit on the user
    name or email address might not be the case when doing a requirement analysis
    or writing a functional specification. Test planning cares for such scenarios
    and forces developers to take care of data checks. However, most programmers are
    impatient to reach the next step of project development, coding.
  prefs: []
  type: TYPE_NORMAL
- en: Coding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As already said earlier, coding is not the only part of project development.
    Before coding, you should carefully design your project by leveraging all of the
    requirements projected in the specification. Coding is a lot easier and more productive
    after the previous steps of project development are completed thoroughly.
  prefs: []
  type: TYPE_NORMAL
- en: Some teams practice **Test-Driven Development (TDD)**, which is a great way
    to produce even more stable project releases. The main concept of TDD is to write
    tests before the project implementation. It's a good way for programmers to define
    project requirements and answer further questions rising during the development.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s suppose we are implementing setters for the `User` class. The user object
    contains an email field discussed earlier, which means that we should have a `set_email()` method, as
    shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The TDD approach suggests writing a test function for the `set_email()` method
    before implementing the `set_email()` method itself. Let''s say we have the following
    test function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we've declared two `string` variables, one of them containing
    an invalid value for an email address. Even before running the test function,
    we know that, in the case of invalid data input, the `set_email()` method should
    react somehow. One of the common approaches is throwing an exception indicating
    the invalid input. You could also ignore the invalid input in the `set_email`
    implementation and return a `boolean` value indicating the success of the operation.
    The error handling should be consistent in the project and agreed by all team
    members. Let's consider that we are going with throwing an exception, therefore,
    the test function should expect an exception when passing an invalid value to
    the method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding code is then should be rewritten as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The test function seems complete. Whenever we run the test function, it outputs
    the current state of the `set_email()` method. Even if we haven't yet implemented
    the `set_email()` function, the corresponding test function is a big step toward
    its implementation details. We now have the basic idea of how should the function
    react to valid and invalid data inputs. We can add more kinds of data to make
    sure the `set_email()` method will be thoroughly tested when its implementation
    is complete. For example, we can test it with empty and long strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an initial implementation of the `set_email()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: After the initial implementation of the method, we should run our test function
    again to make sure that the implementation conforms with the defined test cases.
  prefs: []
  type: TYPE_NORMAL
- en: Writing tests for your project is considered as a good coding practice. There
    are different types of tests, such as unit tests, regression tests, smoke tests, and
    so on. Developers should support unit test coverage for their projects.
  prefs: []
  type: TYPE_NORMAL
- en: The process of coding is one of the steps in the project development life cycle
    that is the most chaotic. It's hard to estimate how long will the implementation
    of a class or its methods will take because most of the questions and difficulties
    arise during coding. The previous steps of the project development life cycle
    described at the beginning of this chapter tend to cover most of these questions
    and ease the process of coding.
  prefs: []
  type: TYPE_NORMAL
- en: Testing and stabilization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After the project is done, it should be properly tested. Usually, software development
    companies have **Quality Assurance** (**QA**) engineers who meticulously test
    the project.
  prefs: []
  type: TYPE_NORMAL
- en: Issues verified during the testing phase are converted into corresponding tasks
    assigned to programmers to fix them. Issues might affect the release of the project
    or might be classified as minor issues.
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic task of the programmer is not fixing the issue right away, but finding
    the root cause of the issue. For the sake of simplicity, let''s take a look at
    the `generate_username()` function that uses random numbers combined with the
    email to generate a username:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `generate_username()` function calls `get_random_number()` to combine the
    returned value with the local part of the email address. The local part is the
    part before the `@` symbol in the email address.
  prefs: []
  type: TYPE_NORMAL
- en: QA engineers reported that the number attached to the local part of the email
    is always the same. For example, for the email `john@gmail.com`, the generated
    username is `john42`, and for `amanda@yahoo.com`, it's `amanda42`. So, the next
    time a user with the email `amanda@hotmail.com` tries to register in the system,
    the generated username, `amanda42`, conflicts with the already existing one. It's
    totally fine for testers not to be aware of the implementation details of the
    project, so they report it as an issue in the username generation functionality.
    While you might already guess that the real issue is hidden in the `get_random_number()`
    function, there can always be scenarios where the issue is fixed without finding
    its root cause. The wrong approach fixing the issue could mutate the implementation
    of the `generate_username()` function. The `generate_random_number()` function
    might be used in other functions as well, which in turn, will make all of the
    functions that call `get_random_number()` work incorrectly. Though the example
    is simple, it is crucial to think deeper and find the real reason behind the issue.
    That approach will save a lot of time in the future.
  prefs: []
  type: TYPE_NORMAL
- en: Release and maintenance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After making the project somewhat stable by fixing all of the critical and major
    issues, it can be released. Sometimes companies release software under the **beta**
    label, hence providing an excuse in case users find it buggy. It's important to
    note that there are rare cases of software that works flawlessly. After releasing
    it, more issues will arise. So, there comes the maintenance phase, when developers
    are working on fixes and release updates.
  prefs: []
  type: TYPE_NORMAL
- en: Programmers sometimes joke that release and maintenance are steps that are never
    achieved. However, if you spend enough time designing the project, releasing its
    first version won't take much time. As we have already introduced in the previous
    section, designing starts with requirements gathering. After that, we spend time
    on defining entities, decomposing them, breaking down into smaller components,
    coding, testing, and finally, releasing it. As developers, we are more interested
    in the designing and coding phases. As already noted, a good design choice has
    a great impact on further project development. Let's now have a closer look at
    the design process overall.
  prefs: []
  type: TYPE_NORMAL
- en: Diving into the design process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As introduced earlier, the project design starts with listing general entities,
    such as users, products, and warehouses when designing an e-commerce platform:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b8991f30-493e-4e8f-84d7-02f1b58ed92e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We then decompose each entity into smaller components. To make things clearer,
    consider each entity as a separate class. When thinking of an entity as a class,
    it makes more sense in terms of decomposition. For example, we express the `user`
    entity as a class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The class diagram for the `User` class is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bd7b14fe-6cee-47bd-be57-e54cd658200b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'However, as we''ve already discussed, the address field of the `User` class
    might be represented as a separate type (`class` or `struct`, it doesn''t matter
    much yet). Whether it''s a data aggregate or a complex type, the class diagram
    takes the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a62f3623-ed77-4cca-9d29-fffe8c9a0bfc.png)'
  prefs: []
  type: TYPE_IMG
- en: The relations between these entities will become clear during the design process.
    For example, the **Address** isn't an entity on its own, it's a part of the **User**,
    that is, it couldn't have an instance if a **User** object isn't instantiated.
    However, as we might want to gesture toward reusable code, the **Address** type
    might be used for warehouse objects as well. That is, the relation between the
    **User** and **Address** is a simple aggregation rather than a composition.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving forward, we could come up with more requirements for the **User** type
    when discussing the payment options. Users of the platform should be able to insert
    an option for paying for products. Before deciding on how will we represent payment
    options in the `User` class, we should find out what those options are, after
    all. Let''s keep it simple and suppose that a payment option is one that contains
    a credit card number, the name of the cardholder, the expiration date, and the
    security code of the card. It sounds like another data aggregation, so let''s
    collect all of that in a single struct, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note `std::chrono::year_month` in the preceding struct; it represents a specific
    month of a specific year and is introduced in C++20\. Most payment cards carry
    only the month and year of the card expiration, so this `std::chrono::year_month` function
    is perfect for `PaymentOption`.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in the process of designing the `User` class, we came up with a new type,
    `PaymentOption`. A user can have more than one payment option, so the relation
    between `User` and `PaymentOption` is one-to-many. Let''s now update our `User`
    class diagram with this new aggregation (though we go with composition in this
    case):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c85c2d3a-0d3f-4143-8879-b5cf71ef29dd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The dependency between `User` and `PaymentOption` is represented in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We should note that even though a user might have more than one payment option
    set up, we should mark one of them as primary. That's tricky because we could
    store all of the options in a vector, but now we have to make one of them the
    primary.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use a pair or `tuple` (if being fancy) to map an option in the vector
    with a `boolean` value, indicating whether it''s primary or not. The following
    code depicts the usage of a tuple in the `User` class introduced earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We can simplify the code by leveraging type aliases in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s how the class user can retrieve the primary payment option for a user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We used structured binding when accessing the tuple items in the `for` loop.
    However, after studying the chapter about data structures and algorithms, you
    are now aware that searching the primary payment option is a linear operation.
    It might be considered a bad practice to loop through the vector each time we
    need to retrieve the primary payment option.
  prefs: []
  type: TYPE_NORMAL
- en: You might change the underlying data structure to make things run faster. For
    example, `std::unordered_map` (that is, a hash table) sounds better. However,
    it doesn't make things faster just because it has constant-time access to its
    elements. In this scenario, we should map a `boolean` value to the payment option.
    For all of the options except one, the `boolean` value is the same falsy value.
    It will lead to collisions in the hash table, which will be handled by chaining
    values together mapped to the same hash value. The only benefit of using a hash
    table will be constant-time access to the primary payment option.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we come to the simplest solution to store the primary payment option
    separately in the class. Here''s how we should rewrite the part of payment options''
    handling in the `User` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We took you through the process of defining the way to store payment options
    so far just to show the process of designing accompanied by coding. Though we've
    created a lot of versions for the single case of payment options, it's not final.
    There is always the case for handling duplicate values in the payment options
    vector. Whenever you add a payment option to the user as primary and then add
    another option as primary, the previous one goes to the non-primary list. If we
    change our minds and add the old payment option once again as a primary, it won't
    be removed from the non-primary list.
  prefs: []
  type: TYPE_NORMAL
- en: So, there are always opportunities to think deeper and avoid potential issues.
    Design and coding go hand in hand; however, you shouldn't forget about TDD. In
    most cases, writing tests before coding will help you to discover a lot of use
    cases.
  prefs: []
  type: TYPE_NORMAL
- en: Using SOLID principles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are lots of principles and design methods that you can use in your project
    design. It's always better to keep the design simpler, however, there are principles
    that are useful in almost all projects in general. For example, **SOLID** comprises
    of five principles, all or some of which can be useful to the design.
  prefs: []
  type: TYPE_NORMAL
- en: 'SOLID stands for the following principles:'
  prefs: []
  type: TYPE_NORMAL
- en: Single responsibility
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Open-closed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Liskov substitution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interface segregation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependency inversion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's discuss each principle with examples.
  prefs: []
  type: TYPE_NORMAL
- en: The single responsibility principle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The single responsibility principle states the simple, that is, one object,
    one task. Try to reduce the functionality of your objects and their relationship
    complexity. Make each object have one responsibility even though it''s not always
    easy to dissect a complex object into smaller and simpler components. Single responsibility
    is a context-bound concept. It''s not about having just one method in a class;
    it''s about making the class or module responsible for one thing. For example,
    the `User` class that we designed earlier has one responsibility: storing user
    information. However, we added payment options into the `User` class and forced
    it to have methods for adding and removing payment options. We also introduced
    a primary payment option, which involves additional logic in the **User** methods.
    We can move toward two directions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first one suggests decomposing the `User` class into two separate classes.
    Each class will have a single responsibility. The following class diagram depicts
    the idea:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/711b0c46-dd8c-438a-904c-c1727528681d.png)'
  prefs: []
  type: TYPE_IMG
- en: One of them will store only the user basic information, the next will store
    payment options for a user. We named them accordingly, `UserInfo` and `UserPaymentOptions`.
    Some might like this new design, but we will stick with the old one. And here's
    why. Though the `User` class contains both user information and payment options,
    the latter also represents a piece of information. We set and get payment options
    the same way we set and get the email of a user. So, we keep the `User` class
    the same because it's already satisfying the single responsibility principle.
    When we add the functionality to make a payment in the `User` class, that will
    break the peace. In that scenario, the `User` class will both store user information
    and make payment transactions. That's unacceptable in terms of the single responsibility
    principle, therefore, we won't do that.
  prefs: []
  type: TYPE_NORMAL
- en: The single responsibility principle relates to functions as well. The `add_payment_option()` method has
    two responsibilities. It adds a new primary payment option if the second (default)
    argument of the function is true. Otherwise, it adds the new payment option to
    the list of non-primary options. It's better to have a separate method for adding
    a primary payment option. That way, each of the methods will have a single responsibility.
  prefs: []
  type: TYPE_NORMAL
- en: The open-closed principle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The open-closed principle states that a class should be open for extension
    but closed for modification. It means that whenever you need new functionality,
    it''s better to extend the base functionality instead of modifying it. For example,
    take the `Product` class of the e-commerce application that we designed. The following
    represents a simple diagram for the `Product` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7a087189-9c02-4c59-857f-38a419d1299d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Each `Product` object has three properties: **name**, **price**, and **weight**.
    Now, imagine that after designing the `Product` class and the whole e-commerce
    platform, a new requirement comes from the clients. They now want to buy digital
    products, such as e-books, movies, and audio recordings. Everything is fine except
    for the weight of the product. Now that there might be two types of products—tangible
    and digital—we should rethink the logic of `Product` usage. We can incorporate
    a new function into `Product` as shown in the code here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Obviously, we modified the class—contradicting the open-closed principle. The
    principle says that the class should be closed for modification. It should be
    open for extension. We can achieve that by redesigning the `Product` class and
    making it an abstract base class for all products. Next, we create two more classes
    inheriting the `Product` base class: `PhysicalProduct` and `DigitalProduct`. The
    following class diagram depicts the new design:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/39a14c81-c9c5-4dee-8924-e6cbccf9a257.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see in the preceding diagram, we removed the `weight_` property from
    the `Product` class. Now that we have two more classes, `PhysicalProduct` has
    a `weight_` property and `DigitalProduct` does not have one. Instead, it has a
    `file_path_` property. This approach satisfies the open-closed principle because
    now all the classes are open for extension. We use inheritance to extend classes,
    and the following principle is strongly related to that.
  prefs: []
  type: TYPE_NORMAL
- en: The Liskov substitution principle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Liskov substitution principle is about inheriting from a type the right
    way. In simple words, if there is a function that takes an argument of some type,
    then the same function should take an argument of the derived type.
  prefs: []
  type: TYPE_NORMAL
- en: The Liskov substitution principle is named after Barbara Liskov, a Turing Award
    winner and doctor of computer science.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you understand inheritance and the Liskov substitution principle, it''s
    hard to forget it. Let''s continue developing the `Product` class and add a new
    method that returns the price of the product based on the currency type. We can
    store the price in the same currency units and provide a function to convert the
    price for a specified currency. Here''s the simple implementation of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'After a while, the company decides to incorporate lifetime discounts for all
    digital products. Now, every digital product will have a 12% discount. Short time,
    we add a separate function in the `DigitalProduct` class that returns a converted
    price by applying the discount. Here''s how it looks in `DigitalProduct`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The problem in the design is obvious. Calling `convert_price()` on the `DigitalProduct`
    instance will have no effect. Even worse, the client code must not call it. Instead,
    it should call `convert_price_with_discount()` because all digital products must
    sell with a 12% discount. The design contradicts the Liskov substitution principle.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of damaging the class hierarchy, we should remember the beauty of polymorphism.
    Here''s what a better version will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we don''t need the `convert_price_with_discount()` function
    anymore. And the Liskov substitution principle holds. However, we should again
    inspect flaws in the design. Let''s make it better by incorporating private virtual
    methods for discount calculation in the base class. The following updated version
    of the `Product` class contains a private virtual member function named `calculate_discount()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The `convert_price()` function calls the private `apply_discount()` function,
    which returns the price as is. And here comes the trick. We override the `apply_discount()`
    function in derived classes as it is shown in the following `DigitalProduct` implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We can't call a private function outside the class, but we can override it in
    derived classes. And the preceding code shows the beauty of overriding private
    virtual functions. We modify the implementation leaving the interface untouched.
    A derived class doesn't override it if it does not need to provide custom functionality
    for discount calculation. On the other hand, `DigitalProduct` needs to apply a
    12% discount on the price before converting it. It is not necessary to modify
    the public interface of the base class.
  prefs: []
  type: TYPE_NORMAL
- en: You should consider rethinking the design of the `Product` class. It seems even
    better to call `apply_discount()` directly in `getPrice()`, hence always returning
    the latest effective price. Though at some point you should force yourself to
    stop.
  prefs: []
  type: TYPE_NORMAL
- en: The design process is creative and sometimes unthankful. It's not uncommon to
    rewrite all of the code because of unexpected new requirements. We use principles
    and approaches to minimize the breaking changes that will follow after implementing
    new features. The next principle of SOLID is one of the best practices that will
    make your design flexible.
  prefs: []
  type: TYPE_NORMAL
- en: The interface segregation principle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The interface segregation principle suggests dividing a complex interface into
    simpler interfaces. This segregation allows classes to avoid implementing an interface
    they don't use.
  prefs: []
  type: TYPE_NORMAL
- en: In our e-commerce application, we should implement a product shipment, replacement,
    and expiring functionalities. The shipment of the product is moving the product
    item to its buyer. We don't care for the shipment details at this point. Replacement
    of a product considers replacing a damaged or lost product after shipping to the
    buyer. Finally, expiring a product means getting rid of products that did not
    sell by their expiry date.
  prefs: []
  type: TYPE_NORMAL
- en: We are free to implement all of the functionality in the `Product` class introduced
    earlier. However, eventually, we will stumble upon types of products that, for
    example, cannot be shipped (for example, selling a house rarely involves shipping
    it to the buyer). There might be products that are not replaceable. For example,
    an original painting is not possible to replace even if it's lost or damaged.
    Finally, digital products won't expire ever. Well, for most cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'We should not force the client code to implement a behavior it doesn''t need.
    By the client, we mean the class implementing behaviors. The following example
    is a bad practice, contradictory to the interface segregation principle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the `Product` class implements the interface shown in the preceding. It
    has to provide an implementation for all of the methods. The interface segregation
    principle suggests the following model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the `Product` class skips implementing any of the interfaces. Its derived
    classes derive (implement) from specific types. The following example declares
    several types of product classes, each of which supports a limited number of behaviors
    introduced earlier. Please note that we omit bodies of classes for code brevity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Consider implementing `IShippable` for `AudioBook` if you want to wrap a file
    downloading as shipment.
  prefs: []
  type: TYPE_NORMAL
- en: The dependency inversion principle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Finally, dependency inversion states that objects should not be strongly coupled.
    It allows switching to an alternate dependency easily. For example, when a user
    purchases a product, we send a receipt about the purchase. Technically, there
    are several ways to send a receipt, namely, printing and sending via mail, sending
    via email, or showing the receipt in the user account page on the platform. For
    the latter, we send a notification to the user via email or the app that the receipt
    is ready to be viewed. Take a look at the following interface for printing a receipt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s suppose we''ve implemented the `purchase()` method in the `Product`
    class, and on its completion, we send the receipt. The following portion of code
    handles the sending of the receipt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We can extend the application by adding as many receipt printing options as
    needed. The following class implements the `IReceiptSender` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Two more classes—`EmailReceiptSender` and `InAppReceiptSender`—both implement
    `IReceiptSender`. So, to use a specific receipt, we just inject the dependency
    to `Product` via the `purchase()` method, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We can move further by implementing a method in the `User` class that returns
    the receipt sending option desirable for the concrete user. This will make the
    classes even more decoupled.
  prefs: []
  type: TYPE_NORMAL
- en: All of the SOLID principles discussed in the preceding are a natural way of
    composing classes. It's not mandatory to stick to the principles, however, it
    will improve your design if you do.
  prefs: []
  type: TYPE_NORMAL
- en: Using domain-driven design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The domain is the subject area of the program. We are discussing and designing
    an e-commerce platform having e-commerce as the main concept with all its supplementary
    concepts as the domain. We rather suggest you consider domain-driven design in
    your projects. However, the method is not a silver bullet for program design.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s convenient to design your projects to have the following three layers
    of the three-tier architecture in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: Presentation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Business logic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The three-tier architecture applies to client-server software such as the one
    we are designing in this chapter. The presentation layer provides users with information
    related to products, purchases, and shipment. It communicates with other layers by
    putting out the results to the client. It's a layer that clients access directly,
    for example, a web browser.
  prefs: []
  type: TYPE_NORMAL
- en: The business logic cares for application functionality. For example, a user
    browses products provided by the presentation layer and decides to purchase one
    of them. The processing of the request is the task of the business layer. In domain-driven
    design, we tend to combine domain-level entities with their attributes to tackle
    the application complexity. We deal with users as instances of the `User` class,
    with products as instances of the `Product` class, and so on. The user purchasing
    a product is interpreted by the business logic as a `User` object creating an
    `Order` object, which, in turn, is related to a `Product` object. The `Order`
    object is then tied to a `Transaction` object related to the purchase of the product.
    Corresponding results of the purchase are represented via the presentation layer.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the data layer handles storing and retrieving data. From user authentication
    to product purchase, each step is retrieved from or recorded in the system database
    (or databases).
  prefs: []
  type: TYPE_NORMAL
- en: Dividing the application into layers allows handling the complexity of it in
    general. It's much better to orchestrate objects having single responsibility.
    The domain-driven design differentiates entities from objects that don't have
    a conceptual identity. The latter are known as value objects. For example, users
    do not distinguish between each unique transaction; they are only concerned about
    information that a transaction represents. On the other hand, a user object has
    a conceptual identity in the form of a `User` class (the entity).
  prefs: []
  type: TYPE_NORMAL
- en: Operations permitted on objects using other objects(or not) are named services.
    A service is rather an operation that is not tied to a specific object. For example,
    setting the name of the user by the `set_name()` method is an operation that shouldn't
    be considered as a service. On the other hand, the purchase of a product by the
    user is an operation encapsulated by a service.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, domain-driven design intensively incorporates **repository** and **factory**
    patterns. The repository pattern is responsible for methods for retrieving and
    storing domain objects. The factory pattern creates domain objects. Using these
    patterns allows us to interchange alternative implementations if and when needed.
    Let's now find out the power of design patterns in the context of the e-commerce
    platform.
  prefs: []
  type: TYPE_NORMAL
- en: Leveraging design patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Design patterns are architectural solutions to commonly occurring problems in
    software design. It is important to note that design patterns are not methods
    nor algorithms. They are architectural constructs that provide a way of organizing
    classes and their relationship to achieve better results in code maintainability.
    Even if you didn't use a design pattern before, you most probably had invented
    one on your own. Many problems tend to recur in software design. For example,
    making a better interface for an existing library is a form of a design pattern
    known as **facade**. Design patterns have names so that programmers use them in
    conversations or documentation. It should be natural for you to chit-chat with
    fellow programmers using facades, factories, and the like.
  prefs: []
  type: TYPE_NORMAL
- en: We've previously mentioned that domain-driven design incorporates repository
    and factory patterns. Let's now find out what they are and how they could be useful
    in our design endeavor.
  prefs: []
  type: TYPE_NORMAL
- en: The repository pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As Martin Fowler best describes, the repository pattern "*mediates between the
    domain and data mapping layers using a collection-like interface for accessing
    domain objects*".
  prefs: []
  type: TYPE_NORMAL
- en: The pattern provides straightforward methods for data manipulation, without
    the need to work with the database driver directly. Adding, updating, removing,
    or selecting data naturally fits with the application domain.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the approaches is to create a generic repository class that provides
    necessary functions. A simple interface is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We introduced a new class named `Entity` in the preceding. The `Repository` class works
    with entities and to make sure that each entity conforms to the same interface
    of `Entity`, it applies `std::enable_if` along with `std::is_base_of_v` to the
    template parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '`std::is_base_of_v` is a short representation for `std::is_base_of<>::value`.
    Also, `std::enable_if_t` replaces `std::enable_if<>::type`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Entity` class is as simple as the following representation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Each business object is an `Entity`, therefore, the classes discussed earlier
    should be updated to inherit from `Entity`. For example, the `User` class takes
    the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'So, we can use the repository the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The preceding repository pattern is a simple introduction to the topic, however,
    you can make it even powerful. It resembles the facade pattern. Though the point
    of using the facade pattern is not access to the database, it is still best explained
    with that example. The facade pattern wraps a complex class or classes, providing
    the client with a simple predefined interface to work with the underlying functionality.
  prefs: []
  type: TYPE_NORMAL
- en: The factory pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When programmers talk about factory patterns, they might confuse the factory
    method and abstract factory. Both of these are creational patterns that provide
    various object creation mechanisms. Let's discuss the factory method. It provides
    an interface for creating objects in the base class and allows derived classes
    to modify the objects that will be created.
  prefs: []
  type: TYPE_NORMAL
- en: Now is the time to deal with logistics, and the factory method will help us
    in that. When you develop an e-commerce platform providing product shipments,
    you should consider that not all users live in the same area in which your warehouses
    are located. So, shipping a product from a warehouse to the buyer, you should choose
    the proper transportation type. A bicycle, a drone, a truck, and so on. The problem
    of interest is designing a flexible logistics management system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Different means of transportation require different implementations. However,
    all of them conform to one interface. The following is the class diagram for the
    `Transport` interface and its derived specific transport implementations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9440ba69-a862-495f-b00d-4e2a4db2e746.png)'
  prefs: []
  type: TYPE_IMG
- en: Each of the concrete classes in the preceding diagram provides specific implementation
    to delivery.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s suppose we design the following `Logistics` base class responsible for
    logistics-related actions, including choosing the proper transportation method
    as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/69a43738-0ce0-4c88-8f17-b5a8d36fec0f.png)'
  prefs: []
  type: TYPE_IMG
- en: The factory method applied in the preceding allows flexibility in adding new
    transport types as well as new logistic methods. Pay attention to the `createTransport()`
    method that returns a pointer to `Transport`. Derived classes override the method,
    each of which returns a subclass of `Transport`, hence providing a specific mode
    of transport. It's possible because subclasses return a derived type, otherwise,
    we can't return a different type when overriding base class methods.
  prefs: []
  type: TYPE_NORMAL
- en: '`createTransport()` in `Logistics` looks as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Transport` class represents a base class for `Drone`, `Truck`, and `Ship`.
    That means we can create an instance of each and refer to them using a `Transport`
    pointer as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This lays at the foundation of the factory pattern because `RoadLogistics`,
    for example, overrides `getLogistics()` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Pay attention to the return type of the function, it's `Truck` instead of `Transport`.
    It works because `Truck` inherits from `Transport`. Also, see how object creation
    is decoupled from the object itself. Creating new objects is done via factories,
    which keeps consistency with the SOLID principles discussed earlier.
  prefs: []
  type: TYPE_NORMAL
- en: At first glance, it might confusingly seem that leveraging a design pattern
    incorporates additional complexity into the design. However, you should develop
    a true sense of better design when practicing design patterns because they allow
    for flexibility and extendibility of the project overall.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Software development requires meticulous planning and design. We''ve learned
    in this chapter that project development involves the following key steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Requirements gathering and analysis: This includes understanding the domain
    of the project, discussing and finalizing the features that should be implemented.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Specification creation: This includes documenting requirements and project
    functionality.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Design and test planning: This refers to designing the project starting from
    the bigger entities down to decomposing each into a separate class with regards
    to other classes in the project. This step also involves planning how the project
    will be tested.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Coding: This step involves writing code that implements the project specified
    in previous steps.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Testing and stabilization: This means checking the project against preplanned
    use cases and scenarios to discover issues and fix them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Release and maintenance: This is the final step that brings us to the project
    release and further maintenance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The project design is a complex task for programmers. They should think ahead
    of time because part of the features is being introduced during the development
    of the process.
  prefs: []
  type: TYPE_NORMAL
- en: To make the design flexible and robust, we've discussed principles and patterns
    leading to better architecture. We have learned the process of designing a software
    project with all its intricacies.
  prefs: []
  type: TYPE_NORMAL
- en: One of the best ways to avoid bad design decisions is to follow already devised
    patterns and practices. You should consider using SOLID principles along with
    proven design patterns in your future projects.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will design a strategy game. We will get familiar with
    more design patterns and see their applications in game development.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are the benefits of TDD?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the purpose of interaction diagrams in UML?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What's the difference between a composition and aggregation?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How would you describe the Liskov substitution principle?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's suppose you are given the class `Animal`, and the class `Monkey`. The
    latter describes a particular animal that jumps on trees. Does inheriting a `Monkey`
    class from an `Animal` class contradict the open-closed principle?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Apply the factory method on the `Product` class with its subclasses that were
    discussed in this chapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For further information refer to :'
  prefs: []
  type: TYPE_NORMAL
- en: '*Object-Oriented Analysis and Design with Applications* by Grady Booch, [https://www.amazon.com/Object-Oriented-Analysis-Design-Applications-3rd/dp/020189551X/](https://www.amazon.com/Object-Oriented-Analysis-Design-Applications-3rd/dp/020189551X/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Design Patterns: Elements of Reusable Object-Oriented Software* by Erich Gamma
    et al, [https://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612/](https://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Code Complete: A Practical Handbook of Software Construction* by Steve McConnel,[ https://www.amazon.com/Code-Complete-Practical-Handbook-Construction/dp/0735619670/](https://www.amazon.com/Code-Complete-Practical-Handbook-Construction/dp/0735619670/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Domain-Driven Design: Tackling Complexity in the Heart of Software* by Eric
    Evans, [https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/](https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
