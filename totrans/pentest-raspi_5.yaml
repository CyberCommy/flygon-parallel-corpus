- en: Chapter 5. Ending the Penetration Test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Hacking into networks can be fun when it's taking place in your personal lab.
    At some point, however, you might need to take it to a real environment. When
    that time comes, it is critical that you make sure you conclude things properly.
    For people providing penetration testing as a service, you must show evidence
    to justify your findings or you won't demonstrate enough value for future business.
    This means documenting everything and not leaving behind possible problems caused
    by your services. For attackers, you will want to remove your footprint so that
    the authorities can't track you back through a forensic investigation.
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to reporting identified network weaknesses as a paid service,
    people don't like when their child is called ugly, and will probably challenge
    your findings. It is important to document the entire process so that it is repeatable,
    assuming that the network is in the same state as when the penetration test was
    performed. Documentation needs to be tailored for both technical and non-technical
    reviewers since both types of people probably have a stake in funding the service
    engagement. You should also note the beginning state of the exercise, including
    any information provided upfront by your customer. You can learn more about the
    starting state of penetration testing by researching white box, black box, and
    grey box penetration testing.
  prefs: []
  type: TYPE_NORMAL
- en: Another key element of ending a penetration test is being aware of the footprint
    that you created during the assignment. Many exploits can impact the functionality
    of systems and cause downtime that most customers will not be happy about. This
    and other types of behaviors could tip off those watching out for your presence,
    which might push them to adjust their security measures. This will make it much
    tougher to accomplish your original task, and will also not provide a true penetration
    testing simulation as real attackers might not be sloppy and get identified. Administrators
    might also fix any identified vulnerabilities before they are reported, thereby
    deflating the value of your final report. This is why everything you attempt on
    a target should be stealthy unless the service engagement is completely in the
    clear, meaning all the parties know that you are providing the service against
    specific systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Covering your tracks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wiping logs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Masking your network footprints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Proxychains
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resetting the Raspberry Pi back to factory settings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remotely corrupting Kali Linux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing reports
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating screenshots
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compressing files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You should have approval from the proper parties prior to executing any penetration
    testing assignment. This approval should be reviewed by a legal representative
    and signed in ink to avoid the risk of being made responsible for any negative
    results caused by an authorized penetration test. If you are an unauthorized hacker,
    don't get caught.
  prefs: []
  type: TYPE_NORMAL
- en: Covering your tracks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the key tasks in which penetration testers as well as criminals tend
    to fail is cleaning up after they breach a system. Forensic evidence can be anything
    from the digital network footprint (the IP address, type of network traffic seen
    on the wire, and so on) to the logs on a compromised endpoint. There is also evidence
    on the used tools, such as those used when using a Raspberry Pi to do something
    malicious. An example is running `more ~/.bash_history` on a Raspberry Pi to see
    the entire history of the commands that were used.
  prefs: []
  type: TYPE_NORMAL
- en: The good news for Raspberry Pi hackers is that they don't have to worry about
    storage elements such as ROM since the only storage to consider is the microSD
    card. This means attackers just need to reflash the microSD card to erase evidence
    that the Raspberry Pi was used. Before doing that, let's work our way through
    the clean up process starting from the compromised system to the last step of
    reimaging your Raspberry Pi.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can use the SD Format tool we covered in [Chapter 1](ch01.html "Chapter 1. Raspberry
    Pi and Kali Linux Basics"), *Raspberry Pi and Kali Linux Basics*,for this purpose.
    You can also use the steps covered in [Chapter 1](ch01.html "Chapter 1. Raspberry
    Pi and Kali Linux Basics"), *Raspberry Pi and Kali Linux*, *Basics* to back up
    your image before performing a penetration test and resetting your Raspberry Pi
    back to that image to hide how it was used prior to reimaging it.
  prefs: []
  type: TYPE_NORMAL
- en: Wiping logs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first step you should perform to cover your tracks is clean any event logs
    from the compromised system that you accessed. For Windows systems, Kali Linux
    has a tool within Metasploit called **clearev** that does this for you in an automated
    fashion. Clearev is designed to access a Windows system and wipe the logs. An
    overzealous administrator might notice the changes when you clean the logs. However,
    most administrators will never notice the changes. Also, since the logs are wiped,
    the worst that could happen is that an administrator might identify that their
    systems have been breached, but the logs containing your access information would
    have been removed.
  prefs: []
  type: TYPE_NORMAL
- en: Clearev comes with the Metasploit arsenal. To use clearev once you have breached
    a Windows system with a Meterpreter, type `meterpreter > clearev`. There are no
    configurations once it is run, which means it just wipes the logs upon execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the launch of the preceding command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Wiping logs](img/6435OT_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here is an example of the logs before they are wiped on a Windows system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Wiping logs](img/6435OT_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Another way to wipe off logs from a compromised Windows system is by installing
    a Windows log cleaning program. There are many options available to download,
    such as **ClearLogs** found at [http://ntsecurity.nu/toolbox/clearlogs/](http://ntsecurity.nu/toolbox/clearlogs/).
    Programs such as these are simple to use, meaning you just install and run it
    on a target once you are finished with your penetration test. You can also just
    delete the logs manually using the `C:\ del %WINDR%\* .log /a/s/q/f` command.
    This command directs all logs using `/a` including subfolders `/s`, disables any
    queries so you don't get prompted, and `/f` forces this action.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Whichever program you use, make sure to delete the executable file once the
    log files are removed so that the file isn't identified during a future forensic
    investigation.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Linux systems, you need to get access to the `/var/log` folder to find
    the log files. Once you have access to the log files, simply open them and remove
    all entries. The following screenshot shows an example of my Raspberry Pi''s `log`
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Wiping logs](img/6435OT_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can just delete the files using the remove command, `rm`, such as `rm FILE.txt`
    or delete the entire folder; however, this wouldn't be as stealthy as wiping existing
    files clean of your footprint. Another option is in Bash. One can simply type
    `> /path/to/file` to empty the contents of a file, without removing it necessarily.
    This approach has some stealth benefits.
  prefs: []
  type: TYPE_NORMAL
- en: Kali Linux does not have a GUI-based text editor, so one easy-to-use tool that
    you can install is **gedit**. Use `apt-get install gedit` to download it. Once
    installed, you can find `gedit` under the application dropdown or just type `gedit`
    in the terminal window. As you can see from the following screenshot, it looks
    like many common text file editors. Click on **File** and select files from the
    `log` folder to modify them.
  prefs: []
  type: TYPE_NORMAL
- en: '![Wiping logs](img/6435OT_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You also need to erase the command history since the Bash shell saves the last
    500 commands. This forensic evidence can be accessed by typing the `more ~/.bash_history`
    command. The following screenshot shows the first of the hundreds of commands
    I recently ran on my Raspberry Pi:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Wiping logs](img/6435OT_05_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To verify the number of stored commands in the `history` file, type the `echo
    $HISTSIZE` command. To erase this history, type `export HISTSIZE=0`. From this
    point, the shell will not store any command history, that is, if you press the
    up arrow key, it will not show the last command.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These commands can also be placed in a `.bashrc` file on Linux hosts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows that I have verified if my last 500 commands
    are stored. It also shows what happens after I erase them:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Wiping logs](img/6435OT_05_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is a best practice to set this command prior to using any commands on a compromised
    system, so that nothing is stored upfront. You could log out and log back in once
    the export `HISTSIZE=0` command is set to clear your history as well. You should
    also do this on your C&C server once you conclude your penetration test if you
    have any concerns of being investigated.
  prefs: []
  type: TYPE_NORMAL
- en: 'A more aggressive and quicker way to remove your history file on a Linux system
    is to shred it with the `shred –zu /root/.bash_history` command. This command
    overwrites the history file with zeros and then deletes the log files. Verify
    this using the `less /root/.bash_history` command to see if there is anything
    left in your history file, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Wiping logs](img/6435OT_05_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Masking your network footprint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You should not launch attacks from a source such as your home network that can
    be traced back to you unless you don't mind being linked to your actions. The
    most common method to hide your real source address is using a proxy or multiple
    proxies between you and the victim. In simple terms, a proxy acts as an intermediary
    for requests from clients seeking resources from another system. The target will
    see traffic from the intermediary system and will not know the real source. Layering
    proxies can cause an onion effect, making tracing the real source extremely difficult
    during a forensic investigation.
  prefs: []
  type: TYPE_NORMAL
- en: There are hundreds of free network proxies available online. You can search
    `Free Anonymous Web Proxy Server` on Google to find various flavors such as Proxify,
    Anonymouse, Anonymizer and Ninja Cloak. The following screenshot shows Anonymouse
    including the explanation of surfing through a proxy. For their service, you need
    to simply type in the address you want to access in the search field.
  prefs: []
  type: TYPE_NORMAL
- en: '![Masking your network footprint](img/6435OT_05_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Administrators of proxies can see all traffic as well as identify both the target
    and the victims that communicate through their proxy. It is highly recommended
    that you research any proxy prior to using it as some might use information captured
    without your permission. This includes providing forensic evidence to authorities
    or selling your sensitive information.
  prefs: []
  type: TYPE_NORMAL
- en: Proxychains
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another option to hide your source IP address is using proxychains. Proxychains
    allows you to tunnel Kali commands through a proxy server. You will need to install
    proxy chains using the `sudo apt-get install proxychains` command since it is
    not preinstalled in the Kali Linux ARM image.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once installed, you will need to add a proxy IP address in the `etc/proxychains.conf`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Proxychains](img/6435OT_05_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: HideMyAss Internet security offers a list of free proxy servers that you can
    use for this purpose. You can find their website at [http://proxylist.hidemyass.com](http://proxylist.hidemyass.com).
    Remember, these are not very reliable and can possibly use your data without your
    permission since the proxy administrators see all the traffic.
  prefs: []
  type: TYPE_NORMAL
- en: The syntax for proxychains is `proxychains < command you want tunneled and proxied>
    <optional arguments>`. In the following example, we will use the `nmap` command
    to scan the `192.168.1.0/24` network through proxychains to hide from where the
    scan is being done. Note that we had to edit the `.conf` file with a proxy prior
    to executing this command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Resetting the Raspberry Pi to factory settings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once you cover your tracks on the endpoints and network, the final step is to
    remove forensic evidence from the tools that you used. To clean a Raspberry Pi,
    you simply need to reimage the SD drive. You can find steps in [Chapter 1](ch01.html
    "Chapter 1. Raspberry Pi and Kali Linux Basics"), *Raspberry Pi and Kali Linux
    Basics,* to format your SD card using SD Card Formatter or Apple's Disk Utility.
    You can continue following [Chapter 1](ch01.html "Chapter 1. Raspberry Pi and
    Kali Linux Basics"), *Raspberry Pi and Kali Linux Basics*, to install a new image
    such as the original NOOBS software to hide that the Raspberry Pi once ran Kali
    Linux. You can also use a Kali Linux image that has been customized prior to launching
    your penetration test to save you the time of rebuilding an attack system, yet
    remove what was done during the previous penetration testing engagement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another option is to remove and break the microSD card. The following image
    shows an example of a cut up microSD card so that it can''t be used for a future
    investigation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Resetting the Raspberry Pi to factory settings](img/6435OT_05_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Remotely corrupting Kali Linux
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You might be put in a situation where you can't physically access your Raspberry
    Pi and need to make sure that it can't be confiscated and later used for a future
    forensic investigation. This could happen if you planted a Raspberry Pi as a network
    tap, remotely accessed it to breach systems, and now need to conclude things by
    killing the Raspberry Pi. In this scenario, you can't wipe the microSD drive,
    so the next best thing is corrupting Kali Linux so that a forensic investigator
    can't access it to see how it was used during the network breach. Let's look at
    how you can remotely kill a Raspberry Pi running Kali Linux.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing you might want to do is delete everything. You can do this by
    using the `rm –rf /` command which means `rm` = remove, `-rf`= remove recursively
    forcing all files and folders without prompting you and `/` tells this command
    to start in the root directory. Running the same command with a `.*` , that is
    `rm –rf .*`, would delete all the configuration files. This option isn't that
    good since deleting only tells the system that space is available, but it does
    not replace the data, meaning it can be uncovered with a forensic tool. A better
    approach is using `dd if=/dev/zero of=/dev/sda1` so that you overwrite bytes making
    the data harder to recover.
  prefs: []
  type: TYPE_NORMAL
- en: Another option is to format the hard drive using the `mkfs.ext4 /dev/sda1` command.
    The `mkfs.ext4` command creates a new `.ext4` file system and `/dev/sda1` specifies
    the first partition on the first hard drive, which is what we are using to run
    Kali Linux.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Running these commands will kill your Kali Linux installation. Be careful of
    people who tell you to use such commands as it is common to see people suggest
    these as a prank.
  prefs: []
  type: TYPE_NORMAL
- en: Developing reports
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most important part of a penetration testing service is the quality of the
    deliverable to the customer. We have seen very talented testers lose business
    to low quality, yet more professional, service providers purely on the basis of
    the customer's reaction to the final report. This is due to the way the message
    is delivered considering the target audience, how sensitive they are to bad news,
    as well as the level of details provided. The best way to customize the message
    for a potential customer is to leverage a mix of standardized reports as well
    as imagine how they would read the material. For example, calling an individual
    a potential weakness would probably be a bad idea if that person has influence
    over the budget for this and other services.
  prefs: []
  type: TYPE_NORMAL
- en: Developing reports is not just documenting your findings. You need to capture
    the entire scenario including the environment prior to the penetration test, what
    information was provided upfront, assumptions about the current conditions, steps
    used when the services was being provided, and the results from each step. You
    might find that administrators patch holes prior to the completion of your report,
    so it's critical to document the time and date of each step. You can learn more
    about best practices for developing reports by using creditable sources such as
    OWASP's testing guide at [https://www.owasp.org/index.php/Testing_Guide_Introduction](https://www.owasp.org/index.php/Testing_Guide_Introduction).
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at some tools that you can use to help build professional reports.
  prefs: []
  type: TYPE_NORMAL
- en: Creating screenshots
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Kali Linux ARM has limited functions to keep the operating system thin.
    One simple concept that can be tedious to execute is capturing screenshots of
    results for reporting purposes. Let's look at a command-line- and GUI-based tool
    that can simplify this process.
  prefs: []
  type: TYPE_NORMAL
- en: ImageMagick
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: ImageMagick is a tool that can be downloaded and executed from a terminal to
    launch a screenshot. To download it, type the `sudo apt-get install imagemagick`
    command.
  prefs: []
  type: TYPE_NORMAL
- en: Once installed, you can type the `import screenshot.png` command to launch a
    screenshot. ImageMagick will change your mouse icon to a box representing that
    it is ready to capture something. Click on the part of the screen you want to
    capture and a screenshot will be saved as a `.png` file in your root. If you click
    on a window, ImageMagick will just capture that particular window. You can type
    the `eog screenshot.png` command to view your screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: 'To capture the entire Raspberry Pi screen while introducing a delay, type the
    `sleep 10; import –window root screenshot.png` command. This is useful for including
    things that require interaction, such as opening a menu while performing a screen
    capture. The number after `sleep` will give you the delay time before the screenshot
    will be taken. The `import –window root` command tells ImageMagick to take a screenshot
    of the entire screen. The last part of the command is the name of your screenshot.
    The following screenshot shows the command to capture the screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ImageMagick](img/6435OT_05_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Shutter
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another image capturing tool is Shutter. Once again, you need to download it
    using the `apt-get install shutter` command. Once installed, you can find it under
    the applications dropdown or just type `shutter` in a terminal window. Shutter
    has a popup that will inform you that it is updating its plugins prior to fully
    launching for the first time.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows a **Session-Shutter** window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Shutter](img/6435OT_05_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Shutter will show a window with options. To take a screenshot, you can click
    on the arrow or scissors image depending on the version. This will change the
    screen and ask you to draw a rectangle where you want to take a screenshot. Once
    you do this, you will draw a rectangle around your desired image and your screenshot
    will appear in the shutter window. From here, you can edit your image and save
    it for your report. The following example shows a screenshot taken by me of a
    part of the website [www.thesecurityblogger.com](http://www.thesecurityblogger.com):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Shutter](img/6435OT_05_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The other option is to take a screenshot of the entire desktop by clicking the
    square labeled desktop or various ways to capture part of a window by clicking
    one of the options to the right of the desktop capture image. Once you have an
    image, you can click on the paintbrush to bring up the editing features, as shown
    in the following screenshot. You can crop, adjust the size, and so on prior to
    saving your final image. You can also upload images using the computer image button
    and edit those images using the paintbrush.
  prefs: []
  type: TYPE_NORMAL
- en: '![Shutter](img/6435OT_05_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Compressing files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you compromise a system or network, at some point you will probably want
    to insert or remove data. Data can be large, which means it can take a while to
    send it over the network. This can be a problem if you only have limited time
    on the compromised system. Also, moving large files off a network can trigger
    security defenses such as the **Data Loss Prevention** (**DLP**) technology.
  prefs: []
  type: TYPE_NORMAL
- en: The best practice is to compress and break files into smaller sizes to speed
    up the download/upload process as well as hide the sending/receiving action. Let's
    look at a command-line and GUI tool that you can use to accomplish these goals.
  prefs: []
  type: TYPE_NORMAL
- en: Zip/Unzip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One simple to use command-line-based compression application is Zip. This program
    let's you shrink files on the Raspberry Pi so that you can send them to the C&C
    server to expand back to their normal form. Zip does not come preinstalled on
    the ARM image, so you will need to use the `apt-get install zip` command to install
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once installed, use the `zip "zip file name" "file to be zipped"` command,
    where `"zip file name"` is what the output will be called and `"file to be zipped"`
    is the file to compress. A `.zip` extension will be added to the compressed file,
    meaning this example will be `data.zip` after being compressed. The following
    screenshot shows the compressing of the `VictimData` file to the `Stolen.zip`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Zip/Unzip](img/6435OT_05_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Use `unzip Stolen.zip` to open the ZIP file back in its normal form, that is
    `VictimData`. You can also specify a particular file to be extracted, for example
    `unzip Stolen.zip VictimData.doc`. The following screenshot shows the unzipping
    of `Stolen.zip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Zip/Unzip](img/6435OT_05_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: File Roller
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are looking for a GUI-based compression program that can read various
    formats, File Roller could meet your needs. Just like Zip, you can open and compress
    files using a simple GUI. File Roller is not included with the Kali Linux ARM
    image, so you will need to use the `apt-get install file-roller` command to install
    it. Once installed, type `file roller` in the terminal and the GUI will open up.
    The following screenshot shows the `VictimData` file after I dragged and dropped
    the `Stolen.zip` file in File Roller. You can also click on the **Open** button
    to open the compressed files.
  prefs: []
  type: TYPE_NORMAL
- en: '![File Roller](img/6435OT_05_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To compress files, you can drag the file into the window and File Roller will
    ask you whether you want to create a new compressed file. Here is an example in
    the following screenshot of dropping the `VictimData` file into File Roller and
    creating a new compressed file called `VictimDataNew.tar.gz`. At the file prompt,
    I told File Roller to call my new file `VictimDataNew` and it added the `.tar.gz`
    extension once the file was compressed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![File Roller](img/6435OT_05_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Split
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To further reduce a file, you can split it into multiple parts before sending
    it over the wire. One simple utility to accomplish this is split. To split a file,
    type `split "size of each file" "file to be split" "name of split files"`. The
    next example in the following screenshot shows splitting a file called `VictimData`
    into smaller 50 MB files called `Breakup`. Each 50 MB file will have the name
    `Breakup` followed by letters starting with `aa`. So, our example created three
    files called `Breakupaa`, `Breakupab`, and `Breakupac`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Split](img/6435OT_05_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To reassemble our three files, we can use the `cat "fileaa fileab fileac" >
    "final file name"`. So, for our example, we''ll assemble the `VictimData` file
    using the files `Breakupaa`, `Breakupab`, and `Breakupac`. We can also use the
    `cat Breakupa[a-c] > VictimData` command, as shown in the following screenshot,
    since the beginning character is the same in the number sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Split](img/6435OT_05_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter focused on closing a penetration test or attacking exercise. Topics
    included removing your footprint from the systems that you breached, masking how
    you communicate with systems, and finally removing evidence that the Raspberry
    Pi was used for a penetration test. We closed this chapter by covering reporting
    options to create professional deliverables for your potential customers.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will look at other ARM images, besides Kali Linux, that are
    available for the Raspberry Pi.
  prefs: []
  type: TYPE_NORMAL
