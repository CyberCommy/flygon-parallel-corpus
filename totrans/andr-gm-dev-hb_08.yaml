- en: Chapter 8. Performance and Memory Optimization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Optimization is one of the most important tasks of any development cycle. It
    is inevitable, especially for games. Game optimization enhances performance significantly.
    Through optimization, more hardware platforms can be targeted.
  prefs: []
  type: TYPE_NORMAL
- en: You have already learned that Android supports a range of hardware platforms.
    Each platform has a separate configuration. By optimizing the use of hardware
    resources, a game can be run on more hardware platforms. This technique can be
    applied to visual quality as well. Not all devices have the same quality display,
    so optimizing the assets for low resolution saves a lot of storage space as well
    as heap memory during runtime.
  prefs: []
  type: TYPE_NORMAL
- en: In programming, the developer often writes intermediate code and forgets to
    optimize it later. This may cause a significant amount of performance loss or
    even cause the game to crash.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will discuss the scope of various optimizations in Android game development
    through the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Fields of optimization in Android games
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Relationship between performance and memory management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory management in Android
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Processing segments in Android
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different memory segments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Importance of memory optimization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimizing performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Increasing the frame rate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Importance of performance optimization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common optimization mistakes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Best optimization practices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fields of optimization in Android games
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We all know the requirement of optimization in any development project. In
    the case of game development, this fact remains the same. In a game development
    project, the process starts with limited resources and design. After development,
    the game is expected to be run on maximum possible devices with maximum quality.
    To achieve that, memory and performance optimization becomes mandatory. So, let''s
    discuss the following four segments of optimization:'
  prefs: []
  type: TYPE_NORMAL
- en: Resource optimization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design optimization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory optimization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance optimization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resource optimization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Resource optimization is basically optimizing the art, sound, and data files.
  prefs: []
  type: TYPE_NORMAL
- en: Art optimization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have already discussed many optimization techniques and tools. Here, we will
    discuss the necessity of art optimization.
  prefs: []
  type: TYPE_NORMAL
- en: Art is visually the most important part in games. Improving the art with bigger
    and better display quality increases processing and storage costs.
  prefs: []
  type: TYPE_NORMAL
- en: Large textures occupy a large amount of memory. However, scaling up art to fit
    a bigger resolution screen affects visual quality. So, a balance must be met.
    Also, various Android devices support various limitations on texture size. Moreover,
    it takes more time for a shader to work on a larger texture.
  prefs: []
  type: TYPE_NORMAL
- en: One common mistake that developers make is using alpha information for a completely
    opaque texture. This data increases the texture size significantly.
  prefs: []
  type: TYPE_NORMAL
- en: Art assets can be optimized on the art style. Many developers use flat-colored
    texture over gradient. Flat color information can be accommodated within 8-bit
    pixel data. This again saves disk space and processing time.
  prefs: []
  type: TYPE_NORMAL
- en: In spite of these optimization scopes, the developer might not use all of them
    to increase flexibility in order to create quality visual art without spending
    much time on optimization.
  prefs: []
  type: TYPE_NORMAL
- en: Sound optimization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sound is another vital resource for games. Audio may be compressed to save space
    and effort. A common practice in the Android game industry is to use a compressed
    format for long audio files.
  prefs: []
  type: TYPE_NORMAL
- en: It takes time to compress and decompress files during runtime. So, using SFX
    dynamically can be a problem if it is compressed. It can trigger a significant
    and visible stutter. Developers like to use an uncompressed format for SFX and
    a compressed format for long and continuous playing sounds such as background
    music.
  prefs: []
  type: TYPE_NORMAL
- en: Data file optimization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes, game developers use separate data files to create a flexible project
    structure to interact with external tools or for better data interface. Such files
    are commonly in text, XML, JSON, or binary formats. Developers may create their
    own data format in a binary model.
  prefs: []
  type: TYPE_NORMAL
- en: Binary data can be processed quickly if the correct algorithm is used. There
    is not much technicality in data optimization. However, developers always need
    to keep a check on the amount of data and the total file size.
  prefs: []
  type: TYPE_NORMAL
- en: Design optimization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Design optimization is used to increase the scalability, quality experience,
    flexibility, and durability of the game. The main method is to restructure or
    modify the game parameters around the core game concept.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s divide this section into two parts from the point of view of functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: Game design optimization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical design optimization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Game design optimization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A game can be completely different from the initial idea during the game design
    optimization phase. Design optimization is done based on certain tasks. The developer
    needs to find different ways to communicate the basic game idea. Then, they can
    choose the best one, following some analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Game design should be flexible enough to accommodate runtime changes to improve
    the overall experience and increase user count. A highly optimized game design
    can be efficient enough to predict user behavior, game performance on various
    devices, and even monetization.
  prefs: []
  type: TYPE_NORMAL
- en: The game control system design has to be optimized enough to carry out all the
    tasks easily. Game controls should be easy to spot and understand. For Android
    touch devices, the placement of controls is also very important.
  prefs: []
  type: TYPE_NORMAL
- en: Technical design optimization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Technical design optimization is limited to the development cycle. It sets the
    project structure, program structure, development platform dependency, and so
    on.
  prefs: []
  type: TYPE_NORMAL
- en: The technical design document also specifies the scope and scale of the game.
    Such specifications help run the game smoothly on a device, because the hardware
    platform is already covered within the technical design document.
  prefs: []
  type: TYPE_NORMAL
- en: This is a pre-development process. A few assumptions need to be taken care of
    in this document. These assumptions should be optimized enough to evolve when
    a real-time situation occurs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Technical design can also take care of the following tasks during development.
    By optimizing these tasks, it is much easier to implement and execute:'
  prefs: []
  type: TYPE_NORMAL
- en: Program architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: System architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: System characteristics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defined dependencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Impacts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Risk analysis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assumptions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All these tasks can be optimized for a better development cycle with less effort,
    and the game will be more polished and will have a higher performance rate.
  prefs: []
  type: TYPE_NORMAL
- en: Memory optimization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Memory optimization is mandatory for any software development procedure. Memory
    has its physical limitation based on the hardware configuration, but games and
    applications cannot be made separately for each device.
  prefs: []
  type: TYPE_NORMAL
- en: In a technical design, the range of memory use for the game across all targeted
    hardware platforms should be mentioned. Now, it is a very common scenario that
    games take more memory than predicted, which eventually results in the game crashing.
    The developer is awarded with a memory overflow exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid this scenario, there are two main things to be taken care of:'
  prefs: []
  type: TYPE_NORMAL
- en: Keep memory peak within the defined range
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don't keep data loaded in memory unnecessarily
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Android uses paging and mapping to manage memory usage. Unfortunately, it does
    not offer memory swapping. Android knows where to find the paged data and loads
    accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Here are some tricks to optimize memory in Android gaming.
  prefs: []
  type: TYPE_NORMAL
- en: Don't create unnecessary objects during runtime
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Often, the developer creates an intermediate data object inside a loop. It
    leaves memory footprints for the garbage collector to collect. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Use primitive data types as far as possible
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: User-defined data types take more memory space than primitive data types. Declaring
    an integer takes less space than embedding an integer in a class. In Android,
    if the developer uses the `Integer` class instead of `int`, the data size increases
    four times.
  prefs: []
  type: TYPE_NORMAL
- en: For Android compilers (32 bit), `int` consumes 4 bytes (32 bit), and `Integer`
    consumes 16 bytes (128 bit).
  prefs: []
  type: TYPE_NORMAL
- en: With full respect to modern age Android devices, limited use of this data type
    may cause no significant harm to memory. However, extensive use of non-primitive
    data types may cause a significant amount of memory block until the developer
    or garbage collector frees the memory.
  prefs: []
  type: TYPE_NORMAL
- en: So, the developer should avoid `enum` and use static final `int` or `byte` instead.
    `enum`, being a user-defined data type, takes more memory than a primitive data
    type.
  prefs: []
  type: TYPE_NORMAL
- en: Don't use unmanaged static objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In older Android versions, it is a common issue that a static object does not
    get destroyed automatically. Developers used to manage static objects manually.
    This issue is no longer there in newer versions of Android. However, creating
    many static objects in games is not a good idea as the life span of static objects
    is equal to the game life. They directly block memory for a longer period.
  prefs: []
  type: TYPE_NORMAL
- en: Using too many static objects may lead to memory exceptions, eventually crashing
    the game.
  prefs: []
  type: TYPE_NORMAL
- en: Don't create unnecessary classes or interfaces
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Each class or interface has some extra binding space in its instance. The modular
    programming approach demands maximum possible breakage in the coding structure.
    This is directly proportional to the number of classes or interfaces. This is
    considered to be a good programming practice.
  prefs: []
  type: TYPE_NORMAL
- en: However, this has a consequence on memory usage. More classes consume more memory
    space for the same amount of data.
  prefs: []
  type: TYPE_NORMAL
- en: Use the minimum possible abstraction
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Many developers use abstraction in multiple layers for a better programming
    structure. It is very useful to restrict a certain part of a custom library and
    provide only selective APIs. When it comes to game development, if the developer
    works on games only, then use of abstraction is not very necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Abstraction results in more instructions, which directly leads to more processing
    time and more memory use. So, even if abstraction may be convenient sometimes,
    the developer should always think twice before using abstraction while developing
    games.
  prefs: []
  type: TYPE_NORMAL
- en: For example, a game may have a set of various enemies. In such a case, creating
    a single enemy interface and implementing it for different enemy objects helps
    create a simple and convenient program hierarchy. However, there may be completely
    different attributes for different enemies. So, the use of abstraction will depend
    on the game design. Whatever the case is, if developers use abstraction, then
    it will always increase the set of instructions to be processed at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Keep a check on services
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Services are useful for the completion of one task in the background, but they
    are very costly in terms of both process and memory. A developer should never
    keep a service running unless required. The best way to automatically manage the
    service life cycle is to use `IntentService`, which will finish once its work
    is done. For other services, it is the developer's responsibility to make sure
    that `stopService` or `stopSelf` are being called after the task is done.
  prefs: []
  type: TYPE_NORMAL
- en: This process proves to be very efficient for game development, as it actively
    supports dynamic communication between the user and developer.
  prefs: []
  type: TYPE_NORMAL
- en: Optimize bitmaps
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Bitmaps are the heaviest assets for a game. In game development, most of the
    heap memory is used by bitmaps. So, optimizing bitmaps can significantly optimize
    the use of heap memory during runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'Usually, the memory required for a bitmap to be loaded in memory is given by
    this formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BitmapSize = BitmapWidth * BitmapHeight * bytePerPixel*'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if a 480 x 800 size bitmap is being loaded in the `ARGB_8888`
    format (4 bytes), the memory will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*BitmapSize = 480 x 800 x 4 = 1536000 bytes ~ 1.5mb*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The format can be of the following types in Android:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ARGB_8888` (4 bytes)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RGB_565` (2 bytes)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ARGB_4444` (2 bytes) (deprecated in API level 13)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ALPHA_8` (1 byte)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each bitmap will occupy memory according to the preceding formula. So, it is
    recommended that you load a bitmap in memory as per requirement to avoid unnecessary
    heap usage.
  prefs: []
  type: TYPE_NORMAL
- en: Release unnecessary memory blocks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we have discussed earlier for freeing memory, the same can be applied on
    any object. After the task is finished, the instance should be set to null so
    that the garbage collector can identify and free the allocated memory.
  prefs: []
  type: TYPE_NORMAL
- en: In a game state machine, the class structure should provide an interface to
    free the memory of instantiated objects. There may be a scenario where a few of
    the member objects are done with their tasks and a few are still in use, so it
    would be a bad idea to wait for the entire class instance to be freed. The developer
    should selectively free the memory of unused objects without deleting the class
    instance.
  prefs: []
  type: TYPE_NORMAL
- en: Use external tools such as zipalign and ProGuard
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The ProGuard tool is efficient at shrinking, optimizing, and obfuscating the
    code by removing unused code and renaming classes, fields, and methods with a
    secured and encoded naming structure. ProGuard can make the code more compact,
    which directly impacts RAM usage.
  prefs: []
  type: TYPE_NORMAL
- en: In game development, developers often use many multiple third-party libraries,
    which may be pre-compiled with ProGuard. In those cases, the developer must configure
    ProGuard to exclude those libraries. It is also a good idea to protect the codebase
    from getting stolen.
  prefs: []
  type: TYPE_NORMAL
- en: zipalign can be used to realign the released APK. This optimizes the APK further
    to use less space and have a more compact size. Normally, most of the APK building
    frameworks provide zipalign automatically. However, the developer might need to
    use it manually for few cases.
  prefs: []
  type: TYPE_NORMAL
- en: Performance optimization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Performance means how smoothly the game will run on the target platform and
    maintain a decent FPS throughout the gameplay session. In the case of Android
    gaming, we already know about the wide range of hardware configurations. Maintaining
    the same performance across all devices is practically impossible. This is the
    reason developers choose target hardware and minimum hardware configuration to
    ensure that the game is performing well enough to be published. However, the expectation
    also varies from device to device.
  prefs: []
  type: TYPE_NORMAL
- en: In real development constraints, performance optimization is limited to the
    targeting set of hardware. Thus, memory has its own optimizing space in the development
    process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Technically, from the programming point of view, performance optimization can
    be done by paying more attention to writing and structuring code:'
  prefs: []
  type: TYPE_NORMAL
- en: Using minimum objects possible per task
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using minimum floating points
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using fewer abstraction layers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using enhanced loops wherever possible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoiding getters/setters of variables for internal use
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using static final for constants
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using minimum possible inner classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using minimum objects possible per task
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Creating unnecessary objects increases processing overhead as they have to
    be initialized in a new memory segment. Using the same object for the same task
    multiple times is much faster. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Using minimum floating points
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In machine-level language, there is nothing like an integer or float. It is
    always a bit indicating true or false (0 and 1 in technical language). So, an
    integer can be directly represented by a set of bits, but floating points requires
    extra processing overhead.
  prefs: []
  type: TYPE_NORMAL
- en: Until a point of time, there was no use of floating points in programming languages.
    Later, the conversion came, and floating point was introduced with extra processing
    requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Using fewer abstraction layers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is very obvious that abstraction demands extra processing per layer. So,
    as we increase the abstraction layers, the process becomes slower.
  prefs: []
  type: TYPE_NORMAL
- en: Using enhanced loops wherever possible
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the case of array and list parsing, an enhanced `for` loop works way faster
    than the usual conventional `for` loop as it has no iterating variable system,
    and each array or list element can be accessed directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of a non-enhanced loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an example of an enhanced loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Avoid getter/setters of variables for internal use
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Getters and setters are used to access or change the state of any internal element
    of an object from outside the object. In high-level reasoning, it does not follow
    the basic concept of data encapsulation. However, getters and setters are used
    widely in Android game development.
  prefs: []
  type: TYPE_NORMAL
- en: In many cases, developers use getters and setters from inside the class object.
    This unnecessarily increases processing time, resulting in degraded performance.
    So, developers should use getters and setters as little as possible and make sure
    they are not being used internally.
  prefs: []
  type: TYPE_NORMAL
- en: Use static final for constants
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Constants are not meant to be changed during runtime. In the case of global
    constants, the data is directly associated with the class object. Hence, we're
    required to parse the class object in order to access it.
  prefs: []
  type: TYPE_NORMAL
- en: Using static is an excellent idea to get rid of this extra process. Element
    accessibility increases significantly when using static for constants. However,
    the developer needs to keep a check on memory usage as well.
  prefs: []
  type: TYPE_NORMAL
- en: Using minimum possible inner classes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Each inner class adds an extra layer to processing. Sometimes, it is good to
    have inner classes in order to structure the codebase in an efficient and readable
    way. However, it comes with the cost of processing overhead. So, the developer
    should use the fewest possible inner classes in order to optimize performance.
  prefs: []
  type: TYPE_NORMAL
- en: Relationship between performance and memory management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Android game development, performance and memory optimization often conflict
    with each other. To maintain the visual quality of the game, better art assets
    are mandatory, which eventually increases memory overhead and performance lag.
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing memory needs to do frequent memory operations, resulting in performance
    drop. To increase performance, objects have to be readily available for smooth
    processing. Clearly, both cannot be applied at their extreme levels.
  prefs: []
  type: TYPE_NORMAL
- en: Balancing between them is the only way out to optimize the full game to run
    smoothly without exhausting memory.
  prefs: []
  type: TYPE_NORMAL
- en: Memory management in Android
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s discuss the memory management system in Android. It has a direct effect
    on the game development process. Games are treated like applications in Android.
    Very often, developers face memory issues in both the runtime and minimized states
    of the game. There are three main topics to discuss to understand the working
    principles:'
  prefs: []
  type: TYPE_NORMAL
- en: Shared application memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory allocation and deallocation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application memory distribution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shared application memory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Android uses the Linux kernel, and Linux uses "shared" pages to share the same
    memory segment within running processes or services. For example, Android often
    shares the "code" memory within processes. Very often, external libraries and
    JVM's executable code memory can be safely shared across processes without creating
    a deadlock. Data pages could be shared temporarily between processes, until a
    process modifies the shared memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Android allocates dedicated memory for each application or process. This is
    called private memory. The same process may also use shared memory. Android automatically
    sets a cap, depending on the total of both, to determine when the process or application
    will be killed, especially if it is in the background. This cap is called **Proportionate
    Set Size** (**PSS**):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Shared application memory](img/B05069_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If an application's PSS is high, then there is a very high chance that the process
    might be killed by Android. This scenario can be handled programmatically to keep
    memory usage in check, especially if the application is relying on some background
    activities or services to carry out some task. The developer has to make sure
    that the game uses minimum possible memory at any point in time, especially when
    the application goes into the background. It may be a good idea to free memory
    and objects that you no longer need in the background, and disconnect from any
    shared memory that you no longer need when you go into the background. This will
    reduce the chances of your application getting unexpectedly killed by the Android
    system.
  prefs: []
  type: TYPE_NORMAL
- en: Memory allocation and deallocation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Android memory management system defines a virtual cap for each application,
    which is the logical heap size. It can be increased if necessary, but only if
    there is free memory available. However, this logical heap size is not the actual
    allocated memory for the application. Calculated PSS is the actual physical cap
    that may vary during runtime and shared memory dependency.
  prefs: []
  type: TYPE_NORMAL
- en: 'Application memory cannot use more physical memory than PSS. So, after reaching
    this limit, if the application tries to allocate more memory, then it will receive
    `OutOfMemoryError` thrown by the system. Android might kill other empty or background
    processes to accommodate memory for the running application in a critical situation.
    Application memory will be deallocated in these scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: If the application quits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the process becomes inactive and some other process requires the memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the application crashes for any reason
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application memory distribution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Android sets a hard limit on the heap size for each app to maintain a multitasking
    environment. The exact heap size limit varies between hardware configurations
    based on the capacity of RAM of the device. If the application reaches the heap
    capacity and tries to allocate more memory, it will receive `OutOfMemoryError`,
    and the application will be killed by Android.
  prefs: []
  type: TYPE_NORMAL
- en: The developer needs to check the amount of memory available on the device and
    then determine an average target memory use. The developer can query the operating
    system for this amount of memory by calling `getMemoryClass()`. This returns an
    integer indicating the number of MBs available for the application's heap.
  prefs: []
  type: TYPE_NORMAL
- en: Processing segments in Android
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A game is basically an application in terms of functionality. Multiple applications
    or games can run on an Android platform. However, for games, only one game is
    active at one point of time, but rest of the applications run in the background.
  prefs: []
  type: TYPE_NORMAL
- en: Let's have a look at how Android processes its applications.
  prefs: []
  type: TYPE_NORMAL
- en: Application priority
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Android sets the priority of the running applications, and it can kill a running
    application of low priority depending on the requirement.
  prefs: []
  type: TYPE_NORMAL
- en: Each application uses some memory and processing bandwidth. There may be a situation
    where multiple applications are running together. If a new application wants to
    run, then Android allocates memory and process bandwidth for the new application.
    If there is not enough bandwidth or process available, then Android kills one
    or more than one running application with low priority.
  prefs: []
  type: TYPE_NORMAL
- en: 'Android sets priority by the following status:'
  prefs: []
  type: TYPE_NORMAL
- en: Active process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visible process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Active services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Background process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Void process![Application priority](img/B05069_08_02.jpg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Active process
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An active process is basically a process that communicates with the platform
    very frequently and runs in the foreground. This process is the last one to be
    killed by Android, when necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'An active process fulfils the following criteria:'
  prefs: []
  type: TYPE_NORMAL
- en: It runs in the foreground
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is visible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At least one Android activity is running
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It interacts actively with the user interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All event handlers are in the active state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visible process
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This process is basically an active process that is not in the foreground and
    does not interact with the user interface. It is the second highest priority for
    the Android platform.
  prefs: []
  type: TYPE_NORMAL
- en: 'The criteria for this process are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: It runs in the background
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has visible activity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It does not interact with the user interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: UI event handlers are not active
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Process event handlers are active
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Active services
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Active services are services that support an ongoing process without a visible
    interface. Android will kill such services first and then the actual active process.
  prefs: []
  type: TYPE_NORMAL
- en: 'This service follows the following criteria:'
  prefs: []
  type: TYPE_NORMAL
- en: It has no visible interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It supports or works for respective active processes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It runs in the background
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Background process
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Background processes are basically minimized or inactive processes. These processes
    are not visible on the screen. The process thread does not run for these processes,
    but the application state is saved in the memory. These are vulnerable to being
    killed by the processor. These processes can be resumed after interruption.
  prefs: []
  type: TYPE_NORMAL
- en: These are inactive/minimized processes. They remain in memory. The application
    stays in the paused state.
  prefs: []
  type: TYPE_NORMAL
- en: Void process
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Void processes are also called empty processes. A void process is literally
    empty. It holds no application data or state in memory. This process has the highest
    priority in order to get killed by the operating system.
  prefs: []
  type: TYPE_NORMAL
- en: Application services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Android application services are parts of the actual application process. These
    services may run within and outside the parent process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s clear two very common misconceptions about services:'
  prefs: []
  type: TYPE_NORMAL
- en: A service is not a separate process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A service is not a thread
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fact is, services are part of an application process and not separate processes.
    Services are not threads. They are part of the process that runs in the background,
    and they keep running even if the main application is in a suspended state.
  prefs: []
  type: TYPE_NORMAL
- en: Services are meant to carry out a single task and do not call back the parent
    application. This is why they can run even after the application is closed.
  prefs: []
  type: TYPE_NORMAL
- en: Service life cycle
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Services are started by the parent application process, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: After being started, the service starts carrying out a single task in the background.
    The service can stop itself after the task is done. For example, a simple file
    download service will stop after a successful downloading task. Many game developers
    use such features in their games to improve the user experience.
  prefs: []
  type: TYPE_NORMAL
- en: These services can be bound with one or more processes for interactivity. The
    application can send request and get response from a bound service, which creates
    a server-client architecture. But these bound services have a limited lifetime
    until the last application component is bound with the service.
  prefs: []
  type: TYPE_NORMAL
- en: Resource processing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Android has its own resource process structure. It has some predefined resource
    types:'
  prefs: []
  type: TYPE_NORMAL
- en: Drawable resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Layout resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Color resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Menu resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tween animation resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drawable resources
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All drawable resources fall in this category, including frame animation. Android
    provides the `res/drawable/` project path dedicated to all drawable resources.
    All bitmaps, various XML, and predetermined frame animations can be placed here.
  prefs: []
  type: TYPE_NORMAL
- en: These can be accessed through the `R.drawable` class.
  prefs: []
  type: TYPE_NORMAL
- en: Layout resources
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All defined layouts fall in this category. Android provides the `res/layout/`
    project path dedicated to all layout files. Layout is useful to define the application
    UI.
  prefs: []
  type: TYPE_NORMAL
- en: These can be accessed through the `R.layout` class.
  prefs: []
  type: TYPE_NORMAL
- en: Color resources
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Color resources are basically a list of colors that are due to change upon changing
    the view of the applicable object. Android stores this in the `res/color/` folder
    in the hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: These can be accessed through the `R.color` class.
  prefs: []
  type: TYPE_NORMAL
- en: Menu resources
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All menu contents can be defined here. Android provides the `res/menu/` project
    path dedicated to all **drawable** resources.
  prefs: []
  type: TYPE_NORMAL
- en: These can be accessed through the `R.menu` class.
  prefs: []
  type: TYPE_NORMAL
- en: Tween animation resources
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All tween animation resources fall in this category. Android provides the `res/anim/`
    project path dedicated to all tween animation resources.
  prefs: []
  type: TYPE_NORMAL
- en: These can be accessed through the `R.anim` class.
  prefs: []
  type: TYPE_NORMAL
- en: Other resources
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All other resources are places in the `res/values/` folder. Many developers
    define the string under this category with styles.
  prefs: []
  type: TYPE_NORMAL
- en: These can be accessed through the `R.values` class.
  prefs: []
  type: TYPE_NORMAL
- en: Different memory segments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'During the runtime of an application, three main kinds of memory segments are
    used depending on the behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: Stack memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Heap memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Register memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stack memory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All auto variables and runtime allocation during processing will be stored in
    the stack memory segment. The garbage collector deallocates the memory after use.
    So, there is no manual memory management process associated with the stack memory.
  prefs: []
  type: TYPE_NORMAL
- en: However, extensive use of auto variables also may cause memory errors. This
    is the reason we have already discussed why minimizing unnecessary auto variable
    declarations is necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Stack memory is also used to execute program instructions. Each instruction
    is broken down into a single operation and put into a stack by the interpreter.
    Then, a recursive procedure is used to execute all the instruction stacks and
    return the result.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at how stack memory works for objects and primitives:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `bitMapCount` is an `int` local variable and gets stored in
    the stack directly. The memory used for this variable will be freed just after
    the scope.
  prefs: []
  type: TYPE_NORMAL
- en: However, `testBmp` is a bitmap object, which will be allocated in the heap,
    but the reference will be stored in the stack. When the program pointer comes
    out of the scope, the reference will be automatically deleted, and the garbage
    collector can identify the heap memory allocated for `testBmp` as having zero
    reference and will free this memory segment.
  prefs: []
  type: TYPE_NORMAL
- en: Heap memory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Heap memory is the segment where all the instances of classes and arrays are
    stored. JVM allocates this memory while instantiating any object.
  prefs: []
  type: TYPE_NORMAL
- en: The garbage collector does not operate automatically on this memory segment
    during application runtime. It is the developer's responsibility to free the memory
    after use. In the case of Android, the garbage collector will only free the memory
    when there is no reference for the memory segment in the running application.
  prefs: []
  type: TYPE_NORMAL
- en: Game assets are the major elements that are stored in this memory segment. Art
    is the most significant asset among them. So, optimizing bitmaps has a direct
    impact on heap memory uses. Very often, the developer allocates memory for assets
    and does not break the reference. This causes the memory block to be occupied
    during the entire runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the memory for the bitmap will be occupied even after the use,
    until the `ExampleClass` instance is there in memory. The interpreter has no standing
    instruction to free the memory segment, because `testBmp` still has the reference
    to the memory allocated to the bitmap.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can optimize this in the following way with a bit of modification:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In this case, by calling `unloadBitmap()` after the use of the bitmap will remove
    the reference of the loaded bitmap from `testBmp`. So, the garbage collector will
    find this memory location as zero-referenced memory and free it to be used for
    other allocations.
  prefs: []
  type: TYPE_NORMAL
- en: Register memory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the case of Android development, the developer must not worry about register
    memory. Registers are directly associated with the processor, and the processor
    stores the most significant and frequently used data in this memory segment.
  prefs: []
  type: TYPE_NORMAL
- en: Register memory is the fastest memory segment used for any application runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Importance of memory optimization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: No matter how the game is, how good it looks, or how well it is designed, if
    the game does not run on the target platform, then it cannot be successful. We
    already know that Android has various sets of hardware configurations.
  prefs: []
  type: TYPE_NORMAL
- en: The main variations of hardware are specific to the processor and memory. In
    the case of processors, it depends on their speed and quality. In case of memory
    or RAM, it is only the volume.
  prefs: []
  type: TYPE_NORMAL
- en: Even today, RAM can vary from 512 MB to 4 GB in Android devices. Memory optimization
    should always have a minimum target of RAM as per design. So, memory optimization
    is immensely important in order to run a game on the minimum available RAM.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, the developer fits the peak usage within the target limit of memory.
    However, they perform on a testing device, which does not project a real-time
    scenario most of the time. There is always an error margin. So, it is not always
    true that if the game runs on a certain limit of RAM, it will always be provided
    with the same memory. This is the place when memory optimization plays a major
    role. It helps a lot in creating the buffer range for the game to run in a real-time
    scenario.
  prefs: []
  type: TYPE_NORMAL
- en: There could be a scenario where the application runs out of memory, even when
    it does not require the amount of RAM it demands. This clearly indicates that
    the application is suffering from memory leakage. Memory leakage is one of the
    most common problems in game development. Optimizing memory properly helps get
    rid of this problem.
  prefs: []
  type: TYPE_NORMAL
- en: Another aspect of memory optimization is to increase the probability of the
    game to stay in the background. When an application goes into the background,
    Android might kill the application if it needs to free memory space for other
    foreground applications. Memory optimization makes sure that the application occupies
    the minimum possible memory while running. So, it is possible to save the data
    of the state in the cache for a longer period of time for applications that use
    less memory.
  prefs: []
  type: TYPE_NORMAL
- en: Many games use game services at the backend. If the application is not active,
    then there is a good chance that the service may also get killed by the operating
    system.
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing overall performance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Earlier, we discussed performance optimization from only the programming point
    of view. Let's discuss other scopes of optimizing the performance of Android games.
  prefs: []
  type: TYPE_NORMAL
- en: 'The developer can optimize performance from the time of design to development
    through the following points:'
  prefs: []
  type: TYPE_NORMAL
- en: Choosing the base resolution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining the portability range
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Program structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing the database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing the network connection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choosing the base resolution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: From the point of view of game development on Android, choosing the base resolution
    is probably the most significant design decision. Base resolution defines the
    scale of the graphical or visual element. The larger the resolution that the developer
    chooses to work upon, the more storage and process time it takes. Base resolution
    is also responsible for the quality and color information to be stored with bitmaps.
    Comparatively lower resolution does not demand many details in the visible asset,
    which can optimize bitmap data. However, as the resolution increases, it requires
    more data to preserve detailing. Eventually, this has a significant influence
    on processing.
  prefs: []
  type: TYPE_NORMAL
- en: With the advancement of technology, Android device resolutions are getting bigger
    and better. So developers now choose a bigger resolution to support higher range
    devices.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the portability range
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is also a design phase optimization. In this stage, the developer needs
    to decide the range of hardware platform to support. This includes various configurations.
    We already know that the Android device range includes a large set of variations
    in terms of memory, processing speed, graphics quality, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the range supports the range of portability of a similar device, then optimization
    becomes easier. However, this is not the case for most cases of game development.
    Usually, the developer should divide the optimization into three segments:'
  prefs: []
  type: TYPE_NORMAL
- en: Low-performing devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Average-performing devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: High-performing devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, ideally, there should be three layers of optimization to properly define
    the portability range.
  prefs: []
  type: TYPE_NORMAL
- en: Program structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The program structure is another very important technical design decision for
    both performance and memory optimization. This includes all the parameters for
    programming optimization, which we have already discussed.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, program hierarchy also matters for performance. Often, the developer
    creates unnecessary intermediate calls to parse through several layers. A few
    singleton classes help here to optimize performance significantly. Proper game
    state machine design also helps optimize performance.
  prefs: []
  type: TYPE_NORMAL
- en: Managing the database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are many games that are mainly data driven. In such cases, a database
    needs to be managed properly.
  prefs: []
  type: TYPE_NORMAL
- en: For example, a quiz game must have a question bank maintained in the database
    at some server to avoid frequent update of the game build. Database queries take
    time to execute as there is also a network layer in between. So, the game layer
    sends a query to the database. Then, the database fetches the data, binds it accordingly,
    and sends it back to the game. Then, the game has to unbind the received data
    in order to use it. Using the minimum query calls is the only way to minimize
    the performance overhead. Using a faster database also helps the game to perform
    well.
  prefs: []
  type: TYPE_NORMAL
- en: Managing the network connection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Modern day gaming has enhanced to multiplayer and server-controlled mechanisms,
    which reduces the job of frequent updates of the game build. In both cases, network
    connection needs to be implemented in a proper way. There are mainly two types
    of multiplayer architecture currently being followed:'
  prefs: []
  type: TYPE_NORMAL
- en: Turn-based multiplayer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Real-time multiplayer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's comparatively easy to manage a turn-based multiplayer system than real-time
    multiplayer. There is another model of multiplayer called asynchronous multiplayer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each network call results in a lag in performance, as the game is dependent
    on the data from the server. So, the client-server architecture needs to be optimized
    in order to achieve the following goals:'
  prefs: []
  type: TYPE_NORMAL
- en: Less lag time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Less layer processing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Less number of pings to the server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Increasing the frame rate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The ultimate target for performance optimization is to increase the frame rate.
    A high frame rate automatically delivers smooth gameplay. However, the developer
    has to make sure that the frame rate effect is visible in the game in terms of
    smoothness and effect.
  prefs: []
  type: TYPE_NORMAL
- en: For the current mobile gaming industry, an average FPS of 60 for a 2D game or
    mid-scaled 3D game is considered high performance. On the other hand, massive
    3D games might consider an average FPS of 30-35 as good performance.
  prefs: []
  type: TYPE_NORMAL
- en: High-performing games with higher FPS open a door for further visual effects
    to improve the user experience. This has a direct impact on monetization.
  prefs: []
  type: TYPE_NORMAL
- en: Importance of performance optimization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we have just discussed, performance optimization directly influences the
    frame rate, which again directly impacts the gameplay experience. However, performance
    optimization has other importance too:'
  prefs: []
  type: TYPE_NORMAL
- en: Games might crash or go in a not-responding state due to a non-optimized program
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance optimization has a direct impact on memory as well
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance optimization can enlarge the range of supported hardware platforms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common optimization mistakes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The gaming industry is now one of the fastest growing industries. To keep up
    with the speed and to stand in the market, many companies plan a shorter development
    period with limited optimization. In this scenario, the developer often commits
    the following mistakes knowingly or unknowingly:'
  prefs: []
  type: TYPE_NORMAL
- en: Programming mistakes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design mistakes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wrong data structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using game services incorrectly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Programming mistakes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Programming is a manual process, and to err is human. So, it is obvious that
    there is no bug-free and completely optimized programming for games. However,
    there are few ways in which a programmer can minimize mistakes to have an optimized
    game code base. Let's discuss the major mistakes a programmer commits while developing
    a game in Android.
  prefs: []
  type: TYPE_NORMAL
- en: Programmers often create many temporary variables and forget to keep track of
    them. Often, these variables occupy unnecessary memory and increase processing
    calls.
  prefs: []
  type: TYPE_NORMAL
- en: Sorting is widely used in game development for many purposes. There are several
    sorting algorithms. Most of the time, the developer chooses convenient techniques
    rather than efficient ones. For large arrays or lists, this may cause a serious
    lag in process flow.
  prefs: []
  type: TYPE_NORMAL
- en: Using too many static instances for accessibility ease is another bad practice.
    Using static may help in faster processing, but is not a good idea to make many
    static instances, as it blocks a lot of memory space during its lifetime. Many
    programmers even forget to manually free this memory.
  prefs: []
  type: TYPE_NORMAL
- en: Creating abstract layers and using them extensively makes the process slower.
    However, it is a good programming practice generally, but for game programming,
    it only helps in limited cases.
  prefs: []
  type: TYPE_NORMAL
- en: Convenient loop use is another bad programming practice for games. There are
    several ways to work with loops. A programmer should first determine what goes
    best with the algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Game programming is mostly about logical development than technical. It may
    take time to build up the perfect logic for certain tasks. Many game programmers
    do not consider multiple ways of doing one task. Most of the time, it leaves a
    great scope of optimization unexplored.
  prefs: []
  type: TYPE_NORMAL
- en: Design mistakes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Designers often make mistakes when defining the hardware range and the game
    scope. Both are very important factors to create an optimized game design.
  prefs: []
  type: TYPE_NORMAL
- en: Another mistake is to target the wrong target resolution. The target resolution
    has a direct effect on the art asset size. Targeting the wrong resolution leads
    to unnecessary scaling, causing extra processing overhead.
  prefs: []
  type: TYPE_NORMAL
- en: Wrong game data structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Data structure is an inevitable part of game programming. Android supports dynamic
    array initialization. Yet, many developers prefer lists to store data. Lists are
    much slower than arrays. Lists should only be used when it is absolutely necessary.
  prefs: []
  type: TYPE_NORMAL
- en: It is the developer's responsibility to figure out the perfect data structure
    for data-driven games. Proper technical design should include a data structure
    model and its use.
  prefs: []
  type: TYPE_NORMAL
- en: Using game services incorrectly
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Services are very useful at times. In the modern day gaming industry, services
    are used for download/upload of data, for push notifications, for deep linking
    in games, or for server connectivity. However, services come at a huge cost of
    processing and memory consumption. Running services causes significant amount
    of power consumption as well.
  prefs: []
  type: TYPE_NORMAL
- en: So, using services should be mandatory only when there is no other way around.
  prefs: []
  type: TYPE_NORMAL
- en: Best optimization practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Some defined and logical optimization techniques are available. We will discuss
    the major scopes and fields that are related to Android game development:'
  prefs: []
  type: TYPE_NORMAL
- en: Game design constraints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Game development optimization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Game data structure model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using game assets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling cache data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design constraints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is always a best practice to define the target hardware platforms and acknowledge
    the limitation. Technical design can structure the development constraints according
    to it.
  prefs: []
  type: TYPE_NORMAL
- en: The scalability and portability should also be decided at the time of designing
    the game. This should give the developer a tentative platform limitation along
    with other constraints. We have already discussed design optimization. All those
    segments should be evaluated before going into development.
  prefs: []
  type: TYPE_NORMAL
- en: Targeting screen size and resolution has to be fixed when designing the game
    along with creating layouts, which will fit in multiple resolutions. This is because
    Android has many screen sizes as discussed earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting the minimum Android version and the target Android version gives the
    developer an advantage when structuring the development project, as supported
    API levels and platform features are already defined.
  prefs: []
  type: TYPE_NORMAL
- en: Development optimization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is one of the most important segments of optimization. Here are some tips
    to carry out the development process successfully with optimization:'
  prefs: []
  type: TYPE_NORMAL
- en: Using as many as possible folder structures provided by Android for project
    scalability.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using resource formats according to the dpi list provided by Android.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The developer should avoid scaling images. This effectively reduces memory and
    processing overhead.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using sprites for multiple purposes is also a good practice to create animations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The tiling technique is very useful in terms of reducing memory consumption.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overriding the `onDraw()` method is always a good practice to flush the old
    rendering pipeline and to use a systematic draw order with absolute requirement.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use XML-based layout wherever possible; however, games have very limited scope
    for this Android feature.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data structure model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Data structures are one of the inevitable parts of game program design since
    the beginning, irrespective of the scale of the game. Each game always processes
    data for various purposes such as sorting, searching, storing, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: There are many data structure models available for various operations. Each
    operation has its own advantages and disadvantages. The developer must choose
    the most efficient one depending on the requirement.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take an example of data storing comparison between an array and a linked
    list. Effectively, linked lists are more flexible and dynamic in nature than arrays.
    However, this feature comes at a cost of slow processing and higher memory consumption.
  prefs: []
  type: TYPE_NORMAL
- en: The developer might not always require to store dynamic data. For example, if
    cricket team data needs to be stored, then an array is sufficient, because there
    will always be 11 players on each side, and that cannot be modified during gameplay.
    It will make the process much faster and more efficient than using a linked list
    in this particular case.
  prefs: []
  type: TYPE_NORMAL
- en: In another case, for a shooting game, the developer cannot predict the number
    of bullets the user may fire during gameplay. So, a queue data structure will
    be most efficient in order to process all the fired bullets.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, stacks and tree structures can be chosen whenever they fit the purpose.
    The same approach may be taken for sort and search algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: Asset-using techniques
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have already categorized assets for games. Let's discuss them from the perspective
    of optimization techniques and best practices.
  prefs: []
  type: TYPE_NORMAL
- en: Art assets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A separate optimization technique can be applied to a set of art assets. Art
    assets are the face of games. So, it is necessary that the visuals are attractive
    enough to start gameplay.
  prefs: []
  type: TYPE_NORMAL
- en: As we have discussed already, better art assets cost memory and performance.
    However, this can be minimized to a certain level. There are several tools for
    art asset optimization. However, using inappropriate tools can cause data loss,
    which eventually results in poor visual quality.
  prefs: []
  type: TYPE_NORMAL
- en: Art should never compromise from the perspective of visual quality. Often, artists
    develop assets that do not reflect perfectly in games because of inappropriate
    optimization.
  prefs: []
  type: TYPE_NORMAL
- en: We have already discussed how art assets should be made. Now, let's assume that
    some art is using only 8-bit data space as raw format, but the same is exported
    in a 24-bit format. Then, the developer can use tools to optimize the asset to
    a typical 8-bit format without affecting the visual quality.
  prefs: []
  type: TYPE_NORMAL
- en: This rule also applies for complete opaque assets. The developer can get rid
    of the transparency information in order to have optimized art assets.
  prefs: []
  type: TYPE_NORMAL
- en: Audio assets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Audio assets are standalone assets too. Audio has become a very important asset
    for extended user experience. Audio configuration can vary with a wide range of
    frequency, bit depth, and compression techniques. Each variation in configuration
    has a different level of processing and memory consumption.
  prefs: []
  type: TYPE_NORMAL
- en: So, audio optimization is also a very important part of the optimization process.
    Regular practice in the Android game development industry is to choose two different
    formats of audio for SFX and music files.
  prefs: []
  type: TYPE_NORMAL
- en: One thing that developers generally ignore is audio information data. Few Android
    devices have a certain frequency cap, but sounds are usually good when more frequencies
    are used. So, it is a technical design level step to determine the cap for Android
    game sounds. So, every sound should be made within the proximity.
  prefs: []
  type: TYPE_NORMAL
- en: Sound designers need to keep up the quality within the limit. In this way, audio
    assets can be optimized at the time of development.
  prefs: []
  type: TYPE_NORMAL
- en: Other assets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Besides art and audio, there may be other data assets used in games. The data
    format can be anything, such as binary, text, XML, JSON, or custom. Custom formats
    are basically the same as binary format, with some encryption.
  prefs: []
  type: TYPE_NORMAL
- en: It is a common practice in game development to use data sets separately. A separate
    data set helps structure the project and give flexibility to use the same code
    for a different output. Often, the developer updates data source to update the
    complete game experience without creating a new APK. This reduces development
    time in the longer run in order to maintain the game and do easy updates.
  prefs: []
  type: TYPE_NORMAL
- en: From the optimization point of view, these data sources should be optimized
    enough to get processed quickly and not consume too much memory. However, reading
    and writing an external file takes time. Normally, binary files are the fastest
    to be processed and smallest in size. However, after reading the binary data,
    it has to be parsed to be used in games, which eventually increases processing.
  prefs: []
  type: TYPE_NORMAL
- en: The most commonly used data formats are XML and JSON. The Android library has
    support for both of them, which includes a generic parser. The developer can have
    readily available data without making extra processing effort. However, the data
    can be manipulated during gameplay, depending on the game's requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Handling cache data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A cache is a memory segment that is similar to RAM from a functionality point
    of view, but acts faster than conventional RAM. The processor can access this
    segment much faster. So, logically, a cache should only store data that is being
    used frequently.
  prefs: []
  type: TYPE_NORMAL
- en: The best possible way to handle cache data is to keep a check on the application
    memory usage. Generally, there should be at least 10 % of free memory available
    for the operating system. It is tested that an application can use an average
    of 2% of the total free memory.
  prefs: []
  type: TYPE_NORMAL
- en: However, the developer cannot control the cache technically. They can only make
    sure that the most commonly used elements are optimized in a perfect way so that
    the executer automatically uses cache memory for them.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Optimization is one of the most important tasks in any software development,
    especially in games, where logical programming dominates technical programming.
    There are plenty of optimization tools and techniques available for technical
    programming as it has the most common algorithms to implement. However, in the
    case of game programming, each gameplay indicates a different set of algorithms.
    In many cases, an artificial intelligence algorithm is also made separately. So,
    there is a very high probability that the programmer has to find out an efficient
    way to optimize freshly written algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: We have discussed all the possible scopes of optimization in Android game development.
    Technical optimization is mandatory as it has fixed guidelines to follow. However,
    logical development will depend on the game algorithm and its requirements. So,
    it is an extra effort for the game developer to optimize Android games.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, developers over-optimize games. This is not recommended. Over-optimization
    usually downgrades the quality of the game. So, at the time of technical design,
    optimization cases should be declared.
  prefs: []
  type: TYPE_NORMAL
- en: Most large-scale development processes have a separately defined task set for
    optimization. Some developers choose to develop a dynamic optimization process.
    This means that the developer optimizes the game in different stages on different
    scales. Both the processes are effective, but the first one is logically more
    sensible, because defining a separate task will always give an idea about the
    tentative time duration for overall optimization. This helps manage the entire
    game development process in a better way.
  prefs: []
  type: TYPE_NORMAL
- en: All optimization processes are validated through a testing phase. All design,
    engineering, and art work is tested in this segment of game development. We will
    have a deeper look at testing in the next chapter of this book.
  prefs: []
  type: TYPE_NORMAL
