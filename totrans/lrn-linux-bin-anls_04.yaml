- en: Chapter 4. ELF Virus Technology – Linux/Unix Viruses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The art of virus writing has been around for several decades now. In fact, it
    goes all the way back to the Elk Cloner Apple virus that was successfully launched
    in the wild in 1981 through a floppy disk video game. Since the mid '80s and through
    the '90s, there have been various secret groups and hackers who have used their
    arcane knowledge to design, release, and publish viruses in virus and hacker e-zines
    (see [http://vxheaven.org/lib/static/vdat/ezines1.htm](http://vxheaven.org/lib/static/vdat/ezines1.htm)).
  prefs: []
  type: TYPE_NORMAL
- en: The art of virus writing is usually of great inspiration to hackers and underground
    technical enthusiasts, not because of the destruction that they are capable of,
    but rather the challenge in designing them and the unconventional coding techniques
    that are required to succeed in programming a parasite that keeps its residency
    by hiding in other executables and processes. Also, the techniques and solutions
    that come with keeping a parasite stealthy, such as polymorphic and metamorphic
    code, present a unique challenge to programmers.
  prefs: []
  type: TYPE_NORMAL
- en: UNIX viruses have been around since the early '90s, but I think many would agree
    to say that the true father of the UNIX virus is Silvio Cesare ([http://vxheaven.org/lib/vsc02.html](http://vxheaven.org/lib/vsc02.html)),
    who published many papers in the late 90s on ELF virus infection methods. These
    methods are still being used today in different variations.
  prefs: []
  type: TYPE_NORMAL
- en: Silvio was the first to publish some awesome techniques, such as PLT/GOT redirection,
    text segment padding infections, data segment infections, relocatable code injection,
    `/dev/kmem` patching, and kernel function hijacking. Not only that, but he personally
    played a big role in my introduction to ELF binary hacking, and I will always
    remain grateful for his influence.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will discuss why it is important to understand ELF virus
    technology and how to design them. The technology behind an ELF virus can be utilized
    for many things other than writing viruses, such as general binary patching and
    hot patching, which can be used in security, software engineering, and reversing.
    In order to reverse-engineer a virus, it would behoove you to understand how many
    of them work. It is worth noting that I recently reverse-engineered and wrote
    a profile for a unique and exceptional ELF virus called **Retaliation**. This
    work can be found at [http://www.bitlackeys.org/#retaliation](http://www.bitlackeys.org/#retaliation).
  prefs: []
  type: TYPE_NORMAL
- en: ELF virus technology
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The world of ELF virus technology shall open up many doors to you as a hacker
    and engineer. To begin, let's discuss what an ELF virus is. Every executable program
    has a control flow, also called the path of execution. The first aim of an ELF
    virus is to hijack the control flow so that the path of execution is temporarily
    altered in order to execute the parasite code. The parasite code is usually responsible
    for setting up hooks to hijack functions and also for copying itself (the body
    of the parasite code) into another program that hasn't yet been infected by the
    virus. Once the parasite code is done running, it usually jumps to the original
    entry point or the regular path of execution. This way, the virus goes unnoticed,
    since the host program appears to be executing normally.
  prefs: []
  type: TYPE_NORMAL
- en: '![ELF virus technology](img/00006.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.1: Generic infection to an executable'
  prefs: []
  type: TYPE_NORMAL
- en: ELF virus engineering challenges
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The design phase of an ELF virus may be considered an artistic endeavor, requiring
    creative thinking and clever constructs; many passionate coders will agree with
    this. Meanwhile, it is a great engineering challenge that exceeds the regular
    conventions of programming, requiring the developer to think outside conventional
    paradigms and to manipulate the code, data, and environment into behaving a certain
    way. At one point in time, I did a security assessment at a large **antivirus**
    (**AV**) company for one of their products. While talking with the developers
    of the AV software, I was amazed that next to none of them had any real idea of
    how to engineer a virus, let alone design any real heuristics for identifying
    them (other than signatures). The truth is that virus writing is difficult, and
    requires serious skill. There are a number of challenges that come into play when
    engineering them, and before we discuss the engineering components, let's look
    at what some of these challenges are.
  prefs: []
  type: TYPE_NORMAL
- en: Parasite code must be self-contained
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A parasite must be able to physically exist inside another program. This means
    that it does not have the luxury of linking to outside libraries through the dynamic
    linker. The parasite must be self-contained, which means that it relies on no
    external linking, is position independent, and is able to dynamically calculate
    memory addresses within itself; this is because the addresses will change between
    each infection, since the parasite will be injected into an existing binary where
    its position will change each time. This means that if the parasite code references
    a function or a string by its address, the hardcoded address will change and the
    code will fail; instead, use IP-relative code with a function that calculates
    the address of the code/data by its offset to the instruction pointer.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In some more complex memory viruses such as my *Saruman* virus, I allow the
    parasite to be compiled as an executable program with dynamic linking, but the
    code to launch it into a process address space is very complicated, because it
    must handle relocations and dynamic linking manually. There are also relocatable
    code injectors such as Quenya, which allow a parasite to be compiled as relocatable
    objects, but the infector must be able to support handling relocations during
    the infection phase.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Compile your initial virus executable with the `gcc` option `-nostdlib`. You
    may also compile it with `-fpic -pie` to make the executable **position-independent
    code** (**PIC**). The IP-relative addressing available on x86_64 machines is actually
    a nice feature for virus writers. Create your own common functions, such as `strcpy()`
    and `memcmp()`. When you need advanced functionality such as heap allocation with
    `malloc()`, you may instead use `sys_brk()` or `sys_mmap()` to create your own
    allocation routines. Create your own syscall wrappers, for example, a wrapper
    for the `mmap` syscall is shown here, using C and inline assembly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Once you have a wrapper calling the `mmap()` syscall, you can create a simple
    `malloc` routine.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `malloc` function is used to allocate memory on the heap. Our little `malloc`
    function uses a memory-mapped segment for each allocation, which is inefficient
    but suffices for simple use cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Complications with string storage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This challenge rather blends in with the last section on self-contained code.
    When handling strings in your virus code, you may have:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: You will want to tend to stay away from code such as the preceding one. This
    is because the compiler will likely store the `elfmaster` data in the `.rodata`
    section, and then reference that string by its address. The address will not be
    valid once the virus executable is injected inside another program. This problem
    is really coupled with the problem of hardcoded addresses that we discussed earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Use the stack to store strings so that they are dynamically allocated at runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Another neat trick that I just recently discovered during the construction
    of the Skeksi virus for 64-bit Linux is to merge the text and data segment into
    a single segment, that is, **read+write+execute** (**RWX**), by using the `-N`
    option with `gcc`. This is very nice because the global data and read-only data,
    such as the `.data` and `.rodata` sections, are all merged into a single segment.
    This allows the virus to simply inject the entire segment during the infection
    phase, which will include string literals such as those from `.rodata`. This technique
    combined with IP-relative addressing allows a virus author to use traditional
    string literals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This type of string can now be used in the virus code, and the method of storing
    strings on the stack can be avoided entirely. It is important to note, however,
    that keeping all of the strings stored off the stack in global data will cause
    the overall size of the virus parasite to increase, which is sometimes undesirable.
    The Skeksi virus was recently released and is available at [http://www.bitlackeys.org/#skeksi](http://www.bitlackeys.org/#skeksi).
  prefs: []
  type: TYPE_NORMAL
- en: Finding legitimate space to store parasite code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is one of the big questions to answer when writing a virus: where will
    the payload (the body of the virus) be injected? In other words, where in the
    host binary will the parasite live? The possibilities vary from binary format
    to binary format. In the `ELF` format, there are quite a number of places to inject
    code, but they all require correct adjustment of the various different `ELF` header
    values.'
  prefs: []
  type: TYPE_NORMAL
- en: The challenge isn't necessarily finding space but rather adjusting the `ELF`
    binary to allow you to use that space while keeping the executable file looking
    reasonably normal and staying within the `ELF` specifications closely enough so
    that it still executes properly. There are many things that must be considered
    when patching a binary and modifying its layout, such as page alignment, offset
    adjustments, and address adjustments.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Read the `ELF` specs carefully when creating new methods of binary patching,
    and make sure that you stay within the boundaries necessary for program execution.
    In the next section, we will discuss some techniques of virus infection.
  prefs: []
  type: TYPE_NORMAL
- en: Passing the execution control flow to the parasite
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here is another common challenge, which is how to pass the control flow of the
    host executable to the parasite. In many cases, it will suffice to adjust the
    entry point in the `ELF` file header to point to the parasite code. This is reliable,
    but also very obvious. If the entry point has been modified to point at the parasite,
    then we can use `readelf -h` to see the entry point and immediately know the location
    of the parasite code.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you don't want to modify the entry point address, then consider finding a
    place where you can insert/modify a branch to your parasite code, such as inserting
    a `jmp` or overwriting a function pointer. One great place for this is in the
    `.ctors` or `.init_array` sections, which contain function pointers. The `.dtors`
    or `.fini_array` sections can work as well if you don't mind the parasite executing
    after the regular program code (instead of before).
  prefs: []
  type: TYPE_NORMAL
- en: ELF virus parasite infection methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are only so many places to fit code in a binary, and for any sophisticated
    virus, the parasite is going to be at least a few thousand bytes and will require
    enlarging the size of the host executable. In `ELF` executables, there aren't
    a whole lot of code caves (such as in the PE format), so you are not likely to
    be able to shove more than just a meager amount of shellcode into existing code
    slots (such as areas that have 0s or `NOPS` for function padding).
  prefs: []
  type: TYPE_NORMAL
- en: The Silvio padding infection method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This infection method was conceived by Silvio Cesare in the late '90s and has
    since shown up in various Linux viruses, such as *Brundle Fly* and the POCs produced
    by Silvio himself. This method is inventive, but it limits the infection payload
    to one page size. On 32-bit Linux systems, this is 4096 bytes, but on 64-bit systems,
    the executables use large pages that measure 0x200000 bytes, which allows for
    about a 2-MB infection. The way that this infection works is by taking advantage
    of the fact that in memory, there will be one page of padding between the text
    segment and data segment, whereas on disk, the text and data segments are back
    to back, but someone can take advantage of the expected space between segments
    and utilize that as an area for the payload.
  prefs: []
  type: TYPE_NORMAL
- en: '![The Silvio padding infection method](img/00007.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.2: The Silvio padding infection layout'
  prefs: []
  type: TYPE_NORMAL
- en: The text padding infection created by Silvio is heavily detailed and documented
    in his VX Heaven paper *Unix ELF parasites and viruses* ([http://vxheaven.org/lib/vsc01.html](http://vxheaven.org/lib/vsc01.html)),
    so for extended reading, by all means check it out.
  prefs: []
  type: TYPE_NORMAL
- en: Algorithm for the Silvio .text infection method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Increase `ehdr->e_shoff` by `PAGE_SIZE` in the ELF file header.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Locate the text segment `phdr`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Modify the entry point to the parasite location:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Increase `phdr[TEXT].p_filesz` by the length of the parasite.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Increase `phdr[TEXT].p_memsz` by the length of the parasite.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For each `phdr` whose segment is after the parasite, increase `phdr[x].p_offset`
    by `PAGE_SIZE` bytes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find the last `shdr` in the text segment and increase `shdr[x].sh_size` by the
    length of the parasite (because this is the section that the parasite will exist
    in).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For every `shdr` that exists after the parasite insertion, increase `shdr[x].sh_offset`
    by `PAGE_SIZE`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Insert the actual parasite code into the text segment at (`file_base + phdr[TEXT].p_filesz`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The original `p_filesz` value is used in the computation.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It makes more sense to create a new binary that reflects all of the changes
    and then copy it over the old binary. This is what I mean by inserting the parasite
    code: rewriting a new binary that includes the parasite within it.'
  prefs: []
  type: TYPE_NORMAL
- en: A good example of this infection technique being implemented by an ELF virus
    is my *lpv* virus, which was written in 2008\. For the sake of being efficient,
    I will not paste the code here, but it can be found at [http://www.bitlackeys.org/projects/lpv.c](http://www.bitlackeys.org/projects/lpv.c).
  prefs: []
  type: TYPE_NORMAL
- en: An example of text segment padding infection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A text segment padding infection (also referred to as a Silvio infection) can
    best be demonstrated by some example code, where we see how to properly adjust
    the ELF headers before inserting the actual parasite code.
  prefs: []
  type: TYPE_NORMAL
- en: Adjusting the ELF headers
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Inserting the parasite code
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Example of using the functions above
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The LPV virus
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The LPV virus uses the Silvio padding infection and is designed for 32-bit Linux
    systems. It is available for download at [http://www.bitlackeys.org/#lpv](http://www.bitlackeys.org/#lpv).
  prefs: []
  type: TYPE_NORMAL
- en: Use cases for the Silvio padding infection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Silvio padding infection method discussed is very popular and has as such
    been used a lot. The implementation of this method on 32-bit UNIX systems is limited
    to a parasite of 4,096 bytes, as mentioned earlier. On newer systems where large
    pages are used, this infection method has a lot more potential and allows much
    larger infections (upto 0x200000 bytes). I have personally used this method for
    parasite infection and relocatable code injection, although I have ditched it
    in favor of the reverse text infection method, which we will discuss next.
  prefs: []
  type: TYPE_NORMAL
- en: The reverse text infection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This idea behind this infection was originally conceived and documented by Silvio
    in his UNIX viruses paper, but it did not provide a working POC. I have since
    extended this into an algorithm that I have used for a variety of ELF hacking
    projects, including my software protection product *Mayas Veil*, which is discussed
    at [http://www.bitlackeys.org/#maya](http://www.bitlackeys.org/#maya).
  prefs: []
  type: TYPE_NORMAL
- en: The premise behind this method is to extend the text segment in reverse. In
    doing this, the virtual address of the text will be reduced by `PAGE_ALIGN` (`parasite_size`).
    And since the smallest virtual mapping address allowed (as per `/proc/sys/vm/mmap_min_addr`)
    on modern Linux systems is 0x1000, the text virtual address can be extended backwards
    only that far. Fortunately, since the default text virtual address on a 64-bit
    system is usually 0x400000, this leaves room for a parasite of 0x3ff000 bytes
    (minus another `sizeof(ElfN_Ehdr)` bytes, to be exact).
  prefs: []
  type: TYPE_NORMAL
- en: 'The complete formula to calculate the maximum parasite size for a host executable
    would be this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'On 32-bit systems, the default text virtual address is 0x08048000, which leaves
    room for an even larger parasite than on a 64-bit system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '![The reverse text infection](img/00008.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.3: The reverse text infection layout'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several attractive features to this `.text` infection: not only does
    it allow extremely large code injections, but it also allows for the entry point
    to remain pointing to the `.text` section. Although we must modify the entry point,
    it will still be pointing to the actual `.text` section rather than another section
    such as `.jcr` or `.eh_frame`, which would immediately look suspicious. The insertion
    spot is in the text, so it is executable (like the Silvio padding infection).
    This beats data segment infections, which allow unlimited insertion space but
    require altering the segment permissions on NX-bit enabled systems.'
  prefs: []
  type: TYPE_NORMAL
- en: Algorithm for reverse text infection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This makes a reference to the `PAGE_ROUND(x)` macro and rounds an integer up
    to the next PAGE aligned value.
  prefs: []
  type: TYPE_NORMAL
- en: Increase `ehdr->e_shoff` by `PAGE_ROUND(parasite_len)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Find the text segment, `phdr`, and save the original `p_vaddr`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Decrease `p_vaddr` by `PAGE_ROUND(parasite_len)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Decrease `p_paddr` by `PAGE_ROUND(parasite_len)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Increase `p_filesz` by `PAGE_ROUND(parasite_len)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Increase `p_memsz` by `PAGE_ROUND(parasite_len)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find every `phdr` whose `p_offset` is greater than the text's `p_offset` and
    increase `p_offset` by `PAGE_ROUND(parasite_len);` this will shift them all forward,
    making room for the reverse text extension.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set `ehdr->e_entry` to this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Increase `ehdr->e_phoff` by `PAGE_ROUND(parasite_len)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Insert the actual parasite code by creating a new binary to reflect all of these
    changes and copy the new binary over the old.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A complete example of the reverse text infection method can be found on my website
    at [http://www.bitlackeys.org/projects/text-infector.tgz](http://www.bitlackeys.org/projects/text-infector.tgz).
  prefs: []
  type: TYPE_NORMAL
- en: 'An even better example of the reverse text infection is used in the Skeksi
    virus, which can be downloaded from the link provided earlier in this chapter.
    A complete disinfection program for this type of infection is also available here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.bitlackeys.org/projects/skeksi_disinfect.c](http://www.bitlackeys.org/projects/skeksi_disinfect.c).'
  prefs: []
  type: TYPE_NORMAL
- en: Data segment infections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: On systems that do not have the NX bit set, such as 32-bit Linux systems, one
    can execute code in the data segment (even though its permissions are R+W) without
    having to change the segment permissions. This can be a really nice way to infect
    a file, because it leaves infinite room for the parasite. One can simply append
    to the data segment with the parasite code. The only caveat to this is that you
    must leave room for the `.bss` section. The `.bss` section takes up no room on
    disk but is allocated space at the end of the data segment at runtime for uninitialized
    variables. You may get the size of what the `.bss` section will be in memory by
    subtracting the data segment's `phdr->p_filesz` from its `phdr->p_memsz`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Data segment infections](img/00009.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.4: Data segment infection'
  prefs: []
  type: TYPE_NORMAL
- en: Algorithm for data segment infection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Increase `ehdr->e_shoff` by the parasite size.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Locate the data segment `phdr`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Modify `ehdr->e_entry` to point where parasite code will be:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Increase `phdr->p_filesz` by the parasite size.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Increase `phdr->p_memsz` by the parasite size.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adjust the `.bss` section header so that its offset and address reflect where
    the parasite ends.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set executable permissions on data segment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Step 4 only applies to systems with the NX (non-executable pages) bit set. On
    32-bit Linux, the data segment doesn't require to be marked executable in order
    to execute code unless something like PaX ([https://pax.grsecurity.net/](https://pax.grsecurity.net/))
    is installed in the kernel.
  prefs: []
  type: TYPE_NORMAL
- en: Optionally, add a section header with a fake name to account for your parasite
    code. Otherwise, if someone runs `/usr/bin/strip <infected_program>` it will remove
    the parasite code completely if it's not accounted for by a section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Insert the parasite by creating a new binary that reflects the changes and includes
    the parasite code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Data segment infections serve well for scenarios that aren't necessarily virus-specific
    as well. For instance, when writing packers, it is often useful to store the encrypted
    executable within the data segment of the stub executable.
  prefs: []
  type: TYPE_NORMAL
- en: The PT_NOTE to PT_LOAD conversion infection method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This method is extremely powerful and, although easily detectable, is also
    relatively easy to implement and provides reliable code insertion. The idea is
    to convert the `PT_NOTE` segment to the `PT_LOAD` type and move its position to
    go after all of the other segments. Of course, you could also just create an entirely
    new segment by creating a `PT_LOAD phdr` entry, but since a program will still
    execute without a `PT_NOTE` segment, you might as well convert it to `PT_LOAD`.
    I have not personally implemented this technique for a virus, but I have designed
    a feature in Quenya v0.1 that allows you to add a new segment. I also did an analysis
    of the Retaliation Linux virus authored by Jpanic, which uses this method for
    infection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.bitlackeys.org/#retaliation](http://www.bitlackeys.org/#retaliation).'
  prefs: []
  type: TYPE_NORMAL
- en: '![The PT_NOTE to PT_LOAD conversion infection method](img/00010.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.5: PT_LOAD infection'
  prefs: []
  type: TYPE_NORMAL
- en: There are no strict rules about the `PT_LOAD` infection. As mentioned here,
    you may convert `PT_NOTE` into `PT_LOAD` or create an entirely new `PT_LOAD` `phdr`
    and segment.
  prefs: []
  type: TYPE_NORMAL
- en: Algorithm for PT_NOTE to PT_LOAD conversion infections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Locate the data segment `phdr`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Find the address where the data segment ends:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Find the file offset of the end of the data segment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Get the alignment size used for the loadable segment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Locate the `PT_NOTE` phdr:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Convert phdr to PT_LOAD:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Assign it this starting address:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Assign it a size to reflect the size of your parasite code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Use `ehdr->e_shoff += parasite_size` to account for the new segment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Insert the parasite code by writing a new binary to reflect the ELF header changes
    and new segment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember that the section header table goes after the parasite segment, hence
    `ehdr->e_shoff += parasite_size`.
  prefs: []
  type: TYPE_NORMAL
- en: Infecting control flow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous section, we examined the methods in which parasite code can
    be introduced into a binary and then executed by modifying the entry point of
    the infected program. As far as introducing new code into a binary goes, these
    methods work excellently; in fact, they are great for binary patching, whether
    it be for legitimate engineering reasons or for a virus. Modifying the entry point
    is also quite suitable in many cases, but it is far from stealthy, and in some
    cases, you may not want your parasite code to execute at entry time. Perhaps your
    parasite code is a single function that you infected a binary with and you only
    want this function to be called as a replacement for another function within the
    binary that it infected; this is called function hijacking. When intending to
    pursue more intricate infection strategies, we must be aware of all of the possible
    infection points in an ELF program. This is where things begin to get real interesting.
    Let''s take a look at many of the common ELF binary infection points:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Infecting control flow](img/00011.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.6: ELF infection points'
  prefs: []
  type: TYPE_NORMAL
- en: As shown in the preceding figure, there are six other primary areas in the ELF
    program that can be manipulated to modify the behavior in some way.
  prefs: []
  type: TYPE_NORMAL
- en: Direct PLT infection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Do not confuse this with PLT/GOT (sometimes called PLT hooks). The PLT (procedure
    linkage table) and GOT (global offset table) work closely in conjunction during
    dynamic linking and through shared library function calls. They are two separate
    sections, though. We learned about them in the *Dynamic linking* section of Chapter
    2, *The ELF Binary Format*. As a quick refresher, the PLT contains an entry for
    every shared library function. Each entry contains code that performs an indirect
    `jmp` to a destination address that is stored in the GOT. These addresses eventually
    point to their associated shared library function once the dynamic linking process
    has been completed. Usually, it is practical for an attacker to overwrite the
    GOT entry containing the address that points to his or her code. This is practical
    because it is easiest; the GOT is writable, and one must only modify its table
    of addresses to change the control flow. When discussing direct PLT infection,
    we are not referring to modifying the GOT, though. We are talking about actually
    modifying the PLT code so that it contains a different instruction to alter the
    control flow.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the code for a PLT entry for the `libc fopen()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that the first instruction is an indirect jump. The instruction is six
    bytes long: this could easily be replaced with another five/six-byte instruction
    that changes the control flow to the parasite code. Consider the following instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: These instructions are encoded as `\x68\x00\x00\x00\x00\xc3`, which could be
    injected into the PLT entry to hijack all `fopen()` calls with a parasite function
    (whatever that might be). Since the `.plt` section is in the text segment, it
    is read-only, so this method won't work as a technique for exploiting vulnerabilities
    (such as `.got` overwriting), but it is absolutely possible to implement with
    a virus or a memory infection.
  prefs: []
  type: TYPE_NORMAL
- en: Function trampolines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This type of infection certainly falls into the last category of direct PLT
    infection, but to be specific with our terminology, let me describe what a traditional
    function trampoline usually refers to, which is overwriting the first five to
    seven bytes of a function''s code with some type of branch instruction that changes
    the control flow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The parasite function is then called instead of the intended function. If the
    parasite function needs to call the original function, which is often the case,
    then it is the job of the parasite function to replace those five to seven bytes
    in the original function with the original instructions, call it, and then copy
    the trampoline code back into place. This method can be used both by applying
    it in the actual binary itself or in memory. This technique is commonly used when
    hijacking kernel functions, although it is not very safe in multithreaded environments.
  prefs: []
  type: TYPE_NORMAL
- en: Overwriting the .ctors/.dtors function pointers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This method was actually mentioned earlier in this chapter when discussing
    the challenges of directing the control flow of execution to the parasite code.
    For the sake of completeness, I will give a recap of it: Most executables are
    compiled by linking to `libc`, and so `gcc` includes `glibc` initialization code
    in compiled executables and shared libraries. The `.ctors` and `.dtors` sections
    (sometimes called `.init_array` and `.fini_array`) contain function pointers to
    initialization or finalization code. The `.ctors/.init_array` function pointers
    are triggered before `main()` is ever called. This means that one can transfer
    control to their virus or parasite code by overwriting one of the function pointers
    with the proper address. The `.dtors/.fini_array` function pointers are not triggered
    until after `main()`, which can be desirable in some cases. For instance, certain
    heap overflow vulnerabilities (for example, *Once upon a free*: [http://phrack.org/issues/57/9.html](http://phrack.org/issues/57/9.html))
    result in allowing the attacker to write four bytes to any location, and often
    will overwrite a `.dtors` function pointer with an address that points to shellcode.
    In the case of most virus or malware authors, the `.ctors/.init_array` function
    pointers are more commonly the target, since it is usually desirable to get the
    parasite code to run before the rest of the program.'
  prefs: []
  type: TYPE_NORMAL
- en: GOT – global offset table poisoning or PLT/GOT redirection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Also called PLT/GOT infection, GOT poisoning is probably the best way to hijack
    shared library functions. It is relatively easy and allows attackers to make good
    use of the GOT, which is a table of pointers. Since we discussed the GOT in depth
    in the dynamic linking section in [Chapter 2](part0019_split_000.html#I3QM1-1d4163ae11644cc2802846625b2dc985
    "Chapter 2. The ELF Binary Format"), *The ELF Binary Format*, I won't elaborate
    more on its purpose. This technique can be applied by infecting a binary's GOT
    directly or simply doing it in memory. There is a paper about doing this in memory
    that I wrote in 2009 called *Modern Day ELF Runtime infection via GOT poisoning*
    at [http://vxheaven.org/lib/vrn00.html](http://vxheaven.org/lib/vrn00.html), which
    explains how to do this in runtime process infection and also provides a technique
    that can be used to bypass security restrictions imposed by PaX.
  prefs: []
  type: TYPE_NORMAL
- en: Infecting data structures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The data segment of an executable contains global variables, function pointers,
    and structures. This opens up an attack vector that is isolated to specific executables,
    as each program has a different layout in the data segment: different variables,
    structures, function pointers, and so on. Nonetheless, if an attacker is aware
    of the layout, one can manipulate them by overwriting function pointers and other
    data to change the behavior of the executable. One good example of this is with
    data/`.bss` buffer overflow exploits. As we learned in [Chapter 2](part0019_split_000.html#I3QM1-1d4163ae11644cc2802846625b2dc985
    "Chapter 2. The ELF Binary Format"), *The ELF Binary Format*, `.bss` is allocated
    at runtime (at the end of the data segment) and contains uninitialized global
    variables. If someone were able to overflow a buffer that contained a path to
    an executable that is executed, then one could control which executable would
    be run.'
  prefs: []
  type: TYPE_NORMAL
- en: Function pointer overwrites
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This technique really falls into the last one (infecting data structures) and
    also into the one pertaining to `.ctors/.dtors` function pointer overwrites. For
    the sake of completeness, I have it listed it as its own technique, but essentially,
    these pointers are going to be in the data segment and in `.bss` (initialized/uninitialized
    static data). As we've already talked about, one can overwrite a function pointer
    to change the control flow so that it points to the parasite.
  prefs: []
  type: TYPE_NORMAL
- en: Process memory viruses and rootkits – remote code injection techniques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up until now, we've covered the fundamentals of infecting ELF binaries with
    parasite code, which is enough to keep you busy for at least several months of
    coding and experimentation. This chapter would not be complete, though, without
    a thorough discussion of infecting process memory. As we've learned, a program
    in memory is not much different than it is on disk, and we can access and manipulate
    a running program with the `ptrace` system call, as shown in [Chapter 3](part0027_split_000.html#PNV61-1d4163ae11644cc2802846625b2dc985
    "Chapter 3. Linux Process Tracing"), *Linux Process Tracing*. Process infections
    are a lot more stealthy than binary infections, since they don't modify anything
    on disk. Therefore, process memory infections are usually an attempt at defeating
    forensic analysis. All of the ELF infection points that we just discussed are
    relevant to process infection, although injecting actual parasite code is done
    differently than it is with an ELF binary. Since it is in memory, we must get
    the parasite code into memory, which can be done by injecting it directly with
    `PTRACE_POKETEXT` (overwriting existing code) or, more preferably, by injecting
    shellcode that creates a new memory mapping to store the code. This is where things
    such as shared library injection come into play. Throughout the rest of this chapter,
    we will discuss some methods for remote code injection (injecting code into another
    process).
  prefs: []
  type: TYPE_NORMAL
- en: Shared library injection – .so injection/ET_DYN injection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This technique can be used to inject a shared library (whether malicious or
    not) into an existing process' address space. Once the library is injected, you
    may use one of the infection points described earlier to redirect control flow
    to the shared library through PLT/GOT redirection, function trampolines, and so
    on. The challenge is getting the shared library into the process, and this can
    be done in a number of ways.
  prefs: []
  type: TYPE_NORMAL
- en: .so injection with LD_PRELOAD
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is debatable whether we can actually call this method for injecting a shared
    library into a process is debatable injection, since it does not work on existing
    processes but rather the shared library is loaded upon execution of the program.
    This works by setting the `LD_PRELOAD` environment variable so that the desired
    shared library is loaded with precedence before any others. This can be a good
    way to quickly test subsequent techniques such as PLT/GOT redirection, but is
    not stealthy and does not work on existing processes.
  prefs: []
  type: TYPE_NORMAL
- en: Illustration 4.7 – using LD_PRELOAD to inject wicked.so.1
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, our shared library, `wicked.so.1`, is mapped into the process
    address space. Amateurs tend to use this technique to create little userland rootkits
    that hijack `glibc` functions. This is because the preloaded library will take
    precedence over any of the other shared libraries, so if you name your functions
    the same as a `glibc` function such as `open()` or `write()` (which are wrappers
    for syscalls), then your preloaded libraries' version of the functions will execute
    and not the real `open()` and `write()`. This is a cheap and dirty way to hijack
    `glibc` functions and should not be used if an attacker wishes to remain stealthy.
  prefs: []
  type: TYPE_NORMAL
- en: .so injection with open()/mmap() shellcode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is a way to load any file (including shared libraries) into the process
    address space by injecting shellcode (using `ptrace`) into an existing process'
    text segment and then executing it to perform `open/mmap` on a shared library
    into the process. We demonstrated this in [Chapter 3](part0027_split_000.html#PNV61-1d4163ae11644cc2802846625b2dc985
    "Chapter 3. Linux Process Tracing"), *Linux Process Tracing*, with our `code_inject.c`
    example, which loaded a very simple executable into the process. That same code
    could be used to load a shared library in as well. The problem with this technique
    is that most shared libraries that you will want to inject will require relocations.
    The `open()/mmap()` functions will only load the file into memory but won't handle
    code relocations, so mostly any shared library that you will want to load won't
    properly execute unless it's completely position-independent code. At this point,
    you could choose to manually handle the relocations by parsing the shared libraries'
    relocations and applying them in memory using `ptrace()`. Fortunately, an easier
    solution exists, which we will discuss next.
  prefs: []
  type: TYPE_NORMAL
- en: .so injection with dlopen() shellcode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `dlopen()` function is used to dynamically load shared libraries that an
    executable wasn''t linked with in the first place. Developers often use this as
    a way to create plugins for their applications in the form of shared libraries.
    A program can call `dlopen()` to load a shared library on the fly, and it actually
    invokes the dynamic linker to perform all of the relocations for you. There is
    a problem, though: most processes do not have `dlopen()` available to them, because
    it exists in `libdl.so.2`, and a program must be explicitly linked to `libdl.so.2`
    in order to invoke `dlopen()`. Fortunately, there is also a solution to this:
    almost every single program has `libc.so` mapped into the process address space
    by default (unless it was explicitly compiled otherwise) and `libc.so` has an
    equivalent to `dlopen()` called `__libc_dlopen_mode()`. This function is used
    almost in the exact same way, but it requires a special flag be set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This isn't much of a hurdle. But prior to using `__libc_dlopen_mode()`, you
    must first resolve it remotely by getting the base address of `libc.so` in the
    process you want to infect, resolve the symbol for `__libc_dlopen_mode()`, and
    then add the symbol value `st_value` (refer to [Chapter 2](part0019_split_000.html#I3QM1-1d4163ae11644cc2802846625b2dc985
    "Chapter 2. The ELF Binary Format"), *The ELF Binary Format*) to the base address
    of `libc` to get the final address of `__libc_dlopen_mode()`. You can then design
    some shellcode in C or assembly that calls `__libc_dlopen_mode()` to load your
    shared library into the process, with full relocations and ready to execute. The
    `__libc_dlsym()` function can then be used to resolve symbols within your shared
    library. See the `dlopen` manpages for more details on using `dlopen()` and `dlsym()`.
  prefs: []
  type: TYPE_NORMAL
- en: Illustration 4.8 – C code invoking __libc_dlopen_mode()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'It is very much worth noting that `dlopen()` will load PIE executables too.
    This means that you can inject a complete program into a process and run it. In
    fact, you can run as many programs as you want in a single process. This is an
    incredible anti-forensics technique, and when using thread injection, you can
    run them all concurrently so that they execute at the same time. Saruman is a
    PoC software that I designed to do this. It uses two possible methods of injection:
    the `open()/mmap()` method with manual relocations or the `__libc_dlopen_mode()`
    method. This is available on my site at [http://www.bitlackeys.org/#saruman](http://www.bitlackeys.org/#saruman).'
  prefs: []
  type: TYPE_NORMAL
- en: .so injection with VDSO manipulation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is a technique that I discussed in my paper at [http://vxheaven.org/lib/vrn00.html](http://vxheaven.org/lib/vrn00.html).
    The idea is to manipulate the **virtual dynamic shared object** (**VDSO**), which
    is mapped into every process address space in Linux since kernel version 2.6.x.
    The VDSO contains code to speed up system calls, and they can be invoked directly
    from the VDSO. The trick is to locate the code that invokes syscalls by using
    `PTRACE_SYSCALL`, which will break once it lands on this code. The attacker can
    then load `%eax/%rax` with the desired syscall number and store the arguments
    in the other registers, following the proper calling convention for Linux x86
    system calls. This is surprisingly easy and can be used to call the `open()/mmap()`
    method without having to inject any shellcode. This can be useful for bypassing
    PaX, which prevents a user from injecting code into the text segment. I recommend
    reading my paper for a complete dissertation on the technique.
  prefs: []
  type: TYPE_NORMAL
- en: Text segment code injections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is a simple technique and is not very useful for anything other than injecting
    shellcode, which should then quickly be replaced with the original code once the
    shellcode has finished executing. Another reason you would want to directly modify
    the text segment is to create function trampolines, which we discussed earlier
    in this chapter, or to directly modify the `.plt` code. As far as code injection
    goes, though, it is preferable to load code into the process or create a new memory
    mapping where code can be stored: otherwise, the text segment could easily be
    detected as being modified.'
  prefs: []
  type: TYPE_NORMAL
- en: Executable injections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned previously, `dlopen()` is capable of loading PIE executables into
    a process, and I even included a link to Saruman, which is the crafty software
    that allows you to run programs within existing processes for anti-forensics measures.
    But what about injecting `ET_EXEC` type executables? This type of executable does
    not provide any relocation information except for dynamic-linking `R_X86_64_JUMP_SLOT/R_386_JUMP_SLOT`
    relocation types. This means that injecting a regular executable into an existing
    process is ultimately going to be unreliable, especially when injecting more complex
    programs. Nevertheless, I created a PoC of this technique called **elfdemon**,
    which maps the executable to some new mappings that don't conflict with the host
    process executable mappings. It then hijacks control (unlike Saruman, which allows
    concurrent execution) and passes control back to the host process once it is done
    running. An example of this can be found at [http://www.bitlackeys.org/projects/elfdemon.tgz](http://www.bitlackeys.org/projects/elfdemon.tgz).
  prefs: []
  type: TYPE_NORMAL
- en: Relocatable code injection – the ET_REL injection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This method is very similar to shared library injection but is not compatible
    with `dlopen(). ET_REL` (`.o` files) are relocatable code, much like `ET_DYN`
    (`.so` files), but they are not meant to be executed as single files; they are
    meant to link into either an executable or a shared library, as discussed in [Chapter
    2](part0019_split_000.html#I3QM1-1d4163ae11644cc2802846625b2dc985 "Chapter 2. The
    ELF Binary Format"), *The ELF Binary Format*. This, however, doesn't mean that
    we can't inject them, relocate them, and execute their code. This can be done
    by using any of the techniques described earlier except `dlopen()`. So, `open/mmap`
    is sufficient but requires that you manually handle the relocations, which can
    be done using `ptrace`. In [Chapter 2](part0019_split_000.html#I3QM1-1d4163ae11644cc2802846625b2dc985
    "Chapter 2. The ELF Binary Format"), *The ELF Binary Format*, we gave an example
    of the relocation code in the software that I designed, called **Quenya**. This
    demonstrates how to handle relocations in an object file when injecting it into
    an executable. The same principles can be used when injecting one into a process.
  prefs: []
  type: TYPE_NORMAL
- en: ELF anti-debugging and packing techniques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the next chapter, *Breaking ELF Software Protection*, we will discuss the
    ins and outs of software encryption and packing with ELF executables. Viruses
    and malware are very commonly encrypted or packed with some type of protection
    mechanism, which can also include anti-debugging techniques to make analyzing
    the binary very difficult. Without giving a complete exegesis on the subject,
    here are some common anti-debugging measures taken by ELF binary protectors that
    are commonly used to wrap around malware.
  prefs: []
  type: TYPE_NORMAL
- en: The PTRACE_TRACEME technique
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This technique takes advantage of the fact that a program can only be traced
    by one process at a time. Almost all debuggers use `ptrace`, including GDB. The
    idea is that a program can trace itself so that no other debugger can attach.
  prefs: []
  type: TYPE_NORMAL
- en: Illustration 4.9 – an anti-debug with PTRACE_TRACEME example
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The function in *Illustration 4.9* will kill the program (itself) if one is
    attached with a debugger; it will know because it will fail to trace itself. Otherwise,
    it will succeed in tracing itself, and no other tracers will be allowed, preventing
    debuggers.
  prefs: []
  type: TYPE_NORMAL
- en: The SIGTRAP handler technique
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While debugging, we often set breakpoints, and when a breakpoint is hit, it
    generates a SIGTRAP signal, which is caught by our debugger's signal handler;
    the program halts and we can inspect it. With this technique, the program sets
    up a signal handler to catch SIGTRAP signals and then deliberately issues a breakpoint
    instruction. When the program's SIGTRAP handler catches it, it will increment
    a global variable from `0` to `1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The program can then check to see whether the global variable is set to `1`,
    if it is, that means that our program caught the breakpoint and there is no debugger
    present; otherwise, if it is `0`, it must have been caught by a debugger. At this
    point, the program can choose to kill itself or exit in order to prevent debugging:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The /proc/self/status technique
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This dynamic file exists for every process and includes a lot of information,
    including whether or not the process is currently being traced.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of the layout of `/proc/self/status`, which can be parsed to detect
    tracers/debuggers, is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'As highlighted in the preceding output, `tracerPid: 0` means that the process
    is not being traced. All that a program must do to see whether it is being traced
    is to open `/proc/self/status` and check whether or not the value is 0\. If not,
    then it knows it is being traced and it can kill itself or exit.'
  prefs: []
  type: TYPE_NORMAL
- en: The code obfuscation technique
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Code obfuscation (also known as code transformation) is a technique where assembly-level
    code is modified to include opaque branch instructions or misaligned instructions
    that throw off the disassembler''s ability to read the bytecode correctly. Consider
    the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'When the preceding code is compiled and viewed with the `objdump` disassembler,
    it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The code is actually doing a `mov $0x31337, %eax` operation, and functionally,
    it performs that correctly, but because there was a single `0xe9` before that,
    the disassembler perceived it as a `jmp` instruction (since `0xe9` is the prefix
    for a `jmp`).
  prefs: []
  type: TYPE_NORMAL
- en: So, code transformation doesn't change the way the code functions, only how
    it looks. A smart disassembler such as IDA wouldn't be fooled by the preceding
    code snippet, because it uses control flow analysis when generating the disassembly.
  prefs: []
  type: TYPE_NORMAL
- en: The string table transformation technique
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is a technique that I conceived in 2008 and have not seen used widely,
    but I would be surprised if it hasn't been used somewhere. The idea behind this
    uses the knowledge we have gained about the ELF string tables for symbol names
    and section headers. Tools such as `objdump` and `gdb` (often used in reverse
    engineering) rely on the string table to learn the names of functions and sections
    within an ELF file. This technique scrambles the order of the name of each symbol
    and section. The result is that section headers will be all mixed up (or appear
    to be) and so will the names of functions and symbols.
  prefs: []
  type: TYPE_NORMAL
- en: This technique can be very misleading to a reverse engineer; for instance, they
    might think they are looking at a function called `check_serial_number()`, when
    really they are looking at `safe_strcpy()`. I have implemented this in a tool
    called `elfscure`, available at [http://www.bitlackeys.org/projects/elfscure.c](http://www.bitlackeys.org/projects/elfscure.c).
  prefs: []
  type: TYPE_NORMAL
- en: ELF virus detection and disinfection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Detecting viruses can be very complicated, let alone disinfecting them. Our
    modern day AV software is actually quite a joke and is very ineffective. Standard
    AV software uses scan strings, which are signatures, to detect a virus. In other
    words, if a known virus always had the string `h4h4.infect.1+` at a given offset
    within the binary, then the AV software would see that it is present in its database
    and flag it as infected. This is very ineffective in the long run, especially
    since viruses are constantly mutating into new strains.
  prefs: []
  type: TYPE_NORMAL
- en: Some AV products are known to use emulation for dynamic analysis that can feed
    the heuristics analyzer with information about an executable's conduct during
    runtime. Dynamic analysis can be powerful, but it is known to be slow. Some breakthroughs
    in dynamic malware unpacking and classification have been made by Silvio Cesare,
    but I am not certain whether this technology is being used in the mainstream.
  prefs: []
  type: TYPE_NORMAL
- en: 'Currently, there exists a very limited amount of software for detecting and
    disinfecting ELF binary infections. This is probably because a more mainstream
    market doesn''t exist and because a lot of these attacks are somehow still so
    underground. There is no doubt, though, that hackers are using these techniques
    to hide backdoors and maintain a stealthy residence on compromised systems. Currently,
    I am working on a project called Arcana, which can detect and disinfect many types
    of ELF binary infections, including executables, shared libraries, and kernel
    drivers, and it is also capable of using ECFS snapshots (described in [Chapter
    8](part0074_split_000.html#26I9K1-1d4163ae11644cc2802846625b2dc985 "Chapter 8. ECFS
    – Extended Core File Snapshot Technology"), *ECFS – Extended Core File Snapshot
    Technology*) which greatly improves process-memory forensics. In the meantime,
    you can read about or download one of the following projects, which are prototypes
    I designed years ago:'
  prefs: []
  type: TYPE_NORMAL
- en: VMA Voodoo ([http://www.bitlackeys.org/#vmavudu](http://www.bitlackeys.org/#vmavudu))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**AVU** (**Anti Virus Unix**) at [http://www.bitlackeys.org/projects/avu32.tgz](http://www.bitlackeys.org/projects/avu32.tgz)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most viruses in a Unix environment are implanted after a system compromise and
    used to maintain residency on the system by logging useful information (such as
    usernames/passwords) or by hooking daemons with backdoors. The software that I
    have designed in this area is most likely to be used as host intrusion detection
    software or for automated forensics analysis of binaries and process memory. Keep
    following the [http://bitlackeys.org/](http://bitlackeys.org/) site to see any
    updates pertaining to the release of *Arcana*, my latest ELF binary analysis software,
    which is going to be the first real production software that is equipped for complete
    analysis and disinfection of ELF binary infections.
  prefs: []
  type: TYPE_NORMAL
- en: I have decided not to write an entire section in this chapter on heuristics
    and the detection of viruses, because we will be discussing most of these techniques
    in [Chapter 6](part0060_split_000.html#1P71O2-1d4163ae11644cc2802846625b2dc985
    "Chapter 6. ELF Binary Forensics in Linux"), *ELF Binary Forensics in Linux*,
    where will examine the methods and heuristics used in detecting binary infections.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered the "need-to-know" information about virus engineering
    for ELF binaries. This knowledge is not common, and therefore this chapter hopefully
    serves as a unique introduction to this arcane art of viruses in the underground
    world of computer science. At this point, you should understand the most common
    techniques for virus infection, anti-debugging, and the challenges that are associated
    with both creating and analysing viruses for ELF. This knowledge comes to great
    use in the event of reverse engineering a virus or performing malware analysis.
    It is worth noting that many great papers can be found on [http://vxheaven.org](http://vxheaven.org)
    to help further your insights into Unix virus technology.
  prefs: []
  type: TYPE_NORMAL
