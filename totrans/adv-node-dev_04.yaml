- en: MongoDB, Mongoose, and REST APIs – Part 3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you're going to resolve the Mongoose queries and ID validation
    after playing with Mongoose in the previous chapter. We will get into the details
    of different types of todo methods followed by deploying the API to Heroku. Finally,
    after learning more about Postman environments and running various test cases,
    we will create our test database.
  prefs: []
  type: TYPE_NORMAL
- en: Mongoose queries and ID validation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you're going to learn a few alternative ways that you can use
    Mongoose to query your data. Now, inside of the `server.test` file, we already
    looked at one way, `Todo.find`. We're going to look at two more and then we're
    also going to explore how to validate ObjectIDs.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to do all of this we are going to make a new file in the `playground`
    folder. I''m going to call this one `mongoose-queries.js`, and the first thing
    we need to do is load in the `mongoose` file in the `db` folder and the `todo`
    file in the `models` folder. I''m going to use ES6 destructuring, like we''ve
    used for all files where this happens, then we can `require` in the local file.
    Using the relative path, we need to go up a directory out of `playgroundserverdb`,
    and finally the filename we''re looking for is called `mongoose`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We can do the same thing for `todo`; we''re going to make that constant `Todo`
    from the `require`, return the result, and the file here is going to follow the
    same path. We need to go back a directory and into `server`, but instead of going
    into `db` we''ll go into `models`. Then we''ll get the `todo` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, before we can actually do any querying, we are going to grab an ID for
    one of our existing Todos over in Robomongo. In the `TodoApp` database I''m going
    to explore all of our documents and I''ll just grab the first one:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3b212db1-09be-4c05-8b05-f3b72f3db2cd.png)'
  prefs: []
  type: TYPE_IMG
- en: I'll right-click to edit it, then I can grab the ID excluding the quotes, parentheses,
    and the `ObjectId` identifier. With this ID in the clipboard back inside of Atom
    I can make a variable called `id` and set it equal to the ID I just copied inside
    of single quotes, and now we have an ID and we can use this for all of our querying.
  prefs: []
  type: TYPE_NORMAL
- en: Todo.find method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, I understand you''ve already used `Todo.find` before but we are going
    to talk about a few other things. So for the moment we will be starting with that.
    `Todo.find` lets you query as many Todos as you like. You can pass in no arguments
    to get all your Todos back, or you can query by anything. We''re going to query
    by `_id`. Now, Mongoose is fantastic, it doesn''t require you to pass in ObjectIDs,
    as it can actually do that for you. In this case, what we have is perfectly valid.
    We pass in a string as the value, and Mongoose is going to take that string, it''s
    going to convert it to an ObjectID, and then it''s going to run the query. This
    means we don''t need to manually convert our string into an ObjectID. Now, after
    we make the query we can attach a `then` callback, we''re going to get all of
    our Todos, we''ll name that argument and we can go ahead and print them to the
    screen, `console.log(''Todos'',)` and the second argument will be the actual `todos`
    array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Nothing new here aside from the fact that you can indeed pass in an `id` as
    a string.
  prefs: []
  type: TYPE_NORMAL
- en: Todo.findOne method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next method we''re going to look at is one called `Todo.findOne`. Now,
    `Todo.findOne` is very similar to find, the only difference is that it returns
    one document at most. That means it simply grabs the first one that matches the
    query you have. In our case we''re querying by a unique ID, so it''s only going
    to find one matching item, but if there were other results, for example, if we
    queried all Todos with completed false, the first doc would be the only one that
    returns, even though there''s two that match the query. What we can do to call
    `findOne` is identical to what we did with find, and to prove it I''m actually
    going to copy the code. All we need to do is change a few things. Instead of `todos`,
    we get `todo`, and we''re just going to get a single document not an array of
    documents. That means I can print a `Todo` string followed by the `todo` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: With this in place we now have enough examples where it makes sense to run the
    file and see exactly what happens.
  prefs: []
  type: TYPE_NORMAL
- en: 'Over inside of the Terminal I''m going to kick things off by running this file,
    and I''ll run it using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run the file, we get our `Todos` array, our array of one document,
    and we get our `Todo` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d4e624d9-1dc2-46eb-b809-c0e8822d156e.png)'
  prefs: []
  type: TYPE_IMG
- en: If you know you're just trying to fetch one individual item, I recommend using
    `findOne` over `find`. You get back the document as opposed to an array. This
    also makes it a lot easier when the ID of the Todo you're looking for doesn't
    exist; instead of getting an empty array as the result you'll get `null` back
    and you can work with that, doing whatever you like. Maybe that means you return
    a 404 or maybe you want to do something else if the ID is not found.
  prefs: []
  type: TYPE_NORMAL
- en: Todo.findById method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The last method we''re going to look at is `Todo.findById`. Now, `findById`
    is fantastic if you are just looking for a document by its identifier. There is
    no way to query by anything else other than the ID and all you do is you pass
    in the id as the argument. You don''t have to make a query object and you don''t
    have to set an `_id` prompt. With this in place, we can now do the exact same
    thing we did with `findOne`. I''m going to prove that by taking the `then` call,
    pasting it inside `Todo.findById`, and just changing the print statement from
    `Todo` to `Todo By Id`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now if I save the file, `nodemon` is going to rerun and we get the exact same
    result for both:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cc9738b1-42e3-49ba-a4d5-7ddc96528f5a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you want to find one document by something other than ID, I recommend using
    `findOne`. If you want to find one document by ID, I always recommend using `findById`.
    Now, all of this and more is available in the docs, so if you want to dive into
    anything I discussed here you can always go to [mongoosejs.com](http://mongoosejs.com).
    Click on the read the docs link, and over in the left-hand side they have a couple
    of links; the one that we''re looking for is the one on Queries:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2f8abc07-5bf2-4d7b-bd94-a602fe79de92.png)'
  prefs: []
  type: TYPE_IMG
- en: You can learn more about how to query your docs, but we pretty much covered
    everything this page talks about.
  prefs: []
  type: TYPE_NORMAL
- en: Handling situations where the ID doesn't exist
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, the next thing I want to talk about is what happens when the ID isn't correct,
    and this is going to be the case because, remember, our API is going to be getting
    this ID from the user, which means that if the ID isn't correct we don't want
    our code to fail, we want to elegantly handle these errors. To prove this I'm
    going to go ahead and tweak the ID a little bit. IDs do have specific protocols
    so what I want you to do, for this example, is find a number in your ID. I'm going
    to go with the first character because it happens to be a number, and just increment
    it by one. I'm going to go from `5` to `6`. Now we have a valid ID but the ID
    is not going to be in the database because I tweaked it, and obviously the other
    Todo in the database does not match this ID.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, with this in place, you can see as we restart the server we get an empty
    array for the find call, and we get null for both `findOne` and `findById`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7c59ab25-aa86-4cb3-b4f4-0295b070e958.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When your ID does not match anything in the database, an error is not going
    to get thrown; it''s still going to fire the success case, it''s just going to
    fire it either with an empty array or with null, which means when we want to handle
    that case where the ID doesn''t exist in the database, all we have to do is add
    an `if` statement. Inside the `Todo.findById` statement, I can add an `if` statement.
    If there is no todo, we''re going to do something, and that something is going
    to be to use `return` which prevents the rest of the function from executing,
    and we''ll print a little message, `console.log(''Id not found'')`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now if I save the file the last call should look a little different:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9bf4952f-8946-444a-bf57-16b483e3eff5.png)'
  prefs: []
  type: TYPE_IMG
- en: As shown in the preceding screenshot, instead of getting Todo with null, we
    get `Id not found`, and this is perfect. Now we know how to query using `findOne`
    and `findById`, and we also know how to handle situations where the ID you're
    querying for doesn't actually exist inside of the collection. I'm going to set
    the ID back to its original value, changing `6` to `5`, and if I save the file,
    nodemon's going to restart and we're going to get our document back.
  prefs: []
  type: TYPE_NORMAL
- en: Validating an ObjectID
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, the last thing I want to talk about is how to validate an ObjectID. What
    we''ve done so far is we''ve created a valid ObjectID. It''s just of a value that
    is not in the collection, but if we were to do something like tack on two `1`s,
    we would actually have an invalid ID which is going to cause errors in the program.
    Now, you might wonder why this would ever happen, but it could happen because
    the user is the one specifying the ID. We''re going to add a `catch` call onto
    `findById`. We''re going to get that error and simply print it to the screen using
    `console.log`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, to illustrate this we don''t need all three queries. In order to clean
    up the Terminal output, I''m going to go ahead and comment out `Todo.find` and
    `Todo.findOne`. With this in place, our invalid ID, and the `catch` callback we
    can save the file, and over in the Terminal we should get a really long error
    message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/271e562b-ff14-43a7-9ddf-950fcfb0494b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We have an error message, `CastError: Cast to ObjectId failed`, for the given
    value. This is warning you that your `ObjectID` doesn''t just not exist in the
    collection, it''s actually completely invalid. Now, running this with a `catch`
    method does let us handle the error. We could do something like tell the user,
    hey, the ID that you sent through is invalid, but there''s also another way to
    get it done that I prefer. What we''re going to do is load in the ObjectID off
    of the MongoDB native driver and that''s something we did before. Right here in
    `mongodb-connect` we loaded in the, `ObjectID`. Inside of `mongoose-queries` we''re
    going to do the same thing. I''m going to make a constant called `ObjectID` and
    we''re going to get it from the `mongodb` library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Now, on `ObjectID` we have a lot of utility methods. We've looked at how we
    can create new ObjectIDs, but one thing we also have access to is a method called
    `ObjectId.isValid`. The `isValid` method takes the value, in this case it's our
    string right in `id`, and it returns true if it's valid, and false if it's not
    valid, which means we can add `if` conditions to validate the ID before we ever
    run the query.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re going to add an `if` statement, and we''re going to check if the value
    is not valid. I''m going to flip it using an exclamation mark, then we can call
    `ObjectID.isValid`. By flipping it we''ve essentially created a method that tests
    whether an ObjectID is not valid. The value I''m going to pass in is just going
    to be the string stored in the `id` variable, and now we can add some code to
    run when the ID is not valid, `console.log(''ID not valid'')`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if I go ahead and save the file, we should get our `ID not valid` message,
    and then after that we should get our error message printing to the Terminal because
    we do still have our `catch` call, and this query is still going to run. Over
    here we get just that. `ID not valid` prints to the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7271def5-894b-4a9b-9afb-cee35c54b518.png)'
  prefs: []
  type: TYPE_IMG
- en: But now we know how to validate IDs and that's going to come in handy in the
    next section.
  prefs: []
  type: TYPE_NORMAL
- en: With this in place it's now time for a challenge. Before I set up the challenge,
    I'm going to comment out the `id` and our `isValid` call, and down below I'll
    comment out `findById`. I'm going to leave them here; you can use them as a reference
    for what to do in the challenge. Your challenge is going to be to query the users
    collection. That means that you're going to want to go ahead and move into Robomongo
    and grab an ID from your users collection. Here I have just one document; if you
    have zero documents for whatever reason, you can always right-click Insert Document,
    and all you have to do is specify the email.
  prefs: []
  type: TYPE_NORMAL
- en: Now, in order to make that query over inside of Atom you are going to need to
    load in the user Mongoose model because currently we only have the Todo one, require.
    Down below I want you to use `User.findById` to query the ID that you picked over
    in Robomongo. Then you're going to go ahead and handle the three cases. There's
    going to be the case where the query works, but there is no user. In that case
    you're going to print something like `User not found`. You're also going to handle
    the case where the user was found. I want you to go ahead and print the user to
    the screen. Then finally you're going to handle any errors that might have occurred.
    You can simply print the error object to the screen for that. There's no need
    to use `isValid` for this one, all you have to do is fill out the `findById` call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the first thing I''m going to do is import the user file. I''m going to
    make a `const`, I''m going to grab the `User` variable off of the return result
    from require, and we''re going to follow the same path we have here. We have to
    go out of the `playground` directory, into the `server/models` directory, and
    finally the filename is `user`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have the user imported, we can query it down below. Before I write
    the query I am going to fetch an ID over in Robomongo:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3f7c8938-a78a-4d42-83e7-ded3e0b6a5ba.png)'
  prefs: []
  type: TYPE_IMG
- en: 'I can edit the document, highlight it, copy it, and move back into Atom. Inside
    of Atom I''m going to set up my `User.findById` call. All I have to do is pass
    in the ID; I have that in the clipboard, and I''m going to wrap it in quotes.
    Next up, the callbacks. I''m going to attach a `then` callback, passing in two
    functions. The first one is when the promise gets resolved, and the second one
    is when the promise gets rejected. For rejections, all we''re going to do is print
    that error object to the screen, which means we can use `console.log(e)`. Now,
    if things go well, there are still a few exceptions. We want to make sure that
    the user actually does exist. The query is still going to pass if the ID doesn''t
    match anything found inside of the collection. If there is no user, we are going
    to stop function execution using `return`, then we''re going to go ahead and print
    using `console.log(''Unable to find user'')`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the last case we need to handle is if things actually go well, which means
    that the query was indeed valid and the ID was found inside of the users collection.
    I''m going to add `console.log` using our pretty printing technique, the `user`
    variable, `JSON.stringify`, passing in our three arguments, `user`, `undefined`,
    and the number `2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'With this in place I can now go ahead and save the file and open up the Terminal
    since it''s currently hidden, we get our user showing up in the Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b4f62900-9086-4a9b-b95e-795003c4df38.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This is fantastic; if you''re seeing this you''ve successfully completed the
    challenge. Now I can also test that my other cases are working as expected. I''m
    going to change `6` at the end of my ID to a `7` and save the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bb17f967-87b5-445b-82a3-16fdb0feb8f4.png)'
  prefs: []
  type: TYPE_IMG
- en: When it restarts I get `Unable to find user`, which is expected. Next up, I'm
    going to change it back to a `6`, but I am going to tack on a few `1`s, or any
    other characters. In this case, I'll use two `1`s and two `a` characters. This
    time we do get our error, we're unable to cast that value to an ObjectId. Let's
    undo the change to the ID and now we're done.
  prefs: []
  type: TYPE_NORMAL
- en: 'I''m going to wrap this section up by committing our changes. I''m going to
    shut down `nodemon`, run a `git status` command, and we have one new file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1fc9a660-f5f3-46e9-90f5-f7471359a469.png)'
  prefs: []
  type: TYPE_IMG
- en: 'I can use `git add` to add it to the next commit, then I can use `git commit`
    to make the commit. A good message for this one is `Add queries playground file`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: With this in place I'm going to push it up to GitHub using the `git push` command,
    and we are done. In the next section you will be responsible for creating an entire
    API request.
  prefs: []
  type: TYPE_NORMAL
- en: Getting an individual resource – GET /todos/:id
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you are going to create an API route for fetching an individual
    Todo. Now, most of this section is going to be a challenge but there is one thing
    I want to show you before we get started, and that is **how to fetch a variable
    that's passed in via the URL.** Now, as I mentioned, the structure for this URL
    is going to be a `GET` request, `/todos`, then we're going to dive into the Todos,
    fetching an individual item where the ID gets passed, such as `/todos/12345`.
    This means that we need to make the ID part of the URL dynamic. I want to be able
    to fetch that value, whatever a user happens to pass in, and use it to make the
    query. The query that we set up in the `mongoose-queries` file like `User.findById`
    one to fetch the todo by Id.
  prefs: []
  type: TYPE_NORMAL
- en: Now in order to get that done, let's go ahead inside `server.js` file and call
    `app.get`, passing in the URL.
  prefs: []
  type: TYPE_NORMAL
- en: Taking on the challenge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first part we already know, `/todos/`, but now what we need is a URL parameter.
    URL parameters follow this pattern: it''s a colon followed by a name. Now I could
    call this `:todoId`, or anything else, but what we''re going to call it for this
    section is `:id`. This is going to create an `id` variable; it''s going to be
    on the request object, the one we''ll set up in just a moment, and we''ll be able
    to access that variable. That means when someone makes the `GET /todos/1234324`
    request, the callback will fire, the one we''re going to specify now, and we''ll
    be able to query by the ID they pass in. Now, we are still going to get the request
    and response object, the only difference is we''re now going to be using something
    off of request. This one is `req.params`. The `req.params` object is going to
    be an object, it''s going to have key value pairs where the key is the URL parameter,
    like id, and the value is whatever value was actually put there. In order to demonstrate
    this, I am going to simply call `res.send`, sending back the `req.params` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This is going to let us test out this route inside of Postman and see exactly
    how it works. Inside of the Terminal I can start up our server. I''m going to
    use following command to start things up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the server''s on `localhost:3000` and we can make a `GET` request to this,
    the `/todos/:id` URL. Over inside Postman I''m going to do just that; we have
    the GET method, the URL is `localhost`, and it''s still on port `3000/todos/`,
    and then we can type whatever we like, for example, `123`. Now, when I send this
    off what we get back is that `req.params` object, and right in Body you can see
    it has an `id` property set to `123`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ba53ccec-d809-40de-a675-b04e78e148c6.png)'
  prefs: []
  type: TYPE_IMG
- en: That means we are able to access the value in the URL using `req.params.id`,
    and that is exactly what you're going to need to do for the challenge. Over inside
    of Atom I'll start things off by creating that variable, a `var id = req.params.id`
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: With this in place you now know everything you need in order to complete the
    challenge, which is going to be to finish filling out this route. First up, you're
    going to validate the ID using that ObjectID `isValid` method we explored over
    in the `mongoose-queries` file. I'll leave a little comment, `Valid id using isValid`.
    Now, if it's not valid, what you're going to do is stop the function execution
    and you're going to respond with a `404` response code, because the ID passed
    in is not valid, and there's no way it's ever going to be in the collection. We're
    going to respond with the `404` response code letting the user know that the Todo
    was not found, and you can send back an empty body, which means you can just call
    send without passing in any value. It would be similar to the `res.status(400).send(e)`
    statement with no error, and you would also change `400` to `404`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, after that, you''re going to start querying the database and this is going
    to happen using `findById`. I want you to take the Id and query the `Todos` collection,
    looking for a matching document; there''s two ways this could go. There''s the
    success case and there is the error case. If we get an error, that one is pretty
    self-explanatory: all we''re going to do is send back a `400` response code letting
    the user know that the request was not valid, and we''re also going to go ahead
    and send back nothing. We''re not going to be sending back that error argument
    because the error that prints for the error message could contain private information.
    We''re going to be beefing out our error handling later. Currently, as you can
    see, we have the function duplicated in quite a few places. That will get moved
    into one location later but for now you can respond with a `400` response code
    and send an empty body back. This brings us to the success case. Now, if there
    is a Todo, `if todo`, you''re going to go ahead and send it back. If there is
    no Todo, `if no todo`, this means the call did succeed, but the ID was not found
    in the collection. All you''re going to do is go ahead and send back a `404` response
    code with an empty body.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, both of these statements are going to look really similar; you're sending
    back a `404` letting the user know that the ID they passed in does not match any
    ID of a document in the `Todos` collection. Now you know how to do all of this,
    you can use anything you need to get this done. That means you can use the `mongoose-queries`
    file, you can use the [mongoosejs.com](http://mongoosejs.com/) documentation,
    you can use Stack Overflow, Google, or anything else; it's not about memorizing
    exactly how to get stuff done, it's about working through those problems on your
    own. Eventually you will memorize a lot of these techniques as they come up again
    and again, but for now your goal is to just get it working. When you're done,
    go ahead and fire off this request over in the Postman application. That means
    you're going to want to grab an ID that is valid from Robomongo and paste it right
    in the URL. You can also test what happens with IDs that are valid, but don't
    exist in the database, and IDs that are invalid, such as `123`, which is not a
    valid ObjectID. With this in place you are ready to start the challenge.
  prefs: []
  type: TYPE_NORMAL
- en: Challenge step 1 - filling the code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first thing I''m going to do is fill out the code. We''re going to validate
    the ID and we''re going to send back a `404` response code if it''s not valid.
    Up at the very top of the file I do not have an ObjectID imported so I''m going
    to have to go ahead and do that. Just below `bodyParser`, I can create a variable
    `ObjectID`, and set that equal to the return result from `require`; we''re requiring
    the `mongodb` library. Now that we have `ObjectID` in place, we can go ahead and
    use it. We''ll write an `if` statement, `if (ObjectID.isValid())`. Now, obviously
    we only want to run this code if it''s not valid, so I''m going to flip the return
    result using an exclamation mark, and then I''m going to pass `id` in. Now we
    have an `if` condition that''s only going to pass if the ID, the one that got
    passed in as the URL parameter, was not valid. In that case we''re going to use
    `return` to prevent function execution, then I''m going to go ahead and respond
    using `res.status`, setting it equal to `404`, and I''m going to call `send` with
    no arguments so I can send back an empty body. There we go, our first thing is
    complete. With this in place we can now go ahead and move onto creating the query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point we actually do have something we can test: we can pass in invalid
    IDs and make sure we get that 404 back. Over inside of the Terminal I ran the
    application using `nodemon` so it automatically restarted in Postman. I can rerun
    the `localhost:3000/todos/123` request and we get our 404, which is fantastic:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a933a96a-a659-45b8-a47b-e09de0c84cd9.png)'
  prefs: []
  type: TYPE_IMG
- en: This is not a valid ObjectID, the condition failed, and the 404 was indeed returned.
  prefs: []
  type: TYPE_NORMAL
- en: Challenge step 2 - Making the query
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next up, we''re going to make that query `Todo.findById`. Here we''re going
    to pass in the ID, which we have in the `id` variable, and then we''re going to
    attach our success and error handlers, `.then`, passing in our success callback.
    This is going to get called potentially with the individual Todo document, and
    I am going to call `catch` as well, getting the error. We can do the error handler
    first. If there is an error, we''re going to keep things really simple, `res.status`,
    setting it equal to `400`, then we''re going to go ahead and call `send`, leaving
    out the error object intentionally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'With this in place the only thing left to do is fill out the success handler.
    The first thing we need to do is make sure that a Todo is actually found. This
    query, if successful, might not always result in an actual document being returned.
    I''m going to use an `if` statement to check if there is no Todo. If there is
    no Todo, we want to respond with a `404` response code, just like we did before.
    We''re going to `return` to stop the function execution, `res.status`. The status
    here will be `404` and we will be using `send` to respond with no data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: challenge step 3 - success path
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The last case is the happy path, the success case, when everything goes as
    planned. The ID is valid and we find a document in the Todos collection that has
    an ID matching the ID passed in. In that case all we''re going to do is respond
    using `res.send`, sending back the Todo. Now, you could have sent it in like `res.todo(todo)`;
    this will indeed work, but what I want to do is tweak it just a little bit. Instead
    of sending back Todo as the body, I''m going to send back an object where the
    Todo is attached as the `todo` property using the ES6 object definition, which
    is identical to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives me a little flexibility down the line. I could always add other
    properties onto the response, like custom status codes or anything else. It''s
    similar to the technique we used for `GET /todos`. Right here, `res.send({todos})`,
    instead of responding with the array, we responded with an object that has a `todos`
    property and that is the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have this in place we are done and we can test things out. I''m
    going to save the file, remove all of our comments, add a semicolon where needed,
    and we''re going to grab an ID from Robomongo. Over inside of Robomongo I can
    grab an ID for one of my Todos. I''m going to go with the second one. I''ll edit
    the document and copy it to the clipboard. Now over in Postman we can go ahead
    and make the request, setting the ID equal to the ID value we just copied:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d1cb9eff-7242-47b7-ad97-c2601367793d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'I''m going to send it off. We get our object where we have a `todo` property,
    and on that `todo` property we have all of the properties for the document, `_id`,
    `text`, `completedAt`, and `completed`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/94030e07-434b-4e56-a0b9-48fc1bbc1047.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, the last case I want to test is what happens when we request a Todo with
    a valid ObjectID, but one that just happens to not exist. I''m going to do this
    by taking the last number in my ID and changing it from `a` to `b`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/16fbd9e5-d0d9-48b6-96a2-c7a3f4d4b0cc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If I send this off we get our `404` response code back, which is fantastic;
    this is exactly what I expect to happen when I make a request for a Todo. The
    ObjectID is valid, it''s just not in the collection. Now that we''ve made this
    request we can actually save this inside of our Todo App collection, so later
    down the line it''s a lot easier to fire off this one. I''m going to save it using
    Save As:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/455f68bc-e917-43fc-8007-6e1b356b7532.png)'
  prefs: []
  type: TYPE_IMG
- en: We can leave the Request description empty, and we can change Request Name to
    `GET /todos/:id`. I am going to add it to our existing collection, the Todo App
    collection. Now we have three routes; the only thing left to do for this route
    is to add some test cases, and that's going to be the topic of the next section.
  prefs: []
  type: TYPE_NORMAL
- en: To wrap this one up, let's commit our changes and push them up to GitHub. I'm
    going to shut down the server and run `git status`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see we have our modified file; this means I can run `git commit` with
    the `-a` flag and the `-m` flag, and then I''m going to provide my commit message.
    Now, if you''re using the `-a` flag and the `-m` flag you can actually use a shortcut,
    the `-am` flag, which does the exact same thing. It''s going to add all of our
    modified files to the commit; it''s also going to give us a place to add a message.
    A good message for this one would be `Add GET /todos/:id`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: With this in place, I'm going to make the commit, push it up to GitHub, and
    we are done. In the next section, we are going to go ahead and write test cases
    for this route. It's going to be mostly a challenge like this one was.
  prefs: []
  type: TYPE_NORMAL
- en: Testing GET /todos/:id
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we're going to create three test cases for this route, the
    one that fetches an individual Todo item. One is going to make sure that when
    we pass in an invalid ObjectID, we get a `404` response code. Another one is going
    to verify that when we pass in a valid ObjectID, but it doesn't match a doc, we
    get a `404` response code back, and lastly we'll write a test case that makes
    sure that when we pass in an ObjectID that does match a doc, that doc actually
    comes back in the response body.
  prefs: []
  type: TYPE_NORMAL
- en: We're going to write the test case for the valid call together, then you'll
    be writing two test cases on your own. That will be the challenge for this section.
  prefs: []
  type: TYPE_NORMAL
- en: Writing test cases for GET/todos/:id
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Over inside of `server.test.js` we can get started down at the very bottom
    by adding a `describe` block. I''m going to call describe, and this `describe`
    block will be named `GET /todos/:id`, and we can add our arrow function (`=>`)
    as the callback function. Inside of our `describe` callback we can now set up
    the test case that we''re going to create together, `it(''should return todo doc'')`.
    This is going to be the test that makes sure that when we pass in a valid ID that
    does match a doc, the doc comes back. It''s going to be an asynchronous test,
    so we will be specifying the `done` argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in order to run this test case we''re going to need the ID of a Todo that''s
    actually inside of the collection, and if you remember we do add two Todos to
    the collection, but unfortunately we don''t have the IDs. The IDs are autogenerated
    behind the scenes; in order to fix this what we''re going to do is add the ID
    property, `_id`. This means we''ll be able to access the ID in our test case and
    everything will work as expected. Now, in order to do this we do have to load
    an ObjectID off of MongoDB, which we''ve done before. I''m going to make a constant
    using ES6 Destructuring. I''m going to grab `ObjectID` off of the return result
    from requiring `mongodb`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, inside of the `todos` array we can add an `_id` property for both of our
    two `todos`, `new ObjectID()`, with a comma—this is for the first `todo`—and down
    below we can add an `_id` for the second `todo` as well, `new ObjectID()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have _ids and we can access those _ids by accessing them off the
    `todos` array, we're ready to write the test case.
  prefs: []
  type: TYPE_NORMAL
- en: Test 1 - Super test request
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''re going to get started by creating our super test request. We''re going
    to `request` something from the `app` express application; it is going to be a
    `get` request, that is, the URL we''re testing, and the actual URL is going to
    be `/todos/id`, where `id` equals one of these _ids in `todos`. I''m going to
    go ahead and use the `_id` of the first `todo`. Down below we can fix this by
    changing our string to a template string, so we can inject `_id`, `/todos/` then
    we''re going to add our syntax for injecting a value into the template string.
    In this case we''re accessing something from the `todos` array. We want to grab
    the first item, this is the first `todo`, and we''re looking for its `_id` property.
    Now, this is an ObjectID; we need to convert this into a string because that is
    what we''re going to pass in as the URL. To convert an ObjectID to a string we
    can use the `toHexString` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'There we go. Now we''ve generated the proper ID and we can start making some
    assertions about what should happen when this request gets fired. First up, the
    HTTP status code. That should be a `200`, so I can call `expect`, passing in `200`.
    Next step: we do want to verify that the body that comes back matches the body
    previous in the `todos` array, most notably that the `text` property equals the
    `text` property we set. I''m going to create a custom `expect` call to get that
    done. We''ll pass in our function that gets called with the response object, and
    now we can make an assertion using the `expect` library. I''m going to use `expect(res.body.todo)`,
    which we set up in `res.send({todo})` when we used the ES6 object syntax, and
    that `todo` property has a `text` property that is equal to using `toBe`, the
    `text` property of our first `todo`. That''s going to be `todos`, grabbing the
    first one, the zero-indexed todo, and we''re going to grab its `text` property.
    With this in place, all of our assertions are done; we can call `end`, passing
    in `done`, which is going to wrap up the test case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can go ahead and run this test over inside of the Terminal by running
    `npm run test-watch`. This is going to kick off our test suite and we should have
    our new section with our test case that is passing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/970e9653-b8a6-4fcd-a4aa-a2b79168b5fe.png)'
  prefs: []
  type: TYPE_IMG
- en: Right here, we get `should return todo doc`, and that is passing, which is fantastic.
    Now it's time for you to write two test cases on your own. I'll give you the it
    calls so we're on the same page, but you are going to be responsible for filling
    out the actual test function, `it('should return 404 if todo not found')`. This
    is going to be an async test, so we'll specify the `done` argument, and your job
    here is going to be to make a request using a real ObjectID, and you're going
    to call its `toHexString` method. It is going to be a valid ID but it won't be
    found in the collection, so we should get a 404 back. Now, the only expectation
    you need to set up is the status code; make sure you get `404` back.
  prefs: []
  type: TYPE_NORMAL
- en: Test 2 - Verifying invalid ID
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The second test you're going to write is going to verify that when we have an
    invalid ID we get back a `404` response code, `it('should return 404 for non-object
    ids')`. This is also going to be an async test, so we'll specify `done`. For this
    one, you're going to pass in a URL, something like this: `/todos/123`. This is
    indeed a valid URL, but when we try to convert `123` to an ObjectID it's going
    to fail, and that should trigger the `return res.status(404).send()` code and
    we should get a `404` response code back. Once again, the only expectation you
    need to set up for this test is that when you make the get request to the URL
    a `404` is the status code. Take a moment to knock out both of these test cases,
    making sure they work as expected when you actually have the calls set up. If
    all of your test cases are passing over in the Terminal when you're done, then
    you are ready to move on.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the first one, I''m going to go ahead and get that `HexString` by creating
    a variable. Now, you didn''t need to create a variable; you could have done it
    slightly differently. I''m going to make a variable called `hexId`, setting it
    equal to `new ObjectID`. Now on this `ObjectID` we do want to call that `toHexString`
    method which we used before. This takes our ObjectID and gives us a string, and
    we can specify that string as part of the URL. Now, it''s fine if you did this
    inside of the get call, kind of like we do here; either way works as long as the
    test case passes. We''re going to call `request`, passing in our app. Next up,
    we are going to make a `get` request, so I''ll call that `get` method and we can
    set up our URL. This one is going to be `/todos/` and we''re going to inject in
    our template string that `hexId` value. The only expectation we need to set up
    is that a `404` status code comes back. We''re expecting `404`. We can wrap this
    test case up by calling `end`, passing in our `done` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can save the file and this test case should rerun. The last test is
    still going to fail, but that''s fine, and over here you can see we get exactly
    that, `should return todo doc` passes and `should return 404 if todo not found`
    passes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6f06ef81-b971-4988-85eb-4ad1b3f5d404.png)'
  prefs: []
  type: TYPE_IMG
- en: And the last test to write is what happens when we have an invalid ObjectID.
  prefs: []
  type: TYPE_NORMAL
- en: Test 3 - Validating invalid ObjectID
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I''m going to call `request`, passing in `app`, then I''m going to go ahead
    and call `get`, setting up the URL. We don''t need to use template strings here
    since we''re just going to be passing in a plain string, `/todos/123abc`. Indeed
    an invalid ObjectID. The ObjectIDs, as we talked about, have a very specific structure
    and this does not pass that criteria. To find out more about ObjectIDs you can
    always go back to the ObjectID section at the beginning of this chapter. Next,
    we''re going to start setting up our assertions by calling `expect` and expecting
    `404` to come back, and we can wrap this test up by calling the `end` method and
    passing in `done`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'With this in place, our test suite for `GET /todos/:id` is complete. Over in
    the Terminal it just reran and all of the test cases passed, and this is fantastic:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/aeccb951-303d-495e-9f59-c56fda1495f6.png)'
  prefs: []
  type: TYPE_IMG
- en: We now have a complete test suite set up for the route, which means we are done,
    and if the data comes back incorrectly, for example, if the body data has an extra
    character appended like the character `1`, the test cases are going to fail. Everything
    is working really, really well.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last thing left to do is commit our changes. Over inside the Terminal I''m
    going to shut down `nodemon` and run `git status`. Here are the only changes we
    have are our changes to the `server.test` file, which is a modified file—git is
    already tracking it, which means I can use `git commit` with the `-a` or `-m`
    flag or the combined `-am` flag, providing a message, `Add test cases for GET
    /todos/:id`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: I'm going to make the commit and push it up to GitHub. In the next section,
    we're going to switch things up a little bit. Instead of continuing on, adding
    new routes, which we will do a little later, we are going to deploy our application
    to Heroku using a real-world MongoDB database. That means all the calls we're
    making in Postman we can make to a real server, and anybody can make those calls,
    not just people on our local machine, because the URL will no longer be on the
    localhost.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying the API to Heroku
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you're going to deploy the Todo API to Heroku so anybody with
    the URL can access these routes, adding and fetching Todo items. Now, before we
    can push it to Heroku, there are quite a few things we need to change, small tweaks
    to get it ready for the Heroku servers. One of the bigger tweaks is going to be
    to set up a real MongoDB database because currently we use a localhost database
    and this is not going to be available once we get our app on Heroku.
  prefs: []
  type: TYPE_NORMAL
- en: 'To kick things off we''re going to move into the `server` file and set up the
    `app` variable to use the `environment` port variable that Heroku is going to
    set, which we did in the previous section when we deployed to Heroku. If you remember,
    what we did was we created a variable called `port` and we set that equal to `process.env.PORT`.
    This is the variable that may or may not be set; it''s going to be set if the
    app is running on Heroku, but it won''t be set if it''s running locally. We can
    use our `||` (OR) syntax to set up a value if a port is not defined. This is going
    to be used on the localhost and we''re going to stick with port `3000`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'If the `process.env.PORT` variable is there, we''re going to use it; if it''s
    not we''ll use `3000`. Now, we need to swap out `3000` in `app.listen` with the
    `port`, which means our call to `app.listen` is going to have `port` passed in
    and our string below is going to get switched to a template string, so we can
    inject the actual port. Inside `app.listen` I''ll use `Started up at port`, then
    I''m going to inject the actual port variable into the template string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Alright, the port is set up and now we can move into the `package.json` file.
    There''s two things we need to tweak. First up, we need to tell Heroku how to
    start the project. This is done via the `start` script. The `start` script is
    the command that Heroku is going to run to start the application. In our case
    it''s going to be `node`, then we''re going to go into the `server` directory
    and we''re going to run the `server.js` file. I have a comma at the end and we
    are good to go with the `start` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The next thing we need to do is tell Heroku which version of Node we want to
    use. The default version currently is a v5 version of Node and that''s going to
    cause some problems because we take advantage of a lot of ES6 features in this
    project, and those are available in v6 of Node. In order to figure out exactly
    what version of Node you''re using, you can run `node -v` from the Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5bd2f4bd-ccb0-4ef8-83e3-4d79bf3343fc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here I''m using 9.3.0; if you''re using a different v6 version that is perfectly
    fine. Over inside of `package.json` we''re going to tell Heroku to use the same
    version we''re using here. This gets done by setting up an `engines` property,
    and `engines` lets us specify various versions for things that Heroku lets us
    configure. One of these is `node`. The property name will be `node` and the value
    is going to be the version of Node to use, `6.2.2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Now our `package.json` file is ready for Heroku. Heroku knows how to start the
    app and it knows exactly which version of Node we want to use, so we won't get
    any weird errors when we deploy.
  prefs: []
  type: TYPE_NORMAL
- en: 'With `package.json` out of the way, the last thing we need to do is set up
    a database, and we''re going to do this with a Heroku add-on. If you go to Heroku''s
    website and click on any of your apps, we haven''t created one for this one, so
    click on an app from the previous section. I''m going to go ahead and click on
    one of mine. You''re going to see a little dashboard where you can do quite a
    few things:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2d3cf4cd-110f-4f91-8b04-491a124357f9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As shown in the preceding screenshot, you can see there''s an Installed add-ons
    section, but what we really want is to configure our add-ons. When you configure
    your add-ons you''re able to add all sorts of really cool tools that come built
    in to Heroku. Now, not all of these are free but most of them have a good free
    plan:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/64dbf0fc-816e-41bc-822c-266c7a5d7921.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can see we have various database-related items; down below we have Data
    Store Utilities, we have Monitoring tools, and a lot of really cool stuff. What
    we''re going to be using is an add-on called mLab:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/933af428-a4ba-4c37-8d70-5cb0bf05186b.png)'
  prefs: []
  type: TYPE_IMG
- en: This is a MongoDB database service; it has a great free plan, and it's going
    to let us integrate MongoDB with our Heroku application. Now, you don't actually
    need to do anything from the website, as we're going to do everything from the
    Terminal. I just want to make you aware of exactly where this lives. Down below,
    you can see they do have a free Sandbox plan and they have plans that go all the
    way up to $5,000 a month. We're going to be sticking with a zero-dollar plan.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Heroku app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to get set up, over inside of the Terminal we''re going to create
    a new Heroku app because currently we don''t have one. `heroku create` is the
    command to get that done:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/228770c5-058b-4d63-9a08-6b772f713115.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once the application has been created we need to tell the app that we want
    to use `mLab`, which is short for Mongo Lab. In order to add this add-on, we''re
    going to run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the add-on is `mongolab:`, and after the `:` we''re going to specify the
    plan we want to use. We''re going to use the Sandbox plan, which is free:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run this command it''s going to configure `mLab` with our Heroku application
    and we are good to go. Now, if you run the `heroku config` command you can actually
    get a list of all the configuration variables for your Heroku application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6530f625-915e-42d0-8859-4e2222687f14.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Right now, we just have one configuration variable; it''s a MONGODB_URI. This
    is the database URL that `mLab` gave us. This is the one we need to connect to,
    it''s the only one available for our app. Now, this MONGODB_URI variable, this
    is actually on `process.env` when the app runs on Heroku, which means we can use
    a similar technique to what we did inside of our `mongoose.js` file. Inside of
    `mongoose.js`, right in our call to `connect`, we can check if `process.env.MONGODB_URI`
    exists. If it does, we''re going to use it; if it doesn''t, after our `||` statement,
    we are going to use the localhost URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: And this is going to make sure that our Heroku app connects to the actual database
    because connecting to localhost will fail, causing the app to crash. With this
    in place, we are now ready to get things going.
  prefs: []
  type: TYPE_NORMAL
- en: 'Over inside of the Terminal I''m going to run `git status` to check our changed
    files:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cda444d3-55d5-44f9-b5f2-e01c9615739d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We have three; everything looks good. I can run `git commit` with the `-am`
    flag. This is going to let us specify our commit message, `Setup app for heroku`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'I''m going to make the commit and push it up to GitHub. Now, we need to push
    our application to Heroku. I''m going to do that using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Remember, when you create a Heroku application, it automatically adds that Heroku
    remote and here we're posting it to the master branch. The master branch is the
    only branch Heroku is actually going to do anything with. The application is getting
    pushed up; it should be ready in just a few seconds. Once it's done, we can open
    up the URL in the browser and see exactly what we get.
  prefs: []
  type: TYPE_NORMAL
- en: Heroku logs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another command I want to talk about for just a moment is a command called
    `heroku logs`. The `heroku logs` command shows you the server lives for your application.
    If anything goes wrong you usually get an error message inside of the Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f50b0316-8ace-4d3a-982b-4b82dbe139da.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, as you can see, we have our Started on port 4765 message printing at the
    bottom, which is great; your port is going to be different. As long as you have
    this message everything should be good to go. I am going to run `heroku open`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is going to open up the application in my browser. I''m going to choose
    to copy the URL. I''ll move into Chrome, and I can visit it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/666649b2-58e3-4844-87c0-fe79f551c4e8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, visiting the root of the app should do nothing because we haven''t set
    up a root URL, but if we go to `/todos` we should get our `todos JSON` coming
    back:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/10bcefb2-8817-4860-b2fa-50106753b2c0.png)'
  prefs: []
  type: TYPE_IMG
- en: Here you can see we have an empty array, which is expected because we haven't
    added any Todo items, so let's go ahead and do that.
  prefs: []
  type: TYPE_NORMAL
- en: 'What I want to do is grab the URL and head over to Postman. Inside of Postman
    we''re going to make a few calls. I''m going to create a `POST /todos` request;
    all I need to do is take the URL and swap it out with the one I just copied, then
    I can send off the request because the body data is already configured. I''m going
    to send that off. We get our Todo item and this is not coming from our local machine,
    this is coming from our Heroku application, which is talking to our Mongo Lab
    MongoDB database:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/090d8e5a-d281-40ea-b91b-c981c6c8ec73.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, all the other commands should also work. I''m going to go to `GET /todos`,
    paste in the URL, and we should be able to get all of our Todo items:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7e5e7556-9672-493d-a82a-d29be9feb3c7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'I''m also going to check what happens when we try to fetch an individual Todo.
    I''ll copy the `_id`, add it on to the URL, and send off that request:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/711071d6-9ab7-4e77-9a4f-f8c9ef5cbbb5.png)'
  prefs: []
  type: TYPE_IMG
- en: I get the individual Todo item. So, no matter which call we use, everything
    is working as expected and this is fantastic. Our application is now running on
    Heroku with a real production database, and that is it for this one. Now that
    we're clued up on Heroku, in the next section I'm going to show you a few tweaks
    and tricks we can use inside of Postman to make switching between our local environment
    and our Heroku environment much, much easier.
  prefs: []
  type: TYPE_NORMAL
- en: Postman environments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we get back to creating our express routes, we're going to take a quick
    moment to explore a feature of Postman that's going to make it a lot easier to
    switch between your local environment and the Heroku application. This is called
    Postman Environments.
  prefs: []
  type: TYPE_NORMAL
- en: Managing Postman environments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, in order to illustrate this I am going to start up my local server by
    running `node server/server.js` command, and over inside of Postman we''re going
    to start making a few requests. Now, if you remember, in the last section we made
    a request to our Heroku application. I click Send on the `GET /todos` URL and
    I get the `todos` array back as expected. The problem is that the actual items
    saved in the Collections tab, they all use that localhost URL and there''s no
    good way to switch between the two. To fix this issue we''re going to create environments,
    one for our local machine, and one for Heroku. This is going to let us create
    a variable as the URL and we can change that variable by flicking a switch over
    in the No environments dropdown. To illustrate exactly how this is going to work
    I am going to be copying the Heroku URL right now, then I''m going to head over
    to the No environment dropdown, and click Manage Environments:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/86476d86-6921-457e-9108-e9d0850f025e.png)'
  prefs: []
  type: TYPE_IMG
- en: Here we currently have none, but we can go ahead and add in two.
  prefs: []
  type: TYPE_NORMAL
- en: Todo App Local environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For the first environment I''m going to call `Todo App Local`. This is going
    to be the local Todo application and we can set up a set of key value pairs. Now,
    the only key we''re going to set is url. We''re going to set a localhost URL for
    the Todo App Local environment and we''ll set the Heroku URL for the Todo App
    Heroku environment, which we''ll create in just a second. We''ll enter `url` as
    `localhost:3000`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0cd6eac1-9736-46fa-bb60-cd05c0dab9b3.png)'
  prefs: []
  type: TYPE_IMG
- en: We're leaving off paths because that is going to depend on the individual route.
    I'm going to go ahead and add that environment.
  prefs: []
  type: TYPE_NORMAL
- en: Todo App Heroku environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can create a second one; this one will be called `Todo App Heroku` and we''re
    going to set the `url` key once again. This time though we''re setting it equal
    to the value I copied to the clipboard, the Heroku application URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d25b6893-7c19-4bcc-b91e-f5e984739785.png)'
  prefs: []
  type: TYPE_IMG
- en: I'm going to add that, now we have our two environments and I can close that
    window manager.
  prefs: []
  type: TYPE_NORMAL
- en: 'I''m going to close all of my tabs and I''m not going to make any changes by
    saving, then I''m going to go to `GET /todos`. Now, currently, `GET /todos` automatically
    fetches from `localhost`. What we''re going to do is replace the URL, everything
    before the slash, with the following syntax, which will look similar if you''re
    familiar with any templating engines: two curly braces followed by the variable
    name, `url`, followed by two closing braces, `{{url}}`. This is going to inject
    the URL meaning that the `GET /todos` request is now dynamic. We can change which
    endpoint it requests from, localhost or Heroku, based on the environment. I''m
    going to save this request and fire it off, and you''ll notice when you try to
    fire this request that we get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dfb4ed04-4556-437c-b818-084110cafd94.png)'
  prefs: []
  type: TYPE_IMG
- en: 'It''s trying to make a request to a URL that starts with the curly braces;
    it is the encoded character, `url`, the closing curly braces, and todos. That''s
    because the `url` variable is currently not defined. We need to switch to an environment.
    Over in the environments list we now have Todo App Heroku and Todo App Local.
    If I click Todo App Local and send that request off, I get my two items in the
    local database:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ec632d3c-ebe0-4764-8f55-92e12132b1e0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If I switch over to Todo App Heroku, this is going to make a request to the
    Heroku application. It''s going to be updating the URL and when we fire it off
    we get a different set of data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ed631fd9-25a4-46e1-a145-68b9d360c2bc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This time around all we have is our one Todo item, the one that''s available
    on the Heroku application. With this in place, `GET /todos` can now easily be
    used to fetch localhost or Heroku items, and we can do the same thing with our
    `POST /todos` request. I''m going to replace the URL with curly braces, and inside
    of those curly braces we''ll have the `url` variable. Now I can go ahead and save
    this request, fire it off, and it''s going to make a new Todo on the Heroku application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bac62164-ff98-4f51-9de7-fae6a35c6012.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If I switch to the Todo App Local, we can fire that off and now we have a new
    Todo on the Local environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e9962c29-7867-4a3c-b2b5-35ad1ece5a3b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The last request to change is going to be the `GET /todos/:id` request. We''re
    going to take that `localhost:3000` once again, then we''re going to go ahead
    and replace it with `url` just like this, `{{url}}`, and now we are done. We can
    save the request and we can go ahead and fire it off. Now, this one has a second
    variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f3f4c26f-c323-4fc7-b655-20f97d8f21ad.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This is the actual Todo ID; you could add this as a variable as well. For now
    though, since it''s going to change as we add and delete Todos, I''m going to
    simply grab one from the local database, move into the `GET /todos` request, swap
    it out, and send it off, and we get our todo back:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/03fbcf9f-d253-4b67-8134-cb994c78507d.png)'
  prefs: []
  type: TYPE_IMG
- en: If I make it a Todo ObjectID that doesn't exist, by changing one of the numbers
    to `6`, I get a `404` status code. Everything is still working as expected, and
    it's also going to work in the Heroku environment. I'm going to fetch all the
    todos from the Heroku environment, grab one of the `_id`s, move to the `GET /todos/:id`
    request, swap out the ID, send it off, and we get the todo item.
  prefs: []
  type: TYPE_NORMAL
- en: Hopefully you're starting to see why these Postman Environments are so convenient.
    You can easily switch between two environments, changing exactly what happens
    to the request. Now, in this case, we happen to only have one variable `url`;
    you could add others, and we will a little bit later. For now though, that is
    it, we have a way to swap between the two environments inside of Postman. Now
    that we have this in place, we're going to move back into the Atom editor and
    we're going to start adding new routes. There's two more to go. In the next section,
    you're going to learn how to delete Todos by ID.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting a resource – DELETE /todos/:id
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we're going to explore how to remove documents from our MongoDB
    collections using Mongoose. Then you're going to be responsible for filling out
    the `delete` route, which will let someone delete a Todo by the ID.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started we''re going to duplicate that `mongoose-queries` file, calling
    the new file `mongoose-remove`. Inside of the file we can remove everything below
    our initial imports. I''m going to highlight everything in the file, including
    the uncommented-out code, remove it, and we end up with a file that looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Mongoose gives us three methods for deleting our records; the first one lets
    you delete multiple records.
  prefs: []
  type: TYPE_NORMAL
- en: Todo.remove method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This one is `Todo.remove`, and `Todo.remove` works kind of like `Todo.find`.
    You pass in a query and that query matches multiple records, removing all of them.
    If it matches none, none will get removed. Now, the difference between `Todo.find`
    and `Todo.remove`, other than the fact that remove removes the docs, is that you
    can''t pass in an empty argument and expect all the documents to get removed.
    If you want to remove everything from your collection you need to run it like
    `Todo.remove({})`. If we run this we''re going to have everything get removed.
    I''m going to tack `then`. We''re going to get back our result and we can print
    that result to the screen using `console.log(result)`, just like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can run the `mongoose-remove` file, which is going to remove all of
    the Todos from our database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/8c04ea2d-7a16-4a78-b0b9-c0f6b1114821.png)'
  prefs: []
  type: TYPE_IMG
- en: Now when we run the `remove` method, once again we get back a `result` object;
    a lot of this stuff is not useful to us but up at the very top there is a `result`
    property. We can see that the removal did work, we got a `1` back as opposed to
    `0`, and we have the number of records that were removed. In this case the number
    of records happens to be `3`.
  prefs: []
  type: TYPE_NORMAL
- en: Todo.findOneAndRemove method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two other ways to remove documents and these are going to be much
    more useful for us in this section. The first one is going to be `Todo.findOneAndRemove`.
    Now, `findOneAndRemove` is going to work kind of like `findOne`: it''s going to
    match that very first document, only it''s going to remove it. This will also
    return the document so you can do something with the removed data. The data will
    be removed from the database but you will get the object back so you can print
    it to the screen or send it back to the user. This is unlike the `remove` method.
    In the `remove` method we do not get the docs back that got removed, we just get
    a number saying how many were removed. With `findOneAndRemove` we do get that
    information back.'
  prefs: []
  type: TYPE_NORMAL
- en: Todo.findByIdAndRemove method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another method is `Todo.findByIdAndRemove`. The `findByIdAndRemove` method
    works just like `findById`: you pass in the ID as the argument and it removes
    it. Now, both of these are going to return the doc and that is exactly what we
    want. There''s no need to run both of them, we can just run one. The `Todo.findByIdAndRemove`
    method, this is going to let us remove a `Todo ById`, some ID like `asdf`, and
    we''re going to be able to attach a `then` method providing our callback, and
    the callback is going to get the doc back. You could call it doc, or in this case
    we can call it `todo` since it is a Todo item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have this in place, we just need to create a Todo, since we deleted
    all of them, and include the ID. Over inside of Robomongo I can right-click that
    `todos` collection and insert a document. We''re just going to set a `text` property
    and I''ll set that `text` property equal to `Something to do`, and we can save
    that record. I''m going to make sure that when I click View Documents we do get
    our one document:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4d70010f-0594-4a0c-a4f4-edf08d09155c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now obviously it is missing some of the properties since I created it in Robomongo,
    but that is fine for our purposes. I''m now going to edit that document and grab
    the ID, and this is the ID we can add in to our playground file to make sure the
    document gets removed. Over inside of Atom, in the `findByIdAndRemove` method,
    we''ll pass in our string. This is the string ID, and inside of our `then` callback
    we''re going to use `console.log` to print the todo to the console. I am going
    to comment out this call to remove previous because otherwise it would remove
    the document we''re trying to remove:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'With this in place, I can now save the file, head into the Terminal, and rerun
    the script. I''m going to shut it down and start it up again:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/18facfc6-160e-471b-9854-7064243c797a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We get our documents, which is fantastic, and if I head into Robomongo and
    try to fetch the documents in todos, we''re going to get an error that there are
    no documents; we had one but we deleted it. Now, inside of Atom we can also play
    around with `findOneAndRemove`. The `findOneAndRemove` method works exactly the
    same as `findByIdAndRemove`, only it takes that query object. This would be `Todo.findOneAndRemove`;
    we would pass in the query object like this, pasting in our ID, and we could attach
    our `then` callback, which would get called with the document:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Both of these work very similarly, but the big difference is whether or not
    you need to query by more than just the ID. Now that you know how to use `findByIdAndRemove`,
    we're going to go into the `server` file and start filling out the actual route.
    This is going to be the route that lets us delete a Todo. I'll do the setup for
    the route for you, but you're going to be responsible for filling out everything
    inside of the callback function.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a delete route
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To create a delete route we're going to use `app.delete`. Then we're going to
    provide the URL, which will look identical to the one we have for getting an individual
    Todo by Id, `/todos/:id`. This will be the ID we can access inside of the callback
    function. The callback function will get the same request and response arguments,
    and inside I'll leave some comments to guide you in the right direction, but you're
    going to be responsible for filling every single thing out. First up, get the
    id. You're going to pull off the ID just like we do up above and we're going to
    do that because the next thing you're going to do is validate the id. If it's
    not valid, return `404`. If it's not valid you're going to send a 404 back just
    like we do above. Next up, you're going to remove todo by id and this is going
    to require you to use that function we just discussed over inside of the `mongoose-remove`
    file. You're going to remove it by ID and there's two ways that could go. We could
    have a success or we could have an error. If we do get an error you can respond
    in the usual way, sending back a `400` status code with empty body. Now, if it's
    a success we're going to need to make sure that a Todo was actually deleted by
    checking that the doc came back; if no doc, send `404`, so the person knows that
    the ID could not be found and it could not be removed, if `doc`, send `doc` back
    with `200`. Now, the reason we need to check if the doc exists is because this
    function, `findByIdAndRemove`, is still going to have its success case called
    even if no Todo gets deleted.
  prefs: []
  type: TYPE_NORMAL
- en: 'I can prove this by rerunning the file after having deleted the item with that
    ID. I''m going to comment out `findOneAndRemove`, head into the Terminal, and
    rerun the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2d54687a-389c-48ad-ad10-3c64281e02a9.png)'
  prefs: []
  type: TYPE_IMG
- en: We get null as the value of Todo. That means you want to set up an `if` statement,
    to do something specific if no item was actually deleted. With this in place,
    you are ready to go. You know how to do all of this, most of it is done in the
    route up above and everything specific to removing an item was done over in this
    `playground` file.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we need to do is grab the ID off of the request object. I'm
    going to make a variable called `id`, setting it equal to `req.params`; this is
    where all of our URL parameters are stored, then we get it by value. We have id
    set up so we would get the `id` property. I'm going to remove the comment and
    down below we can validate the ID, `if(ObjectID.isValid)`. Now, we're checking
    if this ID is valid, and if it is valid, well we don't really want to do anything,
    all we care about is if it's not valid. So, I'm going to flip the Boolean value
    and inside of the `if` condition we can now run some code when the ID is not valid.
    That code is going to send back a `404` status code. I'm going to use `return`
    to prevent the rest of the function from being executed, then we're going to go
    ahead and respond, setting the status, `res.status`, equal to `404`, and we'll
    call `send` to initiate the response with no body data. Now that the ObjectID
    is valid, we can move on down below actually removing it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re going to kick things off by calling `Todo.findByIdAndRemove`. Now, `findByIdAndRemove`
    as you know takes just one argument, the actual `id` to remove, we can call `then`,
    passing in our success callback, which as we know will get called with the individual
    `todo` document. Now, inside of the success case we still have to make sure a
    Todo is actually deleted. If there was no Todo, we''re going to send a 404 back;
    if there was no Todo, we are going to respond using `return` and set the status
    using `res.status` to `404`, and call `send` to initiate the response. Now, if
    this if statement doesn''t run it means a Todo was actually deleted. In that case
    we want to respond with `200`, letting the user know that everything went well,
    and we''re going to send the `todo` argument back, `res.send`, passing in `todo`.
    The only thing left to do for this Todo challenge is to call `catch`. We''re going
    to call catch so we can do something with any potential errors. All we''re going
    to do is respond using `res.status`, setting it equal to `400`, and we''ll go
    ahead and call `send` with no arguments sending back an empty response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: With this in place, we are now good to go. We have everything set up just like
    we wanted to, which means we can remove the comments from down below, and you'll
    notice that the method we have down below looks really similar to the one we have
    up above, and this is going to be the case for a lot of our routes that manage
    an individual Todo item. We're always going to want to get that ID, we're always
    going to want to validate that the ObjectID is indeed a real ObjectID, and inside
    of our success and error cases, similar things are also going to happen. We want
    to make sure that a doc was actually deleted. If it wasn't we'll send back that
    `404`, and with this in place we can now verify that this route works.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can save the file and start up the server in the Terminal. I''ll use
    the `clear` command to clear the Terminal output and then we can run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the server is up, we can move into Postman and start firing off a couple
    of requests. First up, I''m going to create a few Todos. I''ll send this `POST
    /todos` off, and then I''ll change the `text` property and send it off again.
    I''ll change the body text to `Some other todo item`, sending that off, and now
    we should have two todos. If I go to `GET /todos` and fetch them, we get our two
    `todos`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f5298901-ec78-45b8-acad-fd01a11d843c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, I am going to need one of these IDs; this is going to be the todo that
    we delete, so what I will do is copy this to the clipboard, then we can go ahead
    and create our new route. This new route is going to use the `delete` method so
    we''re going to switch from GET to DELETE, then we can go ahead and provide the
    URL using the environment variable URL that we created in the last section. The
    route is `/todos/id`. I''m going to paste the ID in there:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f0366096-9c4b-482c-ba9a-40ec8db5264c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now I can go ahead and run the request. When we run it, we get a status code
    of 200 OK; everything went well, and we have the document that we deleted:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f80c4479-640d-4a61-9f98-62d9c48fad2c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If I go back to `GET /todos` and rerun it, now we only have one document; the
    item that we passed in as the ID to delete did indeed get deleted. I''m going
    to save this request to our collection so we can fire it off without having to
    manually enter all of that information. Let''s save as `DELETE`, followed by the
    route `/todos/:id`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b99a8f13-fdf1-4a17-a2e5-375f4f3b8a3b.png)'
  prefs: []
  type: TYPE_IMG
- en: We are going to save this to an existing collection, the Todo App collection.
    Now we have a `DELETE /todos/:id` route sitting right in Collections, we can always
    go ahead and access it whenever we need to. Now, from here, we're going to go
    ahead and fire the request again, this is going to try and delete a Todo whose
    ID is valid but doesn't match one in the collection, and we get `404` back. Now
    if I make this ID invalid by deleting a bunch of characters and I send that off,
    we also get a `404` status code because the ID is invalid, which is fantastic.
  prefs: []
  type: TYPE_NORMAL
- en: With this in place, we can now make a commit. Over inside of the Terminal, I'm
    going to shut the server down, run `git status`, and you'll see we have two files.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have a new file, the Mongoose playground file, and we have our modified
    `server` file. I''m going to use `git add .` to add all of those to the next commit,
    and we''ll use `git commit` with the `-m` flag to make the commit, `Add DELETE/todos/:id
    route`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'I''m going to make the commit and push it up to GitHub. We can also go ahead
    and deploy our application using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Now we'll be able to delete our Todos inside of the Heroku application. With
    this in place, we are now done. In the next section we're going to write some
    test cases for the route we just set up.
  prefs: []
  type: TYPE_NORMAL
- en: Testing DELETE /todos/:id
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you're going to write some test cases that verify our `delete`
    route works as expected. Now, before we get into that, what we're going to do
    is make one quick change to the delete route to make it match our other routes.
    Our other routes return an object and on that object, the response body, we have
    a `todo` property, and we did the same thing for the `todos` call. On the response
    body we have the `todos` property and that stores the array. For the delete request,
    we never did that.
  prefs: []
  type: TYPE_NORMAL
- en: 'What I''m going to do is send back an object as the response body, where the
    `todo` property equals the `todo` that got deleted, although we''ll just use that
    ES6 syntax to send that back:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: With this in place, we can now go ahead and write some test cases that verify
    the `delete` route works as expected, and this is going to happen at the very
    bottom of our `server.test` file. I'm going to create a new `describe` block for
    the `DELETE /todos/:id` route. We'll provide our arrow function and we can go
    ahead and call it three times.
  prefs: []
  type: TYPE_NORMAL
- en: Test case 1 - should remove a todo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first test case, `it(''should remove a todo'')`, this is going to be test
    case number one; it''s going to verify that when we pass in an ID that does exist
    inside of the Todos collection, the item gets removed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Test case 2 - should return 404 if todo not found
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next up, `it(''should return 404 if todo not found'')`. If we try to delete
    the Todo but nothing was actually deleted, we''re going to send a `404` status
    code back so the user knows that the call probably didn''t work as expected. Yes,
    the call didn''t necessarily fail, but you never deleted the item you wanted to
    delete, so we are going to consider that a failure, and that''s what we did when
    we sent the `404` status code back:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Test case 3 - should return 404 if object id is invalid
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The last test we''re going to write is `it(''should return 404 if object id
    is invalid'')`. This test is going to verify that when we have an invalid ObjectID,
    we do get a `404` status code back which is the expected response status code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, these two tests we''ll fill out a little bit later; we''re going to go
    ahead and focus on the first one because this is where we''re going to need to
    do a few complex things. Not only are we going to need to send off the request,
    but after the request comes back, we''re going to want to assert some things about
    it, and we''re going to want to query the database, making sure the Todo was actually
    removed from the `Todos` collection. The first thing I''m going to do is figure
    out which Todo I want to delete. We have two options up above. I''m going to go
    ahead and delete the second Todo item, though that choice is irrelevant; you could
    easily just do this with the first one. Down below, we''ll create a `hexId` variable,
    like we did for our previous test case. We''re going to set that equal to the
    second item from the `todos` array, then we''re going to go ahead and grab its
    `_id` property, calling the `toHexString` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have the `hexId` for the second Todo item, we can start worrying
    about making the request. I''m going to call `request`, passing in the `app` we
    want to make the request to, then we can call `delete`, which is going to trigger
    a delete HTTP request. The following URL is going to have some variables injected
    into it, so I will use template strings: it''s `/todos/` followed by the ID. I''m
    going to inject the `hexId` variable. Now that we have our `delete` method all
    set up, we can move on and start making our expectations. We''re going to `expect`
    that we get a `200` status code back; we should get a `200` status code because
    `hexId` is going to exist in the database. Next up, we can assert that the data
    comes back as the response body. I''m going to make a custom `expect` call, passing
    in our function, where we have the response argument sent in, and all we''re going
    to do is assert that the ID is the ID right in the `hexId` variable. We''re going
    to `expect` that the `res.body` property has a `todo` prop where the `_id` property
    equals the `hexId`, `toBe(hexId)`. If this is the case then we can verify the
    call pretty much worked as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The last thing we need to do is query the database and make sure the item was
    actually removed. I'm going to call `end`, passing in a callback, so we can do
    a few asynchronous things before we wrap up the test case, and if you remember
    it gets called with an error and the response. If there is an error we're going
    to need to handle that because otherwise there's no need to query the database,
    `if (err)`. We're going to `return` to prevent the function execution, `done`,
    passing in that error so the error gets rendered by Mocha. Now we can go ahead
    and make the query, and this is actually going to be your challenge for this section.
  prefs: []
  type: TYPE_NORMAL
- en: What I want you to do is query database using `findById`. You're going to try
    to find the Todo item that has the ID stored in the `hexId` variable. When you
    try to find that ID it should fail, and you should get nothing back. You're going
    to create that `Todo` variable in your `then` call and make sure it does not exist.
    You can make sure something doesn't exist using the `toNotExist` assertion. That
    would look something like this, we `expect(null).toNotExist()`. Although, instead
    of `null`, you'll pass in the `Todo` argument which is going to be in your success
    handler. Now, this usually would contain the Todo item, but since we've just deleted
    it, it should not exist; this is going to get all of that done. Now, if there
    is an error you're going to do the exact same thing we did in our test case for
    `POST /todos`. We simply add a `catch` clause, passing the error through to `done`.
    Now that you know what to do, it's your job to get it done. What I'd like you
    to do is fill this out, fill out the query, make sure to handle the errors, make
    sure to call `done`, then you can go ahead and run the test suite, verifying that
    this test case passes. The last two test cases are going to fail, so for the moment
    I'm just going to comment them out; they're going to fail because we have a `done`
    argument specified, but we never called it so the test will timeout after two
    seconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing to do is call `Todo.findById`, passing in that `hexId`. This
    is the item that should have gotten deleted. Now we can call then, passing in
    our callback, it is going to get called with the doc, the `todo` variable, and
    all we''re going to do is verify that it does not exist. We just deleted it, so
    `findById` should return null for the doc. We''re going to `expect` that the `todo`
    variable does not exist using the `toNotExist` method available on that expect
    library. Now, we do need to call `done` to wrap up the test case. From here, we
    can go ahead and call `catch`. I''m going to call `catch`, grabbing that error
    argument and passing it through to `done`. There''s no need to provide curly braces
    here; we just have one statement so we can use the shortcut, which is available
    in ES6 for error functions. With our actual query in place, we can remove the
    comments that outlined what was supposed to happen and we can run the test case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Over inside of the Terminal we can now run the test suite to verify that everything
    we set up worked as expected. Over inside of Terminal, I''m going to run the following
    command to start up our test suite with Nodemon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'And when it runs we see that we have our one test under the `DELETE` describe
    block and it is passing; it should remove a todo passed without any errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/864712bc-7e32-458c-a2ec-c3b6d5f2440b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that we have our one test case in place we can fill out the two other ones.
    These test cases are going to be basically identical to the test cases we have
    for the `GET /todos/:id` route. There''s no shame in copying and pasting code
    when you:'
  prefs: []
  type: TYPE_NORMAL
- en: Know exactly what the code does; we know what it does because we wrote it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Actually do need it—we can't reuse it, we need to tweak it just a little bit,
    so it does make sense to copy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test case 4 - should return 404 if todo not found
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I''m going to copy the `should return 404` test case for the `should return
    404 if todo not found` test, and we''re going to paste that into the exact same
    test for the `delete` route, and all we have to do is change `.get` to `.delete`,
    and save the file. This is going to rerun the test suite, and now we have two
    tests under delete; they are both passing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f4e108cd-f803-4800-b1de-e99de825b274.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can see our last test still fails, so we can go ahead and do the same thing.
    I''m going to copy the code from `should return 404 for non-object ids`, which
    verifies that non-ObjectIDs cause a `404` status code. I''m going to paste it
    in the last test case, changing the `.get` method call to `.delete`. If I save
    the file it''s going to rerun the test suite and this time around all 9 test cases
    are passing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ccac1fd1-7cd8-4665-b5b6-c5a64d0195c4.png)'
  prefs: []
  type: TYPE_IMG
- en: With this in place, we now have `DELETE /todos` tested. Let's go ahead and wrap
    this one up by making a commit over inside of the Terminal.
  prefs: []
  type: TYPE_NORMAL
- en: 'I''m going to run `git status` to see what changes I have going on. We made
    one small change to the `server` file and we added our tests to the `server.test`
    file. I can use `git commit` with the `-am` flag to make it commit, and a good
    message for this one would be `Test the DELETE /todos/:id route`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: I'm going to take that commit and push it up to GitHub, and there's no need
    to deploy to Heroku since we haven't created anything visually different. We did
    tweak the `server` code just a little bit, but we'll worry about that a little
    bit later. For now, everything is good; we can move on to the next section where
    you are going to create the final route for managing Todos. This is going to be
    a route that lets you update a Todo.
  prefs: []
  type: TYPE_NORMAL
- en: Updating a Resource - PATCH /todos/:id
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `delete` route is now set up and tested, so it's time to start on the final
    route for managing our Todo resources. This is going to be the route that lets
    you update a Todo item whether you want to change the text to something else or
    whether you want to toggle it as completed. Now this is going to be the most complex
    route we write; everything so far has been relatively straightforward. We're going
    to need to do a few extra things to get this updating route to work as expected.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing I want to do before we go ahead and create the route down below
    is install that Lodash library we used in one of the previous sections for this
    course.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Lodash library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you remember, Lodash provides a few really great utility functions and we''ll
    be taking advantage of a couple of those inside of our update route. Right in
    the Terminal, I''m going to use `npm i` with the `--save` flag to install it;
    the module name itself is called `lodash`, and we''ll be using the most recent
    version `@4.15.0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, once this is installed, we can `require` it up top and then we can go
    ahead and add our route. At the very top of the `server.js` file we can make a
    constant; we''ll use underscore as the name for the variable that stores the Lodash
    library, then we''ll go ahead and `require` it, `require(''lodash'')`. Now, I''ve
    used regular variables instead of constants for my other imports, so I can go
    ahead and switch these variables to constants as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have this in place we are ready to move to the bottom of the file
    and start adding the new route. This route is going to use the HTTP `patch` method;
    `patch` is what you use when you want to update a resource. Now remember, none
    of this is really set in stone. I could have a `delete` route that creates new
    Todos and I could have a `post` route that deletes todos, but these are just the
    general guidelines and best practices for API development. We're going to set
    up a `patch` method route by calling `app.patch`. This is what is going to allow
    us to update Todo items. Now, the URL is going to be the exact same URL as it
    has been when we're managing an individual Todo item, `/todos/:id`. Then we can
    set up our callback with our request and response arguments. Inside of the callback,
    one of the first things that we're going to need to do is grab that id just like
    we do for all our other routes. I'm going to make a variable called `id` and set
    it equal to `req.params.id`. Now, on the next line we're going to go ahead and
    create a variable called `body` and this is the reason I loaded in Lodash. The
    body, the request body, that's where the updates are going to be stored. If I
    want to set a Todos text to something else, I would make a `patch` request. I
    would set the `text` property equal to whatever I wanted the Todo text to be.
    The problem here is that someone can send any property along; they could send
    along properties that aren't on the Todo items or they could send along properties
    we don't want them to update, for example, `completedAt`. The `completedAt` property
    is going to be a property that gets updated, but it's not going to be updated
    by the user, it's going to be updated by us when the user updates the completed
    property. `completedAt` is going to be generated by the program, which means we
    do not want a user to be able to update it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to pull off just the properties we want users to update, we''re going
    to be using the `pick` method, `_.pick`. The `pick` method is fantastic; it takes
    an object, we''re going to pass in `req.body`, then it takes an array of properties
    that you want to pull off, if they exist. For example, if the `text` property
    exists, we want to pull that off of `req.body`, adding it to body. This is something
    that users should be able to update, and we''ll do the same thing for completed.
    These are the only two properties a user is going to be able to update; we don''t
    need users updating IDs or adding any other properties that aren''t specified
    in the Mongoose model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have this in place, we can get started down the usual path, kicking
    things off by validating our ID. There''s no need to rewrite the code since we''ve
    written it before and we know what it does; we can simply copy it from `app.delete`
    block and paste it in `app.patch`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: And now we can go ahead and move onto the slightly complex part of `patch`,
    which is going to be checking the `completed` value and using that value to set
    `completedAt`. If a user is setting a Todos `completed` property to `true`, we
    want to set `completedAt` to a timestamp. If they're setting it to `false`, we
    want to clear that timestamp because the Todo won't be completed. We're going
    to add an `if` statement checking if the `completed` property is a Boolean, and
    it's on `body`. We're going to use the `_.isBoolean` utility method to get that
    done. We want to check if `body.completed` is a Boolean; if it is a Boolean and
    that Boolean is true, `body.completed`, then we're going to go ahead and run some
    code. This code is going to run if it's a Boolean and it's `true`, otherwise we're
    going to run some code if it's not a Boolean or it's not `true`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If it is a Boolean and it is `true`, we''re going to set `body.completedAt`.
    Everything we set on body is eventually going to be updated in the model. Now,
    we don''t want the user to update everything, so we''ve picked off certain ones
    from the `req.body`, but we can make some modifications of our own. We''re going
    to set `body.completedAt` equal to the current timestamp. We''re going to create
    a new date, which we''ve done before, but instead of calling `toString`, which
    is the method we used in the previous section, we''ll be using a method called
    `getTime`. The `getTime` method returns a JavaScript timestamp; this is the number
    of milliseconds since midnight on January 1st of the year 1970\. It''s just a
    regular number. Values greater than zero are milliseconds from that moment forward,
    and values less than zero are in the past, so if I had a number of -1000, it would
    be 1000 milliseconds before that Unix epoch, which is the name for that date,
    that January 1st at midnight on 1970:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have that in place we can go ahead and fill out the `else` clause.
    Inside of the `else` clause, if it is not a Boolean or it''s not `true`, we''re
    going to go ahead and set `body.completed = false` and we''re also going to clear
    `completedAt`. `body.completedAt` is going to get set equal to `null`. When you
    want to remove a value from the database you can simply set it to null:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we''re going to go ahead and follow a usual pattern: we''re going to be
    making a query to actually update the database. The query that we''re going to
    be making is going to be really similar to the one we made in our `mongodb-update`
    file. Inside of `mongodb-update` we used a method called `findOneAndUpdate`. It
    took a query, the update object, and a set of options. We''re going to be using
    a method called `findByIdAndUpdate` which takes a really similar set of arguments.
    Right here in `server`, we will call `Todo.findByIdAndUpdate`. The first argument
    for `findByIdAndUpdate` is going to be `id` itself; since we''re using a `findById`
    method, we can simply pass in `id` as opposed to passing in a query. Now we can
    go ahead and set the values on our object, which is the second argument. Remember,
    you can''t just set key value pairs—you have to use those MongoDB operators, things
    like increment or, in our case, `$set`. Now, `$set`, as we explored, takes a set
    of key value pairs, and these are going to get set. In this case, we''ve already
    generated the object, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'We just happen to generate it in the `app.patch` block and it happens to be
    called `body`. So I will set the `$set` operator equal to the `body` variable.
    Now we can go ahead and move onto the final options. These are just some options
    that let you tweak how the function works. If you remember, in `mongodb-update`,
    we set `returnOriginal` to `false`; this meant we got the new object back, the
    updated one. We''re going to use a similar option with a different name; it''s
    called `new`. It has similar functionality, it just has a different name because
    that''s what the Mongoose developers chose. With a query in place though, we are
    done, and we can tack on a `then` callback and a `catch` callback, and add our
    success and error code. If things go well, we''re going to get our `todo` doc
    back, and if things don''t go well we are going to get an error argument, and
    we can go ahead and send back a `400` status code, `res.status(400).send()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we are going to need to check if the `todo` object exists. If it doesn''t,
    if there is no `todo`, then we''re going to go ahead and respond with a `404`
    status code, `return res.status(404).send()`. If `todo` does exist, that means
    we were able to find it and it was updated, so we can simply send it back, `res.send`,
    and we''re going to send it back as the `todo` property where todo equals the
    `todo` variable using the ES6 syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: With this in place, we are now done. It's not too bad but it was a little more
    complex than any of the routes we've done before, so I wanted to walk you through
    it step by step. Let's take just a quick moment to recap what we did and why we
    did it. First up, the first unusual thing we did is we created the `body` variable;
    this has a subset of the things the user passed to us. We didn't want the user
    to be able to update anything they chose. Next up, we updated the `completedAt`
    property based off of the completed property, and finally we made our call to
    `findByIdAndUpdate`. With these three steps we were able to successfully update
    our Todos when we make the patch call.
  prefs: []
  type: TYPE_NORMAL
- en: Testing Todos for the patch call
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, to test this out I''m going to save the `server` file and start up the
    server over in the Terminal. I''ll use `clear` to clear the Terminal output and
    we can run `npm start` to start up the app. The app is up and running on port
    3000, so over inside of Postman we can make some requests to see exactly how this
    works. I''m going to switch to the Todo App Local environment and make a `GET
    /todos` request so we can get a real ID for one of our Todo items, and you can
    see we have some old data from our tests right here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/715574f4-2129-456e-9d21-eea992ab313b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'I''m going to grab this second one with a `text` property equal to `Second
    test todo`, then I''m going to go ahead and create a new request, changing the
    method from GET to PATCH. We''re going to provide our URL, it''ll be `{{url}}`,
    then we''ll have `/todos/` the ID we copied:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/999eead1-07b4-49df-83b6-12e3e30939a7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now remember, the PATCH request is all about updating the data so we have to
    provide that data as the request body. I''m going to go to Body | raw | JSON in
    order to do just that. Let''s go ahead and make some updates to the Todo. I''m
    going to set `"completed": true` and if you look in the GET /todos tab you can
    see that second Todo has a `completed` value of `false` so it should change and
    the `completedAt` property should get added. With the request set up I''m going
    go ahead and send it off:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7f5eb1b0-0f13-4616-863e-cdbb88ba73d7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We get our `todo`, completed is set to `true`, and `completedAt` is set to
    the timestamp. Now I can also go ahead and tweak this, changing `"completed":
    true` to `"completed": false` to send off the request; this now sets `"completed":
    false` and clears `completedAt`. Lastly, we could go ahead and do something like
    setting the `text` property. I''m going to set it back to `true` and add a second
    property, `text`, setting that equal to `Updates from postman`. I can fire off
    this request and down below we get our Todo, looking just as we had expected it
    to look:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/972a6f06-70fb-4c95-839d-1909ef468be8.png)'
  prefs: []
  type: TYPE_IMG
- en: We have our `text` update; we also have our `completed` update and the timestamp
    showing up in the `completedAt` field. With this in place, we now have the ability
    to get, delete, update, and create Todo items—those are the four main CRUD actions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next thing we''re going to do is write some tests that verify `patch` works
    as expected, so we can automatically run them and catch any regressions in our
    code. For now, that is it, we are going to go ahead and, in the Terminal, make
    a commit and push our changes. We''ll push them up to Heroku and test that out
    as well. `git status` reveals that we have just those two changed files which
    means we can use `git commit` with the `-am` flag to make the commit. A good message
    for this one is, `Add PATCH /todos/:id`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'I''m going to make the commit and push it up to GitHub, and once it''s on GitHub
    we can push it up to Heroku using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Remember, the master branch is the only branch Heroku has access to; we're not
    going to be using branching in this book, but in case you already know branching
    and you're running into any issues, you do need to push to the Heroku master branch
    to have your app redeploy. Like I said, that is not an issue if you're using all
    the commands as I use them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the app is deployed, we can go ahead and open it up; we''re going
    to open it up by making requests inside of Postman. I''m going to switch to the
    Todo App Heroku environment, then I''m going to go ahead and inside of GET /todos,
    fire off the request:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/06715bc4-eb01-4126-b230-eb5d6ce81706.png)'
  prefs: []
  type: TYPE_IMG
- en: 'These are all the Todos available on Heroku. I''m going to grab this first
    one. I''m going to go over to the PATCH request, swap out the ID, and keep the
    same body. I''m going to set `"completed": true` and `"text": "Updates from postman"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/20e9d378-b340-4006-aa2a-a540ce8bb0c1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When we send that off, we get back the updated Todo. `completed` looks great,
    `completedAt` looks great, and `text` looks great as well. Now I''m going to go
    ahead and add this to my collections; the patch call is going to come in handy
    down the line, so I will click Save As, giving it the name we''ve used for all
    of ours, the HTTP method followed by the URL. I am going to save it to our existing
    collection, Todo App:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/79c288af-be83-462b-b760-5893ecc28dab.png)'
  prefs: []
  type: TYPE_IMG
- en: With this in place, we are done; we have our `patch` route working and it's
    time to move onto the next section where we will test this code.
  prefs: []
  type: TYPE_NORMAL
- en: Testing PATCH /todos/:id
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we, well I guess more appropriately you, are going to be writing
    two test cases that verify `patch` works as expected. We're going to take one
    Todo that's not completed and make it complete, and we'll take a second one that
    is complete and make it incomplete.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, in order to do that, we are going to need to tweak the seed data we have
    in our `server.test` file. The seed data right in `server.test` file is two Todo
    items; neither of them have the `completed` property specified, which means it''s
    going to default to `false`. For the second item, we''re going to go ahead and
    set it. We''re going to set `completed: true` and we''re also going to set `completedAt`
    equal to whatever value we want. You can choose any number at all. I''m going
    to go ahead and use `333`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have two Todos that are going to let us toggle both ways. To get started
    down below I will help you create the describe an `It` block so we''re on the
    same page, but you will be responsible for filling out the actual test cases.
    This section is basically going to be a challenge because we''ve done a lot of
    this stuff before. First up, the `describe` block. We''re going to `describe`
    this group of tests; we''ll use the method followed by the URL to do just that,
    then we can go ahead and add our function, and then we can define our two test
    cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: The first test is going to take our first Todo and set its `text` equal to something
    else, and we'll change `completed` from `false` to `true`, `it('should update
    the todo')`. We can provide our function with the `done` argument, and I'll leave
    some comments inside in just a moment to give you an idea as to how I'd like you
    to accomplish this. The second test is going to be for toggling that second Todo
    where the `completed` value is already equal to `true`, and then `it('should clear
    completedAt when todo is not completed')`. This test case is going to make sure
    that when we go ahead and remove the `completed` status, setting it equal to `false`,
    `completedAt` gets cleared. Now, for the first test case what you're going to
    do is grab the ID of the first item, `grab id of first item`, then you're going
    to make our patch request; you're going to provide the proper URL with the ID
    inside of it, and you're going to use send to send some data along as the request
    body. For this one I want you to update text, set it equal to whatever you like,
    and you're going to `set completed equal` to `true`. Now, once you send that off
    you'll be ready to make your assertions and you're going to make one assertion
    using the basic system, assert that you get a `200` status code back, and you're
    going to make one custom assertion. The custom assertion is going to verify that
    the response body has a `text` property equal to the text you sent in, `text is
    changed`. You're going to verify that `completed` is `true`, and you're also going
    to verify that `completedAt` is a number, and you can use the `.toBeA` method
    available inside of `expect` to get that done. Now, for the second test we're
    going to do something similar but we're just going to go in the other direction;
    we're going to `grab id of second todo item`, you're going to update the `text`
    to something different, and you're going to set `completed` to `false`. Then you
    can make your assertions. Once again, we will be expecting `200` for this one
    and we will be expecting that the response body now represents those changes,
    that the text is changed to whatever you happen to pick. I also want you to check
    that `completed` is now `false` and to check that `completedAt` is `null`, and
    you can use the `.toNotExist` method available on expect to make that assertion.
    This is what you need to do to complete the test suite. Once you're done I want
    you to run `npm test` and make sure both test cases pass.
  prefs: []
  type: TYPE_NORMAL
- en: Test 1 -  To complete the incomplete todo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s fill out the first test case first and I''ll kick things off by grabbing
    the proper ID. Let''s make a variable called `hexId`, setting it equal to the
    first todos, `_id` property, and we''re going to call `toHexString` to get the
    string back we can pass in to the URL. Next up, I''m going to go ahead and create
    some dummy text; this will be the new updated text. Let''s make a variable called
    `text` and set it equal to whatever you like. `This should be the new text`. Now
    we can go ahead and actually make our request using `request` to our express application.
    We will be using the `patch` method; hopefully you were able to figure that out
    on your own, and if you weren''t maybe you used the documentation for super test
    since I did not explicitly tell you how to make that `patch` call. Next up, we
    are going to be using a template string as our URL, `/todos/`, then we''re going
    to inject `hexId`. Now, before we can make our assertions we do need to send some
    data along as well, so I''ll call `send`, passing in the data. This is going to
    be the things we want to change. For this test we did want to set `completed`
    equal to `true`. I''m going to set `completed: true`, and we do want to update
    the text, so I''ll set `text` equal to the `text` variable up above, and I can
    always leave off this part using ES6:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have send in place, we can start making our assertions. The first
    one's easy, we're just expecting 200\. I'm going to `expect(200)` to be the return
    status code, and before we add our custom assertion, we can call `end`, passing
    in `done`. Now, the last thing we need to do is make those assertions about the
    data coming back. I'm going to call `expect`, passing in a function; this function
    as we know by now gets called with the response and we can make our custom assertions.
    We're going to make an assertion about `text`, `completed`, and `completedAt`.
    First up, `text`. We use `expect(res.body.todo.text).toBe(text)`, the variable
    we defined up above. If this is equal to the data that came back, then we're good
    to go.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next up, let''s make some assertions about that `completed` property. We''re
    going to use `expect(res.body.todo.completed)` and check that it''s true using
    `.toBe(true)`. We set `completed` to `true` so it should have changed from `false`
    to `true`. Now the last assertion we''re going to make inside of our custom expect
    call is going to be an assertion about `completedAt`, making sure it''s a number.
    We''re going to use `expect(res.body.todo.completedAt)` equals a number using
    `.toBeA`, inside of quotes the `number` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'With this in place, our first test is now complete. We can go ahead and remove
    those comments and actually verify it''s working by running it over in the Terminal.
    Our second test is going to fail; that''s fine, as long as the first one passes,
    we''re good to continue on. I''m going to run `npm test`, and this is going to
    fire off the test suite. We can see our first `PATCH` test succeeds; this is the
    one we just filled out, and our second one fails. We''re getting a timeout after
    two seconds, which is expected because we never call `done`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d8a67b4f-4cca-4143-8b7e-c196c25b3555.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that the first one is in place though, we can go ahead and fill out the
    second one. Now, the code for these two tests is going to be really, really similar.
    Now, since we just wrote the code and we know exactly what it does, we can copy
    and paste it. I'm not a fan of copying and pasting code I don't understand, but
    I am a fan of being efficient. Since I know what that code does, I can paste it
    right in second test case, and now we can go ahead and make some changes.
  prefs: []
  type: TYPE_NORMAL
- en: Test 2 - to make complete todo incomplete
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Instead of grabbing the `hexId` variable or the first Todo item, we want to
    grab the `hexId` variable for the second Todo item, and then the next thing we
    need to do is update the data we''re sending. We don''t want to set `completed`
    equal to `true`; we already did that manually up above. This one we''re trying
    to set to `false`. We are also going to update the `text` so we can leave that
    in place. I''m going to go ahead and tweak the text value a little bit, adding
    a couple of exclamation marks on the end. Next up, the assertions. We''re still
    expecting a `200` to be the status code that comes back. That part''s great, and
    we are still expecting the `text` to equal `text`. For completed, though, we''re
    expecting that to be `false` and we''re not expecting `completedAt` to be a number;
    it was a number originally but after this update it should have been cleared since
    the Todo is no longer completed. We can use `toNotExist` to assert that `completedAt`
    doesn''t exist:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'With this in place, our test case is done. We can now delete those comments,
    save the file, and rerun things from the Terminal. I''m going to rerun the test
    suite:'
  prefs: []
  type: TYPE_NORMAL
- en: We get both of our `PATCH` tests passing. Now, as you've probably noticed, for
    `patch` we didn't write those test cases for invalid ObjectIDs or ObjectIDs not
    found; you could add those but we've done them so many times so far, I don't see
    that as a necessary exercise. These two test cases, though, they do validate that
    our `patch` method is working as expected, especially when it comes to the slightly
    more complex logic that `patch` requires to get everything done. With this in
    place though, we are done testing our last route.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can go ahead and make a commit and move on to the final section of the chapter.
    Over in the Terminal I''m going to run `git status`. We''ll see we have one modified
    file, `server.test` file, which looks great. We can use `git commit` with the
    `-am` flag to make the commit, `Add tests for PATCH /todos/:id`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: I'm going to go ahead and make that commit, then I'll take a moment to push
    it up to GitHub and with that in place we are done. In the next section, which
    is the last one for the chapter, you will learn how to use a separate test database
    locally, so you're not always wiping your data in the development database as
    you run your tests.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Test database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that all of our Todo routes are set up and tested, in this final section
    we're going to be exploring how to create a separate Test database for our application.
    That means when we run the test suite we're not going to be deleting all of the
    data inside of our `TodoApp` database. We will have a separate database alongside
    of `Test` and `TodoApp`, used for the testing DB.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, in order to set all that up we need a way to differentiate between running
    our app locally and running our test suite locally, and that''s exactly where
    we''re going to start. This whole issue stems from the fact that in our `mongoose.js`
    file we either use the `MONGODB_URI` environment variable or we use the URL string.
    This string is used for both testing and for development, and when I say testing
    I mean when we run our `test` script, and when I say development I mean when we
    run our app locally so we can use it inside of tools like Postman. What we really
    need is a way to set environment variables locally as well, so we always use the
    `MONGODB_URI` variable and we never have a default string like the one we have
    in the `mongoose.js` file. Now, in order to get that done we''re going to look
    at an environment variable that''s actually pretty special: it''s `process.env.NODE_ENV`
    and you don''t have to write this code. I''m going to be deleting it in just a
    moment. This `NODE_ENV` environment variable was made popular by the Express library
    but it now has been adopted by pretty much any Node-hosting company. For example,
    Heroku sets this value equal to the string `production` by default. That means
    that we''re going to have three environments total. We already have a `production`
    environment. This is what we call our app on Heroku; we''re going to have a `development`
    environment when we run our app locally, and we''ll have a `test` environment
    when we run our app through Mocha. This means we''ll be able to set up a different
    value for `MONGODB_URI` for all three of those, creating a separate test database.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To kick things off we''re going to add some code in the `server.js` file up
    at the very top. We''ll be moving this code out of `server.js` a little bit later,
    but for now we''re going to tack it at the top. Let''s make a variable called
    `env` and we''re going to set it equal to `process.env.NODE_ENV`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, this variable currently is only set on Heroku; we don''t have this environment
    variable set locally. Environment variables in general are used for much more
    than just Node. Your machine has probably close to two dozen environment variables,
    telling the computer all sorts of things: where certain programs exist, what versions
    of libraries you want to use, that sort of stuff. The `NODE_ENV` variable, however,
    is something that we''re going to need to configure inside of our `package.json`
    file for our development and test environments. Then, just down below, we''ll
    be able to add some `if else` statements to configure our app depending on the
    environment. If we''re in development we''ll use one database, if we''re in test
    we''ll use a different one. Now to kick things off inside of `package.json` we
    are going to need to tweak the `test` script, setting the `NODE_ENV` environment
    variable. You can set environment variables by chaining together multiple commands.
    The code we''re about to write is going to have a fallback for Windows as well,
    so you can write the exact same line if you''re on macOS, Linux, or Windows. This
    is going to work everywhere, including Heroku. The goal here is to just set `NODE_ENV`
    equal to `test` before we run the test suite. In order to do that we''re going
    to start by using the `export` command. The `export` command is available in macOS
    and Linux. This is the way to get it done, type this even if you''re in Windows
    because when you deploy to Heroku you are going to be using Linux. We''re going
    to export `NODE_ENV`, setting it equal to `test`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if you''re on Windows, the `export` command is going to fail; `export`
    is going to trigger an error, something along the lines of export command not
    found. For Windows users, we''re going to add this `||` block where we will call
    `SET`. `SET` is the same as export only it''s the Windows version of the command.
    Right after it, we''ll be providing the exact same argument, `NODE_ENV=test`.
    After the final test we''re going to add two ampersands to chain these commands
    together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: So, let's go ahead and break down exactly what's going to happen. If you're
    on Linux, you're going to run the `export` command; the `SET` command is never
    going to run because the first one did. Then we're going to chain on a second
    command, running `mocha`. If you're on Windows, the `export` command is going
    to fail, which means you will run the second command; either way you get the `NODE_ENV`
    variable set, then finally you'll chain on a call to `mocha`. With this in place,
    we now have a way to set our `NODE_ENV` variable right inside a `package.json`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a quick cross-OS update; as you can see here, we have a modified version
    of that `test` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '`"test": "export NODE_ENV=test || SET \"NODE_ENV=test\" && mocha server/**/*.test.js"`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The original test script had a problem on the Windows side of things: it would
    set the environment variable equal to the string test with a space at the end,
    as opposed to just the string `test`. In order to properly set the `env` variable
    to just `test`, and not `test`, we''re going to be wrapping the entire set argument
    inside of quotes, and we''re escaping those quotes since we use quotes inside
    of our JSON file. This command is going to work on Linux, macOS, and Windows.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now I''m actually not going to add a `start` script for `scripts`. The `start`
    script, which is for the development environment, will just be the default. We''ll
    have it set to production on Heroku, we''ll have it set to `test` inside of our
    `test` script, and in the case of this script we''ll just default it inside of
    `server.js` because we tend to run the file without actually going through the
    `start` script. Right in the `server.js` file, I''ll set a default to `development`.
    If we''re on production, `NODE_ENV` is going to be set, if we''re on test, `development`
    is going to be set, and if we''re on development, `NODE_ENV` won''t be set and
    `development` will be used, which means we are ready to add some `if` statements.
    `if(env)` is `development` we want to do something. The thing we want to do is
    set up the MongoDB URL. `else if (env)` is the `test` environment. In that case
    we also want to set up a custom database URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can go ahead and actually set up our environment variables. We have
    two environment variables being used throughout the app, both of which are set
    on Heroku, so there''s no reason to worry about that environment, the production
    environment. We have our `PORT` environment variable, and we have our `MONGODB_URI`
    variable. Over inside of `server.js`, if we are in the development environment,
    we''re going to go ahead and set `process.env.PORT=3000`. This means that we can
    actually remove the default from the `port` variable; there''s no need to have
    a default because `PORT` is already going to be set. It''ll be set on Heroku for
    production, it''ll be set locally for `development`, and right in the `else if`
    block we''ll set it for our final environment, the test environment, setting it
    equal to `3000`. Inside `mongoose.js`, what we''re going to do is set a `MONGODB_URI`
    environment variable for `development` and `test`, which is the exact same name
    for the variable we have on production. I''m going to remove our default, taking
    the string and cutting it out so it''s in my clipboard, then I can remove all
    the excess code for setting that default, and what we''re left with is just a
    reference to the environment variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Over inside of `server.js` we can now set that environment variable for both
    environments, `process.env.MONGODB_URI`, and we're going to set that equal to
    the string I just copied, `mongodb://localhost:27017/TodoApp`. We are using the
    `TodoApp` database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, down below in the `else if` block, we can set `process.env.MONGODB_URI`
    equal to the string we just copied, but instead of setting it equal to the `TodoApp`
    database, we''re going to set it equal to the `TodoAppTest` database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run our application in test mode, we''re going to be using a completely
    different database, so it''s not going to wipe the database that we''re using
    for development. To test that everything is working as expected, right below the
    `env` variable all I''m going to do is log out of the environment variable using
    `console.log`. I''m going to print the string `env` with a couple of asterisks
    so it''s easy to spot in the Terminal output, and then I''ll go ahead and pass
    the `env` variable in as the second argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can go ahead and test that everything is working as expected. Over inside
    of the Terminal I''m going to start up our app using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'We get an `env` equal to `development`, which is exactly what we''d expect:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fe710e73-932e-4ea9-aca3-636d2fc4611b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'And now we can play around with it in Postman. Over inside of Postman I''m
    going to switch to my Local environment, Todo App Local, then I''m going to go
    ahead and fetch all of my Todos, and you can see we have some leftover test data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f3e33401-f769-49cf-898a-1fb19f534bf1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'What I want to do is go ahead and tweak this first one so it''s different.
    Then we''ll run our tests and make sure that the tweaked Todo still shows up,
    because when we run the tests we shouldn''t be accessing the same database, so
    none of this data should get changed. I''m going to copy the id for the first
    item, moving it into my `PATCH` call. I''m updating the `text` property and the
    `completed` property, so that''s good, I don''t need to change that. I''m going
    to go ahead and swap out the ID in the URL, send off the call, and now we have
    the updated Todo with the `text` property of `Updates from postman`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ab22622f-3104-4e9e-a66b-a3a230dc96a3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next up, I''m going to go into the Terminal, shut down node server, and run
    our tests using `npm test`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3e10b405-a47c-4baa-b08b-b5702220d4a3.png)'
  prefs: []
  type: TYPE_IMG
- en: We get our `env` variable set to `test`, then it runs through the test suite;
    all of our tests pass, which is fantastic. The true test as to whether or not
    what we set up works is if we start up the server again and we try to fetch our
    data from the `development` database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Over inside of Postman I''m going to make that `GET /todos` request one last
    time and right there our Todo data still shows up as expected. Even though the
    test suite did run, it didn''t matter because it''s not wiping this database anymore,
    it''s now wiping a brand new database you can view in Robomongo. If I click the
    connection and click Refresh, we now have two `TodoApp` databases: we have `TodoApp`
    and we have `TodoAppTest`. This is fantastic; everything is set up and we are
    ready to get rolling.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now what I do want to do before we go is take all of this code out of `server.js`
    and move it somewhere else; it doesn''t really belong here and it only makes the
    server file more complex than it needs to be. In the `server` folder, I''m going
    to make a brand new folder called `config`, and in the `config` folder I''ll make
    a new file called `config.js`, and inside we can do all of that process environment
    variable configuration. I''m going to copy all of the code and replace it with
    a `require` call to that file. It''s a relative file so we''ll go to `/config/config`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Inside of `config.js` we can now copy the code in and remove the line related
    to `console.log`. Let's wrap this section up by committing our changes and deploying
    to Heroku.
  prefs: []
  type: TYPE_NORMAL
- en: 'Over inside of the Terminal I''m going to clear the Terminal output, then we
    can go ahead and run `git status` to see what files we have changed, and we have
    quite a few:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a5e2bfee-c91b-4d80-a530-2e908b981b26.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We also have some new files in the `server` directory. I''m going to use `git
    add .` to add all of that to the next commit and I''ll use `git status` again
    to confirm everything looks good. Now we''re ready for the commit and I can go
    ahead and do that, `git commit` with the `-m` flag providing our message, `Setup
    separate test and development envs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'And I''m also going to deploy it to Heroku so we can verify we haven''t broken
    anything there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Once this is done we''ll wrap the section up by heading into Postman and making
    a `GET /todos` request to our Heroku application. Over inside of Postman I''m
    going to switch environments from Todo App Local to Todo App Heroku and we can
    fire off the request:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eac61e9b-7445-4495-8747-d1ae04f00551.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, as shown in the preceding screenshot, we get our two `todo` items coming
    from the real database, which means nothing was broken on the Heroku application,
    and it shouldn't be—technically we haven't changed anything. In Heroku, all we're
    doing is we're running the `config` file, but we don't use the default because
    it's already set, and it's not going to pass any of those statements because the
    `env` variable is going to be equal to the string production, so as far as Heroku
    is concerned, nothing has changed, and it's showing that because the data is still
    coming back as expected.
  prefs: []
  type: TYPE_NORMAL
- en: That is it for this section, and that is it for this chapter. In this section,
    we learned about MongoDB, Mongoose APIs, Postman, testing, routes, all sorts of
    great features. In the next chapter, we're going to wrap up the Todo application
    by adding authentication.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we worked on learning Mongoose queries and ID validation. Next,
    we looked into getting an individual resources and moved on to take a few challenges.
    After deploying the API to Heroku and exploring the Postman environments, we learnt
    about different methods of deleting a resource. Finally, we looked into creating
    a test database.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about Real-Time Web Apps with Socket.io
  prefs: []
  type: TYPE_NORMAL
