- en: Chapter 4. Creating the Template
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we'll learn how to build a UI template using built-in Angular
    2 directives. You'll become familiar with the template syntax, and how to bind
    properties and events in an HTML page, and transform displays using pipes. Of
    course, we need to discuss the design principles behind Angular 2.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end of the chapter, you will have a solid understanding of:'
  prefs: []
  type: TYPE_NORMAL
- en: Template expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Various binding types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Input and output properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using built-in directives
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Local template variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pipe and Elvis operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom pipes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design components of our application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Diving deeper into Angular 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've read three chapters and haven't touched Angular 2 yet. I think it's time
    to invite Angular 2 on stage to demonstrate how this framework can help us in
    creating components for our project. As I mentioned in [Chapter 1](text00014.html#ch01
    "Chapter 1. Saying Hello!") , *Saying Hello!* , the architecture of Angular 2
    builds on top of standard web components so we can define custom HTML selectors
    and program them. That means we can create a set of Angular 2 elements to use
    in the project. In previous chapters, we designed and developed two pages, and
    you can find many repetitive markups so that we can reuse our Angular 2 components
    there as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s, start:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the Terminal, create the folder `ecommerce` and move in
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copy the contents of the project from the folder `chapter_4/1.ecommerce-seed`
    into the new project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Run the following script to install `npm` modules:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Start the TypeScript watcher and lite server with the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This script opens the web browser and navigates to the welcome page of the project.
    Now open Microsoft Visual Studio code and open `app.component.html` from the `app`
    folder. We are ready to analyze the welcome page.
  prefs: []
  type: TYPE_NORMAL
- en: Welcome page analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The welcome page has quite a simple structure, so I would like to create the
    following Angular 2 components to encapsulate inside the current markup and future
    business logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Navbar` with menus'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Slideshow based on the carousel Bootstrap component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Grid of Products based on the card Bootstrap component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I will follow the Angular 2 *Style Guide* ([https://angular.io/docs/ts/latest/guide/style-guide.html](https://angular.io/docs/ts/latest/guide/style-guide.html)
    ) while developing our project to keep our application code cleaner, and easy
    to read and maintain. I recommend following my example on your plans, otherwise,
    the development results could be unpredictable and extremely costly.
  prefs: []
  type: TYPE_NORMAL
- en: Single responsibility principle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will apply the **single responsibility principle** to all aspects of the
    project, so whenever we need to create a component or service, we will create
    the new file for it and try to keep inside maximum 400 lines of code. The benefits
    of keeping one component per file are evident:'
  prefs: []
  type: TYPE_NORMAL
- en: Makes code more reusable and less error prone
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easy to read, test and maintain
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prevents collisions with team in source control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoids unwanted code coupling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The component router can lazily load it at runtime
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Naming conventions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is no secret that **naming conventions** are crucial to readability and
    maintainability. The ability to find files and understand what they contain may
    have a significant impact on future development, so we should be consistent and
    descriptive in naming and organizing files to find content at a glance. The conventions
    comprise the following rules:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The recommended pattern for all features describes the name then its type:
    `feature.type.ts`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The words in descriptive name should be separated by dashes: `feature-list.type.ts`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are well-known types of names including `service` , `component` , `directive`
    , and `pipe: feature-list.service.ts`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Barrels
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are barrel modules—TypeScript files that import, aggregate, and re-export
    other modules. They have one purpose—to reduce the number of `import` statements
    in code. They provide a consistent pattern introducing everything that is exported
    in the barrel from a folder. The conventional name for this file is `index.ts`
    .
  prefs: []
  type: TYPE_NORMAL
- en: Application structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We keep application code in the `app` folder. For easy and quick access to files,
    it is recommended to maintain a flat folder structure for as long as possible
    until there is clear value in creating a new folder.
  prefs: []
  type: TYPE_NORMAL
- en: Folders-by-feature structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For small projects, you can save all files in the `app` folder. Our project
    has many features, so we put each of them in their folders, including TypeScript,
    HTML, Style Sheet, and Spec files. The name of each folder represents the feature
    it has.
  prefs: []
  type: TYPE_NORMAL
- en: Shared folder
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are some features we can use in multiple places. Better move them into
    the `shared` folder and separate them into folders if necessary. If features exist
    in your project, define the overall layout to save them here as well.
  prefs: []
  type: TYPE_NORMAL
- en: Navigation component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is a navigation component needed for the entire application, so we need
    to create files `navbar.component.ts` and `navbar.component.html` into the `navbar`
    folder. Here is the folder structure of our project as it stands now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Navigation component](Image00097.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Open the `navbar.component.ts` file and paste the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the code, we just defined the `NavbarComponent` class with a `@Component`
    decorator to tell Angular that the class, which it attached to, is a component.
    We use an `import` statement here to specify the module, where the TypeScript
    compiler can find the `@Component` decorator.
  prefs: []
  type: TYPE_NORMAL
- en: Decorators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The decorators are a proposed standard for ECMAScript 2016 and available as
    a crucial part of TypeScript defining a reusable structural pattern. Each decorator
    follows the form of `@expression` . The `expression` is a function that evaluates
    at runtime with information about the decorated statement to change the behavior
    and state of it. We can use a **decorator function** , which returns as a result
    of evaluation of the `expression` , to customize how decorator applies to a declaration.
    It is possible to attach one or multiple decorators to any class, method, accessor,
    property, or parameter declarations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `@Component` is a class decorator applied at compile time to the constructor
    of `NavbarComponent` class for the following purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: To modify the class definition with a set of parameters passing through
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To add proposed methods organizing the component lifecycle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We must define the `selector` parameter for every `@Component` decorator and
    use `kebab-case` for naming it. The *style guide* recommends identifying components
    as elements via the `selector` because it provides consistency for components
    that represent the content with a template. I use the `db-navbar` selector name
    for `NavigationComponent` as a combination of:'
  prefs: []
  type: TYPE_NORMAL
- en: The `db` prefix displays the Dream Bean company name abbreviations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `navbar` as the name of the feature
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Always use the prefix for selector names to prevent name collision with components
    from other libraries.
  prefs: []
  type: TYPE_NORMAL
- en: 'The template is a required part of the `@Component` decorator because we associate
    it with putting content on the page. You can supply the `template` as an inline
    string in the code or `templateUrl` as an external resource. It is better to keep
    the content of the template as an external resource:'
  prefs: []
  type: TYPE_NORMAL
- en: When it has more than three lines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because some editors do not support the syntax hints for inline templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As it is easier to read the logic of a component when not mixed with inline
    templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, open the `app.component.html` and find the `nav` element on the top. Cut
    it with content and paste into `navbar.component.html` and replace it with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need to add the `NavbarComponent` into `AppModule` . Open `app.module.ts`
    to add a reference on `NavbarComponent` there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Tree of components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Every Angular application has a top level element to display the content. In
    our application, it is an `AppComponent` . In [Chapter 3](text00058.html#page
    "Chapter 6. Dependency Injection") , *Advanced Bootstrap Components and Customization*
    , we split the welcome page into Bootstrap components, now we move them into separate
    modules, and compose them back with the help of an Angular framework. The Angular
    framework renders an application as a tree of components, from a top level element,
    its children, and further down. When we need to add a child to any component,
    we register it via the `declarations` property of Angular module. The `NavigatorComponent`
    does not belong to any Angular feature module, so I register it in the top most
    module which is the `AppModule` .
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s come back to the `navbar.component.html` to find other repetitive elements.
    In the place where we display the navigation bar we have navigation items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Because we have duplicates in the markup, I propose creating an array of links
    and keeping them inside the `NavbarComponent` as a property, so Angular can display
    them here.
  prefs: []
  type: TYPE_NORMAL
- en: NavItem object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'I suggest you create a separate `NavItem` interface to keep information about
    navigation, because each item should have `href` , `label` , and `active` properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Copy and paste the code in between the top of `NavbarComponent` class and the
    last import statement. Now we can add the `navItems` property into `NavbarComponent`
    which exposes the navigation items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: I add the `appName` property to keep the application name out of the template
    as well. We are ready to use the data binding, but before we do, let's take a
    closer look at template expressions and statements.
  prefs: []
  type: TYPE_NORMAL
- en: Template expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The **template expression** is the central part of data binding. Its primary
    purpose is to execute expressions to produce a value so that Angular can assign
    it to a binding property of an HTML element, directive, or component. We can put
    expressions into the template in two forms:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the interpolation curly braces. Angular first evaluates the content
    inside the braces and then converts to a string: `{{a + 1 - getVal()}}.`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Within the quotes when setting a property of view element to the value of template
    expression: `<button [disabled]="isUnchanged">Disabled</button>.`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The template expression is based on a JavaScript-like language. We can use
    any JavaScript expressions with the following restrictions:'
  prefs: []
  type: TYPE_NORMAL
- en: It is prohibited to use assignments like `=` , `+=` , `-=`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do not use the `new` keyword
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do not create chaining expressions with `;` or `,`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid the use of increment `++` and decrement `--` operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bitwise operators `|` and `&` and new template expression operators `|` and
    `?` are not supported
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Expression context
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The content of template expressions only belongs to the component instance and
    cannot refer to variables or functions in the global context. The component instance
    provides everything the template expression can use. It is usually the context
    of the expression but can include objects other than components, like a template
    reference variable.
  prefs: []
  type: TYPE_NORMAL
- en: Template reference variable
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The **template reference variable** is a reference to a DOM element or directive
    within a template. You can use it as a variable with any native DOM element and
    Angular 2 component. We can reference it on someone, on a sibling or any child
    elements. There are two forms in which we can define it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Within prefix hash (`#` ) and variable name:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The canonical alternative with `ref-` prefix and variable name:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In both places, the variable `product` passes its `value` to the `findProduct`
    method. The `(click)` is the form of data binding, which we will talk about shortly.
  prefs: []
  type: TYPE_NORMAL
- en: Expression guidelines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Authors of the Angular framework recommend following these guidelines in your
    template expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: They should change only the value of the target property. Changes to other application
    states are prohibited.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They must be as quick as possible because they execute more often than other
    code. Consider caching values of computation for better performance when the computation
    is expensive.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Please avoid creating complex template expressions. Usually, you can get value
    from the property or call the method. Move complex logic into the method of the
    component.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Please create idempotent expressions that always return the same thing until
    one of its dependent values changes. It is not allowed to change dependent values
    in the period of the event loop.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Expression operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Template expression language includes a few operators for specific scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: The Elvis operator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are very common situations where the data we want to bind to the view
    is undefined temporarily. Say we render a template and simultaneously fetch data
    from the server. There is a period where the data is unclear since the fetch call
    is asynchronous. As Angular doesn''t know this by default, it throws an error.
    In the following markup we see that the `product` can be equals `null` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The render view may fail with a `null` reference error, or worse yet, entirely
    disappear:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Every time you write markup, you need to analyze it. If you decide that the
    `product` variable must never be `null` , but it is `null` , you find the programming
    error that should be caught and fixed, so this is the reason to throw an exception.
    Contrariwise, a `null` value can be on the property from time to time, since the
    fetch call is asynchronous. In the last case, the view must render without exceptions,
    and the `null` property path must display as blank. We can solve this problem
    in a few ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Include undefined checks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make sure that data always has an initial value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Both of them are useful and have merit but look cumbersome. As an example,
    we can wrap code in `ngIf` and check the existence of `product` variable and its
    properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This code is noteworthy, but it becomes cumbersome and looks ugly especially
    if the path is long. No solution is as elegant as the *Elvis* operator. The Elvis
    or **safe navigation operator** is a convenient way to protect template expression
    evaluation out of `null` or `undefined` exceptions in the property path.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Angular stops expression evaluation when it hits the first null value, displays
    blank, and the application doesn't crash.
  prefs: []
  type: TYPE_NORMAL
- en: The pipe operator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the primary purposes of the template is displaying data. We can show
    the raw data with string values directly to the view. But most of the time we
    need to transform the raw dates into a simple format, add currency symbols to
    raw floats, and so on, so we understand that some values need a bit of message
    before display. I feel like we desire lot of the same transformations in many
    applications. The Angular framework gives us pipes, a way to write display-value
    transformations that we can declare in templates.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pipes are simple functions that accept an input value and return a transformed
    value. We can use them within template expressions, using the pipe operator (`|`
    ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The `uppercase` is a pipe function we placed after the pipe operator. It is
    possible to chain expressions through multiple pipes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Pipe chains always start the transformation from when the first pipe converts
    the product name into `uppercase` , then to `lowercase` . It is possible to pass
    the parameters to a pipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we have a pipe with configuration argument dictates to transform the expiry
    date into the long date format: `August 2, 1969` . There is a list of common pipes
    available in Angular 2:'
  prefs: []
  type: TYPE_NORMAL
- en: The `async`  pipe subscribes to an observable or promise and returns the latest
    value it has emitted.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `date` formats a value to a string based on the requested format.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `i18nSelect` is a generic selector that displays the string that matches
    the current value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`percent` formats a number as a local percent.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`uppercase` implements uppercase transforms to text.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `number` formats a number as local text. i.e. group sizing and the separator
    and other locale-specific configurations base on the active locale.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `json` transforms any input value using `JSON.stringify` . Useful for debugging.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`replace` creates a new string with some or all of the matches of a pattern
    replaced by a replacement.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`currency` formats a number as local currency.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`i18nPlural` maps a value to a string that pluralizes the value correctly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lowercase` transforms text to lowercase.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`slice` creates a new list or string containing only a subset (slice) of the
    elements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The custom pipes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can create a custom pipe similar to `json` for our needs as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Import `Pipe` and `PipeTransform` from the Angular core module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a `JsonPipe` class which implements `PipeTransform`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apply the `@Pipe` decorator to the `JsonPipe` class and give it a name `db-json`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write the `transform` function with input values of `string` type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is the final version of our pipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need a component to demonstrate our pipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Template statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The **template statement** is another important part of data binding. We use
    template statements to respond to an event raised by binding targets like element,
    directive or component. It is based on a JavaScript-like language like the template
    expression, but Angular parses it differently because:'
  prefs: []
  type: TYPE_NORMAL
- en: It supports the basic assignment `=`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It supports chaining expressions with `;` or `,`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Statement context
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The statement expression, like the template expression, can refer only to the
    component instance to which it is a binding event or to a template reference variable.
    You may use reserved `$event` in an event binding statement that represents the
    payload of the raised event.
  prefs: []
  type: TYPE_NORMAL
- en: Statement guidelines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Authors of the Angular framework recommend avoiding creating the complex statement
    expressions. Usually, you can assign a value to the property or call the method.
    Move complex logic into the method of the component.
  prefs: []
  type: TYPE_NORMAL
- en: Data binding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I mentioned **data binding** in [Chapter 1](text00014.html#ch01 "Chapter 1. Saying
    Hello!") , *Saying Hello!* , in passing, but now we dive deeper into this crucial
    tool of the Angular framework. The data binding is the mechanism for updating
    parts of the template with binding markup via properties or methods of a component.
  prefs: []
  type: TYPE_NORMAL
- en: 'The data binding flow supports three directions between data sources and targets
    HTML elements:'
  prefs: []
  type: TYPE_NORMAL
- en: 'One-way binding from the data source to target HTML. This group includes interpolation,
    property, attribute, class, and style binding types:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'One-way binding from the target HTML to the data source. This one is event
    data binding:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Two-way data binding:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The `target` is the directive or component input property that receives data
    from outside. We must explicitly declare any input property before starting to
    use it. There are two ways to do that:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Mark the property with `@Input` decorator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Identify the property as an element of `inputs` array of directive or component
    metadata:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The hosting parent element can use `product` property name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'It is possible to use *alias* for the property to get it a different public
    name from the internal one to meet conventional expectations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now any hosting parent element can use the `bestProduct` property name instead
    of `product` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: HTML attributes versus DOM properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: HTML attributes and DOM properties are not the same thing. We are using HTML
    attributes only to initialize DOM properties, and we cannot change their values
    later.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Template binding works with DOM properties and events, not HTML attributes.
  prefs: []
  type: TYPE_NORMAL
- en: Interpolation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When we need to show the property value of a component on the page we use double
    curly brackets markup to tell Angular how to display it. Let''s update our code
    inside the `navbar.component.html` in such a way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Angular automatically pulls the value of the property `appName` from the `NavbarComponent`
    class and inserts it into the page. When the property changes, the framework updates
    the page. Interpolation is just syntactic sugar to make our life easy. In reality,
    it is one of the forms of property binding.
  prefs: []
  type: TYPE_NORMAL
- en: Property binding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Property binding** is a technique to set the property of an element, component,
    or directive. We can change the preceding markup in this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We can change the classes via the `ngClass` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is how can we change the property of the component or directive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: For the reason that template expressions may contain malicious content, Angular
    sanitizes the values before displaying them. Neither interpolation nor property
    binding allows the HTML with script tags to leak into the web browser.
  prefs: []
  type: TYPE_NORMAL
- en: Attribute binding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are several attributes of an HTML element that do not have corresponding
    DOM properties like `ARIA` , `SVG` , and table span. If you try to write code
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'You will immediately get the following exception because the table data tag
    has a `colspan` attribute, but does not have a `colspan` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'In this particular case, we can use **attribute binding** as part of property
    binding. It uses the prefix `attr` followed by the dot (`.` ) and the name of
    the attribute. Everything else is the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Class binding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Angular provides support for **class binding** . By analogy to attribute binding,
    we use the prefix `class` , optionally followed by a dot (`.` ) and the name of
    a CSS class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We can replace it with binding to a string of the desired class name `meatSpecial`
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Or add the template expression `isSpecial` to evaluate true or false to tell
    Angular to add or remove the `special` class from the target elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Use the **NgClass** directive for managing multiple class names at the same
    time.
  prefs: []
  type: TYPE_NORMAL
- en: Style binding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is possible to manage the styles of the target element via **style binding**
    . We use the prefix `style` , optionally followed by a dot (`.` ) and the name
    of a CSS style property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Use the **NgStyle** directive when setting several inline styles at the same
    time.
  prefs: []
  type: TYPE_NORMAL
- en: The data always flows in one direction in property binding, from the data property
    of the component to the target element. We cannot use property binding to get
    the value from the target element or call a method on the target element. If the
    element raises the events, we can listen to them via an event binding.
  prefs: []
  type: TYPE_NORMAL
- en: Event binding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Any user action on the page generates events, so the authors of Angular framework
    introduced **event binding** . The syntax of this binding is quite simple and
    it consists of a **target event** within the parentheses, equal sign, and a quoted
    template statement. The target event is the name of the event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use the canonical format of event binding if you prefer. It supports
    the prefix `on-` in front of the name without parentheses in such a way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: In cases where the name of an event does not exist on the element or the output
    property is unknown, Angular reports this as an `unknown directive` error.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the information event binding transfers about the event via an **event
    object name** `$event` . Angular uses the target event to determine the shape
    of the `$event` whereby if the DOM element generates an event, the `$event` is
    a DOM event object, and it contains `target` and `target.value` properties. Check
    this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: We define the local variable product and bind the value of the input element
    to its name, and we attach the input event to listen to changes. When the user
    starts to type, the component generates the DOM input event, and the binding executes
    the statement.
  prefs: []
  type: TYPE_NORMAL
- en: Custom events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'JavaScript provides a dozen events for a whole bunch of scenarios out of the
    box, but sometimes we want to fire our own custom events for particular needs.
    It would be good to use them because custom events provide an excellent level
    of decoupling in the application. JavaScript provides `CustomEvent` that does
    all sorts of awesome things, but Angular exposes an `EventEmitter` class we can
    use in *directives* and *components* to emit custom events. What we need to do
    is to create a property of type `EventEmitter` and call the `emit` method to fire
    the event. It is possible to pass in a message payload that can be anything. This
    property regarding Angular works as output because it fires events from the directive
    or component to outside. We must explicitly declare any output property before
    we start to use it. There are two ways to do that:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Mark the property with the `@Output` decorator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Identify the property as an element of `outputs` array of directive or component
    metadata:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'If necessary, we can use *alias* for the property to give it a different public
    name from the internal one to meet conventional expectations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Assume the customer selects the product in the grid of products. We can listen
    to mouse `click` events in markup and handle them in the `browse` method of the
    component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'When the method handles the mouse event, we can fire the custom event with
    the selected `product` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'From now on, any hosting parent component can bind to the `select` event firing
    by the `ProductComponent` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: When the `select` event fires, Angular calls the `productSelected` method in
    the parent component and passes the `Product` in the `$event` variable.
  prefs: []
  type: TYPE_NORMAL
- en: Two-way data binding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Most of the time we need only one-way binding, where data follows from component
    to view or vice verse. Usually, we do not capture input that needs to be applied
    back to the DOM, but in some scenarios, it might be very useful. This is why Angular
    supports **two-way data binding** . As shown previously, we can use the property
    binding to input the data into directive or component properties with the help
    of square brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The opposite direction is denoted by surrounding an event name with parentheses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'We can combine those techniques to have the best of both worlds with the help
    of the `ngModel` directive. There are two forms of two-way data binding:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Where the parentheses go inside the brackets. It is easy to remember as it
    shapes like "banana in a box":'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the canonical prefix `bindon-` :'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: When Angular parses the markup and meets one of these forms, it uses the `ngModel`
    input and `ngModelChange` output to create two-way data binding and hide the details
    behind the scene.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `ngModel` directive only works for HTML elements supported by a `ControlValueAccessor`
    .
  prefs: []
  type: TYPE_NORMAL
- en: We cannot use `ngModel` in a custom component until we implement a suitable
    value accessor.
  prefs: []
  type: TYPE_NORMAL
- en: Built-in directives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Angular has a small number of powerful built-in directives to cover many routine
    operations we need to do in templates.
  prefs: []
  type: TYPE_NORMAL
- en: NgClass
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We use a class binding to add and remove a single class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'In scenarios when we need to manage many classes at once it''s better to use
    the `NgClass` directive. Before use, we need to create a `key:value` control object,
    where the key is a CSS class name and the value is a boolean. If the value is
    `true` , Angular adds the class from the key to the element and if it is `false`
    then it removes it. Here is the method that returns the `key:value` control object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'So, it''s time to add the `NgClass` property and bind it to the `getClasses`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: NgStyle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The style binding helps set inline styles, based on the state of the component.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'If we need to set many inline styles it''s better to use the `NgStyle` directive,
    but before using it we need to create the `key:value` control object. The key
    of the object is the style name, the value is anything appropriated for the particular
    style. Here is the `key:value` control object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s add the `NgStyle` property and bind it to the `getStyles` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: NgIf
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can use different techniques to manage the appearance of elements in DOM.
    One of them uses `hidden` property to hide any unwanted part of the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we bind the `specialName` variable to the HTML `hidden`
    property. Another one uses a built-in directive like `NgIf` to add or remove the
    element from the page entirely:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The difference between hiding and deleting is material. The benefits of invisible
    elements are evident:'
  prefs: []
  type: TYPE_NORMAL
- en: It shows very quickly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It preserves the previous state and is ready to display
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is not necessary to reinitialize
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The side effects of a hidden element are that:'
  prefs: []
  type: TYPE_NORMAL
- en: It still exists on the page and its behavior continues
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It ties up resources, utilizes connections to the backend, etc.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Angular keeps listening to events and checking for changes that could affect
    data bindings and so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `NgIf` directive works differently:'
  prefs: []
  type: TYPE_NORMAL
- en: It removes the component and all children entirely
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removed elements do not utilize resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Angular stops change detection, detaches the element from DOM and destroys it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I recommend you use `ngIf` to remove unwanted components rather than hide them.
  prefs: []
  type: TYPE_NORMAL
- en: NgSwitch
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If we want to display only one element tree from many element trees based on
    some condition, we can use the `NgSwitch` directive. To make it work we need:'
  prefs: []
  type: TYPE_NORMAL
- en: To define a container element which contains the `NgSwitch` directive with a
    switch expression
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define inner elements with a `NgSwitchCase` directive per element
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Establish no more than an item with the `NgSwitchDefault` directive
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `NgSwitch` inserts nested elements based on which match expressions in
    `NgSwitchCase` and which match the value evaluated from the switch expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: If a matching expression is not found, then an element with a `NgSwitchDefault`
    directive is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: NgFor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `NgFor` directive, in contrast to `NgSwitch` , renders each item in the
    collection. We can apply it to simple HTML elements or components with the following
    syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: The text assigned to the `NgFor` directive is not a template expression. It
    is **microsyntax** —the language that Angular interprets how to iterate over the
    collection. Further, Angular translates an instruction into a new set of elements
    and bindings. The `NgFor` directive iterates over the `products` array to return
    the instance of the `Product` and stamps out instances of the DIV element to which
    it is applied. The `let` keyword in an expression creates a *template input variable*
    called the `product` , available in the scope of host and its children elements,
    so we can use its properties like we are doing in interpolation `{{product.name}}`
    .
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A template input variable is neither the template nor the state reference variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes it can be useful to know a bit more about the currently iterated
    element. The `NgFor` directive provides several exported index-like values:'
  prefs: []
  type: TYPE_NORMAL
- en: The `index` value sets to the current loop iteration from 0 to the length of
    collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `first` is the boolean value indicating whether the item is the first in
    the iteration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `last` is the boolean value indicating whether the item is the last one
    in the collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `even` is the boolean value indicating whether the item has an even index
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `odd` is the boolean value indicating whether the item has an odd index
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So we can use any of those values to capture one in a local variable and use
    it inside an iteration context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s imagine an array of products we query from the backend. Each refresh
    operation returns the list containing some, if not all, of the number of changed
    items. Because Angular doesn''t know about changes, it discards the old DOM elements
    and rebuilds a new list with new DOM elements. With a huge number of items in
    the list, the `NgFor` directive can perform poorly, freeze the UI, and make a
    web application entirely unresponsive. We can fix the problem if we give Angular
    a function to track items inside the collection, and so avoid this DOM rebuild
    nightmare. The tracking relies on object identity so that we can use any one or
    many properties to compare new and old items inside the collection. The term *object
    identity* refers to object equality based on the  `===` identity operator. Here
    is an example of track by the ID property of product:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Hence, we can use the tracking function such that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s time to add the tracking function to the `NgFor` directive expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: The tracking function cannot remove the DOM changes but it can reduce the number
    of them and make the UI smoother and more responsive.
  prefs: []
  type: TYPE_NORMAL
- en: 读累了记得休息一会哦~
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**公众号：古德猫宁李**'
  prefs: []
  type: TYPE_NORMAL
- en: 电子书搜索下载
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 书单分享
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 书友学习交流
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**网站：**[沉金书屋 https://www.chenjin5.com](https://www.chenjin5.com)'
  prefs: []
  type: TYPE_NORMAL
- en: 电子书搜索下载
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 电子书打包资源分享
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 学习资源分享
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Structural directives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We quite often see the asterisk prefix in built-in directives, but I haven't
    explain the purpose. It's time to unveil the *secret* Angular developers keep
    from us.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are developing single page applications and at some time, we end up with
    the necessity to manipulate DOM efficiently. The Angular framework helps with
    appearing and disappearing portions of the page according to the application state
    with several built-in directives. In general, Angular has three kinds of directives:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Component** : This is a directive with a template, and we will create a lot
    of them in our project.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Attribute directive:** This kind of directive changes the appearance or behavior
    of an element.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Structural directive** : This changes the DOM layout by adding or removing
    DOM elements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Structural directives use the HTML 5 `template` tag to manage the appearance
    of components on the page. Templates allow the declaration of fragments of HTML
    markup as prototypes. We can insert them into the page anywhere—the head, body,
    or frameset, but without display:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'To use the template we must clone and insert it into the DOM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Angular keeps the content of structural directives in the `template` tag, replaces
    it with a `script` tag, and uses it when it is necessary. Because the template
    form is verbose, the Angular developers introduced the **syntactic sugar** —asterisk
    (`*` ) prefix for directives to hide verbosity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'When Angular reads and parses the above HTML markup, it replaces the asterisk
    back to template form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Custom structural directive
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s create the structural directive similar to `NgIf` that we can use to
    display the content on the page dependent on the condition. Open the project in
    Microsoft Studio Code and create `if.directive.ts` file with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'We import `Directive` to apply it to the `IfDirective` class. We can use our
    directive in any HTML element or component as a property. Because we manipulate
    it with the content of the template, we need `TemplateRef` . Moreover, Angular
    uses a special renderer `ViewContainerRef` to render the content of template,
    so we need to import both of them and inject them into constructor as private
    variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'And lastly, the property to keep the boolean condition so that the directive
    adds or removes the template based on that value: it must have the same name as
    the directive, plus we can make it read-only:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'If the `condition` is `true` , the preceding code calls the view container
    to create an embedded view that references the template content, or otherwise,
    removes it. Here is the final version of our directive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Now we can add our directive into the `directives` array of the host component
    to use it instead of `NgIf` .
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can find the source code at `chapter_4/2.ecommerce-navbar` .
  prefs: []
  type: TYPE_NORMAL
- en: Category product component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will continue to create Angular components for our application. Now, we
    know everything about templates, it''s time to create the `Category` product.
    Let''s create the `category` directory and the file `category.ts` . Copy and paste
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'So, each category of product has a unique identifier, title, description, and
    image. Now create the file `category-card.component.ts` , copy and paste the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a Category component that we use in a grid of categories. It has the
    input property `category` and output event `select` . Let''s have a look at what
    the markup looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'It is an exact copy of the markup from `app.component.html` . We use interpolation
    data binding everywhere. Now create `category-slide.component.ts` , copy and paste
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'The source code of this file looks very similar to the card category, but the
    markup is not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'This one is a copy of HTML from the carousel component. It''s time to create
    our first Angular feature module. Create the file `category.module.ts` with the
    following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'As we know, an Angular module is a class decorated with an `NgModule` decorator.
    Let''s see what we are defining with it:'
  prefs: []
  type: TYPE_NORMAL
- en: There are the `CategoryCardComponent` and `CategorySlideComponent` components
    which belong to the module, so we must declare them as well as other components,
    directives, and pipes inside the `declarations` property
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We make the `CategoryCardComponent` and `CategorySlideComponent` components
    available publicly via the `exports` property so that other component templates
    can use them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And lastly, we import the `CommonModule` and `RouterModule` inside the `imports`
    property because we use their components and services in this module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now we can include this module file in other modules or in the application
    module, to make the export available there. Open the `app.module.ts` file and
    update it accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: This change makes the `CategoryCardComponent` and `CategorySlideComponent` components
    available immediately for the application component. I defined two variables `slideCategories`
    and `cardCategories` to keep data for cards in grid and slides.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the changes in `app.component.html` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'We use the `NgFor` directive here with `first` and `index` values to initialize
    the `data-slide-to` attribute and `active` class of the first component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'In this markup, we form the content of carousel images, so we use the `NgFor`
    directive in the `carousel-inner` component. We use the first value to manage
    the active class of the first component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Here are the last changes where we create the cards grid with help of the `NgFor`
    directive.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can find the source code at `chapter_4/3.ecommerce-category` .
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have been speaking about the structure of the Angular application and how
    important it is to maintain a flat folder structure. Because we are following
    the single responsibility principles, we create only one component per file and
    keep it as small as possible. It is best practice for every angular application
    to have a shared folder.
  prefs: []
  type: TYPE_NORMAL
- en: We have spoken a lot about decorators, tree of components, and templates. We
    know that template expressions and template statements are the crucial part of
    data binding. Both of them are based on a restricted version of the JavaScript-like
    language.
  prefs: []
  type: TYPE_NORMAL
- en: Template expression includes the Elvis and pipe operators for specific scenarios.
    Data binding supports three flow directions and includes interpolation, property
    binding, attribute binding, class binding, style binding, event binding, and two-way
    binding.
  prefs: []
  type: TYPE_NORMAL
- en: Angular has several very powerful directives that help us to manipulate DOM
    elements like `NgFor` , `NgIf` , `NgClass` , `NgStyle` , and `NgSwitch` . We learned
    why we use the asterisk prefix and what Structural Directives are.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00047.html#page "Chapter 5. Routing") , *Routing* , we will
    set up the top navigation with Bootstrap. You will become familiar with Angular's
    component router and how to configure it. Plus we will continue to build the project
    that we started to develop in previous chapters.
  prefs: []
  type: TYPE_NORMAL
