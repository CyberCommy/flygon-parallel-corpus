- en: Chapter 4. Creating the Template
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章。创建模板
- en: In this chapter, we'll learn how to build a UI template using built-in Angular
    2 directives. You'll become familiar with the template syntax, and how to bind
    properties and events in an HTML page, and transform displays using pipes. Of
    course, we need to discuss the design principles behind Angular 2.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何使用内置的Angular 2指令构建UI模板。您将熟悉模板语法，以及如何在HTML页面中绑定属性和事件，并使用管道转换显示。当然，我们需要讨论Angular
    2背后的设计原则。
- en: 'At the end of the chapter, you will have a solid understanding of:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将对以下内容有扎实的理解：
- en: Template expressions
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板表达式
- en: Various binding types
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 各种绑定类型
- en: Input and output properties
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入和输出属性
- en: Using built-in directives
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用内置指令
- en: Local template variables
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地模板变量
- en: Pipe and Elvis operators
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管道和Elvis运算符
- en: Custom pipes
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义管道
- en: Design components of our application
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计应用程序的组件
- en: Diving deeper into Angular 2
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入了解Angular 2
- en: We've read three chapters and haven't touched Angular 2 yet. I think it's time
    to invite Angular 2 on stage to demonstrate how this framework can help us in
    creating components for our project. As I mentioned in [Chapter 1](text00014.html#ch01
    "Chapter 1. Saying Hello!") , *Saying Hello!* , the architecture of Angular 2
    builds on top of standard web components so we can define custom HTML selectors
    and program them. That means we can create a set of Angular 2 elements to use
    in the project. In previous chapters, we designed and developed two pages, and
    you can find many repetitive markups so that we can reuse our Angular 2 components
    there as well.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经读了三章，但还没有涉及Angular 2。我认为现在是时候邀请Angular 2上台，演示这个框架如何帮助我们创建项目组件。正如我在[第1章](text00014.html#ch01
    "第1章。说你好！")中提到的，*说你好！*，Angular 2的架构建立在标准Web组件的基础上，因此我们可以定义自定义HTML选择器并对其进行编程。这意味着我们可以创建一组Angular
    2元素来在项目中使用。在之前的章节中，我们设计并开发了两个页面，您可以在那里找到许多重复的标记，因此我们也可以在那里重用我们的Angular 2组件。
- en: 'Let''s, start:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始：
- en: Open the Terminal, create the folder `ecommerce` and move in
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打开终端，创建名为`ecommerce`的文件夹并进入
- en: Copy the contents of the project from the folder `chapter_4/1.ecommerce-seed`
    into the new project
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将项目的内容从文件夹`chapter_4/1.ecommerce-seed`复制到新项目中
- en: 'Run the following script to install `npm` modules:'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行以下脚本以安装`npm`模块：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Start the TypeScript watcher and lite server with the following command:'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用以下命令启动TypeScript监视器和lite服务器：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This script opens the web browser and navigates to the welcome page of the project.
    Now open Microsoft Visual Studio code and open `app.component.html` from the `app`
    folder. We are ready to analyze the welcome page.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本打开Web浏览器并导航到项目的欢迎页面。现在打开Microsoft Visual Studio代码并从`app`文件夹中打开`app.component.html`。我们准备分析欢迎页面。
- en: Welcome page analysis
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 欢迎页面分析
- en: 'The welcome page has quite a simple structure, so I would like to create the
    following Angular 2 components to encapsulate inside the current markup and future
    business logic:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎页面的结构相当简单，因此我想创建以下Angular 2组件，以封装当前标记和未来的业务逻辑：
- en: '`Navbar` with menus'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有菜单的`Navbar`
- en: Slideshow based on the carousel Bootstrap component
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于carousel Bootstrap组件的幻灯片放映
- en: Grid of Products based on the card Bootstrap component
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于card Bootstrap组件的产品网格
- en: I will follow the Angular 2 *Style Guide* ([https://angular.io/docs/ts/latest/guide/style-guide.html](https://angular.io/docs/ts/latest/guide/style-guide.html)
    ) while developing our project to keep our application code cleaner, and easy
    to read and maintain. I recommend following my example on your plans, otherwise,
    the development results could be unpredictable and extremely costly.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发项目时，我将遵循Angular 2 *风格指南*（[https://angular.io/docs/ts/latest/guide/style-guide.html](https://angular.io/docs/ts/latest/guide/style-guide.html)），以使我们的应用代码更清洁、易于阅读和维护。我建议在你的计划中遵循我的示例，否则，开发结果可能是不可预测的，而且成本极高。
- en: Single responsibility principle
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单一职责原则
- en: 'We will apply the **single responsibility principle** to all aspects of the
    project, so whenever we need to create a component or service, we will create
    the new file for it and try to keep inside maximum 400 lines of code. The benefits
    of keeping one component per file are evident:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在项目的所有方面应用**单一职责原则**，因此每当我们需要创建一个组件或服务时，我们将为其创建新文件，并尽量保持在最多400行代码内。保持一个文件中只有一个组件的好处是显而易见的：
- en: Makes code more reusable and less error prone
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使代码更具可重用性，减少错误
- en: Easy to read, test and maintain
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 易于阅读、测试和维护
- en: Prevents collisions with team in source control
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 防止与团队在源代码控制中发生冲突
- en: Avoids unwanted code coupling
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免不必要的代码耦合
- en: The component router can lazily load it at runtime
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件路由可以在运行时进行惰性加载
- en: Naming conventions
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名约定
- en: 'It is no secret that **naming conventions** are crucial to readability and
    maintainability. The ability to find files and understand what they contain may
    have a significant impact on future development, so we should be consistent and
    descriptive in naming and organizing files to find content at a glance. The conventions
    comprise the following rules:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 命名约定对于可读性和可维护性至关重要是公开的。能够找到文件并理解其包含的内容可能会对未来的开发产生重大影响，因此我们应该在命名和组织文件时保持一致和描述性，以便一目了然地找到内容。约定包括以下规则：
- en: 'The recommended pattern for all features describes the name then its type:
    `feature.type.ts`'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有功能的推荐模式描述了名称，然后是其类型：`feature.type.ts`
- en: 'The words in descriptive name should be separated by dashes: `feature-list.type.ts`'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述性名称中的单词应该用破折号分隔：`feature-list.type.ts`
- en: 'There are well-known types of names including `service` , `component` , `directive`
    , and `pipe: feature-list.service.ts`'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其中包括`service`、`component`、`directive`和`pipe`等类型的命名是众所周知的：`feature-list.service.ts`
- en: Barrels
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 桶
- en: There are barrel modules—TypeScript files that import, aggregate, and re-export
    other modules. They have one purpose—to reduce the number of `import` statements
    in code. They provide a consistent pattern introducing everything that is exported
    in the barrel from a folder. The conventional name for this file is `index.ts`
    .
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 有桶模块——导入、聚合和重新导出其他模块的TypeScript文件。它们有一个目的——减少代码中的`import`语句数量。它们提供了一个一致的模式，从一个文件夹中引入桶中导出的所有内容。这个文件的常规名称是`index.ts`。
- en: Application structure
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序结构
- en: We keep application code in the `app` folder. For easy and quick access to files,
    it is recommended to maintain a flat folder structure for as long as possible
    until there is clear value in creating a new folder.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将应用代码保存在`app`文件夹中。为了方便快速访问文件，建议尽可能保持扁平的文件夹结构，直到创建新文件夹有明显的价值为止。
- en: Folders-by-feature structure
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 按功能划分的文件夹结构
- en: For small projects, you can save all files in the `app` folder. Our project
    has many features, so we put each of them in their folders, including TypeScript,
    HTML, Style Sheet, and Spec files. The name of each folder represents the feature
    it has.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 对于小型项目，你可以将所有文件保存在`app`文件夹中。我们的项目有许多功能，所以我们将每个功能放在它们的文件夹中，包括TypeScript、HTML、样式表和规范文件。每个文件夹的名称代表它所具有的功能。
- en: Shared folder
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 共享文件夹
- en: There are some features we can use in multiple places. Better move them into
    the `shared` folder and separate them into folders if necessary. If features exist
    in your project, define the overall layout to save them here as well.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些功能我们可以在多个地方使用。最好将它们移动到`shared`文件夹中，并根据需要将它们分开放置到文件夹中。如果项目中存在功能，请定义整体布局并将其保存在这里。
- en: Navigation component
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导航组件
- en: 'There is a navigation component needed for the entire application, so we need
    to create files `navbar.component.ts` and `navbar.component.html` into the `navbar`
    folder. Here is the folder structure of our project as it stands now:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 整个应用程序需要一个导航组件，因此我们需要在`navbar`文件夹中创建`navbar.component.ts`和`navbar.component.html`文件。以下是我们项目的文件夹结构：
- en: '![Navigation component](Image00097.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![导航组件](Image00097.jpg)'
- en: 'Open the `navbar.component.ts` file and paste the following content:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`navbar.component.ts`文件，并粘贴以下内容：
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the code, we just defined the `NavbarComponent` class with a `@Component`
    decorator to tell Angular that the class, which it attached to, is a component.
    We use an `import` statement here to specify the module, where the TypeScript
    compiler can find the `@Component` decorator.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，我们刚刚使用`@Component`装饰器定义了`NavbarComponent`类，告诉Angular该类是一个组件。我们在这里使用`import`语句来指定模块，TypeScript编译器可以在其中找到`@Component`装饰器。
- en: Decorators
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 装饰器
- en: The decorators are a proposed standard for ECMAScript 2016 and available as
    a crucial part of TypeScript defining a reusable structural pattern. Each decorator
    follows the form of `@expression` . The `expression` is a function that evaluates
    at runtime with information about the decorated statement to change the behavior
    and state of it. We can use a **decorator function** , which returns as a result
    of evaluation of the `expression` , to customize how decorator applies to a declaration.
    It is possible to attach one or multiple decorators to any class, method, accessor,
    property, or parameter declarations.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器是ECMAScript 2016的一个提议标准，并作为TypeScript的一个关键部分，定义了一种可重用的结构模式。每个装饰器都遵循`@expression`的形式。`expression`是一个在运行时评估的函数，提供有关装饰语句的信息，以改变其行为和状态。我们可以使用**装饰器函数**，它作为`expression`的评估结果返回，来自定义装饰器应用于声明的方式。可以将一个或多个装饰器附加到任何类、方法、访问器、属性或参数声明上。
- en: 'The `@Component` is a class decorator applied at compile time to the constructor
    of `NavbarComponent` class for the following purposes:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Component`是一个类装饰器，应用于`NavbarComponent`类的构造函数，用于以下目的：'
- en: To modify the class definition with a set of parameters passing through
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改通过一组参数传递的类定义
- en: To add proposed methods organizing the component lifecycle
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加建议的方法来组织组件的生命周期
- en: 'We must define the `selector` parameter for every `@Component` decorator and
    use `kebab-case` for naming it. The *style guide* recommends identifying components
    as elements via the `selector` because it provides consistency for components
    that represent the content with a template. I use the `db-navbar` selector name
    for `NavigationComponent` as a combination of:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须为每个`@Component`装饰器定义`selector`参数，并使用`kebab-case`进行命名。*样式指南*建议通过`selector`将组件标识为元素，因为这为代表模板内容的组件提供了一致性。我使用`db-navbar`选择器名称来命名`NavigationComponent`，这是一个组合名称。
- en: The `db` prefix displays the Dream Bean company name abbreviations
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '- `db`前缀显示了Dream Bean公司的名称缩写'
- en: The `navbar` as the name of the feature
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`navbar`作为功能的名称'
- en: Note
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Always use the prefix for selector names to prevent name collision with components
    from other libraries.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 始终使用前缀为选择器名称，以防止与其他库中的组件名称冲突。
- en: 'The template is a required part of the `@Component` decorator because we associate
    it with putting content on the page. You can supply the `template` as an inline
    string in the code or `templateUrl` as an external resource. It is better to keep
    the content of the template as an external resource:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 模板是`@Component`装饰器的必需部分，因为我们将其与在页面上放置内容相关联。您可以在代码中提供`template`作为内联字符串或`templateUrl`作为外部资源。最好将模板的内容保留为外部资源：
- en: When it has more than three lines
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当它有超过三行时
- en: Because some editors do not support the syntax hints for inline templates
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为一些编辑器不支持内联模板的语法提示
- en: As it is easier to read the logic of a component when not mixed with inline
    templates
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为不与内联模板混合在一起时，组件的逻辑更容易阅读
- en: 'Now, open the `app.component.html` and find the `nav` element on the top. Cut
    it with content and paste into `navbar.component.html` and replace it with:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打开`app.component.html`，找到顶部的`nav`元素。将其与内容剪切并粘贴到`navbar.component.html`中，并替换为：
- en: '[PRE3]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now we need to add the `NavbarComponent` into `AppModule` . Open `app.module.ts`
    to add a reference on `NavbarComponent` there:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要将`NavbarComponent`添加到`AppModule`中。打开`app.module.ts`，在那里添加对`NavbarComponent`的引用：
- en: '[PRE4]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Tree of components
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组件树
- en: Every Angular application has a top level element to display the content. In
    our application, it is an `AppComponent` . In [Chapter 3](text00058.html#page
    "Chapter 6. Dependency Injection") , *Advanced Bootstrap Components and Customization*
    , we split the welcome page into Bootstrap components, now we move them into separate
    modules, and compose them back with the help of an Angular framework. The Angular
    framework renders an application as a tree of components, from a top level element,
    its children, and further down. When we need to add a child to any component,
    we register it via the `declarations` property of Angular module. The `NavigatorComponent`
    does not belong to any Angular feature module, so I register it in the top most
    module which is the `AppModule` .
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Angular应用程序都有一个顶级元素来显示内容。在我们的应用程序中，它是一个`AppComponent`。在[第3章](text00058.html#page
    "第6章 依赖注入")中，*高级引导组件和自定义*，我们将欢迎页面拆分为引导组件，现在我们将它们移动到单独的模块中，并借助Angular框架将它们组合在一起。Angular框架将应用程序呈现为组件树，从顶级元素、其子级以及更深层次。当我们需要向任何组件添加子级时，我们通过Angular模块的`declarations`属性进行注册。`NavigatorComponent`不属于任何Angular特性模块，因此我在最顶层模块`AppModule`中注册它。
- en: 'Let''s come back to the `navbar.component.html` to find other repetitive elements.
    In the place where we display the navigation bar we have navigation items:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到`navbar.component.html`，找到其他重复的元素。在显示导航栏的地方，我们有导航项：
- en: '[PRE5]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Because we have duplicates in the markup, I propose creating an array of links
    and keeping them inside the `NavbarComponent` as a property, so Angular can display
    them here.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 因为在标记中有重复项，我建议创建一个链接数组并将其保存在`NavbarComponent`中作为属性，这样Angular可以在这里显示它们。
- en: NavItem object
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NavItem对象
- en: 'I suggest you create a separate `NavItem` interface to keep information about
    navigation, because each item should have `href` , `label` , and `active` properties:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议您创建一个单独的`NavItem`接口来保存有关导航的信息，因为每个项目都应该有`href`、`label`和`active`属性：
- en: '[PRE6]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Copy and paste the code in between the top of `NavbarComponent` class and the
    last import statement. Now we can add the `navItems` property into `NavbarComponent`
    which exposes the navigation items:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 复制并粘贴代码到`NavbarComponent`类的顶部和最后一个导入语句之间。现在我们可以将`navItems`属性添加到`NavbarComponent`中，以公开导航项：
- en: '[PRE7]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: I add the `appName` property to keep the application name out of the template
    as well. We are ready to use the data binding, but before we do, let's take a
    closer look at template expressions and statements.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我添加了`appName`属性，以便将应用程序名称从模板中排除。我们已经准备好使用数据绑定，但在这样做之前，让我们更仔细地看一下模板表达式和语句。
- en: Template expressions
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板表达式
- en: 'The **template expression** is the central part of data binding. Its primary
    purpose is to execute expressions to produce a value so that Angular can assign
    it to a binding property of an HTML element, directive, or component. We can put
    expressions into the template in two forms:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**模板表达式**是数据绑定的核心部分。其主要目的是执行表达式以产生一个值，以便Angular可以将其分配给HTML元素、指令或组件的绑定属性。我们可以以两种形式将表达式放入模板中：'
- en: 'Within the interpolation curly braces. Angular first evaluates the content
    inside the braces and then converts to a string: `{{a + 1 - getVal()}}.`'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在插值大括号内。Angular首先评估大括号内的内容，然后转换为字符串：`{{a + 1 - getVal()}}.`
- en: 'Within the quotes when setting a property of view element to the value of template
    expression: `<button [disabled]="isUnchanged">Disabled</button>.`'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在引号内设置视图元素的属性为模板表达式的值时：`<button [disabled]="isUnchanged">Disabled</button>.`
- en: 'The template expression is based on a JavaScript-like language. We can use
    any JavaScript expressions with the following restrictions:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 模板表达式基于类似JavaScript的语言。我们可以使用任何JavaScript表达式，但有以下限制：
- en: It is prohibited to use assignments like `=` , `+=` , `-=`
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 禁止使用`=`，`+=`，`-=`等赋值操作符
- en: Do not use the `new` keyword
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要使用`new`关键字
- en: Do not create chaining expressions with `;` or `,`
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要创建带有`;`或`,`的链式表达式
- en: Avoid the use of increment `++` and decrement `--` operators
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免使用递增`++`和递减`--`运算符
- en: Bitwise operators `|` and `&` and new template expression operators `|` and
    `?` are not supported
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不支持位运算符`|`和`&`以及新的模板表达式运算符`|`和`?`
- en: Expression context
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表达式上下文
- en: The content of template expressions only belongs to the component instance and
    cannot refer to variables or functions in the global context. The component instance
    provides everything the template expression can use. It is usually the context
    of the expression but can include objects other than components, like a template
    reference variable.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 模板表达式的内容仅属于组件实例，不能引用全局上下文中的变量或函数。组件实例提供了模板表达式可以使用的一切。通常是表达式的上下文，但也可以包括除组件以外的对象，如模板引用变量。
- en: Template reference variable
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模板引用变量
- en: 'The **template reference variable** is a reference to a DOM element or directive
    within a template. You can use it as a variable with any native DOM element and
    Angular 2 component. We can reference it on someone, on a sibling or any child
    elements. There are two forms in which we can define it:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**模板引用变量**是模板内的DOM元素或指令的引用。您可以将其用作任何本机DOM元素和Angular 2组件的变量。我们可以在某人、兄弟或任何子元素上引用它。我们可以以两种形式定义它：'
- en: 'Within prefix hash (`#` ) and variable name:'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在前缀哈希(`#`)和变量名内：
- en: '[PRE8]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The canonical alternative with `ref-` prefix and variable name:'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`ref-`前缀和变量名的规范替代：
- en: '[PRE9]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In both places, the variable `product` passes its `value` to the `findProduct`
    method. The `(click)` is the form of data binding, which we will talk about shortly.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个位置，变量`product`将其`value`传递给`findProduct`方法。`(click)`是数据绑定的形式，我们将很快讨论它。
- en: Expression guidelines
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表达式指南
- en: 'Authors of the Angular framework recommend following these guidelines in your
    template expressions:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Angular框架的作者建议在模板表达式中遵循这些指南：
- en: They should change only the value of the target property. Changes to other application
    states are prohibited.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们应该只改变目标属性的值。禁止对其他应用程序状态进行更改。
- en: They must be as quick as possible because they execute more often than other
    code. Consider caching values of computation for better performance when the computation
    is expensive.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们必须尽快执行，因为它们比其他代码执行更频繁。当计算昂贵时，考虑缓存计算值以获得更好的性能。
- en: Please avoid creating complex template expressions. Usually, you can get value
    from the property or call the method. Move complex logic into the method of the
    component.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请避免创建复杂的模板表达式。通常，您可以从属性中获取值或调用方法。将复杂逻辑移到组件的方法中。
- en: Please create idempotent expressions that always return the same thing until
    one of its dependent values changes. It is not allowed to change dependent values
    in the period of the event loop.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请创建幂等表达式，它们总是返回相同的值，直到其中一个依赖值发生变化。在事件循环期间不允许更改依赖值。
- en: Expression operators
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表达式操作符
- en: Template expression language includes a few operators for specific scenarios.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 模板表达式语言包括一些特定场景的操作符。
- en: The Elvis operator
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Elvis操作符
- en: 'There are very common situations where the data we want to bind to the view
    is undefined temporarily. Say we render a template and simultaneously fetch data
    from the server. There is a period where the data is unclear since the fetch call
    is asynchronous. As Angular doesn''t know this by default, it throws an error.
    In the following markup we see that the `product` can be equals `null` :'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 有很常见的情况是，我们想要绑定到视图的数据是暂时未定义的。比如我们渲染一个模板并同时从服务器获取数据。在获取调用是异步的情况下，数据是不确定的。由于Angular默认不知道这一点，它会抛出错误。在下面的标记中，我们看到`product`可能等于`null`：
- en: '[PRE10]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The render view may fail with a `null` reference error, or worse yet, entirely
    disappear:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染视图可能会因为`null`引用错误而失败，或者更糟糕的是完全消失：
- en: '[PRE11]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Every time you write markup, you need to analyze it. If you decide that the
    `product` variable must never be `null` , but it is `null` , you find the programming
    error that should be caught and fixed, so this is the reason to throw an exception.
    Contrariwise, a `null` value can be on the property from time to time, since the
    fetch call is asynchronous. In the last case, the view must render without exceptions,
    and the `null` property path must display as blank. We can solve this problem
    in a few ways:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 每次编写标记时，都需要进行分析。如果您决定`product`变量绝对不应该是`null`，但实际上却是`null`，那么您会发现应该捕获和修复的编程错误，因此这就是抛出异常的原因。相反，`null`值可能会出现在属性中，因为获取调用是异步的。在最后一种情况下，视图必须在没有异常的情况下呈现，并且`null`属性路径必须显示为空白。我们可以通过几种方式解决这个问题：
- en: Include undefined checks
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包括未定义的检查
- en: Make sure that data always has an initial value
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保数据始终具有初始值
- en: 'Both of them are useful and have merit but look cumbersome. As an example,
    we can wrap code in `ngIf` and check the existence of `product` variable and its
    properties:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 它们都很有用并且有价值，但看起来很繁琐。例如，我们可以在`ngIf`中包裹代码，并检查`product`变量及其属性的存在：
- en: '[PRE12]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This code is noteworthy, but it becomes cumbersome and looks ugly especially
    if the path is long. No solution is as elegant as the *Elvis* operator. The Elvis
    or **safe navigation operator** is a convenient way to protect template expression
    evaluation out of `null` or `undefined` exceptions in the property path.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码值得注意，但如果路径很长，它会变得繁琐且难看。没有什么解决方案比*Elvis*操作符更优雅。Elvis或**安全导航操作符**是保护模板表达式在属性路径中避免`null`或`undefined`异常的便捷方式。
- en: '[PRE13]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Angular stops expression evaluation when it hits the first null value, displays
    blank, and the application doesn't crash.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当遇到第一个null值时，Angular停止表达式评估，显示为空白，并且应用程序不会崩溃。
- en: The pipe operator
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 管道操作符
- en: One of the primary purposes of the template is displaying data. We can show
    the raw data with string values directly to the view. But most of the time we
    need to transform the raw dates into a simple format, add currency symbols to
    raw floats, and so on, so we understand that some values need a bit of message
    before display. I feel like we desire lot of the same transformations in many
    applications. The Angular framework gives us pipes, a way to write display-value
    transformations that we can declare in templates.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 模板的主要目的之一是显示数据。我们可以直接将字符串值的原始数据显示到视图中。但大多数时候，我们需要将原始日期转换为简单格式，给原始浮点数添加货币符号，等等，因此我们知道有些值在显示之前需要一点处理。我觉得我们在许多应用程序中都需要相同的转换。Angular
    框架为我们提供了管道，一种在模板中声明的显示值转换的方法。
- en: 'Pipes are simple functions that accept an input value and return a transformed
    value. We can use them within template expressions, using the pipe operator (`|`
    ):'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 管道是简单的函数，接受一个输入值并返回一个转换后的值。我们可以在模板表达式中使用它们，使用管道操作符 (`|`)：
- en: '[PRE14]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `uppercase` is a pipe function we placed after the pipe operator. It is
    possible to chain expressions through multiple pipes:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`uppercase` 是我们放在管道操作符之后的管道函数。可以通过多个管道链接表达式：'
- en: '[PRE15]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Pipe chains always start the transformation from when the first pipe converts
    the product name into `uppercase` , then to `lowercase` . It is possible to pass
    the parameters to a pipe:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 管道链总是从第一个管道将产品名称转换为 `大写` 开始，然后转换为 `小写`。可以向管道传递参数：
- en: '[PRE16]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Here we have a pipe with configuration argument dictates to transform the expiry
    date into the long date format: `August 2, 1969` . There is a list of common pipes
    available in Angular 2:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个带有配置参数的管道，指示将到期日期转换为长日期格式：`1969年8月2日`。Angular 2 中提供了一系列常见的管道：
- en: The `async`  pipe subscribes to an observable or promise and returns the latest
    value it has emitted.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`async` 管道订阅可观察对象或承诺，并返回它发出的最新值。'
- en: The `date` formats a value to a string based on the requested format.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`date` 根据请求的格式将值格式化为字符串。'
- en: The `i18nSelect` is a generic selector that displays the string that matches
    the current value.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`i18nSelect` 是一个通用选择器，显示与当前值匹配的字符串。'
- en: '`percent` formats a number as a local percent.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`percent` 将数字格式化为本地百分比。'
- en: '`uppercase` implements uppercase transforms to text.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`大写` 实现了文本的大写转换。'
- en: The `number` formats a number as local text. i.e. group sizing and the separator
    and other locale-specific configurations base on the active locale.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`number` 将数字格式化为本地文本。即基于活动区域设置的组大小和分隔符等区域特定配置。'
- en: The `json` transforms any input value using `JSON.stringify` . Useful for debugging.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`json` 使用 `JSON.stringify` 转换任何输入值。用于调试。'
- en: '`replace` creates a new string with some or all of the matches of a pattern
    replaced by a replacement.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`replace` 创建一个新字符串，其中某些或所有模式的匹配项被替换为替换项。'
- en: '`currency` formats a number as local currency.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`currency` 将数字格式化为本地货币。'
- en: '`i18nPlural` maps a value to a string that pluralizes the value correctly.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`i18nPlural` 将值映射到正确复数形式的字符串。'
- en: '`lowercase` transforms text to lowercase.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lowercase` 将文本转换为小写。'
- en: '`slice` creates a new list or string containing only a subset (slice) of the
    elements.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`slice` 创建一个只包含元素的子集（切片）的新列表或字符串。'
- en: The custom pipes
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自定义管道
- en: 'We can create a custom pipe similar to `json` for our needs as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以根据需要创建类似于 `json` 的自定义管道，如下所示：
- en: Import `Pipe` and `PipeTransform` from the Angular core module
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 Angular 核心模块导入 `Pipe` 和 `PipeTransform`
- en: Create a `JsonPipe` class which implements `PipeTransform`
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个实现 `PipeTransform` 的 `JsonPipe` 类
- en: Apply the `@Pipe` decorator to the `JsonPipe` class and give it a name `db-json`
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `@Pipe` 装饰器应用到 `JsonPipe` 类，并给它一个名字 `db-json`
- en: Write the `transform` function with input values of `string` type
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `string` 类型的输入值编写 `transform` 函数
- en: 'Here is the final version of our pipe:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们管道的最终版本：
- en: '[PRE17]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now we need a component to demonstrate our pipe:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要一个组件来演示我们的管道：
- en: '[PRE18]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Template statements
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板语句
- en: 'The **template statement** is another important part of data binding. We use
    template statements to respond to an event raised by binding targets like element,
    directive or component. It is based on a JavaScript-like language like the template
    expression, but Angular parses it differently because:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '**模板语句** 是数据绑定的另一个重要部分。我们使用模板语句来响应由绑定目标（如元素、指令或组件）引发的事件。它基于类似 JavaScript 的语言，就像模板表达式一样，但
    Angular 解析方式不同，因为：'
- en: It supports the basic assignment `=`
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它支持基本赋值 `=`
- en: It supports chaining expressions with `;` or `,`
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它支持使用 `;` 或 `,` 连接表达式
- en: Statement context
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 语句上下文
- en: The statement expression, like the template expression, can refer only to the
    component instance to which it is a binding event or to a template reference variable.
    You may use reserved `$event` in an event binding statement that represents the
    payload of the raised event.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 语句表达式，就像模板表达式一样，只能引用绑定事件的组件实例或模板引用变量。您可以在事件绑定语句中使用保留的 `$event`，它表示引发事件的有效负载。
- en: Statement guidelines
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 语句指南
- en: Authors of the Angular framework recommend avoiding creating the complex statement
    expressions. Usually, you can assign a value to the property or call the method.
    Move complex logic into the method of the component.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 框架的作者建议避免创建复杂的语句表达式。通常，您可以为属性分配一个值或调用方法。将复杂逻辑移到组件的方法中。
- en: Data binding
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据绑定
- en: I mentioned **data binding** in [Chapter 1](text00014.html#ch01 "Chapter 1. Saying
    Hello!") , *Saying Hello!* , in passing, but now we dive deeper into this crucial
    tool of the Angular framework. The data binding is the mechanism for updating
    parts of the template with binding markup via properties or methods of a component.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我在[第1章](text00014.html#ch01 "第1章。说你好！") *说你好！* 中简单提到了**数据绑定**，但现在我们要更深入地了解 Angular
    框架的这个关键工具。数据绑定是通过组件的属性或方法更新模板的机制。
- en: 'The data binding flow supports three directions between data sources and targets
    HTML elements:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 数据绑定流支持数据源和目标 HTML 元素之间的三个方向：
- en: 'One-way binding from the data source to target HTML. This group includes interpolation,
    property, attribute, class, and style binding types:'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从数据源到目标 HTML 的单向绑定。这组包括插值、属性、属性、类和样式绑定类型：
- en: '[PRE19]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'One-way binding from the target HTML to the data source. This one is event
    data binding:'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从目标 HTML 到数据源的单向绑定。这是事件数据绑定：
- en: '[PRE20]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Two-way data binding:'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 双向数据绑定：
- en: '[PRE21]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `target` is the directive or component input property that receives data
    from outside. We must explicitly declare any input property before starting to
    use it. There are two ways to do that:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`target` 是指令或组件的输入属性，用于接收外部数据。在开始使用之前，我们必须明确声明任何输入属性。有两种方法可以做到这一点：'
- en: 'Mark the property with `@Input` decorator:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `@Input` 装饰器标记属性：
- en: '[PRE22]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Identify the property as an element of `inputs` array of directive or component
    metadata:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 将属性标识为指令或组件元数据的 `inputs` 数组的元素：
- en: '[PRE23]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The hosting parent element can use `product` property name:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 托管父元素可以使用 `product` 属性名称：
- en: '[PRE24]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'It is possible to use *alias* for the property to get it a different public
    name from the internal one to meet conventional expectations:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 *别名* 为属性获取不同的公共名称，以满足传统的期望：
- en: '[PRE25]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now any hosting parent element can use the `bestProduct` property name instead
    of `product` :'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在任何托管父元素都可以使用 `bestProduct` 属性名称而不是 `product`：
- en: '[PRE26]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: HTML attributes versus DOM properties
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTML 属性与 DOM 属性
- en: HTML attributes and DOM properties are not the same thing. We are using HTML
    attributes only to initialize DOM properties, and we cannot change their values
    later.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Template binding works with DOM properties and events, not HTML attributes.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: Interpolation
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When we need to show the property value of a component on the page we use double
    curly brackets markup to tell Angular how to display it. Let''s update our code
    inside the `navbar.component.html` in such a way:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Angular automatically pulls the value of the property `appName` from the `NavbarComponent`
    class and inserts it into the page. When the property changes, the framework updates
    the page. Interpolation is just syntactic sugar to make our life easy. In reality,
    it is one of the forms of property binding.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Property binding
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Property binding** is a technique to set the property of an element, component,
    or directive. We can change the preceding markup in this way:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We can change the classes via the `ngClass` property:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Here is how can we change the property of the component or directive:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: For the reason that template expressions may contain malicious content, Angular
    sanitizes the values before displaying them. Neither interpolation nor property
    binding allows the HTML with script tags to leak into the web browser.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Attribute binding
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are several attributes of an HTML element that do not have corresponding
    DOM properties like `ARIA` , `SVG` , and table span. If you try to write code
    like this:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'You will immediately get the following exception because the table data tag
    has a `colspan` attribute, but does not have a `colspan` property:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In this particular case, we can use **attribute binding** as part of property
    binding. It uses the prefix `attr` followed by the dot (`.` ) and the name of
    the attribute. Everything else is the same:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Class binding
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Angular provides support for **class binding** . By analogy to attribute binding,
    we use the prefix `class` , optionally followed by a dot (`.` ) and the name of
    a CSS class.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We can replace it with binding to a string of the desired class name `meatSpecial`
    :'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Or add the template expression `isSpecial` to evaluate true or false to tell
    Angular to add or remove the `special` class from the target elements:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Note
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Use the **NgClass** directive for managing multiple class names at the same
    time.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: Style binding
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is possible to manage the styles of the target element via **style binding**
    . We use the prefix `style` , optionally followed by a dot (`.` ) and the name
    of a CSS style property:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过**样式绑定**管理目标元素的样式。我们使用前缀`style`，可选地跟着一个点(`.`)和CSS样式属性的名称：
- en: '[PRE37]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Note
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Use the **NgStyle** directive when setting several inline styles at the same
    time.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**NgStyle**指令一次设置多个内联样式时。
- en: The data always flows in one direction in property binding, from the data property
    of the component to the target element. We cannot use property binding to get
    the value from the target element or call a method on the target element. If the
    element raises the events, we can listen to them via an event binding.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在属性绑定中，数据始终是单向流动的，从组件的数据属性到目标元素。我们不能使用属性绑定从目标元素获取值或调用目标元素上的方法。如果元素引发事件，我们可以通过事件绑定来监听它们。
- en: Event binding
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件绑定
- en: 'Any user action on the page generates events, so the authors of Angular framework
    introduced **event binding** . The syntax of this binding is quite simple and
    it consists of a **target event** within the parentheses, equal sign, and a quoted
    template statement. The target event is the name of the event:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 页面上的任何用户操作都会生成事件，因此Angular框架的作者引入了**事件绑定**。这种绑定的语法非常简单，由括号内的**目标事件**、等号和带引号的模板语句组成。目标事件是事件的名称：
- en: '[PRE38]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'You can use the canonical format of event binding if you prefer. It supports
    the prefix `on-` in front of the name without parentheses in such a way:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如果愿意，您可以使用事件绑定的规范格式。它支持在名称前面加上`on-`前缀，而不需要括号，如下所示：
- en: '[PRE39]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In cases where the name of an event does not exist on the element or the output
    property is unknown, Angular reports this as an `unknown directive` error.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在事件的名称在元素上不存在或输出属性未知的情况下，Angular会报告这个错误为`未知指令`。
- en: 'We can use the information event binding transfers about the event via an **event
    object name** `$event` . Angular uses the target event to determine the shape
    of the `$event` whereby if the DOM element generates an event, the `$event` is
    a DOM event object, and it contains `target` and `target.value` properties. Check
    this code:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用**事件对象名称**`$event`传递的有关事件的信息。Angular使用目标事件来确定`$event`的形状，如果DOM元素生成事件，则`$event`是一个DOM事件对象，并且它包含`target`和`target.value`属性。检查这段代码：
- en: '[PRE40]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We define the local variable product and bind the value of the input element
    to its name, and we attach the input event to listen to changes. When the user
    starts to type, the component generates the DOM input event, and the binding executes
    the statement.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了局部变量product，并将输入元素的值绑定到其名称，并附加输入事件以侦听更改。当用户开始输入时，组件会生成DOM输入事件，并且绑定会执行该语句。
- en: Custom events
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义事件
- en: 'JavaScript provides a dozen events for a whole bunch of scenarios out of the
    box, but sometimes we want to fire our own custom events for particular needs.
    It would be good to use them because custom events provide an excellent level
    of decoupling in the application. JavaScript provides `CustomEvent` that does
    all sorts of awesome things, but Angular exposes an `EventEmitter` class we can
    use in *directives* and *components* to emit custom events. What we need to do
    is to create a property of type `EventEmitter` and call the `emit` method to fire
    the event. It is possible to pass in a message payload that can be anything. This
    property regarding Angular works as output because it fires events from the directive
    or component to outside. We must explicitly declare any output property before
    we start to use it. There are two ways to do that:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: 'Mark the property with the `@Output` decorator:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Identify the property as an element of `outputs` array of directive or component
    metadata:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'If necessary, we can use *alias* for the property to give it a different public
    name from the internal one to meet conventional expectations:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Assume the customer selects the product in the grid of products. We can listen
    to mouse `click` events in markup and handle them in the `browse` method of the
    component:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'When the method handles the mouse event, we can fire the custom event with
    the selected `product` :'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'From now on, any hosting parent component can bind to the `select` event firing
    by the `ProductComponent` :'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: When the `select` event fires, Angular calls the `productSelected` method in
    the parent component and passes the `Product` in the `$event` variable.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: Two-way data binding
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Most of the time we need only one-way binding, where data follows from component
    to view or vice verse. Usually, we do not capture input that needs to be applied
    back to the DOM, but in some scenarios, it might be very useful. This is why Angular
    supports **two-way data binding** . As shown previously, we can use the property
    binding to input the data into directive or component properties with the help
    of square brackets:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The opposite direction is denoted by surrounding an event name with parentheses:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We can combine those techniques to have the best of both worlds with the help
    of the `ngModel` directive. There are two forms of two-way data binding:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: 'Where the parentheses go inside the brackets. It is easy to remember as it
    shapes like "banana in a box":'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Using the canonical prefix `bindon-` :'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: When Angular parses the markup and meets one of these forms, it uses the `ngModel`
    input and `ngModelChange` output to create two-way data binding and hide the details
    behind the scene.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 当Angular解析标记并遇到这些形式之一时，它使用`ngModel`输入和`ngModelChange`输出来创建双向数据绑定，并隐藏幕后的细节。
- en: Note
  id: totrans-254
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `ngModel` directive only works for HTML elements supported by a `ControlValueAccessor`
    .
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`ngModel`指令仅适用于`ControlValueAccessor`支持的HTML元素。'
- en: We cannot use `ngModel` in a custom component until we implement a suitable
    value accessor.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在自定义组件中无法使用`ngModel`，直到我们实现合适的值访问器。
- en: Built-in directives
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内置指令
- en: Angular has a small number of powerful built-in directives to cover many routine
    operations we need to do in templates.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: Angular具有少量强大的内置指令，可以涵盖我们在模板中需要执行的许多常规操作。
- en: NgClass
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NgClass
- en: 'We use a class binding to add and remove a single class:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用类绑定来添加和移除单个类：
- en: '[PRE51]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'In scenarios when we need to manage many classes at once it''s better to use
    the `NgClass` directive. Before use, we need to create a `key:value` control object,
    where the key is a CSS class name and the value is a boolean. If the value is
    `true` , Angular adds the class from the key to the element and if it is `false`
    then it removes it. Here is the method that returns the `key:value` control object:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在需要同时管理多个类的情况下，最好使用`NgClass`指令。在使用之前，我们需要创建一个`key:value`控制对象，其中键是CSS类名，值是布尔值。如果值为`true`，Angular会将键中的类添加到元素中，如果为`false`，则会将其移除。这是返回`key:value`控制对象的方法：
- en: '[PRE52]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'So, it''s time to add the `NgClass` property and bind it to the `getClasses`
    method:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在是添加`NgClass`属性并将其绑定到`getClasses`方法的时候了：
- en: '[PRE53]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: NgStyle
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NgStyle
- en: The style binding helps set inline styles, based on the state of the component.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 样式绑定有助于根据组件的状态设置内联样式。
- en: '[PRE54]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'If we need to set many inline styles it''s better to use the `NgStyle` directive,
    but before using it we need to create the `key:value` control object. The key
    of the object is the style name, the value is anything appropriated for the particular
    style. Here is the `key:value` control object:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要设置许多内联样式，最好使用`NgStyle`指令，但在使用之前，我们需要创建`key:value`控制对象。对象的键是样式名称，值是适用于特定样式的任何内容。这是`key:value`控制对象：
- en: '[PRE55]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Let''s add the `NgStyle` property and bind it to the `getStyles` method:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加`NgStyle`属性并将其绑定到`getStyles`方法：
- en: '[PRE56]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: NgIf
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NgIf
- en: 'We can use different techniques to manage the appearance of elements in DOM.
    One of them uses `hidden` property to hide any unwanted part of the page:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用不同的技术来管理DOM中元素的外观。其中一种使用`hidden`属性来隐藏页面中任何不需要的部分：
- en: '[PRE57]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'In the preceding code, we bind the `specialName` variable to the HTML `hidden`
    property. Another one uses a built-in directive like `NgIf` to add or remove the
    element from the page entirely:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们将`specialName`变量绑定到HTML的`hidden`属性。另一个方法是使用内置指令如`NgIf`来完全添加或移除页面中的元素：
- en: '[PRE58]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The difference between hiding and deleting is material. The benefits of invisible
    elements are evident:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 隐藏和删除之间的差异是实质性的。不可见元素的好处是显而易见的：
- en: It shows very quickly
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它显示得非常快
- en: It preserves the previous state and is ready to display
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它保留了先前的状态并准备好显示
- en: It is not necessary to reinitialize
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不需要重新初始化
- en: 'The side effects of a hidden element are that:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 隐藏元素的副作用是：
- en: It still exists on the page and its behavior continues
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它仍然存在于页面上，其行为继续
- en: It ties up resources, utilizes connections to the backend, etc.
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它占用资源，利用与后端的连接等
- en: Angular keeps listening to events and checking for changes that could affect
    data bindings and so on
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Angular会持续监听事件并检查可能影响数据绑定等的变化
- en: 'The `NgIf` directive works differently:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '`NgIf`指令的工作方式不同：'
- en: It removes the component and all children entirely
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它完全移除了组件和所有子元素
- en: Removed elements do not utilize resources
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已移除的元素不会占用资源
- en: Angular stops change detection, detaches the element from DOM and destroys it.
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  id: totrans-290
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I recommend you use `ngIf` to remove unwanted components rather than hide them.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: NgSwitch
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If we want to display only one element tree from many element trees based on
    some condition, we can use the `NgSwitch` directive. To make it work we need:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: To define a container element which contains the `NgSwitch` directive with a
    switch expression
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define inner elements with a `NgSwitchCase` directive per element
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Establish no more than an item with the `NgSwitchDefault` directive
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `NgSwitch` inserts nested elements based on which match expressions in
    `NgSwitchCase` and which match the value evaluated from the switch expression:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: If a matching expression is not found, then an element with a `NgSwitchDefault`
    directive is displayed.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: NgFor
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `NgFor` directive, in contrast to `NgSwitch` , renders each item in the
    collection. We can apply it to simple HTML elements or components with the following
    syntax:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The text assigned to the `NgFor` directive is not a template expression. It
    is **microsyntax** —the language that Angular interprets how to iterate over the
    collection. Further, Angular translates an instruction into a new set of elements
    and bindings. The `NgFor` directive iterates over the `products` array to return
    the instance of the `Product` and stamps out instances of the DIV element to which
    it is applied. The `let` keyword in an expression creates a *template input variable*
    called the `product` , available in the scope of host and its children elements,
    so we can use its properties like we are doing in interpolation `{{product.name}}`
    .
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-304
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A template input variable is neither the template nor the state reference variables.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes it can be useful to know a bit more about the currently iterated
    element. The `NgFor` directive provides several exported index-like values:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: The `index` value sets to the current loop iteration from 0 to the length of
    collection
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `first` is the boolean value indicating whether the item is the first in
    the iteration
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `last` is the boolean value indicating whether the item is the last one
    in the collection
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `even` is the boolean value indicating whether the item has an even index
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `odd` is the boolean value indicating whether the item has an odd index
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So we can use any of those values to capture one in a local variable and use
    it inside an iteration context:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Now, let''s imagine an array of products we query from the backend. Each refresh
    operation returns the list containing some, if not all, of the number of changed
    items. Because Angular doesn''t know about changes, it discards the old DOM elements
    and rebuilds a new list with new DOM elements. With a huge number of items in
    the list, the `NgFor` directive can perform poorly, freeze the UI, and make a
    web application entirely unresponsive. We can fix the problem if we give Angular
    a function to track items inside the collection, and so avoid this DOM rebuild
    nightmare. The tracking relies on object identity so that we can use any one or
    many properties to compare new and old items inside the collection. The term *object
    identity* refers to object equality based on the  `===` identity operator. Here
    is an example of track by the ID property of product:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Hence, we can use the tracking function such that:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'It''s time to add the tracking function to the `NgFor` directive expression:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The tracking function cannot remove the DOM changes but it can reduce the number
    of them and make the UI smoother and more responsive.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: 读累了记得休息一会哦~
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**公众号：古德猫宁李**'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: 电子书搜索下载
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 书单分享
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 书友学习交流
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**网站：**[沉金书屋 https://www.chenjin5.com](https://www.chenjin5.com)'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: 电子书搜索下载
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 电子书打包资源分享
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 学习资源分享
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Structural directives
  id: totrans-330
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We quite often see the asterisk prefix in built-in directives, but I haven't
    explain the purpose. It's time to unveil the *secret* Angular developers keep
    from us.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: 'We are developing single page applications and at some time, we end up with
    the necessity to manipulate DOM efficiently. The Angular framework helps with
    appearing and disappearing portions of the page according to the application state
    with several built-in directives. In general, Angular has three kinds of directives:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: '**Component** : This is a directive with a template, and we will create a lot
    of them in our project.'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Attribute directive:** This kind of directive changes the appearance or behavior
    of an element.'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Structural directive** : This changes the DOM layout by adding or removing
    DOM elements.'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Structural directives use the HTML 5 `template` tag to manage the appearance
    of components on the page. Templates allow the declaration of fragments of HTML
    markup as prototypes. We can insert them into the page anywhere—the head, body,
    or frameset, but without display:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'To use the template we must clone and insert it into the DOM:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Angular keeps the content of structural directives in the `template` tag, replaces
    it with a `script` tag, and uses it when it is necessary. Because the template
    form is verbose, the Angular developers introduced the **syntactic sugar** —asterisk
    (`*` ) prefix for directives to hide verbosity:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'When Angular reads and parses the above HTML markup, it replaces the asterisk
    back to template form:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Custom structural directive
  id: totrans-344
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s create the structural directive similar to `NgIf` that we can use to
    display the content on the page dependent on the condition. Open the project in
    Microsoft Studio Code and create `if.directive.ts` file with the following content:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'We import `Directive` to apply it to the `IfDirective` class. We can use our
    directive in any HTML element or component as a property. Because we manipulate
    it with the content of the template, we need `TemplateRef` . Moreover, Angular
    uses a special renderer `ViewContainerRef` to render the content of template,
    so we need to import both of them and inject them into constructor as private
    variables:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'And lastly, the property to keep the boolean condition so that the directive
    adds or removes the template based on that value: it must have the same name as
    the directive, plus we can make it read-only:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'If the `condition` is `true` , the preceding code calls the view container
    to create an embedded view that references the template content, or otherwise,
    removes it. Here is the final version of our directive:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Now we can add our directive into the `directives` array of the host component
    to use it instead of `NgIf` .
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-354
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can find the source code at `chapter_4/2.ecommerce-navbar` .
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: Category product component
  id: totrans-356
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will continue to create Angular components for our application. Now, we
    know everything about templates, it''s time to create the `Category` product.
    Let''s create the `category` directory and the file `category.ts` . Copy and paste
    the following code:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'So, each category of product has a unique identifier, title, description, and
    image. Now create the file `category-card.component.ts` , copy and paste the following
    code:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'This is a Category component that we use in a grid of categories. It has the
    input property `category` and output event `select` . Let''s have a look at what
    the markup looks like:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'It is an exact copy of the markup from `app.component.html` . We use interpolation
    data binding everywhere. Now create `category-slide.component.ts` , copy and paste
    the following code:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The source code of this file looks very similar to the card category, but the
    markup is not:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'This one is a copy of HTML from the carousel component. It''s time to create
    our first Angular feature module. Create the file `category.module.ts` with the
    following content:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'As we know, an Angular module is a class decorated with an `NgModule` decorator.
    Let''s see what we are defining with it:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: There are the `CategoryCardComponent` and `CategorySlideComponent` components
    which belong to the module, so we must declare them as well as other components,
    directives, and pipes inside the `declarations` property
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We make the `CategoryCardComponent` and `CategorySlideComponent` components
    available publicly via the `exports` property so that other component templates
    can use them
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And lastly, we import the `CommonModule` and `RouterModule` inside the `imports`
    property because we use their components and services in this module
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now we can include this module file in other modules or in the application
    module, to make the export available there. Open the `app.module.ts` file and
    update it accordingly:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: This change makes the `CategoryCardComponent` and `CategorySlideComponent` components
    available immediately for the application component. I defined two variables `slideCategories`
    and `cardCategories` to keep data for cards in grid and slides.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the changes in `app.component.html` :'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'We use the `NgFor` directive here with `first` and `index` values to initialize
    the `data-slide-to` attribute and `active` class of the first component:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'In this markup, we form the content of carousel images, so we use the `NgFor`
    directive in the `carousel-inner` component. We use the first value to manage
    the active class of the first component:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Here are the last changes where we create the cards grid with help of the `NgFor`
    directive.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-383
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can find the source code at `chapter_4/3.ecommerce-category` .
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-385
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have been speaking about the structure of the Angular application and how
    important it is to maintain a flat folder structure. Because we are following
    the single responsibility principles, we create only one component per file and
    keep it as small as possible. It is best practice for every angular application
    to have a shared folder.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: We have spoken a lot about decorators, tree of components, and templates. We
    know that template expressions and template statements are the crucial part of
    data binding. Both of them are based on a restricted version of the JavaScript-like
    language.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: Template expression includes the Elvis and pipe operators for specific scenarios.
    Data binding supports three flow directions and includes interpolation, property
    binding, attribute binding, class binding, style binding, event binding, and two-way
    binding.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: Angular has several very powerful directives that help us to manipulate DOM
    elements like `NgFor` , `NgIf` , `NgClass` , `NgStyle` , and `NgSwitch` . We learned
    why we use the asterisk prefix and what Structural Directives are.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 5](text00047.html#page "Chapter 5. Routing") , *Routing* , we will
    set up the top navigation with Bootstrap. You will become familiar with Angular's
    component router and how to configure it. Plus we will continue to build the project
    that we started to develop in previous chapters.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
