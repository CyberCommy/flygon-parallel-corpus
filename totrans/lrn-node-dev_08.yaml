- en: Web Servers in Node
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll cover a ton of exciting stuff in this chapter. We'll learn how to make
    a web server and how to integrate version control into Node applications. Now
    to get all this done, we will look at a framework called Express. It's one of
    the most popular npm libraries, and for good reason. It makes it really easy to
    do stuff such as creating a web server or an HTTP API. It's kind of similar to
    the Dark Sky API we used in the last chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Now most courses start with Express, and that can be confusing because it blurs
    the line between what is Node and what is Express. We'll kick things off by adding
    Express to a brand new Node app.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, we''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Express
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Static server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rendering templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advanced templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Middleware
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing Express
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you'll make your very first Node.js web server, which means
    you'll have a whole new way for users to access your app. Instead of having them
    run it from the Terminal passing in arguments, you'll be able to give them a URL
    they can visit to view your web app or a URL they can make an HTTP request to
    to fetch some data.
  prefs: []
  type: TYPE_NORMAL
- en: This will be similar to what we did when we used the geocode API in the previous
    chapters. Instead of using an API though, we'll be able to create our own. We'll
    also be able to set up a static website for something like a portfolio site. Both
    are really valid use cases. Now all of this will be done using a library called
    **Express**, which is the most popular npm library. It's actually one of the reasons
    that Node got so popular because it was so easy to make REST APIs and static web
    servers.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Express
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Express is a no-nonsense library. Now there are a lot of different ways to configure
    it. So it can get pretty complex. That's why we'll be using it throughout the
    next couple of chapters. To get started, let's make a directory where we can store
    all of the code for this app. This app will be our web server.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the desktop let''s us make a directory called `node-web-server`, by running
    the `mkdir node-web-server` command in the Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a662a1c0-9b49-4917-b238-f538d270a209.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once this directory is created, we''ll navigate into it using `cd`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6e79ccf4-fe81-4cc3-a8ae-5f3562f4c0b1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'And we''ll also open it up inside Atom. In Atom, we''ll open it up from the
    desktop:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9e35a36f-c099-4baa-848d-27aed99c5b2a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now before going further, we''ll run the `npm init` command so we can generate
    the `package.json` file. As shown in the following code, we''ll run `npm init`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3bb36f99-9a07-444b-964e-1082a4c91ba9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, we''ll use the default value just by pressing *enter* through all of
    the options shown in the following screenshot. There''s no need to customize any
    of these as of now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/409f3209-e35c-4464-95f1-c0b6539ddc61.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then we''ll type `yes` in the last statement `Is this ok? (yes)` and the `package.json`
    file goes in place:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cf2525fd-c1cf-4a0b-9431-0784f2bd46f9.png)'
  prefs: []
  type: TYPE_IMG
- en: Express docs website
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As mentioned earlier, Express is a really big library. There''s an entire website
    dedicated to the Express docs. Instead of a simple `README.md` file, you can go
    to [www.expressjs.com](http://expressjs.com/) to view everything the website have
    to offer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/76c08a9b-7416-4ed5-afd9-b62f9f8ecde0.png)'
  prefs: []
  type: TYPE_IMG
- en: We'll find Getting started, help articles, and many more. The website has the Guide option
    to help you do things such as Routing, Debugging, Error handling, and an API reference,
    so we can look into exactly what methods we have access to and what they do. It's
    a very handy website.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Express
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have our `node-web-server` directory, we''ll install Express so
    we can get started making our web server. In the Terminal we''ll run the `clear`
    command first to clear the output. Then we''ll run the `npm install` command.
    The module name is `express` and we''ll be using the latest version, `@4.16.0`.
    We''ll also provide the `save` flag to update the dependencies inside of our `package.json`
    file as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/107b4ff8-819a-4a01-ae06-60b1af04e99e.png)'
  prefs: []
  type: TYPE_IMG
- en: Once again we'll use the `clear` command to clear the Terminal output.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have `Express` installed, we can actually create our web server
    inside Atom. In order to run the server, we will need a file. I''ll call this
    file `server.js`. It will sit right in the root of our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bf797c36-afaf-4e5f-aa29-af9a1d4ae371.png)'
  prefs: []
  type: TYPE_IMG
- en: This is where we'll configure the various routes, things like the root of the
    website, pages like `/about`, and so on. It's also where we'll start the server,
    binding it to a port on our machine. Now we'll be deploying to a real server.
    Later we'll talk about how that works. For now, most of our server examples will
    happen on our localhost.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside `server.js`, the first thing we''ll do is load in Express by making
    a constant called `express` and setting it equal to `require(''express'')`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Next up, what we''ll do is make a new Express app. To do this we''ll make a
    variable called app and we''ll set it equal to the return result from calling
    `express` as a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now there are no arguments we need to pass into `express`. We will do a ton
    of configuration, but that will happen in a different way.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to create an app, all we have to do is call the method. Next to the
    variable `app` we can start setting up all of our HTTP route handlers. For example,
    if someone visits the root of the website we're going to want to send something
    back. Maybe it's some JSON data, maybe it's an HTML page.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can register a handler using `app.get` function. This will let us set up
    a handler for an HTTP get request. There are two arguments we have to pass into
    `app.get`:'
  prefs: []
  type: TYPE_NORMAL
- en: The first argument is going to be a URL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second argument is going to be the function to run; the function that tells
    Express what to send back to the person who made at the request
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In our case we''re looking for the root of the app. So we can just use forward
    slash (`/`) for the first argument. In the second argument, we''ll use a simple
    arrow function (`=>`) as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the arrow function (`=>`) will get called with two arguments. These are
    really important to how Express works:'
  prefs: []
  type: TYPE_NORMAL
- en: The first argument is request (`req`) stores a ton of information about the
    request coming in. Things like the headers that were used, any body information,
    or the method that was made with a request to the path. All of that is stored
    in request.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second argument, respond (`res`), has a bunch of methods available so we
    can respond to the HTTP request in whatever way we like. We can customize what
    data we send back and we could set our HTTP status codes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We''ll explore both of these in detail. For now though, we''ll use one method,
    `res.send`. This will let us respond to the request, sending some data back. In
    `app.get` function, let''s call `res.send`, passing in a string. In the parenthesis
    we''ll add `Hello Express!`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This is the response for the HTTP request. So when someone views the website
    they will see this string. If they make a request from an application, they will
    get back `Hello Express!` as the body data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now at this point we''re not quite done. We have one of our routes set up,
    but the app is never going to actually start listening. What we need to do is
    call `app.listen`. The `app.listen` function will bind the application to a port
    on our machine. In this case for our local host app, we will use port `3000`,
    a really common port for developing locally. Later in the chapter, we''ll talk
    about how to customize this depending on whatever server you use to deploy your
    app to production. For now though, a number like `3000` works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'With this in place we are now done. We have our very first Express server.
    We can actually run things from the Terminal, and view it in the browser. Inside
    the Terminal, we''ll use `nodemon server.js` to start up our app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This will start up the app and you''ll see that the app never really finishes
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/93379da7-8160-4b76-a3f2-f8d4dd461451.png)'
  prefs: []
  type: TYPE_IMG
- en: Right now it's hanging. It's waiting for requests to start coming in. The apps
    that use `app.listen`, they will never stop. You'll have to shut them down manually
    with *control* + *C*, like we've done before. It might crash if you have an error
    in your code. But it'll never stop normally, since we have that binding set up
    here. It will listen to requests until you tell it to stop.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the server is up, we can move into the browser and open up a new tab
    visiting the website, `localhost:` followed by the port `3000`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3cefbc29-a9e1-4959-87bb-6a673b2efa25.png)'
  prefs: []
  type: TYPE_IMG
- en: This will load up the root of the website, and we specify the handler for that
    route. Hello Express! shows up, which is exactly what we expected. Now there's
    no thrills. There's no formatting. We're just sending a string from the server
    back to the client that made the request.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the developer tools in the browser for the app request
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What we''d like to do next is open up the developer tools, so we can explore
    exactly what happened when that request was made. Inside Chrome you can get to
    the Developer Tools using Settings| More Tools| Developer Tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d408ab4a-be5b-4f3f-a06d-5e760c27780d.png)'
  prefs: []
  type: TYPE_IMG
- en: Or you can use the keyboard shortcut shown along with Developer Tools for the
    operating system.
  prefs: []
  type: TYPE_NORMAL
- en: I would highly recommend memorizing that keyboard shortcut because you'll use
    the `Developer Tools` a ton in your career with Node.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll now open up the Developer Tools, which should look similar to the ones
    we used when we ran the Node Inspector debugger. They''re a little different,
    but the idea is the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/54afeb85-d1bd-49b1-8ecb-721dc33b4c82.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We have a bunch of tabs up top, and then we have our tab specific information
    down following on the page. In our case, we want to go to the Network tab, and
    currently we have nothing. So we''ll refresh the page with the tab open, and what
    we see right here is our localhost request:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/82180d8c-58ad-43c9-9dc7-a91b9f2478b2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This is the request that''s responsible for showing Hello Express! to the screen.
    We can actually click the request to view its details:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1e91be78-a106-47a6-9285-94d8720ea76d.png)'
  prefs: []
  type: TYPE_IMG
- en: This page can be a little overwhelming at first. There is a a lot of information.
    Up on top we have some general info, such as the URL that was requested, the method
    that the client wanted; in this case, we made a GET request, and the status code
    that came back. The default status code being 200, meaning that everything went
    great. We'd like to point the attention to is one response header.
  prefs: []
  type: TYPE_NORMAL
- en: Under Response Headers we have a header called Content-Type. This header tells
    the client what type of data came back. Now this could be something like an HTML
    website, some text, or some JSON data and the client could be a web browser, an
    iPhone, an Android device, or any other computer with network capabilities. In
    our case, we're telling the browser that what came back is some HTML, so why don't
    you render it as such. We use the text/html Content-Type. And this automatically
    got set by Express, which is one of the reasons it's so popular. It handles a
    lot of that mundane stuff for us.
  prefs: []
  type: TYPE_NORMAL
- en: Passing HTML to res.send
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have a very basic example, we want to step things up a notch. Inside
    Atom, we can actually provide some HTML right inside of send by wrapping our `Hello
    Express!` message in an `h1` tag. Later in this section, we''ll be setting up
    a static website that has HTML files that get served up. We''ll also look at templating
    to create dynamic web pages. But for now, we can actually just pass in some HTML
    to `res.send`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll save the server file, which should restart things in the browser. When
    we give the browser a refresh, we get Hello Express! printing to the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/95e4efcb-addd-43c0-9878-a0052aaf297a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This time though, we have it in an `h1` tag, which means it''s formatted by
    the default browser styles. In this case it looks nice and big. With this in place
    we can now open up the request inside the Network tab, and what we get is the
    exact same thing we had before. We''re still telling the browser that it''s HTML.
    Only one difference this time: we actually have an HTML tag, so it gets rendered
    using the browser''s default styles.'
  prefs: []
  type: TYPE_NORMAL
- en: Sending JSON data back
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next thing we''d look into is how we can send some JSON data back. Sending
    JSON is really easy with Express. To illustrate how we can do it we''ll comment
    out our current call to `res.send` and add a new one. We''ll call `res.send` passing
    in an object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'On this object we can provide whatever we like. We can create a `name` property,
    setting it equal to the string version of any name, say `Andrew`. We can make
    a property called `likes`, setting it equal to an array, and we can specify some
    things we may like. Let''s add `Biking` as one of them, and then add `Cities`
    as another:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'When we call `res.send` passing in an object, Express notices that. Express
    takes it, converts it into JSON, and sends it back to the browser. When we save
    `server.js` and nodemon refreshes, we can refresh the browser, and what we get
    is my data formatted using JSON view:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/265798fa-1fb0-4233-aac6-d8f51e573ef8.png)'
  prefs: []
  type: TYPE_IMG
- en: This means we can collapse the properties and quickly navigate the JSON data.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a8ab4046-fd65-44d3-bc10-a17341a80e4f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now the only reason JSON view picked up on this is because that Content-Type
    header that we explored in our last request it actually changed. If I open up
    `localhost`, a lot of things look the same. But now Content-Type has an application/json
    Content-Type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d9205712-9724-496a-8c78-e6b6954bae4f.png)'
  prefs: []
  type: TYPE_IMG
- en: This Content-Type tells the requester whether it's an Android phone, an iOS
    device, or the browser that JSON data is coming back, and it should parse it as
    such. That's exactly what the browser does in this case.
  prefs: []
  type: TYPE_NORMAL
- en: 'Express also makes it really easy to set up other routes aside from the root
    route. We can explore that inside Atom by calling `app.get` a second time. We''ll
    call `app.get`. We''ll create a second route. We''ll call this one `about`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that we just used `/about` as the route. It''s important to keep that
    forward slash in place, but after that you can type whatever you like. In this
    case we''ll have a `/about` page that someone can visit. Then I''ll provide the
    handler. The handler will take the `req` and the `res` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This will let us figure out what kind of request came in, and it will let us
    respond to that request. For now just to illustrate we can create more pages,
    we''ll keep the response simple, `res.send`. Inside the string we''re going to
    print `About Page`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now when we save the `server.js` file, the server is going to restart. In the
    browser we can visit `localhost:3000/about`. At `/about` we should now see our
    new data, and that''s exactly what we get back, About Page shows up as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8e3f1986-c5ee-4b56-9984-35ec3ad84fab.png)'
  prefs: []
  type: TYPE_IMG
- en: Using `app.get` we're able to specify as many routes as we like. For now we
    just have an `about` route and a `/` route, which is also referred to as the root
    route. The root route returns some data, which happens to be JSON, and the about
    route returns a little bit of HTML. Now that we have this in place and we have
    a very basic understanding about how we can set up routes in Express, we'd like
    you to create a new route `/bad`. This is going to simulate what happens when
    a request fails.
  prefs: []
  type: TYPE_NORMAL
- en: Error handling in the JSON request
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To show the error handling request with JSON, we''re going to call `app.get`.
    This `app.get` is going to let us register another handler for a get HTTP request.
    In our case the route we''re looking for inside of quotes is going to be `/bad`.
    When someone makes a request for this page, what we want to do is going to be
    specified in the callback. The callback will take our two arguments, `req` and
    `res`. We''ll use an arrow function (`=>`), which I''ve used for all of the handlers
    so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the arrow function (`=>`), we''ll send back some JSON by calling `res.send`.
    But instead of passing in a string, or some string HTML, we''ll pass in an object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our object in place we can specify the properties we want
    to send back. In this case we''ll set one `errorMessage`. We''ll set my error
    message property equal to a string, `Unable to handle request`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Next up we''ll save the file, restarting it in nodemon, and visit it in the
    browser. Make sure our error message showed up correctly. In the browser, we''ll
    visit `/bad`, hit *enter*, and this is what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e824edc3-7898-469e-9ac5-b63ce1f6f5c5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We get our JSON showing up using JSON view. We have our error message, and
    we have the message showing up: Unable to handle request. Now if you are using
    JSON view and you want to view the raw JSON data, you can actually click on View
    source, and it will show it in a new tab. Here, we''re looking at the raw JSON
    data, where everything is wrapped in those double quotes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/db28133e-200d-41d9-a6a3-2ba01543c9ed.png)'
  prefs: []
  type: TYPE_IMG
- en: 'I''ll stick to the JSON view data because it''s a lot easier to navigate and
    view. We now have a very basic Express application up and running. It listens
    on port `3000` and it currently has handlers for 3 URLs: when we get the root
    of the page, when we get `/about`, and when we make a get request for `/bad`.'
  prefs: []
  type: TYPE_NORMAL
- en: The static server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll learn how to set up a static directory. So if we have
    a website with HTML, CSS, JavaScript, and images, we can serve that up without
    needing to provide a custom route for every single file, which would be a real
    burden. Now setting this up is really simple. But before we make any updates to
    `server.js`, we'd create some static assets inside of our project that we can
    actually serve up.
  prefs: []
  type: TYPE_NORMAL
- en: Making an HTML page
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this case we'll make one HTML page that we'll be able to view in the browser.
    Before we get started, we do need to create a new directory, and everything inside
    this directory will be accessible via the web server, so it's important to not
    put anything in here that you don't want prying eyes to see.
  prefs: []
  type: TYPE_NORMAL
- en: 'Everything in the directory should be intended to be view able by anybody.
    We''ll create a public folder to store all of our static assets, and inside here
    we''ll make an HTML page. We''ll create a help page for our example project by
    creating a file called `help.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fafc28c3-1bd3-44e4-b17b-4f38525aa727.png)'
  prefs: []
  type: TYPE_IMG
- en: Now in `help.html` we will make a quick basic HTML file, although we'll not
    touch on all of the subtleties of HTML, since this is not really an HTML book.
    Instead, we'll just set up a basic page.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we need to do is create a `DOCTYPE` which lets the browser
    know what version of HTML we''re using. That will look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'After the opening tag, and the exclamation mark, we''d type `DOCTYPE` in uppercase.
    Then, we provide the actual `DOCTYPE` for HTML5, the latest version. Then we can
    use the greater than sign to close things up. In the next line, we''ll open up
    our `html` tag so we can define our entire HTML file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside `html`, there are two tags we''ll use: the `head` tag which lets us
    configure our doc, and the `body` tag which contains everything we want to render
    to the screen.'
  prefs: []
  type: TYPE_NORMAL
- en: The head tag
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll create the `head` tag first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside `head`, we''ll provide two pieces of info, `charset` and `title` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: First up we have to set up the `charset` which lets the browser know how to
    render our characters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next up we'll provide the `title` tag. The `title` tag lets the browser know
    what to render in that title bar, where the new tab usually is.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As shown in the following code snippet, we''ll set `meta`. And on `meta`, we''ll
    set the `charset` property using equals, and provide the value `utf-8`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'For the `title` tag, we can set it to whatever we like; `Help Page` seems appropriate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The body tag
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that our `head` is configured, we can add something to the body of our
    website. This is the stuff that''s actually going to be viewable inside the viewport.
    Next to the head, we''ll open and close the `body` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside `body` again, we''ll provide two things: an `h1` title and a `p` paragraph
    tag.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The title is going to match the `title` tag we used in the `head`, Help Page,
    and the paragraph will just have some filler text—`Some text here`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Now we have an HTML page and the goal is to be able to serve this page up in
    our Express app without having to manually configure it.
  prefs: []
  type: TYPE_NORMAL
- en: Serving the HTML page in the Express app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll serve our HTML page in the Express app using a piece of Express middleware.
    Middleware lets us configure how our Express application works, and it's something
    we'll use extensively throughout the book. For now, we can think of it kind of
    like a third-party add-on.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to add some middleware, we''ll call `app.use`. The `app.use` takes
    the middleware function we want to use. In our case, we''ll use a built-in piece
    of middleware. So inside `server.js`, next to the variable `app` statement, we''ll
    provide the function off of the `express` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We will be making our own middleware in the next chapter, so it''ll become
    clear exactly what''s getting passed into use in a little bit. For now, we''ll
    pass in `express.static` and to call it as a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now `express.static` takes the absolute path to the folder you want to serve
    up. If we want to be able to serve up `/help`, we''ll need to provide the path
    to the `public` folder. This means we need to specify the path from the root of
    our hard drive, which can be tricky because your projects move around. Luckily
    we have the `__dirname` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the variable that gets passed into our file by the wrapper function
    we explored. The `__dirname` variable stores the path to your projects directory.
    In this case, it stores the path to `node-web-server`. All we have to do is concatenate
    `/public` to tell it to use this directory for our server. We''ll concatenate
    using the plus sign and the string, `/public`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'With this in place, we are now done. We have our server set up and there''s
    nothing else to do. Now we should be able to restart our server and access `/help.html`.
    We should now see the HTML page we have. In the Terminal we can now start the
    app using `nodemon server.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/16d84c8b-973b-49b3-96b7-8cb4546c7269.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once the app is up and running we can visit it in the browser. We''ll start
    by going to `localhost:3000`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cdc5f64a-0aba-48d4-897e-fd0c14f4e71e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here we get our JSON data, which is exactly what we expect. And if we change
    that URL to `/help.html` we should get our Help Page rendering:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/63d0b4c0-6781-4689-93e2-96a4b69adc01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'And that is exactly what we get, we have our Help Page showing to the screen.
    We have the Help Page title as the head, and the Some text here paragraph following
    as body. Being able to set up a static directory that easily has made Node the
    go-to choice for simple projects that don''t really require a backend. If you
    want to create a Node app for the sole purpose of serving up a directory you can
    do it in about four lines of code: the first three lines and the last line in
    the `server.js` file.'
  prefs: []
  type: TYPE_NORMAL
- en: The call to app.listen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now one more thing we''d discuss is the call to `app.listen(3000)`. The `app.listen`
    does take a second argument. It''s optional. It''s a function. This will let us
    do something once the server is up because it can take a little bit of time to
    get started. In our case we''ll assign `console.log` a message: `Server is up
    on port 3000`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now it''s really clear to the person who started the app that the server is
    actually ready to go because the message will print to the screen. If we save
    `server.js`, and go back into the Terminal we can see `Server is up on port 3000`
    prints:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3eb224ed-caec-4a93-ac40-e3e77b73a815.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Back inside the browser we can refresh and we get the exact same results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1340f888-eea5-480e-a997-b060ded511c1.png)'
  prefs: []
  type: TYPE_IMG
- en: That's it for this section. We now have a static directory where we can include
    JavaScript, CSS, images, or any other file types we like.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last couple sections, we looked at multiple ways that we can render HTML
    using Express. We passed some HTML into `response.send`, but obviously that was
    not ideal. It's a real pain to write the markup in a string. We also created a
    public directory where we can have our static HTML files, such as our `help` file,
    and we can serve these up to the browser. Both of those work great but there is
    a third solution, and that will be the topic in this section. The solution is
    a templating engine.
  prefs: []
  type: TYPE_NORMAL
- en: A templating engine will let you render HTML but do it in a dynamic way, where
    we can inject values, such as a username or the current date, inside the template,
    kind of like we would in Ruby or PHP. Using this templating engine, we'll also
    be able to create reusable markup for things such as a header or a footer, which
    is going to be the same on a lot of your pages. This templating engine, handlebars,
    will be the topic of this section and the next, so let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the hbs module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first thing we'll do is install the `hbs` module. This is a handlebars view
    engine for Express. Now there are a ton of other view engines for Express, for
    example EJS or Pug. We'll go with handlebars because its syntax is great. It's
    a great way to get started.
  prefs: []
  type: TYPE_NORMAL
- en: Now we'll see a few things inside of the browser. First up we will visit [handlebarsjs.com](http://handlebarsjs.com/).
    This is the documentation for handlebars. It shows you exactly how to use all
    of its features, so if we want to use anything, we can always go here to learn
    how to use it.
  prefs: []
  type: TYPE_NORMAL
- en: Now we'll install a module that's a wrapper around handlebars. It will let us
    use it as an Express view engine. To view this, we'll go to [npmjs.com/package/hbs](https://www.npmjs.com/package/hbs).
  prefs: []
  type: TYPE_NORMAL
- en: This is the URL structure for all packages. So if you ever want to find a packages
    page, you simply type `npmjs.com/package/ the package name`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This module is pretty popular. It''s a really great view engine. They have
    a lot of documentation. I just want to let you know this exists as well. Now we
    can install and integrate it into our application. In the Terminal, we''ll install
    `hbs` using `npm install`, the module name is `hbs`, and the most recent version
    is `@4.0.1`. I will use the `save` flag to update `package.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/82996805-a5fc-4fbe-9920-db7a0c963951.png)'
  prefs: []
  type: TYPE_IMG
- en: Now actually configuring Express to use this handlebars view engine is super
    simple. All we have to do is import it and add one statement to our Express configuration.
    We'll do just that inside Atom.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring handlebars
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Inside Atom, let''s get started by loading in handlebars `const hbs = require
    hbs`, as shown and from here we can add that one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s call `app.set` where we call `app.use` for Express static:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This lets us set some various Express-related configurations. There''s a lot
    of built-in ones. We''ll be talking about more of them later. For now, about what
    we''ll do is pass in a key-value pair, where the key is the thing you want to
    set and the value is the value you want to use. In this case, the key we''re setting
    is `view engine`. This will tell Express what view engine we''d like to use and
    we''ll pass in inside of quotes `hbs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This is all we need to do to get started.
  prefs: []
  type: TYPE_NORMAL
- en: Our first template
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now in order to create our very first template, what we'd like to do is make
    a directory in the project called `views`. The `views` is the default directory
    that Express uses for your templates. So what we'll do is add the `views` directory
    and then we'll add a template inside it. We'll make a template for our About Page.
  prefs: []
  type: TYPE_NORMAL
- en: Inside views, we'll add a new file and the file name will be `about.hbs`. The
    `hbs` handlebars extension is important. Make sure to include it.
  prefs: []
  type: TYPE_NORMAL
- en: Now Atom already knows how to parse `hbs` files. At the bottom of the `about.hbs`
    file, where it shows the current language it's using, HTML in parentheses mustache.
  prefs: []
  type: TYPE_NORMAL
- en: Mustache is used as the name for this type of handlebars syntax because when
    you type the curly braces (`{`) I guess they kind of look like mustaches.
  prefs: []
  type: TYPE_NORMAL
- en: 'What we''ll do to get started though is take the contents of `help.html` and
    copy it directly. Let''s copy this file so we don''t have to rewrite that boilerplate,
    and we''ll paste it right in the `about.hbs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can try to render this page. We''ll change the `h1` tag from help page
    to about page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We'll talk about how to dynamically render stuff inside this page later. Before
    that we'd like to just get this rendering.
  prefs: []
  type: TYPE_NORMAL
- en: Getting the static page for rendering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Inside `server.js`, we already have a root for `/about`, which means we can
    render our hbs template instead of sending back this about page string. We will
    remove our call to `res.send` and we''ll replace it with `res.render`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Render will let us render any of the templates we have set up with our current
    view engine `about.hbs` file. We do indeed have the about template and we can
    pass that name, `about.hbs`, in as the first and only argument. We''ll render
    `about.hbs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This will be enough to get that static page rendering. We''ll save `server.js`
    and in the Terminal, we''ll clear the output and we''ll run our server using `nodemon
    server.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/212008be-1d6d-4b32-bc02-3864d93dace6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once the server is up and running, it is showing on port `3000`. We can open
    up this `/about` URL and see what we get. We''ll head into Chrome and open up
    `localhost:3000 /about`, and when we do that, we get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f1db99d7-ade4-4a43-8694-2a0e3ee4317d.png)'
  prefs: []
  type: TYPE_IMG
- en: We get my about page rendered just like we'd expect it. We've got an `h1` tag,
    which shows up nice and big, and we have our paragraph tag, which shows up the
    following. So far we have used hbs but we haven't actually used any of its features.
    Right now, we're rendering a dynamic page, so we might as well have not even included
    it. What I want to do is talk about how we can inject data inside of our templates.
  prefs: []
  type: TYPE_NORMAL
- en: Injecting data inside of templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s come up with some things that we want to make dynamic inside our handlebars
    file. First up, we''ll make this `h1` tag dynamic so the page name gets passed
    into the template in `about.hbs` page, and we''ll also add a footer. For now,
    we''ll just make that a simple `footer` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside of the `footer`, we''ll add a paragraph and that paragraph will have
    the copyright for our website. We''ll just say something like copyright followed
    by the year, which is 2018:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Now year should also be dynamic, so that as the years change, we don't have
    to manually update our markup. We'll look at how to make both the 2018 and the
    about page dynamic, which means they're getting passed in instead of being typed
    in the handlebars file.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to do this, we''ll have to do two things:'
  prefs: []
  type: TYPE_NORMAL
- en: We'll have to pass some data into the template. This will be an object a set
    of key value pairs, and
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll have to learn how to pull off some of those key-value pairs inside of
    our handlebars file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Passing in data is pretty simple. All we have to do is specify a second argument
    to `res.render` in `server.js`. This will take an object, and on this object we
    can specify whatever we like. We might have a `pageTitle` that gets set equal
    to `About Page`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We have one piece of data getting injected in the template. It''s not used
    yet but it is indeed getting injected. We could also add another one like `currentYear`.
    We''ll put `currentYear` next to the `pageTitle` and we''ll set `currentYear`
    equal to the actual year off of the date JavaScript constructor. This will look
    something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: We'll create a new date which makes a new instance of the date object. Then,
    we'll use a method called `getFullYear`, which returns the year. In this case,
    it would return `2018`, just like this `.getFullYear`. Now we have a `pageTitle`
    and a `currentYear`. These are both getting passed in, and we can use them.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to use these pieces of data, what we have to do inside of our template
    is use that handlebars syntax which looks a little bit like shown in the following
    code. We start by opening up two curly braces in the `h1` tag, then we close two
    curly braces. Inside the curly braces, we can reference any of the props we passed
    in. In this case, let''s use `pageTitle`, and inside our copyright paragraph,
    we''ll use, inside of double curly braces, `currentYear`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'With this in place, we now have two pieces of dynamic data getting injected
    inside our application. Now nodemon should have restarted in the background, so
    there''s no need to manually do anything there. When we refresh the page, we do
    still get About Page, which is great:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c7fde0ed-6f7e-46af-bb85-696c8299893f.png)'
  prefs: []
  type: TYPE_IMG
- en: This comes from the data we defined in `server.js`, and we get Copyright 2018
    showing up. Well this web page is pretty simple and doesn't look that interesting.
    At least you know how to create those servers and inject that data inside your
    web page. All you have to do from here is add some custom styles to get things
    looking nice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we go ahead, let''s move into the about file and swap out the title.
    Currently, it says `Help Page`. That''s left over from the public folder. Let''s
    change it to `Some Website`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have this in place. Next, we''ll create a brand new template and
    that template is going to get rendered when someone visits the root of our website,
    the `/` route. Now currently, we render some JSON data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: What we want to do is replace this with a call to `response.render`, rendering
    a brand new view.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering the template for the root of the website
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To get started, we''ll duplicate the `about.hbs` file so we can start customizing
    it for our needs. We''ll duplicate it, and call this one `home.hbs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Now from here most things are going to stay the same. We''ll keep the `pageTitle`
    in place. We''ll also keep the `Copyright` and `footer` following. What we want
    to change though is this paragraph. It was fine that the `About Page` as a static
    one, but for the `home` page, we''ll set it equal to, inside curly braces, the
    `welcomeMessage` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Now `welcomeMessage` is only going to be available on `home.hbs`, which is why
    we have specifying it in `home.hbs` but not in `about.hbs`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next up, we needed to call response render inside of the callback. This will
    let us actually render the page. We''ll add `response.render`, passing in the
    template name we want to render. This one is called `home.hbs`. Then we''ll pass
    in our data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Now to get started, we can pass in the page title. We''ll set this equal to
    `Home Page` and we''ll pass in some sort of generic welcome message - `Welcome
    to my website`. Then we''ll pass in the `currentYear`, and we already know how
    to fetch the `currentYear: new Date()`, and on the date object, we''ll call the
    `getFullYear` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'With this in place, all we needed to do is save the file, which is automatically
    going to restart the server using nodemon and refresh the browser. When we do
    that, we get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/068646af-60ac-4dab-bef7-ba1ef545af9f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We get our Home Page title, our Welcome to my website message, and my copyright
    with the year 2018\. And if we go to `/about`, everything still looks great. We
    have our dynamic page title and copyright and we have our static `some text here`
    text:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ca92f075-3fb3-4cc9-91cc-920d441e035c.png)'
  prefs: []
  type: TYPE_IMG
- en: With this in place, we are now done with the very basics of handlebars. We see
    how this can be useful inside of a real-world web app. Aside from a realistic
    example such as the copyright, other reasons you might use this is to inject some
    sort of dynamic user data - things such as a username and email or anything else.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a basic understanding about how to use handlebars to create
    static pages, we'll look at some more advanced features of hbs inside the next
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll learn a few more advanced features that handlebars has
    to offer. This will make it easier to render our markup, especially markup that's
    used in multiple places, and it will make it easier to inject dynamic data into
    your web pages.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to illustrate the first thing we''ll talk about, I want to open up
    both `about.hbs` and `home.hbs`, and you''ll notice down at the bottom that they
    both have the exact same footer code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: We have a little copyright message for both and they both have the same header
    area, which is the `h1` tag.
  prefs: []
  type: TYPE_NORMAL
- en: Now this really isn't a problem because we have two pages, but as you add more
    and more pages it's going to become a real pain to update your header and your
    footer. You'll have to go into every file and manage the code there, but what
    we'll talk about instead is something called a partial.
  prefs: []
  type: TYPE_NORMAL
- en: Adding partials
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A partial is a partial piece of your website. It's something you can reuse throughout
    your templates. For example, we might have a footer partial that renders the footer
    code. You can include that partial on any page you need a footer. You could do
    the same thing for header. In order to get started, the first thing we need to
    do is set up our `server.js` file just a little bit to let handlebars know that
    we want to add support for partials.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to do this, we''ll add one line of code in the `server.js` file where
    we declared our view engine previously, and it will look something like this (`hbs.registerPartials`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Now `registerPartials` is going to take the directory you want to use for all
    of your handlebar partial files, and we''ll be specifying that directory as the
    first and only argument. Once again, this does need to be the absolute directory,
    so I''ll use the `__dirname` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Then we can concatenate the rest of the path, which will be `/views`. In this
    case, I want you to use `/partials`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: We'll store our `partial` files right inside a directory in the `views` folder.
    Now we can create that folder right in views called `partials`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside `partials`, we can put any of the handlebars partials we like. To illustrate
    how they work, we''ll create a file called `footer.hbs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ba84974e-6997-4b86-8e65-909dd7912add.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Inside `footer.hbs`, we''ll have access to the same handlebars features, which
    means we can write some markup, we can inject variables, we can do whatever we
    like. For now, what we''ll do is copy the `footer` tag exactly, pasting it inside
    `footer.hbs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have our `footer.hbs` file, this is the partial and we can include it
    in both `about.hbs` and `home.hbs`. In order to do that, we''ll delete the code
    that we already have in the partial and we''ll replace it with opening and closing
    two curly braces. Now instead of injecting data, we want to inject a template
    and the syntax for that is to add a greater than symbol with a space, followed
    by the partial name. In our case that partial is called `footer`, so we can add
    this right here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Then I can save about and do the same thing over in `home.hbs`. We now have
    our footer partial. It's rendering on both pages.
  prefs: []
  type: TYPE_NORMAL
- en: Working of partial
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To illustrate how this works, I''ll fire up my server and by default `nodemon`;
    it''s not going to watch your handlebars files. So if you make a change, the website''s
    not going to render as you might expect. We can fix this by running `nodemon`,
    passing in `server.js` and providing the `-e` flag. This lets us specify all of
    the extensions we want to watch. In our case, we''ll watch the JS extension for
    the server file, and after the comma, the `hds` extension:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/004348dd-260d-4ad0-a181-cc8bbf7a467e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now our app is up and running, we can refresh things over in the browser, and
    they should look the same. We have our about page with our footer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ed69beb8-6b66-417f-9b86-80b7f071f7e6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We have our home page with the exact same footer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cdb964aa-0e0c-4ab4-a6a6-0b566d19f7d7.png)'
  prefs: []
  type: TYPE_IMG
- en: The advantage now is if we want to change that footer, we just do it in one
    place, in the `footer.hbs` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can add something to our `footer` paragraph tag. Let''s add a little message
    created by `Andrew Mead` with a `-`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, save the file and when we refresh the browser, we have our brand new footer
    for Home Page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3f195019-b92c-4349-8791-faa99b8c8804.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We have our brand new footer for About Page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c310e4de-e690-44d2-99f9-960964edaa74.png)'
  prefs: []
  type: TYPE_IMG
- en: It will show up for both the home page and the about page. There's no need to
    do you anything manual in either of these pages, and this is the real power of
    partials. You have some code, you want to reuse it inside your website, so you
    simply create a partial and you inject it wherever you like.
  prefs: []
  type: TYPE_NORMAL
- en: The Header partial
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have the footer partial in place, let's create the header partial.
    That means we'll need to create a brand new file `header.hbs`. We'll want to add
    the `h1` tag inside that file and then we'll render the partial in both `about.hbs`
    and `home.hbs`. Both pages should still look the same.
  prefs: []
  type: TYPE_NORMAL
- en: We'll get started by creating a new file in the partials folder called `header.hbs`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside `header.hbs`, we''ll take the `h1` tag from our website, paste it right
    inside and save it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can use this header partial in both `about` and `home` files. Inside
    of `about`, we need to do this using the syntax, the double curly braces with
    the greater than sign, followed by the partial name `header`. We''ll do the exact
    same thing for the `home` page. In the `home` page, we''ll delete our `h1` tag,
    inject the `header` and save the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1d0cfc47-2614-44ef-8e51-d47e70a0c554.png)![](img/a934ac3e-cb8e-4907-b2a9-e117eedb29c3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now we''d create something slightly different just so we can test that it actually
    is using the partial. We''ll type `123` right after the `h1` tag in `header.hbs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that all the files are saved, we should be able to refresh the browser,
    and we see `about` page with 123 printing, which is fantastic:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9d7c7b9a-77b3-4582-a586-c7f0ec7adf7f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This means the `header` partial is indeed working, and if I go back to the
    `home` page, everything still looks great:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f84e2173-76d2-4852-b033-7ce62f5be9a4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that we have the header broken out into its own file, we can do all sorts
    of things. We can take our `h1` tag and put it inside of a `header tag`, which
    is the appropriate way to declare your header inside of HTML. As shown, we add
    an opening and closing `header` tag. We can take the `h1` and we can move it right
    inside:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'We could also add some links to the other pages on our website. We could add
    an anchor tag for the homepage by adding an `a` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `a` tag, we''ll specify the link text we''d like to show up. I''ll
    go with `Home`, then inside the `href` attribute, we can specify the path the
    link should take you to, which would just be `/`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we can take the same paragraph tag, copy it and paste it in the next line
    and make a link for the `about` page. I''ll change the page text to `About`, the
    link text, and the URL instead of going to `/` will go to `/about`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we''ve made a change to our `header` file and it will be available on all
    of the pages of our website. I''m on the `home` page. If I refresh it, I get Home
    and About page links:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fc1ba9b1-502f-46ac-af10-ef18c95ff52f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'I can click on the About to go to the About Page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/069951c9-aa95-4915-99a5-053cb121590b.png)'
  prefs: []
  type: TYPE_IMG
- en: Similarly, I can click on Home to come right back. All of this is much easier
    to manage now that we have partials inside of our website.
  prefs: []
  type: TYPE_NORMAL
- en: The Handlebars helper
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now before we go further, there is one more thing I want to talk about, that
    is, a handlebars helper. Handlebars helpers are going to be ways for us to register
    functions to run to dynamically create some output. For example, inside `server.js`,
    we currently inject the current year inside of both of our `app.get` templates
    and that's not really necessary.
  prefs: []
  type: TYPE_NORMAL
- en: There is a better way to pass this data in, and this data shouldn't need to
    be provided because we'll always use the exact same function. We'll always take
    the new date `getfullYear` return value passing it in. Instead, we'll use a partial,
    and we'll set ours up right now. Now a partial is nothing more than a function
    you can run from inside of your handlebars templates.
  prefs: []
  type: TYPE_NORMAL
- en: 'All we need to do is register it and I''ll do that in the `server.js`, following
    on from where we set up our Express middleware. As shown in the following code,
    we''ll call `hbs.register` and we''ll be registering a helper, so we''ll call
    a `registerHelper`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Now `registerHelper` takes two arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: The name of the helper as the first argument
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The function to run as the second argument.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The first argument right here will be `getCurrentYear` in our case. We''ll
    create a helper that returns that current year:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The second argument will be our function. I''ll use an arrow function (`=>`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Anything we return from this function will get rendered in place of the `getCurrentYear`
    call. That means if we call `getCurrentYear` inside the `footer`, it will return
    the year from the function, and that data is what will get rendered.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `server.js`, we can return the year by using `return` and having the
    exact same code we have `app.get` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll make a new date and we''ll call its `getFullYear` method. Now that we
    have a helper, we can remove this data from every single one of our rendering
    calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'This is going to be really fantastic because there really is no need to compute
    it for every page since it''s always the same. Now that we''ve removed that data
    from the individual calls to render, we will have to use `getCurrentYear` inside
    the `footer.hbs` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Instead referencing the current year, we will use the helper `getCurrentYear`,
    and there's no need for any special syntax. When you use something inside curly
    braces that clearly isn't a partial, handlebars is first going to look for a helper
    with that name. If there is no helper, it'll look for a piece of data with that
    `getCurrentYear` name.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, it will find the helper, so everything will work as expected.
    We can now save `footer.hbs`, move into the browser, and give things a refresh.
    When I refresh the page, we still get Copyright 2018 in Home Page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3f8c5249-9726-429a-91a2-e4174faecd99.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If I go to the About Page, everything looks great:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9b2adade-57f5-471e-9eb1-6e080dbe07b9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can prove that data is coming back from our helper by simply returning something
    else. Let''s comment out our helper code in `server.js` and before the comment,
    we can use `return test`, just like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now save `server.js`, refresh the browser, and we get tests showing
    up as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b006455a-30e6-4c48-89c2-4458f2c4ce80.png)'
  prefs: []
  type: TYPE_IMG
- en: So the data that renders right after the Copyright word is indeed coming from
    that helper. Now we can remove the code so we return the proper year.
  prefs: []
  type: TYPE_NORMAL
- en: Arguments in Helper
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Helpers can also take arguments, and this is really useful. Let's create a second
    helper that's going to be a capitalization helper. We'll call the helper `screamIt`
    and its job will be to take some text and it will return that text in uppercase.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to do this, we will be calling `hbs.registerHelper` again. This helper
    will be called `screamIt`, and it will take a function because we do need to run
    some code in order to do anything useful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Now `screamIt` is going to take `text` to scream and all it will do is call
    on that string the `toUpperCase` method. We''ll return `text.toUpperCase`, just
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Now we can actually use `screamIt` in one of our files. Let's move into `home.hbs`.
    Here, we have our welcome message in the `p` tag. We'll remove it and we'll scream
    the welcome message. In order to pass data into one of our helpers, we first have
    to reference the helper by name, `screamIt`, then after a space we can specify
    whatever data we want to pass in as arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, we''ll pass in the welcome message, but we could also pass in
    two arguments by typing a space and passing in some other variable which we don''t
    have access to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'For now, we''ll use it like this, which means we''ll call the `screamIt` helper,
    passing in one argument `welcomeMessage`. Now we can save `home.hbs`, move back
    into the browser, go to the Home Page and as shown following, we get WELCOME TO
    MY WEBSITE in all uppercase:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6d8cf895-07da-4939-ac78-a68c68bcae60.png)'
  prefs: []
  type: TYPE_IMG
- en: Using handlebars helpers, we can create both functions that don't take arguments
    and functions that do take arguments. So when you need to do something to the
    data inside of your web page, you can do that with JavaScript. Now that we have
    this in place, we are done.
  prefs: []
  type: TYPE_NORMAL
- en: Express Middleware
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, you''ll learn how to use Express middleware. Express middleware
    is a fantastic tool. It allows you to add on to the existing functionality that
    Express has. So if Express doesn''t do something you''d like it to do, you can
    add some middleware and teach it how to do that thing. Now we''ve already used
    a little bit of middleware. In `server.js` file, we used some middleware and we
    teach Express how to read from a `static` directory, which is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: We called `app.use`, which is how you register middleware, and then we provided
    the middleware function we want to use.
  prefs: []
  type: TYPE_NORMAL
- en: Now middleware can do anything. You could just execute some code such as logging
    something to the screen. You could make a change to the request or the response
    object. We'll do just that in the next chapter when we add API authentication.
    We'll want to make sure the right header is sent. That header will be expected
    to have an API token. We can use middleware to determine whether or not someone's
    logged in. Basically, it will determine whether or not they should be able to
    access a specific route, and we can also use middleware to respond to a request.
    We could send something back from the middleware, just like we would anywhere
    else, using `response.render` or `response.send`.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring middleware
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to explore middleware, we''ll create some basic middleware. Just following
    where we call `app.use` registering our Express static middleware, we''ll call
    `app.use` again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Now `app.use` is how you register middleware, and it takes a function. So,
    we''ll pass in an arrow function (`=>`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'The `use` function takes just one function. There is no need to add any other
    arguments. This function will get called with the request (`req`) object, the
    response (`res`) object and a third argument, `next`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Now request and response objects, these should seem familiar by now. They're
    the exact same arguments we get whenever we register a handler. The `next` argument
    is where things get a little trickier. The `next` argument exists so you can tell
    Express when your middleware function is done, and this is useful because you
    can have as much middleware as you like registered to a single Express app. For
    example, I have some middleware that serves up a directory. We'll write some more
    that logs some request data to the screen, and we could have a third piece that
    helps with application performance, keeping track of response times, all of that
    is possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now inside `app.use` function, we can do anything we like. We might log something
    to the screen. We might make a database request to make sure a user is authenticated.
    All of that is perfectly valid and we use the `next` argument to tell Express
    when we''re done. So if we do something asynchronous, the middleware is not going
    to move on. Only when we call `next`, will the application continue to run, like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Now this means if your middleware doesn''t call next, your handlers for each
    request, they''re never going to fire. We can prove this. Let''s call `app.use`,
    passing in an empty function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s save the file and in the Terminal, we''ll run our app using `nodemon`
    with `server.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/786125db-b49b-4204-a886-583995fdfe2e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'I''ll move into the browser and I''ll make a request for the home page. I''ll
    refresh the page and you can see that up top, it is trying to load but it''s never
    going to finish:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/af33b302-3460-4c7e-a230-c3fbf7165343.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now it''s not that it can''t connect to the server. It connects to the server
    just fine. The real problem is that inside our app, we have middleware that doesn''t
    call next. To fix this, all we''ll do is call `next` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Now when things refresh over inside the browser, we get our Home Page exactly
    as we expect it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ae177c74-2938-4f73-93a5-24a69c4240ba.png)'
  prefs: []
  type: TYPE_IMG
- en: The only difference is now we have a place where we can add on some functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a logger
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Inside `app.use`, we're going to get started by creating a logger that will
    log out all of the requests that come in to the server. We'll store a timestamp
    so we can see exactly when someone made a request for a specific URL.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started inside the middleware, let''s get the current time. I''ll make
    a variable called now, setting it equal to `newDate`, creating a new instance
    of our date object, and I''ll call it `toString` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: The `toString` method creates a nice formatted date, a human-readable timestamp.
    Now that we have our now variable in place, we can start creating the actual logger
    by calling `console.log`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s call `console.log`, passing in whatever I like. Let''s pass in inside
    of ticks the `now` variable with a colon after:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Now if I save my file, things are going to restart in the Terminal because
    `nodemon` is running. When we make a request for the site again and we go into
    the Terminal, we should see the log:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5019d745-4ca5-4c65-bfd7-5ad13577dc09.png)'
  prefs: []
  type: TYPE_IMG
- en: Currently it's just a timestamp, but we are on the right track. Now everything
    is working because we called `next`, so after this `console.log` call prints to
    the screen, our application continues and it serves up the page.
  prefs: []
  type: TYPE_NORMAL
- en: Inside middleware, we can add on more functionality by exploring the request
    object. On the request object, we have access to everything about the request—the
    HTTP method, the path, query parameters, and anything that comes from the client.
    Whether the client is an app, a browser, or an iPhone, it is all going to be available
    in that request object. Two things we'll pull off now are the HTTP method and
    the path.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to look at a full list of the things you have access to, you can
    go to [expressjs.com](http://expressjs.com/), and go to API reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b8dfc130-d80e-4dc5-a326-3f6e706eff44.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We happen to be using a 4.x version of Express, so we''ll click that link:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7e612137-1291-4772-b708-fba531456141.png)'
  prefs: []
  type: TYPE_IMG
- en: 'On the right-hand side of this link, we have both Request and Response. We''ll
    look for the request objects, so we''ll click that. This''ll lead us to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/07ed8d23-0f1d-49c2-b06c-4454be7ab31e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We''ll be using two request properties: `req.url` and `req.method`. Inside
    Atom, we can start implementing those, adding them into `console.log`. Right after
    the timestamp, we''ll print the HTTP method. We''ll be using other methods later.
    For now we''ve only used the `get` method. Right inside the `console.log`, I''ll
    inject `request.method` printing it to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Next up we can print the path so we know exactly what page the person requested.
    I''ll do that by injecting another variable, `req.url`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'With this in place, we now have a pretty useful piece of middleware. It takes
    the request object, it spits out some information and then it moves on, letting
    the server process that request which was added. If we save the file and rerun
    the app from the browser, we should be able to move into the Terminal and see
    this new logger printing to the screen, and as shown following we get just that:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ba650386-32a1-40b2-8293-741d8abe62a8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We have our timestamp, the HTTP method which is `GET`, and the path. If we
    change the path to something more complicated, such as `/about`, and we move back
    into the Terminal, we''ll see the `/about` where we accessed `req.url`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ff7dc6f1-8c40-40b2-a8ea-33cff4af309b.png)'
  prefs: []
  type: TYPE_IMG
- en: Now this is a pretty basic example of some middleware. We can take it a step
    further. Aside from just logging a message to the screen, we'll also print the
    message to a file.
  prefs: []
  type: TYPE_NORMAL
- en: Printing message to file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To print the message to a file, let''s load in `fs` up in the `server.js` file.
    We''ll create a constant. Call that `const fs` and set that equal to the return
    result from requiring the module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can implement this down following in the `app.use`. We''ll take our
    template string, which is currently defined inside `console.log`. We''ll cut it
    out and instead store in a variable. We''ll make a variable called `log`, setting
    it equal to that template string as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can pass that `log` variable into both `console.log` and into an `fs`
    method to write to our file system. For `console.log`, we will call log like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'For `fs`, I''ll call `fs.appendFile`. Now as you remember, `appendFile` lets
    you add on to a file. It takes two arguments: the file name and the thing we want
    to add. The file name we''ll use is `server.log`. We''ll create a nice log file
    and the actual contents will just be the `log` message. We will need to add one
    more thing: we also want to move on to the next line after every single request
    gets logged, so I''ll concatenate the new line character, which will be `\n`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: If you're using Node V7 or greater, you will need to make a small tweak to this
    line. As shown in the following code, we added a third argument to `fs.appendFile`.
    This is a callback function. It's now required.
  prefs: []
  type: TYPE_NORMAL
- en: '`fs.appendFile(''server.log'', log + ''\n'', (err) => {`'
  prefs: []
  type: TYPE_NORMAL
- en: '`  if (err) {`'
  prefs: []
  type: TYPE_NORMAL
- en: '`    console.log(''Unable to append to server.log.'')`'
  prefs: []
  type: TYPE_NORMAL
- en: '`  }`'
  prefs: []
  type: TYPE_NORMAL
- en: '`});` If you don''t have a callback function, you''ll get a deprecation warning
    over inside the console. Now as you can see, our callback function here takes
    an error argument. If there is an error, we just print a message to the screen.
    If you change your line to look like this, regardless of your Node version, you''ll
    be future proof. If you''re on Node V7 or greater, the warning in the console
    will go away. Now the warning is going to say something such as deprecation warning.
    Calling an asynchronous function without callback is deprecated. If you see that
    warning, make this change.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have this in place, we can test things out. I save the file, which
    should be restarting things inside of `nodemon`. Inside Chrome, we can give the
    page a refresh. If we head back into the Terminal, we do still get my log, which
    is great:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8784f004-8b24-4050-930b-229304d7d367.png)'
  prefs: []
  type: TYPE_IMG
- en: Notice we also have a request for a `favicon.ico`. This is usually the icon
    that's shown in the browser tab. I have one cached from a previous project. There
    actually is no icon file defined, which is totally fine. The browser still makes
    the request anyway, which is why that shows up as shown in the previous code snippet.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside Atom, we now have our `server.log` file, and if we open it up, we have
    a log of all the requests that were made:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9f3671b8-59e9-4f0a-87ce-94914298c519.png)'
  prefs: []
  type: TYPE_IMG
- en: We have timestamps, HTTP methods, and paths. Using `app.use`, we were able to
    create some middleware that helps us keep track of how our server is working.
  prefs: []
  type: TYPE_NORMAL
- en: Now there are times where you might not want to call next. We learned that we
    could call next after we do something asynchronous, such as a read from a database,
    but imagine something goes wrong. You can avoid calling next to never move on
    to the next piece of middleware. We would like to create a new view inside the
    `views` folder. We'll call this one `maintenance.hbs`. This will be a handlebars
    template that will render when the site is in maintenance mode.
  prefs: []
  type: TYPE_NORMAL
- en: The maintenance middleware without the next object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll start with making the `maintenance.hbs` file by duplicating `home.hbs`.
    Inside `maintenance.hbs`, all we''ll do is wipe the body and add a few tags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in the following code, we''ll add an `h1` tag to print a little message
    to the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re going to use something like `We''ll be right back`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, I can add a paragraph tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: Now we will be able to use `p` followed by the tab. This is a shortcut inside
    Atom for creating an HTML tag. It works for all tags. We could type body and hit
    *enter* or I could type `p` and press *enter*, and the tag will be created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the paragraph, I''ll leave a little message: `The site is currently
    being updated`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have our template file in place, we can define our maintenance middleware.
    This is going to bypass all of our other handlers, where we render other files
    and print JSON, and instead it'll just render this template to the screen. We'll
    save the file, move into `server.js`, and define that middleware.
  prefs: []
  type: TYPE_NORMAL
- en: 'Right next to the previously-defined middleware, we can call `app.use` passing
    in our function. The function will take those three arguments: request (`req`),
    response (`res`), and `next`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the middleware, all we''ll need to do is call `res.render`. We''ll add
    `res.render` passing in the name of the file we want to render; in this case,
    it''s `maintenance.hbs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: That is all you needed to do to set up our main middleware. This middleware
    will stop everything after it from executing. We don't call next, so the actual
    handlers in the `app.get` function, they will never get executed and we can test
    this.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the maintenance middleware
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Inside the browser, we''ll refresh the page, and we will get the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/15cdba39-3814-4d5c-91b8-8469871735bf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We get the maintenance page. We can go to the home page and we get the exact
    same thing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/31b494e9-7a29-4e75-92d3-bf6a7ad5b1ef.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now there''s one more really important piece to middleware we haven''t discussed
    yet. Remember inside the `public` folder, we have a `help.html` file as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e3635d59-628c-4081-b745-dd4e9fbc077a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If we visit this in the browser by going to `localhost:3000/help.html`, we''ll
    still get the help page. We''ll not get the maintenance page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5e1d306a-d8c2-4e18-a5b9-850007ada37c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'That is because middleware is executed in the order you call `app.use`. This
    means the first thing we do is we set up our Express static directory, then we
    set up our logger, and finally we set up our `maintenance.hbs` logger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: This is a pretty big problem. If we also want to make the `public` directory
    files such as `help.html` private, we'll have to reorder our calls to `app.use` because
    currently the Express server is responding inside of the Express static middleware,
    so our maintenance middleware doesn't get a chance to execute.
  prefs: []
  type: TYPE_NORMAL
- en: 'To resolve this, we''ll take the `app.use` Express static call, remove it from
    the file, and add it after we render the maintenance file to the screen. The resultant
    code is going to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, everything will work as expected, no matter what we''re going to log the
    request. Then we''ll check if we''re in maintenance mode if the maintenance middleware
    function is in place. If it is, we''ll render the maintenance file. If it''s not,
    we''ll ignore it because it''ll be commented out or something like that, and finally
    we''ll be using Express static. This is going to fix all those problems. If I
    re-render the app now, I get the maintenance page on `help.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/68cc0afb-4c03-45d0-b33f-633917f27264.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If I go back to the root of the website, I still get the maintenance page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eed3d7c1-d744-4eac-8a19-c6cb715f7e0f.png)'
  prefs: []
  type: TYPE_IMG
- en: Now once we're done with the maintenance middleware, we can always comment it
    out. This will remove it from being executed, and the website will work as expected.
  prefs: []
  type: TYPE_NORMAL
- en: This has been a quick dive into Express middleware. We'll be using it a lot
    more throughout the book. We'll be using middleware to check if our API requests
    are actually authenticated. Inside the middleware, we'll be making a database
    request, checking if the user is indeed who they say they are.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter you learned about Express and how it can be used to easily create
    websites. We looked at how we can set up a static web server, so when we have
    an entire directory of JavaScript, images, CSS, and HTML. We can serve that up
    easily without needing to provide routes for everything. This will let us create
    all sorts of applications, which we'll be doing throughout the rest of the book.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we continued on learning how to use Express. We took a look at how we
    can render dynamic templates, kind of like we would with a PHP or Ruby on Rails
    file. We have some variables and we rendered a template injecting those variables.
    Then we learned a little bit about handlebars partials, which let us create reusable
    chunks of code like headers and footers. We also learned about Handlebars helpers,
    which is a way to run some JavaScript code from inside of your handlebars templates.
    Lastly, we moved back to talking about Express and how it can customize our requests,
    responses, our server.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll look into deploying applications to the web.
  prefs: []
  type: TYPE_NORMAL
