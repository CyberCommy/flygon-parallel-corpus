- en: Using Python to Manage Network Devices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we have a fair knowledge about how to use and install Python in different
    operating systems and also how to build the network topology using the EVE-NG.
    In this chapter, we will discover how to leverage many network automation libraries,
    used today to automate various network tasks. Python can interact with network
    devices on many layers.
  prefs: []
  type: TYPE_NORMAL
- en: First, it can handle low-level layers with socket programming and `socket` modules,
    which serve as low-level networking interfaces between operating systems that
    run Python and the network device. Also, Python modules provide higher-level interaction
    through telnet, SSH, and API. In this chapter, we will dive deep into how to use
    Python to establish remote connections and execute commands on remote devices
    using telnet and SSH modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered:'
  prefs: []
  type: TYPE_NORMAL
- en: Using Python to telnet to devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python and SSH
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling IP addresses and networks with `netaddr`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Network automation sample use cases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following tools should be installed and available in your environment:'
  prefs: []
  type: TYPE_NORMAL
- en: Python 2.7.1x
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PyCharm Community or Pro Edition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: EVE-NG topology; please refer to [Chapter 3](part0043.html#190860-9cfcdc5beecd470bbeda046372f0337f), *Setting
    up the Network Lab Environment*, for how to install and configure the emulator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find the full scripts developed in this chapter at the following GitHub
    URL: [https://github.com/TheNetworker/EnterpriseAutomation.git](https://github.com/TheNetworker/EnterpriseAutomation.git).
  prefs: []
  type: TYPE_NORMAL
- en: Python and SSH
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unlike telnet, SSH provides a secure channel to exchange data between client
    and server. The tunnel created between the client and the device is encrypted
    with different security mechanisms that make it hard for anyone to decrypt the
    communication. The SSH protocol is the first choice for network engineers who
    need to securely administrate network nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Python can communicate with network devices using the SSH protocol by utilizing
    a popular library called **Paramiko** that supports authentication, key handling
    (DSA, RSA, ECDSA, and ED25519), and other SSH features such as the `proxy` command
    and SFTP.
  prefs: []
  type: TYPE_NORMAL
- en: Paramiko module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most widely used module for SSH in Python is called `Paramiko` and, as the
    GitHub official page says, the name Paramiko is a combination of the Esperanto
    words for "paranoid" and "friend." The module itself is written and developed
    using Python, though some core functions like crypto depend on the C language.
    You can find out more about the contributors and module history at the official
    GitHub link here: [https://github.com/paramiko/paramiko](https://github.com/paramiko/paramiko).
  prefs: []
  type: TYPE_NORMAL
- en: Module installation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Open Windows cmd or Linux shell and execute the following command to download
    the latest `paramiko` module from PyPI. It will download additional dependency
    packages such as `cyrptography`, `ipaddress`, and `six` and install them on your
    machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '![](../images/00066.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can verify that the installation is done successfully by entering the Python
    shell and importing the `paramiko` module as shown in the following screenshot.
    Python should import it successfully without printing any errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00067.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: SSH to the network device
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As usual, in every Python module, we first need to import it into our Python
    script, then we will create an SSH client by inheriting from `SSHClient()`. After
    that, we will configure the Paramiko to automatically add any unknown host-key
    and trust the connection between you and the server. Then, we will use the `connect`
    function and provide the remote host credentials:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '`AutoAddPolicy()` is one of the policies that can be used inside the `set_missing_host_key_policy()`
    function. It''s preferred and acceptable in a lab environment. However, we should
    use a more restrictive policy in a production environment, such as `WarningPolicy()`
    or `RejectPolicy()`.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `invoke_shell()` will start the interactive shell session towards
    our SSH server. You can provide additional parameters to it such as the terminal
    type, width, and height.
  prefs: []
  type: TYPE_NORMAL
- en: 'Paramiko connect parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Look_For_Keys`: By default, it''s `True`, and it will force the Paramiko to
    use the key-pair authentication where the user is using both private and public
    keys to authenticate against the network device. In our case, we will set it to
    `False` as we will use password authentication.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`allow_agent paramiko`: It can connect to a local SSH agent OS. This is necessary
    when working with keys; in this case, since authentication is performed using
    a login/password, we will disable it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The final step is to send a series of commands such as `show ip int b` and
    `show arp` to the device terminal and get the output back to our Python shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The script output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00068.jpeg)It''s preferable to use `time.sleep()`when you need
    to execute commands that will take a long time on a remote device to force Python
    to wait some time till the device generates output and sends it back to python.
    Otherwise, python may return blank output to the user.'
  prefs: []
  type: TYPE_NORMAL
- en: Netmiko module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `netmiko` module is an enhanced version of paramiko and targets network
    devices specifically. While paramiko is designed to handle SSH connections to
    a device and to check whether the device is a server, printer, or network device,
    Netmiko is designed with network devices in mind and handles SSH connections more
    efficiently. Also, Netmiko supports a wide range of vendors and platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Netmiko is considered a wrapper around paramiko and extends its features with
    many additional enhancements, such as access to vendor-enabled modes directly
    given the enable password, reading configuration from a file and pushing it to
    devices, disabling paging during login, and sending the carriage return `"\n"`
    by default after each command.
  prefs: []
  type: TYPE_NORMAL
- en: Vendor support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Netmiko supports many vendors and regularly adds new vendors to the supported
    list. Following is a list of supported vendors categorized into three groups:
    Regularly tested, Limited testing, and Experimental. You can find the list on
    the module GitHub page at [https://github.com/ktbyers/netmiko#supports](https://github.com/ktbyers/netmiko#supports).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the number of supported vendors under the Regularly
    tested category:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00069.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following screenshot shows the number of supported vendors under the Limited
    testing category:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00070.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following screenshot shows the number of supported vendors under the Experimental
    category:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00071.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Installation and verification
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To install `netmiko`, open the Windows cmd or Linux shell and execute the following
    command to get the latest package from PyPI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '![](../images/00072.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Then import netmiko from the Python shell to make sure the module is correctly
    installed into Python site-packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Using netmiko for SSH
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now it''s time to utilize netmiko and see its power for SSHing to network devices
    and executing commands. By default, netmiko handles many operations in the background
    during session establishment, such as adding unknown SSH key hosts, setting the
    terminal type, width, and height, and accessing enable mode when required, then
    disabling paging by running a vendor-specific command. You will need to define
    the devices first in dictionary format and provide five mandatory keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The first parameter is `device_type`, and it is used to define the platform
    vendor in order to execute the correct commands. Then, we need the `ip` address
    for SSH. This parameter could be the device hostname if it's already been resolved
    by your DNS, or just the IP address. Then we provide the `username`, `password`,
    and enable-mode password in `secret`. Notice you can use the `getpass()` module
    to hide the passwords and only prompt them during the script execution.
  prefs: []
  type: TYPE_NORMAL
- en: While the keys order inside the variable is not important, the key's name should
    be exactly the same as provided in the previous example in order for netmiko to
    correctly parse the dictionary and to start to establish a connection to the device.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will import the `ConnectHandler` function from the netmiko module
    and give it the defined dictionary to start the connection. Since all our devices
    are configured with an enable-mode password, we need to access the enable mode
    by providing `.enable()` to the created connection. We will execute the command
    on the router terminal by using `.send_command()`, which will execute the command
    and return the device output to the variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The script output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00073.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Notice how the output is already cleaned from the device prompt and the command
    that we executed on the device. By default, Netmiko replaces them and generates
    a cleaned output, which could be processed by regular expressions, as we will
    see in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you need to disable this behavior and want to see the device prompt and
    executed command in the returned output, then you need to provide additional flags
    to `.send_command()` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `strip_command=False` and `strip_prompt=False` flags tell netmiko to keep
    both the prompt and command and not to replace them. They''re `True` by default
    and you can toggle them if you want:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00074.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Configuring devices using netmiko
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Netmiko can be used to configure remote devices over SSH. It does that by accessing
    config mode using the `.config` method and then applies the configuration given
    in `list` format. The list itself can be provided inside the Python script or
    read from the file, then converted to a list using the `readlines()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous script, we did the same thing that we did before to connect
    to SW2 and enter enable mode, but this time we leveraged another netmiko method
    called `send_config_set()`, which takes the configuration in list format and accesses
    device configuration mode and starts to apply it. We have a simple configuration
    that modifies the `gig0/1` and `gig0/2` and applies trunk configuration on them.
    You can check if the command executed successfully by running `show run` command
    on the device; you should get output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00075.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Exception handling in netmiko
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we design our Python script, we assume that the device is up and running
    and also that the user has provided the correct credentials, which is not always
    the case. Sometimes there's a network connectivity issue between Python and the
    remote device or the user enters the wrong credentials. Usually, python will throw
    an exception if this happens and will exit, which is not the optimum solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'The exception handling module in netmiko, `netmiko.ssh_exception`, provides
    some exception classes that can handle such situations. The first one is `AuthenticationException`,
    and will catch the authentication errors in the remote device. The second class
    is `NetMikoTimeoutException`, which will catch timeouts or any connectivity issues
    between netmiko and the device. What we will need to do is wrap our ConnectHandler()
    method with the try-except clause and catch timeout and authentication exceptions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Device auto detect
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Netmiko provides a mechanism that can guess the device type and detect it.
    It uses a combination of SNMP discovery OIDS and executes several show commands
    on the remote console to detect the router operating system and type, based on
    the output string. Then netmiko will load the appropriate driver into the `ConnectHandler()`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous script:'
  prefs: []
  type: TYPE_NORMAL
- en: The `device_type` inside the device dictionary will be `autodetect`, which will
    tell `netmiko` to wait and not load the driver till the netmiko guesses it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then we instruct the netmiko to perform device detection using the `SSHDetect()`
    class. The class will connect to the device using SSH and will execute some discovery
    commands to define the operating system type. The returned result will be a dictionary,
    and the best match will be assigned to the `device_type` variable using the `autodetect()`
    function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can see all the matching results by printing the `potential_matches`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now we can update the device dictionary and assign the new `device_type` to
    it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the telnet protocol in Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Telnet is one of the oldest protocols available in the TCP/IP stack. It is used
    primarily to exchange data over an established connection between a server and
    client. It uses TCP port `23` in the server for listening to the incoming connection
    from the client.
  prefs: []
  type: TYPE_NORMAL
- en: In our case, we will create a Python script that acts as a telnet client, and
    other routers and switches in the topology will act as the telnet server. Python
    comes with a native support for telnet via a library called `telnetlib` so we
    don't need to install it.
  prefs: []
  type: TYPE_NORMAL
- en: After creating the client object by instantiating it from the `Telnet()` class,
    available from the `telnetlib` module, we can use the two important functions
    available inside `telnetlib`, which are `read_until()` (used to read the output)
    and `write()` (used to write on the remote device). Both functions are used to
    interact with the created channel, either by writing or reading the output returned
    from it.
  prefs: []
  type: TYPE_NORMAL
- en: Also, it's important to note that reading the channel using `read_until()` will
    clear the buffer and data won't be available for any further reading. So, if you
    read important data and you will process and work on it later, then you need to
    save it as a variable before you continue with your script.
  prefs: []
  type: TYPE_NORMAL
- en: Telnet data is sent in clear text format, so your credentials and password may
    be captured and viewed by anyone performing a man-in-the-middle attack. Some service
    providers and enterprises still use it and integrate it with VPNs and radius/tacacs
    protocols to provide lightweight and secure access.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow the steps to understand the whole script:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will import the `telnetlib` module inside our Python script and define the
    username and passwords in variables, as in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We will define a variable that establishes the connection with the remote host.
    Note that we won''t provide the username or password during connection establishment;
    we will only provide the IP address of the remote host:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we will provide the username for the telnet connection by reading the returned
    output from the channel and searching for the `Username:` keyword. Then we write
    our admin username. The same process is used when we need to enter the telnet
    password and enable password:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: It's important to provide the exact keywords that appear in the console when
    you establish the telnet connection or the connection, will enter an infinite
    loop. Then Python script will be timed out with an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we will write the `show ip interface brief` command on the channel
    and read till the router prompt `#` to get the output. This should get us the
    interface configuration in the router:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The full script is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00076.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The script output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00077.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Notice that the output contains the executed command `show ip int b`, and the
    router prompt "R1#" is returned and printed in the `stdout`. We could use built-in
    string functions like `replace()` to clean them from the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '![](../images/00078.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As you noticed, we provided both the password and enable password as clear text
    inside our script, which is considered a security issue. It's also not good practice
    to hardcode the values inside your Python script. Later, in the next section,
    we will hide the password and design a mechanism to provide credentials during
    script runtime only.
  prefs: []
  type: TYPE_NORMAL
- en: Also, if you want to execute commands that span multiple pages in output like
    `show running config` then you will need to disable paging first by sending `terminal
    length 0` after connecting to the device and before sending the command to it.
  prefs: []
  type: TYPE_NORMAL
- en: Push configuration using telnetlib
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In previous section, we looked at a simplified operation of `telnetlib` by
    executing the `show ip int brief`. Now we need to utilize it to push VLAN configuration
    to the four switches in our topology. We could create a VLAN list using the python
    `range()` function and iterate over it to push the VLAN ID to the current switch.
    Notice we defined the switch IP addresses as an item inside the list, and this
    list will be our outer `for` loop. Also, I will use another built-in module called
    `getpass` to hide the password from the console and only provide it when the script
    is running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In our outermost `for` loop, we are iterating over the devices and then, inside
    each iteration (each device), we're generating a vlan range from 300 to 400 and
    pushing them to the current device.
  prefs: []
  type: TYPE_NORMAL
- en: 'The script output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00079.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Also, you can check the output from the switch console itself (output is omitted):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00080.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Handling IP addresses and networks with netaddr
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Working and manipulating IP addresses is one of the most important tasks for
    network engineers. Python developers provide an amazing library that can understand
    the IP addresses and work on them, called `netaddr`. For example, assume you developed
    an application and part of it is to get the network and broadcast address for
    `129.183.1.55/21`. You can do that easily via two built-in methods inside the
    modules called `network` and `broadcast` respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In general, netaddr provides support for the following features:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Layer 3 addresses:**'
  prefs: []
  type: TYPE_NORMAL
- en: IPv4 and IPv6 addresses, subnets, masks, prefixes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Iterating, slicing, sorting, summarizing, and classifying IP networks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dealing with various range formats (CIDR, arbitrary ranges and globs, nmap)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set-based operations (unions, intersections, and so on) over IP addresses and
    subnets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parsing a large variety of different formats and notations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Looking up IANA IP block information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating DNS reverse lookups
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Supernetting and subnetting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Layer 2 addresses:**'
  prefs: []
  type: TYPE_NORMAL
- en: Representation and manipulation MAC addresses and EUI-64 identifiers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Looking up IEEE organisational information (OUI, IAB)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating derived IPv6 addresses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Netaddr installation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The netaddr module can be installed using pip, as shown in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'As a verification for successfully installing the module, you could open PyCharm
    or the Python console and import the module after installation. If there is no
    error produced, then the module installed successfully:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Exploring netaddr methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `netaddr` module provides two important methods to define the IP address
    and work on it. The first one is called `IPAddress()` and it's used to define
    a single classful IP address with the default subnet mask. The second method is
    `IPNetwork()` and is used to define classless a IP address with CIDR.
  prefs: []
  type: TYPE_NORMAL
- en: Both methods take the IP address as a string and return an IP address or IP
    network object for this string. There are many operations that could be executed
    on the returned object. For example, we can check if the IP address is unicast,
    multicast, loopback, private, public, or even valid or not valid. The output of
    the previous operation is either `True` or `False`, which can be used inside Python
    `if` conditions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, the module supports comparison operations such as `==`, `<`, and `>`
    to compare two IP addresses, generating the subnets, and it is also possible to
    retrieve the list of supernets that a given IP address or subnet belongs to. Finally,
    the `netaddr` module can generate a full list of valid hosts (excluding the network
    IP and network broadcast):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The preceding script first requests the IP address and IP network from the user,
    using the `raw_input()` function, then will call two user methods, `check_ip_address()`
    and `operate_on_ip_network()`, and pass the entered values to them. The first
    function, `check_ip_address()`, will check the IP address entered and try to generate
    a report about IP address attributes, such as whether it is a unicast IP, multicast,
    private, or loopback, and will return the output to the user.
  prefs: []
  type: TYPE_NORMAL
- en: The second function `operate_on_ip_network()` takes the IP network and generates
    the network ID, netmask, broadcast, version, information known about this network,
    the IPv6 representation, and finally generates all IP addresses inside this subnet.
  prefs: []
  type: TYPE_NORMAL
- en: It's important to notice that `net.info` will work and generate useful information
    only for public IP addresses, not private.
  prefs: []
  type: TYPE_NORMAL
- en: Notice we need to import the `IP Network` and `IP Address` from the `netaddr`
    module before using them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The script output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00081.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Sample use cases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As our network becomes bigger and starts to contain many devices from different
    vendors, we need to create modular Python script to automate various tasks in
    it. In the following sections, we will explore three use cases, which could be
    used to collect different information from our network and to lower the time needed
    for troubleshooting a problem, or at least restore the network configuration to
    its last known good state. This will allow network engineers to focus more on
    getting their job done and will provide an automated workflow for the business
    to handle network failure and restoration.
  prefs: []
  type: TYPE_NORMAL
- en: Backup device configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Backup device configuration is one of the most important tasks for any network
    engineer. In this use case, we will design a sample python script that can be
    used for different vendors and platforms in order to back up the device configuration.
    We will leverage the `netmiko` library to do this task.
  prefs: []
  type: TYPE_NORMAL
- en: The result files should be formatted with the device IP address in them for
    easy access or referencing later. For example, the result file for the SW1 backup
    operation should be `dev_10.10.88.111_.cfg`.
  prefs: []
  type: TYPE_NORMAL
- en: Building the python script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will start by defining our switches. We want to back up their configuration
    as a text file and provide the credentials and access details separated by commas.
    This will allow us to use the `split()` function inside the python script to get
    the data and use it inside the `ConnectHandler` function. Also, the file can be
    easily exported and imported from a Microsoft Excel sheet or from any database.
  prefs: []
  type: TYPE_NORMAL
- en: 'The file structure is:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<device_ipaddress>,<username>,<password>,<enable_password>,<vendor>`'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00082.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now we will start building our Python script by importing the file inside it,
    using the `with open` clause. We use the `readlines()` on the file to have each
    line as an item inside a list. We will create a `for` loop to iterate over each
    line and use the `split()` function to get the access details separated by commas
    and assign them to variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: As we need to create a modular and multi-vendor script, we need to have the `if`
    clause check the vendor in each line and assign a correct `device_type` and `backup_command`
    to the current device.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving on, we are now ready to establish the SSH connection to the device and
    execute the backup command on it using the `.send_command()` method available
    inside the `netmiko` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In the last few statements, we opened a file for writing and made its name contain
    the `ipaddr` variable collected from our text file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The script output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00083.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Also, notice the backup configuration files are created in the project home
    directory, and its name contains the IP address of each device:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00084.jpeg)You can design a simple cron job on a Linux server
    or schedule a job on a Windows server, which runs the previous python script at
    a specific time. For example, the script could run on a daily basis at midnight
    and store the configuration in the `latest` directory so the team could refer
    to it later.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating your own access terminal
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Python, and programming in general, you are the vendor! You can create any
    code combination and procedures you like in order to serve your needs. In the
    second use case, we will create our own terminal that accesses the router through
    `telnetlib`. By writing a few words in the terminal, it will be translated too
    many commands executed in the network device and return output, which could be
    just printed in the standard output or saved in file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: First, we establish a telnet connection to the router and enter the user access
    details till we reach enable mode. Then we create an infinite `while` loop that
    is always `true`, and we expect a command from the user using the `raw_input()`
    built-in function. When the user enters any command, the script will capture it
    and execute it directly to the network device.
  prefs: []
  type: TYPE_NORMAL
- en: However, if the user enters `health` or `discover` keywords then our terminal
    will be smart enough to execute a series of commands to reflect the desired operation.
    This should be extremely useful in case of network troubleshooting, and you can
    extend it with any daily operation. Imagine that you need to troubleshoot OSPF
    neighbourship problems between two routers. You just need to open your own terminal
    python script that you already taught him few commands needed for troubleshooting,
    and write something like `tshoot_ospf`. Once your script sees this magic keyword
    it will launch a series of multiple commands that print the OSPF neighborship
    status, interfaces of MTU, advertised network under OSPF, and so on till you find
    the issue.
  prefs: []
  type: TYPE_NORMAL
- en: '**Script output:**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Try the first command in our script by writing `health` in the prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00085.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the script returns the output of multiple commands executed
    in the device.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now try the second supported command, `discover`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00086.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This time the script returns the output of discover commands. In later chapters,
    we can parse the returned output and extract the useful information from it.
  prefs: []
  type: TYPE_NORMAL
- en: Reading data from an Excel sheet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Network and IT engineers always use the excel sheet to store information about
    the infrastructure such as IP addresses, the device vendor, and credentials. Python
    support reading the information from an excel sheet and processes it so you can
    use it later during the script.
  prefs: []
  type: TYPE_NORMAL
- en: In this use case, we will use the **Excel Read** (**xlrd**) module to read the
    `UC3_devices.xlsx` file which contains the hostname, IP, username, password, enable
    password and vendor for our infrastructure and use this information to feed the
    `netmiko` module.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Excel sheet will be as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00087.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'First we will need to install the `xlrd` module, using `pip` as we will use
    it to read the Microsoft excel sheet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The XLRD module read the excel workbook and convert the row and columns into
    a matrix. For example, if you need to get the first item on the left, then you
    will need to access row[0][0]. The next item on the right will be row[0][1] and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, when xlrd reads the sheet, it will increase a special counter called
    `nrows` (number of rows) by one each time it reads a row. Similarly, it will increase
    the `ncols` (number of columns) by one each time it reads the columns so you can
    know the size of your matrix via these two parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00088.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: You can provide the file path to `xlrd` using the `open_workbook()` function.
    Then you can access your sheet that contains the data either by using `sheet_by_index()`
    or `sheet_by_name()` functions. For our use case, our data is stored in the first
    sheet (index=0), and the file path is stored under the chapter name. Then we will
    iterate over the rows in the sheet and use the `row()` function to access a specific
    row. The returned output is a list, and we can access any item in it using the
    index.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: More use cases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Netmiko could be used to realize many network automation use cases. It could
    be used for uploading, downloading files from remote devices during upgrade, loading
    configuration from Jinja2 templates, accessing terminal servers, accessing end
    devices, and many more. You can find a list of some useful use cases at [https://github.com/ktbyers/pynet/tree/master/presentations/dfwcug/examples](https://github.com/ktbyers/pynet/tree/master/presentations/dfwcug/examples):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/00089.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we started our practical journey into the network automation
    world with Python. We explored the different tools that are available in python
    to establish a connection to remote nodes with telnet and SSH and executed commands
    on them. Also, we learned how to handle IP addresses and network subnets with
    the help of the `netaddr` module. Finally, we strengthened our knowledge with
    two practical use cases.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will work on the returned output and start to extract
    useful information from it.
  prefs: []
  type: TYPE_NORMAL
