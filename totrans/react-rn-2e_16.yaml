- en: Rendering Item Lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you'll learn how to work with item lists. Lists are a common
    web application component. While it's relatively straightforward to build lists
    using the `<ul>` and `<li>` elements, doing something similar on native mobile
    platforms is much more involved.
  prefs: []
  type: TYPE_NORMAL
- en: Thankfully, React Native provides an item list interface that hides all of the
    complexity. First, you'll get a feel for how item lists work by walking through
    an example. Then, you'll learn how to build controls that change the data displayed
    in lists. Lastly, you'll see a couple of examples that fetch items from the network.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering data collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start with an example. The React Native component you'll use to render
    lists is `FlatList`, which works the same way on iOS and Android. List views accepts
    a `data` property, which is an array of objects. These objects can have any properties
    you like, but they do require a key property. This is similar to the key property
    requirement for rendering `<li>` elements inside of a `<ul>` element. This helps
    the list to efficiently render the list when changes are made to the list data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s implement a basic list now. Here''s the code to render a basic 100-item
    list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Let's walk through what's going on here, starting with the `data` constant.
    This is an array of 100 items in it. It is created by filling a new array with
    100 null values and then mapping this to a new array with the objects that you
    want to pass to `<FlatList>`. Each object has a key property because this is a
    requirement. Anything else is optional. In this case, you've decided to add a
    value property that value be used later or when the list is rendered.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you render the `<FlatList>` component. It's within a `<View>` container
    because list views need a height in order to make scrolling work correctly. The
    `data` and the `renderItem` properties are passed to `<FlatList>`, which ultimately
    determines the rendered content.
  prefs: []
  type: TYPE_NORMAL
- en: 'At first glance, it would seem that the `FlatList` component doesn''t do too
    much. You have to figure out how the items look? Well, yes, the `FlatList` component
    is supposed to be generic. It''s supposed to excel at handling updates, and embeds
    scrolling capabilities into lists for us. Here are the styles that were used to
    render the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here, you're styling each item in your list. Otherwise, each item would be text-only
    and would be difficult to differentiate between other list items. The `container`
    style gives the list a height by setting the `flexDirection` to `column`. Without
    a height, you won't be able to scroll properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see what this thing looks like now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/b1df327b-1ba5-44b7-9a53-88ed9cc2b210.png)'
  prefs: []
  type: TYPE_IMG
- en: If you're running this example in a simulator, you can click and hold down the
    mouse button anywhere on the screen, like a finger, then scroll up or down through
    the items.
  prefs: []
  type: TYPE_NORMAL
- en: Sorting and filtering lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you have learned the basics of `FlatList` components, including how
    to pass them data, let's add some controls to the list that you just implemented
    in the previous section. The `FlatList` component helps you render fixed-position
    content for list controls. You'll also see how to manipulate the data source,
    which ultimately drives what's rendered on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before implementing list control components, it might be helpful to review
    the high-level structure of these components so that the code has more context.
    Here''s an illustration of the component structure that you''re going to implement:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/5b76e388-d516-49b1-8f18-0caa854e062e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here''s what each of these components is responsible for:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ListContainer`: The overall container for the list; it follows the familiar
    React container pattern'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`List`: A stateless component that passes the relevant pieces of state into
    the `ListControls` and the React Native `ListView` component'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ListControls`: A component that holds the various controls that change the
    state of the list'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ListFilter`: A control for filtering the item list'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ListSort`: A control for changing the sort order of the list'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FlatList`: The actual React Native component that renders items'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In some cases, splitting apart the implementation of a list like this is overkill.
    However, I think that if your list needs controls in the first place, you're probably
    implementing something that will stand to benefit from having a well-thought-out
    component architecture.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s drill down into the implementation of this list, starting with
    the `ListContainer` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: If this seems like a bit much, it's because it is. This container component
    has a lot of state to handle. It also has some nontrivial behavior that it needs
    to make available to its children. If you look at it from the perspective of encapsulating
    state, it will be more approachable. Its job is to populate the list with state
    data and provide functions that operate on this state.
  prefs: []
  type: TYPE_NORMAL
- en: 'In an ideal world, child components of this container should be nice and simple
    since they don''t have to directly interface with state. Let''s take a look at
    the `List` component next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This component takes state from the `ListContainer` component as properties
    and renders a `FlatList` component. The main difference here, relative to the
    previous example, is the `ListHeaderComponent` property. This renders the controls
    for your list. What's especially useful about this property is that it renders
    the controls outside the scrollable list content, ensuring that the controls are
    always visible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, notice that you''re specifying your own `ListControls` component as a
    default value for the `controls` property. This makes it easy for others to pass
    in their own list controls. Let''s take a look at the `ListControls` component
    next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This component brings together the `ListFilter` and `ListSort` controls. So,
    if you were to add another list control, you would add it here. Let''s take a
    look at the `ListFilter` implementation now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The filter control is a simple text input that filters the list of items as
    user types. The `onChange` function that handles this comes from the `ListContainer`
    component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the `ListSort` component next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s a look at the resulting list:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/cacc3fa3-ede7-43c6-b429-fb47d99b6a1c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'By default, the entire list is rendered in ascending order. You can see the
    placeholder text **Search** when the user hasn''t provided anything yet. Let''s
    see how this looks when you enter a filter and change the sort order:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/77ef4539-1c12-42fc-a461-30ca2672cb62.png)'
  prefs: []
  type: TYPE_IMG
- en: This search includes items with a 1 in it, and sorts the results in descending
    order. Note that you can either change the order first or enter the filter first.
    Both the filter and the sort order are part of the `ListContainer` state.
  prefs: []
  type: TYPE_NORMAL
- en: Fetching list data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Often, you'll fetch your list data from some API endpoint. In this section,
    you'll learn about making API requests from React Native components. The good
    news is that the `fetch()` API is pollyfilled by React Native, so the networking
    code in your mobile applications should look and feel a lot like it does in your
    web applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start things off, let''s build a mock API for our list items using functions
    that return promises just like `fetch()` does:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'With the mock API function in place, let''s make some changes to the list container
    component. Instead of using local data sources, you can now use the `fetchItems()`
    function to load data from the API mock:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Any action that modifies the state of the list needs to call `fetchItems()`,
    and set the appropriate state once the promise resolves.
  prefs: []
  type: TYPE_NORMAL
- en: Lazy list loading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you'll implement a different kind of list, one that scrolls
    infinitely. Sometimes, users don't actually know what they're looking for, so
    filtering or sorting isn't going to help. Think about the Facebook news feed you
    see when you log into your account; it's the main feature of the application and
    rarely are you looking for something specific. You'll need to see what's going
    on by scrolling through the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this using a `FlatList` component, you need to be able to fetch more
    API data when the user scrolls to the end of the list. To get an idea of how this
    works, you need a lot of API data to work with. Generators are great at this!
    So let''s modify the mock that you created in the previous example so that it
    just keeps responding with new data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'With this in place, you can now make an API request for new data every time
    the end of the list is reached. Well, eventually this will fail when you run out
    of memory, but I''m just trying to show you in general terms the approach you
    can take to implement infinite scrolling in React Native. Here''s what the `ListContainer`
    component looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Each time `fetchItems()` is called, the response is concatenated with the `data`
    array. This becomes the new list data source, instead of replacing it as you did
    in earlier examples. Now, let''s take a look at the `List` component to see how
    to respond to the end of the list being reached:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: If you run this example, you'll see that, as you approach the bottom of the
    screen while scrolling, the list just keeps growing.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about the `FlatList` component in React Native.
    This component is general-purpose in that it doesn't impose any specific look
    for items that get rendered. Instead, the appearance of the list is up to you,
    while the `FlatList` component helps with efficiently rendering a data source.
    The `FlatList` component also provides a scrollable region for the items it renders.
  prefs: []
  type: TYPE_NORMAL
- en: You implemented an example that took advantage of section headers in list views.
    This is a good place to render static content such as list controls. You then
    learned about making network calls in React Native; it's just like using `fetch()`
    in any other web application. Finally, you implemented lazy lists that scroll
    infinitely, by only loading new items after they've scrolled to the bottom of
    what's already been rendered.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you'll learn how to show the progress of things such as
    network calls.
  prefs: []
  type: TYPE_NORMAL
- en: Test your knowledege
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What type of data can the `FlatList` component render?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `FlatList` expects an array of objects. The `renderItem` property takes
    a function that is responsible for rendering each item.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `FlatList` expects an object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It expects a function that returns an iterable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is the `key` property a requirement for each data item that's passed to
    `FlatList`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It isn't a requirement.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So that the list knows how to sort the data values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So that the list can do efficient equality checks that help with the rendering
    performance during list data updates.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you render list controls that stay in a fixed position during scrolling?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By passing custom control components as children of `FlatList`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can use the `ListHeaderComponent` property of `FlatList`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can't have statically positioned list controls.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to you lazily load more data as the user scrolls through your list?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can provide a function to the `onEndReached` property of `FlatList`. This
    is called when the user nears the end of the list and the function can populate
    the list data with more data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You have to extend the `FlatList` class and respond to scroll events to figure
    out whether the end of the list has been reached yet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Take a look at the following link for more information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://facebook.github.io/react-native/docs/flatlist](https://facebook.github.io/react-native/docs/flatlist)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
