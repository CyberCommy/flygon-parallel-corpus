- en: Build a Personal Shopping List Application Using Context API and Hooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: State management is a very important part of modern web and mobile applications
    and is something that React is very good at. Handling state management in React
    applications can be quite confusing, as there are multiple ways you can handle
    the current state of your application. The projects you created in the first four
    chapters of this book haven't been focusing on state management too much, something
    that will be investigated much more in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will show how you can handle state management in React, by creating
    a global state for your application that is accessible from every component. Before
    React v16.3, you needed third-party packages to handle global state in React, but
    with the renewed version of the context API, this is no longer mandatory. Also,
    with the release of React Hooks, more ways to mutate this Context were introduced.
    Using an example application, the methods to handle global state management for
    your application are demonstrated.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the context API for state management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Higher-Order Components** (**HOC**) and Context'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mutating Context with Hooks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Project overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will create a **Progressive Web App** (**PWA**) with declarative
    routing using `react-router`, which handles global state management using Context
    and React Hooks. Also, HOC is used to access data throughout the application.
  prefs: []
  type: TYPE_NORMAL
- en: Build time is 2.5 hours.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The project that we''ll create in this chapter builds upon an initial version
    that you can find on GitHub: [https://github.com/PacktPublishing/React-Projects/tree/ch5-initial](https://github.com/PacktPublishing/React-Projects/tree/ch5-initial).
    The complete source code can also be found on GitHub: [https://github.com/PacktPublishing/React-Projects/tree/ch5](https://github.com/PacktPublishing/React-Projects/tree/ch5).'
  prefs: []
  type: TYPE_NORMAL
- en: After downloading the initial application, make sure that you run `npm install` from
    the project's root directory. This project is created using Create React App and
    installs the `react`, `react-dom`, `react-scripts`, `styled-components`, and `react-router` packages,
    which you've already seen in previous chapters. After finishing the installation
    process, you can run `npm start` from the same tab in Terminal and view the project
    in your browser (`http://localhost:3000`).
  prefs: []
  type: TYPE_NORMAL
- en: As the project is created with Create React App, the service workers are registered
    to have the application run as a PWA. You can check this by running `npm run build` first
    and `serve -s build` once the build process is completed. The build version of
    the application can now be visited at `http://localhost:5000`. In case you visit
    the application on this URL and see a different one, it might be that the built
    version of an application you've created in any of the preceding chapters is still
    being served. This might be due to the browser cache created by a service worker. You
    can clear any previous application from the browser cache by opening Developer
    Tools on your browse and open the Application tab, where you can click on the Clear
    site data button on the Clear Storage section.
  prefs: []
  type: TYPE_NORMAL
- en: To check whether the application is really still available when there is no
    internet connection, you can have the browser simulate an offline situation. The
    option to enable this can be found in the Application tab in the browser's Developer
    Tools. Inside this tab, you can find Service Workers in the menu on the left and,
    after clicking this link, you can select the Offline checkbox on the page that
    appears.
  prefs: []
  type: TYPE_NORMAL
- en: 'The initial application for this section is available at `http://localhost:3000` and
    is a bit more advanced than in any of the previous chapters. When you open the
    application, a screen displaying a header, a subheader, and two lists is being
    rendered. If you, for example, click on the first list that is displayed here,
    a new page will open that displays the items of this list. On this page, you can
    click on the Add List button at the top-right to open a new page, which has a
    form to add a new list and looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/b98a5a77-3dfa-4140-b1a3-10a6c27951ad.png)'
  prefs: []
  type: TYPE_IMG
- en: This form is rendered by the `Form` component and has no functionality yet,
    as you'll add this later on. When you click on the left button, it redirects you
    to the previously visited page, using the `history.goBack` method from `react-router`.
  prefs: []
  type: TYPE_NORMAL
- en: When you try to submit the form to either add a new list or add a new item to
    a list, nothing happens yet. The functionality of these forms will be added in
    this section later on, for which you'll use the context API and React Hooks.
  prefs: []
  type: TYPE_NORMAL
- en: The project is structured in the same manner as with the applications you've
    created before. A distinction between reusable function components in the `components` directory and
    class components in the `containers` directory is made. The class components are
    wrapped with a HOC called `withDataFetching`, which adds data fetching and life
    cycles (`componentDidMount`) to these components.
  prefs: []
  type: TYPE_NORMAL
- en: The `withDataFetching` HOC is a slightly modified version of the HOC you created
    in [Chapter 2](ee5cf0ab-57c2-48bc-8c50-281de22969c5.xhtml), *Creating a Progressive
    Web Application with Reusable React Components*, which was also called `withDataFetching.js`.
    This modified version is a curried component, meaning it takes multiple arguments
    at once. In the case of a HOC, this means that you can't only use a component
    as an argument, but you also need to use the props for this component as an argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an overview of the complete structure of the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The entry point of this application is the `src/index.js` file that renders
    the `App` class component within a `Router` component from `react-router`. The `App` component contains
    a `Header` component and a `Switch` router component that defines four routes.
    These routes are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/`: Renders `Lists`, with an overview of all of the lists'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/list/:id`: Renders `List`, with an overview of all items from a specific
    list'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/list/:id/new`: Renders `Form`, with a form to add new items to a specific
    list'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The data is fetched from a mock server that was created using the free service, My
    JSON Server, which creates a server from the `db.json` file in the root directory
    of your project in GitHub. This file consists of a JSON object that has two fields, `items` and `lists`,
    which creates multiple endpoints on a mock server. The ones you''ll be using in
    this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`https://my-json-server.typicode.com/<your-username>/<your-repo>/items`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`https://my-json-server.typicode.com/<your-username>/<your-repo>/lists`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `db.json` file must be present in the master branch (or default branch)
    of your GitHub repository for the My JSON Server to work. Otherwise, you'll receive
    a 404 Not Found message when trying to request the API endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: Personal shopping list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you'll build a personal shopping list application that has
    global state management using Context and React Hooks. With this application,
    you can create shopping lists that you can add items to, along with their quantities
    and prices. The starting point of this section is an initial application that
    has routing and local state management already enabled.
  prefs: []
  type: TYPE_NORMAL
- en: Using the context API for state management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: State management is very important, as the current state of the application
    holds data that is valuable to the user. In previous chapters, you've already
    used local state management by setting an initial state in `constructor` and updating
    this with the `this.setState` method. This pattern is very useful when the data
    in the state is only of importance to the component you're setting the state in.
    As passing down the state as props through several components can become confusing,
    you'd need a way to access props throughout your application even when you're
    not specifically passing them as props. For this, you can use the context API
    from React, which is also used by packages you've already used in previous chapters
    such as `styled-components` and `react-router`.
  prefs: []
  type: TYPE_NORMAL
- en: To share state across multiple components, a React feature called Context will
    be explored, starting in the first part of this section.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Context
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you want to add Context to your React application, you can do this by creating
    a new Context with the `createContext` method from React. This creates a Context
    object that consists of two React components, called **Provider** and **Consumer**.
    The Provider is where the initial (and subsequently current) value of the Context
    is placed, which can be accessed by components that are present within the Consumer.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is done in the `App` component in `src/containers/App.js`, as you want
    the Contexts for the lists to be available in every component that is rendered
    by `Route`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by creating a Context for the lists and make it exportable so
    that the list data can be used everywhere. For this, you can create a new file
    called `ListsContextProvider.js` inside a new directory, `src/Context`. In this
    file, you can add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The previous code creates a Provider based on a Context component that is passed
    as a prop and sets a value based on the return from the `withDataFetching` HOC
    that is fetching all of the lists. Using the `children` prop, all of the components
    that will be wrapped inside the `ListsContextProvider` component can retrieve
    the data for the value from a Consumer.
  prefs: []
  type: TYPE_NORMAL
- en: 'This `ListsContextProvider` component and the Context can be imported inside
    your `App` component in `src/containers/App.js`, where it should subsequently
    be placed around the `Switch` component. The `ListsContext` object is also imported,
    as, you can''t create the Consumer later on:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This way, you''re now able to add a Consumer for `ListsContext`, which is nested
    within the `ListsContextProvider` component that holds the Provider for `ListsContext`.
    This Consumer returns the value from the Provider, which contains the list data
    that was fetched before:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'To actually pass this list data to any of the components rendered by `Route`,
    you should change the way the component is passed to the `Route` component. Instead
    of telling `Route` which component to render, you can also use the `RenderProps`
    pattern for React. This pattern refers to a technique for sharing code between
    React components using a prop whose value is a function that returns a component.
    In this case, you want the `Route` component to render a component and not just
    add the `react-router` props to it but also the list data from `ListsContext`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If you now look at the Network tab in the browser''s Developer Tools, you can
    see the API is fetched twice. As the lists are now also being fetched by `ListsContextProvider`,
    the `Lists` component itself doesn''t have to fetch the API anymore as it''s now
    sent as a prop. Therefore, you can make the following changes to `src/containers/Lists.js`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now you've removed the `withDataFetching` HOC from `Lists`, no duplicate requests to
    the API are sent anymore. The data for the lists is fetched from `ListsContextProvider` and
    is passed by `ListsContext.Consumer` to `Lists`. If you open the application in
    the browser by going to `http://localhost:3000/`, you can see the lists are being
    rendered just as before.
  prefs: []
  type: TYPE_NORMAL
- en: 'Something else you can do is to send the list data to the `List` component
    as well, so you could, in the example, display the name of the selected lists
    when you click on a list from the home page:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For this, you use the `RenderProps` pattern again, this time for `Route`, which
    renders `List`. This makes sure `lists` is available and renders the `List` component
    afterward, which also takes all of the `react-router` props:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `List` component in the `src/containers/List.js` file, you can retrieve
    the lists from the props. This array needs to be filtered for the correct `list`
    and the found object contains `title`, which can be added to the `SubHeader` component
    so that it will be displayed on the page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'With these additions, `title` of the current list will now be displayed if
    you visit the project at `http://localhost:3000/list/1`. In the `SubHeader` component,
    the title Daily groceries is now visible, which looks similar to the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/c48fd6c0-648d-4305-8e55-61d57a15c80b.png)'
  prefs: []
  type: TYPE_IMG
- en: In the next section, you'll also add a Context object for the items, so the
    items are also available to all of the components within the `Switch` component
    from `react-router`.
  prefs: []
  type: TYPE_NORMAL
- en: Nesting Context
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Just as for the list data, the item data could also be stored in Context and
    passed to the components that need this data. That way, data is no longer fetched
    from any of the rendered components but from the `ContextProvider` components
    in the `src/Providers` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, start by creating a new component where both a Context and Provider
    are created. This time, it''s called `ItemsContextProvider`, which can also be
    added to the `src/Context` directory in a file called `ItemsContextProvider.js`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, import this new Context and `ContextProvider` in `src/containers/App.js`,
    where you can nest this inside the `ListsContextProvider` component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '`ItemsContextProvider` is now nested below `ListsContextProvider`, which means
    `Consumer` for `ItemsContext` can also be nested below `Consumer` for `ListsContext`.
    This makes the value from `ItemsContextProvider` available to the `List` component
    that uses the `RenderProps` pattern:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'After the item data is passed as a prop to `List`, this can now be used to
    replace the data fetching that is already in place using the `withDataFetching`
    HOC. To accomplish this, you need to make the following changes to `src/containers/List.js`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: All of the data fetching is now no longer by the `List` and `Lists` components.
    By nesting these Context Providers, the return values can be consumed by multiple
    components. But this still isn't ideal, as you're now loading all of the lists
    and all of the items when starting your application.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you'll see how to get only the data you need by combining
    Context with Hooks.
  prefs: []
  type: TYPE_NORMAL
- en: Mutating context with Hooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are multiple ways in which you can get data conditionally from the Context;
    one of these is placing the data from the Context in the local state. That could
    be a solution for a smaller application but can be inefficient for larger applications,
    as you'd still need to pass this state down your component tree. Another solution
    is using React Hooks to create a function that is added to the value of your Context
    and can be invoked from any of the components that are nested in this Context.
    Also, this method of getting the data prevents you from efficiently loading only
    the data that you'd need.
  prefs: []
  type: TYPE_NORMAL
- en: How this can be used together with React life cycles and state management using
    Hooks is demonstrated in the first part of this section.
  prefs: []
  type: TYPE_NORMAL
- en: Using life cycles in functional components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the many great additions that came with Hooks is making life cycles
    available in functional components. Before Hooks, only class components supported
    life cycles using to the container components pattern and the `withDataFetching` HOC you''ve
    used so far. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step in achieving this is by moving the function to do data fetching
    from the `withDataFetching` HOC to the Provider for the lists, in the `src/Context/ListsContextProvider.js` file.
    This function will take `dataSource` (which could be a file or an API) and uses
    `fetch` to retrieve data from this source:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'With this function in place, the next step would be to invoke it with `dataSource`
    and add the data to the Provider. But where should you store the data that is
    returned by `dataSource`? Before, you''ve used the `componentDidMount` life cycle
    method for this and added the results from the source to the local state. With
    Hooks, you can use local state management inside a function component with the
    `useState` Hook. You can pass the initial value for the state, which you set in `constructor` before,
    as an argument to this Hook. The returned value will be an array consisting of
    the current value for this state and a function to update this state. Also, Hooks
    should always be created inside the component in which it''s used—in this case,
    inside `ListsContextProvider`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code block, you can see the initial value for the state is
    an empty array, which is passed to the Provider for `ListsContext`. To fill this
    state with data from `dataSource`, you need to actually invoke the `fetchData` function.
    Normally, this would be done inside a `componentDidMount` or `componentDidUpdate` life
    cycle method, but as a component is a function component, you''re using a Hook
    instead. This Hook is called `useEffect` and is used to handle side effects, either
    when the application mounts or when the state or a prop gets updated. This Hook
    takes two parameters, where the first one is a callback and the second one is
    an array containing all of the variables this Hook depends on. When any of these
    changes, the callback for this Hook will be called. When there are no values in
    this array, the Hook will only be called on the first mount. After the data is
    fetched from the source, the state will be updated with the results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: You can see the `fetchData` function isn't invoked directly but is wrapped inside
    a function called `asyncFetchData`. As `async/await` from the `fetchData` function
    would return `Promise`, you'd need another `async/await` to retrieve the values
    and resolve `Promise`. However, you can't use `async/await` directly with the
    `useEffect` Hook. The array block after the callback from the `useEffect` Hook
    is called the dependency array, and in here the values that are used in the Hook
    are defined. The functions `fetchData` and `setLists` are created on the first
    mount of this component, meaning the `useEffect` Hook mimics a lifecycle that's
    comparable to `componentDidMount`. If you want to use this Hook as a `componentDidUpdate` life
    cycle method, the array would consist of all of the state variables and props
    that should be watched for updates.
  prefs: []
  type: TYPE_NORMAL
- en: By using other Hooks, you can also directly pass data to the Provider, without
    having to use local state management. This will be demonstrated in the next part
    of this section.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the Provider with a Flux pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another way to use actions to add data to the Provider is by using a pattern
    similar to Flux, which was introduced by Facebook. The Flux pattern describes
    a data flow where actions are being dispatched that retrieve data from a store
    and return it to the view. This would mean that actions need to be described somewhere;
    there should be a global place where data is stored and this data can be read
    by the view. To accomplish this pattern with the context API, you can use another
    Hook that is called `useReducer`. This Hook can be used to return data not from
    a local state, but from any data variable:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Just as with the `useState` Hook, the `useReducer` Hook needs to be added to
    the component that is using it. `useReducer` will take an initial value and a
    function that determines which data should be returned. This initial value needs
    to be added to the `src/Context/ListsContextProvider.js` file before adding the
    Hook:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Next to `initialValue`, the `useReducer` Hook also takes a function that''s
    called `reducer`. This `reducer` function should also be created and is a function
    that updates `initialValue`, which was passed and returns the current value, based
    on the action that was sent to it. If the action that was dispatched doesn''t
    match any of those defined in `reducer`, the reducer will just return the current
    value without any changes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The two parameters for the `useReducer` Hook are now added to the file, so
    you need to add the actual Hook and pass `initialValue` and `reducer` to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, `reducer` changes the value it returns when the `GET_LISTS_SUCCESS`
    or `GET_LISTS_ERROR` action is sent to it. Before it was mentioned, you can call
    this `reducer` by using the `dispatch` function that was returned by the `useReducer` Hook.
    However, as you also have to deal with the asynchronous fetching of the data,
    you can''t invoke this function directly. Instead, you need to create an `async/await`
    function that calls the `fetchData` function and dispatches the correct action
    afterward:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: With the preceding `getListsRequest` function, an `async/await` call to the
    `fetchData` function is made when this function is invoked. If the data that was
    returned by `dataSource` is not an empty array, the `GET_LISTS_SUCCESS` action
    will be dispatched to the reducer using the `dispatch` function from the `useReducer` Hook.
    If not, the `GET_LISTS_ERROR` action will be dispatched, which returns an error
    message.
  prefs: []
  type: TYPE_NORMAL
- en: 'This `getListsRequest` function can now be invoked from the `useEffect` Hook
    when your application mounts, so the application will be filled with the list
    data. This should be done from the view, so you need to create an action that
    you can add to `Provider`, so it can be used from any of the components that get
    this value from `Consumer`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In the component where the lists are displayed, the `Lists` component, you
    can retrieve the data for the lists with the `getListsRequest` function. Therefore,
    you''d need to pass it to this component from `RenderProps` in `Route`, in the `src/containers/App.js` file.
    Also, you can add a loading indicator that will be displayed when the list data
    isn''t retrieved yet or an error message when some error occurs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, invoke the `getListsRequest` function from the `Lists` component
    when it mounts, and add the loading indicator or error message. The lists should
    only be retrieved when there aren''t any lists available yet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'If you now visit the project in the browser again, you can see the data from
    the lists is loaded just as before. The big difference is that the data is fetched
    using a Flux pattern, meaning this can be extended to fetch the data in other
    instances as well. The same can be done for `ItemsContextProvider` as well, in
    the `src/Context/ItemsContextProvider.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First add the initial value for the items, which you''ll use with the `useReducer` Hook:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'After this, you can add the reducer, which has two actions that are quite similar
    to the ones for the list reducer. The only difference is that they will add information
    about the items to the Provider. Also, add the same `fetchData` function that
    as you added to `ListsContextProvider`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can create the `async/await` function that will fetch `dataSource`
    for the items. This function will also take the `id` variable of the list that
    is selected, so no over-fetching of data will occur. The `withDataFetching` HOC
    can be removed, as it''s no longer needed to retrieve the data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'As the function to retrieve items is now added to the Provider for the items,
    the Consumer is `src/containers/App.js` and can pass this function to the `List`
    component that is displaying the items:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, call this `getItemsRequest` function from the `List` component
    in `src/containers/List.js`. This function will take the `id` variable for the
    list that you are displaying from the current route, by using the `match` prop.
    It''s important to mention that this function should only be called when the value
    for `items` is empty, to prevent unnecessary data fetching:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'You might notice that the title of the list won''t be displayed any longer
    when you refresh the page. The information for the lists is only fetched when
    the `Lists` component is mounted, so you''d need to create a new function to always
    fetch the information for the list that you''re currently displaying in the `List` component:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `src/Context/ListsContextProvider.js` file, you need to extend `initialValue` to
    also have a field called `list`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'In `reducer`, you now also have to check for two new actions that either add
    the data about a list to the context or add an error message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'These actions will be dispatched from an `async/await` function that calls `dataSource`
    with a specific `id`. If successful, the `GET_LIST_SUCCESS` action will be dispatched;
    otherwise, the `GET_LIST_ERROR` action is dispatched. Also, pass the function
    to the Provider so that it can be used from the `List` component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'And pass this to the `List` component, by destructuring it from the `ListsContext`
    Consumer. Also, take the list data from this Consumer and pass it to the `List` component.
    The `lists` props can be removed from this component, as filtering the list data
    is now done by `ListsContextProvider`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, you can invoke the `getListRequest` function that fetches the list
    data from the `List` component. You only want to retrieve the list information
    when this isn''t already available; the filtering of the `lists` prop is therefore
    no longer needed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: All of the data in your application is now being loaded using the Providers,
    which means it's now detached from the views. Also, the `withDataFetching` HOC is
    completely removed, making your application structure more readable.
  prefs: []
  type: TYPE_NORMAL
- en: Not only can you use the context API with this pattern to make data available
    to many components, but you can also mutate the data. How to mutate this data
    will be shown in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Mutating data in the Provider
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Not only can you retrieve data using this Flux pattern, but you can also use
    it to update data. The pattern would remain the same: you dispatch an action that
    would trigger the request to the server and, based on the outcome, the reducer
    will mutate the data with this result. Depending on whether or not it was successful,
    you could display a success message or an error message.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The code already has a form for adding a new item to a list—something that
    is not working yet. Let''s create the mechanism to add items by updating the Provider
    for `items`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to create a new function that can handle `POST` requests,
    as this function should also set the method and a body when handling the `fetch` request.
    You can create this function in the `src/Context/ItemsContextProvider.js` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This function takes not only `dataSource` but also information that will be
    posted to this source. Just as for retrieving the items, a case can be added to
    the `switch` statement in `reducer`. This time, it will look for an action that
    is called `ADD_ITEM_REQUEST`, which has a payload consisting of `dataSource` and `content`
    that should be added to the value. These actions change the value for `loading` and/or
    `error` and spread the actual current value in its return as well. If you don''t
    do this, all of the information that is already available about the lists will
    be cleared:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The mock API from My JSON Server doesn't persist data once it is added, updated,
    or deleted with a request. However, you can see whether the request was successful
    by checking the request in the Network tab in the Developer Tools of your browser.
    That's why the input content is spread over the value for `items`, so this data
    is available from the Consumer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, create an `async/await` function that handles the `POST` request. If
    this request is successful, the data that will be returned has a field called
    `id`. So, when this is the case, the `ADD_ITEM_SUCCESS` action can be dispatched.
    Otherwise, an `ADD_ITEM_ERROR` action is dispatched. These actions will change
    the value for this Provider from `reducer`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Just as for retrieving the list, the `actionDispatch` function for adding a
    list can be wrapped inside a helper function. This function would take the content
    that is returned from the form later on. Also, pass this function to the Provider
    so that it can be used in any of the components that consume this Provider:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'As the function to add a list is now available from the Provider, you can pass
    it to the `Form` component by using `RenderProps` from its `Route`. This can be
    done in the `src/containers/App.js` file. Make sure you don''t forget to send
    the `match` and `history` props as well, as these are used by the `Form` component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The `Form` component is now able to use the `addListRequest` function that will
    dispatch the action that triggers the `POST` request that will add an item to
    `dataSource`. This function needs to be triggered when the user submits the form.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, the values of the input fields in the form need to be determined first.
    Therefore, the input fields need to be controlled components, meaning their value
    is controlled by the local state that encapsulates the value:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For this, you can use the `useState` Hook, and call it for every `state` value
    that you want to create. The Hook will return both the current value of this `state`
    value and a function to update this value and must be added in `src/containers/Form.js`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The local state values and the function that triggers an update of the local
    `state` values must be set as a prop on the `FormItem` components:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The `FormItem` component, in the `src/components/FormItem.js` file, can take
    these props and have the input field invoke the `handleOnChange` function. The
    element''s current `target` value must be used as the parameter for this function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing you need to do now is to add a function that will be dispatched
    when the form is submitted by clicking the submit button. This function takes
    `value` for the local `state`, adds information about the list and a randomly
    generated `id` and uses this to call the `addItemRequest` function. After this
    function is called, the `goBack` function from the `history` prop is called:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: When you now submit the form, a `POST` request to the mock server will be sent.
    You'll be sent back to the previous page where you can see the result. If successful,
    the `GET_LIST_SUCCESS` action was dispatched and the item you inserted was added
    to the list.
  prefs: []
  type: TYPE_NORMAL
- en: So far, the information from the Context has been used only separately by using
    the Providers, but this can also be combined into one global Context, as shown
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a global Context
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you look at the current structure of the routes in your `App` component,
    you can imagine this will get messy if you add more Providers and Consumers to
    your application. State management packages such as Redux tend to have a global
    state where all of the data for the application is stored. When using Context,
    it''s possible to create a global Context that can be accessed using the `useContext` Hook.
    This Hook acts as a Consumer and can retrieve values from the Provider of the
    Context that was passed to it. Let''s refactor the current application to have
    a global Context:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by creating a file called `GlobalContext.js` in the `src/Context` directory.
    This file will import both `ListsContextProvider` and `ItemsContextProvider`,
    nest them, and have them wrap any component that will be passed to it as `children`
    prop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `src/containers/App.js` file, you can now import this `GlobalContext` file
    in favor of the Providers for the lists and items:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'You can replace `ListsContextProvider` and `ItemsContextProvider` with `GlobalContext`.
    The Consumer will still be able to retrieve the data from `ListsContext` and `ItemsContext` if
    you''d still import them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, you can delete the Consumers and the `RenderProps` pattern from the routes.
    The value from the Context will no longer be passed from both the Consumers but
    will be retrieved by using the `useContext` Hooks in each of the routes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'In each of the components that are being rendered by `Route`, the Context that
    you want to use should be imported. The `useContext` Hook can then retrieve the
    value from this Context. You can start by adding this Hook to the `Lists` component
    in `src/containers/Lists.js`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, `useContext` only takes the Context you want to use as an argument.
    To implement this in the `List` component, you''d need to import both `ListsContext`
    and `ItemsContext` in the `src/containers/List.js` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'And do the same for the `Form` component in the `src/containers/Form.js` file,
    where you only use `ItemsContext`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: You can now see that your application has a much cleaner structure, while the
    data is still being retrieved by the Providers.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you've created a shopping list application that uses the context
    API and Hooks to pass and retrieve data, instead of a HOC. Context is used to
    store data and Hooks are used to retrieve and mutate data. With the context API,
    you can create more advanced scenarios for state management using the `useReducer` Hook.
    Also, you've recreated a situation where all of the data is stored globally and
    can be accessed from any component by creating a shared Context.
  prefs: []
  type: TYPE_NORMAL
- en: The context API will be used in the next chapter as well, which will show you
    how to build a hotel review application with automated testing using libraries
    such as Jest and Enzyme. It will introduce you to the multiple ways you can test
    your UI components created with React, and also show you how to test state management
    in your application using the context API.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Consuming multiple Context objects: [https://reactjs.org/docs/Context.html#consuming-multiple-Contexts](https://reactjs.org/docs/Context.html#consuming-multiple-Contexts)
  prefs: []
  type: TYPE_NORMAL
