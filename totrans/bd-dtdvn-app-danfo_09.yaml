- en: '*Chapter 7*: Data Aggregation and Group Operations'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`groupby` operations (aggregations or transformations) to the grouped data
    to produce a new set of values. The resulting values are then combined into a
    single data group.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This approach is popularly known as **split-apply-combine**. The term was actually
    coined by Hadley Wickham, the author of many popular **R** packages, to describe
    group operations. *Figure 7.1* describes the idea of split-apply-combine graphically:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1 – groupby illustration'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_07_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.1 – groupby illustration
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we look into ways of performing group operations: how to group
    data by column keys and perform data aggregation on grouped data jointly or independently.'
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will also show how to access grouped data by keys. It also gives
    insight into how to create a custom aggregate function for your data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the topics to be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Grouping data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Iterating through grouped data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `.apply` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data aggregation of grouped data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to follow along with this chapter, you should have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A modern browser such as Chrome, Safari, Opera, or Firefox
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Node.js**, **Danfo.js**, and **Dnotebook** installed on your system'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code for this chapter is available here: [https://github.com/PacktPublishing/Building-Data-Driven-Applications-with-Danfo.js/tree/main/Chapter07](https://github.com/PacktPublishing/Building-Data-Driven-Applications-with-Danfo.js/tree/main/Chapter07).'
  prefs: []
  type: TYPE_NORMAL
- en: Grouping data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Danfo.js only provides the ability to group data by means of values in a specific
    column. For the current version of Danfo.js, the specified number of columns for
    grouping can only be one or two.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will show how to group by single and double columns.
  prefs: []
  type: TYPE_NORMAL
- en: Single-column grouping
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, let''s start by creating a DataFrame and then group it by a single column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code involves the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we create a DataFrame by using an `object` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then make a call to the `groupby` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we specify that the DataFrame should be grouped by column `A`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`df.groupby([''A''])` returns a `groupby` data structure that contains all
    the necessary methods needed for grouping data.'
  prefs: []
  type: TYPE_NORMAL
- en: We can decide to perform our data operations on all the columns grouped by `A`
    or we specify any other column.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding code outputs the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2 – DataFrame'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_07_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.2 – DataFrame
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code, we will see how we can perform some common `groupby`
    operations on the grouped data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the `groupby_df` operations created in the preceding code snippet, we
    make a call to the `groupby` `mean` method. This method calculates the mean per
    group as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.3 – groupby DataFrame'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_07_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.3 – groupby DataFrame
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure shows the operation of the preceding code graphically
    and how the preceding table output is generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.4 – Graphical depiction of the groupby method'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_07_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.4 – Graphical depiction of the groupby method
  prefs: []
  type: TYPE_NORMAL
- en: Based on the split-apply-combine method that we discussed at the beginning of
    this chapter, `df.groupby(['A'])` groups the DataFrame into two keys – `foo` and
    `bar`.
  prefs: []
  type: TYPE_NORMAL
- en: With the DataFrame grouped into `foo` and `bar` keys, the values in other columns
    (`C` and `D`) are assigned to each of these keys respectively based on their row
    alignment. To nail this point, if we pick the `bar` key, from *Figure 7.2*, we
    can see that column `C` has three data points (`3`, `4`, `2`) in the `bar` rows.
  prefs: []
  type: TYPE_NORMAL
- en: Hence, if we were to perform a data aggregation operation, such as calculating
    the mean of the data assigned to the `bar` key, the data point belonging to column
    `C` assigned to the `bar` key will have a mean of `3`, which corresponds to the
    table in *Figure 7.3*.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The same operation as described in the preceding paragraph occurs for the `foo`
    key and all other data points are assigned
  prefs: []
  type: TYPE_NORMAL
- en: 'As I said before, this call to the group mean method is applied to all the
    columns grouped by `A`. Let''s choose a column to which we would like to specifically
    apply the group operation, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we make a call to the `col` method in `groupby`. This method takes in
    an array of column names. The main purpose of the preceding code is to obtain
    the sum of column `C` for each of the grouped keys (`foo` and `bar`) and this
    gives the following table output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.5 – The groupby operation on column C'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_07_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.5 – The groupby operation on column C
  prefs: []
  type: TYPE_NORMAL
- en: 'The same operation can be applied to any other column in the grouped data,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This code snippet follows the same approach as the preceding code, just that
    the `count` `groupby` operation is applied to column `D`, which gives us the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.6 – The groupby "count" operation on column D'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_07_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.6 – The groupby "count" operation on column D
  prefs: []
  type: TYPE_NORMAL
- en: A DataFrame can also be grouped by two columns; the operation shown for single-column
    grouping is also applicable to two-column grouping, as we will see in the next
    sub-section.
  prefs: []
  type: TYPE_NORMAL
- en: Double-column grouping
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, let''s create a DataFrame and add an extra column as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We added an extra column, `B`, which contains categoric data – `one`, `two`,
    and `three`. The DataFrame is grouped by columns `A` and `B`, as shown in the
    following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.7 – DataFrame including column B'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_07_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.7 – DataFrame including column B
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also calculate the mean as shown with the single-column grouping, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This applies the mean to columns `C` and `D` based on the group key of columns
    `A` and `B`. For example, in *Figure 7.7*, we can see that we have a group key
    from columns `A` and `B` named (`foo`, `one`). This key occurs twice in the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding code outputs the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.8 – The groupby mean of the groupby A and B DataFrame'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_07_08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.8 – The groupby mean of the groupby A and B DataFrame
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 7.7*, column `C` has the values `1` and `6` belonging to the (`foo`,
    `one`) key. Also, `D` has the values `3` and `7` belonging to the same key. If
    we were to take the mean, we would see that it corresponds to the first column
    in *Figure 7.8*.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also go ahead and obtain the sum for one of the columns grouped by columns
    `A` and `B`. Let''s choose column `C`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We obtained column `C` from the grouped data and then calculated the sum per
    the group keys, as shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.9 – Sum of column C per group'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_07_09.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.9 – Sum of column C per group
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we saw how we can group data by single or double columns. We
    also looked into performing data aggregation and accessing column data of a grouped
    DataFrame. In the next section, we'll look into how to access grouped data per
    grouped keys.
  prefs: []
  type: TYPE_NORMAL
- en: Iterating through grouped data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will see how to access grouped data based on grouped keys,
    loop through this grouped data, and perform data aggregation operations on it.
  prefs: []
  type: TYPE_NORMAL
- en: Iterating through single- and double-column grouped data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will see how Danfo.js provides the means of iterating through
    each of the groups created during the `groupby` operations. This data is grouped
    by the keys contained in the `groupby` column.
  prefs: []
  type: TYPE_NORMAL
- en: The keys are stored as a dictionary or object in a class attribute called `data_tensors`.
    This object contains the grouped key as its keys and also stores the DataFrame
    data associated with the keys as the object values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the previous DataFrame, let''s group by column `A` and then iterate through
    `data_tensors`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We group the DataFrame by column `A` and then print out `data_tensors,` as
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.10 – data_tensors output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_07_10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.10 – data_tensors output
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 7.10* contains more detailed information about what the `data_tensors`
    attribute contains, but the whole content can be summarized into the following
    structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The keys are the values of column `A` and the values for the keys are the DataFrame
    associated with these keys.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can iterate through `data_tensors` and print out the `DataFrame` table to
    see what they contain, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we access `data_tensors`, which is a `groupby` class attribute, and
    assign it to a variable called `grouped_data`. We then loop through `grouped_data`,
    access each of its keys, and print their corresponding DataFrame as a table, as
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.11 – groupby keys and their DataFrame'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_07_11.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.11 – groupby keys and their DataFrame
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, we can apply this same approach, as shown in the preceding code, to data
    grouped by two columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are the steps we followed in the preceding code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: First of all, the `df` DataFrame is grouped by two columns (`A` and `B`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We assign `data_tensors` to a variable called `grouped_data`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We loop through `grouped_data` to obtain the keys.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We loop through the `grouped_data` object and also loop through its inner object
    (`key_data`) per key, due to the object data format generated for `grouped_data`,
    as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The code snippet gives us the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.12 – The output of a two-column grouping of a DataFrame'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_07_12.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.12 – The output of a two-column grouping of a DataFrame
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we went through how to iterate through grouped data. We saw
    how the object format for `data_tensor` varies by how the data is being grouped,
    either by single or double columns.
  prefs: []
  type: TYPE_NORMAL
- en: We saw how to iterate `data_tensor` to obtain the keys and their associated
    data. In the next sub-section, we will see how we can obtain the data associated
    with each key without looping through `data_tensor` manually.
  prefs: []
  type: TYPE_NORMAL
- en: Using the get_groups method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Danfo.js provides a method called `get_groups()` that enables easy access to
    each of the key-value DataFrames without looping through the `data_tensors` object.
    This is handy whenever we need to access particular data belonging to a set of
    key combinations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with a single-column grouping, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We group by column `A`, and then make a call to the `get_groups` method. The
    `get_groups` method takes in a key combination as an array.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a single-column grouping, we only have a single key combination. Hence,
    we pass in one of the keys called `foo` and then print out the corresponding grouped
    data, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.13 – get_groups of the foo key'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_07_13.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.13 – get_groups of the foo key
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, the same thing can be applied to all other keys as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code gives us the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.14 – get_groups for the bar key'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_07_14.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.14 – get_groups for the bar key
  prefs: []
  type: TYPE_NORMAL
- en: 'The same approach as shown for the single-column, `groupby` is also applicable
    to two-column grouping:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember that the `get_groups` method takes in the combination of keys as an
    array. Hence, for two-column grouping, we pass in the key combination of columns
    `A` and `B` that we want. Therefore, we obtain the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.15 – Obtaining a DataFrame for the foo key and one combination'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_07_15.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.15 – Obtaining a DataFrame for the foo key and one combination
  prefs: []
  type: TYPE_NORMAL
- en: 'The same thing can be done for any other key combination. Let''s try for the
    `bar` and `two` keys, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We obtain the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.16 – DataFrame for the bar and two keys'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_07_16.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.16 – DataFrame for the bar and two keys
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we went through how to iterate grouped data, data grouped by
    either single or double columns. We also saw how the internal `data_tensor` data
    object is formatted based on how the data is being grouped. We also saw how to
    access data associated with each grouped key without looping.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll also look into creating custom data aggregation functions
    by using the `.apply` method.
  prefs: []
  type: TYPE_NORMAL
- en: Using the .apply method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will be using the `.apply` method to create custom data
    aggregation functions that can be applied to our grouped data.
  prefs: []
  type: TYPE_NORMAL
- en: The `.apply` method enables custom functions to be applied to grouped data.
    It is the major function of the split-apply-combine method discussed earlier in
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The `groupby` method implemented in Danfo.js only contains a small set of data
    aggregation methods needed for group data, hence the `.apply` method gives users
    the ability to construct a special data aggregation method from the grouped data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the previous data, we will create a new DataFrame excluding column `B`
    as seen in the previous DataFrame, and then create a custom function that will
    be applied to the grouped data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we group the DataFrame by column `A`, and then proceed
    to create a custom function called `add` that adds the value `2` to all the data
    points in the grouped data.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The parameter to be passed into this function, `add`, and similar functions,
    such as `sub`, `mul`, and `div`, can be either a DataFrame, Series, array, or
    an integer value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding code generates the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.17 – Applying a custom function to group data'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_07_17.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.17 – Applying a custom function to group data
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create another custom function to subtract the minimum value of each
    grouped data from each of the group values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: First, we created a DataFrame containing columns `A`, `B`, `C`, and `D`. Then,
    we grouped the DataFrame by columns `A` and `C`.
  prefs: []
  type: TYPE_NORMAL
- en: A custom function called `subMin` is created to take in grouped data, to obtain
    the minimum values of the grouped data, and to subtract the minimum value from
    each of the data points in the grouped data.
  prefs: []
  type: TYPE_NORMAL
- en: 'This custom function is then applied to the `group_df` grouped data via the
    `.apply` method, hence we obtain the following output table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.18 – The subMin custom apply function'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_07_18.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.18 – The subMin custom apply function
  prefs: []
  type: TYPE_NORMAL
- en: If we look at the table in the preceding figure, we can see that some group
    data only occurs once, such as group data belonging to the `bar` and `two`, `bar`
    and `one`, `bar` and `three`, and `foo` and `three` keys.
  prefs: []
  type: TYPE_NORMAL
- en: The group data belonging to previous key has only one item, hence the minimum
    is also the single value contained in the group; therefore, it has a value of
    `0` for the `C_apply` and `D_apply` columns.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can adjust the `subMin` custom function to only subtract the minimum from
    each value if the key pair has more than one row, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The custom function gives us the following output table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.19 – Custom apply function'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_07_19.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.19 – Custom apply function
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure shows a graphical representation of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.20 – groupby and subMin apply method illustration'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_07_20.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.20 – groupby and subMin apply method illustration
  prefs: []
  type: TYPE_NORMAL
- en: The `.apply` method also gives us the ability to perform a data normalization
    process per group on the data.
  prefs: []
  type: TYPE_NORMAL
- en: In machine learning, we have what we called **standardization**, which involves
    rescaling the data between the range -1 and 1\. This process of standardization
    involves subtracting the mean of the data from the data and then dividing by the
    standard deviation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the preceding DataFrame, let''s create a custom function to apply standardization
    to the data per group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we first group the data by column `A`. We then create
    a custom function called `norm`, which contains the standardization process that
    is being applied to the data, to give the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.21 – Standardizing grouped data'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_07_21.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.21 – Standardizing grouped data
  prefs: []
  type: TYPE_NORMAL
- en: We've seen how to use the `.apply` method to create custom functions for `groupby`
    operations. Hence, we can create custom functions as needed based on the kind
    of operation we want to perform on the data.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll look into data aggregation and how to assign different
    data aggregation operations to different columns of grouped data.
  prefs: []
  type: TYPE_NORMAL
- en: Data aggregation of grouped data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data aggregation involves the process of gathering data and presenting it in
    a summary form, such as showing its statistics. Aggregation itself is the process
    of gathering data for statistical purposes and presenting it as a number. In this
    section, we look at how to perform data aggregation in Danfo.js
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a list of all the available aggregation methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mean()`: To calculate the mean of grouped data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`std()`: To calculate the standard deviation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sum()`: To get the sum of values in a group'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`count()`: To count the total number of values per group'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`min()`: To get the minimum value per group'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`max()`: To get the maximum value per group'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the start of this chapter, we saw how we can call some of the aggregate methods
    listed previously on group data. The `groupby` class also contains a method called
    `.agg`, which allows us to apply different aggregate operations to different columns
    at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: Data aggregation on single-column grouping
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will create a DataFrame and group the DataFrame by a column, and then apply
    two different aggregation methods on different columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We created a DataFrame and then grouped the DataFrame by column `A`. The grouped
    data is then aggregated by calling the `.agg` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `.agg` method takes in an object whose keys are names of columns in the
    DataFrame and the values are the aggregation methods we want to apply to each
    of the columns. In the preceding block of code, we specified the keys to be `C`
    and `D` and the values to be `mean` and `count`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.22 – Aggregation method on group data'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_07_22.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.22 – Aggregation method on group data
  prefs: []
  type: TYPE_NORMAL
- en: We've seen how data aggregation can be done on single-column grouping. Let's
    now see how to perform the same operation on a DataFrame grouped by double columns.
  prefs: []
  type: TYPE_NORMAL
- en: Data aggregation on double-column grouping
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For double-column grouping, let''s apply the same aggregation methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code gives the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.23 – Aggregation method on two-column grouped data'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_07_23.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.23 – Aggregation method on two-column grouped data
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we've seen how we can use the `.apply` method to create a custom
    function for grouped data, and also how to perform joint data aggregation on each
    column of the grouped data. The examples shown here can be extended to any specific
    data and custom functions can be created as desired.
  prefs: []
  type: TYPE_NORMAL
- en: A simple application of groupby on real data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We've seen how to use `groupby` methods on dummy data. In this section, we will
    see how we can use `groupby` to analyze data.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll make use of the popular `titanic` dataset available here: [https://web.stanford.edu/class/archive/cs/cs109/cs109.1166/stuff/titanic.csv](https://web.stanford.edu/class/archive/cs/cs109/cs109.1166/stuff/titanic.csv).
    We will see how we can estimate the average number of people that survive the
    Titanic accident based on their gender and their class.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s read the `titanic` dataset into a DataFrame and output some of its rows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code should output the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.24 – DataFrame table'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_07_24.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.24 – DataFrame table
  prefs: []
  type: TYPE_NORMAL
- en: From the dataset, we want to estimate the average number of people that survived
    based on their sex (the `Sex` column) and their traveling class (the `Pclass`
    column).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows how to estimate the average rate of survival as described
    previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The following table shows the average survival per sex:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.25 – Average rate of survival based on sex'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_07_25.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.25 – Average rate of survival based on sex
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table shows the average survival per class:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.26 – Average rate of survival based on Pclass'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17076_07_26.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.26 – Average rate of survival based on Pclass
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we saw a brief introduction of how to use the `groupby` operation
    to analyze real-life data.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we extensively discussed the `groupby` operation as implemented
    in Danfo.js. We discussed grouping data and mentioned that at the moment, Danfo.js
    only supports grouping by single and double columns; there is a plan to make this
    more flexible in coming versions of Danfo.js. We also showed how to iterate through
    grouped data and access group keys and their associated grouped data. We looked
    at how to obtain grouped data associated with a group key without looping.
  prefs: []
  type: TYPE_NORMAL
- en: We also saw how the `.apply` method gives us the ability to create custom data
    aggregation functions for our grouped data, and finally, we demonstrated how to
    perform different aggregation functions on different columns of grouped data at
    the same time.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter equipped us with the knowledge of grouping our data, and more essentially,
    it introduced us to the internals of Danfo.js. With this, we can reshape the `groupby`
    method to our desired taste and have the ability to contribute to Danfo.js.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will move on to more application basics, including how
    to use Danfo.js to build a data analysis web app, a no-code environment. We will
    also see how to turn Danfo.js methods into React components.
  prefs: []
  type: TYPE_NORMAL
