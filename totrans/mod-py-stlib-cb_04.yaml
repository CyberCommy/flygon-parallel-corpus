- en: Filesystem and Directories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Traversing folders—recursively traversing a path in the filesystem and inspecting
    its contents
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with paths—building paths in a system-independent way
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Expanding filenames—finding all files that match a specific pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting file information—detecting the properties of a file or directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Named temporary files—working with temporary files that you need to access from
    other processes too
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory and disk buffer—spooling a temporary buffer to disk if it's bigger than
    a threshold
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing filename encoding—working with the encoding of filenames
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copying a directory—copying the content of a whole directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Safely replacing a file's content—how to replace the content of a file safely
    in case of failures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Working with files and directories is natural with most software and something
    we, as users, do every day, but as a developer, you will quickly find that it
    can be more complex than expected, especially when multiple platforms have to
    be supported or encodings are involved.
  prefs: []
  type: TYPE_NORMAL
- en: The Python standard library has many powerful tools to work with files and directories.
    At first, it might be hard to spot those across the `os`, `shutil`, `stat`, and `glob`
    functions, but once you are aware of all the pieces, it's clear that the standard
    library provides a great set of tools to work with files and directories.
  prefs: []
  type: TYPE_NORMAL
- en: Traversing folders
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When working with a path in the filesystem, it's common the need to find all
    files contained directly or in subfolders. Think about copying a directory or
    computing its size; in both cases, you will need to fetch the complete list of
    files included in the directory you want to copy, or for which you want to compute
    the size.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The steps for this recipe are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `os.walk` function in the `os` module is meant to traverse a directory
    recursively, its usage is not immediate, but with little effort, we can wrap it
    into a convenient generator of all the contained files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can just iterate over `traverse` and apply whatever operation we need
    on top of it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `os.walk` function navigates the directory and all its subfolders. For
    each directory that it finds, it returns three values: the directory itself, the
    subdirectories it contains, and the files it contains. Then, it will move into
    the subdirectories of the directory it just provided and return the same three
    values for the subdirectory.'
  prefs: []
  type: TYPE_NORMAL
- en: This means that in our recipe, `basepath` is always the current directory that
    is being inspected, `directories` are its subdirectories, and `files` are the
    files that it contains.
  prefs: []
  type: TYPE_NORMAL
- en: By iterating over the list of files contained within the current directory and
    joining their names with the directory path itself, we can get the path of all
    files contained in the directory. As `os.walk` will then move into all the subdirectories,
    we will be able to return all the files that are directly or indirectly within
    the required path.
  prefs: []
  type: TYPE_NORMAL
- en: Working with paths
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python was originally created as a system management language. It was originally
    meant to write scripts for the Unix system, so navigating the disk has always
    been one of the core parts of the language, but in the most recent versions of
    Python, this was extended further with the `pathlib` module, which makes it very
    convenient and easy to build paths that refer to files or directories, without
    having to care about the system we are running on.
  prefs: []
  type: TYPE_NORMAL
- en: Since writing multiplatform software can be bothersome, it's very important
    to have intermediate layers that abstract the conventions of the underlying system
    and allow us to write code that will work everywhere.
  prefs: []
  type: TYPE_NORMAL
- en: Especially when working with paths, the differences between how Unix and Windows
    systems treating paths can be problematic. The fact that one system uses `/` and
    the other `\` to separate the parts of the path is bothersome by itself, but Windows
    also has the concept of drivers while Unix systems don't, so we need something
    that allows us to abstract these differences and manage paths easily.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Perform the following steps for this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `pathlib` library allows us to build paths from the parts that constitute
    it, by properly doing the right thing based on the system you are on:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The interesting part is that the same actions would lead to the same exact
    result on Windows, even though `path.resolve()` would have printed a slightly
    different result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have a `pathlib.Path` instance, we can even move around the filesystem
    by using the `/` operator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The previous code works on both Windows and Linux/macOS and leads to the expected
    result, even though I wrote it on a Unix-like system.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`pathlib.Path` actually builds a different object depending on the system we
    are in. On POSIX systems, it will result in a `pathlib.PosixPath` object, while
    on Windows systems, it will lead to a `pathlib.WindowsPath` object.'
  prefs: []
  type: TYPE_NORMAL
- en: It is not possible to build `pathlib.WindowsPath` on a POSIX system, because
    it's implemented on top of Windows system calls, which are not available on Unix
    systems. In case you need to work with Windows paths on a POSIX system (or with
    POSIX paths on a Windows system), you can rely on `pathlib.PureWindowsPath` and
    `pathlib.PurePosixPath`.
  prefs: []
  type: TYPE_NORMAL
- en: Those two objects won't implement features to actually access the files (read,
    write, link, resolve absolute paths, and so on), but they will allow you to perform
    simple operations that are only related to manipulating the path itself.
  prefs: []
  type: TYPE_NORMAL
- en: Expanding filenames
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the everyday use of our system, we are used to providing paths, such as `*.py`,
    to identify all the Python files, so it's not a surprise that our users expect
    to be able to do the same when they provide one or more files to our software.
  prefs: []
  type: TYPE_NORMAL
- en: Usually, wildcards are expanded by the shell itself, but suppose you are reading
    them from a configuration file or you want to write a tool that clears the `.pyc`
    files (a cache of compiled Python bytecode) in your current project, then the
    Python standard library has what you need.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The steps for this recipe are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`pathlib` is able to perform many operations on the path you provided. One
    of them is resolving wildcards:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'It also supports resolving wildcards recursively:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Getting file information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When users provide a path you really don't know what the path refers to. Is
    it a file? Is it a directory? Does it even exist?
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving file information allows us to fetch details about the provided path,
    such as whether it points to a file and how big that file is.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Perform the following steps for this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using `.stat()` on any `pathlib.Path` will provide most details about a path:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The returned details refer to:'
  prefs: []
  type: TYPE_NORMAL
- en: '`st_mode`: File type, flags, and permissions'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '`st_ino`: Filesystem node storing the file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`st_dev`: Device where the file is stored'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`st_nlink`: Number of references (hyperlinks) to this file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`st_uid`: User owning the file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`st_gid`: Group owning the file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`st_size`: Size of the file in bytes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`st_atime`: Last time the file was accessed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`st_mtime`: Last time the file was modified'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`st_ctime`: Time the file was created on Windows, time the metadata was modified
    on Unix'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we want to see other details, such as whether the path exists or whether
    it''s a directory, we can rely on these specific methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Named temporary files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Usually when working with temporary files, we don't care where they are stored.
    We need to create them, store some content there, and get rid of them when we
    are done. Most of the time, we use temporary files when we want to store something
    that is too big to fit in memory, but sometimes you need to be able to provide
    a file to another tool or software, and a temporary file is a great way to avoid
    the need to know where to store such a file.
  prefs: []
  type: TYPE_NORMAL
- en: In that situation, we need to know the path that leads to the temporary file
    so that we can provide it to the other tool.
  prefs: []
  type: TYPE_NORMAL
- en: That's where `tempfile.NamedTemporaryFile` can help. Like all other `tempfile`
    forms of temporary files, it will be created for us and will be deleted automatically
    as soon as we are done working with it, but different from the other types of
    temporary files, it will have a known path that we can provide to other programs
    who will be able to read and write from that file.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`tempfile.NamedTemporaryFile` will create the temporary file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The fact that the `.name` attribute leads to the full file path on disk allows
    us to provide it to other external programs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Memory and disk buffer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, we need to keep certain data in a buffer, such as a file we downloaded
    from the internet or some data we are generating on the fly.
  prefs: []
  type: TYPE_NORMAL
- en: As the size of such data is not always predictable, is usually not a good idea
    to keep it all in memory.
  prefs: []
  type: TYPE_NORMAL
- en: If you are downloading a big 32 GB file from the internet that you need to process
    (such as decompress or parse), it will probably exhaust all your memory if you
    try to store it into a string before processing it.
  prefs: []
  type: TYPE_NORMAL
- en: That's why it's usually a good idea to rely on `tempfile.SpooledTemporaryFile`,
    which will keep the content in memory until it reaches its maximum size and will
    then move it to a temporary file if it's bigger than the maximum allowed size.
  prefs: []
  type: TYPE_NORMAL
- en: That way, we can have the benefit of keeping an in-memory buffer of our data,
    without the risk of exhausting all the memory, because as soon as the content
    is too big, it will be moved to disk.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Like the other `tempfile` object, creating `SpooledTemporaryFile` is enough
    to make the temporary file available. The only additional part is to provide the
    maximum allowed size, `max_size=`, after which the content will be moved to disk:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`tempfile.SpooledTemporaryFile` has an `internal _file` property that keeps
    the real data stored in a `BytesIO` store until it can fit in memory, and then
    moves it to a real file once it gets bigger than `max_size`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can easily see this behavior by printing the value of `_file` while you
    are writing data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Managing filename encoding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Working with filesystems in a reliable way is not as easy as it might seem.
    Our system must have a specific encoding to represent text and usually that means
    that everything we create is handled in that encoding, including filenames.
  prefs: []
  type: TYPE_NORMAL
- en: The problem is that there is no strong guarantee on the encoding of filenames.
    Suppose you attach an external hard drive, what's the encoding of filenames on
    that drive? Well, it will depend on the encoding the system had at the time the
    files were created.
  prefs: []
  type: TYPE_NORMAL
- en: Usually, to cope with this problem, software tries the system encoding and if
    it fails, it prints some placeholders (have you ever seen a filename full of `?`
    just because your system couldn't understand the name of the file?), which usually
    allows us to see that there is a file, and in many cases even open it, even though
    we might not know how it's actually named.
  prefs: []
  type: TYPE_NORMAL
- en: To make everything more complex, there is a big difference between Windows and
    Unix systems regarding how they treat filenames. On Unix systems, paths are fundamentally
    just bytes; you don't really care about their encoding as you just read and write
    a bunch of bytes. While on Windows, filenames are actually text.
  prefs: []
  type: TYPE_NORMAL
- en: In Python, filenames are usually stored as `str`. They are text that needs to
    be encoded/decoded somehow.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Whenever we process a filename, we should decode it according to the expected
    filesystem encoding. If we fail (because it''s not stored in the expected encoding),
    we must still be able to put it into `str` without corrupting it, so that we can
    open that file even though we can''t read its name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`decode_filename` tries to do two things: first of all, it asks Python what
    the expected filesystem encoding according to the OS is. Once that''s known, it
    tries to decode the provided filename using that encoding. If it fails, it decodes
    it using `surrogateescape`.'
  prefs: []
  type: TYPE_NORMAL
- en: What this actually means is *if you fail to decode it, decode it into fake characters
    that we are going to use just to be able to represent it as text*.
  prefs: []
  type: TYPE_NORMAL
- en: This is really convenient because that way we are able to manage the filename
    as text even thought we don't know its encoding, and when it is encoded back to
    bytes with `surrogateescape`, it will lead back to its original sequence of bytes.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the filename is encoded in the same encoding as our system, it''s easy
    to see how we are able to decode it to `str` and also print it to read its content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'If the encoding is instead one that is not our system encoding (that is, the
    file came from a very old external drive), we can''t really read what''s written
    inside, but we are still able to decode it to strings, so that we can keep it
    in a variable and provide it to any function that might need to work with that
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '`surrogateescape` means being able to tell Python *I don''t care whether the
    data is garbage, just pass the unknown bytes along as they are*.'
  prefs: []
  type: TYPE_NORMAL
- en: Copying a directory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Making copies of a directory's contents is something we can do easily, but what
    if I told you that a tool such as `cp` (the command to copy files on GNU systems)
    is around 1,200 lines of code?
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, the `cp` implementation is not Python-based, it has evolved over
    decades, and it takes care of far more than you probably need, but still rolling
    your own code to copy a directory recursively takes far more than you would expect.
  prefs: []
  type: TYPE_NORMAL
- en: Luckily for us, the Python standard library provides utilities to perform the
    most common operations out of the box and this is one of them.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The steps for this recipe are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `copydir` function can rely on `shutil.copytree` to do most of the work:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can easily use it to copy the contents of any directory and even limit
    it to only the relevant parts. We are going to copy a directory that contains
    three files, out of which we really only want to copy the `.pdf` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Our destination doesn''t currently exist, so it contains nothing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we do `copydir`, it will be created and contains what we expect:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the target directory exists and contains the content we expect:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`shutil.copytree` will retrieve the content of the provided directory through
    `os.listdir`. For every entry returned by `listdir`, it will check whether it''s
    a file or a directory.'
  prefs: []
  type: TYPE_NORMAL
- en: If it's a file, it will copy it through the `shutil.copy2` function (it's actually
    possible to replace the used function by providing a `copy_function` argument),
    if it's a directory, `copytree` itself is called recursively.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ignore` argument is then used to build a function that, once called, will
    return all the files that need to be ignored given a provided pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: So, `shutil.copytree` will copy all the files apart from `ignore_patterns`,
    which will make it skip.
  prefs: []
  type: TYPE_NORMAL
- en: The last `ignore_dangling_symlinks=True` argument ensures that in the case of
    broken `symlinks`, we just skip the file instead of crashing.
  prefs: []
  type: TYPE_NORMAL
- en: Safely replacing file's content
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Replacing the content of a file is a very slow operation. Compared to replacing
    the content of a variable, it's usually a few times slower; when we write something
    to disk, it takes time before it's actually flushed and time before the content
    is actually written to disk. It's not an atomic operation, so if our software
    faces any issues while saving a file, there is a good chance that the file might
    end up being half-written and our users don't have a way to recover the consistent
    state of their data.
  prefs: []
  type: TYPE_NORMAL
- en: There is a pattern commonly used to solve this kind of issue, which is based
    on the fact that writing a file is a slow, expensive, error-prone operation, but
    renaming a file is an atomic, fast, and cheap operation.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You need to perform the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Much like `open` can be used as a context manager, we can easily roll out a
    `safe_open` function that allows us to open a file for writing in a safe way:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Using `safe_open` as a context manager allows us to write to the file pretty
    much like we would normally:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'And the content will be properly saved once we quit the context:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The major difference is that in case of a crash in our software or a system
    failure while we are writing, we won''t end up with a half-written file, but we
    will preserve any previous state of the file. In this example, we crash midway
    through trying to write `Replace the hello world, expect to write some more`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'With a normal `open`, the result would be just `"Replace the hello world, "`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'While using `safe_open`, the file will only contain the new data if the whole
    write process succeeded:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'In all other cases, the file will still retain its previous state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`safe_open` relies on `tempfile` to create a new file where the write operations
    actually happen. Any time we write to `f` in our context, we are actually writing
    to the temporary file.'
  prefs: []
  type: TYPE_NORMAL
- en: Then, only when the context exists (`exc_type` is none in `safe_open.__exit__`),
    we actually swap the old file with the new one we just wrote, using `os.rename`.
  prefs: []
  type: TYPE_NORMAL
- en: If everything works as expected, we should have the new file with all its content
    updated.
  prefs: []
  type: TYPE_NORMAL
- en: If any of the steps fails, we just write some or no data to a temporary file
    and get rid of it through `os.unlink`.
  prefs: []
  type: TYPE_NORMAL
- en: Our previous file, in this case, was never touched and thus still retains its
    previous state.
  prefs: []
  type: TYPE_NORMAL
