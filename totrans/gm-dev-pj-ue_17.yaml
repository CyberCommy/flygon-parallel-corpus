- en: 17\. Remote Procedure Calls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will be introduced to Remote Procedure Calls, which is
    another important multiplayer concept of Unreal Engine 4's Network Framework.
    You'll also learn how to use enumerations in Unreal Engine 4 and how to use bi-directional
    circular array indexing, which is a way to help you iterate arrays in both directions
    and be able to loop around when you go beyond its index limits.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you'll understand how Remote Procedure Calls work
    to make the server and the clients execute logic on one another. You'll also be
    able to expose enumerations to the Unreal Engine 4 editor and use bi-directional
    circular array indexing to cycle through arrays.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we covered some critical multiplayer concepts, including
    the server-client architecture, connections and ownership, roles, and variable
    replication. We also saw how the listen server is quicker to set up compared to
    the dedicated server but is not as lightweight. We used that knowledge to create
    a basic first-person shooter character that walks, jumps, and looks around.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we're going to cover **Remote Procedure Calls** (**RPC**s),
    which is another important multiplayer concept that allows the server to execute
    functions on the clients and vice versa. So far, we've learned variable replication
    as a form of communication between the server and the clients, but that won't
    be enough, because the server might need to execute specific logic on the clients
    that doesn't involve updating the value of a variable. The client also needs a
    way to tell its intentions to the server, so that the server can validate the
    action and let the other clients know about it. This will ensure that the multiplayer
    world is synchronized, and we'll explore this in more detail within this chapter.
    We'll also cover how to use enumerations in Unreal Engine 4, as well as bi-directional
    circular array indexing, which helps you iterate an array in both directions and
    loops around when you go beyond its index limits.
  prefs: []
  type: TYPE_NORMAL
- en: In the first topic, we will be looking at RPCs.
  prefs: []
  type: TYPE_NORMAL
- en: Remote Procedure Calls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve covered variable replication in *Chapter 16*, *Multiplayer Basics*,
    and, while a very useful feature, it is a bit limited in terms of allowing the
    execution of custom code in remote machines (client-to-server or server-to-client)
    for two main reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: The first one is that variable replication is strictly a form of server-to-client
    communication, so there isn't a way for a client to use variable replication to
    tell the server to execute some custom logic by changing the value of a variable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second reason is that variable replication, as the name suggests, is driven
    by the values of variables, so even if variable replication allowed the client-to-server
    communication, it would require you to change the value of a variable on the client
    to trigger a `RepNotify` functionality on the server to run the custom logic,
    which is not very practical.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To solve this problem, Unreal Engine 4 supports RPCs. An RPC works just like
    a normal function that can be defined and called, but instead of executing it
    locally, it will execute it on a remote machine. The main goal of using RPCs is
    to have the possibility to execute specific logic, which is not directly tied
    to a variable, on a remote machine. To be able to use RPCs, make sure you are
    defining them in an actor that has replication turned on.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three types of RPCs, and each one serves a different purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: Server RPC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multicast RPC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Client RPC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s go into detail about these three types and explain when you should use
    them:'
  prefs: []
  type: TYPE_NORMAL
- en: Server RPC
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You use a Server RPC every time you want the server to run a function on the
    actor that has defined the RPC. There are two main reasons why you would want
    to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: The first one is for security reasons because when making multiplayer games,
    especially competitive ones, you always have to assume that the client will try
    to cheat. The way to make sure there is no cheating is by forcing the client to
    execute the functions that are critical to gameplay on the server.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second reason is for synchronicity because since the critical gameplay logic
    is only executed on the server, which means that the important variables are only
    going to be changed there, which will trigger the variable replication logic to
    update the clients whenever they are changed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An example of this would be when a client's character tries to fire a weapon.
    Since there's always the possibility that the client might try to cheat, you can't
    just execute the fire weapon logic locally. The correct way of doing this is by
    having the client call a Server RPC that tells the server to validate the `Fire`
    action by making sure the character has enough ammo and has the weapon equipped,
    and so on. If everything checks out, then it will deduct the ammo variable, and
    finally, it will execute a Multicast RPC (*covered in the next RPC type*) that
    will tell all of the clients to play the fire animation on that character.
  prefs: []
  type: TYPE_NORMAL
- en: Declaration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To declare a Server RPC, you use the `Server` specifier on the `UFUNCTION`
    macro. Have a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the `Server` specifier is used on the `UFUNCTION` macro
    to state that the function is a Server RPC. You can have parameters on a Server
    RPC just like a normal function, but with some caveats that will be explained
    later in this topic, as well as the purpose of the `Reliable` and `WithValidation`
    specifiers.
  prefs: []
  type: TYPE_NORMAL
- en: Execution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To execute a Server RPC, you call it from a client on the actor instance that
    defined it. Take a look at the following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The first code snippet implements the `CallMyOwnServerRPC` function, which calls
    the `ServerMyOwnRPC` RPC function, defined in its own `ARPCTest` class, with an
    integer parameter. This will execute the implementation of the `ServerMyOwnRPC`
    function on the server version of that actor's instance.
  prefs: []
  type: TYPE_NORMAL
- en: The second code snippet implements the `CallServerRPCOfAnotherActor` function,
    which calls the `ServerAnotherActorRPC` RPC function, defined in `AAnotherActor`,
    on the `OtherActor` instance as long as it's valid. This will execute the implementation
    of the `ServerAnotherActorRPC` function on the server version of the `OtherActor`
    instance.
  prefs: []
  type: TYPE_NORMAL
- en: Valid Connection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One important thing to take into consideration when calling a Server RPC from
    a client is that the actor that defines it needs to have a valid connection. If
    you try to call a Server RPC on an actor that doesn't have a valid connection,
    then nothing will happen. You have to make sure that the actor is either a player
    controller, is being possessed by one (*if applicable*), or that its owning actor
    has a valid connection.
  prefs: []
  type: TYPE_NORMAL
- en: Multicast RPC
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You use a Multicast RPC when you want the server to tell all clients to run
    a function on the actor that has defined the RPC.
  prefs: []
  type: TYPE_NORMAL
- en: An example of this would be when a client's character tries to fire a weapon.
    After the client calls the Server RPC to ask permission to fire the weapon and
    the server has handled the request (all validations checked out, the ammo has
    been deducted, and the line trace/projectile was processed), then we need to do
    a Multicast RPC so that all of the instances of that specific character play the
    fire animation. This will ensure that the character will always be playing the
    fire animation independent of which client is looking at the character.
  prefs: []
  type: TYPE_NORMAL
- en: Declaration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To declare a Multicast RPC, you need to use the `NetMulticast` specifier on
    the `UFUNCTION` macro. Have a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the `NetMulticast` specifier is used on the `UFUNCTION`
    macro to say that the following function is a Multicast RPC. You can have parameters
    on a Multicast RPC just like a normal function, but with the same caveats as the
    Server RPC.
  prefs: []
  type: TYPE_NORMAL
- en: Execution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To execute a Multicast RPC, you call it from the server on the actor instance
    that defined it. Take a look at the following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The first code snippet implements the `CallMyOwnMulticastRPC` function, which
    calls the `MulticastMyOwnRPC` RPC function, defined in its own `ARPCTest` class,
    with an integer parameter. This will execute the implementation of the `MulticastMyOwnRPC`
    function on all of the clients' versions of that actor's instance.
  prefs: []
  type: TYPE_NORMAL
- en: The second code snippet implements the `CallMulticastRPCOfAnotherActor` function,
    which calls the `MulticastAnotherActorRPC` RPC function, defined in `AAnotherActor`,
    on the `OtherActor` instance as long as it's valid. This will execute the implementation
    of the `MulticastAnotherActorRPC` function on all of the clients' versions of
    the `OtherActor` instance.
  prefs: []
  type: TYPE_NORMAL
- en: Client RPC
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You use a Client RPC when you want to run a function only on the owning client
    of the actor that has defined the RPC. To set the owning client, you need to call
    Set Owner on the server and set it with the client's player controller.
  prefs: []
  type: TYPE_NORMAL
- en: An example of this would be when a character is hit by a projectile and plays
    a pain sound that only that client will hear. By calling a Client RPC from the
    server, the sound will only be played on the owning client, so the other clients
    won't hear it.
  prefs: []
  type: TYPE_NORMAL
- en: Declaration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To declare a Client RPC, you need to use the `Client` specifier on the `UFUNCTION`
    macro. Have a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the `Client` specifier is used on the `UFUNCTION` macro
    to say that the following function is a Client RPC. You can have parameters on
    a Client RPCs just like a normal function, but with the same caveats as the Server
    RPC and Multicast RPC.
  prefs: []
  type: TYPE_NORMAL
- en: Execution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To execute a Client RPC, you call it from the server on the actor instance
    that defined it. Take a look at the following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The first code snippet implements the `CallMyOwnClientRPC` function, which calls
    the `ClientMyOwnRPC` RPC function, defined in its own `ARPCTest` class, with an
    integer parameter. This will execute the implementation of the `ClientMyOwnRPC`
    function on the owning client's version of that actor's instance.
  prefs: []
  type: TYPE_NORMAL
- en: The second code snippet implements the `CallClientRPCOfAnotherActor` function,
    which calls the `ClientAnotherActorRPC` RPC function, defined in `AAnotherActor`,
    on the `OtherActor` instance as long as it's valid. This will execute the implementation
    of the `ClientAnotherActorRPC` function on the owning client's version of the
    `OtherActor` instance.
  prefs: []
  type: TYPE_NORMAL
- en: Important Considerations When Using RPCs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'RPCs are very useful, but there are a couple of things that you need to take
    into consideration when using them, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Implementation**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation of an RPC differs slightly to that of a typical function.
    Instead of implementing the function as you normally do, you should only implement
    the `_Implementation` version of it, even though you didn''t declare it in the
    header file. Have a look at the following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Server RPC:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, we implement the `_Implementation` version of
    the `ServerRPCTest` function, which uses three parameters.
  prefs: []
  type: TYPE_NORMAL
- en: '**Multicast RPC:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, we implement the `_Implementation` version of
    the `MulticastRPCTest` function, which uses three parameters.
  prefs: []
  type: TYPE_NORMAL
- en: '**Client RPC:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, we implement the `_Implementation` version of
    the `ClientRPCTest` function, which uses three parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see from the previous examples, independent of the type of the RPC
    you are implementing, you should only implement the `_Implementation` version
    of the function and not the normal one, as demonstrated in the following code
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we're defining the normal implementation of `ServerRPCFunction`.
    If you implement the RPC like this, you'll get an error saying that it was already
    implemented. The reason for this is that when you declare the RPC function in
    the header file, Unreal Engine 4 will automatically create the normal implementation
    internally, which will later call the `_Implementation` version. If you create
    your version of the normal implementation, the build will fail because it will
    find two implementations of the same function. To fix this, just make sure to
    only implement the `_Implementation` version of the RPC.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we move to name prefixes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Name Prefix**'
  prefs: []
  type: TYPE_NORMAL
- en: 'In Unreal Engine 4, it''s good practice to prefix RPCs with their corresponding
    types. Have a look at the following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: A `ServerRPCFunction`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `MulticastRPCFunction`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `ClientRPCFunction`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Return Value**'
  prefs: []
  type: TYPE_NORMAL
- en: Since the call and execution of RPCs are typically done on different machines,
    you can't have a return value, so it always needs to be void.
  prefs: []
  type: TYPE_NORMAL
- en: '**Overriding**'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can override the implementation of an RPC to expand or bypass the parent''s
    functionality by declaring and implementing the `_Implementation` function in
    the child class without the `UFUNCTION` macro. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The declaration on the parent class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, we have the declaration of the parent class of
    the `ServerRPCTest` function, which uses one integer parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The overridden declaration on the child class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, we override the declaration of the `ServerRPCTest_Implementation`
    function in the child class header file. The implementation of the function is
    just like any other override, with the possibility of calling `Super::ServerRPCTest_Implementation`
    if you still want to execute the parent functionality.
  prefs: []
  type: TYPE_NORMAL
- en: '**Supported Parameter Types**'
  prefs: []
  type: TYPE_NORMAL
- en: When using RPCs, you can add parameters just like any other function. Currently,
    most common types are supported, including `bool`, `int32`, `float`, `FString`,
    `FName`, `TArray`, `TSet`, and `TMap`. The types that you have to pay more attention
    to are pointers to any `UObject` class or sub-class, especially actors.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you create an RPC with an actor parameter, then that actor also needs to
    exist on the remote machine, or else it will be `nullptr`. Another important thing
    to take into account is that the instance names of each version of the actor can
    be different. That means that if you call an RPC with an actor parameter, then
    the instance name of the actor when calling the RPC might be different than the
    one when executing the RPC on the remote machine. Here is an example to help you
    understand this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.1: The listen server and two clients running'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_17_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 17.1: The listen server and two clients running'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, you can see three clients running (one of them is
    a listen server) and each window is displaying the name of all of the character
    instances. If you look at the Client 1 window, its controlled character instance
    is called `ThirdPersonCharacter_C_0`, but on the Server window, that equivalent
    character is called `ThirdPersonCharacter_C_1`. That means that if Client 1 calls
    a Server RPC and passes its `ThirdPersonCharacter_C_0` as an argument, then when
    the RPC is executed on the server, the parameter will be `ThirdPersonCharacter_C_1`,
    which is the instance name of the equivalent character in that machine.
  prefs: []
  type: TYPE_NORMAL
- en: '**Executing RPCs on the Target Machine**'
  prefs: []
  type: TYPE_NORMAL
- en: You can call RPCs directly on its target machine and it will still execute.
    In other words, you can call a Server RPC on the server and it will execute, as
    well as a Multicast/Client RPC on the client, but in this case, it will only execute
    the logic on the client that called the RPC. Either way, in these cases, you should
    always call the `_Implementation` version directly instead so as to execute the
    logic faster.
  prefs: []
  type: TYPE_NORMAL
- en: The reason for this is that the `_Implementation` version just holds the logic
    to execute and doesn't have the overhead of creating and sending the RPC request
    through the network that the regular call has.
  prefs: []
  type: TYPE_NORMAL
- en: 'Have a look at the following example of an actor that has authority on the
    server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, you have the `CallServerRPC` function that calls `ServerRPCFunction`
    in two different ways. If the actor is already on the server, then it calls `ServerRPCFunction_Implementation`,
    which will skip the overhead as mentioned previously.
  prefs: []
  type: TYPE_NORMAL
- en: If the actor is not on the server, then it executes the regular call by using
    `ServerRPCFunction`, which adds the required overhead of creating and sending the
    RPC request through the network.
  prefs: []
  type: TYPE_NORMAL
- en: '**Validation**'
  prefs: []
  type: TYPE_NORMAL
- en: When you define an RPC, you have the option of using an additional function
    to check whether there are any invalid inputs before the RPC is called. This is
    used to avoid processing the RPC if the inputs are invalid, due to cheating or
    for some other reason.
  prefs: []
  type: TYPE_NORMAL
- en: To use validation, you need to add the `WithValidation` specifier in the `UFUNCTION`
    macro. When you use that specifier, you will be forced to implement the `_Validate`
    version of the function, which will return a Boolean stating whether the RPC can
    be executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Have a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we''ve declared a validated Server RPC called `ServerSetHealth`,
    which takes a float parameter for the new value of `Health`. As for the implementation,
    this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we implement the `_Validate` function, which will check
    whether the new health is less than or equal to the maximum value of the health.
    If a client tries to hack and call `ServerSetHealth` with `200` and `MaxHealth`
    is `100`, then the RPC won't be called, which prevents the client from changing
    the health with values outside a certain range. If the `_Validate` function returns
    `true`, the `_Implementation` function is called as usual, which sets `Health`
    with the value of `NewHealth`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Reliability**'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you declare an RPC, you are required to either use the `Reliable` or `Unreliable`
    specifiers in the `UFUNCTION` macro. Here''s a quick overview of what they do:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Reliable`: Used when you want to make sure the RPC is executed, by repeating
    the request until the remote machine confirms its reception. This should only
    be used for RPCs that are very important, such as executing critical gameplay
    logic. Here is an example of how to use it:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '`Unreliable`: Used when you don''t care whether the RPC is executed due to
    bad network conditions, such as playing a sound or spawning a particle effect.
    This should only be used for RPCs that aren''t very important or are called very
    frequently to update values, since it wouldn''t matter if one call missed because
    it''s updating very often. Here is an example of how to use it:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: For more information on RPCs, please visit [https://docs.unrealengine.com/en-US/Gameplay/Networking/Actors/RPCs/index.html](https://docs.unrealengine.com/en-US/Gameplay/Networking/Actors/RPCs/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: In the next exercise, you will see how to implement different types of RPCs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 17.01: Using Remote Procedure Calls'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we''re going to create a C++ project that uses the `Third
    Person` template and we''re going to expand it in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a fire timer variable that will prevent the client from spamming the fire
    button during the fire animation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a new Ammo integer variable that defaults to `5` and replicates to all of
    the clients.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a `Fire Anim montage` that is played when the server tells the client that
    the shot was valid.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a `No Ammo Sound` that will play when the server tells the client that they
    didn't have sufficient ammo.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every time the player presses the *Left Mouse Button*, the client will perform
    a reliable and validated Server RPC that will check whether the character has
    sufficient ammo. If it does, it will subtract 1 from the Ammo variable and call
    an unreliable Multicast RPC that plays the fire animation in every client. If
    it doesn't have ammo, then it will execute an unreliable Client RPC that will
    play the `No Ammo Sound` that will only be heard by the owning client.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following steps will help you complete the exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new `Third Person` template project using `C++` called `RPC` and save
    it to a location of your choosing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the project has been created, it should open the editor as well as the
    Visual Studio solution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Close the editor and go back to Visual Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the `RPCCharacter.h` file and include the `UnrealNetwork.h` header file,
    which has the definition of the `DOREPLIFETIME_CONDITION` macro that we''re going
    to use:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare the protected timer variable to prevent the client from spamming the
    `Fire` action:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare the protected replicated ammo variable, which starts with `5` shots:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, declare the protected animation montage variable that will be played
    when the character fires:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare the protected sound variable that will be played when the character
    has no ammo:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Override the `Tick` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare the input function that will process the pressing of the *Left Mouse
    Button*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare the reliable and validated Server RPC for firing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare the unreliable Multicast RPC that will play the fire animation on all
    of the clients:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare the unreliable Client RPC that will play a sound only in the owning
    client:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, open the `RPCCharacter.cpp` file and include `DrawDebugHelpers.h`, `GameplayStatics.h`,
    `TimerManager.h` and `World.h`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'At the end of the constructor, enable the `Tick` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `GetLifetimeReplicatedProps` function so that the `Ammo` variable
    will replicate to all of the clients:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, implement the `Tick` function, which displays the value of the `Ammo` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'At the end of the `SetupPlayerInputController` function, bind the `Fire` action
    to the `OnPressedFire` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the function that will process the press of the *Left Mouse Button*,
    which will call the fire Server RPC:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the fire Server RPC validation function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the fire Server RPC implementation function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, add the logic to abort the function if the fire timer is still active
    since we fired the last shot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Check whether the character has ammo. If it doesn''t, then play `NoAmmoSound`
    only in the client that controls the character and abort the function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Deduct the ammo and schedule the `FireTimer` variable to prevent this function
    from being spammed while playing the fire animation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Call the fire Multicast RPC to make all the clients play the fire animation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the fire Multicast RPC, which will play the fire animation montage:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the Client RPC that plays a 2D sound:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Finally, you can launch the project in the editor.
  prefs: []
  type: TYPE_NORMAL
- en: Compile the code and wait for the editor to fully load.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Go to `Project Settings`, go to `Engine`, then `Input`, and add the `Fire`
    action binding:![Figure 17.2: Adding the new Fire action binding'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_17_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 17.2: Adding the new Fire action binding'
  prefs: []
  type: TYPE_NORMAL
- en: Close `Project Settings`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `Content Browser`, go to the `Content\Mannequin\Animations` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the `Import` button, go to the `Exercise17.01\Assets` folder and import
    the `ThirdPersonFire.fbx` file, and then make sure it's using the `UE4_Mannequin_Skeleton`
    skeleton.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The `Assets` folder mentioned earlier is available on our GitHub repository
    at [https://packt.live/36pEvAT](https://packt.live/36pEvAT).
  prefs: []
  type: TYPE_NORMAL
- en: Open the new animation and, on the details, the panel finds the `Enable Root
    Motion` option and sets it to true. This will prevent the character from moving
    when playing the animation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save and close `ThirdPersonFire`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Right-click* `ThirdPersonFire` on `Content Browser` and pick `Create -> AnimMontage`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename `AnimMontage` to `ThirdPersonFire_Montage`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `Animations` folder should look like this:![Figure 17.3: The animations
    folder for the Mannequin'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_17_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 17.3: The animations folder for the Mannequin'
  prefs: []
  type: TYPE_NORMAL
- en: Open `ThirdPerson_AnimBP` and then open `AnimGraph`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Right-click* on an empty part of the graph, add a `DefaultSlot` node (to be
    able to play the animation montage), and connect it between `State Machine` and
    `Output Pose`. You should get the following output:![Figure 17.4: The AnimGraph
    of the character'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_17_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 17.4: The AnimGraph of the character'
  prefs: []
  type: TYPE_NORMAL
- en: Save and close `ThirdPerson_AnimBP`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `Content Browser`, go to the `Content` folder, create a new folder called
    `Audio`, and open it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the `Import` button and go to the `Exercise17.01\Assets` folder, import
    `noammo.wav`, and save it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to `Content\ThirdPersonCPP\Blueprints` and open the `ThirdPersonCharacter`
    blueprint.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the class defaults, set `No Ammo Sound` to use `noammo`, and set `Fire Anim
    Montage` to use `ThirdPersonFire_Montage`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save and close `ThirdPersonCharacter`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to the Multiplayer options and set the number of clients to `2`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the window size to 800x600 and play using PIE.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You should get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.5: The end result of the exercise'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_17_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 17.5: The end result of the exercise'
  prefs: []
  type: TYPE_NORMAL
- en: By completing this exercise, you will be able to play on each client, and every
    time you press the *Left Mouse Button*, the character of the client will play
    the `Fire Anim` montage, which all clients will be able to see, and its ammo will
    reduce by `1`. If you try to fire when the ammo is `0`, that client will hear
    `No Ammo Sound` and won't do the fire animation, because the server didn't call
    the Multicast RPC. If you try to spam the fire button, you'll notice that it will
    only trigger a new fire once the animation is finished.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will be looking at enumerations, which are used in game
    development for many different things, such as managing the state of a character (whether
    it's idle, walking, attacking, or dead, and so on) or to assign a human-friendly
    name for each index in the gear slot array (head, primary weapon, secondary weapon,
    torso, hands, belt, pants, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: Enumerations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An enumeration is a user-defined data type that holds a list of integer constants,
    where each item has a human-friendly name assigned by you, which makes the code
    easier to read. As an example, we could use an integer variable to represent the
    different states that a character can be in – `0` means it's idle, `1` means it's
    walking, and so on. The problem with this approach is that when you start writing
    code such as `if(State == 0)`, it will become hard to remember what `0` means,
    especially if you have a lot of states, without using some documentation or comments
    to help you remember. To fix this problem, you should use enumerations, where
    you can write code such as `if(State == EState::Idle)`, which is much more explicit
    and easier to understand.
  prefs: []
  type: TYPE_NORMAL
- en: In C++, you have two types of enums, the older raw enums and the new enum classes,
    introduced in C++11\. If you want to use C++ enumerations in the editor, your
    first instinct might be to do it in the typical way, which is by declaring a variable
    or a function that uses the enumeration as a parameter, with `UPROPERTY` or `UFUNCTION`,
    respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem is, if you try to do that, you''ll get a compilation error. Take
    a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, we declare an enum class called `ETestEnum` that
    has three possible values – `EnumValue1`, `EnumValue2`, and `EnumValue3`.
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, try either one of the following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code snippet, we declare a `UPROPERTY` variable and `UFUNCTION`
    function that uses the `ETestEnum` enumeration in a class. If you try to compile,
    you''ll get the following compilation error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In Unreal Engine 4, it's good practice to prefix the name of an enumeration
    with the letter `E`. Examples include `EWeaponType` and `EAmmoType`.
  prefs: []
  type: TYPE_NORMAL
- en: This error happens because when you try to expose a class, struct, or enumeration
    to the editor with the `UPROPERTY` or `UFUNCTION` macro, you need to add it to
    the Unreal Engine 4 Reflection System by using the `UCLASS`, `USTRUCT`, and `UENUM`
    macros, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'You can learn more about the Unreal Engine 4 Reflection System by visiting
    the following link: [https://www.unrealengine.com/en-US/blog/unreal-property-system-reflection](https://www.unrealengine.com/en-US/blog/unreal-property-system-reflection).'
  prefs: []
  type: TYPE_NORMAL
- en: 'With that knowledge in mind, it is simple to fix the previous error, so just
    do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will look at the `TEnumAsByte` type.
  prefs: []
  type: TYPE_NORMAL
- en: TEnumAsByte
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you want to expose a variable to the engine that uses a raw enum, then you
    need to use the `TEnumAsByte` type. If you declare a `UPROPERTY` variable using
    a raw enum (not enum classes), you'll get a compilation error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Have a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'If you declare a `UPROPERTY` variable using `ETestRawEnum`, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ll get this compilation error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'To fix this error, you need to surround the enum type of the variable, which
    in this case is `ETestRawEnum`, with `TEnumAsByte<>`, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: UMETA
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you use the `UENUM` macro to add an enumeration to the Unreal Engine Reflection
    System, this will allow you to use the `UMETA` macro on each value of the enum.
    The `UMETA` macro, just like with other macros such as `UPROPERTY` or `UFUNCTION`,
    can use specifiers that will inform Unreal Engine 4 on how to handle that value.
    Here is a list of the most commonly used `UMETA` specifiers:'
  prefs: []
  type: TYPE_NORMAL
- en: DisplayName
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This specifier allows you to define a new name that is easier to read for the
    enum value when it's displayed in the editor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s declare the following variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Then, when you open the editor and look at the `TestEnum` variable, you will
    see a dropdown where `EnumValue1`, `EnumValue2,` and `EnumValue3` have been replaced
    by `My First Option`, `My Second Option,` and `My Third Option`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Hidden
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This specifier allows you to hide a specific enum value from the dropdown. This
    is typically used when there is an enum value that you only want to be able to
    use in C++ and not in the editor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s declare the following variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Then, when you open the editor and look at the `TestEnum` variable, you will
    see a dropdown. You should notice that `My Second Option` doesn't appear in the
    dropdown and therefore can't be selected.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: For more information on all of the UMETA specifiers, visit [https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Reference/Metadata/#enummetadataspecifiers](https://docs.unrealengine.com/en-US/Programming/UnrealArchitecture/Reference/Metadata/#enummetadataspecifiers).
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will look at the `BlueprintType` specifier for the `UENUM` macro.
  prefs: []
  type: TYPE_NORMAL
- en: BlueprintType
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This `UENUM` specifier will expose the enumeration to blueprints. This means
    that there will be an entry for that enumeration on the dropdown that is used
    when making new variables or inputs/outputs for a function, as in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.6: Setting a variable to use the ETestEnum variable type.'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_17_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 17.6: Setting a variable to use the ETestEnum variable type.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It will also show additional functions that you can call on the enumeration
    in the editor, as in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.7: List of additional functions available when using BlueprintType'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16183_17_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 17.7: List of additional functions available when using BlueprintType'
  prefs: []
  type: TYPE_NORMAL
- en: MAX
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When using enumerations, it's common to want to know how many values it has.
    In Unreal Engine 4, the standard way of doing this is by adding `MAX` as the last
    value, which will be automatically hidden in the editor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to know how many values `ETestEnum` has in C++, you just need to
    do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'This works because enumerations in C++ are internally stored as numbers, where
    the first value is `0`, the second is `1`, and so on. This means that as long
    as `MAX` is the last value, it will always have the total number of values in
    the enumeration. An important thing to take into consideration is that in order
    for `MAX` to give you the correct value, you cannot change the internal numbering
    order of the enumeration, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: In this case, `MAX` will be `101` because it will use the number immediately
    next to the previous value, which is `EnumValue3 = 100`.
  prefs: []
  type: TYPE_NORMAL
- en: Using `MAX` is only meant to be used in C++ and not in the editor, because the
    `MAX` value is hidden in blueprints, as previously mentioned. To get the number
    of entries of an enumeration in blueprints, you should use the `BlueprintType`
    specifier in the `UENUM` macro in order to expose some useful functions on the
    context menu. After that, you just need to type the name of your enumeration in
    the context menu. If you select the `Get number of entries in ETestEnum` option,
    you will have a function that returns the number of entries of an enumeration.
  prefs: []
  type: TYPE_NORMAL
- en: In the next exercise, you will be using C++ enumerations in the Unreal Engine
    4 editor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 17.02: Using C++ Enumerations in the Unreal Engine 4 Editor'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we''re going to create a new C++ project that uses the `Third
    Person` template, and we''re going to add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: An enumeration called `EWeaponType` containing `3` weapons – a pistol, shotgun,
    and rocket launcher.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An enumeration called `EAmmoType` containing `3` ammo types – bullets, shells,
    and rockets.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A variable called `Weapon` that uses `EWeaponType` to tell the type of the current weapon.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An integer array variable called `Ammo` that holds the amount of ammo for each
    type, which is initialized with the value `10`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the player presses the *1*, *2*, and *3* keys, it will set `Weapon` to
    `Pistol`, `Shotgun`, and `Rocket Launcher`, respectively.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the player presses the *Left Mouse Button*, this will consume ammo from
    the current weapon.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With every `Tick`function call, the character will display the current weapon
    type and the equivalent ammo type and amount.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following steps will help you complete the exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new `Third Person` template project using `C++` called `Enumerations`
    and save it to a location of your choosing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the project has been created, it should open the editor as well as the
    Visual Studio solution.
  prefs: []
  type: TYPE_NORMAL
- en: Close the editor and go back to Visual Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `Enumerations.h` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a macro called `ENUM_TO_INT32` that will convert an enumeration to an
    `int32` datatype:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a macro called `ENUM_TO_FSTRING` that will get the display name for
    a value of an `enum` datatype and convert it to an `FString` datatype:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare the enumerations `EWeaponType` and `EAmmoType`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the `EnumerationsCharacter.h` file, include the `Enumerations.h` header:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare the protected `Weapon` variable that holds the weapon type of the selected
    weapon:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare the protected `Ammo` array that holds the amount of ammo for each type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare the protected overrides for the `Begin Play` and `Tick` functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare the protected input functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the `EnumerationsCharacter.cpp` file, include the `DrawDebugHelpers.h`
    header:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Bind the new action bindings at the end of the `SetupPlayerInputController`
    function, as shown in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, implement the override for `BeginPlay` that executes the parent logic,
    but also initializes the size of the `Ammo` array with the number of entries in
    the `EAmmoType` enumeration. Each position in the array will also be initialized
    with a value of `10`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the override for `Tick`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Convert the `Weapon` variable to `int32` and the `Weapon` variable to an `FString`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Convert the ammo type to an `FString` and get the ammo count for the current weapon:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: We use `Weapon` to get the ammo type string because the entries in `EAmmoType`
    match the type of ammo of the equivalent `EWeaponType`. In other words, `Pistol
    = 0` uses `Bullets = 0`, `Shotgun = 1` uses `Shells = 1`, and `RocketLauncher
    = 2` uses `Rockets = 2`, so it's a 1-to-1 mapping that we can use in our favor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Display in the character''s location the name of the current weapon and its
    corresponding ammo type and ammo count, as shown in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the equip input functions that sets the `Weapon` variable with the
    corresponding value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the fire input function that will use the weapon index to get the
    corresponding ammo type count and subtract `1`, as long as the resulting value
    is greater or equal to 0:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Compile the code and run the editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Go to `Project Settings` and then `Engine`, then `Input`, and add the new action
    `bindings`:![Figure 17.8: Adding the Pistol, Shotgun, Rocket Launcher, and Fire
    bindings'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_17_08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 17.8: Adding the Pistol, Shotgun, Rocket Launcher, and Fire bindings'
  prefs: []
  type: TYPE_NORMAL
- en: Close the `Project Settings`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Play in `New Editor Window (PIE)` in single-player mode (one client and dedicated
    server disabled):![Figure 17.9: The end result of the exercise'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_17_09.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 17.9: The end result of the exercise'
  prefs: []
  type: TYPE_NORMAL
- en: By completing this exercise, you will be able to use the *1*, *2*, and *3* keys
    to select the current weapon. You'll notice that every tick will display the type
    of the current weapon and its corresponding ammo type and ammo count. If you press
    the fire key, this will deduct the ammo count for the current weapon, but it will
    never go below `0`.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you will be looking at bi-directional circular array indexing.
  prefs: []
  type: TYPE_NORMAL
- en: Bi-Directional Circular Array Indexing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, when you use arrays to store information, you might want to iterate
    it in a bi-direction circular fashion. An example of this is the previous/next
    weapon logic in shooter games, where you have an array with weapons and you want
    to be able to cycle through them in a particular direction, and when you reach
    the first or the last index, you want to loop back around to the last and first
    index, respectively. The typical way of doing this example would be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we adjust the weapon index to loop back if the new weapon
    index is outside the limits of the weapons array, which can happen in two cases.
    The first case is when the player has the last weapon of the inventory equipped
    and asks for the next weapon. In this case, it should go back to the first weapon.
  prefs: []
  type: TYPE_NORMAL
- en: The second case is when the player has the first weapon of the inventory equipped
    and asks for the previous weapon. In this case, it should go to the last weapon.
  prefs: []
  type: TYPE_NORMAL
- en: While the example code works, it's still quite a lot of code to solve such a
    trivial problem. To improve this code, there is a mathematical formula that will
    help you contemplate these two cases automatically in just one function. It's
    called the modulo (represented in C++ by the `%` operator), which gives you the
    remainder of a division between two numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'So how do we use the modulo to do a bi-directional circular array indexing?
    Let''s rewrite the previous example using the modulo:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: This is the new version, and you can tell right away that it's a bit harder
    to understand, but it's more functional and compact. If you don't use the variables
    to store the intermediate values of each operation, you can probably make the
    entire function in one or two lines of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s break down the preceding code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '`const int WeaponCount = Weapons.Num()`: We need to know the size of the array
    to determine the index where it should circle back to `0`. In other words, if
    `WeaponCount = 4`, then the array has the indexes `0`, `1`, `2`, and `3`, so that
    tells us that index 4 is the cutoff index where it should go back to `0`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`const int32 NewIndex = WeaponIndex + Direction`: This is the new raw index
    without clamping it to the limits of the array. The `Direction` variable is used
    to indicate the offset we want to navigate the array, and this is either `-1`
    if we want the previous index or `1` if we want the next index.'
  prefs: []
  type: TYPE_NORMAL
- en: '`const int32 ClampedNewIndex = NewIndex % WeaponCount`: This will make sure
    that `NewIndex` is within the `0` to `WeaponCount - 1` interval due to the modulo
    properties.'
  prefs: []
  type: TYPE_NORMAL
- en: If `Direction` was always `1`, then `ClampedNewIndex` would be enough for what
    we need. The problem is, the modulo operation doesn't work very well with negative
    values, which can happen when `WeaponIndex` is `0` and `Direction` is `-1`, which
    would cause `NewIndex` to be `-1`. To fix this limitation, we need to do some
    additional calculations.
  prefs: []
  type: TYPE_NORMAL
- en: '`WeaponIndex = (ClampedNewIndex + WeaponCount) % WeaponCount`: This will add
    `WeaponCount` to `ClampedNewIndex` to make it positive and apply the modulo again
    to get the correct clamped index, which fixes the problem.'
  prefs: []
  type: TYPE_NORMAL
- en: '`return Weapons[WeaponIndex]`: This returns the weapon in the calculated `WeaponIndex`
    index position.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at a practical example to help you visualize how all this
    works:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Weapons** ='
  prefs: []
  type: TYPE_NORMAL
- en: '[0] Knife'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[1] Pistol'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[2] Shotgun'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[3] Rocket Launcher'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Weapons.Num() = 4`.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's assume that `WeaponIndex = 3` and `Direction = 1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then:'
  prefs: []
  type: TYPE_NORMAL
- en: '`NewIndex` = *WeaponIndex + Direction* = 3 + 1 = 4'
  prefs: []
  type: TYPE_NORMAL
- en: '`ClampedIndex` = *NewIndex % WeaponCount* = 4 % 4 = 0'
  prefs: []
  type: TYPE_NORMAL
- en: '`WeaponIndex` = *(ClampedIndex + WeaponCount) % WeaponCount* = (0 + 4) % 4
    = 0'
  prefs: []
  type: TYPE_NORMAL
- en: In this example, the starting value for the weapon index is `3` (which is the
    Rocket Launcher), and we want the next weapon (since `Direction` is `1`). Performing
    the calculations, `WeaponIndex` will now be `0` (which is the Knife). This is
    the desired behavior because we have 4 weapons, so we circled back to In this
    case, since `Direction` is `1`, we could've just used `ClampedIndex` without doing
    the extra calculations.
  prefs: []
  type: TYPE_NORMAL
- en: Let's debug it again using different values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assume that `WeaponIndex = 0` and `Direction = -1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`NewIndex` = *WeaponIndex + Direction* = 0 + -1 = -1'
  prefs: []
  type: TYPE_NORMAL
- en: '`ClampedIndex` = *NewIndex % WeaponCount *= -1 % 4 = -1'
  prefs: []
  type: TYPE_NORMAL
- en: '`WeaponIndex` = *(ClampedIndex + WeaponCount) % WeaponCount* = (-1 + 4) % 4
    = 3'
  prefs: []
  type: TYPE_NORMAL
- en: In this example, the starting value for the weapon index is 0 (which is the
    Knife), and we want the previous weapon (since `Direction` is -`1`). Doing the
    calculations, `WeaponIndex` will now be 3 (which is the Rocket Launcher). This
    is the desired behavior because we have 4 weapons, so we circled back to 3\. In
    this specific case, `NewIndex` is negative, so we can't just use `ClampedIndex`;
    we need to do the extra calculation to get the correct value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 17.03: Using Bi-Directional Circular Array Indexing to Cycle between
    an Enumeration'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we're going to use the project from *Exercise17.02*, *Using
    C++ Enumerations in the Unreal Engine 4 Editor*, and add two new action mappings
    for cycling the weapons. The mouse wheel up will go to the previous weapon type,
    and the mouse wheel down will go to the next weapon type.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps will help you complete the exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: First, open the Visual Studio project from *Exercise 17.02*, *Using C++ Enumerations
    in the Unreal Engine 4 Editor*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, you will be updating `Enumerations.h` and add a macro that will handle
    the bi-directional array cycling in a very convenient way, as shown in the following
    steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `Enumerations.h` and add the `GET_CIRCULAR_ARRAY_INDEX` macro that will
    apply the modulo formula that we''ve already covered previously:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Open `EnumerationsCharacter.h` and declare the new input functions for the
    weapon cycling:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare the `CycleWeapons` function, as shown in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Open `EnumerationsCharacter.cpp` and bind the new action bindings in the `SetupPlayerInputController`
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, implement the new input functions, as shown in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, we define the functions that handle the action
    mappings for `Previous Weapon` and `Next Weapon`. Each function uses the `CycleWeapons`
    function, with a direction of `-1` for the previous weapon and `1` for the next
    weapon.
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement the `CycleWeapons` functions, which does the bi-directional cycling
    using the `Direction` parameter based on the current weapon index:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, we implement the `CycleWeapons` function that
    uses the modulo operator to calculate the next valid weapon index based on the
    direction supplied.
  prefs: []
  type: TYPE_NORMAL
- en: Compile the code and run the editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Go to `Project Settings` and then to `Engine`, then `Input`, and add the new
    action `bindings`:![Figure 17.10: Adding the Previous Weapon and Next Weapon bindings'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_17_10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 17.10: Adding the Previous Weapon and Next Weapon bindings'
  prefs: []
  type: TYPE_NORMAL
- en: Close the `Project Settings`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, play in `New Editor Window (PIE)` in single-player mode (one client and
    dedicated server disabled):![Figure 17.11: The end result of the exercise'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B16183_17_11.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 17.11: The end result of the exercise'
  prefs: []
  type: TYPE_NORMAL
- en: By completing this exercise, you will be able to use the mouse wheel to cycle
    between the weapons. If you select the rocket launcher and use the mouse wheel
    down to go to the next weapon, it will go back to the pistol. If you use the mouse
    wheel down to go to the previous weapon with the pistol selected, it will go back
    to the rocket launcher.
  prefs: []
  type: TYPE_NORMAL
- en: In the next activity, you will be adding the concept of weapons and ammo to
    the multiplayer FPS project we started in *Chapter 16*, *Multiplayer Basics*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 17.01: Adding Weapons and Ammo to the Multiplayer FPS Game'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this activity, you'll add the concept of weapons and ammo to the Multiplayer
    FPS project we embarked on in the previous chapter activity. You will need to
    use the different types of RPCs covered in this chapter to complete this activity.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps will help you complete this activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `MultiplayerFPS` project from *Activity 16.01*, *Creating a Character
    for the Multiplayer FPS Project*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new `AnimMontage` slot called `Upper Body`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import the animations (`Pistol_Fire.fbx`, `MachineGun_Fire.fbx`, and `Railgun_Fire.fbx`)
    from the `Activity17.01\Assets` folder to `Content\Player\Animations`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The Assets folder, `Activity17.01\Assets`, can be found on our GitHub repository
    at [https://packt.live/2It4Plb](https://packt.live/2It4Plb).
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an anim montage for `Pistol_Fire`, `MachineGun_Fire`, and `Railgun_Fire`
    and make sure they have the following configurations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Blend In` time of `0.01`, the `Blend Out` time of `0.1`, and make sure it
    uses the `Upper Body` slot.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Blend In` time of `0.01`, the `Blend Out` time of `0.1`, and make sure it
    uses the Upper Body slot.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Upper Body` slot.'
  prefs: []
  type: TYPE_NORMAL
- en: Import `SK_Weapon.fbx`, `NoAmmo.wav`, `WeaponChange.wav`, and `Hit.wav` from
    the `Activity17.01\Assets` folder to `Content\Weapons`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import `Pistol_Fire_Sound.wav` from `Activity17.01\Assets` to `Content\Weapons\Pistol`
    and use it on an `AnimNotify` Play Sound in the `Pistol_Fire` animation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a simple green-colored material called `M_Pistol` and place it on `Content\Weapons\Pistol`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import `MachineGun_Fire_Sound.wav` from `Activity17.01\Assets` to `Content\Weapons\MachineGun`
    and use it on an `AnimNotify` Play Sound in the `MachineGun_Fire` animation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a simple red-colored material called `M_MachineGun` and place it on `Content\Weapons\MachineGun`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import `Railgun_Fire_Sound.wav` from `Activity17.01\Assets` to `Content\Weapons\Railgun`
    and use it on an `AnimNotify` Play Sound in the `Railgun_Fire` animation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a simple white-colored material called `M_Railgun` and place it on `Content\Weapons\Railgun`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Edit the `SK_Mannequin` skeletal mesh and create a socket called `GripPoint`
    from `hand_r` with Relative Location (*X=-10.403845,Y=6.0,Z=-3.124871*) and Relative
    Rotation (*X=0.0,Y=0.0,Z=90.0*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following input mappings in `Project Settings`, using the knowledge
    acquired in *Chapter 4*, *Player Input*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Fire (Action mapping): Left Mouse Button'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Previous Weapon (Action mapping): Mouse Wheel Up'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next Weapon (Action mapping): Mouse Wheel Down'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Pistol (Action mapping): 1'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Machine Gun (Action mapping): 2'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Railgun (Action mapping): 3'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In `MultiplayerFPS.h`, create the `ENUM_TO_INT32(Enum)` macro, which casts an
    enumeration to `int32` and `GET_CIRCULAR_ARRAY_INDEX(Index, Count)` that uses
    bi-directional circular array indexing to convert the index into an index that
    is within the interval of `0` and a count of `-1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a header file called `EnumTypes.h`, which holds the following enumerations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**EWeaponType**: Pistol, MachineGun, Railgun, MAX'
  prefs: []
  type: TYPE_NORMAL
- en: '**EWeaponFireMode**: Single, Automatic'
  prefs: []
  type: TYPE_NORMAL
- en: '**EAmmoType**: Bullets, Slugs, MAX'
  prefs: []
  type: TYPE_NORMAL
- en: Create a C++ class `Weapon` that derives from the `Actor` class that has a skeletal
    mesh component called `Mesh` as the root component. In terms of variables, it
    stores the name, the weapon type, the ammo type, the fire mode, how far the hitscan
    goes, how much damage the hitscan does when it hits, the fire rate, the animation
    montage to use when firing, and the sound to play when it has no ammo. In terms
    of functionality, it needs to be able to start the fire (and also stop the fire,
    because of the automatic fire mode), which checks whether the player can fire.
    If it can, then it plays the fire animation in all of the clients and shoots a
    line trace in the camera position and direction with the supplied length to damage
    the actor it hits. If it doesn't have ammo, it will play a sound only on the owning
    client.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Edit `FPSCharacter` to support the new mappings for `Fire`, `Previous/Next Weapon`,
    `Pistol`, `Machine Gun`, and `Railgun`. In terms of variables, it needs to store
    the amount of ammo for each type, the currently equipped weapon, all of the weapons
    classes and spawned instances, the sound to play when it hits another player,
    and the sound when it changes weapons. In terms of functions, it needs to be able
    to equip/cycle/add weapons, manage ammo (add, remove, and get), handle when the
    character is damaged, play an anim montage on all of the clients, and play a sound
    on the owning client.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create `BP_Pistol` from `AWeapon`, place it on `Content\Weapons\Pistol`, and
    configure it with the following values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Skeletal Mesh: `Content\Weapons\SK_Weapon`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Material: `Content\Weapons\Pistol\M_Pistol`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Name: `Pistol Mk I`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Weapon Type: `Pistol`, Ammo Type: `Bullets`, Fire Mode: `Automatic`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Hit Scan Range: `9999.9`, Hit Scan Damage: `5.0`, Fire Rate: `0.5`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Fire Anim Montage: `Content\Player\Animations\Pistol_Fire_Montage`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'NoAmmoSound: `Content\Weapons\NoAmmo`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Create `BP_MachineGun` from `AWeapon` and place it on `Content\Weapons\MachineGun`
    and configure it with the following values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Skeletal Mesh: `Content\Weapons\SK_Weapon`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Material: `Content\Weapons\MachineGun\M_MachineGun`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Name: `Machine Gun Mk I`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Weapon Type: `Machine Gun`, Ammo Type: `Bullets`, Fire Mode: `Automatic`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Hit Scan Range: `9999.9`, Hit Scan Damage: `5.0`, Fire Rate: `0.1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Fire Anim Montage: `Content\Player\Animations\MachineGun_Fire_Montage`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'NoAmmoSound: `Content\Weapons\NoAmmo`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Create `BP_Railgun` from `AWeapon` and place it on `Content\Weapons\Railgun`
    and configure it with the following values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Skeletal Mesh: `Content\Weapons\SK_Weapon`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Material: `Content\Weapons\Railgun\M_Railgun`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Name: Railgun `Mk I`, Weapon Type: `Railgun`, AmmoType: `Slugs`, Fire Mode:
    `Single`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Hit Scan Range: `9999.9`, Hit Scan Damage: `100.0`, Fire Rate: `1.5`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Fire Anim Montage: `Content\Player\Animations\Railgun_Fire_Montage`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'No Ammo Sound: `Content\Weapons\NoAmmo`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Configure `BP_Player` with the following values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Weapon Classes (Index 0: `BP_Pistol`, Index 1: `BP_MachineGun`, Index 2: `BP_Railgun`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Hit Sound: `Content\Weapons\Hit`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Weapon Change Sound: `Content\Weapons\WeaponChange`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make the mesh component block the visibility channel so it can be hit by the
    hitscans of the weapons.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Edit `ABP_Player` to use a `Layered Blend Per Bone` node, with `Mesh Space Rotation
    Blend` enabled, on the `spine_01` bone so that the upper body animations use the
    Upper Body slot.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Edit `UI_HUD` so that it displays a white dot crosshair in the middle of the
    screen and the current weapon and ammo count under the Health and Armor indicators:![Figure
    17.12: The expected result of the activity'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '](img/B16183_17_12.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 17.12: The expected result of the activity'
  prefs: []
  type: TYPE_NORMAL
- en: The result should be a project where each client will have weapons with ammo
    and will be able to use them to fire at and damage other players. You will also
    be able to select weapons by using the *1*, *2*, and *3* keys and by using the
    mouse wheel up and down to select the previous and next weapon.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution to this activity can be found at: https://packt.live/338jEBx.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use RPCs to allow the server and the clients
    to execute logic on one another. We also learned how enumerations work in Unreal
    Engine 4 by using the `UENUM` macro and how to use bi-directional circular array
    indexing, which helps you iterate an array in both directions and loops around
    when you go beyond its index limits.
  prefs: []
  type: TYPE_NORMAL
- en: With the activity of this chapter complete, you'll have a basic playable game
    where players can shoot each other and switch weapons, but there is still more
    we can add to make it even more interesting.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll learn where the instances of the most common gameplay
    framework classes exist in multiplayer, as well as learn about the Player State
    and Game State classes, which we haven't covered yet. We'll also cover some new
    concepts in the game mode that are used in multiplayer matches, as well as some
    useful general-purpose, built-in functionality.
  prefs: []
  type: TYPE_NORMAL
