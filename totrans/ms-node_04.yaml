- en: Using Node to Access the Filesystem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"We have persistent objects - they''re called files."'
  prefs: []
  type: TYPE_NORMAL
- en: – *Ken Thompson*
  prefs: []
  type: TYPE_NORMAL
- en: A file is simply a chunk of data that is persisted, usually, on some hard medium
    such as a hard drive. Files are normally composed of a sequence of bytes whose
    encoding maps onto some other pattern, like a sequence of numbers or electrical
    pulses. A nearly infinite number of encodings are possible, with some common ones
    being text files, image files, and music files. Files have a fixed length, and
    to be read, their character encoding must be deciphered by some sort of reader,
    such as an MP3 player or a word processor.
  prefs: []
  type: TYPE_NORMAL
- en: When a file is in transit, moving through a cable after it's been siphoned off
    of some storage device, it is no different than any other data stream running
    through the wire. Its previous solid state is just a stable blueprint that can
    be easily and infinitely copied.
  prefs: []
  type: TYPE_NORMAL
- en: We've already seen how event streams reflect the core design principles informing
    Node's design, where byte streams are to be read from and written to, and piped
    into other streams, emitting relevant stream events, such as `end`. Files are
    easily understood as being containers of data, filled with bytes that can be extracted
    or inserted partially or as a whole.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to their natural similarity to streams, files also display the characteristics
    of objects. Files have properties that describe the interface available for accessing
    file contents—data structures with properties and associated access methods.
  prefs: []
  type: TYPE_NORMAL
- en: A **filesystem** reflects some concept of how files should be organized—how
    they are identified, where they are stored, how they are to be accessed, and so
    forth. A common filesystem for UNIX users is the **UFS** (**Unix File System**),
    while Windows users may be familiar with **NTFS** (**New Technology File System**).
  prefs: []
  type: TYPE_NORMAL
- en: It is interesting that the designers of the Plan 9 operating system (a team
    including *Ken Thompson*) decided to have *all* control interfaces represented
    as filesystems, such that all system interfaces (across devices, across applications)
    are modeled as file operations. Treating files as first-class citizens is a philosophy
    the UNIX OS also uses; using files as references to named pipes and sockets, among
    other things, gives developers enormous power when shaping data flow.
  prefs: []
  type: TYPE_NORMAL
- en: File objects are also powerful, and the system they reside within exposes fundamental
    I/O interfaces that must be easy to use, consistent, and very fast. Not surprisingly,
    Node's `file` module exposes just such an interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be considering handling files in Node from these two perspectives:
    how file data content is streamed in and out (read from and written), and how
    the attributes of file objects are modified, such as changing file permissions.'
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, we will cover the responsibilities of the Node server, in terms
    of accepting file uploads and servicing file requests. By working through examples
    of directory iterators and file servers, the full range and behavior of Node's
    filesystem API should become clear.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we'll take JavaScript back to the desktop, using GitHub's Electron framework
    to make our own desktop app, a simple file browser.
  prefs: []
  type: TYPE_NORMAL
- en: Directories, and iterating over files and folders
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Typically, a filesystem groups files into collections, normally referred to
    as directories. One navigates through directories to find individual files. Once
    a target file is found, the file object must be wrapped by an interface exposing
    the file contents for reading and writing.
  prefs: []
  type: TYPE_NORMAL
- en: As Node development often involves the creation of servers that both accept
    and emit file data, it should be clear how important transfer speed at this active
    and important I/O layer is. As mentioned earlier, files can also be understood
    as objects, and objects have certain attributes.
  prefs: []
  type: TYPE_NORMAL
- en: Types of files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are six types of files commonly encountered on a UNIX system:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ordinary files**: These contain a one-dimensional array of bytes, and cannot
    contain other files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Directories**: These are also files implemented in a special way such that
    they can describe collections of other files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sockets**: Used for IPC, allowing processes to exchange data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Named pipe**: A command such as `ps aux | grep node` creates a pipe,'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: which is destroyed once the operation terminates. Named pipes are persistent
    and addressable, and they can be used variously by multiple processes for IPC
    indefinitely.
  prefs: []
  type: TYPE_NORMAL
- en: '**Device files**: These are representations of I/O devices, processes that
    accept streams of data; `/dev/null` is commonly an example of a character device
    file (accepts serial streams of I/O), and `/dev/sda` is an example of a block
    device file (allowing random access I/O for blocks of data) representing a data
    drive.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Links**: These are pointers to other files of two types: hard links and symbolic
    links. Hard links directly point to another file and are indistinguishable from
    the target file. Symbolic links are indirect pointers and are distinguishable
    from normal files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most Node filesystem interactions encounter only the first two types, with the
    third only indirectly via the Node API. A deeper explanation of the remaining
    types is beyond the scope of this discussion. However, Node provides a full suite
    of file operations via the `file` module, and the reader should have at least
    some familiarity with the full range and power of file types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Studying named pipes will reward the reader interested in understanding how
    Node was designed to work with streams and pipes. Try this from a terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If you get an expanded listing of the current directory `-ls -l`, a listing
    similar to this will be shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Note the `p` flag in the file mode (the first segment, with the dashes). You''ve
    created a named `(p)ipe`. Now, enter this into the same terminal, pushing some
    bytes into the named pipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: It will seem like the process has hung. It hasn't—pipes, like water pipes, must
    be open on both ends to complete their job of flushing contents. We've pumped
    some bytes in... now what?
  prefs: []
  type: TYPE_NORMAL
- en: 'Open another terminal, navigate to the same directory, and enter this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '`hello` will appear in the second terminal as the contents of `namedpipe` are
    flushed. Note that the first terminal is no longer hung—it has flushed. If you
    recall the discussion on Node streams in [Chapter 3](c7665bc9-3f44-4d7c-8318-61f9dfe962b3.xhtml), *Streaming
    Data Across Nodes and Clients,* you will note something of a resemblance with
    Unix pipes, which is intentional.'
  prefs: []
  type: TYPE_NORMAL
- en: File paths
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Most of the filesystem methods provided by Node will require the manipulation
    of file paths, and for this purpose, we make use of the `path` module. We can
    compose, decompose, and relate paths with this module. Instead of hand rolling
    your own path string splitting and regexing and concatenating routines, try to
    normalize your code by delegating path manipulation to this module:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use `path.normalize` whenever working with a file path string whose source
    is untrusted or unreliable to ensure a predictable format:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Use `path.join` whenever building a single path out of path segments:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Use `path.dirname` to snip the directory name out of a path:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Use `path.basename` to manipulate the final path segment:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Use `path.extname` to slice from the last period (`.`) to the end of the path
    string:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Use `path.relative` to find the relative path from one absolute path to another:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Use `path.resolve` to resolve a list of path instructions into an absolute
    path:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Think of the arguments passed to `path.resolve` as being a sequence of `cd`
    calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If the list of arguments passed to `path.resolve` fails to deliver an absolute
    path, the current directory name is used as well. For instance, consider that
    we are in `/users/home/john/`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: These arguments resolve to a relative path `one/two/three/four` that is, therefore,
    prefixed with the current directory name.
  prefs: []
  type: TYPE_NORMAL
- en: File attributes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A file object exposes some of its attributes, comprising a useful set of metadata
    about the file data. If one is using Node to run an HTTP server, it will be necessary
    to determine the file length of any file requested via a GET, for example. Determining
    the time a file was last modified finds uses across many types of applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'To read the attributes of a file, use `fs.stat`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, `stats` will be an `fs.Stats` object describing the
    file through a map of attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'An `fs.Stats` object exposes several useful methods for accessing file attribute
    data:'
  prefs: []
  type: TYPE_NORMAL
- en: Use `stats.isFile` to check for standard files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `stats.isDirectory` to check for directories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `stats.isBlockDevice` to check for block type device files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `stats.isCharacterDevice` to check for character type device files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `stats.isSymbolicLink` after an `fs.lstat` to find symbolic links
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `stats.isFIFO` to identify named pipes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `stats.isSocket` to check for sockets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are two further `stat` methods available:'
  prefs: []
  type: TYPE_NORMAL
- en: '`fs.fstat(fd, callback)`: Similar to `fs.stat`, except that a file descriptor
    `fd`is passed rather than a file path'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fs.lstat(path, callback)`: An `fs.stat` on a symbolic link will return an
    `fs.Stats` object for the target file, while `fs.lstat` will return an `fs.Stats`
    object for the link file itself'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following two methods simplify the file timestamp manipulation:'
  prefs: []
  type: TYPE_NORMAL
- en: '`fs.utimes(path, atime, mtime, callback)`: Change the access and modify timestamps
    on a file at `path`. The access and modify times of a file are stored as instances
    of the JavaScript `Date` object. `Date.getTime` will, for example, return the
    number of milliseconds elapsed since midnight (UTC) on January 1, 1970.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fs.futimes(fd, atime, mtime, callback)`: Change the access and modify timestamps
    on a file descriptor `fd`; it''s similar to `fs.utimes`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'More information about manipulating dates and times with JavaScript can be
    found at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date).'
  prefs: []
  type: TYPE_NORMAL
- en: Opening and closing files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the unofficial rules governing the Node project is to not unnecessarily
    abstract away from the existing OS implementation details. As we will see, references
    to file descriptors appear throughout Node's file API. For **POSIX** (**Portable
    Operating System Interface**), a file descriptor is simply an (non-negative) integer
    uniquely referencing a specific file. Since Node modeled its filesystem methods
    on POSIX, not surprisingly, a file descriptor is represented in Node as an integer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Recalling our discussion of how devices and other elements of the OS are represented
    as files, it would stand to reason that the standard I/O streams (`stdin`, `stdout`,
    `stderr`) would also have file descriptors. In fact, that is the case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: File descriptors are easy to obtain and are convenient ways to pass around file
    references. Let's look at how file descriptors are created and used by examining
    how to perform low-level file open and close operations using Node. As the chapter
    progresses, we'll investigate more refined interfaces to file streams.
  prefs: []
  type: TYPE_NORMAL
- en: fs.open(path, flags, [mode], callback)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Trying to open a file at `path`. `callback` will receive any exceptions with
    the operation as its first argument, and a file descriptor as its second argument.
    Here, we open a file for reading:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '`flags` receives a string indicating the types of operations the caller expects
    to perform on the returned file descriptor. Their meanings should be clear:'
  prefs: []
  type: TYPE_NORMAL
- en: '`r`: Opening a file for reading, throwing an exception if the file doesn''t
    exist.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`r+`: Opening a file for both reading and writing, throwing an exception if
    the file doesn''t exist.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`w`: Opening a file for writing, creating the file if it doesn''t exist, and
    truncating the file to zero bytes if it does exist.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`wx`: Like `w`, but it opens the file in exclusive mode, which means if the
    file already exists, it will **not be opened**, and the open operation will fail.
    This is useful if multiple processes may be simultaneously trying to create the
    same file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`w+`: Opening a file for reading and writing, creating the file if it doesn''t
    exist, and truncating the file to zero bytes if it does exist.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`wx+`: Like `wx` (and `w`), additionally opening the file for reading.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`a`: Opening a file for appending, creating the file if it does not exist.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ax`: Like **a**, but opens the file in exclusive mode, which means if the
    file already exists, it will **not be opened**, and the open operation will fail.
    This is useful if multiple processes may be simultaneously trying to create the
    same file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`a+`: Open a file for reading and appending, creating the file if it does not
    exist.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ax+`: Like `ax` (and `a`), additionally opening the file for reading.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When an operation may create a new file, use the optional `mode` to set permissions
    for this file in octal digits, defaulting to 0666 (refer to `fs.chmod` for more
    information about octal permissions):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: fs.close(fd, callback)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `fs.close(fd, callback)` method closes a file descriptor. The callback receives
    one argument, any exception thrown in the call. It's a good habit to close all
    the file descriptors that have been opened.
  prefs: []
  type: TYPE_NORMAL
- en: File operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Node implements the standard POSIX functions for working with files, which a
    UNIX user will be familiar with. We will not be covering each member of this extensive
    collection in depth, instead focusing on some commonly used examples. In particular,
    we will go into depth discussing the methods for opening file descriptors and
    manipulating file data, reading and manipulating file attributes, and moving through
    filesystem directories. Nevertheless, the reader is encouraged to experiment with
    the entire set, which the following list briefly describes. Note that all of these
    methods are asynchronous, non-blocking file operations.
  prefs: []
  type: TYPE_NORMAL
- en: fs.rename(oldName, newName, callback)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `fs.rename(oldName, newName, callback)` method renames file at `oldName` to
    `newName`. The callback receives one argument, any exception thrown in the call.
  prefs: []
  type: TYPE_NORMAL
- en: fs.truncate(path, len, callback)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `fs.truncate(path, len, callback)` method changes the length of the file
    at `path` by `len` bytes. If `len` represents a length shorter than the file's
    current length, the file is truncated to that length. If `len` is greater, the
    file length is padded by appending null bytes (x00) until `len` is reached. The
    callback receives one argument, any exception thrown in the call.
  prefs: []
  type: TYPE_NORMAL
- en: fs.ftruncate(fd, len, callback)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `fs.ftruncate(fd, len, callback)` method is like `fs.truncate`, except that
    instead of specifying a file, a file descriptor is passed as `fd`.
  prefs: []
  type: TYPE_NORMAL
- en: fs.chown(path, uid, gid, callback)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `fs.chown(path, uid, gid, callback)` method changes the ownership of the
    file at `path`. Use this to set whether user `uid` or group `gid` has access to
    a file. The callback receives one argument, any exception thrown in the call.
  prefs: []
  type: TYPE_NORMAL
- en: fs.fchown(fd, uid, gid, callback)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `fs.fchown(fd, uid, gid, callback)` method is like `fs.chown`, except that
    instead of specifying a file path, a file descriptor is passed as `fd`.
  prefs: []
  type: TYPE_NORMAL
- en: fs.lchown(path, uid, gid, callback)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `fs.lchown(path, uid, gid, callback)` method is like `fs.chown`, except
    that in the case of symbolic links, ownership of the link file itself is changed,
    but not the referenced link.
  prefs: []
  type: TYPE_NORMAL
- en: fs.chmod(path, mode, callback)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `fs.chmod(path, mode, callback)` method changes the `mode`(permissions)
    on a file at `path`. You are setting the read(4), write(2), and execute(1) bits
    for this file, which can be sent in octal digits:'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | [r]ead | [w]rite | E[x]ecute | Total |'
  prefs: []
  type: TYPE_TB
- en: '| Owner | **4** | **2** | **1** | **7** |'
  prefs: []
  type: TYPE_TB
- en: '| Group | **4** | **0** | **1** | **5** |'
  prefs: []
  type: TYPE_TB
- en: '| Other | **4** | **0** | **1** | **5** |'
  prefs: []
  type: TYPE_TB
- en: '|  |  |  |  | **chmod(755)** |'
  prefs: []
  type: TYPE_TB
- en: 'You may also use symbolic representations, such as `g+rw` for group read and
    write, similar to the arguments we saw for `file.open` earlier. For more information
    on setting file modes, consult: [http://en.wikipedia.org/wiki/Chmod](http://en.wikipedia.org/wiki/Chmod).'
  prefs: []
  type: TYPE_NORMAL
- en: The callback receives one argument, any exception thrown in the call.
  prefs: []
  type: TYPE_NORMAL
- en: fs.fchmod(fd, mode, callback) ----
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `fs.fchmod(fd, mode, callback)` method is like `fs.chmod`, except that instead
    of specifying a file path, a file descriptor is passed as `fd`.
  prefs: []
  type: TYPE_NORMAL
- en: fs.lchmod(path, mode, callback)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `fs.lchmod(path, mode, callback)` method is like `fs.chmod`, except that
    in the case of symbolic links, permissions on the link file itself is changed,
    but not those of the referenced link.
  prefs: []
  type: TYPE_NORMAL
- en: fs.link(srcPath, dstPath, callback)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `fs.link(srcPath, dstPath, callback)` creates a hard link between `srcPath`
    and `dstPath`. This is a way of creating many different paths to exactly the same
    file. For example, the following directory contains a `target.txt` file and two
    hard links—`a.txt` and `b.txt`—which each point to this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/071fe6c3-13e6-4da9-8a4c-5df632547f06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Note that `target.txt` is empty. If the content of the target file is changed,
    the length of the link files will also be changed. Consider changing the content
    of the target file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in this new directory structure, clearly demonstrating the hard
    references:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a761ddfa-c59c-4fa5-8c97-f744588b811a.png)'
  prefs: []
  type: TYPE_IMG
- en: The callback receives one argument, any exception thrown in the call.
  prefs: []
  type: TYPE_NORMAL
- en: fs.symlink(srcPath, dstPath, [type], callback)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `fs.symlink(srcPath, dstPath, [type], callback)` method creates a symbolic
    link between `srcPath` and `dstPath`. Unlike hard links created with `fs.link`,
    symbolic links are simply pointers to other files, and do not themselves respond
    to changes in the target file. The default link `type`is file. Other options are
    directory and junction, the last being a Windows-specific type that is ignored
    on other systems. The callback receives one argument, any exception thrown in
    the call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Compare and contrast the directory changes described in our `fs.link` discussion
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e0bc810e-ef05-4e42-af3f-9c69b5d91603.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Unlike hard links, symbolic links do not change in length when their target
    file (in this case `target.txt`) changes length. Here, we see how changing the
    target''s length from zero bytes to six bytes has no effect on the length of any
    bound symbolic links:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/117fd84c-d6db-404a-b48f-87c81a872b97.png)'
  prefs: []
  type: TYPE_IMG
- en: fs.readlink(path, callback)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The given symbolic link at `path` returns the filename of the targeted file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: fs.realpath(path, [cache], callback)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `fs.realpath(path, [cache], callback)` method attempts to find the real
    path to file at `path`. This is a useful way to find the absolute path to a file,
    resolve symbolic links, and even clean up extraneous slashes and other malformed
    paths. Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, consider this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'If some of the path segments to be resolved are already known, one can pass
    a `cache` of mapped paths:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: fs.unlink(path, callback)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `fs.unlink(path, callback)` method removes the file at `path`—equivalent
    to deleting a file. The callback receives one argument, any exception thrown in
    the call.
  prefs: []
  type: TYPE_NORMAL
- en: fs.rmdir(path, callback)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `fs.rmdir(path, callback)` method removes the directory at `path`, equivalent
    to deleting a directory.
  prefs: []
  type: TYPE_NORMAL
- en: Note that if the directory is not empty, this will throw an exception. The callback
    receives one argument, any exception thrown in the call.
  prefs: []
  type: TYPE_NORMAL
- en: fs.mkdir(path, [mode], callback)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `fs.mkdir(path, [mode], callback)` method creates a directory at `path`.
    To set the mode of the new directory, use the permission bit map described in
    `fs.chmod`.
  prefs: []
  type: TYPE_NORMAL
- en: Note that if this directory already exists, an exception will be thrown. The
    callback receives one argument, any exception thrown in the call.
  prefs: []
  type: TYPE_NORMAL
- en: fs.exists(path, callback)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `fs.exists(path, callback)` method checks whether a file exists at `path`.
    The callback will receive a Boolean true or false.
  prefs: []
  type: TYPE_NORMAL
- en: fs.fsync(fd, callback)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Between the instant a request for some data to be written to a file is made
    and that data fully exists on a storage device, the candidate data exists within
    core system buffers. This latency isn't normally relevant but, in some extreme
    cases, such as system crashes, it is necessary to insist that the file reflects
    a known state on a stable storage device.
  prefs: []
  type: TYPE_NORMAL
- en: '`fs.fsync` copies all in-core data of a file referenced by file descriptor
    `fd` to disk'
  prefs: []
  type: TYPE_NORMAL
- en: (or other storage device). The callback receives one argument, any exception
    thrown in the call.
  prefs: []
  type: TYPE_NORMAL
- en: Synchronicity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Conveniently, Node's `file` module provides synchronous counterparts for each
    of the asynchronous methods we've covered, indicated by the `Sync` suffix. For
    example, the synchronous version of `fs.mkdir` is `fs.mkdirSync`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A synchronous call is also able to directly return its result, obviating the
    need for callbacks. While demonstrating the creation of HTTPS servers in [Chapter
    3](c7665bc9-3f44-4d7c-8318-61f9dfe962b3.xhtml), *Streaming Data Across Nodes and
    Clients*, we saw both a good use case for synchronous code and an example of direct
    assignment of results without a callback:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Hey! Doesn't Node strictly enforce asynchronous programming? Isn't blocking
    code always wrong? All developers are encouraged to adhere to non-blocking designs,
    and you are encouraged to avoid synchronous coding—if facing a problem where a
    synchronous operation seems the only solution, it is likely that the problem has
    been misunderstood. Nevertheless, edge cases requiring a file object existing
    fully in memory prior to executing further instructions (a blocking operation)
    do exist. Node give a developer the power to break with asynchronous tradition
    if it is the only possible solution (which it probably isn't!).
  prefs: []
  type: TYPE_NORMAL
- en: 'One synchronous operation developers regularly use (perhaps without realizing
    it) is the `require` directive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Until the dependency targeted by require is fully initialized, subsequent JavaScript
    instructions will not execute (file loading blocks the event loop). *Ryan Dahl*
    struggled with this decision to introduce synchronous operations (file operations
    in particular) into Node, as he mentioned at a Google Tech Talk on July 2013:'
  prefs: []
  type: TYPE_NORMAL
- en: According to [http://www.youtube.com/watch?v=F6k8lTrAE2g](http://www.youtube.com/watch?v=F6k8lTrAE2g),
  prefs: []
  type: TYPE_NORMAL
- en: '"I think this is an OK compromise. It pained me for months, to drop the purity
    of having an asynchronous module system. But, I think it''s ok.'
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  prefs: []
  type: TYPE_NORMAL
- en: 'It simplifies the code a lot to be able to just stick in "require, require,
    require" and not have to do an onload callback...I think that''s been a relatively
    OK compromise. [...] There''s really two parts to your program: there''s the loading
    and starting up phase...and you don''t really care how fast that runs...you''re
    going to load modules and stuff...the setup phase of your daemon, generally, is
    synchronous. It''s when you get into your event loop for serving requests that
    you want to be very careful about this. [...] I will give people synchronous file
    I/O. If they do it in servers...it won''t be terrible, right? The important thing
    is to never let them do synchronous network I/O."'
  prefs: []
  type: TYPE_NORMAL
- en: Synchronous code does have the advantage of being eminently predictable, as
    nothing else happens until this instruction is completed. When starting up a server,
    which will happen only rarely, Dahl is suggesting that a little certainty and
    simplicity goes a long way. The loading of configuration files, for example, might
    make sense on server initialization.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes a desire to use synchronous commands in Node development is simply
    a cry for help; a developer being overwhelmed by deeply nested callback structures.
    If ever faced with this pain, try some of the callback-taming libraries mentioned
    in [Chapter 2](4cb6b06a-7800-4595-9908-f14d1ced3602.xhtml), *Understanding Asynchronous
    Event-Driven Programming*.
  prefs: []
  type: TYPE_NORMAL
- en: Moving through directories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's apply what we have learned and create a directory iterator. The goal for
    this project is to create a function that will accept a directory path and return
    a JSON object reflecting the directory hierarchy of files, its nodes composed
    of file objects. We will also make our directory walker a more powerful event-based
    parser, consistent with the Node philosophy.
  prefs: []
  type: TYPE_NORMAL
- en: 'To move through nested directories, one must first be able to read a single
    directory. Node''s filesystem library provides the `fs.readdir` command for this
    purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Remembering that everything is a file, we will need to do more than simply
    getting a directory listing; we must determine the type of each member of our
    file list. By adding `fs.stat`, we have already completed a large majority of
    the logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This self-executing function receives a directory path argument `(".")`, folds
    that directory listing into an array of file names, fetches an `fs.Stats` object
    for each of these, and makes a decision based on the indicated file type (directory
    or not a directory) on what to do next. At this point, we also have the name of
    the current file and its attributes available to us. Clearly, we have already
    mapped a single directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'We must now map directories within directories, storing results in a JSON object
    reflecting the nested filesystem tree, with each leaf on the tree a file object.
    Recursively passing our directory reader function paths to subdirectories and
    appending returned results as branches of the final object is the next step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We create a `walk` method that receives a directory path and a callback that
    receives the directory graph or an error when `walk` is complete, following Node's
    style. Not much code is needed to create a very fast, non-blocking file tree walker,
    complete with file stats.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s publish events whenever a directory or file is encountered, giving
    any future implementation flexibility to construct its own representation of the
    filesystem. To do this, we will use the friendly `EventEmitter` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Now that we know how to discover and address files, we can start reading from
    and writing to them.
  prefs: []
  type: TYPE_NORMAL
- en: Reading from a file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our discussion of file descriptors, we touched on one method of opening a
    file, fetching a file descriptor, and ultimately pushing or pulling data through
    that reference. Reading files is a common operation. Sometimes, managing a read
    buffer precisely may be necessary, and Node allows byte-by-byte control. In other
    cases, one simply wants a no-frills stream that is simple to use.
  prefs: []
  type: TYPE_NORMAL
- en: Reading byte by byte
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `fs.read` method is the most low-level way Node offers for reading files.
  prefs: []
  type: TYPE_NORMAL
- en: fs.read(fd, buffer, offset, length, position, callback)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Files are composed of ordered bytes, and these bytes are addressable by their
    `position`, relative to the beginning of in the file (position zero [0]). Once
    we have
  prefs: []
  type: TYPE_NORMAL
- en: a file descriptor `fd`, we can begin to read `length` number of bytes and insert
    those into a `Buffer` object `buffer`, insertion beginning at a given buffer `offset`.
    For example, to copy the 8,366 bytes beginning at `position` 309 of the readable
    file `fd` into
  prefs: []
  type: TYPE_NORMAL
- en: a `buffer` beginning at an `offset` of 100, we will use `fs.read(fd, buffer,
    100, 8366, 309, callback)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code demonstrates how to open and read a file in 512 byte chunks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The resulting buffer can be piped elsewhere (including a server response object).
    It can also be manipulated using the methods of Node's `Buffer` object, such as
    conversion into a UTF8 string with `buffer.toString("utf8")`.
  prefs: []
  type: TYPE_NORMAL
- en: Fetching an entire file at once
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Often, one simply needs to fetch an entire file, without any ceremony or fine
    control. Node provides a shortcut method for exactly this.
  prefs: []
  type: TYPE_NORMAL
- en: fs.readFile(path, [options], callback)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Fetching the data contained by the `path` file can be accomplished in one step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We see how `callback` receives a buffer. It may be more desirable to receive
    the file data in a common encoding, such as UTF8\. We are able to specify the
    encoding of the returned data as well as the read mode using the `options` object,
    which has two possible attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**encoding**: A string, such as `utf8`, it defaults to null (no encoding)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**flag**: The file mode as a string, it defaults to `r`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Modifying the previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Creating a readable stream
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While `fs.readFile` is an excellent, simple way to accomplish a common task,
    it does have the significant drawback of requiring that an entire file be read
    into memory prior to any part of the file being sent to a callback. For large
    files or files of unknown size, this isn't a good solution.
  prefs: []
  type: TYPE_NORMAL
- en: In the last chapter, we learned about data streams and the `Stream` object.
    While files are easily and naturally handled using readable streams, Node provides
    a dedicated file streaming interface that offers a compact file streaming facility
    without the extra construction work, with more flexibility than that offered by
    `fs.readFile`.
  prefs: []
  type: TYPE_NORMAL
- en: fs.createReadStream(path, [options])
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `fs.createReadStream(path, [options])` method returns a readable stream
    object for file at `path`. You may then perform stream operations on the returned
    object, such as `pipe()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following options are available:'
  prefs: []
  type: TYPE_NORMAL
- en: '`flags`: File mode argument as a string. Defaults to `r`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`encoding`: One of `utf8`, `ascii`, or `base64`. Defaults to no encoding.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fd`: One may set `path` to null, instead passing the call a file descriptor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mode`: Octal representation of file mode, defaulting to 0666.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bufferSize`: The chunk size, in bytes, of the internal read stream. Defaults
    to 64 * 1024 bytes. You can set this to any number, but memory allocation is strictly
    controlled by the host OS, which may ignore a request. Refer to: [https://groups.google.com/forum/?fromgroups#!topic/nodejs/p5FuU1oxbeY](https://groups.google.com/forum/?fromgroups#!topic/nodejs/p5FuU1oxbeY).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`autoClose`: Whether to automatically close the file descriptor (a la `fs.close`).
    Defaults to true. You may want to set this to false and close manually if you
    are sharing a file descriptor across many streams, as closing a descriptor will
    disrupt any other readers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`start`: Begin reading from this position. Default is 0.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`end`: Stop reading at this position. Default is the file byte length.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading a file line by line
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While reading a file stream byte-by-byte is sufficient for any file-parsing
    job, text files in particular are often more usefully read line by line, such
    as when reading logfiles. More precisely, any stream can be understood in terms
    of the chunks of data separated by newline characters, typically `rn` on UNIX
    systems. Node provides a native module whose methods simplify access to newline-separated
    chunks in data streams.
  prefs: []
  type: TYPE_NORMAL
- en: The Readline module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Readline` module has a simple but powerful goal, that is, to make reading
    a stream of data line-by-line easier. The bulk of its interface is designed to
    make command-line prompting easier, such that interfaces taking user input are
    easier to design.
  prefs: []
  type: TYPE_NORMAL
- en: Remembering that Node is designed for I/O, that I/O operations normally involve
    moving data between readable and writable streams, and that `stdout` and `stdin`
    are stream interfaces identical to the file streams returned by `fs.createReadStream`
    and `fs.createWriteStream`, we will look at how this module can be similarly used
    to prompt file streams for a line of text.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start working with the `Readline` module, one must create an interface defining
    the input stream and the output stream. The default interface options prioritize
    usage as a terminal interface. The options we are interested in are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`input`: Required. The readable stream being listened to.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`output`: Required. The writable stream being written to.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`terminal`: Set this to true if both the input and output streams should be
    treated like a Unix terminal, or **Teletypewriter** (**TTY**). For files, you
    will set this to false.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Reading the lines of a file is made easy through this system. For example,
    assuming that one has a dictionary file listing common words in the English language,
    one might want to read the list into an array for processing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Note how we disable TTY behavior, handling the lines ourselves without redirecting
    to an output stream.
  prefs: []
  type: TYPE_NORMAL
- en: 'As expected with a Node I/O module, we are working with stream events. The
    events listeners that may be of interest are as listed:'
  prefs: []
  type: TYPE_NORMAL
- en: '`line`: Receives the most recently read line, as a string'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pause`: Called whenever the stream is paused'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`resume`: Called whenever a stream is resumed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`close`: Called whenever a stream is closed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Except for `line`, these event names reflect the `Readline` methods, pause a
    stream with `Readline.pause`, `resume` with `Readline.resume`, and `close` with
    `Readline.close`.
  prefs: []
  type: TYPE_NORMAL
- en: Writing to a file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As with reading files, Node provides a rich collection of tools for writing
    to files. We'll see how Node makes it as easy to target a file's contents byte-by-byte,
    as it is to pipe continuous streams of data into a single writable file.
  prefs: []
  type: TYPE_NORMAL
- en: Writing byte by byte
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `fs.write` method is the most low-level way Node offers for writing files.
    This method gives us precise control over where bytes will be written to in a
    file.
  prefs: []
  type: TYPE_NORMAL
- en: fs.write(fd, buffer, offset, length, position, callback)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To write the collection of bytes between positions 309 and 8,675 **(**length
    8,366) of `buffer` to the file referenced by file descriptor `fd`, insertion beginning
    at position 100:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Note that for files opened in the append (`a`) mode, some operating systems
    may ignore `position` values, always adding data to the end of the file. Additionally,
    it is unsafe to call `fs.write` multiple times on the same file without waiting
    for the callback. Use `fs.createWriteStream` in those cases.
  prefs: []
  type: TYPE_NORMAL
- en: With such precise control, we can intelligently structure files. In the following
    (somewhat contrived) example, we create a file-based database containing indexed
    information for 6 months of baseball scores for a single team. We want to be able
    to quickly look up whether this team won or lost (or did not play) on a given
    day.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since a month can have at most 31 days, we can (randomly) create a 6 x 31 grid
    of data in this file, placing one of three values in each grid cell: L (loss),
    W (win), N (no game). For fun, we also create a simple **CLI** (**Command-Line
    Interface**) to our database with a basic query language. This example should
    make it clear how `fs.read`, `fs.write`, and `Buffer` objects are used to precisely
    manipulate bytes in files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Once running, we can simply type in a month/day pair and rapidly access that
    data cell. Adding in bounds checking for the input values would be a simple improvement.
    Pushing the file stream through a visualizing UI might be a nice exercise.
  prefs: []
  type: TYPE_NORMAL
- en: Writing large chunks of data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For straightforward write operations `fs.write` may be overkill. Sometimes,
    all that is needed is a way to create a new file with some content. Just as common
    is the need to append data to the end of a file, as one might do in a logging
    system. The `fs.writeFile` and `fs.appendFile` methods can help us with those
    scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: fs.writeFile(path, data, [options], callback)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `fs.writeFile(path, data, [options], callback)` method writes the contents
    of `data` to the file at `path`. The data argument can be either a buffer or
  prefs: []
  type: TYPE_NORMAL
- en: 'a string. The following options are available:'
  prefs: []
  type: TYPE_NORMAL
- en: '`encoding`: Defaults to `utf8`. If data is a buffer, this option is ignored.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mode`: Octal representation of file mode, defaulting to 0666.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`flag`: Write flags, defaulting to `w`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Usage is straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: fs.appendFile(path, data, [options], callback)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Similar to `fs.writeFile`, except that `data` is appended to the end of the
    file at `path`. Also, the `flag` option defaults to `a`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a writable stream
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If the data being written to a file arrives in chunks (such as occurs with a
    file upload), streaming that data through a `WritableStream` object interface
    provides more flexibility and efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: fs.createWriteStream(path, [options])
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `fs.createWriteStream(path, [options])` method returns a writable stream
    object for file at `path`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following options are available:'
  prefs: []
  type: TYPE_NORMAL
- en: '`flags`: File mode argument as a string. Defaults to `w`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`encoding`: One of `utf8`, `ascii`, or `base64`. Defaults to no encoding.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mode`: Octal representation of file mode, defaulting to 0666.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`start`: An offset indicating the position in the file where writing should
    begin.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, this little program functions as the world''s simplest word processor,
    writing all terminal input to a file, until the terminal is closed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Caveats
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The side effects of opening a file descriptor and reading from it are minimal,
    such that in normal development, very little thought is given to what is actually
    happening within the system. Normally, reading a file doesn't change it.
  prefs: []
  type: TYPE_NORMAL
- en: 'When writing to a file, a number of concerns must be addressed, such as these:'
  prefs: []
  type: TYPE_NORMAL
- en: Is there sufficient writable storage space available?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is another process simultaneously accessing this file, or even erasing it?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What must be done if a write operation fails or is unnaturally terminated mid-stream?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We've seen the exclusive write mode flag (`wx`) that can help in the case of
    multiple write processes simultaneously trying to create a file. Full solutions
    to all the concerns one might face when writing to files are difficult to derive
    in general, or state briefly. Node encourages asynchronous programming. Nevertheless,
    with regard to the filesystem in particular, sometimes synchronous, deterministic
    programming is necessary. You are encouraged to keep these and other issues in
    mind, and to keep I/O non-blocking whenever possible.
  prefs: []
  type: TYPE_NORMAL
- en: Serving static files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Anyone using Node to create a web server will need to respond intelligently
    to HTTP requests. An HTTP request to a web server for a resource expects some
    sort of response. A basic file static file server might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This server services GET requests on port `8000`, expecting to find a local
    file at a relative path equivalent to the URL path segment. We see how easy Node
    makes it for us to stream local file data, simply piping a `ReadableStream` into
    a `WritableStream` representing a client socket connection. This is an enormous
    amount of functionality to be safely implemented in a handful of lines.
  prefs: []
  type: TYPE_NORMAL
- en: Eventually, a great deal more will be added, such as handling routines for standard
    HTTP methods, handling errors and malformed requests, setting proper headers,
    managing favicon requests, and so forth.
  prefs: []
  type: TYPE_NORMAL
- en: Let's build a reasonably useful file server with Node, one that will respond
    to HTTP requests by streaming back a resource and which will respect caching requests.
    In the process, we will touch on how to manage content redirection. Later on in
    this chapter, we will also look at implementing file uploads. Note that a web
    server fully compliant with all features of HTTP is a complicated beast, so what
    we are creating should be considered a good start, not an end.
  prefs: []
  type: TYPE_NORMAL
- en: Redirecting requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, a client will try to `GET` a URL that is incorrect or incomplete
    in some way, the resource may have been moved, or there are better ways to make
    the same request. Other times, a `POST` may create a new resource at a new location
    the client cannot know, necessitating some response header information pointing
    to the newly created URI. Let's look at two common redirection scenarios someone
    implementing a static file server with Node might face.
  prefs: []
  type: TYPE_NORMAL
- en: 'Two response headers are fundamental to redirection:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Location`: This indicates a redirection to a location where said content body
    can be found'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Content-Location`: This is meant to indicate the URL where the requester will
    find the original location of the entity enclosed in the response body'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Also, there are two specific use cases for these headers:'
  prefs: []
  type: TYPE_NORMAL
- en: To provide information about the location of a newly created resource
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: in response to a `POST`
  prefs: []
  type: TYPE_NORMAL
- en: To inform the client of an alternate location for the requested resource
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: in response to a `GET`
  prefs: []
  type: TYPE_NORMAL
- en: There are many possible pairings of `Location` and `Content-Location` headers
    with HTTP status codes, the **3xx** (redirection) set in particular. In fact,
    these headers may even appear together in the same response. The user is encouraged
    to read the relevant sections of the HTTP/1.1 specification, as only a small set
    of common cases is discussed here.
  prefs: []
  type: TYPE_NORMAL
- en: Location
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Responding to a `POST` with a `201` status code indicates that a new resource
    has been created its URI assigned to the `Location` header and that the client
    may go ahead and use that URI in the future. Note that it is up to the client
    to decide whether, and when, to fetch this resource. As such, this is not, strictly
    speaking, a redirect.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, a system might create new accounts by posting new user information
    to a server, expecting to receive the location of a new user page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, in cases where a resource creation request has been accepted but
    not yet fulfilled, a server will indicate a status of `202`. This will be the
    case in the preceding example if creation of the new user record had been delegated
    to a worker queue, which might at some point in the future create a record at
    the given `Location`.
  prefs: []
  type: TYPE_NORMAL
- en: We will see a realistic implementation demonstrating this usage later on in
    the chapter, when we discuss file uploads.
  prefs: []
  type: TYPE_NORMAL
- en: Content-Location
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When a `GET` is made to a resource that has multiple representations and those
    can be found at distinct resource locations, a `content-location` header for the
    particular entity should be returned. For example, content format negotiation
    is a good candidate for `Content-Location` handling. One might be interested in
    retrieving all blog posts for a given month, perhaps available at a URL such as:
    `http://example.com/september/`. GET requests with an `Accept` header of `application/json`
    will receive a response in JSON format. A request for XML will receive that representation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If a caching mechanism is being used those resources may have alternate permanent
    locations, such as `http://example.com/cache/september.json` or `http://example.com/cache/september.xml`.
    One will send this additional location information via `Content-Location`, in
    a response object resembling this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'In cases where the requested URL has been moved, permanently or temporarily,
    the **3xx** group of status codes can be used with `Content-Location` to indicate
    this state. For example, to redirect a request to a URL that has been permanently
    moved, one should send a 301 code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Implementing resource caching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a general rule, never expend resources delivering irrelevant information
    to clients. For an HTTP server, resending files that the client already possesses
    is an unnecessary I/O cost, exactly the wrong way to implement a Node server,
    increasing latency as well as the financial hit of paying for misappropriated
    bandwidth.
  prefs: []
  type: TYPE_NORMAL
- en: Browsers maintain a cache of the files they have already fetched, and an **Entity
    Tag** (**ETag**) identifies these files. An ETag is a response header sent by
    servers to uniquely identify entities they are returning, such as a file. When
    a file changes on a server, that server will send a different ETag for said file,
    allowing file changes to be tracked by clients.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a client makes a request to a server for a resource contained within that
    client''s cache, that request will contain an `If-None-Match` header set to the
    value of the ETag associated with the said cached resource. The `If-None-Match`
    header can contain one or multiple ETags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: A server understands this header and will return the full entity body of the
    requested resource only if none of the sent ETags match the current resource entity
    tag. If one of the sent ETags matches the current entity tag, the server will
    respond with a 304 (not modified) status, which should result in a browser, fetching
    the resource from its internal cache.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming that we have an `fs.Stats` object available, managing cache controls
    on a resource can be done easily with Node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: We create an `etag` for the current file by creating an MD5 of the current file
    size and its last modified time, and match against the sent `If-None-Match` header.
    If the two do not match, the resource representation has changed, and the new
    version must be sent back to the requesting client. Note that the specific algorithm
    one should use to create an `etag` is not formally specified. The example technique
    should work well for most purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hey! What about `Last-Modified` and `If-Unmodified-Since`? These are fine headers
    and are also useful in the case of caching files. Indeed, one should set the `Last-Modified`
    header where possible when responding to entity requests. The techniques we''re
    describing here using ETag will work similarly with these tags, and in fact, using
    both Etags and these other tags is encouraged. For more information, consult:
    [http://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html#sec13.3.4](http://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html#sec13.3.4).'
  prefs: []
  type: TYPE_NORMAL
- en: Handling file uploads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is likely that anyone reading this sentence has had at least one experience
    with uploading a file from a client to a server. Some may have even implemented
    a file upload service, a server that will receive and do something useful with
    a multipart data stream. Within popular development environments, this task has
    been made very easy. In the PHP environment, for example, uploaded data is automatically
    processed and made globally available, neatly parsed and packaged into an array
    of files or form field values, without the developer having written a single line
    of code.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, Node leaves implementation of file upload handling to the developer,
    a challenging bit of work many developers may be unable to successfully or safely
    complete.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, Felix Geisendorfer created the **Formidable** module, one of the
    most important early contributions to the Node project. A widely implemented,
    enterprise-grade module with extensive test coverage, it not only makes handling
    file uploads a snap, but can be used as a complete tool for handling form submissions.
    We will use this library to add file upload capability to our file server.
  prefs: []
  type: TYPE_NORMAL
- en: For more information about how HTTP file uploads are designed, and the tricky
    implementation problems developers must overcome, consult the multipart/form-data
    specification at [http://www.w3.org/TR/html401/interact/forms.html#h-17.13.4.2](http://www.w3.org/TR/html401/interact/forms.html#h-17.13.4.2)
    and Geisendorfer's breakdown of how **Formidable** was conceived of and evolved
    at [http://debuggable.com/posts/parsing-file-uploads-at-500-mb-s-with-node-js:4c03862e-351c-4faa-bb67-4365cbdd56cb](http://debuggable.com/posts/parsing-file-uploads-at-500-mb-s-with-node-js:4c03862e-351c-4faa-bb67-4365cbdd56cb).
  prefs: []
  type: TYPE_NORMAL
- en: 'First, install `formidable` via npm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now `require` it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: We will assume that file uploads will be posted to our server along a path of
  prefs: []
  type: TYPE_NORMAL
- en: '`/uploads/`, and that the upload arrives via a HTML form that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: This form will allow a client to write some sort of title for the upload, and
    to select one (or multiple) files for uploading. At this point, our only responsibility
    on our server is to properly detect when a `POST` request has been made and pass
    the relevant request object to Formidable.
  prefs: []
  type: TYPE_NORMAL
- en: 'We won''t be covering every part of the comprehensive formidable API design,
    but we''ll focus on the key `POST` events the library exposes. As formidable extends
    `EventEmitter`, we use the `on(eventName,callback)` format to catch file data,
    field data, and termination events, sending a response to the client describing
    what the server has successfully processed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: We see here how a `formidable` instance receives an `http.Incoming` object through
    its `parse` method, and how the write path for incoming files is set using the
    `uploadDir` attribute of that instance. The example sets this directory to the
    local directory. A real implementation would likely target a dedicated upload
    folder, or even direct the received file to a storage service, receiving in return
    the final storage location (perhaps receiving it via HTTP and a `Location` header...).
  prefs: []
  type: TYPE_NORMAL
- en: 'Also note how the file event callback receives a formidable `File` object as
    a second argument, which contains important file information including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**size**: The size of the uploaded file, in bytes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*` **path**: The current location of the uploaded file on the local filesystem,
    such'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: as `/tmp/bdf746a445577332e38be7cde3a98fb3`
  prefs: []
  type: TYPE_NORMAL
- en: '**name**: The original name of the file as it existed on the client filesystem,
    such as `lolcats.jpg`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**type**: The file mime type, such as `image/png`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In a few lines of code, we''ve implemented a significant amount of `POST` data
    management. Formidable also provides tools for handling progress indicators, dealing
    with network errors, and more, which the reader can learn about by visiting: [https://github.com/felixge/node-formidable](https://github.com/felixge/node-formidable).'
  prefs: []
  type: TYPE_NORMAL
- en: Putting it all together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Recalling our discussion of favicon handling from the last chapter and adding
    what we''ve learned about file caching and file uploading, we can now construct
    a simple file server handling the `GET` and `POST` requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Note the 404 (not found) and 500 (internal server error) status codes.
  prefs: []
  type: TYPE_NORMAL
- en: '`Content-Length` is measured in bytes, not characters. Normally, your data
    will be in single byte characters (hello is five bytes long), but this is not
    always the case. If you are determining the length of a stream buffer, use `Buffer.byteLength`.'
  prefs: []
  type: TYPE_NORMAL
- en: A simple file browser
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s take what we''ve learned about files and Node to do something that
    truly (and hopefully) no web page can; let''s directly browse the entire hard
    disk of your personal computer! To make this possible, we''ll use two powerful
    recent additions to the JavaScript and Node family: *Electron* and *Vue.js*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start out at your terminal with commands like these:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The default answers are fine, except for the entry point—instead of `index.js`,
    type `main.js`. When you''re done, you should have a `package.json` file like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s take a look at these three commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Try the first to ensure that npm got a working copy of Electron onto your computer.
    As of this writing, the current version is v1.7.9\. The second command will execute
    electron "empty", that is, without giving it an app to run. The third command
    tells electron to run the app in this folder: Electron will read `package.json`
    to find and run `main.js`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, you can use `-g` to install Electron globally, and then reach
    the executable more easily with commands like these:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Electron
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s run the second command. The result may be surprising: a graphical window
    appears on your screen!:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/74646cbc-c5e5-41ff-b207-9d1524a547a4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'What is this? What is Electron? Let''s answer that question several ways: to
    the end user, to the developer or product owner, under the hood, and at the end
    of the chapter, from the perspective of JavaScript''s history and development.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To the end user, an Electron app is just a regular desktop app. Users can''t
    even tell it''s made with Electron. The unboxing flow is exactly the same: the
    user gets the app from their favorite app store, or downloads `setup.exe` from
    your website. The daily experience is also the same: the app has an icon on the
    Start menu or dock, menus where they should be, a `File|Open...` dialog—all the
    features users expect from a desktop application. You might use Slack on Windows
    or macOS, for instance, and may be surprised to learn that Slack is made with
    Electron.'
  prefs: []
  type: TYPE_NORMAL
- en: To the developer or product owner, Electron is a great way to make desktop apps.
    Developers can use the modern and powerful technologies they learned for the web
    on the desktop now. All your favorite npm modules can come along, too. Product
    owners like being able to ship version 1.0 simultaneously on Windows, Mac, and
    Linux with very little additional development or testing required. Business stakeholders
    like being able to task a single group of web developers across web and desktop
    projects, instead of having to hire new individual dedicated teams (a separate
    one per target operating system) experienced in each individual native desktop
    stack.
  prefs: []
  type: TYPE_NORMAL
- en: Under the hood, Electron is pretty amazing. It's built from parts of both Chromium
    and Node, getting abilities like page rendering from Chromium, and abilities like
    buffers, files, and sockets from Node. Both Chromium and Node contain V8, and
    inside V8 a JavaScript event loop, of course. In an impressive engineering feat,
    Electron merges these two event loops together, allowing a single JavaScript event
    to run code that affects both the screen and the system.
  prefs: []
  type: TYPE_NORMAL
- en: Electron is made by GitHub, which also develops the Atom text editor. To make
    Atom as hackable as the web, GitHub built it using web technologies. Realizing
    that other software teams might want to construct desktop apps this way, GitHub
    released their tools first as Atom Shell, and simplified the name to Electron.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''ve got Electron running, let''s make Electron an app of our own.
    The `electron .` command causes Electron to look in `package.json` to see what
    it should do. There, we''re pointing it to `main.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'You can imagine that Node is running the file, even though the executable that''s
    running it is actually Electron (which has Node and V8 inside, of course). Note
    how the code can require familiar Node modules like `path` and `url` as well as
    some new ones, such as `electron`. The code in `main.js` creates a special Electron
    browser window that''s 800 pixels wide and 800 pixels high, and navigates it to
    `index.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: This also looks quite familiar from what we'd expect on the web. We'll talk
    about Vue later in this chapter; right now, note the reload `button` at the top
    of the page and the `script` tag at the end.
  prefs: []
  type: TYPE_NORMAL
- en: The button is useful when developing. Instead of restarting the Electron process
    at the command line, you can just make a change to this page or the JavaScript
    it brings in and see the results from hitting the Reload button. Electron doesn't
    display Chromium's default browser toolbar, where the Reload button lives, but
    View, Reload is available on the menu bar on macOS, and it's even easier to put
    a Reload button right in the page.
  prefs: []
  type: TYPE_NORMAL
- en: To understand the `script` tag at the end, it's best to first get a basic understanding
    of Electron's process architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Electron processes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Built from Chromium, Electron inherited Chromium''s (and Chrome''s) one-process-per-tab
    architecture. With Electron running our app, there is only one "tab": the window
    on your screen, but there are still two processes. The *main* process represents
    the underlying browser, which you started from the command line, at which point
    it read `package.json`, and then ran `main.js`. Electron''s main process can create
    new `BrowserWindow` objects, and deal with events that affect the overall lifecycle
    of the desktop app, from startup to shutdown.'
  prefs: []
  type: TYPE_NORMAL
- en: On the page Electron opens, however, a different process, the *renderer* process,
    runs the JavaScript there. Only a renderer process is able to perform GUI-related
    tasks, like manipulating the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: Node is available in both processes. If a module expects the DOM to be present,
    it may not work in the main process, however. For instance, jQuery fails to load
    in Electron's main process, but works fine in a renderer process, while Handlebars
    works fine in both.
  prefs: []
  type: TYPE_NORMAL
- en: In instances where the code in one Electron process needs to perform an action
    or get an answer from some code in the other process, the solution is Node's standard
    inter-process communication tools, described later in [Chapter 7](48e16668-9318-4577-b3c0-3f4dbce035d9.xhtml),
    *Using Multiple Processes*. Additionally, Electron conveniently wraps some of
    these in its own API.
  prefs: []
  type: TYPE_NORMAL
- en: The renderer process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we''ve seen Electron start, run `main.js`, and open `index.html`. In
    summary, here''s how the whole thing works:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Electron''s *main* process does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: reads `package.json`, which tells it to then
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: run `main.js`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This causes Electron to start a *renderer* process to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: parse `index.html`, which then
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: runs `renderer.js`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s take a look at the code there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: First, this code brings in the bluebird promise library, setting it to `Promise`.
    The call to `Promise.promisifyAll()` creates functions like `fs.lstatAsync()`,
    the promisified version of `fs.lstat()`.
  prefs: []
  type: TYPE_NORMAL
- en: Our app's core logic is factored into a single function named `go()`, which
    gets passed an absolute filesystem path the user wants the app to take a look
    at. If the path is to an image, the app shows it on the page. If the path is to
    a directory, the app lists the folder's contents.
  prefs: []
  type: TYPE_NORMAL
- en: To perform this logic, the preceding code first simply looks for a common image
    file extension. If not present, an asynchronous step looks at the disk with `fs.lstatAsync()`
    to then be able to call `stat.isDirectory()`. If it is a directory, another promisified
    call, `fs.readdirAsync()`, gets the directory listing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a picture of our simple Electron-powered file browser in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c9740216-ac9e-4e7f-a15a-74a2a6ef710e.png)'
  prefs: []
  type: TYPE_IMG
- en: Vue.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our app's user experience is powered by *Vue.js*, a frontend JavaScript framework
    for building and easily changing the contents of a web page. Like React, Vue lets
    you template components, put them on the page, and change them when the data underneath
    changes.
  prefs: []
  type: TYPE_NORMAL
- en: React uses JSX to combine HTML tags with JavaScript code. This requires a preprocessor
    like *Babel* to transpile the JSX portions into ES6 JavaScript. In a typical React
    stack, *webpack* manages a build process that includes Babel, converting and combining
    your development files into files you'll run, test, and eventually deploy. The
    webpack dev server shows your site as you code it, even automatically refreshing
    as you change your code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Vue, however, doesn''t require a transpilation step. You can use it with webpack,
    but you can also use it with just a script tag, like this one in our app''s `index.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: This flexibility makes it easy to get started with Vue, makes Vue easy to get
    running in Electron, and is why we've picked it for this example app.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back on the `index.html` page, take a look at these lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, in the `renderer.js` script, take a look at this part:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: In the page, `<div id="app">` identifies `div` as our app, and in the script,
    `var app = new Vue({});` creates the new JavaScript object that connects to and
    controls the *app* `div`. The data object inside `app` defines values that appear
    in the div and thus on the page. For example, `app.location`, which through some
    clever internal linking with `this` reaches into the `data` object above, is shown
    on the page where `{{ location }}` appears. Vue even watches for changes to `data.location`—set
    that to a new value and the page will update automatically. With this ability,
    Vue is said to be *reactive*.
  prefs: []
  type: TYPE_NORMAL
- en: Browse around your local disk with the file browser we just built, and imagine
    all the desktop apps you can now create with Node and Electron.
  prefs: []
  type: TYPE_NORMAL
- en: Earlier, this chapter asked, "What is Electron?" and composed different answers
    imagining different stakeholders and considering different perspectives.
  prefs: []
  type: TYPE_NORMAL
- en: Electron gets JavaScript one step closer to Kris Kowal's goal for the language,
    which you may remember from [Chapter 1](ad3a0c29-f1fb-4319-9042-a9f38bb0b53a.xhtml),
    *Understanding the Node Environment*, is no less than "world domination", meaning
    able to run everywhere and do anything. Also, taking JavaScript's place in the
    last few decades of computing into consideration, it achieves this with some wry
    irony.
  prefs: []
  type: TYPE_NORMAL
- en: Brendan Eich created JavaScript to script small tasks within web pages running
    on browsers on personal computers in the 1990s, which had just recently gained
    bitmapped displays and graphical operating systems. There, JavaScript was tightly
    contained within the sandbox of the browser tab. The sandbox enforced strict security
    requirements, and limited it from, among other things, looking at some files.
    Close to the user and close to the screen, JavaScript could validate form data,
    and change CSS on the fly. In this first stage of life, most days, JavaScript
    animated some text.
  prefs: []
  type: TYPE_NORMAL
- en: Node took JavaScript to the server, distancing it from the graphical screen,
    but freeing it from the confines of the browser. There, JavaScript became a competent
    and complete systems language, accessing files and sockets to perform useful and
    powerful tasks. In this second stage of life, most days, JavaScript migrated a
    database.
  prefs: []
  type: TYPE_NORMAL
- en: Electron takes JavaScript back to the client. Like a wandering feudal warrior
    returning to his home village after years of exile, (and, of course, distant and
    elite training) JavaScript returns with ES6 features and npm modules it developed
    in the harsh wasteland of the server, being used and developed alongside formidable
    partners (and oftentimes foes) like C++ and Java. Back on the desktop and armed
    with Electron, it can use these abilities outside of the restricted confines of
    the browser. In this third stage of life, JavaScript really can do anything.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we saw how Node's API is a comprehensive map to native filesystem
    bindings, exposing a full range of functionality to the developer while requiring
    very little code or complexity. Additionally, we saw how files are easily wrapped
    into `Stream` objects, and how this consistency with the rest of Node's design
    simplifies interactions between different types of I/O, such as between network
    data and files. Using Electron, we built a file browser that runs as a cross-platform
    native application, opening up a whole new world for Node developers.
  prefs: []
  type: TYPE_NORMAL
- en: We've also learned something about how to build servers with Node that can accommodate
    regular client expectations, easily implementing file uploading and resource caching.
    Having covered the key features of Node, it is time to use these techniques in
    building larger applications able to handle many thousands of clients.
  prefs: []
  type: TYPE_NORMAL
