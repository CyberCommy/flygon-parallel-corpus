- en: Using Node to Access the Filesystem
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Node访问文件系统
- en: '"We have persistent objects - they''re called files."'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '"我们有持久对象——它们被称为文件。"'
- en: – *Ken Thompson*
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: – Ken Thompson
- en: A file is simply a chunk of data that is persisted, usually, on some hard medium
    such as a hard drive. Files are normally composed of a sequence of bytes whose
    encoding maps onto some other pattern, like a sequence of numbers or electrical
    pulses. A nearly infinite number of encodings are possible, with some common ones
    being text files, image files, and music files. Files have a fixed length, and
    to be read, their character encoding must be deciphered by some sort of reader,
    such as an MP3 player or a word processor.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 文件只是一块数据，通常保存在硬盘等硬介质上。文件通常由一系列字节组成，其编码映射到其他模式，如一系列数字或电脉冲。几乎可以有无限数量的编码，其中一些常见的是文本文件、图像文件和音乐文件。文件具有固定长度，要读取它们，必须由某种阅读器解密其字符编码，例如MP3播放器或文字处理器。
- en: When a file is in transit, moving through a cable after it's been siphoned off
    of some storage device, it is no different than any other data stream running
    through the wire. Its previous solid state is just a stable blueprint that can
    be easily and infinitely copied.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 当文件在传输中，从某个存储设备吸取后通过电缆移动时，它与通过电线运行的任何其他数据流没有区别。它以前的固态只是一个稳定的蓝图，可以轻松且无限地复制。
- en: We've already seen how event streams reflect the core design principles informing
    Node's design, where byte streams are to be read from and written to, and piped
    into other streams, emitting relevant stream events, such as `end`. Files are
    easily understood as being containers of data, filled with bytes that can be extracted
    or inserted partially or as a whole.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到事件流如何反映了Node设计的核心设计原则，其中字节流应该被读取和写入，并被传送到其他流中，发出相关的流事件，如`end`。文件很容易被理解为数据的容器，其中充满了可以部分或完整提取或插入的字节。
- en: In addition to their natural similarity to streams, files also display the characteristics
    of objects. Files have properties that describe the interface available for accessing
    file contents—data structures with properties and associated access methods.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 除了它们与流的自然相似性之外，文件还显示了对象的特征。文件具有描述访问文件内容的接口的属性——具有属性和相关访问方法的数据结构。
- en: A **filesystem** reflects some concept of how files should be organized—how
    they are identified, where they are stored, how they are to be accessed, and so
    forth. A common filesystem for UNIX users is the **UFS** (**Unix File System**),
    while Windows users may be familiar with **NTFS** (**New Technology File System**).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 文件系统反映了文件应该如何组织的一些概念——它们如何被识别，它们存储在哪里，如何被访问等等。UNIX用户常用的文件系统是UFS（Unix文件系统），而Windows用户可能熟悉NTFS（新技术文件系统）。
- en: It is interesting that the designers of the Plan 9 operating system (a team
    including *Ken Thompson*) decided to have *all* control interfaces represented
    as filesystems, such that all system interfaces (across devices, across applications)
    are modeled as file operations. Treating files as first-class citizens is a philosophy
    the UNIX OS also uses; using files as references to named pipes and sockets, among
    other things, gives developers enormous power when shaping data flow.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，Plan 9操作系统的设计者（包括Ken Thompson在内的一个团队）决定将*所有*控制接口表示为文件系统，以便所有系统接口（跨设备，跨应用程序）都被建模为文件操作。将文件视为一等公民是UNIX操作系统也使用的哲学；使用文件作为命名管道和套接字的引用等等，使开发人员在塑造数据流时拥有巨大的力量。
- en: File objects are also powerful, and the system they reside within exposes fundamental
    I/O interfaces that must be easy to use, consistent, and very fast. Not surprisingly,
    Node's `file` module exposes just such an interface.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 文件对象也是强大的，它们所在的系统公开了必须易于使用、一致且非常快速的基本I/O接口。不足为奇，Node的`file`模块公开了这样的接口。
- en: 'We will be considering handling files in Node from these two perspectives:
    how file data content is streamed in and out (read from and written), and how
    the attributes of file objects are modified, such as changing file permissions.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从这两个角度考虑在Node中处理文件：文件数据内容如何流入和流出（读取和写入），以及如何修改文件对象的属性，如更改文件权限。
- en: Additionally, we will cover the responsibilities of the Node server, in terms
    of accepting file uploads and servicing file requests. By working through examples
    of directory iterators and file servers, the full range and behavior of Node's
    filesystem API should become clear.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们将介绍Node服务器的责任，接受文件上传并处理文件请求。通过示例演示目录迭代器和文件服务器，Node的文件系统API的全部范围和行为应该变得清晰。
- en: Lastly, we'll take JavaScript back to the desktop, using GitHub's Electron framework
    to make our own desktop app, a simple file browser.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将使用GitHub的Electron框架将JavaScript带回桌面，制作我们自己的桌面应用程序，一个简单的文件浏览器。
- en: Directories, and iterating over files and folders
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 目录和文件夹的迭代
- en: Typically, a filesystem groups files into collections, normally referred to
    as directories. One navigates through directories to find individual files. Once
    a target file is found, the file object must be wrapped by an interface exposing
    the file contents for reading and writing.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，文件系统将文件分组成集合，通常称为目录。通过目录导航以找到单个文件。一旦找到目标文件，文件对象必须被包装成一个公开文件内容以供读取和写入的接口。
- en: As Node development often involves the creation of servers that both accept
    and emit file data, it should be clear how important transfer speed at this active
    and important I/O layer is. As mentioned earlier, files can also be understood
    as objects, and objects have certain attributes.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Node开发通常涉及创建既接受又发出文件数据的服务器，因此应该清楚这个活跃和重要的I/O层的传输速度有多重要。正如前面提到的，文件也可以被理解为对象，而对象具有某些属性。
- en: Types of files
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件类型
- en: 'There are six types of files commonly encountered on a UNIX system:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在UNIX系统上通常遇到的有六种类型的文件：
- en: '**Ordinary files**: These contain a one-dimensional array of bytes, and cannot
    contain other files.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**普通文件**：这些文件包含一维字节数组，不能包含其他文件。'
- en: '**Directories**: These are also files implemented in a special way such that
    they can describe collections of other files.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**目录**：这些也是以特殊方式实现的文件，可以描述其他文件的集合。'
- en: '**Sockets**: Used for IPC, allowing processes to exchange data.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**套接字**：用于IPC，允许进程交换数据。'
- en: '**Named pipe**: A command such as `ps aux | grep node` creates a pipe,'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**命名管道**：像`ps aux | grep node`这样的命令创建了一个管道，'
- en: which is destroyed once the operation terminates. Named pipes are persistent
    and addressable, and they can be used variously by multiple processes for IPC
    indefinitely.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦操作终止，它就会被销毁。命名管道是持久的、可寻址的，并且可以被多个进程用于IPC。
- en: '**Device files**: These are representations of I/O devices, processes that
    accept streams of data; `/dev/null` is commonly an example of a character device
    file (accepts serial streams of I/O), and `/dev/sda` is an example of a block
    device file (allowing random access I/O for blocks of data) representing a data
    drive.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设备文件**：这些是I/O设备的表示，接受数据流的进程；`/dev/null`通常是字符设备文件的一个例子（接受I/O的串行数据流），`/dev/sda`是块设备文件的一个例子（允许数据块的随机访问I/O），代表一个数据驱动器。'
- en: '**Links**: These are pointers to other files of two types: hard links and symbolic
    links. Hard links directly point to another file and are indistinguishable from
    the target file. Symbolic links are indirect pointers and are distinguishable
    from normal files.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**链接**：这些是指向其他文件的指针，有两种类型：硬链接和符号链接。硬链接直接指向另一个文件，并且与目标文件无法区分。符号链接是间接指针，并且可以与普通文件区分开。'
- en: Most Node filesystem interactions encounter only the first two types, with the
    third only indirectly via the Node API. A deeper explanation of the remaining
    types is beyond the scope of this discussion. However, Node provides a full suite
    of file operations via the `file` module, and the reader should have at least
    some familiarity with the full range and power of file types.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数Node文件系统交互只涉及前两种类型，第三种类型只是通过Node API间接涉及。对剩余类型的更深入解释超出了本讨论的范围。然而，Node通过`file`模块提供了完整的文件操作套件，读者应该至少对文件类型的全部范围和功能有一定的了解。
- en: 'Studying named pipes will reward the reader interested in understanding how
    Node was designed to work with streams and pipes. Try this from a terminal:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 学习命名管道将奖励那些对了解Node如何设计以与流和管道一起工作感兴趣的读者。在终端中尝试这个：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If you get an expanded listing of the current directory `-ls -l`, a listing
    similar to this will be shown:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你得到了当前目录的扩展列表`-ls -l`，将会显示类似于这样的列表：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Note the `p` flag in the file mode (the first segment, with the dashes). You''ve
    created a named `(p)ipe`. Now, enter this into the same terminal, pushing some
    bytes into the named pipe:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 注意文件模式中的`p`标志（第一个段，带有破折号）。你已经创建了一个命名的`(p)ipe`。现在，输入到同一个终端中，将一些字节推送到命名管道中：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: It will seem like the process has hung. It hasn't—pipes, like water pipes, must
    be open on both ends to complete their job of flushing contents. We've pumped
    some bytes in... now what?
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来好像进程已经挂起了。其实没有——管道，就像水管一样，必须在两端打开才能完成它们刷新内容的工作。我们已经把一些字节放进去了……现在呢？
- en: 'Open another terminal, navigate to the same directory, and enter this:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 打开另一个终端，导航到相同的目录，并输入以下内容：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`hello` will appear in the second terminal as the contents of `namedpipe` are
    flushed. Note that the first terminal is no longer hung—it has flushed. If you
    recall the discussion on Node streams in [Chapter 3](c7665bc9-3f44-4d7c-8318-61f9dfe962b3.xhtml), *Streaming
    Data Across Nodes and Clients,* you will note something of a resemblance with
    Unix pipes, which is intentional.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`hello`将出现在第二个终端中，作为`namedpipe`的内容被刷新。请注意，第一个终端不再挂起——它已经刷新了。如果你回忆一下[第3章](c7665bc9-3f44-4d7c-8318-61f9dfe962b3.xhtml)中关于Node流的讨论，*在节点和客户端之间流式传输数据*，你会注意到与Unix管道有些相似之处，这是有意为之的。'
- en: File paths
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件路径
- en: 'Most of the filesystem methods provided by Node will require the manipulation
    of file paths, and for this purpose, we make use of the `path` module. We can
    compose, decompose, and relate paths with this module. Instead of hand rolling
    your own path string splitting and regexing and concatenating routines, try to
    normalize your code by delegating path manipulation to this module:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Node提供的大多数文件系统方法都需要操作文件路径，为此，我们使用`path`模块。我们可以使用这个模块来组合、分解和关联路径。不要手动拆分你自己的路径字符串，也不要使用正则表达式和连接例程，尝试通过将路径操作委托给这个模块来规范化你的代码：
- en: 'Use `path.normalize` whenever working with a file path string whose source
    is untrusted or unreliable to ensure a predictable format:'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在处理源不可信或不可靠的文件路径字符串时，使用`path.normalize`来确保可预测的格式：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Use `path.join` whenever building a single path out of path segments:'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在构建路径段时，使用`path.join`：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Use `path.dirname` to snip the directory name out of a path:'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`path.dirname`来剪切路径中的目录名：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Use `path.basename` to manipulate the final path segment:'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`path.basename`来操作最终的路径段：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Use `path.extname` to slice from the last period (`.`) to the end of the path
    string:'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`path.extname`从路径字符串的最后一个句点（`.`）开始切片到末尾：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Use `path.relative` to find the relative path from one absolute path to another:'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`path.relative`来找到从一个绝对路径到另一个绝对路径的相对路径：
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Use `path.resolve` to resolve a list of path instructions into an absolute
    path:'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`path.resolve`来将路径指令列表解析为绝对路径：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Think of the arguments passed to `path.resolve` as being a sequence of `cd`
    calls:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 将传递给`path.resolve`的参数视为一系列`cd`调用：
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If the list of arguments passed to `path.resolve` fails to deliver an absolute
    path, the current directory name is used as well. For instance, consider that
    we are in `/users/home/john/`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果传递给`path.resolve`的参数列表未能提供绝对路径，那么当前目录名称也会被使用。例如，假设我们在`/users/home/john/`中：
- en: '[PRE12]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: These arguments resolve to a relative path `one/two/three/four` that is, therefore,
    prefixed with the current directory name.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这些参数解析为一个相对路径`one/two/three/four`，因此，它是以当前目录名称为前缀的。
- en: File attributes
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件属性
- en: A file object exposes some of its attributes, comprising a useful set of metadata
    about the file data. If one is using Node to run an HTTP server, it will be necessary
    to determine the file length of any file requested via a GET, for example. Determining
    the time a file was last modified finds uses across many types of applications.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 文件对象公开了一些属性，包括有关文件数据的一组有用的元数据。例如，如果使用Node运行HTTP服务器，将需要确定通过GET请求的任何文件的文件长度。确定文件上次修改的时间在许多类型的应用程序中都有用。
- en: 'To read the attributes of a file, use `fs.stat`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 要读取文件的属性，使用`fs.stat`：
- en: '[PRE13]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the preceding example, `stats` will be an `fs.Stats` object describing the
    file through a map of attributes:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，`stats`将是描述文件的`fs.Stats`对象：
- en: '[PRE14]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'An `fs.Stats` object exposes several useful methods for accessing file attribute
    data:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`fs.Stats`对象公开了几个有用的方法来访问文件属性数据：'
- en: Use `stats.isFile` to check for standard files
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`stats.isFile`来检查标准文件
- en: Use `stats.isDirectory` to check for directories
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`stats.isDirectory`来检查目录
- en: Use `stats.isBlockDevice` to check for block type device files
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`stats.isBlockDevice`来检查块设备文件
- en: Use `stats.isCharacterDevice` to check for character type device files
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`stats.isCharacterDevice`来检查字符类型设备文件
- en: Use `stats.isSymbolicLink` after an `fs.lstat` to find symbolic links
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`fs.lstat`之后使用`stats.isSymbolicLink`来查找符号链接
- en: Use `stats.isFIFO` to identify named pipes
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`stats.isFIFO`来识别命名管道
- en: Use `stats.isSocket` to check for sockets
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`stats.isSocket`来检查套接字
- en: 'There are two further `stat` methods available:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 还有两个可用的`stat`方法：
- en: '`fs.fstat(fd, callback)`: Similar to `fs.stat`, except that a file descriptor
    `fd`is passed rather than a file path'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fs.fstat(fd, callback)`: 类似于`fs.stat`，只是传递了文件描述符`fd`而不是文件路径'
- en: '`fs.lstat(path, callback)`: An `fs.stat` on a symbolic link will return an
    `fs.Stats` object for the target file, while `fs.lstat` will return an `fs.Stats`
    object for the link file itself'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fs.lstat(path, callback)`: 对符号链接进行`fs.stat`将返回目标文件的`fs.Stats`对象，而`fs.lstat`将返回链接文件本身的`fs.Stats`对象'
- en: 'The following two methods simplify the file timestamp manipulation:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 以下两种方法简化了文件时间戳的操作：
- en: '`fs.utimes(path, atime, mtime, callback)`: Change the access and modify timestamps
    on a file at `path`. The access and modify times of a file are stored as instances
    of the JavaScript `Date` object. `Date.getTime` will, for example, return the
    number of milliseconds elapsed since midnight (UTC) on January 1, 1970.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fs.utimes(path, atime, mtime, callback)`: 更改`path`上的文件的访问和修改时间戳。文件的访问和修改时间以JavaScript
    `Date`对象的实例存储。例如，`Date.getTime`将返回自1970年1月1日午夜（UTC）以来经过的毫秒数。'
- en: '`fs.futimes(fd, atime, mtime, callback)`: Change the access and modify timestamps
    on a file descriptor `fd`; it''s similar to `fs.utimes`.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fs.futimes(fd, atime, mtime, callback)`: 更改文件描述符`fd`上的访问和修改时间戳；它类似于`fs.utimes`。'
- en: 'More information about manipulating dates and times with JavaScript can be
    found at:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 有关使用JavaScript操作日期和时间的更多信息，请访问：
- en: '[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date).'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date)。'
- en: Opening and closing files
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打开和关闭文件
- en: One of the unofficial rules governing the Node project is to not unnecessarily
    abstract away from the existing OS implementation details. As we will see, references
    to file descriptors appear throughout Node's file API. For **POSIX** (**Portable
    Operating System Interface**), a file descriptor is simply an (non-negative) integer
    uniquely referencing a specific file. Since Node modeled its filesystem methods
    on POSIX, not surprisingly, a file descriptor is represented in Node as an integer.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Node项目的一个非正式规则是不要不必要地从现有的操作系统实现细节中抽象出来。正如我们将看到的，文件描述符的引用出现在整个Node的文件API中。对于**POSIX**（**可移植操作系统接口**），文件描述符只是一个（非负）整数，唯一地引用特定的文件。由于Node的文件系统方法是基于POSIX建模的，因此文件描述符在Node中表示为整数并不奇怪。
- en: 'Recalling our discussion of how devices and other elements of the OS are represented
    as files, it would stand to reason that the standard I/O streams (`stdin`, `stdout`,
    `stderr`) would also have file descriptors. In fact, that is the case:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下我们讨论过的设备和操作系统的其他元素是如何表示为文件的，那么标准I/O流（`stdin`，`stdout`，`stderr`）也会有文件描述符是合理的。事实上，情况就是这样的：
- en: '[PRE15]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: File descriptors are easy to obtain and are convenient ways to pass around file
    references. Let's look at how file descriptors are created and used by examining
    how to perform low-level file open and close operations using Node. As the chapter
    progresses, we'll investigate more refined interfaces to file streams.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 文件描述符易于获取，并且是传递文件引用的便捷方式。让我们看看如何通过检查如何执行低级文件打开和关闭操作来创建和使用文件描述符。随着本章的进行，我们将研究更精细的文件流接口。
- en: fs.open(path, flags, [mode], callback)
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: fs.open(path, flags, [mode], callback)
- en: 'Trying to open a file at `path`. `callback` will receive any exceptions with
    the operation as its first argument, and a file descriptor as its second argument.
    Here, we open a file for reading:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试在`path`处打开文件。`callback`将接收操作的任何异常作为其第一个参数，并将文件描述符作为其第二个参数。在这里，我们打开一个文件进行读取：
- en: '[PRE16]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`flags` receives a string indicating the types of operations the caller expects
    to perform on the returned file descriptor. Their meanings should be clear:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`flags`接收一个字符串，指示调用者期望在返回的文件描述符上执行的操作类型。它们的含义应该是清楚的。'
- en: '`r`: Opening a file for reading, throwing an exception if the file doesn''t
    exist.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`r`：打开文件进行读取，如果文件不存在则抛出异常。'
- en: '`r+`: Opening a file for both reading and writing, throwing an exception if
    the file doesn''t exist.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`r+`：打开文件进行读取和写入，如果文件不存在则抛出异常。'
- en: '`w`: Opening a file for writing, creating the file if it doesn''t exist, and
    truncating the file to zero bytes if it does exist.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`w`：打开文件进行写入，如果文件不存在则创建文件，并且如果文件存在则将文件截断为零字节。'
- en: '`wx`: Like `w`, but it opens the file in exclusive mode, which means if the
    file already exists, it will **not be opened**, and the open operation will fail.
    This is useful if multiple processes may be simultaneously trying to create the
    same file.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wx`：类似于`w`，但以独占模式打开文件，这意味着如果文件已经存在，它将**不会被打开**，打开操作将失败。如果多个进程可能同时尝试创建相同的文件，则这很有用。'
- en: '`w+`: Opening a file for reading and writing, creating the file if it doesn''t
    exist, and truncating the file to zero bytes if it does exist.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`w+`：打开文件进行读取和写入，如果文件不存在则创建文件，并且如果文件存在则将文件截断为零字节。'
- en: '`wx+`: Like `wx` (and `w`), additionally opening the file for reading.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wx+`：类似于`wx`（和`w`），此外还打开文件进行读取。'
- en: '`a`: Opening a file for appending, creating the file if it does not exist.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`a`：打开文件进行追加，如果文件不存在则创建文件。'
- en: '`ax`: Like **a**, but opens the file in exclusive mode, which means if the
    file already exists, it will **not be opened**, and the open operation will fail.
    This is useful if multiple processes may be simultaneously trying to create the
    same file.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ax`：类似于**a**，但以独占模式打开文件，这意味着如果文件已经存在，它将**不会被打开**，打开操作将失败。如果多个进程可能同时尝试创建相同的文件，则这很有用。'
- en: '`a+`: Open a file for reading and appending, creating the file if it does not
    exist.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`a+`：打开文件进行读取和追加，如果文件不存在则创建文件。'
- en: '`ax+`: Like `ax` (and `a`), additionally opening the file for reading.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ax+`：类似于`ax`（和`a`），此外还打开文件进行读取。'
- en: 'When an operation may create a new file, use the optional `mode` to set permissions
    for this file in octal digits, defaulting to 0666 (refer to `fs.chmod` for more
    information about octal permissions):'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当操作可能创建新文件时，使用可选的`mode`以八进制数字形式设置此文件的权限，默认为0666（有关八进制权限的更多信息，请参阅`fs.chmod`）：
- en: '[PRE17]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: fs.close(fd, callback)
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: fs.close(fd, callback)
- en: The `fs.close(fd, callback)` method closes a file descriptor. The callback receives
    one argument, any exception thrown in the call. It's a good habit to close all
    the file descriptors that have been opened.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`fs.close(fd, callback)` 方法关闭文件描述符。回调函数接收一个参数，即调用中抛出的任何异常。关闭所有已打开的文件描述符是一个好习惯。'
- en: File operations
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件操作
- en: Node implements the standard POSIX functions for working with files, which a
    UNIX user will be familiar with. We will not be covering each member of this extensive
    collection in depth, instead focusing on some commonly used examples. In particular,
    we will go into depth discussing the methods for opening file descriptors and
    manipulating file data, reading and manipulating file attributes, and moving through
    filesystem directories. Nevertheless, the reader is encouraged to experiment with
    the entire set, which the following list briefly describes. Note that all of these
    methods are asynchronous, non-blocking file operations.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Node实现了用于处理文件的标准POSIX函数，UNIX用户会很熟悉。我们不会深入讨论这个庞大集合的每个成员，而是专注于一些常用的例子。特别是，我们将深入讨论打开文件描述符和操作文件数据的方法，读取和操作文件属性，以及在文件系统目录中移动。然而，鼓励读者尝试整套方法，以下列表简要描述了这些方法。请注意，所有这些方法都是异步的，非阻塞文件操作。
- en: fs.rename(oldName, newName, callback)
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: fs.rename(oldName, newName, callback)
- en: The `fs.rename(oldName, newName, callback)` method renames file at `oldName` to
    `newName`. The callback receives one argument, any exception thrown in the call.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`fs.rename(oldName, newName, callback)` 方法将`oldName`处的文件重命名为`newName`。回调函数接收一个参数，即调用中抛出的任何异常。'
- en: fs.truncate(path, len, callback)
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: fs.truncate(path, len, callback)
- en: The `fs.truncate(path, len, callback)` method changes the length of the file
    at `path` by `len` bytes. If `len` represents a length shorter than the file's
    current length, the file is truncated to that length. If `len` is greater, the
    file length is padded by appending null bytes (x00) until `len` is reached. The
    callback receives one argument, any exception thrown in the call.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`fs.truncate(path, len, callback)` 方法通过`len`字节更改`path`处文件的长度。如果`len`表示比文件当前长度更短的长度，则文件将被截断为该长度。如果`len`更大，则文件长度将通过附加空字节（x00）进行填充，直到达到`len`。回调函数接收一个参数，即调用中抛出的任何异常。'
- en: fs.ftruncate(fd, len, callback)
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: fs.ftruncate(fd, len, callback)
- en: The `fs.ftruncate(fd, len, callback)` method is like `fs.truncate`, except that
    instead of specifying a file, a file descriptor is passed as `fd`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`fs.ftruncate(fd, len, callback)` 方法类似于`fs.truncate`，不同之处在于不是指定文件，而是将文件描述符作为`fd`传递。'
- en: fs.chown(path, uid, gid, callback)
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: fs.chown(path, uid, gid, callback)
- en: The `fs.chown(path, uid, gid, callback)` method changes the ownership of the
    file at `path`. Use this to set whether user `uid` or group `gid` has access to
    a file. The callback receives one argument, any exception thrown in the call.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`fs.chown(path, uid, gid, callback)` 方法更改`path`处文件的所有权。使用此方法设置用户`uid`或组`gid`是否可以访问文件。回调函数接收一个参数，即调用中抛出的任何异常。'
- en: fs.fchown(fd, uid, gid, callback)
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: fs.fchown(fd, uid, gid, callback)
- en: The `fs.fchown(fd, uid, gid, callback)` method is like `fs.chown`, except that
    instead of specifying a file path, a file descriptor is passed as `fd`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`fs.fchown(fd, uid, gid, callback)` 方法与`fs.chown`类似，不同之处在于不是指定文件路径，而是将文件描述符作为`fd`传递。'
- en: fs.lchown(path, uid, gid, callback)
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: fs.lchown(path, uid, gid, callback)
- en: The `fs.lchown(path, uid, gid, callback)` method is like `fs.chown`, except
    that in the case of symbolic links, ownership of the link file itself is changed,
    but not the referenced link.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`fs.lchown(path, uid, gid, callback)` 方法与`fs.chown`类似，不同之处在于对于符号链接，更改的是链接文件本身的所有权，而不是引用的链接。'
- en: fs.chmod(path, mode, callback)
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: fs.chmod(path, mode, callback)
- en: 'The `fs.chmod(path, mode, callback)` method changes the `mode`(permissions)
    on a file at `path`. You are setting the read(4), write(2), and execute(1) bits
    for this file, which can be sent in octal digits:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`fs.chmod(path, mode, callback)` 方法更改`path`处文件的`mode`（权限）。您正在设置该文件的读取（4）、写入（2）和执行（1）位，可以以八进制数字形式发送：'
- en: '|  | [r]ead | [w]rite | E[x]ecute | Total |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '|  | [r]读取 | [w]写入 | E[x]执行 | 总计 |'
- en: '| Owner | **4** | **2** | **1** | **7** |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| 所有者 | **4** | **2** | **1** | **7** |'
- en: '| Group | **4** | **0** | **1** | **5** |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| 组 | **4** | **0** | **1** | **5** |'
- en: '| Other | **4** | **0** | **1** | **5** |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| 其他 | **4** | **0** | **1** | **5** |'
- en: '|  |  |  |  | **chmod(755)** |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '|  |  |  |  | **chmod(755)** |'
- en: 'You may also use symbolic representations, such as `g+rw` for group read and
    write, similar to the arguments we saw for `file.open` earlier. For more information
    on setting file modes, consult: [http://en.wikipedia.org/wiki/Chmod](http://en.wikipedia.org/wiki/Chmod).'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以使用符号表示，例如`g+rw`表示组读写，类似于我们之前在`file.open`中看到的参数。有关设置文件模式的更多信息，请参阅：[http://en.wikipedia.org/wiki/Chmod](http://en.wikipedia.org/wiki/Chmod)。
- en: The callback receives one argument, any exception thrown in the call.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 回调函数接收一个参数，在调用中抛出的任何异常。
- en: fs.fchmod(fd, mode, callback) ----
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: fs.fchmod(fd, mode, callback) ----
- en: The `fs.fchmod(fd, mode, callback)` method is like `fs.chmod`, except that instead
    of specifying a file path, a file descriptor is passed as `fd`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`fs.fchmod(fd, mode, callback)`方法类似于`fs.chmod`，不同之处在于不是指定文件路径，而是将文件描述符作为`fd`传递。'
- en: fs.lchmod(path, mode, callback)
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: fs.lchmod(path, mode, callback)
- en: The `fs.lchmod(path, mode, callback)` method is like `fs.chmod`, except that
    in the case of symbolic links, permissions on the link file itself is changed,
    but not those of the referenced link.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`fs.lchmod(path, mode, callback)`方法类似于`fs.chmod`，不同之处在于对于符号链接，只会更改链接文件本身的权限，而不会更改引用链接的权限。'
- en: fs.link(srcPath, dstPath, callback)
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: fs.link(srcPath, dstPath, callback)
- en: 'The `fs.link(srcPath, dstPath, callback)` creates a hard link between `srcPath`
    and `dstPath`. This is a way of creating many different paths to exactly the same
    file. For example, the following directory contains a `target.txt` file and two
    hard links—`a.txt` and `b.txt`—which each point to this file:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`fs.link(srcPath, dstPath, callback)`在`srcPath`和`dstPath`之间创建一个硬链接。这是创建指向完全相同文件的许多不同路径的一种方法。例如，以下目录包含一个`target.txt`文件和两个硬链接—`a.txt`和`b.txt`—它们各自指向这个文件：'
- en: '![](img/071fe6c3-13e6-4da9-8a4c-5df632547f06.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](img/071fe6c3-13e6-4da9-8a4c-5df632547f06.png)'
- en: 'Note that `target.txt` is empty. If the content of the target file is changed,
    the length of the link files will also be changed. Consider changing the content
    of the target file:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`target.txt`是空的。如果更改目标文件的内容，链接文件的长度也将更改。考虑更改目标文件的内容：
- en: '[PRE18]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This results in this new directory structure, clearly demonstrating the hard
    references:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致了这种新的目录结构，清楚地展示了硬引用：
- en: '![](img/a761ddfa-c59c-4fa5-8c97-f744588b811a.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a761ddfa-c59c-4fa5-8c97-f744588b811a.png)'
- en: The callback receives one argument, any exception thrown in the call.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 回调函数接收一个参数，在调用中抛出的任何异常。
- en: fs.symlink(srcPath, dstPath, [type], callback)
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: fs.symlink(srcPath, dstPath, [type], callback)
- en: The `fs.symlink(srcPath, dstPath, [type], callback)` method creates a symbolic
    link between `srcPath` and `dstPath`. Unlike hard links created with `fs.link`,
    symbolic links are simply pointers to other files, and do not themselves respond
    to changes in the target file. The default link `type`is file. Other options are
    directory and junction, the last being a Windows-specific type that is ignored
    on other systems. The callback receives one argument, any exception thrown in
    the call.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`fs.symlink(srcPath, dstPath, [type], callback)`方法在`srcPath`和`dstPath`之间创建一个符号链接。与使用`fs.link`创建的硬链接不同，符号链接只是指向其他文件的指针，并且本身不会对目标文件的更改做出响应。默认的链接`type`是文件。其他选项是目录和junction，最后一个是Windows特定类型，在其他系统上被忽略。回调函数接收一个参数，在调用中抛出的任何异常。'
- en: 'Compare and contrast the directory changes described in our `fs.link` discussion
    to the following:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们在`fs.link`讨论中描述的目录更改与以下内容进行比较：
- en: '![](img/e0bc810e-ef05-4e42-af3f-9c69b5d91603.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e0bc810e-ef05-4e42-af3f-9c69b5d91603.png)'
- en: 'Unlike hard links, symbolic links do not change in length when their target
    file (in this case `target.txt`) changes length. Here, we see how changing the
    target''s length from zero bytes to six bytes has no effect on the length of any
    bound symbolic links:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 与硬链接不同，当它们的目标文件（在本例中为`target.txt`）更改长度时，符号链接的长度不会改变。在这里，我们看到将目标长度从零字节更改为六字节对任何绑定的符号链接的长度没有影响：
- en: '![](img/117fd84c-d6db-404a-b48f-87c81a872b97.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](img/117fd84c-d6db-404a-b48f-87c81a872b97.png)'
- en: fs.readlink(path, callback)
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: fs.readlink(path, callback)
- en: 'The given symbolic link at `path` returns the filename of the targeted file:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 给定`path`处的符号链接返回目标文件的文件名：
- en: '[PRE19]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: fs.realpath(path, [cache], callback)
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: fs.realpath(path, [cache], callback)
- en: 'The `fs.realpath(path, [cache], callback)` method attempts to find the real
    path to file at `path`. This is a useful way to find the absolute path to a file,
    resolve symbolic links, and even clean up extraneous slashes and other malformed
    paths. Consider this example:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`fs.realpath(path, [cache], callback)`方法尝试找到`path`处文件的真实路径。这是查找文件的绝对路径，解析符号链接，甚至清理多余的斜杠和其他格式不正确的路径的有用方法。考虑这个例子：'
- en: '[PRE20]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Alternatively, consider this:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，考虑这个：
- en: '[PRE21]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If some of the path segments to be resolved are already known, one can pass
    a `cache` of mapped paths:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要解析的一些路径段已知，可以传递一个映射路径的`cache`：
- en: '[PRE22]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: fs.unlink(path, callback)
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: fs.unlink(path, callback)
- en: The `fs.unlink(path, callback)` method removes the file at `path`—equivalent
    to deleting a file. The callback receives one argument, any exception thrown in
    the call.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`fs.unlink(path, callback)`方法删除`path`处的文件，相当于删除文件。回调函数接收一个参数，在调用中抛出的任何异常。'
- en: fs.rmdir(path, callback)
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: fs.rmdir(path, callback)
- en: The `fs.rmdir(path, callback)` method removes the directory at `path`, equivalent
    to deleting a directory.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`fs.rmdir(path, callback)`方法删除`path`处的目录，相当于删除目录。'
- en: Note that if the directory is not empty, this will throw an exception. The callback
    receives one argument, any exception thrown in the call.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果目录不为空，这将抛出异常。回调函数接收一个参数，在调用中抛出的任何异常。
- en: fs.mkdir(path, [mode], callback)
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: fs.mkdir(path, [mode], callback)
- en: The `fs.mkdir(path, [mode], callback)` method creates a directory at `path`.
    To set the mode of the new directory, use the permission bit map described in
    `fs.chmod`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`fs.mkdir(path, [mode], callback)`方法在`path`处创建一个目录。要设置新目录的模式，请使用`fs.chmod`中描述的权限位图。'
- en: Note that if this directory already exists, an exception will be thrown. The
    callback receives one argument, any exception thrown in the call.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果此目录已经存在，将抛出异常。回调函数接收一个参数，在调用中抛出的任何异常。
- en: fs.exists(path, callback)
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: fs.exists(path, callback)
- en: The `fs.exists(path, callback)` method checks whether a file exists at `path`.
    The callback will receive a Boolean true or false.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: fs.fsync(fd, callback)
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Between the instant a request for some data to be written to a file is made
    and that data fully exists on a storage device, the candidate data exists within
    core system buffers. This latency isn't normally relevant but, in some extreme
    cases, such as system crashes, it is necessary to insist that the file reflects
    a known state on a stable storage device.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '`fs.fsync` copies all in-core data of a file referenced by file descriptor
    `fd` to disk'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: (or other storage device). The callback receives one argument, any exception
    thrown in the call.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Synchronicity
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Conveniently, Node's `file` module provides synchronous counterparts for each
    of the asynchronous methods we've covered, indicated by the `Sync` suffix. For
    example, the synchronous version of `fs.mkdir` is `fs.mkdirSync`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: 'A synchronous call is also able to directly return its result, obviating the
    need for callbacks. While demonstrating the creation of HTTPS servers in [Chapter
    3](c7665bc9-3f44-4d7c-8318-61f9dfe962b3.xhtml), *Streaming Data Across Nodes and
    Clients*, we saw both a good use case for synchronous code and an example of direct
    assignment of results without a callback:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Hey! Doesn't Node strictly enforce asynchronous programming? Isn't blocking
    code always wrong? All developers are encouraged to adhere to non-blocking designs,
    and you are encouraged to avoid synchronous coding—if facing a problem where a
    synchronous operation seems the only solution, it is likely that the problem has
    been misunderstood. Nevertheless, edge cases requiring a file object existing
    fully in memory prior to executing further instructions (a blocking operation)
    do exist. Node give a developer the power to break with asynchronous tradition
    if it is the only possible solution (which it probably isn't!).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: 'One synchronous operation developers regularly use (perhaps without realizing
    it) is the `require` directive:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Until the dependency targeted by require is fully initialized, subsequent JavaScript
    instructions will not execute (file loading blocks the event loop). *Ryan Dahl*
    struggled with this decision to introduce synchronous operations (file operations
    in particular) into Node, as he mentioned at a Google Tech Talk on July 2013:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: According to [http://www.youtube.com/watch?v=F6k8lTrAE2g](http://www.youtube.com/watch?v=F6k8lTrAE2g),
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '"I think this is an OK compromise. It pained me for months, to drop the purity
    of having an asynchronous module system. But, I think it''s ok.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '...'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: 'It simplifies the code a lot to be able to just stick in "require, require,
    require" and not have to do an onload callback...I think that''s been a relatively
    OK compromise. [...] There''s really two parts to your program: there''s the loading
    and starting up phase...and you don''t really care how fast that runs...you''re
    going to load modules and stuff...the setup phase of your daemon, generally, is
    synchronous. It''s when you get into your event loop for serving requests that
    you want to be very careful about this. [...] I will give people synchronous file
    I/O. If they do it in servers...it won''t be terrible, right? The important thing
    is to never let them do synchronous network I/O."'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: Synchronous code does have the advantage of being eminently predictable, as
    nothing else happens until this instruction is completed. When starting up a server,
    which will happen only rarely, Dahl is suggesting that a little certainty and
    simplicity goes a long way. The loading of configuration files, for example, might
    make sense on server initialization.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes a desire to use synchronous commands in Node development is simply
    a cry for help; a developer being overwhelmed by deeply nested callback structures.
    If ever faced with this pain, try some of the callback-taming libraries mentioned
    in [Chapter 2](4cb6b06a-7800-4595-9908-f14d1ced3602.xhtml), *Understanding Asynchronous
    Event-Driven Programming*.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，在Node开发中使用同步命令的愿望只是在请求帮助；开发人员被深度嵌套的回调结构所压倒。如果曾经面对这种痛苦，请尝试一些在[第2章](4cb6b06a-7800-4595-9908-f14d1ced3602.xhtml)中提到的回调控制库，*理解异步事件驱动编程*。
- en: Moving through directories
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 浏览目录
- en: Let's apply what we have learned and create a directory iterator. The goal for
    this project is to create a function that will accept a directory path and return
    a JSON object reflecting the directory hierarchy of files, its nodes composed
    of file objects. We will also make our directory walker a more powerful event-based
    parser, consistent with the Node philosophy.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们应用我们所学到的知识，创建一个目录迭代器。这个项目的目标是创建一个函数，该函数将接受一个目录路径，并返回一个反映文件目录层次结构的JSON对象，其节点由文件对象组成。我们还将使我们的目录遍历器成为一个更强大的基于事件的解析器，与Node哲学一致。
- en: 'To move through nested directories, one must first be able to read a single
    directory. Node''s filesystem library provides the `fs.readdir` command for this
    purpose:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 要移动到嵌套目录中，必须首先能够读取单个目录。Node的文件系统库提供了`fs.readdir`命令来实现这一目的：
- en: '[PRE25]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Remembering that everything is a file, we will need to do more than simply
    getting a directory listing; we must determine the type of each member of our
    file list. By adding `fs.stat`, we have already completed a large majority of
    the logic:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 记住一切都是文件，我们需要做的不仅仅是获取目录列表；我们必须确定文件列表中每个成员的类型。通过添加`fs.stat`，我们已经完成了大部分逻辑：
- en: '[PRE26]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This self-executing function receives a directory path argument `(".")`, folds
    that directory listing into an array of file names, fetches an `fs.Stats` object
    for each of these, and makes a decision based on the indicated file type (directory
    or not a directory) on what to do next. At this point, we also have the name of
    the current file and its attributes available to us. Clearly, we have already
    mapped a single directory.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这个自执行函数接收一个目录路径参数`(".")`，将该目录列表折叠成一个文件名数组，为其中的每个文件获取一个`fs.Stats`对象，并根据指示的文件类型（目录或非目录）做出决定下一步该做什么。在这一点上，我们也已经映射了一个单个目录。
- en: 'We must now map directories within directories, storing results in a JSON object
    reflecting the nested filesystem tree, with each leaf on the tree a file object.
    Recursively passing our directory reader function paths to subdirectories and
    appending returned results as branches of the final object is the next step:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在必须映射目录中的目录，将结果存储在反映嵌套文件系统树的JSON对象中，树上的每个叶子都是一个文件对象。递归地将我们的目录读取器函数路径传递给子目录，并将返回的结果附加为最终对象的分支是下一步：
- en: '[PRE27]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We create a `walk` method that receives a directory path and a callback that
    receives the directory graph or an error when `walk` is complete, following Node's
    style. Not much code is needed to create a very fast, non-blocking file tree walker,
    complete with file stats.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个`walk`方法，该方法接收一个目录路径和一个回调函数，该回调函数在`walk`完成时接收目录图或错误，遵循Node的风格。创建一个非常快速的、非阻塞的文件树遍历器，包括文件统计信息，不需要太多的代码。
- en: 'Now, let''s publish events whenever a directory or file is encountered, giving
    any future implementation flexibility to construct its own representation of the
    filesystem. To do this, we will use the friendly `EventEmitter` object:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在遇到目录或文件时发布事件，使任何未来的实现都能够灵活地构建自己的文件系统表示。为此，我们将使用友好的`EventEmitter`对象：
- en: '[PRE28]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now that we know how to discover and address files, we can start reading from
    and writing to them.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何发现和处理文件，我们可以开始从中读取和写入。
- en: Reading from a file
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从文件中读取
- en: In our discussion of file descriptors, we touched on one method of opening a
    file, fetching a file descriptor, and ultimately pushing or pulling data through
    that reference. Reading files is a common operation. Sometimes, managing a read
    buffer precisely may be necessary, and Node allows byte-by-byte control. In other
    cases, one simply wants a no-frills stream that is simple to use.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论文件描述符时，我们提到了一种打开文件、获取文件描述符并最终通过该引用推送或拉取数据的方法。读取文件是一个常见的操作。有时，精确管理读取缓冲区可能是必要的，Node允许逐字节控制。在其他情况下，人们只是想要一个简单易用的无花俏流。
- en: Reading byte by byte
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 逐字节读取
- en: The `fs.read` method is the most low-level way Node offers for reading files.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`fs.read`方法是Node提供的读取文件的最低级别的方法。'
- en: fs.read(fd, buffer, offset, length, position, callback)
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: fs.read(fd, buffer, offset, length, position, callback)
- en: Files are composed of ordered bytes, and these bytes are addressable by their
    `position`, relative to the beginning of in the file (position zero [0]). Once
    we have
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 文件由有序字节组成，这些字节可以通过它们相对于文件开头的`position`进行寻址（位置零[0]）。一旦我们有
- en: a file descriptor `fd`, we can begin to read `length` number of bytes and insert
    those into a `Buffer` object `buffer`, insertion beginning at a given buffer `offset`.
    For example, to copy the 8,366 bytes beginning at `position` 309 of the readable
    file `fd` into
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 文件描述符`fd`，我们可以开始读取`length`字节数，并将其插入到`Buffer`对象`buffer`中，插入从给定的缓冲区`offset`开始。例如，要将从可读文件`fd`的位置309开始的8,366字节复制到
- en: a `buffer` beginning at an `offset` of 100, we will use `fs.read(fd, buffer,
    100, 8366, 309, callback)`.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 一个从`offset`为100开始的`buffer`，我们将使用`fs.read(fd, buffer, 100, 8366, 309, callback)`。
- en: 'The following code demonstrates how to open and read a file in 512 byte chunks:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码演示了如何以512字节块打开和读取文件：
- en: '[PRE29]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The resulting buffer can be piped elsewhere (including a server response object).
    It can also be manipulated using the methods of Node's `Buffer` object, such as
    conversion into a UTF8 string with `buffer.toString("utf8")`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的缓冲区可以被传送到其他地方（包括服务器响应对象）。也可以使用Node的`Buffer`对象的方法进行操作，例如使用`buffer.toString("utf8")`将其转换为UTF8字符串。
- en: Fetching an entire file at once
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一次获取整个文件
- en: Often, one simply needs to fetch an entire file, without any ceremony or fine
    control. Node provides a shortcut method for exactly this.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们只需要获取整个文件，而不需要任何仪式或精细控制。Node提供了一个快捷方法来实现这一点。
- en: fs.readFile(path, [options], callback)
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: fs.readFile(path, [options], callback)
- en: 'Fetching the data contained by the `path` file can be accomplished in one step:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 获取`path`文件中包含的数据可以在一步中完成：
- en: '[PRE30]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We see how `callback` receives a buffer. It may be more desirable to receive
    the file data in a common encoding, such as UTF8\. We are able to specify the
    encoding of the returned data as well as the read mode using the `options` object,
    which has two possible attributes:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到`callback`接收一个缓冲区。可能更希望以常见编码（如UTF8）接收文件数据。我们可以使用`options`对象指定返回数据的编码以及读取模式，该对象有两个可能的属性：
- en: '**encoding**: A string, such as `utf8`, it defaults to null (no encoding)'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**encoding**：一个字符串，如`utf8`，默认为null（无编码）'
- en: '**flag**: The file mode as a string, it defaults to `r`'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**flag**：文件模式作为字符串，默认为`r`'
- en: 'Modifying the previous example:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 修改上一个例子：
- en: '[PRE31]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Creating a readable stream
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建可读流
- en: While `fs.readFile` is an excellent, simple way to accomplish a common task,
    it does have the significant drawback of requiring that an entire file be read
    into memory prior to any part of the file being sent to a callback. For large
    files or files of unknown size, this isn't a good solution.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`fs.readFile`是一种完成常见任务的简单方法，但它有一个重大缺点，即在将文件的任何部分发送到回调之前，需要将整个文件读入内存。对于大文件或未知大小的文件，这不是一个好的解决方案。
- en: In the last chapter, we learned about data streams and the `Stream` object.
    While files are easily and naturally handled using readable streams, Node provides
    a dedicated file streaming interface that offers a compact file streaming facility
    without the extra construction work, with more flexibility than that offered by
    `fs.readFile`.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了数据流和`Stream`对象。虽然文件可以很容易和自然地使用可读流处理，但Node提供了一个专用的文件流接口，提供了一种紧凑的文件流功能，无需额外的构造工作，比`fs.readFile`提供的更灵活。
- en: fs.createReadStream(path, [options])
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: fs.createReadStream(path, [options])
- en: The `fs.createReadStream(path, [options])` method returns a readable stream
    object for file at `path`. You may then perform stream operations on the returned
    object, such as `pipe()`.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`fs.createReadStream(path, [options])`方法返回`path`文件的可读流对象。然后，您可以对返回的对象执行流操作，例如`pipe()`。'
- en: 'The following options are available:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 以下选项可用：
- en: '`flags`: File mode argument as a string. Defaults to `r`.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flags`：文件模式参数作为字符串。默认为`r`。'
- en: '`encoding`: One of `utf8`, `ascii`, or `base64`. Defaults to no encoding.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`encoding`：`utf8`、`ascii`或`base64`之一。默认为无编码。'
- en: '`fd`: One may set `path` to null, instead passing the call a file descriptor.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fd`：可以将`path`设置为null，而不是传递文件描述符。'
- en: '`mode`: Octal representation of file mode, defaulting to 0666.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mode`：文件模式的八进制表示，默认为0666。'
- en: '`bufferSize`: The chunk size, in bytes, of the internal read stream. Defaults
    to 64 * 1024 bytes. You can set this to any number, but memory allocation is strictly
    controlled by the host OS, which may ignore a request. Refer to: [https://groups.google.com/forum/?fromgroups#!topic/nodejs/p5FuU1oxbeY](https://groups.google.com/forum/?fromgroups#!topic/nodejs/p5FuU1oxbeY).'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bufferSize`：内部读取流的块大小，以字节为单位。默认为64 * 1024字节。您可以将其设置为任何数字，但内存分配严格受主机操作系统控制，可能会忽略请求。参考：[https://groups.google.com/forum/?fromgroups#!topic/nodejs/p5FuU1oxbeY](https://groups.google.com/forum/?fromgroups#!topic/nodejs/p5FuU1oxbeY)。'
- en: '`autoClose`: Whether to automatically close the file descriptor (a la `fs.close`).
    Defaults to true. You may want to set this to false and close manually if you
    are sharing a file descriptor across many streams, as closing a descriptor will
    disrupt any other readers.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`autoClose`：是否自动关闭文件描述符（类似于`fs.close`）。默认为true。如果您正在跨多个流共享文件描述符，则可能希望将其设置为false并手动关闭，因为关闭描述符将中断任何其他读取器。'
- en: '`start`: Begin reading from this position. Default is 0.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`start`：从这个位置开始阅读。默认为0。'
- en: '`end`: Stop reading at this position. Default is the file byte length.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`end`：在这个位置停止阅读。默认为文件字节长度。'
- en: Reading a file line by line
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 逐行读取文件
- en: While reading a file stream byte-by-byte is sufficient for any file-parsing
    job, text files in particular are often more usefully read line by line, such
    as when reading logfiles. More precisely, any stream can be understood in terms
    of the chunks of data separated by newline characters, typically `rn` on UNIX
    systems. Node provides a native module whose methods simplify access to newline-separated
    chunks in data streams.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 逐字节读取文件流对于任何文件解析工作都足够了，但特别是文本文件通常更适合逐行读取，例如读取日志文件时。更准确地说，可以将任何流理解为由换行字符分隔的数据块，通常在UNIX系统上是`rn`。Node提供了一个本地模块，其方法简化了对数据流中的换行分隔块的访问。
- en: The Readline module
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Readline模块
- en: The `Readline` module has a simple but powerful goal, that is, to make reading
    a stream of data line-by-line easier. The bulk of its interface is designed to
    make command-line prompting easier, such that interfaces taking user input are
    easier to design.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`Readline`模块有一个简单但强大的目标，即使得逐行读取数据流更容易。其接口的大部分设计是为了使命令行提示更容易，以便更容易设计接受用户输入的接口。'
- en: Remembering that Node is designed for I/O, that I/O operations normally involve
    moving data between readable and writable streams, and that `stdout` and `stdin`
    are stream interfaces identical to the file streams returned by `fs.createReadStream`
    and `fs.createWriteStream`, we will look at how this module can be similarly used
    to prompt file streams for a line of text.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 记住Node是为I/O设计的，I/O操作通常涉及在可读和可写流之间移动数据，并且`stdout`和`stdin`是与`fs.createReadStream`和`fs.createWriteStream`返回的文件流相同的流接口，我们将看看如何使用这个模块类似地提示文件流以获取一行文本。
- en: 'To start working with the `Readline` module, one must create an interface defining
    the input stream and the output stream. The default interface options prioritize
    usage as a terminal interface. The options we are interested in are as follows:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用`Readline`模块，必须创建一个定义输入流和输出流的接口。默认接口选项优先使用作为终端接口。我们感兴趣的选项如下：
- en: '`input`: Required. The readable stream being listened to.'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`output`: Required. The writable stream being written to.'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`terminal`: Set this to true if both the input and output streams should be
    treated like a Unix terminal, or **Teletypewriter** (**TTY**). For files, you
    will set this to false.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Reading the lines of a file is made easy through this system. For example,
    assuming that one has a dictionary file listing common words in the English language,
    one might want to read the list into an array for processing:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Note how we disable TTY behavior, handling the lines ourselves without redirecting
    to an output stream.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: 'As expected with a Node I/O module, we are working with stream events. The
    events listeners that may be of interest are as listed:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '`line`: Receives the most recently read line, as a string'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pause`: Called whenever the stream is paused'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`resume`: Called whenever a stream is resumed'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`close`: Called whenever a stream is closed'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Except for `line`, these event names reflect the `Readline` methods, pause a
    stream with `Readline.pause`, `resume` with `Readline.resume`, and `close` with
    `Readline.close`.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: Writing to a file
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As with reading files, Node provides a rich collection of tools for writing
    to files. We'll see how Node makes it as easy to target a file's contents byte-by-byte,
    as it is to pipe continuous streams of data into a single writable file.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: Writing byte by byte
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `fs.write` method is the most low-level way Node offers for writing files.
    This method gives us precise control over where bytes will be written to in a
    file.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: fs.write(fd, buffer, offset, length, position, callback)
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To write the collection of bytes between positions 309 and 8,675 **(**length
    8,366) of `buffer` to the file referenced by file descriptor `fd`, insertion beginning
    at position 100:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Note that for files opened in the append (`a`) mode, some operating systems
    may ignore `position` values, always adding data to the end of the file. Additionally,
    it is unsafe to call `fs.write` multiple times on the same file without waiting
    for the callback. Use `fs.createWriteStream` in those cases.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: With such precise control, we can intelligently structure files. In the following
    (somewhat contrived) example, we create a file-based database containing indexed
    information for 6 months of baseball scores for a single team. We want to be able
    to quickly look up whether this team won or lost (or did not play) on a given
    day.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: 'Since a month can have at most 31 days, we can (randomly) create a 6 x 31 grid
    of data in this file, placing one of three values in each grid cell: L (loss),
    W (win), N (no game). For fun, we also create a simple **CLI** (**Command-Line
    Interface**) to our database with a basic query language. This example should
    make it clear how `fs.read`, `fs.write`, and `Buffer` objects are used to precisely
    manipulate bytes in files:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Once running, we can simply type in a month/day pair and rapidly access that
    data cell. Adding in bounds checking for the input values would be a simple improvement.
    Pushing the file stream through a visualizing UI might be a nice exercise.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: Writing large chunks of data
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For straightforward write operations `fs.write` may be overkill. Sometimes,
    all that is needed is a way to create a new file with some content. Just as common
    is the need to append data to the end of a file, as one might do in a logging
    system. The `fs.writeFile` and `fs.appendFile` methods can help us with those
    scenarios.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: fs.writeFile(path, data, [options], callback)
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `fs.writeFile(path, data, [options], callback)` method writes the contents
    of `data` to the file at `path`. The data argument can be either a buffer or
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: 'a string. The following options are available:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '`encoding`: Defaults to `utf8`. If data is a buffer, this option is ignored.'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mode`: Octal representation of file mode, defaulting to 0666.'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`flag`: Write flags, defaulting to `w`.'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Usage is straightforward:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: fs.appendFile(path, data, [options], callback)
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Similar to `fs.writeFile`, except that `data` is appended to the end of the
    file at `path`. Also, the `flag` option defaults to `a`.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: Creating a writable stream
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If the data being written to a file arrives in chunks (such as occurs with a
    file upload), streaming that data through a `WritableStream` object interface
    provides more flexibility and efficiency.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: fs.createWriteStream(path, [options])
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `fs.createWriteStream(path, [options])` method returns a writable stream
    object for file at `path`.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: 'The following options are available:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '`flags`: File mode argument as a string. Defaults to `w`.'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`encoding`: One of `utf8`, `ascii`, or `base64`. Defaults to no encoding.'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mode`: Octal representation of file mode, defaulting to 0666.'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`start`: An offset indicating the position in the file where writing should
    begin.'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, this little program functions as the world''s simplest word processor,
    writing all terminal input to a file, until the terminal is closed:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Caveats
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The side effects of opening a file descriptor and reading from it are minimal,
    such that in normal development, very little thought is given to what is actually
    happening within the system. Normally, reading a file doesn't change it.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: 'When writing to a file, a number of concerns must be addressed, such as these:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: Is there sufficient writable storage space available?
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is another process simultaneously accessing this file, or even erasing it?
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What must be done if a write operation fails or is unnaturally terminated mid-stream?
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We've seen the exclusive write mode flag (`wx`) that can help in the case of
    multiple write processes simultaneously trying to create a file. Full solutions
    to all the concerns one might face when writing to files are difficult to derive
    in general, or state briefly. Node encourages asynchronous programming. Nevertheless,
    with regard to the filesystem in particular, sometimes synchronous, deterministic
    programming is necessary. You are encouraged to keep these and other issues in
    mind, and to keep I/O non-blocking whenever possible.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: Serving static files
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Anyone using Node to create a web server will need to respond intelligently
    to HTTP requests. An HTTP request to a web server for a resource expects some
    sort of response. A basic file static file server might look like this:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This server services GET requests on port `8000`, expecting to find a local
    file at a relative path equivalent to the URL path segment. We see how easy Node
    makes it for us to stream local file data, simply piping a `ReadableStream` into
    a `WritableStream` representing a client socket connection. This is an enormous
    amount of functionality to be safely implemented in a handful of lines.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: Eventually, a great deal more will be added, such as handling routines for standard
    HTTP methods, handling errors and malformed requests, setting proper headers,
    managing favicon requests, and so forth.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: Let's build a reasonably useful file server with Node, one that will respond
    to HTTP requests by streaming back a resource and which will respect caching requests.
    In the process, we will touch on how to manage content redirection. Later on in
    this chapter, we will also look at implementing file uploads. Note that a web
    server fully compliant with all features of HTTP is a complicated beast, so what
    we are creating should be considered a good start, not an end.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: Redirecting requests
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, a client will try to `GET` a URL that is incorrect or incomplete
    in some way, the resource may have been moved, or there are better ways to make
    the same request. Other times, a `POST` may create a new resource at a new location
    the client cannot know, necessitating some response header information pointing
    to the newly created URI. Let's look at two common redirection scenarios someone
    implementing a static file server with Node might face.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: 'Two response headers are fundamental to redirection:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '`Location`: This indicates a redirection to a location where said content body
    can be found'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Content-Location`: This is meant to indicate the URL where the requester will
    find the original location of the entity enclosed in the response body'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Content-Location`：这意味着指示请求者将在响应主体中找到实体的原始位置的URL'
- en: 'Also, there are two specific use cases for these headers:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这些头还有两个特定的用例：
- en: To provide information about the location of a newly created resource
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供有关新创建资源位置的信息
- en: in response to a `POST`
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 对`POST`的响应
- en: To inform the client of an alternate location for the requested resource
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通知客户端请求资源的替代位置
- en: in response to a `GET`
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 对`GET`的响应
- en: There are many possible pairings of `Location` and `Content-Location` headers
    with HTTP status codes, the **3xx** (redirection) set in particular. In fact,
    these headers may even appear together in the same response. The user is encouraged
    to read the relevant sections of the HTTP/1.1 specification, as only a small set
    of common cases is discussed here.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '`Location`和`Content-Location`头与HTTP状态代码有许多可能的配对，特别是**3xx**（重定向）集。实际上，这些头甚至可以在同一个响应中一起出现。鼓励用户阅读HTTP/1.1规范的相关部分，因为这里只讨论了一小部分常见情况。'
- en: Location
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 位置
- en: Responding to a `POST` with a `201` status code indicates that a new resource
    has been created its URI assigned to the `Location` header and that the client
    may go ahead and use that URI in the future. Note that it is up to the client
    to decide whether, and when, to fetch this resource. As such, this is not, strictly
    speaking, a redirect.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`201`状态代码响应`POST`表示已创建新资源并将其URI分配给`Location`头，客户端可以在将来使用该URI。请注意，由客户端决定是否以及何时获取此资源。因此，严格来说，这不是重定向。
- en: 'For example, a system might create new accounts by posting new user information
    to a server, expecting to receive the location of a new user page:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，系统可能通过将新用户信息发布到服务器来创建新帐户，期望接收新用户页面的位置：
- en: '[PRE38]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Similarly, in cases where a resource creation request has been accepted but
    not yet fulfilled, a server will indicate a status of `202`. This will be the
    case in the preceding example if creation of the new user record had been delegated
    to a worker queue, which might at some point in the future create a record at
    the given `Location`.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，在接受但尚未完成的情况下，服务器将指示`202`状态。在前面的例子中，如果创建新用户记录的工作已被委托给工作队列，那么这将是情况。
- en: We will see a realistic implementation demonstrating this usage later on in
    the chapter, when we discuss file uploads.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章后面看到一个实际的实现，演示这种用法，当我们讨论文件上传时。
- en: Content-Location
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Content-Location
- en: 'When a `GET` is made to a resource that has multiple representations and those
    can be found at distinct resource locations, a `content-location` header for the
    particular entity should be returned. For example, content format negotiation
    is a good candidate for `Content-Location` handling. One might be interested in
    retrieving all blog posts for a given month, perhaps available at a URL such as:
    `http://example.com/september/`. GET requests with an `Accept` header of `application/json`
    will receive a response in JSON format. A request for XML will receive that representation.'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 当对具有多个表示形式的资源进行`GET`请求，并且这些表示形式可以在不同的资源位置找到时，应该返回特定实体的`content-location`头。例如，内容格式协商是`Content-Location`处理的一个很好的例子。可能有兴趣检索给定月份的所有博客文章，可能可以在URL上找到，比如：`http://example.com/september/`。带有`application/json`的`Accept`头的GET请求将以JSON格式接收响应。对XML的请求将接收该表示形式。
- en: 'If a caching mechanism is being used those resources may have alternate permanent
    locations, such as `http://example.com/cache/september.json` or `http://example.com/cache/september.xml`.
    One will send this additional location information via `Content-Location`, in
    a response object resembling this:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 如果正在使用缓存机制，这些资源可能具有替代的永久位置，比如`http://example.com/cache/september.json`或`http://example.com/cache/september.xml`。将通过`Content-Location`发送此附加位置信息，响应对象类似于这样：
- en: '[PRE39]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In cases where the requested URL has been moved, permanently or temporarily,
    the **3xx** group of status codes can be used with `Content-Location` to indicate
    this state. For example, to redirect a request to a URL that has been permanently
    moved, one should send a 301 code:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在请求的URL已经被永久或临时移动的情况下，可以使用`3xx`状态代码组和`Content-Location`来指示此状态。例如，要重定向到已永久移动的URL，应发送301代码：
- en: '[PRE40]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Implementing resource caching
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施资源缓存
- en: As a general rule, never expend resources delivering irrelevant information
    to clients. For an HTTP server, resending files that the client already possesses
    is an unnecessary I/O cost, exactly the wrong way to implement a Node server,
    increasing latency as well as the financial hit of paying for misappropriated
    bandwidth.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个一般规则，永远不要浪费资源向客户端传递无关的信息。对于HTTP服务器，重新发送客户端已经拥有的文件是不必要的I/O成本，这是实现Node服务器的错误方式，会增加延迟以及支付被挪用的带宽的财务损失。
- en: Browsers maintain a cache of the files they have already fetched, and an **Entity
    Tag** (**ETag**) identifies these files. An ETag is a response header sent by
    servers to uniquely identify entities they are returning, such as a file. When
    a file changes on a server, that server will send a different ETag for said file,
    allowing file changes to be tracked by clients.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器维护已经获取的文件的缓存，并且**实体标签**（**ETag**）标识这些文件。ETag是服务器发送的响应头，用于唯一标识它们返回的实体，比如一个文件。当服务器上的文件发生变化时，该服务器将为该文件发送一个不同的ETag，允许客户端跟踪文件的更改。
- en: 'When a client makes a request to a server for a resource contained within that
    client''s cache, that request will contain an `If-None-Match` header set to the
    value of the ETag associated with the said cached resource. The `If-None-Match`
    header can contain one or multiple ETags:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端向服务器请求其缓存中包含的资源时，该请求将包含一个`If-None-Match`头，该头设置为与所述缓存资源相关联的ETag的值。`If-None-Match`头可以包含一个或多个ETag：
- en: '[PRE41]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: A server understands this header and will return the full entity body of the
    requested resource only if none of the sent ETags match the current resource entity
    tag. If one of the sent ETags matches the current entity tag, the server will
    respond with a 304 (not modified) status, which should result in a browser, fetching
    the resource from its internal cache.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming that we have an `fs.Stats` object available, managing cache controls
    on a resource can be done easily with Node:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We create an `etag` for the current file by creating an MD5 of the current file
    size and its last modified time, and match against the sent `If-None-Match` header.
    If the two do not match, the resource representation has changed, and the new
    version must be sent back to the requesting client. Note that the specific algorithm
    one should use to create an `etag` is not formally specified. The example technique
    should work well for most purposes.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: 'Hey! What about `Last-Modified` and `If-Unmodified-Since`? These are fine headers
    and are also useful in the case of caching files. Indeed, one should set the `Last-Modified`
    header where possible when responding to entity requests. The techniques we''re
    describing here using ETag will work similarly with these tags, and in fact, using
    both Etags and these other tags is encouraged. For more information, consult:
    [http://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html#sec13.3.4](http://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html#sec13.3.4).'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: Handling file uploads
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is likely that anyone reading this sentence has had at least one experience
    with uploading a file from a client to a server. Some may have even implemented
    a file upload service, a server that will receive and do something useful with
    a multipart data stream. Within popular development environments, this task has
    been made very easy. In the PHP environment, for example, uploaded data is automatically
    processed and made globally available, neatly parsed and packaged into an array
    of files or form field values, without the developer having written a single line
    of code.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, Node leaves implementation of file upload handling to the developer,
    a challenging bit of work many developers may be unable to successfully or safely
    complete.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, Felix Geisendorfer created the **Formidable** module, one of the
    most important early contributions to the Node project. A widely implemented,
    enterprise-grade module with extensive test coverage, it not only makes handling
    file uploads a snap, but can be used as a complete tool for handling form submissions.
    We will use this library to add file upload capability to our file server.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: For more information about how HTTP file uploads are designed, and the tricky
    implementation problems developers must overcome, consult the multipart/form-data
    specification at [http://www.w3.org/TR/html401/interact/forms.html#h-17.13.4.2](http://www.w3.org/TR/html401/interact/forms.html#h-17.13.4.2)
    and Geisendorfer's breakdown of how **Formidable** was conceived of and evolved
    at [http://debuggable.com/posts/parsing-file-uploads-at-500-mb-s-with-node-js:4c03862e-351c-4faa-bb67-4365cbdd56cb](http://debuggable.com/posts/parsing-file-uploads-at-500-mb-s-with-node-js:4c03862e-351c-4faa-bb67-4365cbdd56cb).
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: 'First, install `formidable` via npm:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'You can now `require` it:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We will assume that file uploads will be posted to our server along a path of
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: '`/uploads/`, and that the upload arrives via a HTML form that looks like this:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This form will allow a client to write some sort of title for the upload, and
    to select one (or multiple) files for uploading. At this point, our only responsibility
    on our server is to properly detect when a `POST` request has been made and pass
    the relevant request object to Formidable.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: 'We won''t be covering every part of the comprehensive formidable API design,
    but we''ll focus on the key `POST` events the library exposes. As formidable extends
    `EventEmitter`, we use the `on(eventName,callback)` format to catch file data,
    field data, and termination events, sending a response to the client describing
    what the server has successfully processed:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: We see here how a `formidable` instance receives an `http.Incoming` object through
    its `parse` method, and how the write path for incoming files is set using the
    `uploadDir` attribute of that instance. The example sets this directory to the
    local directory. A real implementation would likely target a dedicated upload
    folder, or even direct the received file to a storage service, receiving in return
    the final storage location (perhaps receiving it via HTTP and a `Location` header...).
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: 'Also note how the file event callback receives a formidable `File` object as
    a second argument, which contains important file information including the following:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: '**size**: The size of the uploaded file, in bytes'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*` **path**: The current location of the uploaded file on the local filesystem,
    such'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: as `/tmp/bdf746a445577332e38be7cde3a98fb3`
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: '**name**: The original name of the file as it existed on the client filesystem,
    such as `lolcats.jpg`'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**type**: The file mime type, such as `image/png`'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In a few lines of code, we''ve implemented a significant amount of `POST` data
    management. Formidable also provides tools for handling progress indicators, dealing
    with network errors, and more, which the reader can learn about by visiting: [https://github.com/felixge/node-formidable](https://github.com/felixge/node-formidable).'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: Putting it all together
  id: totrans-351
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Recalling our discussion of favicon handling from the last chapter and adding
    what we''ve learned about file caching and file uploading, we can now construct
    a simple file server handling the `GET` and `POST` requests:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Note the 404 (not found) and 500 (internal server error) status codes.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: '`Content-Length` is measured in bytes, not characters. Normally, your data
    will be in single byte characters (hello is five bytes long), but this is not
    always the case. If you are determining the length of a stream buffer, use `Buffer.byteLength`.'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: A simple file browser
  id: totrans-356
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s take what we''ve learned about files and Node to do something that
    truly (and hopefully) no web page can; let''s directly browse the entire hard
    disk of your personal computer! To make this possible, we''ll use two powerful
    recent additions to the JavaScript and Node family: *Electron* and *Vue.js*.'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: 'Start out at your terminal with commands like these:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The default answers are fine, except for the entry point—instead of `index.js`,
    type `main.js`. When you''re done, you should have a `package.json` file like
    this:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now, let''s take a look at these three commands:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Try the first to ensure that npm got a working copy of Electron onto your computer.
    As of this writing, the current version is v1.7.9\. The second command will execute
    electron "empty", that is, without giving it an app to run. The third command
    tells electron to run the app in this folder: Electron will read `package.json`
    to find and run `main.js`.'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, you can use `-g` to install Electron globally, and then reach
    the executable more easily with commands like these:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Electron
  id: totrans-367
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s run the second command. The result may be surprising: a graphical window
    appears on your screen!:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/74646cbc-c5e5-41ff-b207-9d1524a547a4.png)'
  id: totrans-369
  prefs: []
  type: TYPE_IMG
- en: 'What is this? What is Electron? Let''s answer that question several ways: to
    the end user, to the developer or product owner, under the hood, and at the end
    of the chapter, from the perspective of JavaScript''s history and development.'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: 'To the end user, an Electron app is just a regular desktop app. Users can''t
    even tell it''s made with Electron. The unboxing flow is exactly the same: the
    user gets the app from their favorite app store, or downloads `setup.exe` from
    your website. The daily experience is also the same: the app has an icon on the
    Start menu or dock, menus where they should be, a `File|Open...` dialog—all the
    features users expect from a desktop application. You might use Slack on Windows
    or macOS, for instance, and may be surprised to learn that Slack is made with
    Electron.'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: To the developer or product owner, Electron is a great way to make desktop apps.
    Developers can use the modern and powerful technologies they learned for the web
    on the desktop now. All your favorite npm modules can come along, too. Product
    owners like being able to ship version 1.0 simultaneously on Windows, Mac, and
    Linux with very little additional development or testing required. Business stakeholders
    like being able to task a single group of web developers across web and desktop
    projects, instead of having to hire new individual dedicated teams (a separate
    one per target operating system) experienced in each individual native desktop
    stack.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: Under the hood, Electron is pretty amazing. It's built from parts of both Chromium
    and Node, getting abilities like page rendering from Chromium, and abilities like
    buffers, files, and sockets from Node. Both Chromium and Node contain V8, and
    inside V8 a JavaScript event loop, of course. In an impressive engineering feat,
    Electron merges these two event loops together, allowing a single JavaScript event
    to run code that affects both the screen and the system.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: Electron is made by GitHub, which also develops the Atom text editor. To make
    Atom as hackable as the web, GitHub built it using web technologies. Realizing
    that other software teams might want to construct desktop apps this way, GitHub
    released their tools first as Atom Shell, and simplified the name to Electron.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''ve got Electron running, let''s make Electron an app of our own.
    The `electron .` command causes Electron to look in `package.json` to see what
    it should do. There, we''re pointing it to `main.js`:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'You can imagine that Node is running the file, even though the executable that''s
    running it is actually Electron (which has Node and V8 inside, of course). Note
    how the code can require familiar Node modules like `path` and `url` as well as
    some new ones, such as `electron`. The code in `main.js` creates a special Electron
    browser window that''s 800 pixels wide and 800 pixels high, and navigates it to
    `index.html`:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: This also looks quite familiar from what we'd expect on the web. We'll talk
    about Vue later in this chapter; right now, note the reload `button` at the top
    of the page and the `script` tag at the end.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: The button is useful when developing. Instead of restarting the Electron process
    at the command line, you can just make a change to this page or the JavaScript
    it brings in and see the results from hitting the Reload button. Electron doesn't
    display Chromium's default browser toolbar, where the Reload button lives, but
    View, Reload is available on the menu bar on macOS, and it's even easier to put
    a Reload button right in the page.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: To understand the `script` tag at the end, it's best to first get a basic understanding
    of Electron's process architecture.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: Electron processes
  id: totrans-382
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Built from Chromium, Electron inherited Chromium''s (and Chrome''s) one-process-per-tab
    architecture. With Electron running our app, there is only one "tab": the window
    on your screen, but there are still two processes. The *main* process represents
    the underlying browser, which you started from the command line, at which point
    it read `package.json`, and then ran `main.js`. Electron''s main process can create
    new `BrowserWindow` objects, and deal with events that affect the overall lifecycle
    of the desktop app, from startup to shutdown.'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: On the page Electron opens, however, a different process, the *renderer* process,
    runs the JavaScript there. Only a renderer process is able to perform GUI-related
    tasks, like manipulating the DOM.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: Node is available in both processes. If a module expects the DOM to be present,
    it may not work in the main process, however. For instance, jQuery fails to load
    in Electron's main process, but works fine in a renderer process, while Handlebars
    works fine in both.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: In instances where the code in one Electron process needs to perform an action
    or get an answer from some code in the other process, the solution is Node's standard
    inter-process communication tools, described later in [Chapter 7](48e16668-9318-4577-b3c0-3f4dbce035d9.xhtml),
    *Using Multiple Processes*. Additionally, Electron conveniently wraps some of
    these in its own API.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: The renderer process
  id: totrans-387
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we''ve seen Electron start, run `main.js`, and open `index.html`. In
    summary, here''s how the whole thing works:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: 'Electron''s *main* process does the following:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: reads `package.json`, which tells it to then
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: run `main.js`
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This causes Electron to start a *renderer* process to do this:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: parse `index.html`, which then
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: runs `renderer.js`
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s take a look at the code there:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: First, this code brings in the bluebird promise library, setting it to `Promise`.
    The call to `Promise.promisifyAll()` creates functions like `fs.lstatAsync()`,
    the promisified version of `fs.lstat()`.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: Our app's core logic is factored into a single function named `go()`, which
    gets passed an absolute filesystem path the user wants the app to take a look
    at. If the path is to an image, the app shows it on the page. If the path is to
    a directory, the app lists the folder's contents.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: To perform this logic, the preceding code first simply looks for a common image
    file extension. If not present, an asynchronous step looks at the disk with `fs.lstatAsync()`
    to then be able to call `stat.isDirectory()`. If it is a directory, another promisified
    call, `fs.readdirAsync()`, gets the directory listing.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a picture of our simple Electron-powered file browser in action:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c9740216-ac9e-4e7f-a15a-74a2a6ef710e.png)'
  id: totrans-401
  prefs: []
  type: TYPE_IMG
- en: Vue.js
  id: totrans-402
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our app's user experience is powered by *Vue.js*, a frontend JavaScript framework
    for building and easily changing the contents of a web page. Like React, Vue lets
    you template components, put them on the page, and change them when the data underneath
    changes.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: React uses JSX to combine HTML tags with JavaScript code. This requires a preprocessor
    like *Babel* to transpile the JSX portions into ES6 JavaScript. In a typical React
    stack, *webpack* manages a build process that includes Babel, converting and combining
    your development files into files you'll run, test, and eventually deploy. The
    webpack dev server shows your site as you code it, even automatically refreshing
    as you change your code.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: 'Vue, however, doesn''t require a transpilation step. You can use it with webpack,
    but you can also use it with just a script tag, like this one in our app''s `index.html`:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: This flexibility makes it easy to get started with Vue, makes Vue easy to get
    running in Electron, and is why we've picked it for this example app.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: 'Back on the `index.html` page, take a look at these lines:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Also, in the `renderer.js` script, take a look at this part:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: In the page, `<div id="app">` identifies `div` as our app, and in the script,
    `var app = new Vue({});` creates the new JavaScript object that connects to and
    controls the *app* `div`. The data object inside `app` defines values that appear
    in the div and thus on the page. For example, `app.location`, which through some
    clever internal linking with `this` reaches into the `data` object above, is shown
    on the page where `{{ location }}` appears. Vue even watches for changes to `data.location`—set
    that to a new value and the page will update automatically. With this ability,
    Vue is said to be *reactive*.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: Browse around your local disk with the file browser we just built, and imagine
    all the desktop apps you can now create with Node and Electron.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: Earlier, this chapter asked, "What is Electron?" and composed different answers
    imagining different stakeholders and considering different perspectives.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: Electron gets JavaScript one step closer to Kris Kowal's goal for the language,
    which you may remember from [Chapter 1](ad3a0c29-f1fb-4319-9042-a9f38bb0b53a.xhtml),
    *Understanding the Node Environment*, is no less than "world domination", meaning
    able to run everywhere and do anything. Also, taking JavaScript's place in the
    last few decades of computing into consideration, it achieves this with some wry
    irony.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: Brendan Eich created JavaScript to script small tasks within web pages running
    on browsers on personal computers in the 1990s, which had just recently gained
    bitmapped displays and graphical operating systems. There, JavaScript was tightly
    contained within the sandbox of the browser tab. The sandbox enforced strict security
    requirements, and limited it from, among other things, looking at some files.
    Close to the user and close to the screen, JavaScript could validate form data,
    and change CSS on the fly. In this first stage of life, most days, JavaScript
    animated some text.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: Node took JavaScript to the server, distancing it from the graphical screen,
    but freeing it from the confines of the browser. There, JavaScript became a competent
    and complete systems language, accessing files and sockets to perform useful and
    powerful tasks. In this second stage of life, most days, JavaScript migrated a
    database.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: Electron takes JavaScript back to the client. Like a wandering feudal warrior
    returning to his home village after years of exile, (and, of course, distant and
    elite training) JavaScript returns with ES6 features and npm modules it developed
    in the harsh wasteland of the server, being used and developed alongside formidable
    partners (and oftentimes foes) like C++ and Java. Back on the desktop and armed
    with Electron, it can use these abilities outside of the restricted confines of
    the browser. In this third stage of life, JavaScript really can do anything.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-419
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we saw how Node's API is a comprehensive map to native filesystem
    bindings, exposing a full range of functionality to the developer while requiring
    very little code or complexity. Additionally, we saw how files are easily wrapped
    into `Stream` objects, and how this consistency with the rest of Node's design
    simplifies interactions between different types of I/O, such as between network
    data and files. Using Electron, we built a file browser that runs as a cross-platform
    native application, opening up a whole new world for Node developers.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: We've also learned something about how to build servers with Node that can accommodate
    regular client expectations, easily implementing file uploading and resource caching.
    Having covered the key features of Node, it is time to use these techniques in
    building larger applications able to handle many thousands of clients.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
