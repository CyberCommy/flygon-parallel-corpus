- en: Using Strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At some point your application will need to communicate with people, and that
    means using text; such as outputting text, taking in data as text, and then converting
    that data to appropriate types. The C++ Standard Library has a rich collection
    of classes to manipulate strings, convert between strings and numbers, and to
    obtain string values localized for specified languages and cultures.
  prefs: []
  type: TYPE_NORMAL
- en: Using the string class as a container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'C++ strings are based on the `basic_string` template class. This class is a
    container, so it uses iterator access and methods to obtain information, and has
    template parameters that contain information about the character type it holds.
    There are different `typedef` for specific character types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `string` class is based on `char`, `wstring` is based on `wchar_t` wide
    characters, and the `16string` and `u32string` classes are based upon 16-bit and
    32-bit characters, respectively. For the rest of the chapter, we will concentrate
    on just the `string` class, but it equally applies to the other classes.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing, copying, and accessing characters in a string will require a different
    code for the different-sized characters, while the traits template parameter provides
    the implementations. For `string`, this is the `char_traits` class. When this
    class, for example, copies characters, it will delegate this action to the `char_traits`
    class and its `copy` method. The traits classes are also used by stream classes,
    so they also define an end of file value that is appropriate to the file stream.
  prefs: []
  type: TYPE_NORMAL
- en: 'A string is essentially an array of zero or more characters that allocates
    memory when it is needed and deallocates it when a `string` object is destroyed.
    In some respects, it is very similar to a `vector<char>` object. As a container,
    the `string` class gives iterator access through the `begin` and `end` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the `begin` and `end` methods are called to get iterators from the items
    in the `string,` which are passed to the `copy` function from `<algorithm>` to
    copy each character to the console via the `ostream_iterator` temporary object.
    In this respect, the `string` object is similar to a `vector`, so we use the previously
    defined `s` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This fills the `vector` object using the range of characters provided using
    the `begin` and `end` methods on the `string` object and then prints those characters
    to the console using the `copy` function in exactly the same way as we used previously.
  prefs: []
  type: TYPE_NORMAL
- en: Getting information about a string
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `max_size` method will give the maximum size of the string of the specified
    character type on your computer architecture and this can be surprisingly large.
    For example, on a 64-bit Windows computer with 2 GB of memory, `max_size` for
    a `string` object will return 4 billion characters, and for a `wstring` object
    the method will return 2 billion characters. This is clearly more than the memory
    in the machine! The other size methods return more meaningful values. The `length`
    method returns the same value as the `size` method, that is, how many items (characters)
    there are in the string. The `capacity` method indicates how much memory is already
    allocated for the string in terms of the number of characters.
  prefs: []
  type: TYPE_NORMAL
- en: You can compare a `string` with another by calling its `compare` method. This
    returns an `int` and not a `bool` (but note that an `int` can be converted silently
    to a `bool`), where a return value of `0` means that the two strings are the same.
    If they are not the same, this method returns a negative value if the parameter
    string is greater that the operand string, or a positive value if the parameter
    is less than the operand string. In this respect *greater* and *less than* will
    test the ordering of the strings alphabetically. In addition, there are global
    operators defined for `<`, `<=`, `==`, `>=`, and `>` to compare string objects.
  prefs: []
  type: TYPE_NORMAL
- en: A `string` object can be used like a C string through the `c_str` method. The
    pointer returned is `const`; you should be aware that the pointer may be invalidated
    if the `string` object is changed, so you should not store this pointer. You should
    not use `&str[0]` to get a C string pointer for the C++ string `str` because the
    internal buffer used by the string classes is not guaranteed to be `NUL` terminated.
    The `c_str` method is provided to return a pointer that *can* be used as a C string,
    and hence `NUL` terminated.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to copy data from the C++ string to a C buffer you can call the
    `copy` method. You pass the destination pointer and the number of characters to
    copy as parameters (and optionally an offset) and the method will attempt to copy,
    at most, the specified number of characters to the destination buffer: *but without
    a null termination character*. This method assumes that the destination buffer
    is big enough to hold the copied characters (and you should take steps to ensure
    this). If you want to pass the size of the buffer so that the method performs
    this check for you, call the `_Copy_s` method instead.
  prefs: []
  type: TYPE_NORMAL
- en: Altering strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The string classes have standard container access methods, so you can access
    individual characters through a reference (read and write access) with the `at`
    method and `[]` operator. You can replace the entire string using the `assign`
    method, or swap the contents of two string objects with the `swap` method. Further,
    you can insert characters in specified places with the `insert` method, remove
    specified characters with the `erase` method, and remove all characters with the
    `clear` method. The class also allows you to push characters to the end of the
    string (and remove the last character) with the `push_back` and `pop_back` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You can add one or more characters to the end of a string using the `append`
    method or the `+=` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `<string>` library also defines a global `+` operator that will concatenate
    two strings in a third string.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to change characters in a string you can access the character through
    an index with the `[]` operator, using the reference to overwrite the character.
    You can also use the `replace` method to replace one or more characters at a specified
    position with characters from a C string or from a C++ string, or some other container
    accessed through iterators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Finally, you can extract part of a string as a new string. The `substr` method
    takes an offset and an optional count. If the count of characters is omitted,
    then the substring will be from the specified position until the end of the string.
    This means that you can copy a left-hand part of a string by passing an offset
    of 0 and a count that is less than the size of the string, or you can copy a right-hand
    part of the string by passing just the index of the first character.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In this code, the first example copies the first three characters into a new
    string. In the second example, the copying starts at the eighth character and
    continues to the end.
  prefs: []
  type: TYPE_NORMAL
- en: Searching strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `find` method is passed using either a character, a C string, or a C++ string,
    and you can provide an initial search position to start the search. The `find`
    method returns the position (rather than an iterator) to where the search text
    was located, or a value of `npos` if the text cannot be found. The offset parameter,
    and a successful return value from the `find` method, enables you to parse a string
    repeatedly to find specific items. The `find` method searches for the specified
    text in the forward direction, and there is also an `rfind` method that performs
    the search in the reverse direction.
  prefs: []
  type: TYPE_NORMAL
- en: Note that `rfind` is not the complete opposite of the `find` method. The `find`
    method moves the search point forward in the string and at each point compares
    the search string with the characters from the search point forwards (so the first
    search text character, then the second, and so on). The `rfind` method moves the
    search point *backwards*, but the comparisons are still made *forwards*. So, assuming
    the `rfind` method is not given an offset, the first comparison will be made at
    an offset from the end of the string the size of the search text. Then, the comparison
    is made by comparing the first character in the search text with the character
    at the search point in the searched string, and if this succeeds, the second character
    in the search text is compared with the character after the search point. So,
    the comparisons are made in a direction opposite to the direction of the movement
    of the search point.
  prefs: []
  type: TYPE_NORMAL
- en: This becomes important because if you want to parse a string using the return
    value from the `find` method as an offset, after each search you should move the
    search offset *forwards**, *and for `rfind` you should move it *backwards*.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to search for all the positions of `the` in the following string,
    you can call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This will find the search text at the character positions of 3, 9, and 15\.
    To search the string backwards, you could call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The highlighted code shows the changes that should be made, showing you that
    you need to search from the end and use the `rfind` method. When you have a successful
    result you need to decrement the position before the next search. Like the `find`
    method, the `rfind` method returns `npos` if it cannot find the search text.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are four methods that allow you to search for one of several individual
    characters. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The search string is `eh` and the `find_first_of` will return when it finds
    either the character `e` or `h` in the string. In this example, the character
    `h` is found first at position 4\. You can provide an offset parameter to start
    the search, so you can use the return value from `find_first_of` to parse through
    a string. The `find_last_of` method is similar, but it searches the string in
    the reverse direction for one of the characters in the search text.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are also two search methods that will look for a character *other than*
    the characters provided in the search text: `find_first_not_of` and `find_last_not_of`.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This code looks for a character other than a digit and so it finds the `t` at
    position 3 (the fourth character).
  prefs: []
  type: TYPE_NORMAL
- en: There is no library function to trim whitespace from a `string`, but you can
    trim spaces on the left and right of strings by using the find functions to find
    non-whitespace and then use this as an appropriate index for the `substr` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, two new strings are created: one left-trims spaces,
    and the other right-trims spaces. The first forward searches for the first character
    that is not whitespace and uses this as the start index of the substring (no count
    is provided because all of the remaining string is copied). In the second case
    the string is reverse searched for a character that is not whitespace, but the
    location returned will be the last character of `hello`; since we need the substring
    from the first character, we increment this index to get the count of characters
    to copy.'
  prefs: []
  type: TYPE_NORMAL
- en: Internationalization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `<locale>` header contains the classes for localizing how time, dates, and
    currency are formatted, and also to provide localized rules for string comparisons
    and ordering.
  prefs: []
  type: TYPE_NORMAL
- en: The C Runtime Library also has global functions to carry out localization. However,
    it is important in the following discussion that we distinguish between C functions
    and the C locale. The C locale is the default locale, including the rules for
    localization, used in C and C++ programs and it can be replaced with a locale
    for a country or culture. The C Runtime Library provides functions to change the
    locale, as does the C++ Standard Library.
  prefs: []
  type: TYPE_NORMAL
- en: Since the C++ Standard Library provides classes for localization, this means
    that you can create more than one object representing a locale. A locale object
    can be created in a function and can only be used there, or it can be applied
    globally to a thread and used only by code running on that thread. This is in
    contrast to the C localization functions, where changing the locale is global,
    so all code (and all threads of execution) will be affected.
  prefs: []
  type: TYPE_NORMAL
- en: Instances of the `locale` class are either created through the class constructor
    or through static members of the class. The C++ stream classes will use a locale
    (as explained later), and if you want to change the locale you call the `imbue`
    method on the stream object. In some cases, you will want to access one of these
    rules directly, and you have access to them through the locale object.
  prefs: []
  type: TYPE_NORMAL
- en: Using facets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Internationalization rules are known as **facets**. A locale object is a container
    of facets, and you can test if the locale has a specific facet using the `has_facet`
    function; if it does, you can get a `const` reference to the facet by calling
    the `use_facet` function. There are six types of facets summarized by seven categories
    of class in the following table. A facet class is a subclass of the `locale::facet`
    nested class.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Facet type** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `codecvt`, `ctype` | Converts between one encoding scheme to another and
    is used to classify characters and convert them to upper or lowercase |'
  prefs: []
  type: TYPE_TB
- en: '| `collate` | Controls the ordering and grouping of characters in a string,
    including comparing and hashing of strings |'
  prefs: []
  type: TYPE_TB
- en: '| `messages` | Retrieves localized messages from a catalog |'
  prefs: []
  type: TYPE_TB
- en: '| `money` | Converts numbers representing currency to and from strings |'
  prefs: []
  type: TYPE_TB
- en: '| `num` | Converts numbers to and from strings |'
  prefs: []
  type: TYPE_TB
- en: '| `time` | Converts times and dates in numeric form to and from strings |'
  prefs: []
  type: TYPE_TB
- en: The facet classes are used to convert the data to strings and so they all have
    a template parameter for the character type used. The `money`, `num,` and `time`
    facets are represented by three classes each. A class with the `_get` suffix that
    handles parsing strings, while a class with the `_put` suffix handles formatting
    as strings. For the `money` and `num` facets there is a class with the `punct`
    suffix that contains the rules and symbols for punctuation.
  prefs: []
  type: TYPE_NORMAL
- en: Since the `_get` facets are used to convert sequences of characters into numeric
    types, the classes have a template parameter that you can use to indicate the
    input iterator type that the `get` methods will use to represent a range of characters.
    Similarly, the `_put` facet classes have a template parameter that you can use
    to provide the output iterator type the `put` methods will write the converted
    string to. There are default types provided for both iterators types.
  prefs: []
  type: TYPE_NORMAL
- en: The `messages` facet is used for compatibility with POSIX code. The class is
    intended to allow you to provide localized strings for your application. The idea
    is that the strings in your user interface are indexed and at runtime you access
    the localized string using the index through the `messages` facet. However, Windows
    applications typically use message resource files compiled using the **Message
    Compiler**. It is perhaps for this reason that the `messages` facet provided as
    part of the Standard Library does not do anything, but the infrastructure is there,
    and you can derive your own `messages` facet class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `has_facet` and `use_facet` functions are templated for the specific type
    of facet that you want. All facet classes are subclasses of the `locale::facet`
    class, but through this template parameter the compiler will instantiate a function
    that returns the specific type you request. So, for example, if you want to format
    time and date strings for the French locale, you can call this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the `french` string identifies the locale, and this is the language string
    used by the C Runtime Library `setlocale` function. The second line obtains the
    facet for converting numeric times into strings, and hence the function template
    parameter is `time_put<char>`. This class has a method called `put` that you can
    call to perform the conversion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `time` function (via `<ctime>`) returns an integer with the current time
    and date, and this is converted to a `tm` structure using the `gmtime` function.
    The `tm` structure contains individual members for the year, month, day, hours,
    minutes, and seconds. The `gmtime` function returns the address to a structure
    that is statically allocated in the function, so you do not have to delete the
    memory it occupies. The facet will format the data in the `tm` structure as a
    string through the output iterator passed as the first parameter. In this case,
    the output stream iterator is constructed from the `cout` object and so the facet
    will write the format stream to the console (the second parameter is not used,
    but because it is a reference you have to pass something, so the `cout` object
    is used there too). The third parameter is the separator character (again, this
    is not used). The fifth and (optional) sixth parameters indicate the formatting
    that you require. These are the same formatting characters as used in the C Runtime
    Library function `strftime`, as two single characters rather than the format string
    used by the C function. In this example, `x` is used to get the date and `#` is
    used as a modifier to get the long version of the string.
  prefs: []
  type: TYPE_NORMAL
- en: 'The  code will give the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that the words are not capitalized and there is no punctuation, also
    notice the order: weekday name, day number, month, then year.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If the `locale` object constructor parameter is changed to `german` then the
    output will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The items are in the same order as in French, but the words are capitalized
    and punctuation is used. If you use `turkish` then the result is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the day of the week is at the end of the string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Two countries divided by a common language will give two different strings,
    and the following are the results for `american` and `english-uk`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Time is used as the example here because there is no stream, an insertion operator
    is used for the `tm` structure, and it is an unusual case. For other types, there
    are insertion operators that put them into a stream, and so the stream can use
    a locale to internationalize how it shows the type. For example, you can insert
    a `double` into the `cout` object and the value will be printed to the console.
    The default locale, American English, uses the period to separate whole numbers
    from the fractional part, but in other cultures a comma is used.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `imbue` function will change the localization until the method is called
    subsequently:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Here, the stream object is localized to US English and then the floating-point
    number `1.1` is printed on the console. Next, the localization is changed to French,
    and this time the console will show `1,1`. In French, the decimal point is the
    comma. The last line resets the stream object by passing the locale returned from
    the `static classic` method. This returns the so-called **C locale**, which is
    the default in C and C++ and is American English.
  prefs: []
  type: TYPE_NORMAL
- en: The `static` method `global` can be used to set the locale that will be used
    as the default by each stream object. When an object is created from a stream
    class it calls the `locale::global` method to get the default locale. The stream
    clones this object so that it has its own copy independent of any local subsequently
    set by calling the `global` method. Note that the `cin` and `cout` stream objects
    are created before the `main` function is called, and these objects will use the
    default C locale until you imbue another locale. However, it is important to point
    out that, once a stream has been created, the `global` method has no effect on
    the stream, and `imbue` is the only way to change the locale used by the stream.
  prefs: []
  type: TYPE_NORMAL
- en: The `global` method will also call the C `setlocale` function to change the
    locale used by the C Runtime Library functions. This is important because some
    of the C++ functions (for example `to_string`, `stod`, as explained in the following
    text) will use the C Runtime Library functions to convert values. However, the
    C Runtime Library knows nothing about the C++ Standard Library, so calling the
    C `setlocale` function to change the default locale will not affect subsequently
    created stream objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is worth pointing out that the `basic_string` class compares strings using
    the character traits class indicated by a template parameter. The `string` class
    uses the `char_traits` class and its version of the `compare` method does a straight
    comparison of the corresponding characters in the two strings. This comparison
    does not take into account cultural rules for comparing characters. If you want
    to do a comparison that uses cultural rules, you can do this through the `collate`
    facet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Strings and numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Standard Library contains various functions and classes to convert between
    C++ strings and numeric values.
  prefs: []
  type: TYPE_NORMAL
- en: Converting strings to numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The C++ standard library contains functions with names like `stod` and `stoi`
    that convert a C++ `string` object to a numeric value (`stod` converts to a `double`
    and `stoi` converts to an `integer`). For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This will initialize the floating-point variable `d` with a value of `10.5`,
    which is then used in a calculation and the result is printed on the console.
    The input string may have characters that cannot be converted. If this is the
    case then the parsing of the string ends at that point. You can provide a pointer
    to a `size_t` variable, which will be initialized to the location of the first
    character that cannot be converted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the `idx` variable will be initialized with a value of
    `4`, indicating that the space between the `5` and `r` is the first character
    that cannot be converted to a `double`.
  prefs: []
  type: TYPE_NORMAL
- en: Converting numbers to strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `<string>` library provides various overloads of the `to_string` function
    to convert integer types and floating point types into a `string` object. This
    function does not allow you to provide any formatting details, so for an integer
    you cannot indicate the radix of the string representation (for example, hex),
    and for floating point conversions, you have no control over options like the
    number of significant figures. The `to_string` function is a simple function with
    limited facilities. A better option is to use the stream classes, as explained
    in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Using stream classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can print floating point numbers and integers to the console using the `cout`
    object (an instance of the `ostream` class) or to files with an instance of `ofstream`.
    Both of these classes will convert numbers to strings using member methods and
    manipulators to affect the formatting of the output string. Similarly, the `cin`
    object (an instance of the `istream` class) and the `ifstream` class can read
    data from formatted streams.
  prefs: []
  type: TYPE_NORMAL
- en: Manipulators are functions that take a reference to a stream object and return
    that reference. The Standard Library has various global insertion operators whose
    parameters are a reference to a stream object and a function pointer. The appropriate
    insertion operator will call the function pointer with the stream object as its
    parameter. This means that the manipulator will have access to, and can manipulate,
    the stream it is inserted into. For input streams, there are also extraction operators
    that have a function parameter which will call the function with the stream object.
  prefs: []
  type: TYPE_NORMAL
- en: The architecture of C++ streams means that there is a buffer between the stream
    interface that you call in your code and the low-level infrastructure that obtains
    the data. The C++ Standard Library provides stream classes that have string objects
    as the buffer. For an output stream, you access the string after items have been
    inserted in the stream, which means that the string will contain those items formatted
    according to those insertion operators. Similarly, you can provide a string with
    formatted data as the buffer for an input stream, and when you use extraction
    operators to extract the data from the stream you are actually parsing the string
    and converting parts of the string to numbers.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, stream classes have a `locale` object and stream objects will call
    the conversion facet of this locale to convert character sequences from one encoding
    to another.
  prefs: []
  type: TYPE_NORMAL
- en: Outputting floating point numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `<ios>` library has manipulators that alter how streams handle numbers.
    By default, the output stream will print floating-point numbers in a decimal format
    for numbers in the range `0.001` to `100000,` and for numbers outside this range
    it will use a scientific format with a mantissa and exponent. This mixed format
    is the default behavior of the `defaultfloat` manipulator. If you always want
    to use scientific notation, then you should insert the `scientific` manipulator
    into the output stream. If you want to display floating point numbers using just
    the decimal format (that is the whole number on the left side of a decimal point
    and the factional part on the right side), then modify the output stream with
    the `fixed` manipulator. The number of decimal places can be altered by calling
    the `precision` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The output from the preceding code is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The first line shows that scientific notation is used for large numbers. The
    second line shows the default behavior of `fixed`, which is to give the decimal
    number to 6 decimal places. This is changed in the code by calling the `precision`
    method to give 9 decimal places (the same effect can be achieved by inserting
    the `setprecision` manipulator in the `<iomanip>` library in the stream). Finally,
    the format is switched over to the scientific format with 9 decimal places to
    the mantissa from calling the `precision` method. The default is that the exponent
    is identified by the lowercase `e`. If you prefer, you can make this uppercase
    using the `uppercase` manipulator (and lowercase with `nouppercase`). Notice that
    the way that fractional parts are stored means that in fixed formats with 9 decimal
    places we see that the ninth digit is `8` rather than `1` as expected.
  prefs: []
  type: TYPE_NORMAL
- en: You can also specify whether a `+` symbol is shown for a positive number; the
    `showpos` manipulator will show the symbol, but the default `noshowpos` manipulator
    will not show the symbol. The `showpoint` manipulator will ensure that the decimal
    point is shown even if the floating-point number is a whole number. The default
    is `noshowpoint`, which means that, if there is no fractional part, no decimal
    point is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `setw` manipulator (defined in the `<iomanip>` header) can be used with
    both integer and floating point numbers. In effect, this manipulator defines the
    minimum width of the space that the next (and only the next) item placed in the
    stream will occupy when printed on the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'To illustrate the effect of the `setw` manipulator, this code calls `setfill`
    manipulator, which indicates that instead of spaces a hash symbol (`#`) should
    be printed. The rest of the code says that the number should be printed using
    the fixed format (to 6 decimal places by default) in a space 15 characters wide.
    The result is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'If the number is negative (or `showpos` is used), then by default the sign
    will be with the number; if the `internal` manipulator (defined in `<ios>`) is
    used, then the sign will be left-justified in the space set for the number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the `+` sign to the right of the spaces is indicated by the pound
    symbol.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `setw` manipulator is typically used to allow you to output tables of data
    in formatted columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This fills a `vector` of pairs with a string and a number. The `vector` is
    initialized with the string values and a zero, then the floating-point number
    is altered in the `for` loop (the actual calculation is irrelevant here; the point
    is to create some numbers with multiple decimal places). The data is printed out
    in two columns with the numbers printed with 6 decimal places. This means that,
    including the leading zero and decimal point, each number will take up 8 spaces.
    The text column is specified as being 6 characters wide and the number column
    is specified as 10 characters wide. By default, when you specify a column width,
    the output will be right justified, meaning that each number is preceded by two
    spaces and the text is padded according to the length of the string. The output
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want the items in a column to be left justified, then you can use the
    `left` manipulator. This will affect all columns until the `right` manipulator
    is used to change the justification to right:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The output from this will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want different justification for the two columns, then you need to set
    the justification before printing a value. For example, to left justify the text
    and right justify the numbers, use this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Outputting integers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Integers can also be printed in columns using the `setw` and `setfill` methods.
    You can insert manipulators to print integers in base 8 (`oct`), base 10 (`dec`),
    and base 16 (`hex`). (You can also use the `setbase` manipulator and pass the
    base you want to use, but the only values allowed are 8, 10, and 16.) The number
    can be printed with the base indicated (prefixed with `0` for octal or `0x` for
    hex) or without using the `showbase` and `noshowbase` manipulators. If you use
    `hex`, then the digits above `9` are the letters `a` to `f`, and by default these
    are lowercase. If you prefer these to be uppercase, then you can use the `uppercase`
    manipulator (and lowercase with `nouppercase`).
  prefs: []
  type: TYPE_NORMAL
- en: Outputting time and money
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `put_time` function in `<iomanip>` is passed a `tm` structure initialized
    with a time and date and a format string. The function returns an instance of
    the `_Timeobj` class. As the name suggests, you are not really expected to create
    variables of this class; instead, the function should be used to insert a time/date
    with a specific format into a stream. There is an insertion operator that will
    print a `_Timeobj` object. The function is used like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The output from this is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The function will use the locale in the stream, so if you imbue a locale into
    the stream and then call `put_time`, the time/date will be formatted using the
    format string and the time/date localization rules for the locale. The format
    string uses format tokens for `strftime`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, the `put_money` function returns a `_Monobj` object. Again, this
    is simply a container for the parameters that you pass to this function and you
    are not expected to use instances of this class. Instead, you are expected to
    insert this function into an output stream. The actual work occurs in the insertion
    operator that obtains the money facet on the current locale, which uses this to
    format the number to the appropriate number of decimal places and determine the
    decimal point character; if a thousands separator is used, what character to use,
    before it is inserted it in the appropriate place.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding code is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: You provide the number in either a `double` or a string as Euro cents or cents
    and the `put_money` function formats the number in Euros or dollars using the
    appropriate decimal point (`,` for German, `.` for American) and the appropriate
    thousands separator (`.` for German, `,` for American). Inserting the `showbase`
    manipulator into the output stream means that the `put_money` function will show
    the currency symbol, otherwise just the formatted number will be shown. The second
    parameter to the `put_money` function specifies whether the currency character
    (`false`) or the international symbol (`true`) is used.
  prefs: []
  type: TYPE_NORMAL
- en: Converting numbers to strings using streams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Stream buffer classes are responsible for obtaining characters and writing characters
    from the appropriate source (file, console, and so on) and are derived from the
    abstract class `basic_streambuf` from `<streambuf>`. This base class defines two
    virtual methods, `overflow` and `underflow,` which are overridden by the derived
    classes to write and read characters (respectively) to and from the device associated
    with the derived class. The stream buffer class does the basic action of getting
    or putting items into a stream, and since the buffer handles characters, the class
    is templated with parameters for the character type and character traits.
  prefs: []
  type: TYPE_NORMAL
- en: As the name suggests, if you use a `basic_stringbuf` the stream buffer will
    be a string, so the source for read characters and the destination for written
    characters is that string. If you use this class to provide the buffer for a stream
    object, it means that you can use the insertion or extraction operators written
    for streams to write or read formatted data into or out of a string. The `basic_stringbuf`
    buffer is extendable, so as you insert items in the stream, the buffer will extend
    appropriately. There are `typedef`, where the buffer is a `string` (`stringbuf`)
    or a `wstring` (`wstringbuf`).
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, imagine you have a class that you have defined and you have also
    defined an insertion operator so that you can use this with the `cout` object
    to print the value to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Using this with the `cout` object is simple--consider the following piece of
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use the `stringbuf` to direct the formatted output to a string rather
    than the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Since the stream object handles the formatting it means that you can insert
    any data type for which there is an insertion operator, and you can use any of
    the `ostream` formatting methods and any of the manipulators. The formatted output
    from all of these methods and manipulators will be inserted into the string object
    in the buffer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another option is to use the `basic_ostringstream` class in `<sstream>`. This
    class is templated on the character type of the strings used as the buffer (so
    the `string` version is `ostringstream`). It is derived from the `ostream` class,
    so you can use instances wherever you would use an `ostream` object. The formatted
    results can be accessed through the `str` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: This code obtains the value of `42` in hexadecimal (`2a`); this is achieved
    by inserting the `hex` manipulator in the stream and then inserting the integer.
    The formatted string is obtained by calling the `str` method.
  prefs: []
  type: TYPE_NORMAL
- en: Reading numbers from strings using streams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `cin` object, an instance of the `istream` class (in the `<istream>` library),
    can input characters from the console and convert them to the numeric form you
    specify. The `ifstream` class (in the `<ifstream>` library) will also allow you
    to input characters from a file and convert them to numeric form. As with outputting
    streams, you can use the stream classes with a string buffer so that you can convert
    from a string object to a numeric value.
  prefs: []
  type: TYPE_NORMAL
- en: The `basic_istringstream` class (in the `<sstream>` library) is derived from
    the `basic_istream` class, so you can create stream objects and extract items
    (numbers and strings) from these objects. The class provides this stream interface
    on a string object (the `typedef`s keyword `istringstream` is based on a `string`
    and `wistringstream` is based on a `wstring`). When you construct objects of this
    class you initialize the object with a `string` containing a number and then you
    use the `>>` operator to extract objects for the fundamental built-in types, just
    as you would extract those items from the console using `cin`.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is important to reiterate that the extraction operators treat whitespaces
    as the separators between items in a stream, and hence they will ignore all leading
    whitespaces, read the non-whitespaces characters up to the next whitespaces and
    attempt to convert this substring into the appropriate type as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'This will initialize the `d` variable with the value of `-1e-6`. As with `cin,`
    you have to know the format of the item in the stream; so if, instead of extracting
    a `double` from the string in the preceding example, you try to extract an integer,
    the object will stop extracting characters when it comes to the decimal point.
    If some of the string is not converted, you can extract the rest into a string
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'This will print the following at the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'If you have more than one number in the string you can extract these with several
    calls to the `>>` operator. The stream also supports some manipulators. For example,
    if the number in the string is in `hex` format you can inform the stream that
    this is the case using the `hex` manipulator as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'This says that the number in the string is in hexadecimal format and the variable
    `i` will be initialized with a value of 255\. If the string contains non-numeric
    values, then the stream object will still try to convert the string to the appropriate
    format. In the following snippet you can test if such an extraction fails by calling
    the `fail` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'If you know that the string contains text, you can extract it into string objects,
    but bear in mind that whitespace characters are treated as delimiters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, there are four words before the number, so the code reads a `string`
    four times. If you don''t know where in the string the number is but you know
    there is a number in the string, you can move the internal buffer pointer until
    it points to a digit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The `peek` method returns the character at the current position, but does not
    move the buffer pointer. This code checks to see if this character is a digit,
    and if not, the internal buffer pointer is moved by calling the `get` method.
    (This code tests the `eof` method to ensure that there is no attempt to read a
    character after the end of the buffer.) If you know where the number starts then
    you can call the `seekg` method to move the internal buffer pointer to a specified
    position.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `<istream>` library has a manipulator called `ws` that removes whitespace
    from a stream. Recall earlier that we said that there is no function to remove
    whitespace from a string. This is true because the `ws` manipulator removes whitespace
    from a *stream* and not from a *string*, but since you can use a string as the
    buffer for a stream it means that you can use this function to remove white space
    from a string indirectly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The `ws` function essentially iterates through the items in the input stream
    and returns when a character is not whitespace. If the stream is a file or the
    console stream then the `ws` function will read in the characters from those streams;
    in this case, the buffer is provided by an already-allocated string and so it
    skips over the whitespaces at the beginning of the string. Note that stream classes
    treat subsequent whitespaces as being separators between values in the stream,
    so in this example the stream will read in characters from the buffer until there
    is a whitespace, and will essentially *left-**and right-trim* the string. However,
    this is not necessarily what you want. If you have a string with several words
    padded by whitespace, this code will only provide the first word.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `get_money` and `get_time` manipulators in the `<iomanip>` library allow
    you to extract money and time from strings using the money and time facets for
    a locale:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, the stream is first initialized with a date in the French
    format (day/month/year) and the date is extracted with `get_time` using the locale''s
    standard date representation. The date is parsed into a `tm` structure, which
    is then printed out in standard date representation for the American locale using
    `put_time`. The results is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Using regular expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Regular expressions are patterns of text that can be used by a regular expression
    parser to search a string for text that matches the pattern, and if required,
    replace the matched items with other text.
  prefs: []
  type: TYPE_NORMAL
- en: Defining regular expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **regular expression** (**regex**) is made up of characters that define a
    pattern. The expression contains special symbols that are meaningful to the parser,
    and if you want to use those symbols in the search pattern in the expression then
    you can escape them with a backslash (`\`). Your code will typically pass the
    expression as a `string` object to an instance of the `regex` class as a constructor
    parameter. This object is then passed to functions in `<regex>` that will use
    the expression to parse text for sequences that match the pattern.
  prefs: []
  type: TYPE_NORMAL
- en: The following table summarizes *some* of the patterns that you can match with
    the `regex` class.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Pattern** | **Explanation** | **Example** |'
  prefs: []
  type: TYPE_TB
- en: '| literals | Matches the exact characters | `li` matches `flip` `lip` `plier`
    |'
  prefs: []
  type: TYPE_TB
- en: '| [group] | Matches a single character in a group | `[at]` matches `cat`, `cat`,
    `top`, `pear` |'
  prefs: []
  type: TYPE_TB
- en: '| [^group] | Matches a single character not in the group | `[^at]` matches
    **c**at, t**o**p, to**p**, **p**ear, p**e**ar, pea**r** |'
  prefs: []
  type: TYPE_TB
- en: '| [first-last] | Matches any character in the range `first` to `last` | `[0-9]`
    matches digits **1**02, 1**0**2, 10**2** |'
  prefs: []
  type: TYPE_TB
- en: '| {n} | The element is matched exactly n times | **91{2}** matches **911**
    |'
  prefs: []
  type: TYPE_TB
- en: '| {n,} | The element is matched n or more times | `wel{1,}` matches `well`
    and **wel**come |'
  prefs: []
  type: TYPE_TB
- en: '| {n,m} | The element is matched between n and m times | `9{2,4}` matches `99`,
    `999`, `9999`, `9999`9 but not 9 |'
  prefs: []
  type: TYPE_TB
- en: '| . | Wildcard, any character except `n` | `a.e` matches `ate` and `are` |'
  prefs: []
  type: TYPE_TB
- en: '| * | The element is matched zero or more times | `d*.d` matches `.1`, `0.1`,
    `10.1` but not 10 |'
  prefs: []
  type: TYPE_TB
- en: '| + | The element is matched one or more times | `d*.d` matches `0.1`, `10.1`
    but not 10 or .1 |'
  prefs: []
  type: TYPE_TB
- en: '| ? | The element is matched zero or one time | `tr?ap` matches `trap` and
    `tap` |'
  prefs: []
  type: TYPE_TB
- en: '| &#124; | Matches any one of the elements separated by the &#124; | `th(e&#124;is&#124;at)`
    matches `the`, `this`, `that` |'
  prefs: []
  type: TYPE_TB
- en: '| [[:class:]] | Matches the character class | `[[:upper:]]` matches uppercase
    characters: `I` am `R`ichard |'
  prefs: []
  type: TYPE_TB
- en: '| n | Matches a newline |  |'
  prefs: []
  type: TYPE_TB
- en: '| s | Matches any single whitespace |  |'
  prefs: []
  type: TYPE_TB
- en: '| d | Matches any single digit | `d` is `[0-9]` |'
  prefs: []
  type: TYPE_TB
- en: '| w | Matches a character that can be in a word (upper case and lower case
    characters) |  |'
  prefs: []
  type: TYPE_TB
- en: '| b | Matches at a boundary between alphanumeric characters and non-alphanumeric
    characters | `d{2}b` matches 9`99` and 99`99 bd{2}` matches `99`9 and `99`99 |'
  prefs: []
  type: TYPE_TB
- en: '| $ | End of the line | `s$` matches a single white space at the end of a line
    |'
  prefs: []
  type: TYPE_TB
- en: '| ^ | Start of line | `^d` matches if a line starts with a digit |'
  prefs: []
  type: TYPE_TB
- en: You can use regular expressions to define a pattern to be matched--the Visual
    C++ editor allows you to do this in the search dialog (which is a good test bed
    to develop your expressions).
  prefs: []
  type: TYPE_NORMAL
- en: It is much easier to define a pattern to match rather than a pattern *not* to
    match. For example, the expression `w+b<w+>` will match the string `"vector<int>"`,
    because this has one or more word characters followed by a non-word character
    (`<`), followed by one or more word characters followed by `>`. This pattern will
    not match the string `"#include <regex>"` because there is a space after the `include`
    and the `b` indicates that there is a boundary between alphanumeric characters
    and non-alphanumeric characters.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `th(e|is|at)` example in the table shows that you can use parentheses to
    group patterns when you want to provide alternatives. However, parentheses have
    another use--they allow you to capture groups. So, if you want to perform a replace
    action, you can search for a pattern as a group and then refer to that group as
    a named subgroup later (for example, search for `(Joe)` so that you can replace
    `Joe` with `Tom`). You can also refer to a sub-expression specified by parentheses
    in the expression (called back references):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'This expression says: *search for words with one or more characters in the
    ranges a to z and A to Z; the word is called 1 so find where it appears twice
    with a space between them*.'
  prefs: []
  type: TYPE_NORMAL
- en: Standard Library classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To perform matching or replacement you have to create a regular expression
    object. This is an object of the class `basic_regex` that has template parameters
    for the character type and a regular expression traits class. There are two `typedef`s
    for this class: `regex` for `char` and `wregex` for wide chars, which have traits
    described by the `regex_traits` and `wregex_traits` classes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The traits class determines how the regex class parses the expression. For
    example, recall from previous text that you can use `w` for a word, `d` for a
    digit, and `s` for whitespace. The `[[::]]` syntax allows you to use a more descriptive
    name for the character class: `alnum`, `digit`, `lower`, and so on. And since
    these are text sequences that depend upon a character set, the traits class will
    have the appropriate code to test whether the expression uses a supported character
    class.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The appropriate regex class will parse the expression to enable functions in
    the `<regex>` library to use the expression to identify patterns in some text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'This searches for repeated words using a back reference. Note that the regular
    expression uses `1` for the back reference, but in a string the backslash has
    to be escaped (`\`). If you use character classes such as `s` and `d` then you
    will need to do a lot of escaping. Instead, you can use raw strings (`R"()"`),
    but bear in mind that the first set of parentheses inside the quote marks is part
    of the syntax for raw strings and does not form a regex group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: It is entirely up to you as to which is the more readable; both introduce extra
    characters within the double quotes, which has the potential to confuse a quick
    glance-over what the regular expression matches.
  prefs: []
  type: TYPE_NORMAL
- en: Bear in mind that the regular expression is essentially a program in itself,
    so the `regex` parser will determine whether that expression is valid, and if
    it isn't the object, the constructor, will throw an exception of type `regex_error`.
    Exception handling is explained in the next chapter, but it is important to point
    out that if the exception is not caught it will result in the application aborting
    at runtime. The exception's `what` method will return a basic description of the
    error, and the `code` method will return one of the constants in the `error_type`
    enumeration in the `regex_constants` namespace. There is no indication of where
    in the expression the error occurs. You should thoroughly test your expression
    in an external tool (for example Visual C++ search).
  prefs: []
  type: TYPE_NORMAL
- en: 'The constructor can be called with a string (C or C++) or a pair of iterators
    to a range of characters in a string (or other container), or you can pass an
    initialization list where each item in the list is a character. There are various
    flavors of the language of regex; the default for the `basic_regex` class is **ECMAScript**.
    If you want a different language (basic POSIX, extended POSIX, awk, grep, or egrep),
    you can pass one of the constants defined in the `syntax_option_type` enumeration
    in the `regex_constants` namespace (copies are also available as constants defined
    in the `basic_regex` class) as a constructor parameter. You can only specify one
    language flavor, but you can combine this with some of the other `syntax_option_type`
    constants: `icase` specifies case insensitivity, `collate` uses the locale in
    matches, `nosubs` means you do not want to capture groups, and `optimize` optimizes
    matching.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The class uses the method `getloc` to obtain the locale used by the parser
    and `imbue` to reset the locale. If you `imbue` a locale, then you will not be
    able to use the `regex` object to do any matching until you reset it with the
    `assign` method. This means there are two ways to use a `regex` object. If you
    want to use the current locale then pass the regular expression to the constructor:
    if you want to use a different locale create an empty `regex` object with the
    default constructor, then call `imbue` with the locale and pass the regular expression
    using the `assign` method. Once a regular expression has been parsed you can call
    the `mark_count` method to get the number of capture groups in the expression
    (assuming you did not use `nosubs`).'
  prefs: []
  type: TYPE_NORMAL
- en: Matching expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once you have constructed a `regex` object you can pass it to the methods in
    the `<regex>` library to search for the pattern in a string. The `regex_match`
    function is passed in a string (C or C++) or iterators to a range of characters
    in a container and a constructed `regex` object. In its simplest form, the function
    will return `true` only if there is an exact match, that is, the expression exactly
    matches the search string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code, the search expression is for a single character in the
    range given (`a` or `t`), so the first two calls to `regex_match` return `true`
    because the searched string is one character. The last call returns `false` because
    the match is not the same as the searched string. If you remove the `[]` in the
    regular expression, then just the third call returns `true` because you are looking
    for the exact string `at`. If the regular expression is `[at]+` so that you are
    looking for one or more of the characters `a` and `t`, then all three calls return
    `true`. You can alter how the match is determined by passing one or more of the
    constants in the `match_flag_type` enumeration.
  prefs: []
  type: TYPE_NORMAL
- en: If you pass a reference to a `match_results` object to this function, then after
    the search the object will contain information about the position and the string
    that matches. The `match_results` object is a container of `sub_match` objects.
    If the function succeeds it means that the entire search string matches the expression,
    and in this case the first `sub_match` item returned will be the entire search
    string. If the expression has subgroups (patterns identified with parentheses)
    then these sub groups will be additional `sub_match` objects in the `match_results`
    object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the expression is the literal `trump` followed by any number of characters.
    The entire string matches this expression and there are two sub groups: the literal
    string `trump` and whatever is left over after the `trump` is removed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Both the `match_results` class and the `sub_match` class are templated on the
    type of iterator that is used to indicate the matched item. There are `typedef`
    call''s `cmatch` and `wcmatch` where the template parameter is `const char*` and
    `const wchar_t*`, respectively, and `smatch` and `wsmatch` where the parameter
    is the iterator used in `string` and `wstring` objects, respectively (similarly,
    there are submatch classes: `csub_match`, `wcsub_match`, `ssub_match`, and `wssub_match`).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `regex_match` function can be quite restrictive because it looks for an
    exact match between the pattern and the searched string. The `regex_search` function
    is more flexible because it returns `true` if there is a substring within the
    search string that matches the expression. Note that even if there are multiple
    matches in the search string, the `regex_search` function will only find the first.
    If you want to parse through the string you will have to call the function multiple
    times until it indicates that there are no more matches. This is where the overload
    with iterator access to the search string becomes useful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Here, the expression will match a 2 digit number (`d{2}`) that is surrounded
    by whitespace (the two `b` patterns mean a boundary before and after). The loop
    starts with an iterator pointing to the start of the string, and when a match
    is found this iterator is incremented to that position and then incremented by
    the length of the match. The `regex_iterator` object, explained further, wraps
    this behavior.
  prefs: []
  type: TYPE_NORMAL
- en: The `match_results` class gives iterator access to the contained `sub_match`
    objects so you can use ranged `for`. Initially, it appears that the container
    works in an odd way because it knows the position in the searched string of the
    `sub_match` object (through the `position` method, which takes the index of the
    sub match object), but the `sub_match` object appears to only know the string
    it refers to. However, on closer inspection of the `sub_match` class, it shows
    that it derives from `pair`, where both parameters are string iterators. This
    means that a `sub_match` object has iterators specifying the range in the original
    string of the sub string. The `match_result` object knows the start of the original
    string and can use the `sub_match.first` iterator to determine the character position
    of the start of the substring.
  prefs: []
  type: TYPE_NORMAL
- en: The `match_result` object has a `[]` operator (and the `str` method) that returns
    the substring of the specified group; this will be a string constructed using
    the iterators to the range of characters in the original string. The `prefix`
    method returns the string that precedes the match and the `suffix` method returns
    the string that follows the match. So, in the previous code, the first match will
    be `10`, the prefix will be `1 4`, and the suffix will be `42 100 999`. In contrast,
    if you access the `sub_match` object itself, it only knows its length and the
    string, which is obtained by calling the `str` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `match_result` object can also return the results through the `format`
    method. This takes a format string where the matched groups are identified through
    numbered placeholders identified by the `$` symbol (`$1`, `$2`, and so on). The
    output can either be to a stream or returned from the method as a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: With `regex_match` or `regex_search,` you can use parentheses to identify subgroups.
    If the pattern matches then you can obtain these subgroups using an appropriate
    `match_results` object passed by reference to the function. As shown earlier,
    the `match_results` object is a container for `sub_match` objects. Sub matches
    can be compared with the `<`, `!=`, `==`, `<=`, `>`, and `>=` operators, which
    compare items that the iterators point to (that is, the sub strings). Further,
    `sub_match` objects can be inserted into a stream.
  prefs: []
  type: TYPE_NORMAL
- en: Using iterators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The library also provides an iterator class for regular expressions, which
    provides a different way to parse strings. Since the class will involve comparisons
    of strings it is templated with the element type and traits. The class will need
    to iterate through strings, so the first template parameter is the string iterator
    type and the element and traits types can be deduced from that. The `regex_iterator`
    class is a forward iterator so it has a `++` operator and it provides a `*` operator
    that gives access to a `match_result` object. In the previous code, you saw that
    a `match_result` object is passed to the `regex_match` and `regex_search` functions,
    which use it to contain their results. This raises the question of what code fills
    the `match_result` object accessed through the `regex_iterator`. The answer lies
    in the iterator''s `++` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: In this code, a string is searched for words where the second and third letters
    are `at`. The `b` says that the pattern must be at the start of a word (the `.`
    means that the word can start with any letter). There is a capture group around
    these three characters and a second capture group for one or more characters other
    than spaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'The iterator object `next` is constructed with iterators to the string to search
    and the `regex` object. The `++` operator essentially calls the `regex_search`
    function while maintaining the position of the place to perform the next search.
    If the search fails to find the pattern then the operator returns the **end of
    sequence** iterator, which is the iterator that is created by the default constructor
    (the `end` object in this code). This code prints out the full match because we
    use the default parameter for the `str` method (`0`). If you want the actual substring
    matched, use `str(1)` and the result will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Since the `*` (and the `->`) operator gives access to a `match_result` object,
    you can also access the `prefix` method to get the string that precedes the match
    and the `suffix` method will return the string that follows the match.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `regex_iterator` class allows you to iterate over the matched substrings,
    whereas the `regex_token_iterator` goes one step further in that it also gives
    you access to all submatches. In use, this class is the same as `regex_iterator,`
    except in construction. The `regex_token_iterator` constructor has a parameter
    to indicate which submatch you wish to access through the `*` operator. A value
    of `-1` means you want the prefix, a value of `0` means you want the whole match,
    and a value of `1` or above means you want the numbered sub match. If you wish,
    you can pass an `int vector` or C array with the submatch types that you want:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Replacing strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `regex_replace` method is similar to the other methods in that it takes
    a string (a C string or C++ `string` object, or iterators to a range of characters),
    a `regex` object, and optional flags. In addition, the function has a format string
    and returns a `string`. The format string is essentially passed to the `format`
    method of each `results_match` object from the result of the matches to the regular
    expression. This formatted string is then used as the replacement for the corresponding
    matched substring. If there are no matches, then a copy of the searched string
    is returned.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we say that the entire matched string (which should be
    `list<` followed by some text followed by `>` and a space) should be replaced
    with `vector,` followed by the second sub match (`<` followed by some text followed
    by `>` and a space). The result is that `list<int>` will be replaced with `vector<int>`.
  prefs: []
  type: TYPE_NORMAL
- en: Using strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The example will read in emails as a text file and processed. An email in Internet
    message format will be in two parts: the header and message body. This is simple
    processing, so no attempt is carried out to process MIME email body formatting
    (although this code can be used as a starting point for that). The email body
    will start after the first blank line, and Internet standards say that lines should
    be no longer than 78 characters. If they are longer they must not be longer than
    998 characters. This means that newlines (carriage return, linefeed pairs) are
    used to maintain this rule, and that an end of paragraph is indicated by a blank
    line.'
  prefs: []
  type: TYPE_NORMAL
- en: Headers are more complicated. In their simplest form, a header is on a single
    line and is in the form `name:value`. The header name is separated from the header
    value by a colon. A header may be split over more than one line using a format
    called folded white space, where the newline splitting a header is placed before
    whitespace (space, tab, and so on). This means that a line that starts with whitespace
    is the continuation of the header on the previous line. Headers often contain
    `name=value` pairs separated by semicolons, so it is useful to be able separate
    these subitems. Sometimes these subitems do not have a value, that is, there will
    be a subitem terminated by a semicolon.
  prefs: []
  type: TYPE_NORMAL
- en: The example will take an email as a series of strings and using these rules
    will create an object with a collection of headers and a string containing the
    body.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a folder for the project and create a C++ file called `email_parser.cpp`.
    Since this application will read files and process strings, add includes for the
    appropriate libraries and add code to take the name of a file from the command-line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'A header will have a name and a body. The body could be a single string, or
    one or more subitems. Create a class to represent the body of a header, and for
    the time being, treat this as a single line. Add the following class above the
    `usage` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'This simply wraps the class around a `string`; later on we will add code to
    separate out the subitems in the `body` data member. Now create a class to represent
    the email. Add the following code after the `header_body` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: The `headers` data member holds the headers as name/value pairs. The items are
    stored in a `vector` rather than a `map` because as an email is passed from mail
    server to mail server, headers may be added by each server that already exist
    in the email, so headers are duplicated. We could use a `multimap`, but then we
    will lose the ordering of the headers, since a `multimap` will store the items
    in an order that aids searching for items.
  prefs: []
  type: TYPE_NORMAL
- en: A `vector` keeps the items in the order that they are inserted in the container,
    and since we will parse the e-mail serially, this means that the `headers` data
    member will have the header items in the same order as in the e-mail. Add an appropriate
    include so that you can use the `vector` class.
  prefs: []
  type: TYPE_NORMAL
- en: There are accessors for the body and the headers as a single string. In addition,
    there are accessors that return iterators from the `headers` data member, so that
    external code can iterate through the `headers` data member (a complete implementation
    of this class would have accessors that allow you to search for a header by name,
    but for the purpose of this example, only iteration is permitted).
  prefs: []
  type: TYPE_NORMAL
- en: The class supports two-stage construction, where most of the work is carried
    out by passing an input stream to the `parse` method. The `parse` method reads
    in the email as a series of lines in a `vector` object and it calls a private
    function, `process_headers`, to interpret these lines as headers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `get_headers` method is simple: it just iterates through the headers and
    puts one header on each line in the format `name: value`. Add the inline function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, you need to read in the email from a file and extract the body and the
    headers. The `main` function already has the code to open a file, so create an
    `email` object and pass the `ifstream` object for the file to the `parse` method.
    Now print out the parsed email using the accessors. Add the following to the end
    of the `main` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'After the `email` class declaration, add the definition for the `parse` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is simple: it repeatedly calls the `getline` function in the `<string>`
    library to read a `string` until a newline is detected. In the first half of the
    method, the strings are stored in a `vector` and then passed to the `process_headers`
    method. If the string read in is empty, it means a blank line has been read--in
    which case, all of the headers have been read. In the second half of the method,
    the body of the e-mail is read in. The `getline` function will have stripped the
    newlines used to format the email to 78-character line lengths, so the loop merely
    appends the lines as one string. If a blank line is read in, it indicates the
    end of a paragraph, and so a newline is added to the body string.'
  prefs: []
  type: TYPE_NORMAL
- en: 'After the `parse` method, add the `process_headers` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: This code iterates through each line in the collection, and when it has a complete
    header it splits the string into the name/body pair on the colon. Within the loop,
    the first line tests to see if the first character is whitespace; if not, then
    the `header` variable is checked to see if it has a value; and if so, the name/body
    pair are stored in the class `headers` data member before clearing the `header`
    and `body` variables.
  prefs: []
  type: TYPE_NORMAL
- en: The following code acts upon the line read from the collection. This code assumes
    that this is the start of the header line, so the string is searched for the colon
    and split at this point. the name of the header is before the colon and the body
    of the header (trimmed of leading whitespace) is after the colon. Since we do
    not know if the header body will be folded onto the next line, the name/body is
    not stored; instead, the `while` loop is allowed to repeat another time so that
    the first character of the next line can be tested to see if it is whitespace,
    and if so, it is appended to the body. This action of holding the name/body pair
    until the next iteration of the `while` loop means that the last line will not
    be stored in the loop, and hence there is a test at the end of the method to see
    if the `header` variable is empty, and if not, the name/body pair is stored.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can now compile the code (remember to use the `/EHsc` switch) to test that
    there are no typos. To test the code, you should save an email from your email
    client as a file and then run the `email_parser` application with the path to
    this file. The following is one of the example email messages given in the Internet
    Message Format RFC 5322, which you can put into a text file to test the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: You can test the application with an email message to show that the parsing
    has taken into account header formatting, including folding whitespace.
  prefs: []
  type: TYPE_NORMAL
- en: Processing header subitems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next action is to process the header bodies into subitems. To do this,
    add the following highlighted declaration to the `public` section of the `header_body`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Each subitem will be a name/value pair, and since the order of a subitem may
    be important, the subitems are stored in a `vector`. Change the `main` function,
    remove the call to `get_headers`, and instead print out each header individually:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Since the `email` class implements the `begin` and `end` methods, it means that
    the ranged `for` loop will call these methods to get access to the iterators on
    the `email::headers` data member. Each iterator will give access to a `pair<string,header_body>`
    object, so in this code we first print out the header name and then access the
    subitems on the `header_body` object. If there are no subitems, there will still
    be some text for the header, but it won't be split into subitems, so we call the
    `get_body` method to get the string to print. If there are subitems then these
    are printed out. Some items will have a body and some will not. If the item has
    a body then the subitem is printed in the form `name = value`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final action is to parse the header bodies to split them into subitems.
    Below the `header_body` class, add the definition of the method to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Since subitems are separated using semicolons there is a simple test to look
    for a semicolon on the `body` string. If there is no semicolon, then an empty
    `vector` is returned.
  prefs: []
  type: TYPE_NORMAL
- en: Now the code must repeatedly parse through the string, extracting subitems.
    There are several cases that need to be addressed. Most subitems will be in the
    form `name=value;,` so this subitem must be extracted and split at the equals
    character and the semicolon discarded.
  prefs: []
  type: TYPE_NORMAL
- en: Some subitems do not have a value and are in the form `name;` in which case,
    the semicolon is discarded and an item is stored with an empty string for the
    subitem value. Finally, the last item in a header may not be terminated with a
    semicolon, so this must be taken into account.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following `while` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'As the name suggests, the `start` variable is the start index of a subitem
    and `end` is the end index of a subitem. The first action is to ignore any whitespace,
    so within the `while` loop add:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: This simply increments the `start` index while it refers to a whitespace character
    and as long as it has not reached the end of the string. If the end of the string
    is reached, it means there are no more characters and so the loop is finished.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, add the following to search for the `=` and `;` characters and handle
    one of the search situations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: The `find` method will return the `npos` value if the searched item cannot be
    found. The first call looks for the `=` character and the second call looks for
    a semicolon. If no `=` can be found then the item has no value, just a name. If
    the semicolon cannot be found, then it means that the `name` is the entire string
    from the `start` index until the end of the string. If there is a semicolon, then
    the `name` is from the `start` index until the index indicated by `end` (and hence
    the number of characters to copy is `end-start`). If an `=` character is found
    then the string needs to be split at this point, and that code will be shown in
    a moment. Once the `name` and `value` variables have been given values, these
    are inserted into the `subitems` data member and the `start` index is moved to
    the character after the `end` index. If the `end` index is `npos` then the value
    of the `start` index will be invalid, but this does not matter because the `while`
    loop will test the value of the `end` index and will break the loop if the index
    is `npos`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you need to add the code for when there is an `=` character in the
    subitem. Add the following highlighted text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: The first line tests to see if the search for a semicolon failed. In this case,
    the name is from the `start` index until the character before the equals character,
    and the value is the text following the equals sign until the end of the string.
  prefs: []
  type: TYPE_NORMAL
- en: If there are valid indices for the equals and semicolon characters then there
    is one more situation to check for. It is possible that the location of the equals
    character could be after the semicolon, in which case it means that this subitem
    does not have a value, and the equals character will be for a subsequent subitem.
  prefs: []
  type: TYPE_NORMAL
- en: At this point you can compile the code and test it with a file containing an
    email. The output from the program should be the email split into headers and
    a body, and each header split into subitems, which may be a simple string or a
    `name=value` pair.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you have seen the various C++ standard library classes that
    support strings. You have seen how to read strings from streams, how to write
    strings to streams, how to convert between numbers and strings, and how to manipulate
    strings using regular expressions. When you write code, you will inevitably spend
    time running your code to check if it works according to your specifications.
    This will involve providing code that checks the results of your algorithms, code
    that logs intermediate code to a debugging device, and, of course, running the
    code under a debugger. The next chapter is all about debugging code!
  prefs: []
  type: TYPE_NORMAL
