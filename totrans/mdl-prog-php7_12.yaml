- en: Chapter 12. Integrating and Distributing Modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout a few of the previous chapters, we built a simple web shop application
    in a modular manner. Each of the modules play a special role in handling individual
    bits and pieces, which add to the overall application. The application itself,
    though written in modular, was kept in a Git single version control repository.
    It would be a far cleaner separation if each of the modules was provided in its
    own repository. This way, we will be able to keep the different module developments
    as completely different projects while still being able to use them together.
    As we move forward, we will see how we can achieve this via GIT and Composer in
    two different manners.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following tools and services:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Git
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding GitHub
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding Composer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding Packagist
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding Git
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Originally started by Linus Torvalds, Git version control is currently one of
    the most popular version control systems. Overall speed and efficiency with large
    projects, alongside a great branching system, has made it popular among developers.
  prefs: []
  type: TYPE_NORMAL
- en: Learning about Git version control itself is out of the scope of this book,
    for which recommended reading is the *Pro Git* book.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *Pro Git* book, written by Scott Chacon and Ben Straub, and published by
    Apress, is available for free at [https://git-scm.com/book/en/v2](https://git-scm.com/book/en/v2).
  prefs: []
  type: TYPE_NORMAL
- en: One neat feature of Git, which we are interested in as part of this chapter,
    is its submodules. They enable us to slice larger modular projects, such as our
    web shop app, into a series of smaller submodules, whereas each submodule is a
    Git repository on its own.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding GitHub
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Within three years of Git's appearance, GitHub emerged. GitHub is basically
    a web service built on top of the Git version control system. It enables developers
    to easily post their code online, where others can simply clone their repository
    and use their code. Creating an account on GitHub is free and can be done by following
    instructions on their official homepage ([https://github.com](https://github.com)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Currently, our application is structured as per the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding GitHub](graphics/B05460_12_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'What we want to do is to split it into six different Git repositories, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`core`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`catalog`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`customer`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`payment`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sales`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`shipment`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `core` repository is to contain everything except the content of the `src/Foggyline`
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming we created an empty `core` repository on GitHub, and our local *all-in-one*
    app is currently held in the `shop` directory, we initialize the following commands
    on our computer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: At this point, we merely pushed the core application part of our all-in-one
    web shop app into the `core` repository on GitHub. The `src/Foggyline/` directory
    does not contain any modules in it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s go back to GitHub and create an appropriate empty repository for
    each of the five modules, that is, `catalog`, `customer`, `payment`, `sales`,
    and `shipment`. We can now execute a set of console commands for each of the modules,
    as shown in the following `CatalogBundle` example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Once all of the five modules are pushed to a repository, we can finally treat
    them as submodules, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If we were to run the `ls-al` command within the `core` repository directory
    now, we should be able to see a `.gitmodules` file in there with the following
    content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The `.gitmodules` file, basically, contains the list of all of the submodules
    added to our core project, that is, core application. We should commit and push
    this file to the `core` repository now. Assuming that the `.gitmodules` file is
    pushed to the `core` repository, we can easily delete all directories created
    so far and initiate the project with one simple command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `--recursive` argument to the `git clone` command automatically initializes
    and updates each submodule in the repository based on the `.gitmodules` file.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Composer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Composer is a dependency management tool for PHP. By default, it does not install
    anything global but rather on a per-project basis. We can use it to redistribute
    our project in order to define which libraries and packages it needs for it to
    be successfully executed. Using Composer is quite simple. All it creating is to
    create a `composer.json` file in the root directory of our project with similar
    content, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: If we were to create the preceding `composer.json` file in some empty directory
    and execute the `composer install` command within that directory, Composer will
    pickup the `composer.json` file and install the defined dependencies for our project.
    The actual `install` action implies on downloading the required code from a remote
    repository to our machine. In doing so, the `install` command creates the `composer.lock`
    file, which writes a list of the exact versions of dependencies installed.
  prefs: []
  type: TYPE_NORMAL
- en: We can also simply execute the command `twig/twig:~1.0` that a Composer requires,
    which does the same thing but with a different approach. It does not require us
    to write a `composer.json` file, and if one exists, it will update it.
  prefs: []
  type: TYPE_NORMAL
- en: Learning about Composer itself is out of the scope of this book, for which the
    recommended official documentation is available at [https://getcomposer.org/doc](https://getcomposer.org/doc).
  prefs: []
  type: TYPE_NORMAL
- en: Composer allows packaging and formal dependency management, making it a great
    choice to slice our all-in-one modular application into a series of Composer packages.
    These packages need a repository.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Packagist
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main repository, when it comes to Composer packages, is **Packagist** ([https://packagist.org](https://packagist.org)).
    It is a web service that we can access through our browser, open an account on
    for free, and start submitting our packages to the repository. We can also use
    it to search through already existing packages.
  prefs: []
  type: TYPE_NORMAL
- en: Packagist is generally used for free open source packages, though we can attach
    **privateGitHub** and **BitBucket** repositories to it in the same manner, the
    only difference being that the private repositories require SSH keys in order
    to work.
  prefs: []
  type: TYPE_NORMAL
- en: There are more convenient commercial installations of the Composer packager,
    such as **Toran Proxy** ([https://toranproxy.com](https://toranproxy.com)). This
    allows easier hosting of private packages, higher bandwidth for faster package
    installations, and commercial support.
  prefs: []
  type: TYPE_NORMAL
- en: Up to this point, we sliced our applications into six different Git repositories,
    one for core application and the remaining five for each module (`catalog`, `customer`,
    `payment`, `sales`, and `shipment`) individually. Now, let's take the final step
    and see how we can move away from the Git submodules to the Composer packages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming we created an account on [https://packagist.org](https://packagist.org)
    and successfully logged in, we will start by clicking on the **Submit** button,
    which should land us on a screen similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding Packagist](graphics/B05460_12_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here, we need to provide a link to our existing Git, SVN, or Mercurial (HG)
    repository. The preceding example provides a link ([https://github.com/ajzele/B05460_CatalogBundle](https://github.com/ajzele/B05460_CatalogBundle))
    to the Git repository. Before we press the **Check** button, we will need to make
    sure that our repository has a `composer.json` file defined in its root, otherwise
    an error similar to the one shown in the following screenshot will be thrown.
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding Packagist](graphics/B05460_12_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We will then create the `composer.json` file for our `CatalogBundle` with the
    following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: There are quite a lot of attributes here, all of which are fully documented
    over on the [https://getcomposer.org/doc/04-schema.md](https://getcomposer.org/doc/04-schema.md)
    page.
  prefs: []
  type: TYPE_NORMAL
- en: With the preceding `composer.json` file in place, running the `composer install`
    command on console will pull in the code under the `vendor/foggyline/catalogbundle`
    directory, making for a full path of our bundle file under `vendor/foggyline/catalogbundle/Foggyline/CatalogBundle/FoggylineCatalogBundle.php`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we add the preceding `composer.json` file to our Git repository, we can
    go back to Packagist and proceed with clicking the **Check** button, which should
    result in a screen similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding Packagist](graphics/B05460_12_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, when we click the **Submit** button, a screen similar to the following
    screenshot should appear:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding Packagist](graphics/B05460_12_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Our package is now added to Packagist, and running the following command on
    console will install it to into the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, we can just add the proper entry to the existing project''s `composer.json`
    file, as shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Now that we know how to slice out the application across several Git repositories
    and Composer packages, we need to do the same for the remaining modules within
    the `src/Foggyline/` directory, as only those modules will be registered as the
    Composer packages.
  prefs: []
  type: TYPE_NORMAL
- en: During the `sales` module development, we noticed that it depends on several
    other modules, such as `catalog` and `customer`. We can use the require attribute
    of the `composer.json` file to outline this dependency.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once all of the Git repositories for the `src/Foggyline/` modules are updated
    with the proper `composer.json` definitions, we can go back to our core application
    repository and update the `require` attribute in its `composer.json` file, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The difference between using submodules and packages might not be that obvious
    at this point. However, packages, unlike submodules, allow versioning. Though
    all of our packages are pulled in from `dev-master`, we could have easily targeted
    specific versions of packages, if any.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this chapter, we took a quick look at Git and Composer and how we
    can integrate and distribute our modules via GitHub and Packagist as their respectful
    services. Publishing packages under Packagist has been shown to be a pretty straightforward
    and easy process. All it took was a public link to the version control system
    repository and a `composer.json` file definition within the root of our project.
  prefs: []
  type: TYPE_NORMAL
- en: Writing our own applications from ground up does not necessarily mean we need
    to use the Git submodules or the Composer packages, as presented in this chapter.
    The Symfony application, on its own, is structured modularly via bundles. The
    version control system, when used on a Symfony project, is supposed to save only
    our code, which means all of the Symfony libraries and other dependencies are
    to be pulled in via Composer when the project is being set. The examples shown
    in this chapter merely show what can be accomplished if we are after writing modular
    components that are to be shared with others. As an example, if we were really
    working on a robust `catalog` module, others interested in coding their own web
    shop might find it interesting to require and use it in their project.
  prefs: []
  type: TYPE_NORMAL
- en: This book started by looking into the current state of the PHP ecosystem. We
    then touched upon design patterns and principles, as a foundation of professional
    programming. Then we moved onto writing a brief, more visual, specification for
    our web shop application. Finally, we split our application into core and several
    other smaller modules, which we then coded following the specification. Along
    the way, we familiarized ourselves with some of the most commonly used Symfony
    features. The overall application we wrote is far from being robust. It is a web
    shop in its simplest form, which leaves much to be desired on a feature side.
    However, the concepts applied showcase how easy and quick it can be to write modular
    applications in PHP.
  prefs: []
  type: TYPE_NORMAL
