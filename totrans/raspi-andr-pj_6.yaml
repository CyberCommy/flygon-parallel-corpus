- en: Chapter 6. The Vehicle Pi
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will continue to use Bluetooth on our Pi in this chapter to track the location
    and data from our car. The following sections will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Finding out the location of the car
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using your Android device as an access point
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collecting the car data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending data to the cloud
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Putting it all together
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding out the car location
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will collect the engine data from our car, but things will
    get more exciting if we can gather some for of location data as well. For this
    purpose, we will connect a USB GPS receiver to the Pi and receive our location
    through this piece of equipment. We will use one of the cheapest receivers available
    in the market, as shown in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Finding out the car location](img/image00138.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The Globalsat BU-353 GPS receiver
  prefs: []
  type: TYPE_NORMAL
- en: 'After connecting the GPS to the Pi, you can issue the `lsusb` command to see
    if it is registered correctly. The output from this command on my system is as
    follows, and here `Prolific` is the GPS adapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The next thing we need to install is a GPS daemon that receives location information
    from the adapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You might need to reboot in order to get the daemon to start. Otherwise, you
    can issue the following command to get it working immediately:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The installation script has even provided us with a tool to see the current
    GPS location and the satellites that are in range through a text-based window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The GPS receiver works best outdoors or with a clear view of the sky near a
    window.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output on my system and in my location from the `cgps` command is shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Finding out the car location](img/image00139.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The output from the cgps –s command
  prefs: []
  type: TYPE_NORMAL
- en: Here, you can see the GPS satellites that I, in particular, have in my view,
    and my latitude and longitude as well as other useful information that is available
    through the GPS system.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you get a timeout error from the `cgps` command, you need to restart the
    GPS daemon using the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If you get this timeout even though you have rebooted the Pi, then you can
    put the following commands in **crontab**, but, there is even a better place to
    put these, which will be described later on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'It is possible to get the location information programmatically from Python
    as well. We will make use of this possibility later on. But for now, the following
    Python code in a file named `getgps.py` to test the Python `gps` library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The only thing this tiny program does is to output the GPS location whenever
    there is one to report. We can call it using the `python getgps.py` command.
  prefs: []
  type: TYPE_NORMAL
- en: Collecting the car data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the purpose of collecting the car data, we will use a standard **On-board**
    **diagnostics** (**OBD**) interface found on most cars and referred to as OBD-II
    or EOBD in Europe. These are equivalent standards used to connect to the OBD port
    of the car; you can also read diagnostics data and fault codes about the car from
    this port.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In 1996, the OBD-II specification was made mandatory for all cars manufactured
    and sold in the United States. The European Union followed suit in 2001 by making
    EOBD mandatory for all gasoline (petrol) vehicles sold in the European Union,
    followed by all diesel vehicles in 2003\. In 2010, the HDOBD (heavy duty) specification
    was made mandatory for certain select commercial (non-passenger car) engines sold
    in the United States. Even China followed suit in 2008, and by then, some light
    vehicles in China were required by the Environmental Protection Administration
    Office to implement OBD.
  prefs: []
  type: TYPE_NORMAL
- en: 'On most cars, the OBD interface is found under the steering wheel. On a Toyota
    Aygo from 2008, it is found on the right-hand side under the steering wheel. Some
    car manufacturers do not have standard port connections. So, you might have to
    buy an extra OBD converter cable. The port in the car looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Collecting the car data](img/image00140.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The OBD connection in the car
  prefs: []
  type: TYPE_NORMAL
- en: 'We will connect an **ELM327**-Bluetooth sender to this OBD connection and the
    Bluetooth dongle from the previous chapter to the Pi and make the two communicate.
    The ELM327 is a programmed microcontroller produced by **ELM Electronics** to
    translate the on-board diagnostics (OBD) interface. The ELM327 command protocol
    is one of the most popular PC-to-OBD interface standards implemented. You can
    buy one of these pieces of hardware in any price range with different properties
    on Amazon. The one that I have is by **Goliton**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Collecting the car data](img/image00141.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The ELM 327-OBD Bluetooth sender
  prefs: []
  type: TYPE_NORMAL
- en: The easiest way to get data from a car is to use an app on Android that can
    translate the data for you. Search for OBD on the Play Store, and you will find
    lots of great apps that can connect to ELM327 and show you all the details of
    your car data. However, we want to have a lot more fun than this.
  prefs: []
  type: TYPE_NORMAL
- en: Getting the car data to the Pi
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To collect car data from the Pi using Python via Bluetooth, we need to install
    some tools. Run the following update command to download Bluetooth-related packages.
    Note that I am assuming that you have a **new Raspbian installation**. Same packages
    have been installed in previous chapters as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You are most probably sitting in your car and working right now. If you are
    struggling to figure out how to connect to the Internet, you can always use your
    Android device as a hotspot and connect to the Internet using the Wi-Fi dongle
    that we need for this chapter later on anyway.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting the Pi to a Wi-Fi network was covered previously, but lets remind
    ourselves about how it works.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following lines to the `/etc/wpa_supplicant/wpa_supplicant.conf` file.
    You need to have configured the hotspot to apply the WPA PSK security instead
    of PSK2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Now, reboot the Pi, and after a few minutes, you will see that it is automatically
    connected to the hotspot on the Android device in the hotspot settings window.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once again, we can use the `lsusb` command to list the connected USB devices.
    The output on my system is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The `005` device is the Bluetooth dongle that I am reusing from the previous
    section. Issue the `hcitool scan` command to see if you can reach the OBD Bluetooth
    device connected to the car:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: You can see the MAC address of the OBD device as well; write it down as it will
    be used later.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you get into problems, such as scanning or reaching the OBD, you can use
    the following commands to see the status of the connected Bluetooth dongle and
    the `bluetooth` service on the Pi:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a look at the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command is used to restart the `bluetooth` service.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we need to give the `pi` user access to the Bluetooth device. Edit the
    `/etc/group` file, find the row containing the `bluetooth` text, and add `pi`
    to the end of this row. It needs to look something similar to `bluetooth:x:113:pi`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now connect the Pi''s Bluetooth dongle to the OBD Bluetooth device using
    the `rfcomm` command. This command should be the first thing you execute before
    connecting to OBD. You can hang up before continuing using the *Ctrl*+*C* key
    combination:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Here, you should use the MAC address of your own ODB Bluetooth, which we found
    out previously using the `hcitool scan` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, issue the following Bluetooth pairing command to pair the Pi with OBD
    and use the MAC address of OBD:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The PIN is usually either `0000` or `1234`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We should even add the `dbus` connection support before we continue to the
    next command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Make the OBD device trusted by the Pi in order to skip manual pairing the next
    time using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following command will let you test the connection if you have any problems.
    Replace the MAC address with your OBD adapter''s MAC address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We will use a tool, called `pyOBD-pi`, to access the data that the OBD dongle
    makes available. Download and start the logger using the `git` command. This is
    a more developer-friendly version of a well-known library located at [https://github.com/peterh/pyobd](https://github.com/peterh/pyobd):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Do not forget to turn your ignition on. Also, don''t forget to connect via
    Bluetooth using the upcoming command. It is a good idea to put this in crontab,
    otherwise, you''ll need to use it every time you reboot the Pi:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The command will save the data traffic to the `log` directory. If you get errors
    regarding `0100 response:CAN ERROR`, then you have problems with protocol selections,
    and you simply need to edit the `obd_io.py` file and find the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, add the following lines of code just before it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In this way, we have forced the communication protocol to be chosen automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You may want to run the `init` server script on reboot. You cannot put it in
    cronbtab as the Bluetooth or GPS might not be ready when it is run. Put the commands
    at the end of `/etc/rc.local` file before the exit line, instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Using your Android device as an access point
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will send the data we have gathered so far to a location on a cloud, but
    we need to connect the Pi to the Internet before we do this. Making an Android
    device an Internet access point or a hotspot is trivial and can be done from the
    settings of a device. We can then connect the Pi to this network that Android
    provides. However, there is a major problem with this setup. First of all, we
    want to be able to leave the Pi and the phone in the car all the time. As soon
    as the car starts, we want the data to be sent automatically, and we do not want
    to carry around the Pi and a phone. However, if we leave the phone in the car
    and it is connected to the 12V power output, the device will soon run out of battery
    and shut down. Then, we'll need to power it on manually and make changes in the
    hotspot settings again. We want all these steps to be undertaken automatically.
    For this reason, we need a way to get the device powered on as soon as it is connected
    to a power source, or the power source it is connected to, such as a 12V power
    output in the car, wakes up when we start the car. The techniques I will now present
    require that you have super user privileges to your Android device, which means
    that we need to root the device.
  prefs: []
  type: TYPE_NORMAL
- en: An alternative to rooting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An alternative to rooting a device is using a USB Wi-Fi 3G modem to get Internet
    access in the car. Note that most of the 3G USB modems in the market do not provide
    you with a Wi-Fi network. They only give network access to the computer into which
    they are plugged. The one we need acts similar to a Wi-Fi hotspot when connected
    to a USB power source. You can find these at online retailers, such as Amazon
    or AliExpress. The one I personally use is shown in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![An alternative to rooting](img/image00142.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The USB Wi-Fi 3G modem
  prefs: []
  type: TYPE_NORMAL
- en: If you choose to use one of these, you may jump over the rest of this section
    and go directly to the next.
  prefs: []
  type: TYPE_NORMAL
- en: Rooting Samsung Galaxy S2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are different ways of rooting different devices. I will use one of the
    most common second hand Android devices in the market, namely, Samsung Galaxy
    S2\. If you have another phone, there are plenty of resources available on the
    Internet on how to root each device. The most popular one is located at [http://www.androidcentral.com/root](http://www.androidcentral.com/root),
    the **Android Central** website.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that rooting a device will make the guarantee invalid. This may cause damage
    to your phone and is not a secure process. Do it on your own risk. But the steps
    provided here worked for me. You should backup any files you would like to keep
    before you continue with the rest of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Samsung devices can be put into recovery mode by pressing the *volume down*,
    *power*, *home* buttons at the same time. By pressing these buttons, you will
    get Samsung's standard recovery screen with a warning sign on it. We should replace
    this recovery program with another one, as the standard recovery is only to be
    done through a computer connected via a USB and downloads a complete OS image.
    However, what we really need to do is only replace a kernel with one that gives
    us super user rights. We also want to make sure that we do this from an SD card
    attached to an Android device. That is why we need to replace Samsung's default
    recovery program. We can do this again using the recovery operation provided by
    Samsung.
  prefs: []
  type: TYPE_NORMAL
- en: When you put the device in this recovery mode, attach it to a computer through
    a USB. Next, we can download a software, named **Odin**, to upload a new recovery
    tool to the phone. It can be downloaded from quite a lot of places on the Internet
    along with different versions. The one we will use is called `ODIN3_v1.85.zip`,
    and it is located at [https://www.androidfilehost.com/?fid=9390169635556426736](https://www.androidfilehost.com/?fid=9390169635556426736).
    Another file we need is a kernel to replace the existing one that will help us
    with new ways of recovery operations. This file is named **Jeboo Kernel**, and
    can be found at [http://downloadandroidrom.com/file/GalaxyS2/kernels/JB/jeboo_kernel_i9100_v1-2a.tar](http://downloadandroidrom.com/file/GalaxyS2/kernels/JB/jeboo_kernel_i9100_v1-2a.tar).
  prefs: []
  type: TYPE_NORMAL
- en: 'As instructed on the recovery screen on the phone, you should press the *volume
    up* button to put the device in the download mode. Then, start Odin, and select
    the newly downloaded Jeboo Kernel as **PDA**. You should see a COM box marked
    in yellow if the phone is correctly connected, and is in the kernel download mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Rooting Samsung Galaxy S2](img/image00143.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Odin shows Jeboo as PDA and a connected device on `COM11`. Click on **Start**
    to upload upload the new Jeboo kernel you have selected.
  prefs: []
  type: TYPE_NORMAL
- en: 'It should not take too much time before you get a **PASS** notification:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Rooting Samsung Galaxy S2](img/image00144.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Odin has been completed successfully
  prefs: []
  type: TYPE_NORMAL
- en: Now, your phone should reboot, and you should see a warning triangle on the
    restart screen, indicating that you have a new kernel with the "recovery from
    SD card" feature.
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to save the **CWM Super User** file from [http://downloadandroidrom.com/file/tools/SuperSU/CWM-SuperSU-v0.99.zip](http://downloadandroidrom.com/file/tools/SuperSU/CWM-SuperSU-v0.99.zip)
    to the SD card and attach it to the device. Now, power off your device and put
    it into recovery mode again this time using a slightly different key combination,
    that is, *volume up*, *power*, *home*. Note that we press *volume up* instead
    of *volume down* as we did before. You will see a different recovery screen called
    **CWM-based Recovery**. You can scroll up and down using the *volume up* and *volume
    down* keys. Select the **Install Zip** item using the *home* button, and then
    the **Choose from SD card** option. You should browse to the CWM Super User ZIP
    file that you have downloaded on to the SD card. Finally, choose **Yes**.
  prefs: []
  type: TYPE_NORMAL
- en: Reboot the device, and you will see a new app called **Super User**, which indicates
    that you have successfully rooted your device. You can even verify that you have
    super user access to your device by downloading one of the Super User checker
    apps on Google Play. You will see a message box asking you a question from the
    Super User app, that we had installed from the previous step, if you want to grant
    super user privileges to any other app asking to get those.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling tethering on being connected to a power source
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As our phone hypothetically stays in the car all the time, and only gets powered
    up when the car is being used, we need to find a way to enable Wi-Fi tethering
    or a hotspot, as it is as well called, whenever the phone is connected to a power
    source. There are two cases that we might encounter, though:'
  prefs: []
  type: TYPE_NORMAL
- en: The battery has run out and the phone is turned off at night. Here, we need
    to find a way to turn on the phone whenever it gets powered up again. This happens
    when we start the car. When the phone is successfully turned on, we need to find
    a way to enable a hotspot.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The phone still has enough battery to keep it turned on, but as it hasn't been
    used, the hotspot is disabled. Note that the only device using the phone's hotspot
    is the Pi and it is turned off if the car isn't being used. When we start the
    car again, the phone gets powered up from the USB contact. In this case, we need
    to enable the hotspot again.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automatic restart on power connect
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When we connect a turned off Samsung device to a power source, we will see
    a gray battery image with a turning arrow inside it. Then, when it begins charging
    the battery, we will see another colored battery image showing the current charge
    level. This second image is generated by a program that is triggered whenever
    a turned off device begins charging the battery. It is a binary file located in
    `/system/bin/playlpm` on the phone. We will change this file to a script of our
    own to reboot the device. In order to be able to edit this file, we need super
    user privileges. This is why we have rooted the phone. As an Android system is
    actually a Linux OS under the hood, we can run any Linux command on it. We can
    do this using an app that we can download from the Play Store, called **Terminal
    Emulator**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Automatic restart on power connect](img/image00145.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The Terminal Emulator app screen
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, issue the upcoming commands to change the contents of the `playlpm` file
    and make it an executable file. We need to also remount the `/system` directory
    in order to enable it for write operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Turn off the device and connect it to a power source. You will see that it turns
    on automatically after one minute. We have introduced the one minute delay because
    if the battery is totally discharged, it will not have enough capacity to restart
    the device. We want to wait at least one minute in these kinds of situations for
    the battery to get charged enough to restart the device. If it is not charged
    sufficiently, you might need to charge your phone before it can automatically
    restart. You can charge the phone without getting it restarted by putting it in
    to the recovery mode and then begin charging it.
  prefs: []
  type: TYPE_NORMAL
- en: Auto tethering
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now we are able to restart the device on connecting it to a power source. We
    need to also enable tethering on the device when it wakes up or is connected to
    a power source. There are apps on the market that already do this, but the best
    ones are paid. This is one of the reasons that we will implement our own app for
    this purpose. The other reason is that it is fun.
  prefs: []
  type: TYPE_NORMAL
- en: We can create a new application in the Android Studio as we did before. We will
    not need any `Activity` for this application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new java file, called `StartTetheringAtBootReceiver`, for `BroadcastReceiver`
    and add the following code in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This piece of code receives broadcast events whenever the phone is booted or
    connected to a power source, and enables tethering on the device with the default
    settings. If we'd like to change the name of the network or the password, we'll
    need to modify the settings on the device.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the manifest definition for the new broadcast receiver to `AndroidManifest.xml`
    inside the `application` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following permission declarations inside the `manifest` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Now, install this app to your phone and see if the tethering is enabled whenever
    you reboot the device or connect a power cable to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can optionally add a shortcut button for tethering in `MainActivity`. In
    the `activity_main.xml` file, add the following button definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, in the `MainAcitivty.java` file, define the handler for the button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to connect the Pi to the hotspot that we have created so far.
    Connecting the Pi to a Wi-Fi network was covered earlier, but let''s remind ourselves
    about this concept again. Add the upcoming lines of code to the `/etc/wpa_supplicant/wpa_supplicant.conf`
    file. We can configure the hotspot to apply WPA PSK security instead of PSK2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we''ll reboot the Pi, and after a few minutes, we''ll see that it is automatically
    connected to a hotspot on the Android device in the hotspot settings window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Auto tethering](img/image00146.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The list of connected devices is shown in hotspot settings in Android
  prefs: []
  type: TYPE_NORMAL
- en: You must be wondering why we have covered this content at this point. This is
    because in order to implement the next section, you'll most probably need to sit
    in your car and communicate with the Pi inside your car, where you most probably
    do not have more network access than the hotspot Android provides you with. Now,
    if you connect to the same hotspot on Android from your computer, you will be
    able to SSH to the Pi with a tool called **PuTTY** that you can install on Windows
    machines or using built in SSH terminal tool on a Mac.
  prefs: []
  type: TYPE_NORMAL
- en: Sending data to the cloud
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will use a Google Docs spreadsheet to save data and a special Python library
    developed for this purpose. We begin doing this by creating an API key to access
    Google services.
  prefs: []
  type: TYPE_NORMAL
- en: 'Browse to [https://console.developers.google.com/project](https://console.developers.google.com/project)
    and create an account for this purpose. When it''s ready, you will be directed
    to the Google Developer Console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Sending data to the cloud](img/image00147.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The Google Developer Console start page
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we''ll need to create a new project in the **Select a project** drop-down
    menu. Give it a suitable name, accept the agreement, and click on **Create**.
    Select the newly created project, **APIs & auth**, and then select **APIs** from
    the menu on the left-hand side. Then, find and select **Drive API**, and press
    the **Enable API** button. When it is enabled, go to **Credentials** on the left-hand
    side menu under **APIs & auth**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Sending data to the cloud](img/image00148.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The menu to enable OAuth in the Google Developer Console
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, under **OAuth**, click on the **Create new Client ID** button. In the
    message box that appears, select the **Service account**, and click on the **Create
    Client ID** button. We''ll see a box telling us that we have successfully created
    **New public/private key pair** for the project. We''ll even see that the site
    has sent us a **JSON** file with credentials in it. For the dummy account I created,
    the contents looks similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: We can choose to generate a new key from the Developer Console site using the
    **Generate new JSON key** button for our project.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this stage, we need to generate a **P12** key using the **Generate new P12
    key** button. This file will be used later on. We will also be provided with a
    secret key when we download the file which we need to note down. The following
    screenshot illustrates the Google Developer Console after successful creation
    of the API key:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Sending data to the cloud](img/image00149.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Google Developer Console after successful API key creations
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we can install the Google Python library, we need to install a tool,
    called `pip`, which will help us install an OAuth client we will use to connect
    to Google services. Use the following commands to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, use this new `pip` tool to install the OAuth clients:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to download and install the client library to access Google
    Sheets on the Pi using the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we begin coding, we need to add a new spreadsheet on the [https://docs.google.com](https://docs.google.com)
    website. Select **Sheets** in the menu, create a new sheet using the plus (**+**)
    sign, and change the name from `Untitled spreadsheet` to `CAR_OBD_SHEET`. It should
    be saved automatically. We need to share this spreadsheet with the Google Developer
    Console client created for us when we generated the OAuth key pair. We''ll find
    a `client_email` field in the JSON file we''ve downloaded. We will share the new
    spreadsheet with this client. Now, open the `CAR_OBD_SHEET` spreadsheet in Google
    Docs and click on the **Share** button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Sending data to the cloud](img/image00150.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Open the spreadsheet in Google Docs
  prefs: []
  type: TYPE_NORMAL
- en: 'In the pop-up window, paste `client_email` from the JSON file, then click on
    the **Send** button on the pop-up window. This will share the spreadsheet with
    the client generated when we created the OAuth key pair in the previous step:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Sending data to the cloud](img/image00151.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Sharing the spreadsheet with the generated client
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will test to see if everything works fine. Create a file on the Pi,
    name it `send_to_sheet.py`, and put the following content in it. Do not forget
    to create the OAuth JSON file and put the contents of the one we have downloaded
    from the Google Developer Console and name it as `piandroidprojects.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Now, run the file using the `python send_to_sheet.py` command, and we will see
    the update on the Google Docs sheet. The code will create a new worksheet named
    as the current timestamp and save a single value in this sheet. Note that Google
    allows 200 worksheets per sheet, and by default, 100 rows per worksheet; in our
    code, we create a new worksheet each time we run it. We need to clean the sheet
    from time to time in order to not to go beyond the limit.
  prefs: []
  type: TYPE_NORMAL
- en: Putting it all together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the next two sections, we will put together what we have done so far. First,
    we'll begin by sending data to the Google Docs sheet. Then, we will build an Android
    app to show the data on a map.
  prefs: []
  type: TYPE_NORMAL
- en: Sending measurements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will use a Python script to access GPS data on the Pi that we''ll need to
    run on system reboot. For this purpose, add the following code at the end of the
    `/etc/rc.local` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we can restart the GPS services, connect to the OBD Bluetooth dongle,
    create a log file, and start the `sender.py` script that we will implement next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The code begins running at the end where we define `json_key` by loading the
    JSON key file. Then, we'll try to authorize using the `gspread.authorize(credentials)`
    method. The next step is to create a new worksheet with the date timestamp as
    the title, and then start to consume the GPS data in another thread defined by
    the `GpsPoller` class. Next, we'll initiate the `OBD_Sender` class and connect
    to the ODB Bluetooth device twice. The connect operation may fail when it's executed
    for the first time, but it almost always succeeds when it's run a second time.
    Then, we need to run the `get_data` method of the `OBD_Sender` class to begin
    the loop.
  prefs: []
  type: TYPE_NORMAL
- en: The `GpsPoller` class consumes all the values of the GPS device connected to
    the serial USB port. This is required in order to get the most recent values whenever
    we access the `gpsd.fix.latitude` and `gpsd.fix.longitude` variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `get_data` method of the `OBD_Sender` class sends the local time, latitude,
    and longitude values to the spreadsheet, and it also sends seven different readings
    defined in `self.sensorlist = [3,4,5,12,13,31,32]`. We can see these values from
    the `SENSORS` list in the `obd_sensors.py` file. For your information, these are
    the Fuel System Status, Calculated Load Value, Coolant Temp, Engine RPM, Vehicle
    Speed, Engine Start MIN, and Engine Run MIL values. We can change the indexes
    to read the values that we want. Take a look at additional values at [https://en.wikipedia.org/wiki/OBD-II_PIDs](https://en.wikipedia.org/wiki/OBD-II_PIDs).
    We go through these codes, read their current values, and send them to the different
    cells of a current row on our worksheet. After starting and driving your car around,
    you can see that the data is uploaded to the spreadsheet, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Sending measurements](img/image00152.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Data uploaded to the spreadsheet
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving measurements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will build our very own app to download the measurement values and show them
    on a map. Create a new blank project in the Android Studio, and choose to include
    a Google Maps Activity during the last step of create project wizard. I've used
    Android 4.3 as the base SDK for this project; I will name my main activity as
    `MapsActivity`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To access Google Docs and download the content of the spreadsheet, we will
    use some of the Java libraries provided by Google. They are located at different
    places. Download the ZIP files from the following locations:'
  prefs: []
  type: TYPE_NORMAL
- en: A general purpose Java client for Google data services is located at [https://github.com/google/gdata-java-client](https://github.com/google/gdata-java-client),
    and the file is named as `gdata-src.java-*.zip`, which is found under the **Source**
    link.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Download the HTTP client from [https://developers.google.com/api-client-library/java/google-http-java-client/download](https://developers.google.com/api-client-library/java/google-http-java-client/download)
    which is named as `google-http-java-client-featured.zip`. We will use this to
    authorize ourselves.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Download the OAuth client contained in `google-oauth-java-client-featured.zip`,
    which is available at [https://developers.google.com/api-client-library/java/google-oauth-java-client/download](https://developers.google.com/api-client-library/java/google-oauth-java-client/download)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, open these ZIP files, locate the following JAR libraries, and move them
    to the `libs` folder under your Android `app` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '`gdata-base-1.0.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gdata-core-1.0.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gdata-spreadsheet-3.0.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`google-api-client-1.20.0.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`google-http-client-1.20.0.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`google-http-client-jackson-1.20.0.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`google-oauth-client-1.20.0.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`guava-11.0.2.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jackson-core-asl-1.9.11.jar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To include these libraries in your Android project, you need to add them to
    the `build.gradle` file for `Module:app`. To do this, add the following code under
    the `dependencies` tag.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: When you edit the `build.gradle` file, you might get a message in Android, stating
    that **Gradle files has changed since last project sync. A project sync maybe
    necessary for the IDE to work properly**. Click on the **Sync Now** link located
    near this notification to update the project.
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to move the `P12` key file, which we have downloaded from the
    Google Developer Console, and include it in our Android project. We need to copy
    this file in the `raw` directory located at `PROJECT_HOME\app\src\main\res\raw`
    and rename it as `piandroidprojects.p12`.
  prefs: []
  type: TYPE_NORMAL
- en: As we plan to show the content on a map, we will use Google's Map API for this
    purpose. To use it, we need an access API key. Go to the developer console again
    at [https://console.developers.google.com/project](https://console.developers.google.com/project),
    and select the project that we've created previously. In the menu located on the
    left-hand side, choose **APIs** under **APIS & auth**, then, **Google Maps Android
    API**, and finally, click on the **Enable API** button. Next, navigate to **Credential**s,
    and click on the **Create new key** button under the **Public API access** section.
    We need to choose **Android key** in the window that pops up. Copy the generated
    **API key** and replace it with the `YOUR_KEY_HERE` string in the `google_maps_api.xml`
    file. Now, we are ready with our Android project setup, and it is time to code
    now.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing to do in the code is download a list of sheets from Google
    Docs. There is one sheet for each restart of the Pi. Add the following code inside
    the `onCreate` method of the `MapsActivity.java` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'This piece of code will create an asynchronous task that is implemented as
    an Android `AsyncTask`, which downloads and presents the spreadsheets. Let''s
    define the task class in the same file as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we describe the preceding code, define an instance variable for the
    spreadsheet service, which is used in the task we have just defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The Android `AsyncTask` requires us to override the `doInBackground` method,
    which is executed in a new thread whenever we call the `execute` method of the
    task that we performed in `onCreate`. In `doInBackground`, we will define `KeyStore`,
    and load the `P12` file that we've downloaded from the Google Developer Console
    and copied to the `raw` directory of our Android project. Note that `notasecret`
    was the secret that the Developer Console informed me about when I created and
    downloaded the `P12` file. Also, inside the `setServiceAccountId` method, you'll
    need to use your own account name. You can find it in the Developer Console under
    the **Service account** section in the **Email address** field as well as in the
    JSON key file **client_email** field. In the background method, after loading
    the key file and defining the credentials, we'll authorize ourselves to Google
    Spreadsheets service using OAuth. We'll simply get the first spreadsheet that
    I assume is `CAR_OBD_SHEET` and return the worksheets in it. We could go through
    all the spreadsheets and search for the title as well, but I will skip this part
    of the code and assume that you have only one spreadsheet in your account with
    the title as `CAR_OBD_SHEET`.
  prefs: []
  type: TYPE_NORMAL
- en: The second function we'll define is `onPostExecute`. This function is called
    inside the UI thread by the Android system whenever background processing is performed.
    It is important that this is run in the UI thread as we cannot touch UI elements
    if we run UI-related code in non-UI threads.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note here that the return value of the `doInBackground` method is sent as a
    parameter to the `onPostExecute` method, which is a list of worksheets found in
    a sheet in the Google Docs service. We''ll go through this list and collect the
    titles in another list. Then, we''ll show this list in a pop-up dialog box, which
    a user can click on and select. Whenever the user selects one of the worksheets,
    Android calls the `onClick` method of `DialogInterface.OnClickListener`, which
    we have sent in as a parameter to the adapter of `AlertDialog`. This method calls
    the `execute` method of another `AsyncTask` that we''ll call `RetrieveWorksheetContent`,
    which, as the name implies, retrieves the content of the selected worksheet. Here
    is the definition for this task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the most important part is where we iterate through `feed.getEntries()`,
    which refers to all the rows in the spreadsheet and the part where we iterate
    through `entry.getCustomElements().getTags()`, refers to all the columns. Then,
    in `onPostExecute`, we''ll call the `setUpMap` method with all the values that
    we have retrieved. Inside this method, we''ll create markers on the map that is
    contained in **MapsActivity**. Comment out the automatically defined `setUpMap`
    method if you do not want a marker at location `0`,`0`, which Android Studio has
    defined for you as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'When you start the app, you will see a list of spreadsheets to choose from:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Retrieving measurements](img/image00153.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The list of spreadsheets
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, after selecting one of these sheets, you can see the data on the map:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Retrieving measurements](img/image00154.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The data points on the map
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered a lot of content, ranging from car diagnostics to
    Android device root process. We even covered a lot of Android code.
  prefs: []
  type: TYPE_NORMAL
- en: I hope that all of you have fun implementing these exciting projects, will try
    to enhance them and making them better than I did.
  prefs: []
  type: TYPE_NORMAL
