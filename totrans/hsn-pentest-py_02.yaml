- en: Building Python Scripts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter will cover the core concepts of all programming languages. This
    includes conditional statements, loops, functions, and packages. We will see that
    these concepts are pretty much the same in Python as they are in other programming
    languages, except for some syntactical differences. But syntax just requires practice;
    everything else will fall into line automatically. The topics that we are going
    to cover in this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Conditional statements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loops
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modules and packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comprehensions and generators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Make sure you have the following pre-requisites needed to proceed further:'
  prefs: []
  type: TYPE_NORMAL
- en: A working computer or laptop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ubuntu OS (preferably 16.04)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python 3.x
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A working internet connection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Indentation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you come from a background of a language such as Java, C, or C++, you might
    be familiar with the concept of grouping logically connected statements using
    curly braces. This is not the case, however, in Python. Instead, the logically
    connected statements, including classes, functions, conditional statements, and
    loops, are grouped using indentation. Indentation keeps the code clean and easy
    to read. We shall explore this in more detail in the coming sections. For now,
    however, let's say goodbye to braces. I recommend that you use tabs for indentation,
    as typing an equal number of spaces in every line becomes very time-consuming.
  prefs: []
  type: TYPE_NORMAL
- en: Conditional statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Just like all other languages, to carry out the conditional operations, Python
    makes use of conditional statements. The conditional statements supported by Python
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`if` condition'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`if...else` condition'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`else...if` conditional ladder, known as `elif` in Python'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python doesn't support the `switch` statement.
  prefs: []
  type: TYPE_NORMAL
- en: The if condition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `if` condition or the `if` statement takes a statement and returns either a
    Boolean `True` or a Boolean `False` value after evaluating the statement. If the
    condition returns `True`, the code proceeding the `if` statement (equally indented)
    is executed. If the statement/condition evaluates to `False`, then either the
    `else` block of code gets executed if there is one, or the block of code following
    the `if` block is executed, so the `if` block is effectively skipped. Let's take
    a look at the `if` code in action.
  prefs: []
  type: TYPE_NORMAL
- en: 'From now on, we are going to look at how scripting works. We will either be
    creating script files or carrying out exercises. For this reason, go ahead and
    create a file on gedit or any editor of your choice and name it `if_condition.py`.
    Alternatively, we can type `gedit if_condition.py` in the Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/aa9f2b2d-6c1e-4a9c-9f32-6256eeea1e66.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We then type the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in order to run this script, we can simply type `python3.5 if_condition.py`
    in the Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1312d095-dbf5-4364-b1b7-5b7579c8056e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The Python `print` method by default adds `\n` to the string to be printed,
    using which we can see two outputs in different lines. Note that the syntax of
    the `if` statement is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`if <condition> : and then indented code`'
  prefs: []
  type: TYPE_NORMAL
- en: Whether or not we use brackets with the conditions is up to us. As you can see,
    the condition evaluated to `True`, so the line `a is greater` was printed. For
    `if` conditions in Python, anything that does not evaluate to zero (`0`), `False`,
    `None`, or `empty` would be treated as `True` and the code proceeding the `if`
    statement will get executed.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see another example of the `if` condition in conjunction with the `and...or` and `and...not`logical
    operators.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create another file called `if_detailed.py` and type the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7c54677b-14e2-455c-9d44-5ca468c56ff8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You might have noticed that at the beginning of the file, we have a statement
    that reads `#! /usr/bin/python3.5`. This means we don''t have to type `python3.5`
    every time we execute the code. It directs the code to use the program placed
    at `/usr/bin/python3.5` to execute it every time it''s executed as an executable.
    We need to change the permissions of the file to make it executable. Do this,
    and then execute the code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7e5e11fc-3482-487e-bb75-e91fda5623a7.png)'
  prefs: []
  type: TYPE_IMG
- en: The output produced is self-explanatory. As I mentioned before, anything that
    doesn't evaluate to `0`, `False`, `None`, or `empty` is taken as `True` and the `if`
    block is executed. This explains why the first three `if` conditions were evaluated
    to `True` and the message was printed, but the fourth message was not printed.
    From line 19 onwards, we have made use of logical operators. In Python, the conjunction
    operation is carried by the `and` operator, which is the same as `&&`, which we
    use with C, C++, and Java.  For the short circuit Boolean operator, we have the
    `or` keyword in Python, which is the same as `||` in C, C++, and Java. Finally,
    the `not` keyword provides negation in Python, as `!` does in other languages.
  prefs: []
  type: TYPE_NORMAL
- en: It should be noted that in Python, `null` byte characters are represented by
    a reserved keyword, `None`, which is the same as `null` in languages such as Java
    or C#.
  prefs: []
  type: TYPE_NORMAL
- en: The if...else condition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `if...else` condition is pretty much the same as in any other language.
    If the `if` condition evaluates to a `True` value, the code block indented under
    `if` is executed. Otherwise, the code block indented under the `else` block is
    executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create a file called `if_else.py` and see how to use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5599335c-aa75-4ca0-84cb-e3fc8080ee70.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Again, the output here is self-explanatory. In this section of code, we explored
    the usage of some bitwise operators alongside the `if...else` code structure.
    We also used variables, which are to be printed with the print method. `%s` is
    a placeholder, and specifies that the value of `%s` should be replaced by a string
    variable whose value would come immaterially after the string ends. If we have
    multiple values to substitute, they can be passed as a tuple such as `%(val1,val2,val3)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/adaa4be6-332d-470f-8ae1-b6d99a3a6bac.png)'
  prefs: []
  type: TYPE_IMG
- en: The if...elif condition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `if...elif` ladder, popularly known as **if...else if** in other programming
    languages such as C, C ++, and Java, has the same function in Python. An `if`
    condition let''s us specify a condition alongside the `else` part of the code.
    Only if the condition is `true` is the section proceeding the conditional statement
    executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'It must be noted that the third `else` in the preceding code snippet is optional.
    Even if we don''t specify it, the code works just fine:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ee775bc5-f579-4818-b1b7-e52d557c3560.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s create a file named `if_el_if.py`, and see how this can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2676e133-5cb3-4a20-85c9-3a22b38122d7.png)'
  prefs: []
  type: TYPE_IMG
- en: Loops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Loops** are utilities that every programming language has. With the help
    of loops, we execute tasks or statements that are repetitive in nature, which,
    without loops, would take up lots of lines of code. This, in a way, defeats the
    purpose of having a programming language in the first place. If you are familiar
    with Java, C, or C ++, you might have already come across `while`, `for`, and
    `do...while` loops. Python is pretty much the same, except that it doesn''t support
    `do...while` loops. Thus, the loops that we are going to study in the following
    section in Python are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`while` loop'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`for` loop'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The while loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Remember that when we discussed lists in the first chapter of the book, we
    mentioned that lists can actually hold heterogeneous data types in Python. A list
    may contain integers, strings, dictionaries, tuples, or even nested lists. This
    feature makes lists very powerful and exceptionally easy and intuitive to use.
    Let''s take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a closer look at `while` loops with the help of the following code,
    which we will call `while_loops.py`. We will also see how we can iterate over
    lists using `while` loops:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0e68bc32-414c-496d-adc4-3b226d86b136.png)'
  prefs: []
  type: TYPE_IMG
- en: The first portion of the code, lines 2 to 6, depicts a simple usage of the `while`
    loop, where we are printing a statement five times. Note that the condition that
    is specified for the loop to be executed can be placed with or without braces,
    as shown from lines 7 to 10.
  prefs: []
  type: TYPE_NORMAL
- en: 'In line 12, we declared a list containing numbers, strings, a float, and a
    nested list as well. Then, in the final `while` loop starting at line 14, we iterate
    over the elements of the list by setting the loop control variable to be less
    than the length of the list. Within the loop, we check for the type of the list
    variable. The `if` type (`1`) returns an integer class, type (`a`) returns a string
    class, and type (`[]`) returns a list class. When the type is a list, we iterate
    over its elements again in a nested `while` loop, and print each one, as shown
    from lines 19 to 24:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/10ea76e3-b448-4f3b-83b1-94ab2fb0b198.png)'
  prefs: []
  type: TYPE_IMG
- en: The for loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `for` loop is very widely used in Python, and it's the default choice whenever
    we have to iterate over an inalterable list. Before moving forward with the `for`
    loop, let's take a closer look at what the terms **iteration**, **iterable**,
    and **iterator** mean in Python.
  prefs: []
  type: TYPE_NORMAL
- en: Iteration, iterable, and iterator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Iteration**: An iteration is a process wherein a set of instructions or structures
    are repeated in a sequence a specified number of times or until a condition is
    met. Each time the body of a loop executes, it''s said to complete one iteration.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Iterable**: An iterable is an object that has an `__iter__` method, which
    returns an iterator. An iterator is any object that contains a sequence of elements
    that can be iterated over, and then an operation can be performed. Python strings,
    lists, tuples, dictionaries, and sets are all iterables as they implement the
    `__iter__` method. Take a look at the following snippet to see an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/519d23b0-3a68-4990-8bdc-a9ab679251bb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding code snippet, we declare a string `a` and place the value
    `hello` value in it. To see all the built-in methods of any object in Python,
    we can use the `dir(<object>)` method. For strings, this returns us all the operations
    and methods that can be carried out on the string type. In the second row, the
    5th operation is the `iter` method we mentioned previously. It can be seen that `iter(a)`
    returns a string iterator:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a0a1f01f-e979-4f87-978e-bad863fc3fa3.png)'
  prefs: []
  type: TYPE_IMG
- en: Likewise, a list object's `iter` method would return a list iterator, as previously
    shown.
  prefs: []
  type: TYPE_NORMAL
- en: '**Iterator**: An iterator is an object with a `__next__` method. The next method
    always returns the `next` element of the sequence over which the original `iter()`
    method is called, starting from index 0\. This is shown in the following code
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/56b3b03d-3e4d-46ed-9c14-5e7635670261.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As can be seen in the examples for both string and list, the `next` method
    over the iterator will always return us the `next` element in the sequence or
    the object that we are iterating over. It must be noted that the iterator only
    moves forwards, and if we want `iter_a` or `list_itr` to go back to any element,
    we must reinitialize the iterator to the original object or sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/debc073b-944c-415d-8025-4aad8c31828f.png)'
  prefs: []
  type: TYPE_IMG
- en: A closer look at for loops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `for` loops in Python exceed the capabilities of `for` loops in other programming
    languages. When calling upon iterables such as strings, tuples, lists, sets, or
    dictionaries, the `for` loop internally calls the `iter` to get an iterator. Then,
    it calls the `next` method over that iterator to get the actual element in the
    iterable. It then calls next repeatedly until a `StopIteration` exception is raised,
    which it would internally handle and get us out of the loop. The syntax of the `for`
    loop is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create a file called `for_loops.py`, which will explain the basic use
    of `for` loops:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/21f3c53c-8026-4eb0-89c2-584610aaf3bd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding example, we used the Python range function/method, which helps
    us implement the traditional `for` loop that we learnt in other programming languages
    such as C, C ++, or Java. This might look like `for i =0 ;i < 5 ;i ++`. The range
    function in Python takes one mandatory argument and two default ones. The mandatory
    argument specifies the limit of the iteration and, starting from index `0`, returns
    numbers until it reaches the limit, as seen in lines 3 and 4 of the code. When
    invoked with two arguments, the first one serves as the starting point of the
    range and the last one serves as the end point, as is depicted in lines 7 and
    8 of our code. Finally, when the `range` function is invoked with three arguments,
    the third one serves as the step size, which is equal to one by default. This
    is depicted in the following output and lines 12 and 13 of the sample code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/52eaf92b-b027-400f-ad61-adc8931dae46.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s take a look at another example of a `for` loop, which we shall use to
    iterate over all the iterables that Python defines. This will allow us to explore
    the real power of `for` loops. Let''s create a file called `for_loops_ad.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5899a34e-3c43-477a-b13b-b2fe50d1e557.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Earlier, we saw how we can read the values from lists, strings, and tuples.
    In the preceding example, we use the `for` loop to enumerate over strings, lists,
    and dictionaries. We learned earlier that the `for` loop actually invokes the
    `iter` method of iterables and then calls the `next` method for each iteration.
    This is shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c6c41da0-de0e-4976-9ac5-55a9dea1ab52.png)'
  prefs: []
  type: TYPE_IMG
- en: When we iterate over Python dictionaries using a `for` loop, by default, the
    dictionary keys are returned to us. When we use `.items()` over dictionaries,
    it returns us a tuple each time we iterate over it, with the key at 0^(th) index
    of the tuple and the value at the first index.
  prefs: []
  type: TYPE_NORMAL
- en: Functions and methods in Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functions and methods are used to design or make a logical unit of code that
    can be reused throughout the course of your script or other scripts. Functions
    actually form the basis of code reuse and bring modularity to the code structure.
    They keep the code clean and easier to modify.
  prefs: []
  type: TYPE_NORMAL
- en: It is advisable to always try to break our logic into small units of code, each
    of which is a function. We should try to keep the size of the method small in
    terms of the lines of code whenever possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code represents the basic syntax of defining methods in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Python methods do not have a return type in their definition as you might have
    seen in C, C++, or Java, such as `void`, `in`, `float`, and so on. A Python method
    may or may not return a value, but we do not explicitly need to specify that.
    Methods are very powerful and flexible in Python.
  prefs: []
  type: TYPE_NORMAL
- en: It should be noted that the default name of every Python script is `main` and
    that this is placed inside a global variable that is accessible throughout the
    Python context called `__name__`. We shall use this in the coming example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s explore the various ways of invoking methods using our `method_basics.py` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6433781e-b3c0-4444-ac77-972cb6a9b54e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s now break this down into smaller pieces and try to understand what has
    happened:'
  prefs: []
  type: TYPE_NORMAL
- en: '`print_msg1()`: This is a basic method that just prints a string on the console.
    It is defined at line 2 and invoked at line 19.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`print_msg2()`: This is a method that takes an argument in the variable message
    and then prints that variable value on the screen. Remember that Python variables
    do not require a type to be specified, so we can pass any data to the `message` variable.
    This is a Pythonic example of a method that takes a single argument. Remember
    that the type of the argument is a Python object and it can take any value passed
    to it. The output can be seen in the following screenshot:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/f707b6e8-aff7-4cf9-99f6-05cf4084806f.png)'
  prefs: []
  type: TYPE_IMG
- en: '`print_msg3()`: This is a Python method that takes two arguments. It is similar
    to the `print_msg2()` method that we saw previously. The difference is that it
    may sometimes return a value. It is also invoked differently. Note that in line
    22, we invoke this method by passing the second parameter as `True`. This means
    it has a return value of `True`, but we do not invoke it with `True` as a second
    parameter in line 26, so it therefore returns nothing. For this reason, we get
    `None` printed on the screen. In other programming languages, such as C, C++,
    or Java, the order of parameters while invoking the method is very important.
    This is because the sequence with which we passed the argument should be the same
    sequence that is passed to the method. In Python, however, we can invoke the methods
    and pass the named parameters during invocation. This means that the order or
    sequence doesn''t matter, as long as the name matches the name of the method parameter.
    This is depicted in line 29, where we are passing a message as a second parameter,
    even though it is the first parameter in the method definition. This works perfectly,
    as shown in the output.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`print_msg4()`: This is where we get familiar with Python default parameters
    and how they can be used with methods. A default parameter is a variable that
    is assigned a default value while a method is declared. If the caller passes on
    a value for this parameter or variable, then the default value is overwritten
    by the value passed by the caller. If no value is passed for the default parameter
    during invocation, then the variable persists the default value to which it was
    initialized. The `print_msg4()` method has got one mandatory argument, `m`, and
    two optional  arguments, `op1` and `op2`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`print_msg4(''Test Mandatory'')`: This is invoked at line 31\. This indicates
    that the `Test mandatory` string should be passed for the mandatory parameter
    and the other two `op1` and `op2` variables will be initialized to the default
    values, as seen in the output.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`print_msg4(1,2)`: This is invoked at line 32\. This indicates that an integer
    with `value=1` should be passed for the mandatory parameter and another integer
    with `value=2` should be passed for `op1`. The default value will therefore be
    overwritten for `op1`. `op2` will retain the default value, as no value is passed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`print_msg4(2,3,2)`: This is invoked at line 33\. This indicates that an integer
    with `value=2` should be passed for the mandatory parameter and another integer
    with `value=3` should be passed for `op1 ` so the default values for `op1` and
    `op2` are overwritten.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`print_msg4(1,op2=''Test'')`: This is invoked at line 34\. The mandatory parameter
    receives an integer with `value=1`. For the second parameter, we are specifying
    a named parameter during invocation, so the sequence does not matter for `Test`,
    which will get copied to `op2` of the caller.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`print_msg4(1,op2=33,op1=44)`: This is invoked at line 35\. The mandatory parameter
    receives `value=1`. For the second parameter, we specify a named parameter, `op2`,
    and for the third parameter, we pass `op1`. Again, we can see in the output that
    the sequence does not matter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`print_msg5()`: Usually, in other programming languages, a function or method
    can always return one value. If it needs to return multiple values, it must put
    the values in an array or another structure and then return them. Python handles
    this situation abstractly for us. If you read the code, you might think that the
    method is returning multiple values, whereas in reality it''s returning a tuple
    with each value multiplied by two. This can be validated from the output.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's now explore some further methods and ways to pass arguments, using the
    following example, `methods_adv.py`. The following code snippet represents variable-argument
    type methods in Python. As can be verified from the output, `method_1` takes a
    normal sequence of any size as an input, meaning we can pass any number of arguments
    to the method. When the method is declared with a parameter preceded by the `*`
    sign, all the passed arguments are translated into a sequence and a tuple object
    is placed inside `args`. On the other hand, when `*` is used with a parameter
    while invoking the method, the parameter type from the sequence is changed and
    internally each element `if` sequence is passed as a single parameter to the caller,
    as seen in `method_1_rev`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Furthermore, when `if` is used with a parameter in the method declaration,
    it internally transforms all the maned parameters into a Python dictionary, with
    the key as the name and the value being the same as the value after the `=` operator.
    This can be seen in `method_2`. Finally, when `**` is used with the caller parameter,
    that parameter is internally transformed from a Python dictionary to named parameters.
    This can be validated with `method_2_rev`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a143bc5f-0fdd-4a93-a9ff-650b65748d8b.png)'
  prefs: []
  type: TYPE_IMG
- en: Modules and packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Every Python script is called a module. Python has been designed with reusability
    and ease of code in mind. For this reason, every Python file we create becomes
    a Python module and is eligible to be invoked or used within any other file or
    script. You might have learned in Java how to import classes and reuse them with
    other classes. The idea is pretty much the same here, except that we are importing
    the whole file as a module and we can reuse any method, class, or variable of
    the imported file. Let''s take a look at an example. We will create two files, `child.py`
    and `parent.py`, and put the following code in each, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4978a91f-a963-4631-9d09-6704e427d4f0.png)'
  prefs: []
  type: TYPE_IMG
- en: The first five lines belong to `child.py`, and the last eight lines belong to
    `parent.py`. We will run the parent, as shown in the output. It should be noted
    that the imported file can be given an alias. In our case, we imported the child
    and gave it the alias C. Finally, we called `child_method()` class of that module
    from the parent Python script.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now try to explore Python packages and how they can be used. In Java,
    a package is nothing but a folder or directory that collects logically connected
    class files in Java. Packages do the same in Python; they collect logically connected
    Python modules. It is always recommended to use packages, as this keeps the code
    clean and makes it reusable and modular.
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned earlier, a Python package is a normal directory. The only difference
    is that in order to make a normal directory behave like a Python package, we must
    place an empty `__init__.py` file inside the directory. This indicates to Python
    which directories it should use as packages. Let''s go ahead and create a package
    called `shapes`. We will place an empty Python file called `__init__.py` and another
    file called `area_finder.py` inside it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3f51903f-9f5e-4c09-a2d4-51e0ab61bd4c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s now put the following code in the `area_finder.py` file. Let''s also
    create another file called `invoker.py` and place it **outside the shapes** folder
    that we created. The code of the invoker is given on the right-hand side of the
    following image, while the code of the `area_finder` is given on the left-hand
    side:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d04e78e6-484e-4d8b-a142-751caf7ca5ce.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding code is a straightforward example of how to use packages in Python.We
    created a package called `shapes` and placed a file called `area_finder` in it,
    which will compute the area of a shape. Then, we went ahead and created a file
    called `invoker.py` outside the `shapes` folder, and imported the `area_finder`
    script from the package in multiple ways (for demonstration purposes). Finally,
    we used one of the aliases to invoke the `find_area()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Generators and comprehensions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A **generator** is a special kind of iterator in Python. In other words, a
    Python generator is a function that returns us a generator iterator by issuing
    the `yield` command, which can be iterated upon. There might be occasions in which
    we would want a method or function to return us a series of values, instead of
    just one. We might, for example, want our method to partially carry out a task,
    return the partial results to the caller, and then resume the work right from
    the place where it returned the last value. Usually, when a method terminates
    or returns a value, its execution begins again from the start. This is what generators
    try to address. A generator method returns a value and a control to the caller
    and then continues its execution right from where it left off. A generator method
    is a normal Python method with a yield statement. The following code snippet, `generators.py`,
    explains how generators can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/602efafc-01fe-4ce4-99db-0d946dea3d9e.png)'
  prefs: []
  type: TYPE_IMG
- en: Note that since `genMethod` has a yield statement in it, it becomes a generator.
    Every time the yield statement is executed, the value of "a" is returned to the
    caller as well as the control (remember that generators return series of values).
    Every time the `next()` call is made to the generator method, it resumes its execution
    from where it left off previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'We know that every time a yield is executed, the generator method returns a
    generator iterator. Thus, as with any iterator, we can use a `for` loop to iterate
    over the generator method. This `for` loop will continue until it reaches the
    yield operation in the method. The same example with a `for` loop would look as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8f445fb5-837c-4f90-af71-da0d2bebab28.png)'
  prefs: []
  type: TYPE_IMG
- en: You might be wondering why we would use generators when the same result can
    be achieved with lists. Generators are very memory- and space-efficient. If a
    lot of processing is required to generate values, it makes sense to use generators,
    because then we only generate values according to our requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Generator expressions are one-line expressions that can produce generator objects,
    which can be iterated over. This means that the same optimization in terms of
    memory and processing can be achieved. The following code snippet shows how generator
    expressions can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2d06b188-024e-4928-b650-aa02d5d0f302.png)'
  prefs: []
  type: TYPE_IMG
- en: Comprehensions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Python comprehensions**, commonly known as **list comprehensions**, are a
    very powerful Python utility that comes in handy if we need to perform some manipulation
    operations over all or some of the elements of a list. A list comprehension would
    return a new list with the modifications applied. Let''s say that we have a  list
    of numbers and we want to square each number in the list.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at two different approaches to this problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eaed9af8-43f0-40e1-86df-0076c101d8d4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The code snippet on the left, the more traditional approach, took nine lines.
    The same code using comprehensions took us just three lines. A list comprehension
    is declared within square brackets and it performs any operation on each element
    of a list. It then returns a new list with the modifications. Let''s take a look
    at another example of comprehensions. This time, we will use an `if` condition
    (known as a comprehension filter), and nested loops with comprehensions. We will
    name the file `list_comp_adv.py` and enter the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5a1a5b89-0434-4f19-b6c6-60d05a1c1ca1.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding snippet is self-explanatory. It shows us how to use `if` conditions
    with comprehensions (line 4). It also shows us how to use nested loops to add
    up two lists (line 5). Finally, it shows us how to use dictionaries with comprehensions
    (line 6).
  prefs: []
  type: TYPE_NORMAL
- en: Map, Lambda, zip, and filters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to understand some very handy Python functions.
    These allow us to carry out quick processing operations on Python iterables such
    as lists.
  prefs: []
  type: TYPE_NORMAL
- en: '`Map()`: As we saw earlier, list comprehensions come in very handy when we
    have to perform an operation on all or some of the elements in a list. The same
    can be achieved with the help of the `map` function. This takes two arguments,
    the first being the function that will perform the manipulation on the elements
    of the list, and the second being the list itself. The following example, `map_usage.py`,
    demonstrates this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/77878f15-4172-4891-8b59-225dce87a415.png)'
  prefs: []
  type: TYPE_IMG
- en: '`Lambda()`: Lambda functions are small but powerful in-line functions that
    can be used for manipulation of data. They can be very useful for small manipulations,
    as very little code is required to implement them. Let''s look at the same example
    again, but this time we will use a Lambda function in place of a normal Python
    function:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/cb16e80b-43d7-4c23-bfef-9aebe43b2889.png)'
  prefs: []
  type: TYPE_IMG
- en: '`Zip()`: The `zip` method takes two lists or iterables and aggregates the elements
    across multiple iterables. Finally, it returns us a tuple iterator that contains
    the aggregation. Let''s make use of a simple code, `zip_.py`, to demonstrate this
    function:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/3b2d1050-84aa-4988-8977-1da910a5f0f7.png)'
  prefs: []
  type: TYPE_IMG
- en: '`Filter()` :The `filter` method is used to filter out the elements of the list
    that return true for a particular condition. The `filter` method takes two arguments,
    the first being the method or Lambda function that either returns `true` or `false`
    for a particular element, and the second being the list or iterable to which that
    element belongs. It returns a list that contains the elements for which the condition
    evaluated as `true`. Let''s create a file called `filter_usage.py`, and add the
    following content:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/5281cba6-6154-46fd-a92d-b7b1edbd98ad.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed abut conditions, loops, methods, iterators, packages,
    generators, and comprehensions. All of these are widely used in Python. The reason
    why we covered these topics is because when we get into automating penetration
    testing and cyber security test cases later on, we will see these concepts widely
    used within our code files. In the next chapter, we will explore the object-oriented
    nature of Python. We will explore how to deal with XML, CSV, and JSON data in
    Python. We will also read about files, IO, and regular expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Name a real-world use case in which generators are used.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can we store a function name in a variable and then invoke it via a variable?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can we store a module name in a variable?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Generators and Comprehensions: [http://jpt-pynotes.readthedocs.io/en/latest/generators-comprehensions.html](http://jpt-pynotes.readthedocs.io/en/latest/generators-comprehensions.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Modules: [https://docs.python.org/3/tutorial/modules.html](https://docs.python.org/3/tutorial/modules.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
