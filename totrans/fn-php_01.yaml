- en: Chapter 1. Functions as First Class Citizens in PHP
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Functional programming, as its name suggests, revolves around functions. In
    order to apply functional techniques effectively, a language has to support functions
    as the first class citizen, or also **first functions**.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: This means that functions are considered like any other value. They can be created
    and passed around as parameters to other functions and they can be used as return
    value. Luckily, PHP is such a language. This chapter will demonstrate the various
    way functions can be created and used.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Declaring function and methods
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scalar type hints
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Anonymous functions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Closures
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using objects as functions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Higher Order Functions
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The callable type hint
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before we begin
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the first release of PHP 7 happened in December 2015, it will be the version
    that will be used for the examples in this book.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: However, since it's a fairly new version, each time we use a new feature, it
    will be clearly outlined and explained. Also, since not everyone is able to migrate
    right away, changes needed to run the code on PHP 5 will be proposed whenever
    possible.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: The latest version available at the time of writing is 7.0.9\. All code and
    examples are validated using this version.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Coding standards
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Examples in this book will respect **PSR**-**2** (**PHP Standard Recommendation2**)
    and its parent recommendation, PSR-1, for their coding style, as should most of
    the libraries presented. For people not familiar with them, here are the most
    important parts:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Classes are in a namespace and use CamelCase with the first letter capitalized
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Methods use CamelCase without the first letter capitalized
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constants are written with all letters in capital
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Braces for classes and methods are on a new line, other braces are on the same
    line
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Also, although not being defined in PSR-2, the following choices were made:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Function names are in snake_case
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parameters, variables, and property names are in snake_case
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Properties are private whenever possible
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Autoloading and Composer
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The examples will also assume the presence of a PSR-4 compatible autoloader.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: As we will use Composer dependency manager to install the presented libraries,
    we recommend using it as the autoloader.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Functions and methods
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although this book is not designed for PHP beginners, we will quickly cover
    some basis in order to be sure we share a common vocabulary.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: 'In PHP, you usually declare a function using the `function` keyword:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'A function declared inside a class is called a **method**. It differs from
    a traditional function as it can access the object properties, have visibility
    modifiers, and can be declared static. As we will try to write code as pure as
    possible, our properties will be of `private` type:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: PHP 7 scalar type hints
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You were already able to declare type hints for classes, callables, and arrays
    in PHP 5\. PHP 7 introduces the idea of scalar type hints. This means you can
    now say that you want a `string`, an `int`, a `float`, or a `bool`data type, both
    for parameters and return types. The syntax is roughly similar to what can be
    found in other languages.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: 'Contrary to class type hints, you can also choose between two modes: the **strict**
    mode and the**non-strict** mode, the latter being the default. This means PHP
    will try to cast the values to the desired type. The casts will happen silently
    if there is no loss of information, otherwise, a warning will be raised. This
    can lead to the same strange results you can have with string to numbers conversion
    or true and false values.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some examples of such casts:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If you want to avoid issues with casting, you can opt-in for the strict mode.
    This way PHP will raise an error each time the values do not exactly conform to
    the desired type. In order to do so, the `declare(strict_types=1)` directive must
    be added to the very first line of your file. Nothing must precede it.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: The only cast that PHP allows itself is from `int` to `float` by adding `.0`
    as there is absolutely no risk of data loss.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the same examples as before, but with strict mode activated:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Although not demonstrated here, the same casting rules apply for return types.
    Depending on the mode, PHP will happily perform the same casting and display the
    same warning and errors as for parameters hints.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: Also, another subtlety is that the mode that is applied is the one being declared
    at the top of the file where the function call is made. This means that when you
    call a function that was declared in another file, the mode this file was in is
    not taken into account. Only the directive at the top of the current file matters.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: Concerning errors raised about types, we will see in [Chapter 3](ch03.html "Chapter 3. 
    Functional Basis in PHP"), *Functional basis in PHP* how exception and error handling
    was changed in PHP 7 and how you can use it to catch those.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: From now on, every time it makes sense, our examples will use scalar type hints
    to make the code more robust and readable.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Imposing types can be seen as cumbersome and will probably lead to a few irritations
    when you start using them, but in the long run, I can assure you that it will
    save you from some nasty bugs. All checks that can be done by the interpreter
    are something you don't need to test yourself.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: It also makes your function easier to understand and reason with. The person
    looking at your code won't have to ask themselves what could a value be, they
    know with certitude what kind of data they have to pass as parameters and what
    they will get back. The result is that the cognitive burden is lessened and you
    can use your time thinking of solving issues instead of keeping in mind menial
    details about your code.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: Anonymous functions
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You were probably well aware of the syntax we saw to declare functions. What
    you may not know is that a function does not necessarily need to have a name.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: Anonymous functions can be assigned to variables, used as callbacks and have
    parameters.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: In the PHP documentation, the term anonymous function is used interchangeably
    with the term *closure*. As we will see in the following code snippet, an anonymous
    function is even an instance of the `Closure` class, which we will discuss. According
    to the academic literature both concepts, although similar, are a bit different.
    The first usage of the term closure was in 1964 by Peter Landin in *The mechanical
    evaluation of expressions*. In the paper, a closure is described as having an
    environment part and a control part. The functions we will declare in this section
    won't have any environment, so they won't be, strictly speaking, closures.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to avoid confusion when reading other work, this book will use the
    term *anonymous function* to describe a function without a name, as presented
    in this section:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The previous code snippet declared an anonymous function and assigned it to
    a variable so that we can reuse it later either as a parameter to another function
    or call it directly:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You can also declare an anonymous function directly as a parameter if you don''t
    plan to reuse it:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Or you can return a function as you would return any kind of value:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Closures
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we saw earlier, the academicals description of a closure is a function that
    has access to some outside environment. Throughout this book, we will keep to
    this semantics, despite PHP calling both anonymous functions and closure using
    the later term.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: 'You may be familiar with JavaScript closures, where you can simply use any
    variable from the outside scope without doing anything particular. In PHP, you
    need to use the `use` keyword to import an existing variable into the scope of
    an anonymous function:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'PHP closures use an early-binding approach. This means that the variable inside
    the closure will have the value that the variable had at the closure creation.
    If you change the variable afterward, the change will not be seen from inside
    the closure:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You could pass the variable by reference so that changes to the variable are
    propagated inside the closure, but since this is a book on functional programming
    where we try to use immutable data structures and avoid having state, figuring
    how to do it is left as an exercise to the reader.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Be aware that when you pass objects to a closure, any modification done to properties
    in the object will be accessible inside the closure. PHP does not make a copy
    of objects when passed to the closure.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: Closures inside of classes
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you declare any anonymous function inside a class, it will automatically
    get access to the instance reference via the usual `$this` variable. To stay coherent
    about the vocabulary, the function will automatically become a closure:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If you want to avoid this automatic binding, you can declare a static anonymous
    function:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Using objects as functions
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, you might want to split your function into smaller parts, but without
    those parts being accessible to everyone. When this is the case, you can leverage
    the `__invoke` magic method on any object that let you use an instance as a function
    and hide that helper function as private methods inside your object:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `__invoke` method will be called with any parameters you pass to the instance.
    If you want, you can also add a constructor to your object and use any methods
    and properties that it contains. Just try to keep it as pure as possible, because
    as soon as you use mutable properties, your function will be harder to understand.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: The Closure class
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All anonymous functions are in fact an instance of the `Closure` class. However,
    as stated in the documentation ([http://php.net/manual/en/class.closure.php](http://php.net/manual/en/class.closure.php)),
    this class does not use the aforementioned `__invoke` method; it''s a special
    case in the PHP interpreter:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '*Besides the methods listed here, this class also has an __invoke method. This
    is for consistency with other classes that implement calling magic, as this method
    is not used for calling the function.*'
  id: totrans-80
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This method on the class allows you to change to which object the `$this` variable
    will be bound inside the closure. You can even bind an object to a closure created
    outside of the class.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: If you start using the features of the `Closure` class, keep in mind that the
    `call` method was just recently added in PHP 7.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: Higher-order functions
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PHP functions can take functions as parameters and return functions as return
    values. A function that does either of those is called a higher-order function.
    It is as simple as that.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: In fact, if you read the following code samples, you will quickly see that we
    have already created multiple higher-order functions. You will also discover,
    without much surprise, that most of the functional techniques you will learn revolve
    around higher-order functions.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: What is a callable?
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A `callable` is a type hint that can be used to enforce that the parameter
    of a function is something that can be called, like a function. Beginning with
    PHP 7, it can also be used as a type hint for the return value:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: However, what you cannot enforce with the type hint is the number and type of
    arguments your callable should have. But it is already great to guarantee to have
    something you can call.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: 'A callable can take multiple forms:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: A string for named functions
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An array for class methods or static functions
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A variable for anonymous functions or closures
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An object with a `__invoke` method
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s see how we can use all these possibilities. Let''s start with calling
    a simple function by name:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We can also do the same for functions inside of classes. Let's declare an `A`
    class with some functions and use an array to call it.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Using a string will only work for the static method, as other methods will
    need an object to use as their context. In the case of a static method, you can
    also use a simple string directly, this will, however, only work starting with
    PHP 7; the previous version didn''t support this syntax:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You can call a method on a class instance as easily:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以轻松地在类实例上调用方法：
- en: '[PRE17]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Since our `A` class has an`__invoke` method, we can use it as a `callable`
    directly:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的`A`类具有`__invoke`方法，因此我们可以直接将其用作`callable`：
- en: '[PRE18]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You can also use any variable to which an anonymous function is assigned as
    a `callable`:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用任何变量，其中分配了一个匿名函数作为`callable`：
- en: '[PRE19]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'PHP also provides you with two helpers to call functions in the form of `call_user_func_array`
    and `call_user_func`. They take a callable as a parameter and you can also pass
    parameters. For the first helper, you pass an array with all the parameters; for
    the second one, you pass them separately:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: PHP还为您提供了两个助手来调用函数，即`call_user_func_array`和`call_user_func`。它们将可调用作为参数，并且您还可以传递参数。对于第一个助手，您传递一个包含所有参数的数组；对于第二个助手，您分别传递它们：
- en: '[PRE20]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'A final word of caution, if you are using the `callable` type hint: any string
    that contains a function name that has been declared is considered valid; this
    can lead to some unexpected behavior sometimes.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要注意的一点是，如果您使用了`callable`类型提示：任何包含已声明的函数名称的字符串都被视为有效；这有时会导致一些意外的行为。
- en: A somewhat contrived example would be a test suite where you check that some
    functions only accept valid callables by passing it some strings and catching
    the resulting exception. At some point, you introduce a library and this test
    is now failing, although both should be unrelated. What is happening is that the
    library in question declares a function with the exact name that your string contained.
    Now, the function exists and no exception is raised anymore.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有些牵强的例子是一个测试套件，您可以通过传递一些字符串来检查某些函数是否只接受有效的可调用对象，并捕获结果异常。在某个时候，您引入了一个库，现在这个测试失败了，尽管两者应该是无关的。发生的情况是，所涉及的库声明了一个与您的字符串完全相同的函数名称。现在，该函数存在，不再引发异常。
- en: Summary
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we discovered how you can create new anonymous functions and
    closures. You are also now familiar with the various ways you can pass those around.
    We also learned about the new PHP 7 scalar type hints that help us to make our
    program more robust, and the `callable` type hint so we can enforce having a valid
    function as a parameter or return value.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们发现了如何创建新的匿名函数和闭包。您现在也熟悉了传递它们的各种方式。我们还了解了新的PHP 7标量类型提示，这有助于使我们的程序更加健壮，以及`callable`类型提示，这样我们就可以强制参数或返回值为有效函数。
- en: For anyone who has been using PHP for some time already, there was probably
    really nothing new in this chapter. But we now share a common ground that will
    help us dive into the functional world.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些已经使用PHP一段时间的人来说，本章可能没有什么新鲜的内容。但现在我们有了一个共同的基础，这将帮助我们进入函数式世界。
- en: With the basics about functions in PHP covered, we will learn more about the
    fundamental concepts pertaining to functional programming in the next chapter.
    We will see that your functions have to respect certain rules in order to be truly
    useful in a functional code base.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP函数的基础知识介绍完毕后，我们将在下一章中了解有关函数式编程的基本概念。我们将看到，您的函数必须遵守某些规则，才能真正在函数式代码库中发挥作用。
