- en: Working with Databases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The PHP language has a pretty good support for several different databases. MySQL
    has been embraced by PHP developers as the go-to database ever since the early
    days of the PHP language. While the initial emphasis was mostly on **relational
    database management systems** (**RDBMS**), other types of databases proved to
    be equally (or more) important for modern applications. The document and data
    key-value databases have been growing in popularity ever since.
  prefs: []
  type: TYPE_NORMAL
- en: Nowadays, it is not uncommon to see a PHP application making use of MySQL, Mongo,
    Redis, and possibly a few more databases or data stores all at once.
  prefs: []
  type: TYPE_NORMAL
- en: The NoSQL ("non SQL", "non relational" or "not only SQL") nature of Mongo allows
    building applications that generate massive volumes of new and possibly rapidly
    changing data types. Relieved from the strictness of **SQL** (**Structured Query
    Language**), working with structured, semi-structured, unstructured, and polymorphic
    data becomes a whole new experience with the Mongo database. The in-memory data
    structure stores such as Redis strive on speed, which makes them great to cache
    and message broker systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will take a closer look at MySQL, Mongo, and Redis through
    the following sections:'
  prefs: []
  type: TYPE_NORMAL
- en: Working with MySQL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing MySQL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up sample data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Querying via the mysqli driver extension
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Querying via the PHP Data Objects driver extension
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with MongoDB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing MongoDB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up sample data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Querying via the MongoDB driver extension
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with Redis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing Redis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up sample data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Querying via the phpredis driver extension
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Throughout this chapter, we provide quick installation instructions for each
    of the three database servers. These instructions are given on a relatively basic
    level, without any post-installation configuration or tuning that is usually done
    on production-type machines. The general idea here was to merely get the developer
    machine up and running with each of the database servers.
  prefs: []
  type: TYPE_NORMAL
- en: Working with MySQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MySQL is an open source RDBMS that has been around for over 20 years now. Originally
    developed and owned by the Swedish company MySQL AB, it is now owned by Oracle
    Corporation. The current stable version of MySQL is 5.7.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the key strengths of MySQL can be outlined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Cross-platform, runs on server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can be used for desktop and web applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fast, reliable, and easy to use
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Good for small and large applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uses standard SQL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Supports query caching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Supports Unicode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ACID compliance when using InnoDB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transactions when using InnoDB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing MySQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Assuming we are using the fresh Ubuntu 16.10 (Yakkety Yak) installation, the
    following steps outline how we can set up MySQL:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To install MySQL, we execute the following console commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The installation process triggers a console GUI interface that asks us to enter
    a `root` user password:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/7f664b9e-a662-4d17-9720-59a7faa92dcf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The provided password needs to be repeated for confirmation purposes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/15b71313-29a0-484f-a4dd-dfe8720e51b7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once the installation is done, we can execute the following `mysql --version`
    command to confirm if the MySQL server is up and running:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the server is running, we need to secure the installation. This is done
    by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The secure installation process triggers an interactive shell with several
    prompts, asking for the following information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter password for user root:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Would you like to setup VALIDATE PASSWORD plugin?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Please enter 0 = LOW, 1 = MEDIUM and 2 = STRONG:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'New password:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Re-enter new password:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remove anonymous users?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disallow root login remotely?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remove test database and access to it?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reload privilege tables now?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following screenshot depicts this process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/d8d43bee-0866-40bc-833e-396789e3bab1.png)Check out [https://dev.mysql.com/doc/refman/5.7/en/validate-password-plugin.html](https://dev.mysql.com/doc/refman/5.7/en/validate-password-plugin.html)
    for more information about the password validation plugin.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the secure installation process is done, we can go ahead and connect to
    MySQL using the `mysql` console tool, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice the use of the single quote character (`''`) around the password. While
    normally we could use the `"` or `''` quotes, the `!` char used in password forces
    us to use `''`. Without wrapping the password in a single quote, in this case,
    we will be seeing an error like !Tq: event not found. This is because the exclamation
    mark (`!`) is a part of the history expansion in bash. To use it as a part of
    the password, we need to enclose it in single quotes. Furthermore, our passwords
    can contain the `''` or `"` characters. To escape these quotes in the password,
    we can either use a leading backslash (), or enclose the entire argument in the
    opposite style of quotes. However, the simplest and safest way to get around quirky
    password characters is to avoid assigning the password value with `-p` or `--password`
    arguments, and provide the password through the Enter password: prompt.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This should give us the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ace8ab7e-822e-4aa2-aeee-6539546b5240.png)Check out [https://dev.mysql.com/doc/refman/5.7/en/mysql-shell.html](https://dev.mysql.com/doc/refman/5.7/en/mysql-shell.html)
    for more information about the MySQL shell.'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up sample data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we move onto querying MySQL, let''s go ahead and set up some sample
    data. MySQL provides a sample database called Sakila, which we can download from
    the official MySQL site, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Once downloaded and unpacked, this should give us the following three files:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ea9fa1b3-cc77-4f8b-be21-392a783d5243.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Moving forward, we need to see how we can import `sakila-schema.sql` and `sakila-data.sql`.
    Luckily, MySQL provides several ways to do this. A quick look at the `sakila-schema.sql`
    file shows the following entries at the top of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This means that the `sakila-schema.sql` file will create a schema (database)
    for us, as well as set it as currently used database. This is an important bit
    to understand, as not all of the `.sql` / backup files will have this, and we
    will be forced to do this part manually. Knowing how `sakila-schema.sql` handles
    everything we need to import it, the following commands show three different approaches
    we can use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The second command uses the `-e` (`--execute`)  argument to pass SQL statements
    to the server. We could have easily used the `mysql` tool interactively and then executed `SOURCE
    sakila-schema.sql` within it. With the schema in place, we can go ahead and import
    the actual data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If we now use the `mysql` tool interactively, we can check if the database
    is imported successfully:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This should give us the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/2b3df6df-212e-4f2d-919f-029daa68b9c7.png)Check out [https://dev.mysql.com/doc/sakila/en/](https://dev.mysql.com/doc/sakila/en/)
    for more information about the Sakila sample database.'
  prefs: []
  type: TYPE_NORMAL
- en: Querying via the MySQLi driver extension
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are several driver extensions that allow us to query MySQL. MySQLi is
    one of them. In order to use MySQLi on the console, we need to ensure that we
    have the PHP CLI and `mysql` driver extension installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note that the name of the extension lacks the `i` suffix. Once the `mysql` driver
    extension is installed, we can go ahead and start querying the MySQL server.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can either use the MySQLi functions or classes to interact with MySQL. In
    the spirit of OOP, we will use the class approach for all of our examples. Using
    the `mysqli` class, we can establish a MySQL connection from PHP, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This single line expression will look for MySQL on the `127.0.0.1` host and
    try to connect to its `sakila` database using the `root` username and `mL08e!Tq` as
    its password.
  prefs: []
  type: TYPE_NORMAL
- en: Error handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Handling errors around `mysqli` is relatively easy as we can use a simple `try...catch`
    block, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Ideally, we would want to use `mysqli_sql_exception` for more targeted MySQL
    exceptions-only handling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We can pass one of the following report levels to the `mysqli_report()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '`MYSQLI_REPORT_INDEX`: This reports if a bad index or no index at all was used
    in a query'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MYSQLI_REPORT_ERROR`: This reports errors from the MySQL function calls'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MYSQLI_REPORT_STRICT`: This reports `mysqli_sql_exception` instead of possible
    warnings'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MYSQLI_REPORT_ALL`: This reports everything'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MYSQLI_REPORT_OFF`: This reports nothing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While `MYSQLI_REPORT_ALL` may seem like an overkill, using it may pinpoint MySQL
    errors that are not obvious on the application level, such as the lack of an index
    on a column.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can select data from MySQL using the `query()` method of a `mysqli` instance,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding example gives the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'If we have used `MYSQLI_REPORT_STRICT` instead of `MYSQLI_REPORT_ALL`, we would
    not have got the error. However, using less restrictive error reporting is not
    a solution for mitigating the error. Even though we might not be in charge of
    the database architecture and maintenance, it is our duty as a developer to report
    overlooks like these as they will most definitely affect our application performance.
    A solution, in this case, is to actually create an index on the email column.
    We can do so easily via the following query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '![](assets/03089aff-be4e-4585-965d-fe41c12c0b33.png)'
  prefs: []
  type: TYPE_IMG
- en: '`idx_email` is the freely given name of the index we are creating, while `email`
    is the column for which we are creating an index. The `idx_` prefix is merely
    a matter of convention some developers use; the index can easily be named `xyz`
    or just `email`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'With the index in place, if we now try to execute the previous code, it should
    output MARIA MILLER, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/80f364e5-0d24-403b-85d8-5184b001d2f7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `query()` method returns either the `mysqli_result` object or the `True`
    and `False` Boolean value, based on the following type:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SELECT` type of query - `mysqli_result` object or Boolean `False`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SHOW` type of query - `mysqli_result` object or Boolean `False`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DESCRIBE` type of query - `mysqli_result` object or Boolean `False`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EXPLAIN` type of query - `mysqli_result` object or Boolean `False`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: other types of queries - Boolean `True` or `False`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The instance of the `mysqli_result` object has several different result fetching
    methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`fetch_object()`: This fetches the current row of a result set as an object,
    and allows being called repeatedly'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fetch_all()`: This fetches all result rows as either `MYSQLI_ASSOC`, `MYSQLI_NUM`,
    or `MYSQLI_BOTH`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fetch_array()`: This fetches a single result row as either `MYSQLI_ASSOC`,
    `MYSQLI_NUM`, or `MYSQLI_BOTH`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fetch_assoc()`: This fetches a single result row as an associative array,
    and allows being called repeatedly'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fetch_field()`: This fetches the next field in the result set, and allows
    being called repeatedly'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fetch_field_direct()`: This fetches meta-data for a single field'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fetch_fields()`: This fetches meta-data for fields in an entire result set'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fetch_row()`: This fetches a single result row as an enumerated array and allows
    being called repeatedly'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Binding parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'More often than not, querying data comes with data binding. Security-wise,
    data binding is the way to go, as we should never concatenate query string with
    variables on our own. This leads to SQL injection attacks. We can bind data into
    a query using the `prepare()` and `bind_param()` methods of the respective `mysqli`
    and `mysqli_stmt` instances, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This should give us the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/f135143d-8a93-4901-9830-db2de28fa206.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `bind_param()` method has an interesting syntax. It accepts two or more
    parameters. The first parameter--the `$types` string--contains one or more characters.
    These characters specify the types for the corresponding bind variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '`i`: This is the variable of a type integer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`d`: This is the variable of a type double'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`s`: This is the variable of a type string'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`b`: This is the variable of a type blob'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The second and all of the following parameters represent the binding variables.
    Our example uses `''iis''` for the `$types` parameter, which basically reads the
    `bind_param()` method and its parameters as: bind integer type (`$customerIdGt`), integer
    type (`$storeId`), and string type (`$email`).'
  prefs: []
  type: TYPE_NORMAL
- en: Inserting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have learned how to prepare a query and bind data to it, inserting
    new records becomes pretty easy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The example here pretty much follows the previous one where we introduced binding.
    The obvious difference merely lies in the actual `INSERT INTO` SQL expression.
    It goes without saying that `mysqli` does not have separate PHP classes or methods
    to handle selecting, inserting, or any other action.
  prefs: []
  type: TYPE_NORMAL
- en: Updating
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Much like selecting and inserting, we can also use the `prepare()`, `bind_param()`,
    and `execute()` methods to handle record updating, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Deleting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Again, we can use the `prepare()`, `bind_param()`, and `execute()` methods
    to handle record deleting, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Transactions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While the `SELECT`, `INSERT`, `UPDATE`, and `DELETE` methods allow us to manipulate
    data in a step-by-step manner, the real strength of MySQL lies in transactions.
    Using the `begin_transaction()`, `commit()`, `commit()`, and `rollback()` methods
    of an `mysqli` instance, we are able to control the transaction features of MySQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The valid transaction flags are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`MYSQLI_TRANS_START_READ_ONLY`: This matches the MySQL `START TRANSACTION READ
    ONLY` query'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MYSQLI_TRANS_START_READ_WRITE`: This matches the MySQL `START TRANSACTION
    READ WRITE` query'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MYSQLI_TRANS_START_WITH_CONSISTENT_SNAPSHOT`: This matches the MySQL `START
    TRANSACTION WITH CONSISTENT SNAPSHOT` query'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check out [https://dev.mysql.com/doc/refman/5.7/en/commit.html](https://dev.mysql.com/doc/refman/5.7/en/commit.html)
    for more information about the MySQL transaction syntax and meaning.
  prefs: []
  type: TYPE_NORMAL
- en: Querying via the PHP Data Objects driver extension
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **PHP Data Objects** (**PDO**) driver extension comes with PHP by default,
    ever since PHP 5.1.0.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using the PDO driver extension, we can connect to a MySQL database from PHP
    using the `PDO` class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This simple multiline expression will look for MySQL on the `127.0.0.1` host
    and try to connect to its `sakila` database using the `root` username and `mL08e!Tq`
    password.
  prefs: []
  type: TYPE_NORMAL
- en: Error handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Handling errors around PDO can be done using the special `PDOException` class,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'There are three different error modes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ERRMODE_SILENT`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ERRMODE_WARNING`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ERRMODE_EXCEPTION`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here, we are using `ERRMODE_EXCEPTION` in order to utilize the `try...catch`
    blocks.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Querying for records with `PDO` is somewhat similar to querying for records
    with `mysqli`. We use raw SQL statements in both cases. The difference lies in
    the convenience of PHP methods and the subtle differences they provide. The following
    example demonstrates how we can select records from a MySQL table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ba1f9b0a-105f-4977-9655-96ca820db1b1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The instance of the `PDOStatement` and `$result` object has several different
    result-fetching methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`fetch()`: This fetches the next row from a result set, allows being called repeatedly,
    and returns a value depending on the fetch style'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fetchAll()`: This fetches all of the result set rows as an array, and returns
    a value depending on the fetch style'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fetchObject()`: This fetches the next row from a result set as an object,
    and allows being called repeatedly'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fetchColumn()`: This fetches a single column from the next row of a result
    set, and allows being called repeatedly'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following list shows available PDO fetch styles:'
  prefs: []
  type: TYPE_NORMAL
- en: '`PDO::FETCH_LAZY`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PDO::FETCH_ASSOC`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PDO::FETCH_NUM`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PDO::FETCH_BOTH`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PDO::FETCH_OBJ`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PDO::FETCH_BOUND`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PDO::FETCH_COLUMN`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PDO::FETCH_CLASS`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PDO::FETCH_INTO`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PDO::FETCH_FUNC`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PDO::FETCH_GROUP`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PDO::FETCH_UNIQUE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PDO::FETCH_KEY_PAIR`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PDO::FETCH_CLASSTYPE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PDO::FETCH_SERIALIZE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PDO::FETCH_PROPS_LATE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PDO::FETCH_NAMED`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While most of these fetch styles are quite self-explanatory, we can consult [http://php.net/manual/en/pdo.constants.php](http://php.net/manual/en/pdo.constants.php) for
    further details.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example demonstrates a more elaborate select approach, one with
    parameter binding in the mix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/083fe023-37f4-4e94-b8c7-a181425e22ef.png)'
  prefs: []
  type: TYPE_IMG
- en: The most obvious difference between binding with `PDO` and binding with `mysqli`
    is that `PDO` allows named parameter binding. This makes for much more readable
    queries.
  prefs: []
  type: TYPE_NORMAL
- en: Inserting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Much like selecting, inserting involves the same set of PDO methods wrapped
    around the `INSERT INTO` SQL statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Updating
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Much like selecting and inserting, updating involves the same set of PDO methods
    wrapped around the `UPDATE` SQL statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Deleting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Much like selecting, inserting, and updating, deleting involves the same set
    of PDO methods wrapped around the `DELETE FROM` SQL statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Transactions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Transactions with PDO are not much different from those with MySQLi. Utilizing
    the `beginTransaction()`, `commit()`, and `rollback()` methods of the `PDO` instance,
    we are able to control the transaction features of MySQLi:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Working with MongoDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MongoDB is a free and open source NoSQL database developed by MongoDB Inc.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the key strengths of MongoDB can be outlined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: It is a document-based database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is cross-platform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It runs on a single server as well as on distributed architectures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can be used for desktop and web applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It uses JSON objects to store data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can use JavaScript map-reduce for information processing at the server side
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It processes large volumes of data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It aggregates calculations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It supports fields, range queries, and regular expression searches
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is a native replication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing MongoDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Assuming we are using the fresh Ubuntu 16.10 (Yakkety Yak) installation, the
    following steps outline how we can setup MongoDB:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will install MongoDB using the following console command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'To further check that MongoDB is successfully installed and running, we can
    execute the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This should give us the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/c1e47bda-507b-4206-bfcc-d595cda6935e.png)'
  prefs: []
  type: TYPE_IMG
- en: Setting up sample data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Running the `mongo` command on the Ubuntu terminal gets us into a mongo interactive
    shell. From here on, with a simple few commands, we can add the sample data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This should give us an output much like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/f83de627-4f06-4e31-acf9-62d4bf809f6f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Using `use foggyline` and `db.products.find()`, we are able to now list all
    the entries added to the `products` collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/f077bd4e-6193-4bee-a8d0-2b4324c8b276.png)'
  prefs: []
  type: TYPE_IMG
- en: Querying via the MongoDB driver extension
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We need to make sure we have the PHP CLI and MongoDB driver extension installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Upon successful execution of these commands, we can confirm that the `mongodb` driver
    extension is installed, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/7f71d7c9-2572-404e-8bae-5b02547f3110.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Aside from the driver extension, we also need a `mongodb/mongodb` composer
    package added to our project directory. We can do so by running the following
    console command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Assuming we have the `mongo.php` file within our project directory, all it
    takes is to load the MongoDB library, and start working with Mongo database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Connecting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using the `mongodb` driver extension and the `mongodb/mongodb` PHP library,
    we can connect to the Mongo database from PHP using the `MongoDBDriverManager`
    class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This single-line expression will look for MongoDB on `localhost` under port
    `27017`.
  prefs: []
  type: TYPE_NORMAL
- en: Error handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Handling errors is pretty straightforward with the `try...catch` blocks, as `MongoDBDriverExceptionException`
    is being thrown whenever an error occurs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Selecting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Fetching data with MongoDB comes down to working with three different classes,
    `MongoDBDriverManager`, `MongoDBDriverQuery`, and `MongoDBDriverReadPreference`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/8dc9e943-de05-44f8-8ddf-0a23749090bc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The list of query operators we can pass onto `$filter` is quite an extensive one,
    but the following comparison operators may be the most interesting ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$eq`: These match all values that are equal to a specified value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$gt`: These match all values that are greater than a specified value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$gte`: These match all values that are greater than or equal to a specified
    value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$lt`: These match all values that are less than a specified value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$lte`: These match all values that are less than or equal to a specified value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$ne`: These match all values that are not equal to a specified value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$in`: These match all values that are specified in an array'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$nin`: These match the none values that are specified in an array'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check out [ttps://docs.mongodb.com/manual/reference/operator/query/](https://docs.mongodb.com/manual/reference/operator/query/) for
    a full list of MongoDB query and projection operators.
  prefs: []
  type: TYPE_NORMAL
- en: 'The list of query options we can pass onto `$queryOptions` is equally impressive,
    but the following options may be the essential ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '`collation`: These allow specifying language-specific rules for string comparison'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`limit`: These allow specifying the maximum number of documents to return'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`maxTimeMS`: These set the processing operations time limit in milliseconds'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`projection`: These allow specifying which fields to include in the returned
    documents'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sort`: These allow specifying sort ordering of the results'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check out [http://php.net/manual/en/mongodb-driver-query.construct.php](http://php.net/manual/en/mongodb-driver-query.construct.php) for
    a full list of the `MongoDBDriverQuery` query options.
  prefs: []
  type: TYPE_NORMAL
- en: Inserting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Writing new data with MongoDB comes down to working with three different classes,
    `MongoDBDriverManager`, `MongoDBDriverBulkWrite`, and `MongoDBDriverWriteConcern`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The instance of `BulkWrite` can store one or more insert statements through
    the `insert()` method. We then simply pass `$bulkWrite` and `$writeConcern` to
    `executeBulkWrite()` on the `$manager` instance. Once executed, we can observe
    the newly added records through the `mongo` shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/dca64ccf-a77c-4baf-8350-0a99565ef598.png)'
  prefs: []
  type: TYPE_IMG
- en: Updating
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Updating existing data is a nearly identical process as writing new data. The
    obvious difference being the use of the `update()` method on the `MongoDBDriverBulkWrite`
    instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The `update()` method accepts three different parameters: filter, a new object, and update
    options. The `multi` option passed under update options, tells if all documents''
    matching criteria will be updated. The `upsert` option passed under update options,
    controls the creation of a new record if the existing record is not found. The
    resulting change can be observed through the `mongo` shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/bef46af0-ec27-46f9-9912-9215f17ee3c7.png)'
  prefs: []
  type: TYPE_IMG
- en: Deleting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Deletion is done in a manner similar to write and update, in that it uses an
    instance of the `MongoDBDriverBulkWrite` object. This time, we are using the instance
    `delete()` method, which accepts filter and delete options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the `false` value for the `limit` option, we are effectively asking to
    delete all matching documents. Using the `mongo` shell, we can observe the changes
    shown in the following  screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/75596302-1926-4aa5-a7ad-a598e97a3dde.png)'
  prefs: []
  type: TYPE_IMG
- en: Transactions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MongoDB does not have a full **ACID** (**Atomicity, Consistency, Isolation,
    Durability**) support in a sense that MySQL has. It supports ACID transactions
    only at the document level. The multi-document transactions are not supported. The
    lack of ACID compliance certainly limits its use with platforms that depend on
    this feature. This is not to say that MongoDB cannot be used with such platforms.
    Let's consider a popular Magento e-commerce platform. There is nothing preventing
    Magento from adding MongoDB to the mix. While the MySQL features can guarantee
    ACID compliance around sales-related functionality, MongoDB can be used within
    the conjunction to cover bits around catalog functionality. This type of symbiosis can
    then easily bring the best of both database features to our platform.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Redis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Redis is an open source, in-memory data structure store, whose development is
    sponsored by Redis Labs. The name originated from **REmote DIctionary Server**.
    It currently ranks as one of the most popular key-value databases.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the key strengths of Redis can be outlined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: In-memory data structure store
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Key-value data store
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keys with a limited time-to-live
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Publish/subscribe messaging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can be used for cache data stores
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transactions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Master-slave replication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing Redis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Assuming we are using the fresh Ubuntu 16.10 (Yakkety Yak) installation, the
    following steps outline how we can setup the Redis server:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can install the Redis server using the following console commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'This should give us the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/e171ce49-e5c7-4be9-9cef-c9d54b12f95e.png)'
  prefs: []
  type: TYPE_IMG
- en: Setting up sample data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Running the `redis-cli` command on the Ubuntu terminal gets us into the Redis interactive
    shell. From here on, with a simple few commands, we can add the following sample
    data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'This should give us the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/d182d03c-9f1a-4e64-a1c7-b1187fa08bbf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Using the `KEYS *` command within the `redis-cli` shell, we are able to now
    list all the entries added by Redis:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/2264aaab-0740-45d0-b8d6-96a37f4e7146.png)'
  prefs: []
  type: TYPE_IMG
- en: Querying via the phpredis driver extension
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we start querying, we need to ensure that we have the PHP CLI and `phpredis` driver
    extension installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Upon successful execution of these commands, we can confirm that the `phpredis` driver
    extension is installed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/6bcd8954-b17a-4e94-94cc-e53c94316c88.png)'
  prefs: []
  type: TYPE_IMG
- en: Connecting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using the `phpredis` driver extension, we can connect to Redis from PHP using
    the `Redis` class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: This single-line expression will look for Redis on localhost under port `6379`.
  prefs: []
  type: TYPE_NORMAL
- en: Error handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `phpredis` driver extension throws `RedisException` for every error that
    occurs using the `Redis` class. This makes it easy to handle errors via simple `try...catch`
    blocks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Selecting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Given that Redis is a key value store, selecting keys is as easy as using a
    single `get()` method of the `Redis` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'This should give us the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/61576137-5dfa-4782-8aa2-c02a063425cd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `Redis` client class also provides the `mget()` method, which is able to
    fetch more than one key value at a time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'This should give us the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/82bc6db8-3fc6-4983-ac5b-7045e0e301c4.png)'
  prefs: []
  type: TYPE_IMG
- en: Inserting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The simplicity behind the Redis key-value mechanism makes for a simple and
    straightforward `set()` method, through which we insert new entries, as shown
    in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'This should give us the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/50b0a300-61e0-4d2f-b323-84dc6a9ca282.png)'
  prefs: []
  type: TYPE_IMG
- en: We should be careful when using the set methods with non-string like structures.
    The `user` key value resulted in the Array string being stored in Redis, and not
    the actual array structure. This is easily sorted by converting our array structure
    to JSON using `json_encode()`, right before we pass it onto the `set()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'One great benefit of the `set()` method is that it supports the timeout in
    seconds, so we can easily write expressions such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Although, calling the `setex()` method is the preferred way for when we want
    to add a timeout to our keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Timeouts are a great feature to use when using Redis as a cache database. They basically
    automate the cache lifetime for us.
  prefs: []
  type: TYPE_NORMAL
- en: Updating
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Updating a value via the Redis client is the same as inserting it. We use the
    same `set()` method, with the same key. The new value simply overwrites the previous
    one, if any exists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Deleting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Removing records from Redis is as easy as calling the Redis client `del()`
    method and passing it the key that we want to delete:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Transactions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Much like MongoDB, Redis also does not have ACID support in a sense that MySQL
    has, which is alright really, as Redis is just a key/value store and not a relational
    database. Redis, however, provides a level of atomicity. Using `MULTI`, `EXEC`,
    `DISCARD`, and `WATCH`, we are able to execute a group of commands within a single
    step, during which Redis makes the following two guarantees:'
  prefs: []
  type: TYPE_NORMAL
- en: Another client request can never be served in the middle of our group-commands
    execution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Either all or none of the commands are processed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The `$result2`  value comes out as `false`, which triggers `$client->discard();`.
    Although, `result1` is a valid expression, it came after the `$client->multi();`
    call, which means that its command is not really processed; so, we don't get to
    see the `Test#1` value stored in Redis. Although there is no classically looking
    rollback mechanism, like we had with MySQL, this makes for a nice transaction
    model.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this chapter, we touched upon the basics of querying three very different
    database systems.
  prefs: []
  type: TYPE_NORMAL
- en: The MySQL database has been around for a very long time, and is likely the number
    one database for most PHP applications. Its ACID compliance makes it irreplaceable
    for applications dealing with financial or other sensitive data where atomicity,
    consistency, isolation, and durability are key factors.
  prefs: []
  type: TYPE_NORMAL
- en: Mongo, on the other hand, tackles data storage through a schema-less approach.
    This makes it much easier for developers to pace up application development, although
    the lack of ACID compliance across documents limits its use in certain types of
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the Redis data store serves as a great caching, or even a session-storing
    solution for our applications.
  prefs: []
  type: TYPE_NORMAL
- en: Moving forward, we will take a closer look at dependency injection, what it
    is, and what role does it have within modular applications.
  prefs: []
  type: TYPE_NORMAL
