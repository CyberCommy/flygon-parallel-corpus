- en: Chapter 8. Offline Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will cover the basics of offline application development.
    Specifically, we’ll discuss the application manifest, including the advantages
    and disadvantages, and see how we can handle offline interactions. Then we’ll
    jump into how `localStorage` and `IndexedDB` can be used to temporarily store
    data on the client side. The content in this chapter will be supplemented with
    basic examples that will help you get up and going quickly. So, let’s start out
    by covering how the application manifest is beneficial for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: The application manifest
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling offline interactions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `localStorage` and `IndexedDB` APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application Cache
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Application Cache**, or otherwise known as **AppCache** , allows you to define
    the resources that should be cached and available during offline use. This essentially
    makes your web application usable when the user is offline, and thus losing network
    connectivity or even refreshing the page will not affect your users'' connectivity,
    and they will still be able to interact with your application. Let’s get started
    by taking a look at what the application cache manifest looks like.'
  prefs: []
  type: TYPE_NORMAL
- en: The manifest file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our application manifest file contains the information regarding what resources
    will be cached by the file. It explicitly informs the browser of the resources
    you want to be made available offline, making it accessible for offline use, but
    also speeding up the page load through caching. The following code showcases a
    basic example of what a cache manifest looks like for the examples that accompany
    this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, there are a couple of things happening. First, we
    identify the cache manifest using the all-caps word, `CACHE MANIFEST`. This line
    is required and read by the browser to be exactly what it is, a cache manifest.
    The next line defines a file we would like to cache, `index.html`. Now, there
    is something we need to keep in mind; this manifest file is relative to where
    we are. This means that our file is located where `index.html` is in a directory
    (for example, `offline.appcache` is located at `localhost/`, just like `index.html`).
  prefs: []
  type: TYPE_NORMAL
- en: Moving on, we find that we can include comments in our manifest file by including
    the pound sign in front (`#stylesheets`). This helps us keep track of what’s going
    on in this file. From here on out, we define the stylesheets and scripts that
    we would like to define relative to the page being viewed. At this time, we are
    looking at a real manifest file and breaking it down to understand it. As we progress
    through the chapter, we’ll come back to this file and see how it affects the example
    built in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Manifest implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to effectively use our cache manifest, we need to be able to associate
    it with the current page. But to do this, we also need to set up our server to
    handle the manifest correctly by sending over the correct MIME-type. Each type
    of server handles this a bit differently, and the directives may seem different,
    but they all achieve the same results—sending the correct type of header associated
    with that file.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Apache, our configuration would look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we have defined all files of type `.appcache` to be delivered
    with a content type of `text`/`cache-manifest`. This allows the browser to interpret
    the file correctly, and thus the browser associates it as `cache-manifest`. Although
    this is great, we are not yet done. To finish up, we need our page to define this
    file so that it is associated correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make our cache manifest related to our page, we need to set the `manifest`
    attribute on our HTML tag like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We are now done defining our application cache manifest and delivering it with
    the related page, but we have only briefly touched upon this technology. To fully
    understand its power, we need to see this in use. So we’ll go ahead and create
    a simple example that gets us using what we have learned so far.
  prefs: []
  type: TYPE_NORMAL
- en: A simple example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our example for this chapter will be based on the previous chapter. For this
    reason, we won’t go into detail on the structure, styling, or scripts used to
    create this sample. However, it will be stripped down to an essential profile
    view that will allow you to understand offline applications without any additional
    knowledge needed from previous chapters. To begin with, let’s look at our markup.
  prefs: []
  type: TYPE_NORMAL
- en: The markup
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As always, the source code accompanying this book contains everything you need
    to get started with this chapter’s goals. So, let’s look at the meat of this sample
    and examine how this example will function, starting with the markup. If you open
    the index file located in the `offline` directory, you’ll notice that our content
    should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As with any web application, especially those written in this book, this is
    just an excerpt of the overall application architecture, which would contain a
    header, footer, stylesheets, and scripts. But, the preceding markup describes
    a profile view that displays a user’s information, including a short bio, age,
    and birth date. Along with this information is a form that allows you to update
    such information.
  prefs: []
  type: TYPE_NORMAL
- en: The experience for this application is as follows. First, when the user loads
    the page they should see all the information associated with them. Secondly, they
    will have the option to edit this information using a hyperlink with the text
    **Edit**. When the hyperlink is clicked, a form will appear that allows the user
    to edit their information. Accordingly, the **Edit** hyperlink will update to
    **View Profile**. Lastly, when the user clicks on **View Profile**, the form will
    hide and the display of the user’s information will reappear.
  prefs: []
  type: TYPE_NORMAL
- en: The JavaScript
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This isn’t as complicated as it sounds. In fact, the script that is used to
    create the functionality of the page is dependent on the following script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Let’s look at what’s going on in the preceding code to make sure no one is lost.
    First, we cache the elements appropriate to our page. In this way, we are optimizing
    the performance by not traversing the DOM every time we need to look something
    up. Then, we define our `onEditClick` and `onViewClick` event handlers, which
    show or hide the appropriate content blocks and then update the `text` and `href`
    properties of the anchor tag it relates to. Finally, we attach the `click` event
    on the anchor tags to the cached `$viewProfile` element.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that the preceding JavaScript is an excerpt of the book’s accompanying
    source code for this chapter. For simplicity, we have removed the closure and
    `Offline` class in order to better explain the meat and bones of the application
    being built here. Of course, you are welcome to either use the preceding code
    as is, or continue using the book’s source code. Whichever way you choose, the
    desired outcome will be an application that shows or hides content based on the
    current state.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the preceding code is executed and the page is loaded, these are the following
    states of the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The JavaScript](img/1024OT_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Initial application state and application edit state
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a solid foundation of what the application should look like
    when we interact with it, we want to make sure that it gets cached. By implementing
    the techniques given at the beginning of our application, we should have an application
    that now functions offline.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that we need to place the application cache manifest in the same directory
    as the sample application that is being built here. So, our application manifest
    needs to exist in the offline directory along with our `index.html` file. If you
    look at the source code for this chapter, you should see a working example of
    the structure and layout of our manifest and source files. Running this application
    on a server configured correctly will render our page offline. But the question
    is, how do we debug something like this? Well, this is what the next section tackles.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging the cache manifest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Debugging our offline applications is extremely important, after all, if our
    application depends on network connectivity, it’s crucial we deliver an alternative
    experience that is successful to our users. However, it is not easy to debug an
    offline application. There are several reasons for this, but it’s mostly based
    on the implementation of the application cache interface.
  prefs: []
  type: TYPE_NORMAL
- en: When Safari revisits your site, the site is loaded from the cache. If the cache
    manifest has changed, Safari checks the HTML file that declares the cache, as
    well as each resource listed in the manifest, to see if any of them has changed.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '>'
  prefs: []
  type: TYPE_NORMAL
- en: A file is considered unchanged if it is byte-for-byte identical to the previous
    version; changing the modification date of a file does not trigger an update.
    You must change the contents of the file. (Changing a comment is sufficient.)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'This can be found in the Apple documentation at: [https://developer.apple.com/library/safari/#documentation/iPhone/Conceptual/SafariJSDatabaseGuide/OfflineApplicationCache/OfflineApplicationCache.html#//apple_ref/doc/uid/TP40007256-CH7-SW5](https://developer.apple.com/library/safari/#documentation/iPhone/Conceptual/SafariJSDatabaseGuide/OfflineApplicationCache/OfflineApplicationCache.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Debugging in the browser
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Based on the previous documentation, we can improve the debugging process by
    clearing the cache with updated resources. This could be as simple as updating
    a comment in our code, but to ensure that the correct assets are being cached,
    we can use modern browsers and use the debugger tools to review the assets being
    cached. Review the following screenshots to see how you can test that your assets
    are being cached:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Debugging in the browser](img/1024OT_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Safari developer tools – resources
  prefs: []
  type: TYPE_NORMAL
- en: The developer tools in Safari, shown in the preceding screenshot, help us debug
    our application cache by providing a **Resource** tab that allows us to analyze
    the application cache for multiple domains. In this example, we can see the resources
    related to the domain for our sample application. When we review the application
    cache, we can see a list of files associated with the cache to the right. Additionally,
    we can see the location of the file and the status of the user; in this case,
    we are online and idle.
  prefs: []
  type: TYPE_NORMAL
- en: '![Debugging in the browser](img/1024OT_08_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Chrome developer tools – resources
  prefs: []
  type: TYPE_NORMAL
- en: The Chrome developer tools similarly help display information related to the
    application cache. Although the user interface is a bit different, it contains
    all the same components needed to review the assets associated with your application
    cache. This view also includes the online status of your application; in this
    example, we are not online and idle.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging using JavaScript
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The application cache can also be debugged using JavaScript, and luckily for
    us, the implementation of the application cache manifest is extremely easy to
    interact with. There are multiple events we can listen to, including `progress`,
    `error`, and `updateready`. When we listen to these events, we can choose to implement
    a supplementary experience, but for our use case here, we’ll just log out the
    event.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding script, we listen to the events defined by the specification
    ([http://www.whatwg.org/specs/web-apps/current-work/#appcacheevents](http://www.whatwg.org/specs/web-apps/current-work/#appcacheevents))
    and call either the `handleCacheEvent` or `handleCacheError` methods. In each
    of these methods, we just log out the event itself; however, if we wanted to,
    we could create an alternate experience.
  prefs: []
  type: TYPE_NORMAL
- en: There are also a number of action methods that can be employed during the implementation
    of the application cache process. For example, we could manually update the cache
    using the `update` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Although the preceding method could be helpful for us, remember that the cache
    will only update if the contents themselves have changed. In reality, the `update`
    method triggers the download process ([http://www.whatwg.org/specs/web-apps/current-work/#application-cache-download-process](http://www.whatwg.org/specs/web-apps/current-work/#application-cache-download-process)),
    which does not tell the browser to get the latest cache. The `swapCache` method
    is another action call that can be used to debug our applications by switching
    the cache to the latest version.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Keep in mind that if we make this call, the assets are not updated automatically.
    The way we get the updated assets are on a page refresh. Based on the specification,
    an easier way to do what we need here would be to do `location.reload()` ([http://www.whatwg.org/specs/web-apps/current-work/#dom-appcache-swapcache](http://www.whatwg.org/specs/web-apps/current-work/#dom-appcache-swapcache)).
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we have a good idea about the application cache manifest, including
    how it functions, the implementation details, and ultimately how to debug it.
    Now we need to know how to handle offline interactions using the preceding methods
    and more. When we have a good understanding of both aspects, we’ll be able to
    create simple offline applications that utilize this technology.
  prefs: []
  type: TYPE_NORMAL
- en: Handling offline applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, we have learned how to cache our files on the client side using
    the application manifest interface to not only speed up our site, but also make
    it available to our users when they are offline. However, this technique doesn’t
    take into account what you should do to handle interactions by the user. In this
    case, we need to make sure our application has usable parts that can make the
    application seamless when they lose connection.
  prefs: []
  type: TYPE_NORMAL
- en: A simple use case
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we proceed, let’s define a simple use case for why handling an offline
    application is useful to both the user and us. Let’s say we have a user named
    John, and John is commuting to work and is currently updating his profile in a
    web application on his iPhone. The commute involves some spotty network connections,
    and sometimes he does lose connection. He would like to be able to continue using
    the application while he is on his way to work, instead of waiting to do so at
    work.
  prefs: []
  type: TYPE_NORMAL
- en: Given the world we live in today, and how a spotty interaction could really
    cost a company a customer, we definitely want to handle this gracefully. It doesn’t
    mean that we will provide all the services to the user while they are offline,
    that would be unreasonable. What this does mean is that we need to inform the
    user that they are offline and that certain features are currently disabled for
    this reason.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting network connectivity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, you may be asking, “How do you detect a network connection?” Well, it’s
    actually pretty simple. Let’s take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Let’s review the preceding code briefly. The first part of this code creates
    a cached element in memory and stores it in the `$p` variable. The next line,
    which is the most important, detects online connectivity by checking the `navigator`
    object’s `onLine` property. If the person is not online, we finally set the text
    of that cached element and append it to our previous code.
  prefs: []
  type: TYPE_NORMAL
- en: 'If our application were offline, it would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Detecting network connectivity](img/1024OT_08_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Detecting network connectivity
  prefs: []
  type: TYPE_NORMAL
- en: Of course, this is a stripped down version of how you would handle network connectivity
    in your real-world applications, but it showcases that you can pick up the status
    of the network and determine the experience offline. This is great for us because
    it opens up a new world in web development that we haven’t been able to explore.
    But of course, this also entails some complex forethought into how such experiences
    are handled.
  prefs: []
  type: TYPE_NORMAL
- en: Going back to the use case we defined, the user wanted to update his/her profile
    information, and obviously this would be extremely difficult to achieve without
    the necessary resources. Fortunately for us, there are two new technologies we
    can use to accomplish simple tasks similar to this use case. So, let’s briefly
    go over these two technologies.
  prefs: []
  type: TYPE_NORMAL
- en: The localStorage API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although offline status is a feature of the new HTML5 specification, it goes
    hand in hand with another feature of HTML5, namely storage ([http://dev.w3.org/html5/webstorage/](http://dev.w3.org/html5/webstorage/)).
    Storage is something that many developers have thought previously to be a one-to-one
    relationship with a backend system. This is no longer true, since we are now able
    to save data on the client device using the `localStorage` API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s cover a brief example using `localStorage` to see how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The code we just wrote here has multiple parts to it. First, there is a global
    object named `localStorage`. This object has methods that a developer can interact
    with, including the `setItem` method. Lastly, the `setItem` method takes two parameters,
    both of which are strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'To retrieve the value of the item we just set, we would do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Pretty cool, huh? The only downside is that the current implementation of this
    describes the API as only accepting strings for each key/value pair, similar to
    a JavaScript object. However, we can go beyond this limitation by doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The difference here is that we are also accessing the built-in `JSON` object
    that turns the object into a string so that the `localStorage` API can efficiently
    store this as a plain string. Otherwise, you would store `[object Object]`, which
    is just the type of the object.
  prefs: []
  type: TYPE_NORMAL
- en: 'To access this information, we would do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: When you run this code in the console, you should then see an object. What the
    `JSON` functionality has done is turn the “stringified” object into a traditional
    JavaScript object. This makes accessing the data we have stored easy and efficient.
  prefs: []
  type: TYPE_NORMAL
- en: As you can start to gather, we have the power to store information on the client
    side that we could not in the past, allowing us to temporarily allow the user
    to interact with certain aspects of the site while the application is offline.
    Combining the storage and offline features of HTML5 allows us to bring deeper
    interactions to our applications while meeting client and user expectations.
  prefs: []
  type: TYPE_NORMAL
- en: However, the limitation to `localStorage` is the amount of information that
    can be stored. For this reason, another technology exists, called `IndexedDB`.
    Although its support is not consistent and the technology is still in experimental
    stages across browsers, it’s worth taking a look at. Unfortunately, we won’t cover
    that technology in this book, due to its lack of support in iOS Safari, but it’s
    still worth some review ([https://developer.mozilla.org/en-US/docs/IndexedDB](https://developer.mozilla.org/en-US/docs/IndexedDB)).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered the basics of application cache including an example
    of its implementation. Our review pointed out the benefits of using this new technology,
    but also discussed the downsides, such as the inconsistent support, mostly with
    older browsers, and the issues we face when testing it. We learned how to handle
    offline interactions and how `localStorage` and `IndexedDB` allow us to store
    information temporarily on the client side as a solution. In the next chapter,
    we’ll discuss performance optimization and see how this has played out in the
    application developed in this book.
  prefs: []
  type: TYPE_NORMAL
