- en: Arrays and Lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a developer, you have certainly stored various collections within your applications,
    such as user data, books, and logs. One of the natural ways of storing such data
    is by using arrays and lists. However, have you ever thought about their variants?
    Have you heard about jagged arrays or circular-linked lists? In this chapter you
    will see such data structures in action, together with examples and detailed descriptions.
    That is not all, because the chapter is related to many topics regarding arrays
    and lists, suitable for developers with various levels of programming skills.
  prefs: []
  type: TYPE_NORMAL
- en: At the start of the chapter, the arrays will be presented and divided into single-dimensional,
    multi-dimensional, and jagged arrays. You will also get to know four sorting algorithms,
    namely selection, insertion, bubble sort, and quicksort. For each of them, you
    will see an illustration-based example, the implementation code, and a step-by-step
    explanation.
  prefs: []
  type: TYPE_NORMAL
- en: The arrays have a lot of possibilities. However, generic lists available while
    developing in the C# language are even more powerful. In the remaining part of
    the chapter, you will see how to use a few variants of lists, such as simple,
    sorted, double-linked, and circular-linked. For each of them, the C# code of an
    example will be shown with a detailed description.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sorting algorithms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simple lists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sorted lists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linked lists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Circular-linked lists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start with the array data structure. You can use it to store many variables
    of the same type, such as `int`, `string`, or a user-defined class. As mentioned
    in the introduction, while developing applications in the C# language, you can
    benefit from a few variants of arrays, as presented in the following diagram.
    You have access not only to single-dimensional arrays (indicated as **a**), but
    also multi-dimensional (**b**), and jagged (**c**). Examples of all of them are
    shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9fefe52c-959d-4887-aa69-dfc748aab7a9.png)'
  prefs: []
  type: TYPE_IMG
- en: What is important is that the number of elements in an array cannot be changed
    after initialization. For this reason, you will not be able to easily add a new
    item at the end of the array or insert it in a given position within the array.
    If you need such features, you can use other data structures described in this
    chapter, such as generic lists.
  prefs: []
  type: TYPE_NORMAL
- en: You can find more information about arrays at [https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/arrays/](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/arrays/).
  prefs: []
  type: TYPE_NORMAL
- en: After this short description, you should be ready to learn more about particular
    variants of arrays and to take a look at some C# code. Thus, let's proceed to
    the simplest variant of arrays, namely single-dimensional ones.
  prefs: []
  type: TYPE_NORMAL
- en: Single-dimensional arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A single-dimensional array stores a collection of items of the same type, which
    are accessible by an index. It is important to remember that indices of arrays
    in C# are zero-based. This means that the first element has an index equal to
    **0**, while the last one—length of the array minus one.
  prefs: []
  type: TYPE_NORMAL
- en: 'The example array is shown in the preceding diagram (on the left, indicated
    by **a**). It contains five elements with the following values: **9**, **-11**,
    **6**, **-12**, and **1**. The first element has an index equal to **0**, while
    the last one has an index equal to **4**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To use a single-dimensional array, you need to declare and initialize it. The
    declaration is very simple, because you just need to specify a type of element
    and a name, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The declaration of an array with integer values is shown in the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you know how to declare an array, but what about the initialization? To
    initialize the array elements to default values, you can use the `new` operator,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, you can combine a declaration and initialization in the same line,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Unfortunately, all the elements currently have default values, that is, zeros
    in the case of integer values. Thus, you need to set the values of particular
    elements. You can do this using the `[]` operator and an index of an element,
    as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Moreover, you can combine a declaration and initialization of array elements
    to specific values using one of the following variants:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'When you have the proper values of elements within an array, you can get values
    using the `[]` operator and by specifying the index, as shown in the following
    line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Here, you get a value of the third element (the index equal to `2`) from the
    array named `numbers` and store it as a value of the `middle` variable.
  prefs: []
  type: TYPE_NORMAL
- en: More information about single-dimensional arrays is available at [https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/arrays/single-dimensional-arrays](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/arrays/single-dimensional-arrays).
  prefs: []
  type: TYPE_NORMAL
- en: Example – month names
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To summarize the information you have learned about single-dimensional arrays,
    let's take a look at a simple example, where the array is used to store names
    of months in English. Such names should be obtained automatically, not by hardcoding
    them in the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: At the start, a new single-dimensional array is declared and initialized with
    default values. It contains `12` elements to store names of months in a year.
    Then, the `for` loop is used to iterate through the numbers of all months, that
    is, from `1` to `12`. For each of them, the `DateTime` instance representing the
    first day in a particular month is created.
  prefs: []
  type: TYPE_NORMAL
- en: The name of the month is obtained by calling the `ToString` method on the `DateTime`
    instance, passing the proper format of the date (`MMMM`), as well as specifying
    the culture (`en` in the example). Then, the name is stored in the array using
    the `[]` operator and an index of the element. It is worth noting that the index
    is equal to the current value of the `month` variable minus one. Such subtraction
    is necessary, because the first element in the array has an index equal to zero,
    not one.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next interesting part of the code is the `foreach` loop, which iterates
    through all elements of the array. For each of them, one line is shown in the
    console, namely the name of the month after `->`. The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As mentioned earlier, single-dimensional arrays are not the only available variant.
    You will learn more about multi-dimensional arrays in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Multi-dimensional arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The arrays in the C# language do not need to have only one dimension. It is
    also possible to create two-dimensional or even three-dimensional arrays. To start
    with, let''s take a look at an example regarding the declaration and initialization
    of a two-dimensional array with `5` rows and `2` columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to create a three-dimensional array, the following code can be
    used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, you can also combine a declaration with an initialization, as shown
    in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Some small explanation is necessary for the way you access particular elements
    from a multi-dimensional array. Let''s take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In the first line of code, the value from the third row (index equal to `2`)
    and second column (index equal to `1`) is obtained (that is, `115`) and set as
    a value of the `number` variable. The other line replaces `-11` with `11` in the
    second row and first column.
  prefs: []
  type: TYPE_NORMAL
- en: More information about multi-dimensional arrays is available at [https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/arrays/multidimensional-arrays](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/arrays/multidimensional-arrays).
  prefs: []
  type: TYPE_NORMAL
- en: Example – multiplication table
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first example shows basic operations on a two-dimensional array with the
    purpose of presenting a multiplication table. It writes the results of the multiplication
    of all integer values in the range from `1` to `10`, as shown in the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a look at the method of declaration and initialization of the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Here, a two-dimensional array with `10` rows and `10` columns is created and
    its elements are initialized to default values, that is, to zeros.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the array is ready, you should fill it with the results of the multiplication.
    Such a task can be performed using two `for` loops:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, you can find the `GetLength` method, which is called
    on an array object. The method returns the number of elements in a particular
    dimension, that is, the first (when passing `0` as the parameter) and the second
    (`1` as the parameter). In both cases, a value of `10` is returned, according
    to the values specified during the array initialization.
  prefs: []
  type: TYPE_NORMAL
- en: Another important part of the code is the way of setting a value of an element
    in a two-dimensional array. To do so, you need to provide two indices, such as
    `results[i, j]`.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end, you just need to present the results. You can do so using two `for`
    loops, as in the case of filling the array. This part of the code is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The multiplication results, after conversion to `string` values, have different
    lengths, from one character (as in the case of `4` as a result of `2*2`) to three
    (`100` from `10*10`). To improve the presentation, you need to write each result
    always on `4` chars. Therefore, if the integer value takes less space, the leading
    spaces should be added. As an example, the result 1 will be shown with three leading
    spaces (`___1`, where `_` is a space), while `100` with only one (`_100`). You
    can achieve this goal by using the proper composite format string (namely `{0,4}`)
    while calling the `Write` method from the `Console` class.
  prefs: []
  type: TYPE_NORMAL
- en: Example – game map
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another example of the application of a two-dimensional array is a program
    that presents a map of a game. The map is a rectangle with 11 rows and 10 columns.
    Each element of the array specifies a type of terrain as grass, sand, water, or
    wall. Each place on the map should be shown in a particular color (such as green
    for grass), as well as using a custom character that depicts the terrain type
    (such as `≈` for water), as shown in the screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dd73ef8b-693e-4a5d-b14c-2af5879f2233.png)'
  prefs: []
  type: TYPE_IMG
- en: 'At the start, let''s declare the enumeration value, named `TerrainEnum`, with
    four constants, namely `GRASS`, `SAND`, `WATER`, and `WALL`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: To improve the readability of the whole project, it is recommended to declare
    the `TerrainEnum` type in a separate file, named `TerrainEnum.cs`. This rule should
    also be applied to all user-defined types, including classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, you create two extension methods that make it possible to get a particular
    color and character depending on the terrain type (`GetColor` and `GetChar`, respectively).
    Such extension methods are declared within the `TerrainEnumExtensions` class,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: It is worth mentioning that the `GetChar` method returns a proper Unicode character
    depending on the `TerrainEnum` value. For example, in the case of the `WATER`
    constant, the `'\u2248'` value is returned, which is a representation of the `≈`
    character.
  prefs: []
  type: TYPE_NORMAL
- en: Have you heard about the **extension methods**? If not, think of them as methods
    that are "added" to a particular existing type (both built-in or user-defined),
    which can be called in the same way as when they are defined directly as instance
    methods. The declaration of an extension method requires you to specify it within
    a static class as a static method with the first parameter indicating the type,
    to which you want to "add" this method, with the `this` keyword. You can find
    more information at [https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/extension-methods](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/extension-methods).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the body of the `Main` method in the `Program` class.
    Here, you configure the map, as well as present it in the console. The code is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Some comment can be useful regarding the way of getting a color and obtaining
    a character for a particular map place. Both these operations are performed using
    the extension methods "added" to the `TerrainEnum` user-defined type. For this
    reason, you first obtain the `TerrainEnum` value for a particular map place (using
    the `[]` operator and two indices) and then you call a suitable extension method,
    either `GetChar` or `GetColor`. To use Unicode values, you should not forget to
    choose the UTF-8 encoding by setting the `UTF8Encoding.UTF8` value for the `OutputEncoding`
    property.
  prefs: []
  type: TYPE_NORMAL
- en: So far, you have learned about both single- and multi-dimensional arrays, but
    one more variant remains to be presented in this book. Let's continue reading
    to get to know more about it.
  prefs: []
  type: TYPE_NORMAL
- en: Jagged arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last variant of arrays described in this book is a jagged array, which is
    also referred to as an **array of arrays**. It sounds complicated, but fortunately,
    it is very simple. A jagged array could be understood as a single-dimensional
    array, where each element is another array. Of course, such inner arrays can have
    different lengths or they can even be not initialized.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you take a look at the following diagram, you will see an example of a jagged
    array with four elements. The first element has an array with three elements (`9`,
    `5`, `-9`), the second element has an array with five elements (`0`, `-3`, `12`,
    `51`, `-3`), the third is not initialized (`NULL`), while the last one is an array
    with only one element (`54`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/949bdc78-43f5-4477-8bb5-b25ab8b1d35c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Before proceeding to the example, it is worth mentioning the way of declaring
    and initializing a jagged array, because it is a bit different to the arrays already
    described. Let''s take a look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In the first line, you can see the declaration of a single-dimensional array
    with four elements. Each element is another single-dimensional array of integer
    values. When the first line is executed, the `numbers` array is initialized with
    default values, namely `NULL`. For this reason, you need to manually initialize
    particular elements, as shown in the following three lines of codes. It is worth
    noting that the third element is not initialized.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also write the preceding code in a different way, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'A small comment is also necessary for the method of accessing a particular
    element from a jagged array. You can do this in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The first line of code sets the value of the `number` variable to `12`, that
    is, to the value of the third element (index equal to `2`) from the array, which
    is the second element of the jagged array. The other line changes the value of
    the fourth element within the array, which is the second element of the jagged
    array, from `51` to `50`.
  prefs: []
  type: TYPE_NORMAL
- en: More information about jagged arrays is available at [https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/arrays/jagged-arrays](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/arrays/jagged-arrays).
  prefs: []
  type: TYPE_NORMAL
- en: Example – yearly transport plan
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After the introduction of jagged arrays, let''s proceed with an example. You
    will see how to develop a program that creates a plan of transportation for the
    whole year. For each day of each month, the application draws one of the available
    means of transport. At the end, the program presents the generated plan, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e50a99c3-cd6f-42d8-bd1b-2a0d736a2b2b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To start with, let''s declare the enumeration type with constants representing
    available types of transport, namely a car, a bus, a subway, a bike, or on foot,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In the next step, you create two extension methods that return a character
    and a color for the representation of a given mean of transport in the console.
    The code is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code should not require additional clarification, because it is
    very similar to the one already presented in this chapter. Now let's proceed to
    the code from the `Main` method from the `Program` class, which will be shown
    and described in parts.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the first part, a jagged array is created and filled with proper values.
    It is assumed that the jagged array has 12 elements, representing months from
    the current year. Each element is a single-dimensional array with `TransportEnum`
    values. The length of such an inner array depends on the number of days in a given
    month. For instance, it is set to 31 elements for January and 30 elements for
    April. The code is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Let's analyze the preceding code. At the beginning, a new instance of the `Random`
    class is created. It will be later used for drawing a suitable mean of transport
    from the available ones. In the next line, you get the number of constants from
    the `TransportEnum` enumeration type, that is, the number of available transport
    types. Then, the jagged array is created and the `for` loop is used to iterate
    through all months within the year. In each iteration, the number of days is obtained
    (using the `DaysInMonth` static method of `DateTime`) and an array (as an element
    from the jagged array) is initialized with zeros. In the following line of code,
    you can see the next `for` loop that iterates through all days of the month. Within
    this loop, you draw a transport type, and set it as a value of a suitable element
    within an array that is an element of the jagged array.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next part of the code is related to the process of presenting the plan
    in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: At the beginning, a single-dimensional array with month names is created using
    the `GetMonthNames` method, which will be described later. Then, a value of the
    `monthNamesPart` variable is set to the maximum necessary length of text for storing
    the month name. To do so, the LINQ expression is used to find the maximum length
    of text from the collection with names of months. The obtained result is increased
    by 2 for reserving the place for a colon and a space.
  prefs: []
  type: TYPE_NORMAL
- en: One of the great features of the C# language is its ability to use LINQ. Such
    a mechanism makes it possible to get data not only from various collections, but
    also from **Structured Query Language** (**SQL**) databases and **Extensible Markup
    Language** (**XML**) documents in a consistent way. You can read more at [https://docs.microsoft.com/dotnet/csharp/linq/index](https://docs.microsoft.com/dotnet/csharp/linq/index).
  prefs: []
  type: TYPE_NORMAL
- en: Then, the `for` loop is used to iterate through all elements of the jagged array,
    that is, through all months. In each iteration, the name of the month is presented
    in the console. Later, the next `for` loop is used to iterate through all the
    elements of the current element of the jagged array, that is, through all days
    of the month. For each of them, proper colors are set (for background and foreground),
    and a suitable character is presented.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end, let''s take a look at the implementation of the `GetMonthNames`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This code does not require additional explanation, because it is based on the
    code already described in the example for single-dimensional arrays.
  prefs: []
  type: TYPE_NORMAL
- en: Sorting algorithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many algorithms that perform various operations on arrays. However,
    one of the most common tasks is sorting an array to arrange its elements in the
    correct order, either ascending or descending. The topic of sorting algorithms
    involves many approaches, including selection sort, insertion sort, bubble sort,
    and quicksort, which will be explained in detail in this part of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Selection sort
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start with the **selection sort**, which is one of the simplest sorting
    algorithms. The algorithm divides the array into two parts, namely sorted and
    unsorted. In the following iterations, the algorithm finds the smallest element
    in the unsorted part and exchanges it with the first element in the unsorted part.
    It sounds very simple, doesn't it?
  prefs: []
  type: TYPE_NORMAL
- en: 'To better understand the algorithm, let''s take a look at the following iterations
    for an array with nine elements (**-11**, **12**, **-42**, **0**, **1**, **90**,
    **68**, **6**, **-9**), as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/81e1a940-e7ad-41b1-bb26-870264d29f34.png)'
  prefs: []
  type: TYPE_IMG
- en: To simplify the analysis, the bold line is used to present the border between
    the sorted and unsorted parts of the array. At the beginning (*Step 1*), the border
    is located just at the top of the array, which means that the sorted part is empty.
    Thus, the algorithm finds the smallest value in the unsorted part (**-42**) and
    swaps it with the first element in this part (**-11**). The result is shown in
    *Step 2*, where the sorted part contains one element (**-42**), while the unsorted
    part consists of eight elements. The afore mentioned steps are performed a few
    times until only one element is left in the unsorted part. The final result is
    shown in *Step 9*.
  prefs: []
  type: TYPE_NORMAL
- en: Now you know how the selection sort algorithm works, but what role is performed
    by the `i` and `m` indicators shown on the left of the following steps in the
    preceding diagram? They are related to the variables used in the implementation
    of this algorithm. Thus, it is time to see the code in the C# language.
  prefs: []
  type: TYPE_NORMAL
- en: 'The algorithm implementation is created as the `SelectionSort` static class
    with the `Sort` generic static method, which is shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Sort` method takes one parameter, namely the array that should be sorted
    (`array`). Within the method, the `for` loop is used to iterate through the elements
    until only one item is left in the unsorted part. Thus, the number of iterations
    of the loop is equal to the length of the array minus one (`array.Length-1`).
    In each iteration, another `for` loop is used to find the smallest value in the
    unsorted part (`minValue`, from the `i+1` index until the end of array), as well
    as to store an index of the smallest value (`minIndex`, referred to as the `m`
    indicator in the preceding diagram). Then, the smallest element in the unsorted
    part (with an index equal to `minIndex`) is swapped with the first element in
    the unsorted part (`i` index), using the `Swap` auxiliary method, the implementation
    of which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to test the implementation of the selection sort algorithm, you
    can place the following code in the `Main` method of the `Program` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, a new array is declared and initialized. Then, the `Sort`
    static method is called, passing the array as a parameter. At the end, the `string`
    value is created by joining elements of the array (separated by the `|` character)
    and is shown in the console, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'By using the generic method, you can easily use the created class for sorting
    various arrays, such as with floating point numbers or strings. The example code
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'As a result, you will receive the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: While talking about various algorithms, one of the most important topics is
    **computational complexity**, especially **time complexity**. There are a few
    of its variants, such as for the worst or average case. The complexity can be
    interpreted as the number of basic operations that need to be performed by the
    algorithm, depending on the input size (*n*). The time complexity can be specified
    using the **Big O notation**, for example, as *O(n)*, *O(n²)* or *O(n log(n))*.
    However, what does this mean? The *O(n)* notation indicates that the number of
    operations increases linearly with the input size (*n*). The *O(n²)* variant is
    named **quadratic**, while *O(n log(n))* is named**linearithmic**. There are other
    variants as well, such as *O(1),* which is **constant**.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of the selection sort, both the worst and average time complexity
    is *O(n²)*. Why? Let's take a look at the code to answer this question. There
    are two loops (one within the other), each iterating through many elements of
    the array. For this reason, the complexity is indicated as *O(n²)*.
  prefs: []
  type: TYPE_NORMAL
- en: 'More information about the selection sort and its implementations can be found
    at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Selection_sort](https://en.wikipedia.org/wiki/Selection_sort)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://en.wikibooks.org/wiki/Algorithm_Implementation/Sorting/Selection_sort](https://en.wikibooks.org/wiki/Algorithm_Implementation/Sorting/Selection_sort)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You have just learned about the first sorting algorithm! If you are interested
    in the next approach to sorting, let's proceed to the next section, where the
    insertion sort is presented.
  prefs: []
  type: TYPE_NORMAL
- en: Insertion sort
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **insertion sort** is another algorithm that makes it possible to sort a
    single-dimensional array in a simple way, as shown in the following diagram. Similarly,
    as in the case of the selection sort, the array is divided into two parts, namely
    sorted and unsorted. However, at the beginning, the first element is included
    in the sorted part. In each iteration, the algorithm takes the first element from
    the unsorted part and places it in a suitable location within the sorted part,
    to leave the sorted part in the correct order. Such operations are repeated until
    the unsorted part is empty.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at an example of sorting an array with nine elements (**-11**,
    **12**, **-42**, **0**, **1**, **90**, **68**, **6**, **-9**) using the insertion
    sort, which is presented in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0fa22285-42f2-4cdb-a20b-e5d9907d95e6.png)'
  prefs: []
  type: TYPE_IMG
- en: At the beginning, only one element (**-11**) is located in the sorted part (*Step
    1*). Then, the smallest element is found in the unsorted part (**-42**) and is
    moved to the correct location in the sorted part, that is, to the beginning of
    the array, performing a set of swap operations (*Steps 2* and *3*). Thus, the
    length of the sorted part is increased to two elements, namely **-42** and **-11**.
    Such operations are repeated until the unsorted part is empty (*Step 22*).
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation code for the insertion sort is very simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, as in the case of the selection sort, the implementation is provided
    in a new class, namely `InsertionSort`. The static generic `Sort` method performs
    operations regarding sorting and takes an array as the parameter. Within this
    method, the `for` loop is used to iterate through all elements in the unsorted
    part. Thus, the initial value of the `i` variable is set to `1`, instead of `0`.
    In each iteration of the `for` loop, the `while` loop is executed to move the
    first element from the unsorted part of the array (with the index equal to a value
    of the `i` variable) to the correct location within the sorted part, using the
    `Swap` auxiliary method with the same implementation as shown in the case of the
    selection sort. The way of testing the insertion sort is also very similar, but
    another class name should be used, that is, `InsertionSort` instead of `SelectionSort`.
  prefs: []
  type: TYPE_NORMAL
- en: 'More information about the insertion sort and its implementations can be found
    at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Insertion_sort](https://en.wikipedia.org/wiki/Insertion_sort)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://en.wikibooks.org/wiki/Algorithm_Implementation/Sorting/Insertion_sort](https://en.wikibooks.org/wiki/Algorithm_Implementation/Sorting/Insertion_sort)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the end, it is worth mentioning the time complexity of the insertion sort.
    Similarly, as in the case of the selection sort, both worst and average time complexity
    is *O(n²)*. If you take a look at the code, you will also see two loops (`for`
    and `while`) placed one within the other, which could iterate multiple times,
    depending on the input size.
  prefs: []
  type: TYPE_NORMAL
- en: Bubble sort
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The third sorting algorithm presented in the book is **bubble sort**. Its way
    of operation is very simple, because the algorithm just iterates through the array
    and compares adjacent elements. If they are located in an incorrect order, they
    are swapped. It sounds very easy, but the algorithm is not very efficient and
    its usage with large collections could cause performance-related problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'To better understand how the algorithm works, let''s take a look at the following
    diagram that shows how the algorithm operates in the case of sorting a single-dimensional
    array with nine elements (**-11**, **12**, **-42**, **0**, **1**, **90**, **68**,
    **6**, **-9**):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2a67b8b0-b786-4aa5-8744-a1dd41b7bdf8.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, in each step the algorithm compares two adjacent elements in
    the array and swaps them, if necessary. For example, in *Step 1*, **-11** and
    **12** are compared, but they are placed in the correct order, so it is not necessary
    to swap such elements. In *Step 2*, the next adjacent elements are compared (namely
    **12** and **-42**). This time, such elements are not placed in the correct order,
    thus they are swapped. The afore mentioned operations are performed several times.
    At the end, the array will be sorted, as shown in *Step 72*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The algorithm seems to be very easy, but what about the implementation? Is
    it also so simple? Fortunately, yes! You just need to use two loops, compare adjacent
    elements, and swap them if necessary. That''s all! Let''s take a look at the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The `Sort` static generic method, declared in the `BubbleSort` class, contains
    the implementation of the bubble sort algorithm. As already mentioned, two `for`
    loops are used, together with a comparison and a call of the `Swap` method (with
    the same implementation as shown in the case of the previously described sorting
    algorithms). What is more, you can use similar code for testing the implementation,
    but do not forget to replace the name of the class to `BubbleSort`.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also possible to use a more optimized version of the bubble sort algorithm
    by introducing a simple modification in the implementation. It is based on the
    assumption that comparisons should be stopped when no changes are discovered during
    one iteration through the array. The modified code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: By introducing such a simple modification, the number of comparisons could decrease
    significantly. In the preceding example, it decreases from 72 steps to 56 steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'More information about the bubble sort and its implementations can be found
    at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Bubble_sort](https://en.wikipedia.org/wiki/Bubble_sort)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://en.wikibooks.org/wiki/Algorithm_Implementation/Sorting/Bubble_sort](https://en.wikibooks.org/wiki/Algorithm_Implementation/Sorting/Bubble_sort)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before moving to the next sorting algorithm, it is worth mentioning the time
    complexity of the bubble sort. As you may have already guessed, both worst and
    average cases are the same as in the case of the selection and insertion sort,
    that is, *O(n²)*.
  prefs: []
  type: TYPE_NORMAL
- en: Quicksort
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last sorting algorithm described in this book is named **quicksort**. It
    is one of the popular **divide and conquer algorithms**, which divide a problem
    into a set of smaller ones. Moreover, such an algorithm provides developers with
    an efficient way of sorting. Does this mean that its idea and implementation are
    very complicated? Fortunately, no! You will learn how the algorithm works, as
    well as what its implementation code can look like in this section. Let's start!
  prefs: []
  type: TYPE_NORMAL
- en: How does the algorithm work? At the beginning, it picks some value (such as
    from the first or the middle element of the array) as a **pivot**. Then, it reorders
    the array in such a way that values lower than or equal to the pivot are placed
    before it (forming the lower subarray), while values greater than the pivot are
    placed after it (the higher subarray). Such a process is called **partitioning**.
    In this book, the **Hoare partition scheme** is used. Next, the algorithm recursively
    sorts each of the afore mentioned subarrays. Of course, each subarray is further
    divided into the next two subarrays, and so on. The recursive calls stop when
    there are one or zero elements in a subarray, because in such a case there is
    nothing to sort.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding description may sound a bit complicated, so let''s take a look
    at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/16a55dc5-bea8-4a05-9b5a-93482f5e6c3b.png)'
  prefs: []
  type: TYPE_IMG
- en: The example shows how the quicksort algorithm sorts a single-dimensional array
    with nine elements (**-11**, **12**, **-42**, **0**, **1**, **90**, **68**, **6**,
    **-9**). In this scenario, it is assumed that the pivot is chosen as a value of
    the first element of the subarray that is currently being sorted. In *Step 1*,
    value **-11** is chosen as the pivot. Then, it is necessary to reorder the array.
    Therefore, **-11** is swapped with **-42**, as well as **12** with **-11**, to
    ensure that only values lower than or equal to the pivot (**-42**, **-11**) are
    in the lower subarray and only values greater than the pivot (**12**, **0**, **1**,
    **90**, **68**, **6**, **-9**) are placed in the higher subarray. Then, the algorithm
    is called recursively for both afore mentioned subarrays, namely (**-42**, **11**)
    and (**12**, **0**, **1**, **90**, **68**, **6**, **-9**), so they are analyzed
    in the same way as the input array.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, *Step 5* shows that value **12** is chosen as the pivot. After
    partitioning, the subarray is divided into two other subarrays, namely (**-9**,
    **0**, **1**, **6**, **12**) and (**68**, **90**). For both, other pivot elements
    are chosen, namely **-9** and **68**. After performing such operations for all
    remaining parts of the array, you will receive the final result, as shown on the
    right-hand side of the diagram (*Step 15*).
  prefs: []
  type: TYPE_NORMAL
- en: 'It is worth mentioning that the pivot can be selected variously in other implementations
    of this algorithm. As an example, let''s take a look at how the following steps
    will change in the case when a value of the middle element of the array is chosen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/34991257-e59f-4dbc-868d-2422d64a303b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you understand how the algorithm works, let''s proceed to the implementation.
    It is more complicated than the examples shown earlier, and it uses **recursion**
    to call the sorting method for subarrays. The code is placed in the `QuickSort`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The `QuickSort` class contains two variants of the `Sort` method. The first
    takes only one parameter, namely the array that should be sorted, and is shown
    in the preceding code snippet. It just calls another variant of the `Sort` method,
    which makes it possible to specify the lower and upper indices that indicate which
    part of the array should be sorted. The other version of the `Sort` method is
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The `Sort` method checks whether the array (or subarray) has at least two elements,
    by comparing the values of the `lower` and `upper` variables. In such a case,
    it calls the `Partition` method, which is responsible for the partitioning phase,
    and then calls the `Sort` method recursively for two subarrays, namely lower (indices
    from `lower` to `p`) and higher (from `p+1` to `upper`).
  prefs: []
  type: TYPE_NORMAL
- en: 'The code regarding the partitioning is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: At the beginning, the pivot value is chosen and stored as a value of the `pivot`
    variable. As already mentioned, it can be chosen in various ways, such as by taking
    a value of the first element (shown in the preceding code snippet), a value of
    the middle element (as shown in the preceding code as the comment), or even as
    a random value. Then, the `do-while` loop is used to rearrange the array according
    to the Hoare partition scheme, using comparisons and by swapping elements. At
    the end, the current value of the `j` variable is returned.
  prefs: []
  type: TYPE_NORMAL
- en: The presented implementation is based on the Hoare partition scheme, the pseudocode
    and explanation of which are presented at [https://en.wikipedia.org/wiki/Quicksort](https://en.wikipedia.org/wiki/Quicksort).
    There are various possible ways in which to implement quicksort. You can find
    more information at [https://en.wikibooks.org/wiki/Algorithm_Implementation/Sorting/Quicksort](https://en.wikibooks.org/wiki/Algorithm_Implementation/Sorting/Quicksort).
  prefs: []
  type: TYPE_NORMAL
- en: What about the time complexity? Do you think that it differs in comparison with
    the selection, insertion, and bubble sort? If so, you are right! It has *O(n log(n))*
    average time complexity, despite having *O(n²)* worst time complexity.
  prefs: []
  type: TYPE_NORMAL
- en: Simple lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Arrays are really useful data structures and they are applied in many algorithms.
    However, in some cases their application could be complicated due to their nature,
    which does not allow to increase or decrease the length of the already-created
    array. What should you do if you do not know the total number of elements to store
    in the collection? Do you need to create a very big array and just not use unnecessary
    elements? Such a solution does not sound good, does it? A much better approach
    is to use a data structure that makes it possible to dynamically increase the
    size of the collection if it is necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Array list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first data structure that meets this requirement is the **array list**,
    which is represented by the `ArrayList` class from the `System.Collections` namespace.
    You can use this class to store big collections of data, to which you can easily
    add new elements when necessary. Of course, you can also remove them, count items,
    and find an index of a particular value stored within the array list.
  prefs: []
  type: TYPE_NORMAL
- en: 'How can you do this? Let''s take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'In the first line, a new instance of the `ArrayList` class is created. Then,
    you use the `Add`, `AddRange`, and `Insert` methods to add new elements to the
    array list. The first (namely, `Add`) allows you to add a new item at the end
    of the list. The `AddRange` method adds a collection of elements at the end of
    the array list, while `Insert` can be used to place an element in a specified
    location within the collection. When the preceding code is executed, the array
    list will contain the following elements: `5`, `6`, `-7`, `8`, `"Marcin"`, `7.8`,
    and `"Mary"`. As you can see, all items stored within the array list are of the
    type `object`. Thus, you can place in the same collection data of various types
    at the same time.'
  prefs: []
  type: TYPE_NORMAL
- en: If you want to specify a type of each element stored within the list, you can
    use the generic `List` class, described just after `ArrayList`.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is worth mentioning that you can easily access a particular element within
    the array list using the index, as shown in the following two lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Let's take a look at casting to `int` in the second line. Such casting is necessary,
    because the array list stores `object` values. As in the case of arrays, the zero-based
    indices are used while accessing particular elements within the collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, you can use the `foreach` loop to iterate through all items, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'That is not all! The `ArrayList` class has a set of properties and methods
    which you can use while developing applications utilizing the afore mentioned
    data structure. To start with, let''s take a look at the `Count` and `Capacity`
    properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The first (`Count`) returns the number of elements stored in the array list,
    while the other (`Capacity`) indicates how many elements can be stored within
    it. If you check a value of the `Capacity` property after adding new elements
    to the array list, you will see that this value is automatically increased to
    prepare a place for new items. This is shown in the following diagram, presenting
    the difference between `Count` (as **A**) and `Capacity` (**B**):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a89f3497-53bd-4728-a403-765f66143602.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The next common and important task is checking whether the array list contains
    an element with a particular value. You can perform this operation by calling
    the `Contains` method, as shown in the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'If the specified value is found in the array list, the `true` value is returned.
    Otherwise, `false` is returned. Using this method, you can check whether the element
    exists in the collection. However, how can you find an index of this element?
    To do so, you can use the `IndexOf` or `LastIndexOf` method, as shown in the following
    line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The `IndexOf` method returns an index of the first occurrence of the element
    in the array list, while `LastIndexOf` returns an index of the last occurrence.
    If a value is not found, `-1` is returned by the method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Apart from adding some items to the array list, you can also easily remove
    added elements, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: For removing items from the array list, you can use more than one method, namely
    `Remove`, `RemoveAt`, and `RemoveRange`. The first (`Remove`) removes the first
    occurrence of the value provided as the parameter. The `RemoveAt` method removes
    an item with the index equal to the value passed as the parameter, while the other
    (`RemoveRange`) makes it possible to remove the specified number of elements starting
    from the provided index. What is more, if you want to remove all elements, you
    can use the `Clear` method.
  prefs: []
  type: TYPE_NORMAL
- en: Among other methods, it is worth mentioning `Reverse`, which reverses the order
    of the elements within the array list, as well as `ToArray`, which returns an
    array with all items stored in the `ArrayList` instance.
  prefs: []
  type: TYPE_NORMAL
- en: More information about the `ArrayList` class is available at [https://msdn.microsoft.com/library/system.collections.arraylist.aspx](https://msdn.microsoft.com/library/system.collections.arraylist.aspx).
  prefs: []
  type: TYPE_NORMAL
- en: Generic list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you can see, the `ArrayList` class contains a broad range of features, but
    it has a significant drawback—it is not a strongly typed list. If you want to
    benefit from a strongly typed list, you can use the generic `List` class representing
    the collection, whose size can be increased or decreased, whenever necessary.
  prefs: []
  type: TYPE_NORMAL
- en: The generic `List` class contains many properties and methods that are very
    useful while developing applications that store data. You will see that many members
    are named exactly the same as in the `ArrayList` class, such as `Count` and `Capacity`
    properties, as well as the `Add`, `AddRange`, `Clear`, `Contains`, `IndexOf`,
    `Insert`, `InsertRange`, `LastIndexOf`, `Remove`, `RemoveAt`, `RemoveRange`, `Reverse`,
    and `ToArray` methods. You can also get a particular element from the list using
    the index and the `[]` operator.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from the already-described features, you can also use the comprehensive
    set of extension methods from the `System.Linq` namespace, such as for finding
    the minimum or maximum value (`Min` or `Max`), calculating the average (`Average`),
    ordering in an ascending or descending order (`OrderBy` or `OrderByDescending`),
    as well as checking whether all the elements in the list satisfy a condition (`All`).
    Of course, these are not the only features available for developers while creating
    applications using generic lists in the C# language.
  prefs: []
  type: TYPE_NORMAL
- en: More information about the generic `List` class is available at [https://msdn.microsoft.com/library/6sh2ey19.aspx](https://msdn.microsoft.com/library/6sh2ey19.aspx).
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at two examples that show how to use the generic list in practice.
  prefs: []
  type: TYPE_NORMAL
- en: Example – average value
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first example utilizes the generic `List` class for storing floating point
    values (of the `double` type) entered by the user. After typing a number, the
    average value is calculated and presented in the console. The program stops the
    operation when an incorrect value is entered by the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code from the `Main` method in the `Program` class is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: At the beginning, an instance of the `List` class is created. Then, within the
    infinite loop (`do-while`), the program waits until the user enters the number.
    If it is correct, the entered value is added to the list (by calling the `Add`
    method), and the average value from elements of the list is calculated (by calling
    the `Average` method) and shown in the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a result, you could receive output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: In the current example, you have seen how to use the list that stores `double`
    values. However, can it also store instances of user-defined classes? Of course!
    You will see how to achieve this goal in the next example.
  prefs: []
  type: TYPE_NORMAL
- en: Example – list of people
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The second example regarding the `List` class shows how to use this data structure
    to create a very simple database of people. For each of them, a name, a country,
    and an age are stored. When the program is launched, some data of people are added
    to the list. Then, the data is sorted (using the LINQ expression) and presented
    in the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with declaration of the `Person` class, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The class contains three public properties, namely `Name`, `Age`, and `Country`.
    It is worth noting that the `Country` property is of the `CountryEnum` type, which
    defines three constants, that is, `PL` (Poland), `UK` (United Kingdom), and `DE`
    (Germany), as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The following part of the code should be added in the `Main` method within
    the `Program` class. It creates a new instance of the `List` class, and adds data
    of a few people with different names, countries, and ages, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'In the next line, the LINQ expression is used to sort the list by names of
    people in ascending order, and convert the results into the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you can easily iterate through all the results using the `foreach` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'After running the program, the following result is presented:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: That's all! Let's now talk a bit more about the LINQ expressions, which can
    be used not only to order elements, but also to perform the filtering of items
    based on the provided criteria, and even more.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, let''s take a look at the following query using the **method
    syntax**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: It selects the names (the `Select` clause) of all people whose age is lower
    than or equal to `30` years (the `Where` clause), ordered by names (the `OrderBy`
    clause). The query is then executed and the results are returned as a list.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same task could be accomplished using the **query syntax**, as shown in
    the following example, combined with calling the `ToList` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: In this part of the chapter, you have seen how to use the `ArrayList` class
    and the generic `List` class for storing data in collections, the size of which
    could be dynamically adjusted. However, this is not the end of list-related topics
    within this chapter. Are you ready to get to know another data structure, which
    maintains the elements in the sorted order? If so, let's proceed to the next section,
    which is focused on sorted lists.
  prefs: []
  type: TYPE_NORMAL
- en: Sorted lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you have already learned how to store data using arrays and
    lists. However, do you know that you can even use a data structure that ensures
    that the elements are sorted? If not, let's get to know the `SortedList` generic
    class (from the `System.Collections.Generic` namespace), which is a collection
    of **key-value pairs**, sorted by keys, without the necessity of sorting them
    on your own. It is worth mentioning that all keys must be unique and cannot be
    equal to `null`.
  prefs: []
  type: TYPE_NORMAL
- en: You can easily add an element to the collection using the `Add` method, and
    remove a specified item using the `Remove` method. Among other methods, it is
    worth noting `ContainsKey` and `ContainsValue` for checking whether the collection
    contains an item with a given key or value, as well as `IndexOfKey` and `IndexOfValue`
    for returning an index of a given key or value within the collection. As the sorted
    list stores the key-value pairs, you have also access to the `Keys` and `Values`
    properties. Particular keys and values can be easily obtained using the index
    and the `[]` operator.
  prefs: []
  type: TYPE_NORMAL
- en: More information about the `SortedList` generic class is available at [https://msdn.microsoft.com/library/ms132319.aspx](https://msdn.microsoft.com/library/ms132319.aspx).
  prefs: []
  type: TYPE_NORMAL
- en: After this short introduction, let's take a look at an example that will show
    you how to use this data structure, and will also indicate some significant differences
    in the code compared with the previously-described `List` class.
  prefs: []
  type: TYPE_NORMAL
- en: Example – address book
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This example uses the `SortedList` class to create a very simple address book,
    which is sorted by names of people. For each person, the following data is stored:
    `Name`, `Age`, and `Country`. The declaration of the `Person` class is shown in
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'A value of the `Country` property can be set to one of the constants from `CountryEnum`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The most interesting part of code is placed in the `Main` method within the
    `Program` class. Here, a new instance of the `SortedList` generic class is created,
    specifying types for keys and values, namely `string` and `Person`, as presented
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you can easily add data to the sorted list by calling the `Add` method,
    passing two parameters, namely a key (that is, a name), and a value (that is,
    an instance of the `Person` class), as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'When all the data are stored within the collection, you can easily iterate
    through its elements (key-value pairs) using the `foreach` loop. It is worth mentioning
    that a type of the variable used in the loop is `KeyValuePair<string, Person>`.
    Thus, you need to use the `Key` and `Value` properties to get access to a key
    and a value, respectively, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'When the program is launched, you will receive the following results in the
    console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the collection is automatically sorted by names, which are used
    as keys for the sorted list. However, you need to remember that keys must be unique,
    so you cannot add more than one person with the same name in this example.
  prefs: []
  type: TYPE_NORMAL
- en: Linked lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While using the `List` generic class, you can easily get access to particular
    elements of the collection using indices. However, when you get a single element,
    how can you move to the next element of the collection? Is it possible? To do
    so, you may consider the `IndexOf` method to get an index of the element. Unfortunately,
    it returns an index of the first occurrence of a given value in the collection,
    so it will not always work as expected in this scenario.
  prefs: []
  type: TYPE_NORMAL
- en: 'It would be great to have some kind of *pointer* to the next element, as shown
    in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bbd7ff01-046f-41d1-99b1-1ae4c7116212.png)'
  prefs: []
  type: TYPE_IMG
- en: 'With this approach, you can easily navigate from one element to the next one
    using the `Next` property. Such a structure is named the **single-linked list**.
    However, can it be further expanded by adding the `Previous` property to allow
    navigating in forward and backward directions? Of course! Such a data structure
    is named the **double-linked list** and is presented in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b3e08b82-fb00-4983-b030-17f397830457.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the double-linked list contains the `First` property that indicates
    the first element in the list. Each item has two properties that point to the
    previous and next element (`Previous` and `Next`, respectively). If there is no
    previous element, the `Previous` property is equal to `null`. Similarly, when
    there is no next element, the `Next` property is set to `null`. Moreover, the
    double-linked list contains the `Last` property that indicates the last element.
    When there are no items in the list, both the `First` and `Last` properties are
    set to `null`.
  prefs: []
  type: TYPE_NORMAL
- en: However, do you need to implement such a data structure on your own if you want
    to use it in your C#-based applications? Fortunately, no, because it is available
    as the `LinkedList` generic class in the `System.Collections.Generic` namespace.
  prefs: []
  type: TYPE_NORMAL
- en: While creating an instance of the class, you need to specify the type parameter
    that indicates a type of a single element within the list, such as `int` or `string`.
    However, a type of a single node is not just `int` or `string`, because in such
    a case you will not have access to any additional properties related to the double-linked
    list, such as `Previous` or `Next`. To solve this problem, each node is an instance
    of the `LinkedListNode` generic class, such as `LinkedListNode<int>` or `LinkedListNode<string>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some additional explanation is necessary for the methods of adding new nodes
    to the double-linked list. For this purpose, you can use a set of methods, namely:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AddFirst`: For adding an element at the beginning of the list'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AddLast`: For adding an element at the end of the list'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AddBefore`: For adding an element before the specified node in the list'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AddAfter`: For adding an element after the specified node in the list'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All these methods return an instance of the `LinkedListNode` class. Moreover,
    there are also other methods, such as `Contains` for checking whether the specified
    value exists in the list, `Clear` for removing all elements from the list, and `Remove`
    for removing a node from the list.
  prefs: []
  type: TYPE_NORMAL
- en: More information about the `LinkedList` generic class is available at [https://msdn.microsoft.com/library/he2s3bh7.aspx](https://msdn.microsoft.com/library/he2s3bh7.aspx).
  prefs: []
  type: TYPE_NORMAL
- en: After this short introduction, you should be ready to take a look at an example
    that shows how to apply the double-linked list, implemented as the `LinkedList`
    class, in practice.
  prefs: []
  type: TYPE_NORMAL
- en: Example – book reader
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As an example, you will prepare a simple application that allows a user to
    read a book by changing the pages. One should be able to move to the next page
    (if it exists) after pressing the *N* key, and go back to the previous page (if
    it exists) after pressing the *P* key. The content of the current page, together
    with the page number, should be shown in the console, as presented in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6b53b23c-4fd4-4102-a08f-8ba0a5a9ff04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s start with the declaration of the `Page` class, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'This class represents a single page and contains the `Content` property. You
    should create a few instances of the `Page` class, representing six pages of the
    book, in the `Main` method in the `Program` class, as presented in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'When the instances are created, let''s proceed to constructing the linked list,
    using a few addition-related methods, as shown in the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'In the first line, a new list is created. Then, the following operations are
    performed:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding the data of the second page at the end of the list (`[2]`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding the data of the fourth page at the end of the list (`[2, 4]`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding the data of the sixth page at the end of the list (`[2, 4, 6]`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding the data of the first page at the beginning of the list (`[1, 2, 4, 6]`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding the data of the third page before the node of the fourth page (`[1, 2,
    3, 4, 6]`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding the data of the fifth page after the node of the fourth page (`[1, 2,
    3, 4, 5, 6]`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The next part of the code is responsible for presenting the page in the console,
    as well as for navigating between pages after pressing the appropriate keys. The
    code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Some explanation may be useful for this part of the code. In the first line,
    a value of the `current` variable is set to the first node in the linked list.
    Generally speaking, the `current` variable represents the page which is currently
    presented in the console. Then, the initial value for the page number is set to
    `1` (the `number` variable). However, the most interesting and complicated part
    of the code is shown in the `while` loop.
  prefs: []
  type: TYPE_NORMAL
- en: Within the loop, the current content of the console is cleared and the string
    for presenting the page number is properly formatted to display. Before and after
    it, the `-` characters are added. Moreover, leading spaces are inserted (using
    the `PadLeft` method) to prepare the string that is centered horizontally.
  prefs: []
  type: TYPE_NORMAL
- en: Then, the content of the page is divided into lines of no more than 90 characters
    and written in the console. For dividing the string, the `Substring` method and
    the `Length` properties are used. In a similar way, additional information (about
    quotations from another book) is presented in the console. It is worth mentioning
    the `Environment.NewLine` property that inserts the line break in a specified
    place of the string. Then, the `PREVIOUS` and `NEXT` captions are shown, if the
    previous or the next page is available.
  prefs: []
  type: TYPE_NORMAL
- en: In the following part of the code, the program waits until the user presses
    any key and does not present it in the console (by passing the `true` value as
    the parameter). When the user presses the *N* key, the `current` variable is set
    to the next node, using the `Next` property. Of course, the operation should not
    be performed when the next page is unavailable. In a similar way, the *P* key
    is handled, which causes the user to be navigated to the previous page. It is
    worth mentioning that the number of the page (the `number` variable) is modified
    together with changing a value of the `current` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end, the code of the auxiliary `GetSpaces` method is shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: This just prepares and returns the `string` variable with the specified number
    of spaces.
  prefs: []
  type: TYPE_NORMAL
- en: Circular-linked lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, you have learned about the double-linked list. As you
    can see, the implementation of such a data structure allows for navigating between
    the nodes using the `Previous` and `Next` properties. However, the `Previous`
    property of the first node is set to `null`, as is the `Next` property of the
    last node. Do you know that you can easily expand this approach to create the
    **circular-linked list**?
  prefs: []
  type: TYPE_NORMAL
- en: 'Such a data structure is presented in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7329d090-98aa-4bc7-a60e-442040f75443.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, the `Previous` property of the first node navigates to the last one, while
    the `Next` property of the last node navigates to the first. This data structure
    can be useful in some specific cases, as you will see while developing a real-world
    example.
  prefs: []
  type: TYPE_NORMAL
- en: It is worth mentioning that the way of navigating between nodes does not need
    to be implemented as properties. It can also be replaced with methods, as you
    will see in the example within the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After the short introduction to the topic of circular-linked lists, it is time
    to take a look at the implementation code. Let''s start with the following code
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: The implementation of the circular-linked list can be created as a generic class
    that extends `LinkedList`, as shown in the preceding code. It is worth mentioning
    the implementation of the `GetEnumerator` method, which uses the `CircularLinkedListEnumerator`
    class. By creating it, you will be able to indefinitely iterate through all the
    elements of the circular-linked list, using the `foreach` loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code of the `CircularLinkedListEnumerator` class is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: The `CircularLinkedListEnumerator` class implements the `IEnumerator` interface.
    The class declares the `private` field representing the current node (`_current`)
    in the iteration over the list. It also contains two properties, namely `Current`
    and `IEnumerator.Current`, which are required by the `IEnumerator` interface.
    The constructor just sets a value of the `_current` variable, based on an instance
    of the `LinkedList` class, passed as the parameter.
  prefs: []
  type: TYPE_NORMAL
- en: One of the most important parts of code is the `MoveNext` method. It stops iterating
    when the `_current` variable is set to `null`, that is, if there are no items
    in the list. Otherwise, it changes the current element to the next one or to the
    first node in the list, if the next node is unavailable. In the `Reset` method,
    you just set a value of the `_current` field to the first node in the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end, you need to create two extension methods that make it possible
    to navigate to the first element while trying to get the next element from the
    last item in the list, as well as to navigate to the last element while trying
    to get the previous element from the first item in the list. To simplify the implementation,
    such features will be available as `Next` and `Previous` methods, instead of `Next`
    and `Previous` properties, as shown in the preceding diagram. The code is shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: The first extension method, namely `Next`, checks whether the node exists and
    whether the list is available. In such a case, it returns a value of the `Next`
    property of the node (if such a value is not equal to `null`) or returns a reference
    to the first element in the list, using the `First` property. The `Previous` method
    operates in a similar way.
  prefs: []
  type: TYPE_NORMAL
- en: That's all! You have just completed the C#-based implementation of the circular-linked
    list, which can be used later in various applications. But how? Let's take a look
    at the following example that uses this data structure.
  prefs: []
  type: TYPE_NORMAL
- en: Example – spin the wheel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This example simulates a game in which the user spins a wheel with random speed.
    The wheel rotates slower and slower until it stops. Then the user can spin it
    again, from the previous stop position, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/75f72d77-a896-4392-94ac-61d6771fef43.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s proceed to the first part of code of the `Main` method in the `Program`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: At the beginning, a new instance of the `CircularLinkedList` class is created,
    which represents the circular-linked list with `string` elements. Then, eight
    values are added, namely `Sport`, `Culture`, `History`, `Geography`, `People`,
    `Technology`, `Nature`, and `Science`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following part of the code performs the most important operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: First, three variables are declared, namely for drawing random values (`random`),
    the total drawn time of spinning of the wheel in milliseconds (`totalTime`), as
    well as the remaining time of spinning of the wheel in milliseconds (`remainingTime`).
  prefs: []
  type: TYPE_NORMAL
- en: Then, the `foreach` loop is used to iterate through all the elements within
    the circular-linked list. If there are no `break` or `return` instructions within
    such a loop, it will execute indefinitely due to the nature of the circular-linked
    list. If the last item is reached, the first element in the list is taken automatically
    in the next iteration.
  prefs: []
  type: TYPE_NORMAL
- en: In the loop, the remaining time is checked. If it is less than or equal to zero,
    that is, the wheel has stopped or has not been started yet, the message is presented
    to the user and the program waits until the *Enter* key is pressed. In such a
    situation, the new spinning operation is configured by drawing the total time
    of spinning and setting the remaining time. When the user presses any other key,
    the program stops the execution.
  prefs: []
  type: TYPE_NORMAL
- en: In the next step, the time for one iteration of the loop is calculated. The
    formula makes it possible to provide smaller times at the beginning (the wheel
    spins faster) and bigger times at the end (the wheel spins slower). Then, the
    remaining time decreases and the program waits for the specified number of milliseconds,
    using the `Sleep` method.
  prefs: []
  type: TYPE_NORMAL
- en: At the end, the foreground color is changed to red, if the final result is shown,
    and the currently-chosen category on the spinning wheel is presented in the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you run the application, you can get the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: You have already completed the example that uses the circular-linked list. It
    is one of the data structures that have been described in this chapter. If you
    want to briefly summarize the information you have learned, let's proceed to the
    short summary of this topic.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Arrays and lists are among the most common data structures used while developing
    various kinds of applications. However, this topic is not as easy as it seems
    to be, because even arrays can be divided into a few variants, namely single-dimensional,
    multi-dimensional, and jagged arrays, also referred to as arrays of arrays.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of lists, the differences are even more visible, as you could see
    in the case of simple, generic, sorted, single-linked, double-linked, and circular-linked
    lists. Fortunately, the built-in implementation is available for the array list,
    as well as the generic, sorted, and double-linked lists. Furthermore, you can
    quite easily extend the double-linked list to behave as the circular-linked list.
    Therefore, you can benefit from the features of suitable structures without the
    significant development effort.
  prefs: []
  type: TYPE_NORMAL
- en: The available types of data structures can sound quite complicated, but in this
    chapter you have seen detailed descriptions of particular data structures, together
    with the implementation code of C#-based examples. They should simplify things
    for you and could be used as the base for your future projects.
  prefs: []
  type: TYPE_NORMAL
- en: Are you ready to learn other data structures? If so, let's proceed to the next
    chapter and read about stacks and queues!
  prefs: []
  type: TYPE_NORMAL
