- en: Build a Dynamic Project Management Board with React and Suspense
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the first two chapters of this book, you've already created two React projects
    all by yourself, and you should, by now, have a solid understanding of the core
    concepts of React. The concepts you've used so far will also be used in this chapter
    to create your third project with React, including some new and more advanced
    concepts that will show you the strength of using React. Again, if you feel you
    may lack some of the knowledge you'll need to finalize the contents of this chapter,
    you can always repeat what you have built so far.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will once again use Create React App, which you used in the previous
    chapter. During the development of the project management board application for
    this chapter, you'll use reusable components that have been created using `styled-components`.
    Following this, you'll use more advanced React techniques to control the dataflow
    throughout your components. Furthermore, HTML5 Web APIs will be used to dynamically
    drag and drop components that function as **Higher-Order Components** (**HOC**).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: React Suspense and code-splitting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using HOC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamic data flow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Project overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will create a **Progressive Web Application** (**PWA**)
    that has reusable React components and styling using Create React App and `styled-components`.
    The application will feature a dynamic drag and drop interface that uses the HTML5
    Drag and Drop API.
  prefs: []
  type: TYPE_NORMAL
- en: The build time is 1.5-2 hours.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The project that we'll create in this chapter builds upon an initial version
    that you can find on GitHub: [https://github.com/PacktPublishing/React-Projects/tree/ch3-initial](https://github.com/PacktPublishing/React-Projects/tree/ch3-initial).
    The complete source code can also be found on GitHub: [https://github.com/PacktPublishing/React-Projects/tree/ch3](https://github.com/PacktPublishing/React-Projects/tree/ch3).
  prefs: []
  type: TYPE_NORMAL
- en: After downloading the initial application from GitHub, we can start by moving
    into its root directory and running the `npm install` command. This will install
    the core packages from Create React App (`react`, `react-dom`, and `react-scripts`) next
    to the `styled-components` package, which we used in the previous chapter. After
    the installation, we can start the application by executing the `npm start` command and
    visit the project in the browser by visiting `http://localhost:3000`.
  prefs: []
  type: TYPE_NORMAL
- en: We can also build the application by executing `npm run build` and subsequently `serve
    -s build`. The minified version of the application can now be visited at `http://localhost:5000`.
    Since it's been set up as a PWA, it will also work without any internet connection.
  prefs: []
  type: TYPE_NORMAL
- en: It's possible that you'll see a different application than when you ran the
    project locally, if you've built and served a Create React App PWA before. This
    is due to the service worker of the PWA that has stored a cached version of that
    application in the browser. You can delete any previous application from the browser
    cache by opening `devTools` and opening the Application tab, where you can click
    on the Clear site data button in the Clear storage section.
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in the following screenshot, the application has a basic header with
    a title and is divided into four columns. These columns are the lanes for the
    **Project Management Board** and will contain the individual tickets once we''ve
    connected the project to the data file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/85a074c4-8949-4341-a38f-6bd913bc28a5.png)'
  prefs: []
  type: TYPE_IMG
- en: As we mentioned in [Chapter 2](ee5cf0ab-57c2-48bc-8c50-281de22969c5.xhtml), *Creating
    a Progressive Web Application with Reusable React Components*, we can check whether
    our application is running when there is no internet connection by visiting the Service
    Workers section of the Application tab. On this page, we can check the Offline checkbox
    and try refreshing the browser.
  prefs: []
  type: TYPE_NORMAL
- en: If we look at the project's structure, we'll see that it's structured in the
    same way as the projects in the previous chapters. The entry point of the application
    is the `src/index.js` file, which renders a component called `App`, which holds
    two other components called `Header` and `Board`. The first one is the actual
    header of the application, while the `Board` component holds the four columns
    we can see in the application. These columns are represented by the `Lane` component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, in the `assets` directory, we will see a file called `data.json`, which
    contains data that we can display on the project management board:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Creating a project management board application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll create a project management board PWA that uses React
    APIs such as Suspense and the HTML5 Drag and Drop API. We're going to use a Create
    React App, which we can find in the GitHub repository for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Handling the data flow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the initial version of the application in place, the next step is to fetch
    the data from the data file and handle its flow through the components. For this,
    we will use React Suspense and memo. With Suspense, we can access the React lazy
    API to dynamically load components and, with memo, we can control which components
    should rerender when their props change.
  prefs: []
  type: TYPE_NORMAL
- en: The first part of this section will show us how to load data from a data source
    using React life cycle methods and display this in React components.
  prefs: []
  type: TYPE_NORMAL
- en: Loading and displaying the data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Loading and displaying data that is retrieved from a data source is something
    we did in the previous chapter. This section will explore this further. Follow
    these steps to get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start by fetching the project data from the data file. To do this,
    we need to add the necessary functions to the `Board` component. We need these
    to access the React life cycles. These are `constructor`, where the initial state
    is set, and `componentDidMount`, where the data will be fetched:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the `componentDidMount` life cycle function, the data is fetched inside a
    `try..catch` statement. This statement catches any errors that are being returned
    from the data fetching process and replaces the error state with this message.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can distribute the tickets over the corresponding lanes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we can see that, inside `render`, the `data`, `loading`,
    and `error` constants have been destructured from the state object. Inside the
    function that iterates over the `lanes` constant, these values should be passed
    as props to the `Lane` component. For the data state, something special is going
    on since the `filter` function is being used to only return tickets from the `data`
    state that match the lane ID.
  prefs: []
  type: TYPE_NORMAL
- en: '3\. Next, we need to make some changes to the `Lane` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Lane` component now takes three other props, that is, `tickets`, `loading`,
    and `error`, where `tickets` contains the array of tickets from the `data` state, `loading`
    indicates whether the loading message should be displayed, and `error` contains
    the error message when there is one. We can see that a wrapper has been created
    and that, inside the `map` function, the `Ticket` component that displays the
    ticket information will be rendered. This `Ticket` component is also something
    we need to create in the `src/components` directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If we visit our application in a web browser at `http://localhost:3000`, we
    will see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/36586f9d-bcd0-4458-829f-6d7eaf57f8c3.png)'
  prefs: []
  type: TYPE_IMG
- en: As this application has been set up as a PWA, we can build the project again
    and restart the service worker. In offline mode, the project should still display
    the header and the four columns, with a message inside these columns that displays Failed
    to fetch*.*
  prefs: []
  type: TYPE_NORMAL
- en: To build and serve the PWA, we need to run `npm run` and `serve -s build` after
    the build process has completed. Now, we can visit the project at `http://localhost:5000`.
    We may need to restart the service worker, which we can do in the `devTools` on
    the Application tab, and select the Service Worker section. On the right-hand
    side of this section, next to the service worker, press Update. To check out the
    application in offline mode, we need to check the Offline checkbox.
  prefs: []
  type: TYPE_NORMAL
- en: Fetching data from a data source is logic that can be reused throughout our
    application. In the next section, we will explore how this logic can be reused across
    multiple components with HOC.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with HOC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: HOCs are advanced features in React that focus on the reusability of our components.
    They aren't part of the official React APIs, but introduce a pattern that is popular
    among the core team and many libraries, such as Redux.
  prefs: []
  type: TYPE_NORMAL
- en: In the first part of this section, we'll create our first HOC, which uses logic
    to retrieve data from the data source that we created in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: Creating HOC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we mentioned previously, HOCs focus on reusing components. Therefore, it
    can best be described as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '"A HOC is a function that takes a component and returns a new component."'
  prefs: []
  type: TYPE_NORMAL
- en: To explain what this means in practice, let's create an example. Our project
    has a `Board` component, which fetches and renders all the lanes. There is logic
    in this component in the form of a `constructor`, a `componentDidMount`, and information
    about how each `Lane` component is being rendered. How would we handle a situation
    where we just want to show a board without lanes, but only tickets? Do we just
    send different props to the `Board` component? Sure, that's possible, but, in
    React, that's what HOCs are used for.
  prefs: []
  type: TYPE_NORMAL
- en: A `Board` component without lanes wouldn't map over all the lanes and render
    the corresponding lane with the tickets as a prop. Instead, it would map over
    all the tickets and render them directly. Although the rendered components are
    different, the logic to set the initial state, fetch the data, and render the
    component(s) could be reused. The HOC should be able to add the life cycles to
    the `Board` component just by sending this component to it, along with some additional
    props.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create the HOC, place a new file called `withDataFetching.js` inside the
    `src` directory. Now, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to import React and create a new function for the HOC which
    becomes the default export. Since this HOC will add the life cycles for data fetching,
    let''s call this HOC `withDataFetching` and have it take a component as a parameter.
    This function should return another component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside this returned component, add the `constructor` component, which has
    almost the same structure as the `Board` component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to create the `componentDidMount` function, which is where the
    data fetching will be done. The `dataSource` prop is used as the location to fetch
    from. Also, notice that the constant names are now more generic and no longer
    specify a single use:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `render` function, we can return the `WrappedComponent` that was inserted
    into the function and pass the `data`, `loading`, and `error` state as props.
    It''s important to understand that it also takes any additional props that are
    spread with `{...this.props}`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Congratulations! You''ve created your very first HOC! However, it needs a component
    to return a component that supports data fetching. Therefore, we need to refactor
    our `Board` component into a function component. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the HOC from the `src/withDataFetching.js` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Subsequently, we can delete the entire class component, that is, `Board`, from
    this file and create a new function component that returns the JSX we declared
    in the `return` function for the refactored class component. This function component
    will take `lanes`, `loading`, `error`, and `data` as props:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '3\. Finally, export the function component along with the HOC function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'But where do these props come from? If we open the application and open up
    the browser, we will see the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This is because our `Board` component tries to map over the `lanes` prop, but,
    in the HOC, `WrappedComponent` receives the `data`, `loading`, and `error` props.
    Luckily, we''ve also added the option to spread over any additional props that
    are sent to the component. If we open the `App` component where the `Board` component
    is being opened, we can pass the `lanes` prop with the `lane` constant that was
    declared in the `Board` component previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we take a look at our project in the browser, we''ll see that the application
    has been rendered again. However, it displays an error message from the `try...catch`
    statement in the HOC. This HOC needs the `dataSource0` prop, which we also need
    to pass to the `Board` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we can see the `Board` component being rendered by the HOC in the browser.
    However, as we mentioned previously, a HOC is supposed to reuse logic. In the
    next section, we'll learn how to do this by adding the HOC to a different component.
  prefs: []
  type: TYPE_NORMAL
- en: Using the HOC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With the very first HOC in place it''s time to think of other components you
    can create with this HOC, such as a component that is displaying only tickets.
    The process to create this component consists of two steps: creating the actual
    component and importing the component and passing the required props to it. Let''s
    get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the directory containers, we need to create a new file called `Tickets.js` and
    place the following code inside it. Where we imported the HOC, set some basic
    styling with `styled-components` and create a function component that we can export
    with the HOC:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `App` component, we can import this component and pass a `dataSource`
    prop to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Something that seems a bit off is how the tickets are displayed next to each
    other without any margin. We could change this in the actual `Ticket` component,
    but that would also change the margin for the tickets that are displayed in the
    lanes. What we can do to solve this problem is pass a prop that is being used
    by `styled-components` to this component. To do this, we need to make changes
    to the `Tickets` component where we render the tickets and the `Ticket` component
    where the styling is defined. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pass a new prop called `marginRight` to the `Ticket` components inside the
    `map` function. This prop is just a Boolean and takes no value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `Ticket` component, we need to destructure this prop and pass it to
    the `TicketWrapper` we created with `styled-components`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can control the `margin-right` property for this `TicketWrapper` just
    by sending props to the `Ticket` component. If we view our application in a browser,
    we''ll see how, right below our `Board` component with the four lanes, another
    component rendering a `Ticket` component is being displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/996d76ec-4437-4aaa-bfef-3fe46f0753f4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Another thing we can customize is how the components that are returned by the
    HOC are named by the React developer tools. Open up the application in the browser
    and have a look at the component tree. Here, we can see the components that we''ve
    created without the HOC have a readable naming convention such as `App` or `Header`.
    The components that have been created by the HOC are named `<_class />`. To make
    this component tree more clear, we can easily have our HOC add this naming convention
    to the components it creates. Usually, we would use the name of the component
    that is created by the HOC. In our case, however, the HOC is called `withDataFetching`
    and when we insert a component called `Board`, the name that''s displayed in the
    React developer tools would be `withDataFetching(Board)`. To set this up, we need
    to make a few changes to the `withDataFetching.js` file. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Remove `return` before declaring the class component and give the class component
    a name. For this, use the name of the HOC and change the first character to a
    capital letter. This results in `WithDataFetching`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In the last few lines of this file, we can take the name of the `WrappedComponent`
    that has been inserted into the HOC and use it to name the HOC by setting the
    `displayName` of the returned component. Don''t forget to return the `WithDataFetching`
    class component at the end of this file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Looking at the React developer tools again, we can see that these changes have
    resulted in a more readable naming convention for the components that have been
    created by the HOC.
  prefs: []
  type: TYPE_NORMAL
- en: All the tickets that are displayed in the lanes are only in one part of our
    application since we want to be able to drag and drop these tickets into different
    lanes. We'll learn how to do this in the next section, where we'll add dynamic
    functionalities to the board.
  prefs: []
  type: TYPE_NORMAL
- en: Making the board dynamic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the things that usually gives project management boards great user interaction
    is the ability to drag and drop tickets from one lane into another. This is something
    that can easily be accomplished using the HTML5 Drag and Drop API, which is available
    in every modern browser, including IE11.
  prefs: []
  type: TYPE_NORMAL
- en: 'The HTML5 Drag and Drop API makes it possible for us to drag and drop elements
    across our project management board. To make this possible, it uses drag events. `onDragStart`, `onDragOver`,
    and `onDrop` will be used for this application. These events should be placed
    on both the `Lane` and the `Ticket` components. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to make the `Board` component a class component instead of a
    functional component. We''re doing this because the ticket data needs to be added
    to the state and the `Board` component is the most logical place to do this since
    we may want the `Lane` component to be reused somewhere else. We can do this by
    changing the definition of the `Board` constant, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can add the initial value for the tickets to the state. We''re doing
    this since we want to change the key of the lane it should be placed on. By adding
    this data to the state, we can mutate it dynamically with the `setState` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the data needs to be loaded from the source and isn''t available when
    the application first mounts, we need to check whether the props for these components
    have changed. If they have, we need to add the ticket data to the state. To do
    this, use the `componentDidUpdate` life cycle method, which can take the previous
    props as a parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, show the tickets from the state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: If we take at the project in the browser now, no visible changes should be present.
    The only difference is the data for the tickets is now loaded from the state,
    instead of being loaded from the props.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this same file, let''s add the functions that respond to the drop events,
    which need to be sent to the `Lane` and `Ticket` components:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by adding the event handler function for the `onDragStart` event, which fires
    when the dragging operation is started, to the `Board` component. This function
    needs to be passed to the `Lane` component, where it can be passed on to the `Ticket` component.
    This function sets an ID for the ticket that is being dragged to the `dataTransfer`
    object of the element, which is used by the browser to identify the drag element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `Lane` component, we need to pass this event handler function to the
    `Ticket` component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can invoke this function in the `Ticket` component, where we also need
    to add the `draggable` attribute to`TicketWrapper`. Here, we send the element
    and the ticket ID as a parameter to the event handler:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'After making these changes, we should be able to see each ticket can be dragged
    around. But don''t drop them anywhere yet—the other drop events and event handlers
    that update the state should be added as well. Dragging a ticket from one lane
    to another can be done by clicking on a ticket without releasing the mouse and
    dragging it to another lane, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/8294248f-db92-4260-9317-934a712d18a1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'With the `onDragStart` event implemented, the `onDragOver` and `onDrop` events
    can be implemented as well. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, it''s impossible to drop elements into another element; for example,
    a `Ticket` component into the `Lane` component. This can be prevented by calling
    the `preventDefault` method for the `onDragOver` event:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '2\. This event handler needs to be placed on the `Lane` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The `onDrop` event is where things get interesting since, this event makes it
    possible for us to mutate the state after we've finished the drag operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The event handler function for this event should be placed on the `Ticket` component,
    but defined in the `Board` component, since the `setState` function can only be
    invoked in the same file as the initial value for the state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This `onDrop` event handler function takes an element and ID of the lane as
    a parameter, because it needs the ID of the dragged element and the new lane it
    should be placed in. With this information, the function uses a `filter` function
    to find the ticket that needs to be moved and changes the ID of the lane. This
    new information will replace the current object for the tickets in the state with
    the `setState` function. Since the `onDrop` event gets fired from the `Lane` component,
    it is passed as a prop to this component. Also, the ID of the lane is added as
    a prop because this needs to be passed to the `onDrop` event handler function
    from the `Lane` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: With this, we're able to drag and drop tickets onto other lanes in our board.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you created a project management board that lets you move and
    drag and drop tickets from one lane to another using React Suspense and the HTML5
    Drag and Drop API. The data flow of this application is handled using local state
    and life cycles and determines which tickets are displayed in the different lanes.
    This chapter also introduced the advanced React pattern of **Higher-Order Components**
    (**HOCs**). With HOCs, you can reuse state logic from class components across
    your applications.
  prefs: []
  type: TYPE_NORMAL
- en: This advanced pattern will be also be used in the next chapter, which will handle
    routing and **Server-Side Rendering** (**SSR**) in React applications. Have you
    ever tried using Stack Overflow to find a solution to a programming issue you
    once had? I have!
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be building a community feed that uses Stack Overflow
    as a data source and React to render the application.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Drag and Drop API: [https://developer.mozilla.org/en-US/docs/Web/API/HTML_Drag_and_Drop_API](https://developer.mozilla.org/en-US/docs/Web/API/HTML_Drag_and_Drop_API).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HOC: [https://medium.com/@dan_abramov/mixins-are-dead-long-live-higher-order-components-94a0d2f9e750](https://medium.com/@dan_abramov/mixins-are-dead-long-live-higher-order-components-94a0d2f9e750).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DataTransfer: [https://developer.mozilla.org/en-US/docs/Web/API/DataTransfer](https://developer.mozilla.org/en-US/docs/Web/API/DataTransfer).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: React DnD: [https://github.com/react-dnd/react-dnd](https://github.com/react-dnd/react-dnd).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
