- en: Continuous Integration Pipeline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We already know how to configure Jenkins. In this chapter, you will see how
    to use it effectively, focusing on the feature that lays at the heart of Jenkins,
    pipelines. By building a complete Continuous Integration process from scratch,
    we will describe all aspects of modern team-oriented code development.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following points:'
  prefs: []
  type: TYPE_NORMAL
- en: Explaining the idea of pipelining
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing the Jenkins pipeline syntax
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a Continuous Integration pipeline
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explaining the idea of Jenkinsfile
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating code quality checks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding pipeline triggers and notifications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explaining development workflows and branching strategies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing Jenkins Multibranch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing pipelines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A pipeline is a sequence of automated operations that usually represents a
    part of software delivery and the quality assurance process. It can be simply
    seen as a chain of scripts providing the following additional benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Operation grouping**: Operations are grouped together into stages (also known
    as **gates** or **quality gates**) that introduce a structure into the process
    and clearly defines the rule: if one stage fails, no further stages are executed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Visibility**: All aspects of the process are visualized, which help in quick
    failure analysis and promotes team collaboration'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Feedback**: Team members learn about any problems as soon as they occur,
    so they can react quickly'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The concept of pipelining is similar for most Continuous Integration tools,
    however, the naming can differ. In this book, we stick to the Jenkins terminology.
  prefs: []
  type: TYPE_NORMAL
- en: Pipeline structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A Jenkins pipeline consists of two kinds of elements: stages and steps. The
    following figure shows how they are used:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/f0485dcf-1ed8-4ab0-bb5a-7cea1f89a09f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following are the basic pipeline elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Step**: A single operation (tells Jenkins what to do, for example, checkout
    code from repository, execute a script)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stage**: A logical separation of steps (groups conceptually distinct sequences
    of steps, for example, **Build, Test,** and **Deploy**) used to visualize the
    Jenkins pipeline progress'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technically, it's possible to create parallel steps; however, it's better to
    treat it as an exception when really needed for optimization purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Multi-stage Hello World
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As an example, let''s extend the `Hello World` pipeline to contain two stages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The pipeline has no special requirements in terms of environment (any slave
    agent), and it executes three steps inside two stages. When we click on Build
    Now, we should see the visual representation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/e654212a-9407-4e1a-9543-e54ee2b15bdf.png)'
  prefs: []
  type: TYPE_IMG
- en: The pipeline succeeded, and we can see the step execution details by clicking
    on the console. If any of the steps failed, the processing would stop and no further
    steps would run. Actually, the entire reason for a pipeline is to prevent all
    further steps from execution and visualize the point of failure.
  prefs: []
  type: TYPE_NORMAL
- en: Pipeline syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have discussed the pipeline elements and already used a few of the pipeline
    steps, for example, `echo`. What other operations can we use inside the pipeline
    definition?
  prefs: []
  type: TYPE_NORMAL
- en: In this book, we use the declarative syntax that is recommended for all new
    projects. The different options are Groovy-based DSL and (prior to Jenkins 2)
    XML (created via the web interface).
  prefs: []
  type: TYPE_NORMAL
- en: The declarative syntax was designed to make it as simple as possible to understand
    the pipeline, even by the people who do not write code on a daily basis. This
    is why the syntax is limited only to the most important keywords.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s prepare an experiment and, before we describe all the details, read
    the following pipeline definition and try to guess what it does:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Hopefully, the pipeline didn''t scare you. It is quite complex. Actually, it
    is so complex that it contains all possible Jenkins instructions. To answer the
    experiment puzzle, let''s see what the pipeline does instruction by instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: Use any available agent.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Execute automatically every minute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Stop if the execution takes more than 5 minutes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ask for the Boolean input parameter before starting.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set `Rafal` as the environment variable NAME.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Only in the case of the `true` input parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Print `Hello from Rafal`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Print `Testing the chrome browser`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Print `Testing the firefox browser`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Print `I will always say Hello again!` no matter if there are any errors during
    the execution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's describe the most important Jenkins keywords. A declarative pipeline is
    always specified inside the `pipeline` block and contains sections, directives,
    and steps. We will walk through each of them.
  prefs: []
  type: TYPE_NORMAL
- en: The complete pipeline syntax description can be found on the official Jenkins
    page at [https://jenkins.io/doc/book/pipeline/syntax/](https://jenkins.io/doc/book/pipeline/syntax/).
  prefs: []
  type: TYPE_NORMAL
- en: Sections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sections define the pipeline structure and usually contain one or more directives
    or steps. They are defined with the following keywords:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Stages**: This defines a series of one or more stage directives'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Steps**: This defines a series of one or more step instructions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Post**: This defines a series of one or more step instructions that are run
    at the end of the pipeline build; marked with a condition (for example, always,
    success, or failure), usually used to send notifications after the pipeline build
    (we will cover this in detail in the *Triggers and notifications* section.)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Directives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Directives express the configuration of a pipeline or its parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Agent**: This specifies where the execution takes place and can define the
    `label` to match the equally labeled agents or `docker` to specify a container
    that is dynamically provisioned to provide an environment for the pipeline execution'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Triggers**: This defines automated ways to trigger the pipeline and can use
    `cron` to set the time-based scheduling or `pollScm` to check the repository for
    changes (we will cover this in detail in the *Triggers and notifications* section)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Options**: This specifies pipeline-specific options, for example, `timeout` (maximum
    time of pipeline run) or `retry` (number of times the pipeline should be rerun
    after failure)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Environment**: This defines a set of key values used as environment variables
    during the build'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Parameters**: This defines a list of user-input parameters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stage**: This allows for logical grouping of steps'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**When**: This determines whether the stage should be executed depending on
    the given condition'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Steps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Steps are the most fundamental part of the pipeline. They define the operations
    that are executed, so they actually tell Jenkins **what to do**.
  prefs: []
  type: TYPE_NORMAL
- en: '**sh**: This executes the shell command; actually, it''s possible to define
    almost any operation using `sh`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**custom**: Jenkins offers a lot of operations that can be used as steps (for
    example, `echo`); many of them are simply wrappers over the `sh` command used
    for convenience; plugins can also define their own operations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**script**: This executes a block of the Groovy-based code that can be used
    for some non-trivial scenarios, where flow control is needed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The complete specification of the available steps can be found at: [https://jenkins.io/doc/pipeline/steps/](https://jenkins.io/doc/pipeline/steps/).
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the pipeline syntax is very generic and technically, can be used
    for almost any automation process. This is why the pipeline should be treated
    as a method of structurization and visualization. The most common use case is,
    however, implementing the Continuous Integration server that we will look at in
    the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Commit pipeline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most basic Continuous Integration process is called a commit pipeline. This
    classic phase, as its name says, starts with a commit (or push in Git) to the
    main repository and results in a report about the build success or failure. Since
    it runs after each change in the code, the build should take no more than 5 minutes
    and should consume a reasonable amount of resources. The commit phase is always
    the starting point of the Continuous Delivery process, and it provides the most
    important feedback cycle in the development process, constant information if the
    code is in a healthy state.
  prefs: []
  type: TYPE_NORMAL
- en: 'The commit phase works as follows. A developer checks in the code to the repository,
    the Continuous Integration server detects the change, and the build starts. The
    most fundamental commit pipeline contains three stages:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Checkout**: This stage downloads the source code from the repository'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Compile**: This stage compiles the source code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Unit test**: This stage runs a suite of unit tests'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's create a sample project and see how to implement the commit pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: This is an example of a pipeline for the project that uses technologies such
    as Git, Java, Gradle, and Spring Boot. Nevertheless, the same principles apply
    to any other technology.
  prefs: []
  type: TYPE_NORMAL
- en: Checkout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Checking out code from the repository is always the first operation in any pipeline.
    In order to see this, we need to have a repository. Then, we will be able to create
    a pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a GitHub repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Creating a repository on the GitHub server takes just a few steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to the [https://github.com/](https://github.com/) page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an account if you don't have one yet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on New repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Give it a name, `calculator`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tick Initialize this repository with a README.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on Create repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, you should see the address of the repository, for example, `https://github.com/leszko/calculator.git`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a checkout stage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can create a new pipeline called `calculator` and, as **Pipeline script**,
    put the code with a stage called Checkout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The pipeline can be executed on any of the agents, and its only step does nothing
    more than downloading code from the repository. We can click on Build Now and
    see if it was executed successfully.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the Git toolkit needs to be installed on the node where the build
    is executed.
  prefs: []
  type: TYPE_NORMAL
- en: When we have the checkout, we're ready for the second stage.
  prefs: []
  type: TYPE_NORMAL
- en: Compile
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to compile a project, we need to:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a project with the source code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Push it to the repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the Compile stage to the pipeline.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating a Java Spring Boot project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's create a very simple Java project using the Spring Boot framework built
    by Gradle.
  prefs: []
  type: TYPE_NORMAL
- en: Spring Boot is a Java framework that simplifies building enterprise applications.
    Gradle is a build automation system that is based on the concepts of Apache Maven.
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest way to create a Spring Boot project is to perform the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to the [http://start.spring.io/](http://start.spring.io/) page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select Gradle project instead of Maven project (you can also leave Maven if
    you prefer it to Gradle).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fill Group and Artifact (for example, `com.leszko` and `calculator`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add Web to Dependencies.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on Generate Project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The generated skeleton project should be downloaded (the `calculator.zip` file).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following screenshot presents the [http://start.spring.io/](http://start.spring.io/)
    page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/f7679438-1eed-48ca-be76-8fc68853701d.png)'
  prefs: []
  type: TYPE_IMG
- en: Pushing code to GitHub
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will use the Git tool to perform the `commit` and `push` operations:'
  prefs: []
  type: TYPE_NORMAL
- en: In order to run the `git` command, you need to have the Git toolkit installed
    (it can be downloaded from [https://git-scm.com/downloads](https://git-scm.com/downloads)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first clone the repository to the filesystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Extract the project downloaded from [http://start.spring.io/](http://start.spring.io/)
    into the directory created by Git.
  prefs: []
  type: TYPE_NORMAL
- en: If you prefer, you can import the project into IntelliJ, Eclipse, or your favorite
    IDE tool.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a result, the `calculator` directory should have the following files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In order to perform the Gradle operations locally, you need to have Java JDK
    installed (in Ubuntu, you can do it by executing `sudo apt-get install -y default-jdk`).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can compile the project locally using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In the case of Maven, you can run `./mvnw compile`. Both Gradle and Maven compile
    the Java classes located in the `src` directory.
  prefs: []
  type: TYPE_NORMAL
- en: You can find all possible Gradle instructions (for the Java project) at [https://docs.gradle.org/current/userguide/java_plugin.html](https://docs.gradle.org/current/userguide/java_plugin.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can `commit` and `push` to the GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: After running the `git push` command, you will be prompted to enter the GitHub
    credentials (username and password).
  prefs: []
  type: TYPE_NORMAL
- en: The code is already in the GitHub repository. If you want to check it, you can
    go to the GitHub page and see the files.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a compile stage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can add a `Compile` stage to the pipeline using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note that we used exactly the same command locally and in the Jenkins pipeline,
    which is a very good sign because the local development process is consistent
    with the Continuous Integration environment. After running the build, you should
    see two green boxes. You can also check that the project was compiled correctly
    in the console log.
  prefs: []
  type: TYPE_NORMAL
- en: Unit test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s time to add the last stage that is Unit test, which checks if our code
    does what we expect it to do. We have to:'
  prefs: []
  type: TYPE_NORMAL
- en: Add the source code for the calculator logic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write unit test for the code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a stage to execute the unit test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating business logic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first version of the calculator will be able to add two numbers. Let''s
    add the business logic as a class in the `src/main/java/com/leszko/calculator/Calculator.java` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'To execute the business logic, we also need to add the web service controller
    in a separate file `src/main/java/com/leszko/calculator/CalculatorController.java`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This class exposes the business logic as a web service. We can run the application
    and see how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: It should start our web service and we can check that it works by navigating
    to the browser and opening the page `http://localhost:8080/sum?a=1&b=2`. This
    should sum two numbers ( `1` and `2`) and show `3` in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a unit test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We already have the working application. How can we ensure that the logic works
    as expected? We have tried it once, but in order to know constantly, we need a
    unit test. In our case, it will be trivial, maybe even unnecessary; however, in
    real projects, unit tests can save from bugs and system failures.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a unit test in the file `src/test/java/com/leszko/calculator/CalculatorTest.java`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We can run the test locally using the `./gradlew test` command. Then, let''s
    `commit` the code and `push` it to the repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Creating a unit test stage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we can add a `Unit test` stage to the pipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In the case of Maven, we would have to use `./mvnw test`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we build the pipeline again, we should see three boxes, which means that
    we''ve completed the Continuous Integration pipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ee925c80-529f-4732-8a8e-57c41190cf79.png)'
  prefs: []
  type: TYPE_IMG
- en: Jenkinsfile
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the time, so far, we created the pipeline code directly in Jenkins. This
    is, however, not the only option. We can also put the pipeline definition inside
    a file called `Jenkinsfile` and `commit` it to the repository together with the
    source code. This method is even more consistent because the way your pipeline
    looks is strictly related to the project itself.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if you don't need the code compilation because your programming
    language is interpreted (and not compiled), then you won't have the `Compile`
    stage. The tools you use also differ depending on the environment. We used Gradle/Maven
    because we've built the Java project; however, in the case of a project written
    in Python, you could use PyBuilder. It leads to the idea that the pipelines should
    be created by the same people who write the code, developers. Also, the pipeline
    definition should be put together with the code, in the repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'This approach brings immediate benefits, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: In case of Jenkins' failure, the pipeline definition is not lost (because it's
    stored in the code repository, not in Jenkins)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The history of the pipeline changes is stored
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pipeline changes go through the standard code development process (for example,
    they are subjected to code reviews)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Access to the pipeline changes is restricted exactly in the same way as the
    access to the source code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating Jenkinsfile
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can create the `Jenkinsfile` and push it to our GitHub repository. Its content
    is almost the same as the commit pipeline we wrote. The only difference is that
    the checkout stage becomes redundant because Jenkins has to checkout the code
    (together with `Jenkinsfile`) first and then read the pipeline structure (from
    `Jenkinsfile`). This is why Jenkins needs to know the repository address before
    it reads `Jenkinsfile`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a file called `Jenkinsfile` in the root directory of our project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now `commit` the added files and `push` to the GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Running pipeline from Jenkinsfile
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When `Jenkinsfile` is in the repository, then all we have to do is to open
    the pipeline configuration and in the `Pipeline` section:'
  prefs: []
  type: TYPE_NORMAL
- en: Change Definition from `Pipeline script` to `Pipeline script from SCM`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Select Git in SCM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Put `https://github.com/leszko/calculator.git` in Repository URL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](assets/2abce73b-7789-4457-9252-7eff8f912dbf.png)'
  prefs: []
  type: TYPE_IMG
- en: After saving, the build will always run from the current version of Jenkinsfile
    into the repository.
  prefs: []
  type: TYPE_NORMAL
- en: We have successfully created the first complete commit pipeline. It can be treated
    as a minimum viable product, and actually, in many cases, it's sufficient as the
    Continuous Integration process. In the next sections, we will see what improvements
    can be done to make the commit pipeline even better.
  prefs: []
  type: TYPE_NORMAL
- en: Code quality stages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can extend the classic three steps of Continuous Integration with additional
    steps. The most widely used are code coverage and static analysis. Let's look
    at each of them.
  prefs: []
  type: TYPE_NORMAL
- en: Code coverage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Think about the following scenario: you have a well-configured Continuous Integration
    process; however, nobody in your project writes unit tests. It passes all the
    builds, but it doesn''t mean that the code is working as expected. What to do
    then? How to ensure that the code is tested?'
  prefs: []
  type: TYPE_NORMAL
- en: The solution is to add the code coverage tool that runs all tests and verifies
    which parts of the code have been executed. Then, it creates a report showing
    not-tested sections. Moreover, we can make the build fail when there is too much
    untested code.
  prefs: []
  type: TYPE_NORMAL
- en: There are a lot of tools available to perform the test coverage analysis; for
    Java, the most popular are JaCoCo, Clover, and Cobertura.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use JaCoCo and show how the coverage check works in practice. In order
    to do this, we need to perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Add JaCoCo to the Gradle configuration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the code coverage stage to the pipeline.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Optionally, publish JaCoCo reports in Jenkins.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adding JaCoCo to Gradle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to run JaCoCo from Gradle, we need to add the `jacoco` plugin to the
    `build.gradle` file by adding the following line in the plugin section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, if we would like to make the Gradle fail in case of too low code coverage,
    we can add the following configuration to the `build.gradle` file as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This configuration sets the minimum code coverage to 20%. We can run it with
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The command checks if the code coverage is at least 20%. You can play with
    the minimum value to see the level at which the build fails. We can also generate
    a test coverage report using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also have a look at the full coverage report in the `build/reports/jacoco/test/html/index.html` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/f40840a3-e0e7-47f2-810c-53cd492ae0f6.png)'
  prefs: []
  type: TYPE_IMG
- en: Adding a code coverage stage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Adding a code coverage stage to the pipeline is as simple as the previous stages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: After adding this stage, if anyone commits code that is not well-covered with
    tests, the build will fail.
  prefs: []
  type: TYPE_NORMAL
- en: Publishing the code coverage report
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When the coverage is low and the pipeline fails, it would be useful to look
    at the code coverage report and find what parts are not yet covered with tests.
    We could run Gradle locally and generate the coverage report; however, it is more
    convenient if Jenkins shows the report for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to publish the code coverage report in Jenkins, we need the following
    stage definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This stage copies the generated JaCoCo report to the Jenkins output. When we
    run the build again, we should see a link to the code coverage reports (in the
    menu on the left side, below "Build Now").
  prefs: []
  type: TYPE_NORMAL
- en: To perform the `publishHTML` step, you need to have the **HTML Publisher** plugin
    installed in Jenkins. You can read more about the plugin at [https://jenkins.io/doc/pipeline/steps/htmlpublisher/#publishhtml-publish-html-reports](https://jenkins.io/doc/pipeline/steps/htmlpublisher/#publishhtml-publish-html-reports).
  prefs: []
  type: TYPE_NORMAL
- en: We have created the code coverage stage, which shows the code that is not tested
    and therefore vulnerable to bugs. Let's see what else can be done in order to
    improve the code quality.
  prefs: []
  type: TYPE_NORMAL
- en: If you need code coverage that is more strict, you can check the concept of
    mutation testing and add the PIT framework stage to the pipeline. Read more at [http://pitest.org/](http://pitest.org/).
  prefs: []
  type: TYPE_NORMAL
- en: Static code analysis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Your code may work perfectly fine, however, what about the quality of the code
    itself? How do we ensure it is maintainable and written in a good style?
  prefs: []
  type: TYPE_NORMAL
- en: Static code analysis is an automatic process of checking the code without actually
    executing it. In most cases, it implies checking a number of rules on the source
    code. These rules may apply to a wide range of aspects; for example, all public
    classes need to have a Javadoc comment; the maximum length of a line is 120 characters,
    or if a class defines the `equals()` method, it has to define the `hashCode()`
    method as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most popular tools to perform the static analysis on the Java code are
    Checkstyle, FindBugs, and PMD. Let''s look at an example and add the static code
    analysis stage using Checkstyle. We will do this in three steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Add the Checkstyle configuration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the Checkstyle stage.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Optionally, publish the Checkstyle report in Jenkins.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adding the Checkstyle configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to add the Checkstyle configuration, we need to define the rules against
    which the code is checked. We can do this by specifying the `config/checkstyle/checkstyle.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The configuration contains only one rule: Checking if public classes, interfaces,
    and enums are documented with Javadoc. If they are not, the build fails.'
  prefs: []
  type: TYPE_NORMAL
- en: The complete Checkstyle description can be found at [http://checkstyle.sourceforge.net/config.html](http://checkstyle.sourceforge.net/config.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to add the `checkstyle` plugin to the `build.gradle` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can run the `checkstyle` with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'In the case of our project, it should result in a failure because none of our
    public classes (`Calculator.java`, `CalculatorApplication.java`, `CalculatorTest.java`, `CalculatorApplicationTests.java`) has
    a Javadoc comment. We need to fix it by adding the documentation, for example,
    in case of the `src/main/java/com/leszko/calculator/CalculatorApplication.java` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Now, the build should be successful.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a static code analysis stage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can add a `Static code analysis` stage to the pipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Now, if anyone commits a file with a public class without Javadoc, the build
    will fail.
  prefs: []
  type: TYPE_NORMAL
- en: Publishing static code analysis reports
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Very similar to JaCoCo, we can add the Checkstyle report to Jenkins:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: It generates a link to the Checkstyle report.
  prefs: []
  type: TYPE_NORMAL
- en: We have added the static code analysis stage that can help in finding bugs and
    in standardizing the code style inside the team or organization.
  prefs: []
  type: TYPE_NORMAL
- en: SonarQube
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SonarQube is the most widespread source code quality management tool. It supports
    multiple programming languages and can be treated as an alternative to the code
    coverage and static code analysis steps we looked at. Actually, it is a separate
    server that aggregates different code analysis frameworks, such as Checkstyle,
    FindBugs, and JaCoCo. It has its own dashboards and integrates well with Jenkins.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of adding code quality steps to the pipeline, we can install SonarQube,
    add plugins there, and add a "sonar" stage to the pipeline. The advantage of this
    solution is that SonarQube provides a user-friendly web interface to configure
    rules and show code vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: You can read more about SonarQube on its official page [https://www.sonarqube.org/](https://www.sonarqube.org/).
  prefs: []
  type: TYPE_NORMAL
- en: Triggers and notifications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have always built the pipeline manually by clicking on the Build
    Now button. It works but is not very convenient. All team members would have to
    remember that after committing to the repository, they need to open Jenkins and
    start the build. The same works with pipeline monitoring; so far, we manually
    opened Jenkins and checked the build status. In this section, we will see how
    to improve the process so that the pipeline would start automatically and, when
    completed, notify the team members about its status.
  prefs: []
  type: TYPE_NORMAL
- en: Triggers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An automatic action to start the build is called the pipeline trigger. In Jenkins,
    there are many options to choose from; however, they all boil down to three types:'
  prefs: []
  type: TYPE_NORMAL
- en: External
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Polling SCM (Source Control Management)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scheduled build
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's take a look at each of them.
  prefs: []
  type: TYPE_NORMAL
- en: External
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: External triggers are natural to understand. They mean that Jenkins starts the
    build after it's called by the notifier, which can be the other pipeline build,
    the SCM system (for example, GitHub), or any remote script.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure presents the communication:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/51bf1a24-ebcd-48de-b743-4bea791ba412.png)'
  prefs: []
  type: TYPE_IMG
- en: GitHub triggers Jenkins after a push to the repository and the build is started.
  prefs: []
  type: TYPE_NORMAL
- en: 'To configure the system this way, we need the following setup steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Install the GitHub plugin in Jenkins.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generate a secret key for Jenkins.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the GitHub web hook and specify the Jenkins address and key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the case of the most popular SCM providers, dedicated Jenkins plugins are
    always provided.
  prefs: []
  type: TYPE_NORMAL
- en: There is also a more generic way to trigger Jenkins via the REST call to the
    endpoint `<jenkins_url>/job/<job_name>/build?token=<token>`. For security reasons,
    it requires setting `token` in Jenkins and then using it in the remote script.
  prefs: []
  type: TYPE_NORMAL
- en: Jenkins must be accessible from the SCM server. In other words, if we use the
    public GitHub to trigger Jenkins, then our Jenkins server must be public as well.
    This also applies to the generic solution; the `<jenkins_url>` address must be
    accessible.
  prefs: []
  type: TYPE_NORMAL
- en: Polling SCM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Polling SCM trigger is a little less intuitive. The following figure presents
    the communication:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/ea1d08c6-7d01-477e-9d0f-3639f4aabc12.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Jenkins periodically calls GitHub and checks if there was any push to the repository.
    Then, it starts the build. It may sound counter-intuitive, however, there are
    at least two good cases for using this method:'
  prefs: []
  type: TYPE_NORMAL
- en: Jenkins is inside the firewalled network (which GitHub does not have access
    to)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Commits are frequent and the build takes a long time, so executing a build after
    every commit would cause an overload
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The configuration of **poll SCM** is also somehow simpler because the way to
    connect from Jenkins to GitHub is already set up (Jenkins checks out the code
    from GitHub, so it needs to have access). In the case of our calculator project,
    we can set up an automatic trigger by adding the `triggers` declaration (just
    after `agent`) to the pipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: After running the pipeline manually for the first time, the automatic trigger
    is set. Then, it checks GitHub every minute, and for new commits, it starts a
    build. To test that it works as expected, you can commit and push anything to
    the GitHub repository and see that the build starts.
  prefs: []
  type: TYPE_NORMAL
- en: We used the mysterious `* * * * *` as an argument to `pollSCM`. It specifies
    how often Jenkins should check for new source changes and is expressed in the
    cron-style string format.
  prefs: []
  type: TYPE_NORMAL
- en: The cron string format is described (together with the cron tool) at [https://en.wikipedia.org/wiki/Cron](https://en.wikipedia.org/wiki/Cron).
  prefs: []
  type: TYPE_NORMAL
- en: Scheduled build
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Scheduled trigger means that Jenkins runs the build periodically, no matter
    if there was any commit to the repository or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the following figure presents, there is no communication with any system
    needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a7ecf582-38bd-4402-98f3-b28700ff392a.png)'
  prefs: []
  type: TYPE_IMG
- en: The implementation of Scheduled build is exactly the same as polling SCM. The
    only difference is that the keyword `cron` is used instead of `pollSCM`. This
    trigger method is rarely used for the commit pipeline but applies well to nightly
    builds (for example, complex integration testing executed at nights).
  prefs: []
  type: TYPE_NORMAL
- en: Notifications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Jenkins provides a lot of ways to announce its build status. What's more, as
    with everything in Jenkins, new notification types can be added using plugins.
  prefs: []
  type: TYPE_NORMAL
- en: Let's walk through the most popular types so that you can choose the one that
    fits your needs.
  prefs: []
  type: TYPE_NORMAL
- en: Email
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most classic way to notify about the Jenkins build status is to send emails.
    The advantage of this solution is that everybody has a mailbox; everybody knows
    how to use the mailbox; and everybody is used to receiving information by the
    mailbox. The drawback is that usually there are simply too many emails and the
    ones from Jenkins quickly become filtered out and never read.
  prefs: []
  type: TYPE_NORMAL
- en: 'The configuration of the email notification is very simple; it''s enough to:'
  prefs: []
  type: TYPE_NORMAL
- en: Have the SMTP server configured
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set its details in Jenkins (in Manage Jenkins | Configure System)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `mail to` instruction in the pipeline
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The pipeline configuration can be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that all notifications are usually called in the `post` section of the
    pipeline, which is executed after all steps, no matter whether the build succeeded
    or failed.  We used the `always` keyword; however, there are different options:'
  prefs: []
  type: TYPE_NORMAL
- en: '**always:** Execute regardless of the completion status'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**changed:** Execute only if the pipeline changed its status'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**failure:** Execute only if the pipeline has the **failed** status'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**success:** Execute only if the pipeline has the **success** status'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**unstable:** Execute only if the pipeline has the **unstable** status (usually
    caused by test failures or code violations)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Group chat
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If group chat (for example, Slack or HipChat) is the first method of communication
    in your team, then it''s worth considering adding the automatic build notifications
    there. No matter which tool you use, the procedure to configure it is always the
    same:'
  prefs: []
  type: TYPE_NORMAL
- en: Find and install plugin for your group chat tool (for example, the **Slack Notification**
    plugin).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure the plugin (server URL, channel, authorization token, and so on).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the sending instruction to the pipeline.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s see a sample pipeline configuration for Slack to send notifications
    after the build fails:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Team space
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Together with the agile culture came the idea that it's better to have everything
    happening in the team space. Instead of writing emails, meet together; instead
    of online messaging, come and talk; instead of task-tracking tool, have a whiteboard.
    The same idea came to Continuous Delivery and Jenkins. Currently, it's very common
    to install big screens (also called **build radiators**) in the team space. Then,
    when you come to the office, the first thing you see is the current status of
    the pipeline. Build radiators are considered one of the most effective notification
    strategies. They ensure that everyone is aware of failing builds and, as a side-effect
    benefit, they boost team spirit and favor in-person communication.
  prefs: []
  type: TYPE_NORMAL
- en: Since developers are creative beings, they invented a lot of other ideas that
    play the same role as the radiators. Some teams hang large speakers that beep
    when the pipeline failed. Some others have toys that blink when the build is done.
    One of my favorites is Pipeline State UFO, which is provided as an open source
    project on GitHub. On its page, you can find the description of how to print and
    configure a UFO that hangs under the ceiling and signals the pipeline state. You
    can find more at [https://github.com/Dynatrace/ufo](https://github.com/Dynatrace/ufo).
  prefs: []
  type: TYPE_NORMAL
- en: Since Jenkins is extensible by plugins, its community wrote a lot of different
    ways to inform about the build statuses. Among them, you can find RSS feeds, SMS
    notifications, mobile applications, desktop notifiers, and much more.
  prefs: []
  type: TYPE_NORMAL
- en: Team development strategies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already described everything about how the Continuous Integration pipeline
    should look. However, when exactly should it be run? Of course, it is triggered
    after the commit to the repository but after the commit to which branch? Only
    to the trunk or to every branch? Or maybe it should run before, not after committing
    so that the repository would always be healthy? Or, how about the crazy idea to
    have no branches at all?
  prefs: []
  type: TYPE_NORMAL
- en: There is no single best answer to these questions. Actually, the way you use
    the Continuous Integration process depends on your team development workflow.
    So, before we go any further, let's describe what the possible workflows are.
  prefs: []
  type: TYPE_NORMAL
- en: Development workflows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A development workflow is the way your team puts the code into the repository.
    It depends, of course, on many factors such as the source control management tool,
    the project specifics, or the team size.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a result, each team develops the code in a slightly different manner. We
    can, however, classify them into three types: trunk-based workflow, branching
    workflow, and forking workflow.'
  prefs: []
  type: TYPE_NORMAL
- en: All workflows are described in detail with examples at [https://www.atlassian.com/git/tutorials/comparing-workflows](https://www.atlassian.com/git/tutorials/comparing-workflows).
  prefs: []
  type: TYPE_NORMAL
- en: Trunk-based workflow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Trunk-based workflow is the simplest possible strategy. Its overview is presented
    in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/dfd60182-ccde-4fba-aec5-e01d4fb677af.png)'
  prefs: []
  type: TYPE_IMG
- en: There is one central repository with a single entry for all changes to the project,
    which is called the trunk or master. Every member of the team clones the central
    repository to have their own local copies. The changes are committed directly
    to the central repository.
  prefs: []
  type: TYPE_NORMAL
- en: Branching workflow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Branching workflow, as its name suggests, means that the code is kept in many
    different branches. The idea is presented in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/18d4bcff-09cf-42c4-8e90-b88268349bee.png)'
  prefs: []
  type: TYPE_IMG
- en: When developers start to work on a new feature, they create a dedicated branch
    from the trunk and commit all feature-related changes there. This makes it easy
    for multiple developers to work on a feature without breaking the main codebase.
    This is why, in the case of branching workflow, there is no problem in keeping
    the master healthy. When the feature is completed, a developer rebases the feature
    branch from master and creates a pull request that contains all feature-related
    code changes. It opens the code review discussions and makes space to check if
    the changes don't disturb the master. When the code is accepted by other developers
    and automatic system checks, then it is merged into the main codebase. Then, the
    build is run again on master but should almost never fail since it didn't fail
    on the branch.
  prefs: []
  type: TYPE_NORMAL
- en: Forking workflow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Forking workflow is very popular among the open source community. Its idea
    is presented in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/83ff827e-d29b-4e4e-8449-cb5d979dc6a2.png)'
  prefs: []
  type: TYPE_IMG
- en: Each developer has his own server-side repository. They may or may not be the
    official repository, but technically, each repository is exactly the same.
  prefs: []
  type: TYPE_NORMAL
- en: Forking means literally creating a new repository from the other repository.
    Developers push to their own repositories and when they want to integrate the
    code, they create a pull request to the other repository.
  prefs: []
  type: TYPE_NORMAL
- en: The main advantage of the forking workflow is that the integration is not necessarily
    via a central repository. It also helps with the ownership because it allows accepting
    pull requests from others without giving them write access.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of requirement-oriented commercial projects, the team usually works
    on one product and therefore has a central repository, so this model boils down
    to the branching workflow with the good ownership assignment, for example, only
    project leads can merge pull requests into the central repository.
  prefs: []
  type: TYPE_NORMAL
- en: Adopting Continuous Integration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We described different development workflows, but how do they influence the
    Continuous Integration configuration?
  prefs: []
  type: TYPE_NORMAL
- en: Branching strategies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Each development workflow implies a different Continuous Integration approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Trunk-based workflow**: implies constantly struggling against the broken
    pipeline. If everyone commits to the main codebase, then the pipeline often fails.
    In this case, the old Continuous Integration rule says, "*If the build is broken,
    then the development team stops whatever they are doing and fixes the problem
    immediately*."'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Branching workflow**: solves the broken trunk issue but introduces another
    one: if everyone develops in their own branches, then where is the integration?
    A feature usually takes weeks or months to develop, and for all this time, the
    branch is not integrated into the main code, therefore it cannot be really called
    "continuous" integration; not to mention that there is a constant need for merging
    and resolving conflicts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Forking workflow**: implies managing the Continuous Integration process by
    every repository owner, which isn''t usually a problem. It shares, however, the
    same issues as the branching workflow.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is no silver bullet, and different organizations choose different strategies.
    The solution that is the closest to perfection is using the technique of the branching
    workflow and the philosophy of the trunk-based workflow. In other words, we can
    create very small branches and integrate them frequently into master. This seems
    to take the best of both, however, requires either having tiny features or using
    feature toggles. Since the concept of feature toggles fits very well into Continuous
    Integration and Continuous Delivery, let's take a moment to explore it.
  prefs: []
  type: TYPE_NORMAL
- en: Feature toggles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Feature toggle is a technique that is an alternative to maintaining multiple
    source code branches such that the feature can be tested before it is completed
    and ready for release. It is used to disable the feature for users but enable
    it for developers while testing. Feature toggles are essentially variables used
    in conditional statements.
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest implementation of feature toggles are flags and the `if` statements.
    A development using feature toggles, as opposed to feature branching development,
    looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A new feature has to be implemented.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new flag or a configuration property `feature_toggle` (instead of the `feature` branch).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Every feature-related code is added inside the `if` statement (instead of committing
    to the `feature` branch), for example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'During the feature development:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Coding is done in master with `feature_toggle = true` (instead of coding in
    the feature branch)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Release is done from master with `feature_toggle = false`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the feature development is completed, all `if` statements are removed and
    `feature_toggle` is removed from the configuration (instead of merging `feature`
    to master and removing the `feature` branch).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The benefit of feature toggle is that all development is done in the `trunk`,
    which enables the real Continuous Integration and mitigates problems with merging
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Jenkins Multibranch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you decide to use branches in any form, the long feature branches or the
    recommended short-lived branches, then it is convenient to know that the code
    is healthy before merging it into master. This approach results in always keeping
    the main codebase green and, luckily, there is an easy way to do it with Jenkins.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to use Multibranch in our calculator project, let''s proceed with
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the main Jenkins page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on New Item.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `calculator-branches` as the item name, select Multibranch Pipeline, and
    click on OK.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Branch Sources section, click on Add source, and select Git.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter the repository address into Project Repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/612d9172-f32d-4de6-93b8-d050718945ea.png)'
  prefs: []
  type: TYPE_IMG
- en: Tick Periodically if not otherwise run and set 1 minute as Interval.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on Save.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Every minute, this configuration checks if there were any branches added (or
    removed) and creates (or deletes) the dedicated pipeline defined by Jenkinsfile.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create a new branch and see how it works. Let''s create a new branch
    called `feature` and `push` it into the repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'After a moment, you should see a new branch pipeline automatically created
    and run:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/1d029385-1907-49ca-8a47-6869c12edbfd.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, before merging the feature branch to master, we can check if it's green.
    This approach should never break the master build.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of GitHub, there is an even better approach, using the `GitHub Organization
    Folder` plugin. It automatically creates pipelines with branches and pull requests
    for all projects.
  prefs: []
  type: TYPE_NORMAL
- en: A very similar approach is to build a pipeline per pull request instead of a
    pipeline per branch, which gives the same result; the main codebase is always
    healthy.
  prefs: []
  type: TYPE_NORMAL
- en: Non-technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Last but not least, Continuous Integration is not all about the technology.
    On the contrary, technology comes second. James Shore in his article *Continuous
    Integration on a Dollar a Day* described how to set up the Continuous Integration
    process without any additional software. All he used was a rubber chicken and
    a bell. The idea is to make the team work in one room and set up a separate computer
    with an empty chair. Put the rubber chicken and the bell in front of that computer.
    Now, when you plan to check in the code, take the rubber chicken, check in the
    code, go to the empty computer, checkout the fresh code, run all tests there,
    and if everything passes, put back the rubber chicken and ring the bell so that
    everyone knows that something has been added to the repository.
  prefs: []
  type: TYPE_NORMAL
- en: '*Continuous Integration on a Dollar a Day* by *James Shore* can be found at: [http://www.jamesshore.com/Blog/Continuous-Integration-on-a-Dollar-a-Day.html](http://www.jamesshore.com/Blog/Continuous-Integration-on-a-Dollar-a-Day.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The idea is a little oversimplified, and automated tools are useful; however,
    the main message is that without each team member''s engagement, even the best
    tools won''t help. Jez Humble in his great book, *Continuous Delivery*, mentions
    the prerequisites for Continuous Integration that can be rephrased with the following
    points:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Check in regularly**: Quoting *Mike Roberts,* <q>"Continuously is more often
    than you think"</q>, the minimum is once a day.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Create comprehensive unit tests**: It''s not only about the high test coverage,
    it''s possible to have no assertions and still keep 100% coverage.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Keep the process quick**: Continuous Integration must take a short time,
    preferably under 5 minutes. 10 minutes is already a lot.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Monitor the builds**: It can be a shared responsibility or you can adapt
    the **build master** role that rotates weekly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You''ve learned a lot about how to configure the Continuous Integration process.
    Since *practice makes man perfect*, we recommend doing the following exercises:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a Python program that multiplies two numbers passed as the command-line
    parameters. Add unit tests and publish the project on GitHub:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create two files `calculator.py` and `test_calculator.py`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use the `unittest` library at [https://docs.python.org/library/unittest.html](https://docs.python.org/library/unittest.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run the program and the unit test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Build the Continuous Integration pipeline for the Python calculator project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use Jenkinsfile for specifying the pipeline
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configure the trigger so that the pipeline runs automatically in case of any
    commit to the repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The pipeline doesn't need the `Compile` step since Python is an interpretable
    language
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run the pipeline and observe the results
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Try to commit the code that breaks each stage of the pipeline and observe how
    it is visualized in Jenkins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we covered all aspects of the Continuous Integration pipeline,
    which is always the first step for Continuous Delivery. The key takeaway from
    the chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Pipeline provides a general mechanism for organizing any automation processes;
    however, the most common use cases are Continuous Integration and Continuous Delivery
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jenkins accepts different ways of defining pipelines but the recommended one
    is the declarative syntax
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Commit pipeline is the most basic Continuous Integration process and, as its
    name suggests, it should be run after every commit to the repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The pipeline definition should be stored in the repository as a Jenkinsfile
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Commit pipeline can be extended with the code quality stages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No matter the project build tool, Jenkins commands should always be consistent
    with the local development commands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jenkins offers a wide range of triggers and notifications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The development workflow should be carefully chosen inside the team or organization
    because it affects the Continuous Integration process and defines the way the
    code is developed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next chapter, we will focus on the next phase of the Continuous Delivery
    process, automated acceptance testing. It can be considered as the most important
    and, in many cases, the most difficult step to implement. We will explore the
    idea of acceptance testing and a sample implementation using Docker.
  prefs: []
  type: TYPE_NORMAL
