- en: Chapter 4. Getting Started with Boost.Asio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We already know about the Boost C++ library in general. Now it is time to find
    out more about Boost.Asio, the library that we use to develop network applications.
    Boost.Asio is a collection of libraries that are used to process data asynchronously
    because Asio itself stands for **Asynchronous I/O** (**input and output**). Asynchronous
    means that a particular task in a program will operate without blocking other
    tasks and Boost.Asio will notify the program when it has finished carrying out
    that task. In other words, the task is executed concurrently.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to discuss the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Distinguishing between concurrent and nonconcurrent programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the I/O service, the brain and the heart of Boost.Asio
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Binding a function dynamically to a function pointer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Synchronizing access to any global data or shared data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting closer to the Boost.Asio library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine we are developing an audio downloader application and we want the user
    to be able to navigate to all the menus in the application, even when the downloading
    process is in progress. If we do not use asynchronous programming, the application
    will be blocked by the downloading process and the user will have to wait until
    the downloading of the file is complete. But thanks to asynchronous programming,
    the user does not need to wait until the download process is complete to continue
    using the application.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, a synchronous process is like queuing in a theater ticketing
    line. We will be served only if we reach the ticket counter and before that, we
    have to wait for all the processes of the previous costumers who are in front
    of us in the line to be completed. In contrast, we can imagine that the asynchronous
    process is like dinning in a restaurant where the waiter does not have to wait
    for the order of a customer to be prepared by the cook. Instead of blocking the
    time and waiting for the cook, the waiter can go and take orders from other customers.
  prefs: []
  type: TYPE_NORMAL
- en: The `Boost` libraries also have the `Boost.Thread` library that is used to execute
    tasks concurrently, but the `Boost.Thread` library is used to access internal
    resources, such as the CPU core resource, while the `Boost.Asio` library is used
    to access external resources, such as network connections, because the data is
    sent and received by a network card.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s distinguish between concurrent and nonconcurrent programming. Take a
    look at the following code for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code is a nonconcurrent program. Save the code as `nonconcurrent.cpp`
    and then compile it using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'After running `nonconcurrent.cpp`, an output like this will be displayed in
    front of you:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting closer to the Boost.Asio library](img/00021.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We want to run two functions: `Print1()` and `Print2()`. In nonconcurrent programming,
    the application runs the `Print1()` function first and afterwards, completes all
    the instructions in the function. The program continues to invoke the `Print2()`
    function until the instruction is run completely.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s compare nonconcurrent programming with concurrent programming.
    For this, take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Save the preceding code as `concurrent.cpp` and compile it using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the program to get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting closer to the Boost.Asio library](img/00022.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We can see from the preceding output that the `Print1()` and `Print2()` functions
    are run concurrently. The `Print2()` function does not need to wait for the `Print1()`
    function to finish executing all the instructions that are to be invoked. This
    is why we call this concurrent programming.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Do not forget to copy the associated dynamic library file if you include a library
    in your code. For instance, if you include `boost_system-mgw49-mt-1_58` using
    the `–l` option, you have to copy the `libboost_system-mgw49-mt-1_58.dll` file
    and paste it into the same directory as the output-executable file.
  prefs: []
  type: TYPE_NORMAL
- en: Examining the I/O service in the Boost.Asio library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The core object of the `Boost::Asio` namespace is `io_service`. The **I/O service**
    is a channel that is used to access operating system resources and establish communication
    between our program and the operating system that performs I/O requests. There
    is also an **I/O object** that has the role of submitting I/O requests. For instance,
    the `tcp::socket` object will provide a socket programming request from our program
    to the operating system.
  prefs: []
  type: TYPE_NORMAL
- en: Using and blocking the run() function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the most frequently used functions in the I/O service object is the `run()`
    function. It is used to run the `io_service` object's event processing loop. It
    will block the next statement program until all the work in the `io_service` object
    is completed and there are no more handlers to be dispatched. If we stop the `io_service`
    object, it will no longer block the program.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In programming, `event` is an action or occurrence detected by a program, which
    will be handled by the program using the `event handler` object. The `io_service`
    object has one or more instances where events are handled, which is `event processing
    loop`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s take a look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We save the preceding code as `unblocked.cpp` and then run the following command
    to compile it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run the program, the following output gets displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: However, why do we still obtain the line of text in the console even though
    previously we knew that the `run()` function blocks the next function after it
    is invoked? This is because we have not given any work to the `io_service` object.
    Since there is no work for `io_service` to do, the `io_service` object should
    not block the program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s give the `io_service` object some work to do. The program for this
    will look like as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Give the preceding code the name `blocked.cpp` and then compile it by typing
    the following command in our console window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run the program by typing `blocked` in our console, we will not see the
    line of text anymore since we have added the following code line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `work` class is responsible for telling the `io_service` object when the
    work starts and when it has finished. It will make sure that the `run()` function
    in the `io_service` object will not exit during the time the work is underway.
    Also, it will make sure that the `run()` function does exit when there is no unfinished
    work remaining. In our preceding code, the `work` class informs the `io_service`
    object that it has work to do, but we do not define what the work is. Therefore,
    the program will be blocked infinitely and it will not show the output. The reason
    it has been blocked is because the `run()` function is invoked even though we
    can still terminate the program by pressing *Ctrl* + *C*.
  prefs: []
  type: TYPE_NORMAL
- en: Using the non-blocking poll() function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, we will leave the `run()` function for a while and try to use the `poll()`
    function. The `poll()` function is used to run ready handlers until there are
    no more ready handlers remaining or until the `io_service` object has been stopped.
    However, in contrast with the `run()` function, the `poll()` function will not
    block the program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s type the following code that uses the `poll()` function and save it
    as `poll.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, compile `poll.cpp` by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Because there is no work that the `io_service` object has to do, the program
    should display the five lines of text as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the non-blocking poll() function](img/00023.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'However, what if we give work to the `io_service` object when we use the `poll()`
    function? To find out the answer, let''s type the following code and save it as
    `pollwork.cpp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'To compile `pollwork.cpp`, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The difference between the `poll.cpp` file and the `pollwork.cpp` file is only
    the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: However, if we run `pollwork.exe`, we will obtain the same output as that of
    `poll.exe`. This is because, as we know from before, the `poll()` function will
    not block the program while there is more work to do. It will execute the current
    work and then return the value.
  prefs: []
  type: TYPE_NORMAL
- en: Removing the work object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can also unblock the program by removing the `work` object from the `io_service`
    object, but we have to use a pointer to the `work` object in order to remove the
    `work` object itself. We are going to use the `shared_ptr` pointer, a smart pointer
    provided by the `Boost` libraries.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use the modified code of `blocked.cpp`. The code for this will be as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Save the preceding code as `removework.cpp` and compile it using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run `removework.cpp`, compared to `blocked.cpp`, which will block the
    program infinitely, the following line of text will be displayed to us:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Removing the work object](img/00024.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now, let's dissect the code. As we can see in the preceding code, we used the
    `shared_ptr` pointer to instantiate the `work` object. With this smart pointer
    provided by Boost, we no longer need to manually delete memory allocation in order
    to store the pointer since it guarantees that the object pointed to will be deleted
    when the last pointer is destroyed or reset. Do not forget to include `shared_ptr.hpp`
    inside the `boost` directory as the `shared_ptr` pointer is defined in the header
    file.
  prefs: []
  type: TYPE_NORMAL
- en: We also add the `reset()` function to reset the `io_service` object when it
    prepares for a subsequent `run()` function invocation. The `reset()` function
    has to be invoked before any invocation of the `run()` or `poll()` functions.
    It will also tell the `shared_ptr` pointer to automatically destroy the pointer
    we created. More information about the `share_ptr` pointer can be found at [www.boost.org/doc/libs/1_58_0/libs/smart_ptr/shared_ptr.htm](http://www.boost.org/doc/libs/1_58_0/libs/smart_ptr/shared_ptr.htm).
  prefs: []
  type: TYPE_NORMAL
- en: The preceding program explains that we have successfully removed the `work`
    object from the `io_service` object. We can use this functionality if we intend
    to finish all the pending work even though it hasn't actually been finished yet.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with many threads
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have only dealt with one thread for one `io_service` object so far. If we
    want to deal with more threads in a single `io_service` object, the following
    code will explain how to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Give the preceding code the name `mutithreads.cpp` and then compile it using
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We include the `thread.hpp` header file so that we can use the `thread` object
    defined inside the header file. The thread itself is a piece sequence of instructions
    that can be run independently, so we can run multiple threads at once.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, run `mutithreads.exe` in our console. I obtained the following output
    by running it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Dealing with many threads](img/00025.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'You might obtain a different output because all the threads that are set up
    as a pool of threads are equivalent to each other. The `io_service` object may
    choose any one of them randomly and invoke its handler, so we cannot guarantee
    whether or not the `io_service` object will choose a thread sequentially:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the preceding code snippet, we can create five threads to display lines
    of text as you can see in the previous screenshot. The five lines of text will
    be enough for this example to view the order of nonconcurrent flow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In every thread that is created, the program will invoke the `run()` function
    to run the work of the `io_service` object. Calling the `run()` function once
    is insufficient because all nonworkers will be invoked after the `run()` object
    finishes all its work.
  prefs: []
  type: TYPE_NORMAL
- en: 'After creating five threads, the program runs the work of the `io_service`
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'After all the work is run, the program waits for you to press the *Enter* key
    from the keyboard using the preceding code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'So after we press the *Enter* key, the program will finish its remaining code
    and we will obtain the rest of the output as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Dealing with many threads](img/00026.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Understanding the Boost.Bind library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have been able to use the `io_service` object and initialize the `work` object.
    What we should know after this is how to give some work to the `io_service` object.
    But before we progress to giving work to the `io_service` service, we need to
    understand the `boost::bind` library.
  prefs: []
  type: TYPE_NORMAL
- en: The `Boost.Bind` library is used to ease the invocation of a function pointer.
    It converts the syntax from something that is abstruse and confusing to something
    that is easy to understand.
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping a function invocation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s look at the following code in order to understand how to wrap a function
    invocation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Save the preceding code as `uncalledbind.cpp` and then compile it using the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We will not get any line of text as output since we just created a function
    invocation but haven''t actually called it. We have to add it to the `()` operator
    to call the function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Name the preceding code `calledbind.cpp` and run the following command to compile
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will get the line of text as the output if we run the program, and
    of course, we will see the `bind()` function as an output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following command to compile the preceding `argumentbind.cpp` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We successfully call the function with the argument using `boost::bind` because
    of which we obtain the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'You need to remember that if the function has more than one argument, we have
    to match the function signature exactly. The following code will explain this
    in more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile the `signaturebind.cpp` code by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The signature of an identity function are `std::string`, `int`, and `float`.
    So, we have to fill the `bind` parameter with `std::string`, `int`, and `float`,
    respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because we have matched the function signature exactly, we will obtain an output
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Wrapping a function invocation](img/00027.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We have already been able to call the `global()` function in `boost::bind`.
    Now, let''s continue to call the function inside a class in `boost::bind`. The
    code for this looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile the preceding `classbind.cpp` code by using following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The output for this will be exactly the same as the `signaturebind.cpp` code
    since the content of the function is exactly the same as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Working with the Boost.Bind library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we have been able to use `boost::bind` for the global and class functions.
    However, when we use the `io_service` object with `boost::bind`, we will get a
    **non-copyable** error because the `io_service` object cannot be copied.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s take a look at `multithreads.cpp` again. We will modify the code
    to explain the use of `boost::bind` for the `io_service` object and we will still
    need the help of the `shared_ptr` pointer. Let''s take a look at the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'We name the preceding code `ioservicebind.cpp` and compile it using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run `ioservicebind.exe`, we obtain the same output as `multithreads.exe`,
    but of course, the program will randomize the order of all threads:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'We instantiate the `io_service` object in the `shared_ptr` pointer to make
    it **copyable** so that we can bind it to the worker `thread()` function that
    we use as a thread handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: If we look at the `create_thread()` function, we see the different arguments
    that it gets in the `ioservicebind.cpp` and `multithreads.cpp` files. We can pass
    a pointer to the `void()` function that takes no arguments as the argument to
    the `create_thread()` function, as we can see in the `multithreads.cpp` file.
    We can also pass a binding function as an argument to the `create_thread()` function,
    as we can see in the `ioservicebind.cpp` file.
  prefs: []
  type: TYPE_NORMAL
- en: Synchronizing data access with the Boost.Mutex library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Have you ever got the following output when you ran the `multithreads.exe` or
    `ioservicebind.exe` executable files?
  prefs: []
  type: TYPE_NORMAL
- en: '![Synchronizing data access with the Boost.Mutex library](img/00028.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can see in the preceding screenshot that there is a formatting issue here.
    Because the `std::cout` object is a global object, writing to it from different
    threads at once can cause output formatting issues. To solve this issue, we can
    use a `mutex` object that can be found in the `boost::mutex` object provided by
    the `thread` library. Mutex is used to synchronize access to any global data or
    shared data. To understand more about Mutex, take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Save the preceding code as `mutexbind.cpp` and then compile it using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, run the `mutexbind.cpp` file and we will not face the formatting issue
    anymore:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: We instantiate the new `mutex` object, `global_stream_lock`. With this object,
    we can call the `lock()` and `unlock()` functions. The `lock()` function will
    block other threads that access the same function to wait for the current thread
    to be finished. The other threads can access the same function if only the current
    thread has called the `unlock()` function. One thing to remember is that we should
    not call the `lock()` function recursively because if the `lock()` function is
    not unlocked by the `unlock()` function, then thread deadlock will occur and it
    will freeze the application. So, we have to be careful when using the `lock()`
    and `unlock()` functions.
  prefs: []
  type: TYPE_NORMAL
- en: Giving some work to the I/O service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, it is time for us to give some work to the `io_service` object. Knowing
    more about `boost::bind` and `boost::mutex` will help us to give the `io_service`
    object work to do. There are two member functions in the `io_service` object:
    the `post()` and `dispatch()` functions, which we will frequently use to do this.
    The `post()` function is used to request the `io_service` object to run the `io_service`
    object''s work after we queue up all the work, so it does not allow us to run
    the work immediately. While the `dispatch()` function is also used to make a request
    to the `io_service` object to run the `io_service` object''s work, but it will
    execute the work right away without queuing it up.'
  prefs: []
  type: TYPE_NORMAL
- en: Using the post() function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s examine the `post()` function by creating the following code. We will
    use the `mutexbind.cpp` file as our base code, since we will just modify the source
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Name the preceding code as `post.cpp` and compile it using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we run the program, let''s examine the code to understand its behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'We add the `fac()` function to calculate the *n* factorial recursively. There
    is a time delay to slow down the process in order to see the work of our worker
    threads:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: In the `main` block, we post three function objects on the `io_service` object,
    using the `post()` function. We do this just after we initialize the five worker
    threads. However, because we call the `run()` function of the `io_service` object
    inside each thread, the work of the `io_service` object will run. This means that
    the `post()` function will do its job.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s run `post.cpp` and take a look at what has happened here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the post() function](img/00029.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As we can see in the output of the preceding screenshot, the program runs the
    thread from the pool of threads, and after it finishes one thread, it calls the
    `post()` function from the `io_service` object until all three `post()` functions
    and all five threads have been called. Then, it calculates the factorial for each
    three *n* number. After it gets the `worker.reset()` function, it is notified
    that the work has been finished, and then it joins all the threads via the `threads.join_all()`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: Using the dispatch() function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let''s examine the `dispatch()` function to give the `io_service` function
    some work. We will still use the `mutexbind.cpp` file as our base code and we
    will modify it a little so that it becomes like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Give the preceding code the name `dispatch.cpp` and compile it using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s run the program to get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the dispatch() function](img/00030.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Different than the `post.cpp` file, in the `dispatch.cpp` file, we just create
    one worker thread. Also, we add two functions, `dispatch(),` and `post()` to understand
    the difference between both functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two functions that we can use to get the `io_service` object working
    for us: the `run()` and `poll()` member functions. The `run()` function blocks
    the program because it has to wait for the work that we assign to it, while the
    `poll()` function does not block the program. When we need to give some work to
    the `io_service` object, we simply use the `poll()` or `run()` functions, depending
    on what we need, and then we call the `post()`or `dispatch()` functions as needed.
    The `post()` function is used to command the `io_service` object in order to run
    the given handler, but without permitting the handler is called by the `io_service`
    object from inside this function. While the `dispatch()` function is used to call
    the handler in the thread in which the `run()`or `poll()` functions are currently
    being invoked. The fundamental difference between the `dispatch()` and the `post()`
    functions is that the `dispatch()` function completes the work right away whenever
    it can, while the `post()` function always queues the work.'
  prefs: []
  type: TYPE_NORMAL
- en: We found out about the `io_service` object, how to run it, and how to give it
    some work. Now, let's move to the next chapter to find out more about the `Boost.Asio`
    library, and we will be one step closer to creating our network programming.
  prefs: []
  type: TYPE_NORMAL
