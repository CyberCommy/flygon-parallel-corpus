- en: Chapter 4. Getting Started with Boost.Asio
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We already know about the Boost C++ library in general. Now it is time to find
    out more about Boost.Asio, the library that we use to develop network applications.
    Boost.Asio is a collection of libraries that are used to process data asynchronously
    because Asio itself stands for **Asynchronous I/O** (**input and output**). Asynchronous
    means that a particular task in a program will operate without blocking other
    tasks and Boost.Asio will notify the program when it has finished carrying out
    that task. In other words, the task is executed concurrently.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to discuss the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Distinguishing between concurrent and nonconcurrent programming
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the I/O service, the brain and the heart of Boost.Asio
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Binding a function dynamically to a function pointer
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Synchronizing access to any global data or shared data
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting closer to the Boost.Asio library
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine we are developing an audio downloader application and we want the user
    to be able to navigate to all the menus in the application, even when the downloading
    process is in progress. If we do not use asynchronous programming, the application
    will be blocked by the downloading process and the user will have to wait until
    the downloading of the file is complete. But thanks to asynchronous programming,
    the user does not need to wait until the download process is complete to continue
    using the application.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: In other words, a synchronous process is like queuing in a theater ticketing
    line. We will be served only if we reach the ticket counter and before that, we
    have to wait for all the processes of the previous costumers who are in front
    of us in the line to be completed. In contrast, we can imagine that the asynchronous
    process is like dinning in a restaurant where the waiter does not have to wait
    for the order of a customer to be prepared by the cook. Instead of blocking the
    time and waiting for the cook, the waiter can go and take orders from other customers.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: The `Boost` libraries also have the `Boost.Thread` library that is used to execute
    tasks concurrently, but the `Boost.Thread` library is used to access internal
    resources, such as the CPU core resource, while the `Boost.Asio` library is used
    to access external resources, such as network connections, because the data is
    sent and received by a network card.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s distinguish between concurrent and nonconcurrent programming. Take a
    look at the following code for this:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The preceding code is a nonconcurrent program. Save the code as `nonconcurrent.cpp`
    and then compile it using the following command:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'After running `nonconcurrent.cpp`, an output like this will be displayed in
    front of you:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting closer to the Boost.Asio library](img/00021.jpeg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
- en: 'We want to run two functions: `Print1()` and `Print2()`. In nonconcurrent programming,
    the application runs the `Print1()` function first and afterwards, completes all
    the instructions in the function. The program continues to invoke the `Print2()`
    function until the instruction is run completely.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s compare nonconcurrent programming with concurrent programming.
    For this, take a look at the following code:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Save the preceding code as `concurrent.cpp` and compile it using the following
    command:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Run the program to get the following output:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting closer to the Boost.Asio library](img/00022.jpeg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
- en: We can see from the preceding output that the `Print1()` and `Print2()` functions
    are run concurrently. The `Print2()` function does not need to wait for the `Print1()`
    function to finish executing all the instructions that are to be invoked. This
    is why we call this concurrent programming.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Do not forget to copy the associated dynamic library file if you include a library
    in your code. For instance, if you include `boost_system-mgw49-mt-1_58` using
    the `–l` option, you have to copy the `libboost_system-mgw49-mt-1_58.dll` file
    and paste it into the same directory as the output-executable file.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: Examining the I/O service in the Boost.Asio library
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The core object of the `Boost::Asio` namespace is `io_service`. The **I/O service**
    is a channel that is used to access operating system resources and establish communication
    between our program and the operating system that performs I/O requests. There
    is also an **I/O object** that has the role of submitting I/O requests. For instance,
    the `tcp::socket` object will provide a socket programming request from our program
    to the operating system.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: Using and blocking the run() function
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the most frequently used functions in the I/O service object is the `run()`
    function. It is used to run the `io_service` object's event processing loop. It
    will block the next statement program until all the work in the `io_service` object
    is completed and there are no more handlers to be dispatched. If we stop the `io_service`
    object, it will no longer block the program.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In programming, `event` is an action or occurrence detected by a program, which
    will be handled by the program using the `event handler` object. The `io_service`
    object has one or more instances where events are handled, which is `event processing
    loop`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s take a look at the following code snippet:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We save the preceding code as `unblocked.cpp` and then run the following command
    to compile it:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'When we run the program, the following output gets displayed:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: However, why do we still obtain the line of text in the console even though
    previously we knew that the `run()` function blocks the next function after it
    is invoked? This is because we have not given any work to the `io_service` object.
    Since there is no work for `io_service` to do, the `io_service` object should
    not block the program.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s give the `io_service` object some work to do. The program for this
    will look like as shown in the following code:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Give the preceding code the name `blocked.cpp` and then compile it by typing
    the following command in our console window:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If we run the program by typing `blocked` in our console, we will not see the
    line of text anymore since we have added the following code line:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `work` class is responsible for telling the `io_service` object when the
    work starts and when it has finished. It will make sure that the `run()` function
    in the `io_service` object will not exit during the time the work is underway.
    Also, it will make sure that the `run()` function does exit when there is no unfinished
    work remaining. In our preceding code, the `work` class informs the `io_service`
    object that it has work to do, but we do not define what the work is. Therefore,
    the program will be blocked infinitely and it will not show the output. The reason
    it has been blocked is because the `run()` function is invoked even though we
    can still terminate the program by pressing *Ctrl* + *C*.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Using the non-blocking poll() function
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, we will leave the `run()` function for a while and try to use the `poll()`
    function. The `poll()` function is used to run ready handlers until there are
    no more ready handlers remaining or until the `io_service` object has been stopped.
    However, in contrast with the `run()` function, the `poll()` function will not
    block the program.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s type the following code that uses the `poll()` function and save it
    as `poll.cpp`:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then, compile `poll.cpp` by using the following command:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Because there is no work that the `io_service` object has to do, the program
    should display the five lines of text as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the non-blocking poll() function](img/00023.jpeg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
- en: 'However, what if we give work to the `io_service` object when we use the `poll()`
    function? To find out the answer, let''s type the following code and save it as
    `pollwork.cpp`:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To compile `pollwork.cpp`, use the following command:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The difference between the `poll.cpp` file and the `pollwork.cpp` file is only
    the following line:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: However, if we run `pollwork.exe`, we will obtain the same output as that of
    `poll.exe`. This is because, as we know from before, the `poll()` function will
    not block the program while there is more work to do. It will execute the current
    work and then return the value.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: Removing the work object
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can also unblock the program by removing the `work` object from the `io_service`
    object, but we have to use a pointer to the `work` object in order to remove the
    `work` object itself. We are going to use the `shared_ptr` pointer, a smart pointer
    provided by the `Boost` libraries.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use the modified code of `blocked.cpp`. The code for this will be as
    follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Save the preceding code as `removework.cpp` and compile it using the following
    command:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'When we run `removework.cpp`, compared to `blocked.cpp`, which will block the
    program infinitely, the following line of text will be displayed to us:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '![Removing the work object](img/00024.jpeg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
- en: Now, let's dissect the code. As we can see in the preceding code, we used the
    `shared_ptr` pointer to instantiate the `work` object. With this smart pointer
    provided by Boost, we no longer need to manually delete memory allocation in order
    to store the pointer since it guarantees that the object pointed to will be deleted
    when the last pointer is destroyed or reset. Do not forget to include `shared_ptr.hpp`
    inside the `boost` directory as the `shared_ptr` pointer is defined in the header
    file.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: We also add the `reset()` function to reset the `io_service` object when it
    prepares for a subsequent `run()` function invocation. The `reset()` function
    has to be invoked before any invocation of the `run()` or `poll()` functions.
    It will also tell the `shared_ptr` pointer to automatically destroy the pointer
    we created. More information about the `share_ptr` pointer can be found at [www.boost.org/doc/libs/1_58_0/libs/smart_ptr/shared_ptr.htm](http://www.boost.org/doc/libs/1_58_0/libs/smart_ptr/shared_ptr.htm).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: The preceding program explains that we have successfully removed the `work`
    object from the `io_service` object. We can use this functionality if we intend
    to finish all the pending work even though it hasn't actually been finished yet.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with many threads
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have only dealt with one thread for one `io_service` object so far. If we
    want to deal with more threads in a single `io_service` object, the following
    code will explain how to do this:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Give the preceding code the name `mutithreads.cpp` and then compile it using
    the following command:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We include the `thread.hpp` header file so that we can use the `thread` object
    defined inside the header file. The thread itself is a piece sequence of instructions
    that can be run independently, so we can run multiple threads at once.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, run `mutithreads.exe` in our console. I obtained the following output
    by running it:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '![Dealing with many threads](img/00025.jpeg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
- en: 'You might obtain a different output because all the threads that are set up
    as a pool of threads are equivalent to each other. The `io_service` object may
    choose any one of them randomly and invoke its handler, so we cannot guarantee
    whether or not the `io_service` object will choose a thread sequentially:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Using the preceding code snippet, we can create five threads to display lines
    of text as you can see in the previous screenshot. The five lines of text will
    be enough for this example to view the order of nonconcurrent flow:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In every thread that is created, the program will invoke the `run()` function
    to run the work of the `io_service` object. Calling the `run()` function once
    is insufficient because all nonworkers will be invoked after the `run()` object
    finishes all its work.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: 'After creating five threads, the program runs the work of the `io_service`
    object:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'After all the work is run, the program waits for you to press the *Enter* key
    from the keyboard using the preceding code snippet:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'So after we press the *Enter* key, the program will finish its remaining code
    and we will obtain the rest of the output as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '![Dealing with many threads](img/00026.jpeg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
- en: Understanding the Boost.Bind library
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have been able to use the `io_service` object and initialize the `work` object.
    What we should know after this is how to give some work to the `io_service` object.
    But before we progress to giving work to the `io_service` service, we need to
    understand the `boost::bind` library.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: The `Boost.Bind` library is used to ease the invocation of a function pointer.
    It converts the syntax from something that is abstruse and confusing to something
    that is easy to understand.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping a function invocation
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s look at the following code in order to understand how to wrap a function
    invocation:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Save the preceding code as `uncalledbind.cpp` and then compile it using the
    following command:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We will not get any line of text as output since we just created a function
    invocation but haven''t actually called it. We have to add it to the `()` operator
    to call the function as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Name the preceding code `calledbind.cpp` and run the following command to compile
    it:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, we will get the line of text as the output if we run the program, and
    of course, we will see the `bind()` function as an output:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Run the following command to compile the preceding `argumentbind.cpp` file:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We successfully call the function with the argument using `boost::bind` because
    of which we obtain the following output:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'You need to remember that if the function has more than one argument, we have
    to match the function signature exactly. The following code will explain this
    in more detail:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Compile the `signaturebind.cpp` code by using the following command:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The signature of an identity function are `std::string`, `int`, and `float`.
    So, we have to fill the `bind` parameter with `std::string`, `int`, and `float`,
    respectively.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: 'Because we have matched the function signature exactly, we will obtain an output
    as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '![Wrapping a function invocation](img/00027.jpeg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
- en: 'We have already been able to call the `global()` function in `boost::bind`.
    Now, let''s continue to call the function inside a class in `boost::bind`. The
    code for this looks as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Compile the preceding `classbind.cpp` code by using following command:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The output for this will be exactly the same as the `signaturebind.cpp` code
    since the content of the function is exactly the same as well:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Working with the Boost.Bind library
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we have been able to use `boost::bind` for the global and class functions.
    However, when we use the `io_service` object with `boost::bind`, we will get a
    **non-copyable** error because the `io_service` object cannot be copied.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s take a look at `multithreads.cpp` again. We will modify the code
    to explain the use of `boost::bind` for the `io_service` object and we will still
    need the help of the `shared_ptr` pointer. Let''s take a look at the following
    code snippet:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We name the preceding code `ioservicebind.cpp` and compile it using the following
    command:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'When we run `ioservicebind.exe`, we obtain the same output as `multithreads.exe`,
    but of course, the program will randomize the order of all threads:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We instantiate the `io_service` object in the `shared_ptr` pointer to make
    it **copyable** so that we can bind it to the worker `thread()` function that
    we use as a thread handler:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: If we look at the `create_thread()` function, we see the different arguments
    that it gets in the `ioservicebind.cpp` and `multithreads.cpp` files. We can pass
    a pointer to the `void()` function that takes no arguments as the argument to
    the `create_thread()` function, as we can see in the `multithreads.cpp` file.
    We can also pass a binding function as an argument to the `create_thread()` function,
    as we can see in the `ioservicebind.cpp` file.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: Synchronizing data access with the Boost.Mutex library
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Have you ever got the following output when you ran the `multithreads.exe` or
    `ioservicebind.exe` executable files?
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '![Synchronizing data access with the Boost.Mutex library](img/00028.jpeg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
- en: 'We can see in the preceding screenshot that there is a formatting issue here.
    Because the `std::cout` object is a global object, writing to it from different
    threads at once can cause output formatting issues. To solve this issue, we can
    use a `mutex` object that can be found in the `boost::mutex` object provided by
    the `thread` library. Mutex is used to synchronize access to any global data or
    shared data. To understand more about Mutex, take a look at the following code:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Save the preceding code as `mutexbind.cpp` and then compile it using the following
    command:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now, run the `mutexbind.cpp` file and we will not face the formatting issue
    anymore:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: We instantiate the new `mutex` object, `global_stream_lock`. With this object,
    we can call the `lock()` and `unlock()` functions. The `lock()` function will
    block other threads that access the same function to wait for the current thread
    to be finished. The other threads can access the same function if only the current
    thread has called the `unlock()` function. One thing to remember is that we should
    not call the `lock()` function recursively because if the `lock()` function is
    not unlocked by the `unlock()` function, then thread deadlock will occur and it
    will freeze the application. So, we have to be careful when using the `lock()`
    and `unlock()` functions.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: Giving some work to the I/O service
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, it is time for us to give some work to the `io_service` object. Knowing
    more about `boost::bind` and `boost::mutex` will help us to give the `io_service`
    object work to do. There are two member functions in the `io_service` object:
    the `post()` and `dispatch()` functions, which we will frequently use to do this.
    The `post()` function is used to request the `io_service` object to run the `io_service`
    object''s work after we queue up all the work, so it does not allow us to run
    the work immediately. While the `dispatch()` function is also used to make a request
    to the `io_service` object to run the `io_service` object''s work, but it will
    execute the work right away without queuing it up.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: Using the post() function
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s examine the `post()` function by creating the following code. We will
    use the `mutexbind.cpp` file as our base code, since we will just modify the source
    code:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Name the preceding code as `post.cpp` and compile it using the following command:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Before we run the program, let''s examine the code to understand its behavior:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We add the `fac()` function to calculate the *n* factorial recursively. There
    is a time delay to slow down the process in order to see the work of our worker
    threads:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: In the `main` block, we post three function objects on the `io_service` object,
    using the `post()` function. We do this just after we initialize the five worker
    threads. However, because we call the `run()` function of the `io_service` object
    inside each thread, the work of the `io_service` object will run. This means that
    the `post()` function will do its job.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s run `post.cpp` and take a look at what has happened here:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the post() function](img/00029.jpeg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
- en: As we can see in the output of the preceding screenshot, the program runs the
    thread from the pool of threads, and after it finishes one thread, it calls the
    `post()` function from the `io_service` object until all three `post()` functions
    and all five threads have been called. Then, it calculates the factorial for each
    three *n* number. After it gets the `worker.reset()` function, it is notified
    that the work has been finished, and then it joins all the threads via the `threads.join_all()`
    function.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: Using the dispatch() function
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let''s examine the `dispatch()` function to give the `io_service` function
    some work. We will still use the `mutexbind.cpp` file as our base code and we
    will modify it a little so that it becomes like this:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Give the preceding code the name `dispatch.cpp` and compile it using the following
    command:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 给上述代码命名为`dispatch.cpp`，并使用以下命令进行编译：
- en: '[PRE57]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Now, let''s run the program to get the following output:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们运行程序以获得以下输出：
- en: '![Using the dispatch() function](img/00030.jpeg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![使用dispatch()函数](img/00030.jpeg)'
- en: 'Different than the `post.cpp` file, in the `dispatch.cpp` file, we just create
    one worker thread. Also, we add two functions, `dispatch(),` and `post()` to understand
    the difference between both functions:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 与`post.cpp`文件不同，在`dispatch.cpp`文件中，我们只创建一个工作线程。此外，我们添加了两个函数`dispatch()`和`post()`来理解两个函数之间的区别：
- en: '[PRE58]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Summary
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'There are two functions that we can use to get the `io_service` object working
    for us: the `run()` and `poll()` member functions. The `run()` function blocks
    the program because it has to wait for the work that we assign to it, while the
    `poll()` function does not block the program. When we need to give some work to
    the `io_service` object, we simply use the `poll()` or `run()` functions, depending
    on what we need, and then we call the `post()`or `dispatch()` functions as needed.
    The `post()` function is used to command the `io_service` object in order to run
    the given handler, but without permitting the handler is called by the `io_service`
    object from inside this function. While the `dispatch()` function is used to call
    the handler in the thread in which the `run()`or `poll()` functions are currently
    being invoked. The fundamental difference between the `dispatch()` and the `post()`
    functions is that the `dispatch()` function completes the work right away whenever
    it can, while the `post()` function always queues the work.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个函数可以让我们使用`io_service`对象工作：`run()`和`poll()`成员函数。`run()`函数会阻塞程序，因为它必须等待我们分配给它的工作，而`poll()`函数不会阻塞程序。当我们需要给`io_service`对象一些工作时，我们只需使用`poll()`或`run()`函数，取决于我们的需求，然后根据需要调用`post()`或`dispatch()`函数。`post()`函数用于命令`io_service`对象运行给定的处理程序，但不允许处理程序在此函数内部被`io_service`对象调用。而`dispatch()`函数用于在调用`run()`或`poll()`函数的线程中调用处理程序。`dispatch()`和`post()`函数之间的根本区别在于，`dispatch()`函数会立即完成工作，而`post()`函数总是将工作排队。
- en: We found out about the `io_service` object, how to run it, and how to give it
    some work. Now, let's move to the next chapter to find out more about the `Boost.Asio`
    library, and we will be one step closer to creating our network programming.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们了解了`io_service`对象，如何运行它，以及如何给它一些工作。现在，让我们转到下一章，了解更多关于`Boost.Asio`库的内容，我们将离创建网络编程更近一步。
