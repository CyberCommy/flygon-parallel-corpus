- en: Monitoring a Surfing Competition with Cloud-Based Real-Time MQTT Providers and
    Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will write Python code to use the PubNub cloud-based real-time
    MQTT provider in combination with a Mosquitto MQTT server to monitor a surfing
    competition. We will build a solution from scratch by analyzing the requirements,
    and we will write Python code that will run on waterproof IoT boards connected
    to multiple sensors in surfboards. We will define the topics and commands, and
    we will work with a cloud-based MQTT server in combination with the Mosquitto
    MQTT server used in the previous chapters. We will cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the requirements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining the topics and payloads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coding a surfboard sensor emulator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring PubNub MQTT interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Publishing data retrieved from sensors to the cloud-based MQTT server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with multiple MQTT servers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a web-based dashboard with freeboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Many surfers that are training for surfing competitions want us to build a
    real-time web-based dashboard with the data provided by an IoT board connected
    to multiple sensors in the surfboards. Each IoT board will provide the following
    data:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Status**: Many wearable wireless sensors embedded in each surfer''s wetsuit
    and other sensors included in the surfboard will provide data and the IoT board
    will perform a real-time analysis to indicate the status of the surfer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Speed**: A sensor will measure the surfboard''s speed in **miles per hour**
    (**mph**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Altitude**: A sensor will measure the surfboard''s altitude in feet'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Water temperature**: A sensor located in one of the surfboard''s fins will
    measure the water temperature in degrees Fahrenheit'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Third-party software is running on the IoT board and we cannot make changes
    to the code that publishes the data on different topics. We can provide the necessary
    certificates to configure the secured connection with our Mosquitto MQTT server
    and specify its host name and protocol. In addition, we can configure a name that
    identifies the surfboard and determines the topics in which the data will be published.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the topics and payloads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The IoT board uses the following topic names to publish data about a specific
    surfboard, where `surfboardname` must be replaced with a unique name assigned
    to a surfboard:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Variable** | **Topic name** |'
  prefs: []
  type: TYPE_TB
- en: '| Status | `surfboards/surfboardname/status` |'
  prefs: []
  type: TYPE_TB
- en: '| Speed (mph) | `surfboards/surfboardname/speedmph` |'
  prefs: []
  type: TYPE_TB
- en: '| Altitude (feet) | `surfboards/surfboardname/altitudefeet` |'
  prefs: []
  type: TYPE_TB
- en: '| Water temperature (degrees Fahrenheit) | `surfboards/surfboardname/temperaturef`
    |'
  prefs: []
  type: TYPE_TB
- en: For example, if we assign `surfboard01` as the name for the surfboard, the client
    that wants to receive the actual speed for the surfboard has to subscribe to the
    `surfboards/surfboard01/speedmph` topic.
  prefs: []
  type: TYPE_NORMAL
- en: 'The IoT board and its connected sensors are capable of distinguishing between
    the following five possible statuses of a surfer and their surfboard:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Status key** | **Meaning** |'
  prefs: []
  type: TYPE_TB
- en: '| `0` | Idle |'
  prefs: []
  type: TYPE_TB
- en: '| `1` | Paddling |'
  prefs: []
  type: TYPE_TB
- en: '| `2` | Riding |'
  prefs: []
  type: TYPE_TB
- en: '| `3` | Ride finished |'
  prefs: []
  type: TYPE_TB
- en: '| `4` | Wiped out |'
  prefs: []
  type: TYPE_TB
- en: The IoT board publishes the integer value specified in the status key column
    that indicates the current status of a surfer and their surfboard. For example,
    when a surfer is riding a wave, the board will publish `2` to the `surfboards/surfboard01/status`
    topic.
  prefs: []
  type: TYPE_NORMAL
- en: The board will publish floating-point values in the previously explained topics
    for speed, altitude, and water temperature. In this case, the IoT board will just
    publish either the integer or floating-point values as the payloads for the MQTT
    messages. The payload won't be JSON, as in our previous examples. The payload
    won't include any additional information about the unit of measurement. This information
    is included in the topic name.
  prefs: []
  type: TYPE_NORMAL
- en: The IoT board will publish the data in the previously explained topics every
    second.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous examples, we designed our solution from scratch. In this case,
    we have to interact with an IoT board that is already running code that we cannot
    change. Imagine that we have to start working on the solution without the IoT
    board; therefore, we will develop a surfboard sensor emulator in Python that will
    provide us with data so that we can receive the published data and develop the
    desired dashboard. In real-life projects, this is a very common scenario.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we learned in the previous chapters, MQTT has become an extremely popular
    protocol for IoT projects in which many sensors have to publish data. Due to this
    increasing popularity, many cloud-based messaging infrastructures have included
    MQTT interfaces or bridges. For example, the PubNub data stream network provides
    a scalable MQTT interface. We can take advantage of everything we learned so far
    about MQTT to work with this cloud-based data stream network. You can read more
    about PubNub on its web page: [http://www.pubnub.com](http://www.pubnub.com).'
  prefs: []
  type: TYPE_NORMAL
- en: A Python program will collect the data published by the IoT board by subscribing
    to the four topics and the code will build a complete status for the surfer and
    their surfboard every second. Then, the code will build a JSON message with the
    status, speed, altitude, and water temperature and it will publish it to a topic
    of the MQTT PubNub interface.
  prefs: []
  type: TYPE_NORMAL
- en: In our example, we will take advantage of the free services offered by PubNub
    and its MQTT interface. We won't use some advanced features and additional services
    that might empower our IoT project connectivity requirements, but also require
    a paid subscription.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will take advantage of freeboard.io to visualize the data collected from
    the sensors and published to the PubNub MQTT interface in many gauges and make
    the dashboard available to different computers and devices all over the world.
    freeboard.io allows us to build a dashboard by selecting data sources and dragging
    and dropping customizable widgets. freeboard.io defines itself as a cloud-based
    service that allows us to visualize the Internet of Things. You can read more
    about freeboard.io in its web page: [http://freeboard.io](http://freeboard.io).'
  prefs: []
  type: TYPE_NORMAL
- en: In our example, we will take advantage of the free services offered by freeboard.io
    and we won't use some advanced features that provide privacy for our dashboards,
    but also require a paid subscription. Our dashboard will be available to anyone
    that has the unique URL for it because we are not working with private dashboards.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following lines show an example of the payload for the message that provides
    the status of the surfer and their surfboard:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Freeboard.io allows us to easily select each key of the JSON message received
    in the PubNub MQTT interface as a data source for the dashboard. This way, we
    will easily build a web-based dashboard to provide us with the status, speed,
    altitude, and water temperature values in gauges.
  prefs: []
  type: TYPE_NORMAL
- en: 'To summarize, our solution will be composed of the following two Python programs:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Surfboard sensor emulator**: This program will establish a secured connection
    to our Mosquitto MQTT server and it will publish status, speed, altitude, and
    water temperature values read from a **CSV** (short for **Comma Separated Values**)
    file to the appropriate topics every second. The program will work as if we had
    a real-life surfer with his wetsuit and surfboard sensors riding waves and publishing
    data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Surfboard monitor**: This program will establish a secured connection to
    our Mosquitto MQTT server and it will subscribe to the topics in which the surfboard
    sensor emulator publishes status, speed, altitude, and water temperature values.
    The surfboard monitor program will also establish a connection with the PubNub
    MQTT interface. The program will publish a single message with the key-value pairs
    that determine the status of a surfer and their surfboard to the PubNub MQTT interface
    every second.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coding a surfboard sensor emulator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, we will create a CSV file with many status, speed in mph, altitude in
    feet, and temperature in degrees Fahrenheit values separated by commas. Each line
    in the file will represent a set of values that the surfboard sensor emulator
    will publish to the appropriate topics. In this case, it is not convenient to
    work with random values because we want to emulate real-life scenarios for a surfer
    and his surfboard.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will create a new file named `surfboard_sensors_data.csv` in the main
    virtual environment folder. The following lines show the code that defines the
    data retrieved from a short surfing session for the surfer and their surfboard.
  prefs: []
  type: TYPE_NORMAL
- en: 'The values separated with commas from left to right are the following: speed
    in mph, altitude in feet, and temperature in degrees Fahrenheit. First, the surfer
    is idle, he increases the speed when paddling, he reaches the speed maximum value
    when riding the wave, and finally reduces speed when his status is set to ride
    finished. The code file for the sample is included in the `mqtt_python_gaston_hillar_06_01`
    folder, in the `surfboard_sensors_data.csv` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will create a new Python file named `surfboard_config.py` in the main
    virtual environment folder. The following lines show the code for this file, which
    defines many configuration values that will be used to configure the topics to
    which the surfboard sensor emulator will publish the values retrieved from the
    sensors. The surfboard monitor will also need these topics to subscribe to them,
    and therefore it is convenient to include all the configuration values in a specific
    Python script. The code file for the sample is included in the `mqtt_python_gaston_hillar_06_01`
    folder, in the `surfboard_config.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The code defines the surfboard name and stores it in the `surfboard_name` variable.
    The `topic_format` variable holds a string that makes it easy to build different
    topics that have a common prefix. The following table summarizes the string values
    for the four variables that define the topic names for each sensor, based on a
    defined surfboard named `surfboard01`:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Variable** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| `status_topic` | `surfboards/surfboard01/status` |'
  prefs: []
  type: TYPE_TB
- en: '| `speed_mph_topic` | `surfboards/surfboard01/speedmph` |'
  prefs: []
  type: TYPE_TB
- en: '| `altitude_feet_topic` | `surfboards/surfboard01/altitudefeet` |'
  prefs: []
  type: TYPE_TB
- en: '| `temperature_f_topic` | `surfboards/surfboard01/temperaturef` |'
  prefs: []
  type: TYPE_TB
- en: 'Now, we will create a new Python file named `surfboard_sensors_emulator.py`
    in the main virtual environment folder. The following lines show the code for
    this file, which establishes a connection with our Mosquitto MQTT server, reads
    the previously created `surfboard_sensors_data.csv` CSV file, and continuously
    publishes the values read from this file to the previously enumerated topics.
    The code file for the sample is included in the `mqtt_python_gaston_hillar_06_01`
    folder, in the `surfboard_sensors_emulator.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In [Chapter 4](87908cb8-83ed-4b74-bfc5-dd0c4ddd93aa.xhtml), *Writing Code to
    Control a Vehicle with Python and MQTT Messages*, we created a Python file named
    `config.py` in the main virtual environment folder. In this file, we defined many
    configuration values that were used to establish a connection with the Mosquitto
    MQTT server. This way, all the configuration values were included in a specific
    Python script. If you need to make changes to this file to configure the surfboard
    emulator and the future surfboard monitor, make sure you review the explanations
    included in that chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The first lines import the variables we have declared in the `config.py` file
    and in the previously coded `surfboard_config.py` file. In this case, we also
    import the `csv` module to enable us to easily read from the CSV file that contains
    the values for the emulated sensors. The code for the `on_connect` function is
    very similar to the one we used in our previous examples.
  prefs: []
  type: TYPE_NORMAL
- en: The `publish_value` function receives the MQTT client, the topic name, and the
    value that we want to publish in the `client`, `topic`, and `value` arguments.
    The function calls the `client.publish` method to publish the received value as
    the payload to the topic name received in the `topic` argument with a QoS level
    of 0.
  prefs: []
  type: TYPE_NORMAL
- en: The main block uses our very well-known code to establish a connection with
    the Mosquitto MQTT server. After calling the `client.connect` method, the code
    calls the `client.loop_start` method to start a new thread that processes the
    MQTT network traffic and frees up the main thread.
  prefs: []
  type: TYPE_NORMAL
- en: Then, the codes enters in a continuous loop that opens the `surfboard_sensors_data.csv`
    CSV file and creates a `csv.reader` to read each row of comma-separated values
    into the `row` array. The code retrieves the string in `row[0]`, which represents
    the status value; converts it to an integer value; and saves the value in the
    `status_value` local variable. The next lines retrieve the strings for speed,
    altitude, and water temperature in `row[1]`, `row[2]`, and `row[3]`. The code
    converts these three values to floats and saves them in the `speed_mph_value`,
    `altitude_feet_value` and `water_temperature_f_value` local variables.
  prefs: []
  type: TYPE_NORMAL
- en: The next lines print debug messages with the values read for each emulated sensor
    from the CSV file and call the previously explained `publish_value` function for
    each of these values. Each call to the `publish_value` function uses the appropriate
    variable for the topic name that was configured in the `surfboard_config.py` file
    because each value is published to a different topic.
  prefs: []
  type: TYPE_NORMAL
- en: After the code publishes the values for the four emulated sensors, it sleeps
    for one second and repeats the procedure for the next line in the CSV file. After
    the last line is read, the code starts the loop again until the user presses *Ctrl*
    + *C* and causes a `KeyboardInterrupt` exception to be thrown and captured. In
    this case, we capture this exception and call the `client.disconnect` and `client.loop_stop`
    methods to have an appropriate disconnection from the Mosquitto MQTT server. In
    previous examples, we didn't care about this exception.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the PubNub MQTT interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PubNub requires us to sign up and create an account with a valid email and a
    password before we can create an application in PubNub, which allows us to start
    using their free services, including the PubNub MQTT interface for a device. We
    aren't required to enter any credit card or payment information. If you already
    have an account at PubNub, you can skip the next step.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have created your account, PubNub will redirect you to the admin portal
    that lists your PubNub applications. It is necessary to generate your PubNub publish
    and subscribe keys in order to send and receive messages on the network. Click
    on CREATE NEW APP+, enter `MQTT` in App Name, and click CREATE.
  prefs: []
  type: TYPE_NORMAL
- en: 'A new pane will represent the application in the admin portal. The following
    screenshot shows the MQTT application pane in the PubNub admin portal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/9688a166-7994-4df1-93c5-9405719dbb2b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on the MQTT pane and PubNub will display the Demo Keyset pane, which
    has been automatically generated for the application. Click on this pane and PubNub
    will display the Publish Key, Subscribe Key, and Secret key. We must copy and
    paste each of these keys to use them in our code that will use the PubNub MQTT
    interface to publish messages and the freeboard.io web-based dashboard that will
    subscribe to them. The following screenshot shows the prefixes for the keys. Notice
    that the remaining characters have been erased in the image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/1bd7d1cf-d2e7-4029-8689-cae606953d28.png)'
  prefs: []
  type: TYPE_IMG
- en: In order to copy the Secret key, you must click on the eye icon at the right-hand
    side of the Secret key and PubNub will make all the characters visible.
  prefs: []
  type: TYPE_NORMAL
- en: Publishing data retrieved from sensors to the cloud-based MQTT server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we display the status of the surfer and his surfboard with numbers, it will
    be difficult to understand the real status. So, we will have to map the integer
    that represents the status into a string that explains the status.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will create a new Python file named `surfboard_status.py` in the main
    virtual environment folder. The following lines show the code for this file, which
    defines constants for the different status numbers and a dictionary that maps
    these constants with integers to strings with the descriptions for the status.
    The code file for the sample is included in the `mqtt_python_gaston_hillar_06_01`
    folder, in the `surfboard_status.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will write the code for the surfboard monitor. We will split the code
    into many code snippets to make it easier to understand each code section. Create
    a new Python file named `surfboard_monitor.py` in the main virtual environment
    folder. The following lines declare all the necessary imports and the variables
    that we will use to establish a connection with the PubNub MQTT interface. Don''t
    forget to replace the strings assigned to the `pubnub_publish_key` and `pubnub_subscribe_key`
    variables with the values you have retrieved from the previously explained PubNub
    key generation process. The code file for the sample is included in the `mqtt_python_gaston_hillar_06_01`
    folder, in the `surfboard_monitor.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The first lines import the variables we have declared in the `config.py` file
    and in the previously coded `surfboard_config.py` and `surfboard_status.py` files.
    Then, the code declares the following variables that we will use to establish
    a connection with the PubNub MQTT interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '`pubnub_publish_key`: This string specifies the PubNub publish key.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pubnub_subscribe_key`: This string specifies the PubNub subscribe key.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pubnub_mqtt_server_host`: This string specifies the PubNub MQTT server address.
    In order to use the PubNub MQTT interface, we must always establish a connection
    with the `mqtt.pndsn.com` host.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pubnub_mqtt_server_port`: This number specifies the PubNub MQTT server port.
    In this case, we will establish an unsecured connection with the PubNub MQTT server,
    and therefore we will use port number `1883`. We want to keep the PubNub MQTT
    interface configuration simple for this example, and therefore we won''t use TLS.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pubnub_mqtt_keepalive`: This number specifies the keep alive interval configuration
    for the connection with the PubNub MQTT interface.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`device_id`: This string specifies the device identifier we want to use when
    we create an instance of the `Surfboard` class. The code assigns the `surfboard_name`
    value imported from the `surfboard_config.py` file. We will analyze the code for
    this class later.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Pubnub_topic`: This string specifies the topic to which the surfboard monitor
    will publish the JSON payload with the key-value pairs that specify the status
    for the surfer and their surfboard. The code assigns the `surfboard_name` value
    imported from the `surfboard_config.py` file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The surfboard monitor will establish a connection to the `mqtt.pndsn.com` host
    on port `1883`. So, we have to make sure that our firewall configuration has the
    appropriate inbound and outbound rules configurations to allow a connection on
    the specified port.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following lines to the existing `surfboard_monitor.py` in the main
    virtual environment folder. The following lines declare the `Surfboard` class.
    The code file for the sample is included in the `mqtt_python_gaston_hillar_06_01`
    folder, in the `surfboard_monitor.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We have to specify a `device_id` and the initial values for the data that the
    sensors provide in the `device_id`, `status`, `speed_mph`, `altitude_feet`, and
    `water_temperature_f` required arguments. The constructor, that is, the `__init__`
    method, saves the received values in attributes with the same names.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code also saves a reference to this instance in the `active_instance` class
    attribute because we have to access the instance in many functions that we will
    specify as callbacks for the different events that two MQTT clients will fire:
    the PubNub MQTT client and the Mosquitto MQTT client. We will access the active
    instance with the `Surfboard.active_instance` class attribute after the code creates
    a `Surfboard` instance.'
  prefs: []
  type: TYPE_NORMAL
- en: The class declares the `build_json_message` method, which builds a message with
    the status for the surfboard and returns the JSON string with the key-value pairs
    that composes the status message. The code maps the number stored in the `status`
    attribute into the string that explains the status by using the `SURFBOARD_STATUS_DICTIONARY`
    declared in the `surfboard_status.py` file. The code uses the `speed_mph`, `altitude_feet`,
    and `water_temperature_f` attributes to provide the values for the other keys.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following lines to the existing `surfboard_monitor.py` in the main
    virtual environment folder. The following lines declare the functions that we
    will use as callbacks and other functions that will be called by these callbacks.
    The code file for the sample is included in the `mqtt_python_gaston_hillar_06_01`
    folder, in the `surfboard_monitor.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The code declares the following functions that end with the `mosquitto` prefix:'
  prefs: []
  type: TYPE_NORMAL
- en: '`on_connect_mosquitto`: This function is the callback that will be executed
    once a successful connection has been established with the Mosquitto MQTT server.
    The code checks the value of the `rc` argument that provides the `CONNACK` code
    returned by the Mosquitto MQTT server. If this value matches `mqtt.CONNACK_ACCEPTED`,
    it means that the Mosquitto MQTT server accepted the connection request, and therefore
    the code calls the `client.subscribe` method for the MQTT client received in the
    `client` argument to subscribe to the `surfboards/surfboard01/+` topic filter
    with a QoS level of 0\. This way, the MQTT client will receive the messages sent
    to the `surfboards/surfboard01/status`, `surfboards/surfboard01/speedmph`, `surfboards/surfboard01/altitudefeet`,
    and `surfboards/surfboard01/temperaturef` topics with the values retrieved from
    the different sensors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`on_subscribe_mosquitto`: This function will be called when the subscription
    to the `surfboards/surfboard01/+` topic filter has been successfully completed.
    As in previous examples, the function prints a message indicating the QoS level
    granted to the subscription.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`print_received_message_mosquitto`: This function receives an `mqtt.MQTTMessage`
    instance in the `msg` argument and prints the topic and the payload of this message
    to help us understand what is happening in the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`on_status_message_mosquitto`: This function will be called when a message
    to the `surfboards/surfboard01/status` topic arrives from the Mosquitto MQTT server.
    The function calls the `print_received_message_mosquitto` function with the received
    `mqtt.MQTTMessage` instance as an argument and sets the value of the `status`
    attribute of the `Surfboard` active instance to the conversion of the received
    message''s payload to an `int`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`on_speed_mph_message_mosquitto`: This function will be called when a message
    to the `surfboards/surfboard01/speedmph` topic arrives from the Mosquitto MQTT
    server. The function calls the `print_received_message_mosquitto` function with
    the received `mqtt.MQTTMessage` instance as an argument and sets the value of
    the `speed_mph` attribute of the `Surfboard` active instance to the conversion
    of the received message''s payload to a `float`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`on_altitude_feet_message_mosquitto`: This function will be called when a message
    to the `surfboards/surfboard01/altitudefeet` topic arrives from the Mosquitto
    MQTT server. The function calls the `print_received_message_mosquitto` function
    with the received `mqtt.MQTTMessage` instance as an argument and sets the value
    of the `altitude_feet` attribute of the `Surfboard` active instance to the conversion
    of the received message''s payload to an `int`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`on_water_temperature_f_message_mosquitto`: This function will be called when
    a message to the `surfboards/surfboard01/watertemperaturef` topic arrives from
    the Mosquitto MQTT server. The function calls the `print_received_message_mosquitto`
    function with the received `mqtt.MQTTMessage` instance as an argument and sets
    the value of the `water_temperature_f` attribute of the `Surfboard` active instance
    to the conversion of the received message''s payload to an `int`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this case, we don't have a single function that works as a callback to process
    all the incoming messages from the Mosquitto MQTT server. We work with a callback
    for each specific topic. This way, we don't have to check the topic for the message
    to determine the code that we have to run.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code declares the following functions that end with the `pubnub` prefix:'
  prefs: []
  type: TYPE_NORMAL
- en: '`on_connect_pubnub`: This function is the callback that will be executed once
    a successful connection has been established with the PubNub MQTT server. The
    code checks the value of the `rc` argument that provides the `CONNACK` code returned
    by the PubNub MQTT server. If this value matches `mqtt.CONNACK_ACCEPTED`, it means
    that the PubNub MQTT server accepted the connection request, and therefore the
    code sets the value of the `is_pubnub_connected` attribute of the Surfboard active
    instance to `True`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`on_disconnect_pubnub`: This function is the callback that will be executed
    if the client that was connected to the PubNub MQTT server loses the connection.
    The code sets the value of the `is_pubnub_connected` attribute of the Surfboard
    active instance to `False` and prints a message.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with multiple MQTT servers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Add the following lines to the existing `surfboard_monitor.py` in the main
    virtual environment folder. The following lines declare the main block. The code
    file for the sample is included in the `mqtt_python_gaston_hillar_06_01` folder,
    in the `surfboard_monitor.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'First, the main block creates an instance of the `Surfboard` class and saves
    it in the `surfboard` local variable. Then, the code generates the client ID string
    that is required to establish a connection with the PubNub MQTT interface and
    saves it in the `pubnub_client_id` local variable. The PubNub MQTT interface requires
    us to use a client ID composed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The code uses the values of the `pubnub_publish_key`, `pubnub_subscribe_key`,
    and `device_id` variables to build a client ID as required by the PubNub MQTT
    interface. Then, the code creates an instance of the `mqtt.Client` class (`paho.mqtt.client.Client`)
    named `pubnub_client`, which represents the PubNub MQTT interface client. We use
    this instance to communicate with the PubNub MQTT server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, the code assigns functions to attributes. The following table summarizes
    these assignments:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Attribute** | **Assigned function** |'
  prefs: []
  type: TYPE_TB
- en: '| `pubnub_client.on_connect` | `on_connect_pubnub` |'
  prefs: []
  type: TYPE_TB
- en: '| `pubnub_client.on_disconnect` | `on_disconnect_pubnub` |'
  prefs: []
  type: TYPE_TB
- en: Then, the code calls the `pubnub_client.connect` method and specifies the values
    for the `host`, `port`, and `keepalive` arguments. This way, the code asks the
    MQTT client to establish a connection to the specified PubNub MQTT server. After
    calling the `pubnub_client.connect` method, the code calls the `pubnub_client.loop_start`
    method. This method starts a new thread that processes the MQTT network traffic
    related to the PubNub MQTT interface and frees up the main thread.
  prefs: []
  type: TYPE_NORMAL
- en: Then, the main block creates another instance of the `mqtt.Client` class (`paho.mqtt.client.Client`)
    named `mosquitto_client`, which represents the Mosquitto MQTT server client. We
    use this instance to communicate with the local Mosquitto MQTT server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, the code assigns functions to attributes. The following table summarizes
    these assignments:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Attribute** | **Assigned function** |'
  prefs: []
  type: TYPE_TB
- en: '| `mosquitto_client.on_connect` | `on_connect_mosquitto` |'
  prefs: []
  type: TYPE_TB
- en: '| `mosquitto_client.on_subscribe` | `on_subscribe_mosquitto` |'
  prefs: []
  type: TYPE_TB
- en: 'Notice that in this case, the code doesn''t assign a function to `mosquitto_client.on_message`.
    The next lines call the `mosquitto_client.message_callback_add` method to specify
    the callback function that the client has to call when it receives a message in
    a specific topic. The following table summarizes the function that will be called
    based on the variable that defines the topic in which the message arrives:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Topic variable** | **Assigned function** |'
  prefs: []
  type: TYPE_TB
- en: '| `status_topic` | `on_status_message_mosquitto` |'
  prefs: []
  type: TYPE_TB
- en: '| `speed_mph_topic` | `on_speed_mph_message_mosquitto` |'
  prefs: []
  type: TYPE_TB
- en: '| `altitude_feet_topic` | `on_altitude_feet_message_mosquitto` |'
  prefs: []
  type: TYPE_TB
- en: '| `water_temperature_f_topic` | `on_water_temperature_f_message_mosquitto`
    |'
  prefs: []
  type: TYPE_TB
- en: Whenever the client receives a message from any of the sensors, it will update
    the appropriate attribute for the `Surfboard` active instance. These assigned
    functions are responsible for updating the status of the `Surfboard` active instance.
  prefs: []
  type: TYPE_NORMAL
- en: Then, the code calls the well-known `mosquitto_client.tls_set` and `mosquitto_client.connect`
    methods. This way, the code asks the MQTT client to establish a connection to
    the specified Mosquitto MQTT server. After calling the `mosquitto_client.connect`
    method, the code calls the `mosquitto_client.loop_start` method. This method starts
    a new thread that processes the MQTT network traffic related to the Mosquitto
    MQTT server and frees up the main thread.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that we made two calls to `loop_start`, and therefore we will have two
    threads processing MQTT network traffic: one for the PubNub MQTT server and the
    other for the Mosquitto MQTT server.'
  prefs: []
  type: TYPE_NORMAL
- en: The next lines declare a `while` loop that runs forever until a `KeyboardInterrupt`
    exception occurs. The loop checks the value of the `Surfboard.active_instance.is_pubnub_connected`
    attribute to make sure that the connection to the PubNub MQTT server isn't broken.
    If the connection is alive, the code calls the `Surfboard.active_instance.build_json_message`
    method to build the JSON string based on the current values of the `Surfboard`
    attributes, which are being updated whenever a message with new values arrives
    from the sensors.
  prefs: []
  type: TYPE_NORMAL
- en: The code saves the JSON string in the `payload` local variable and calls the
    `pubnub_client.publish` method to publish the `payload` JSON formatted string
    to the topic name saved in the `pubnub_topic` variable with a QoS level of 0\.
    This way, the message will be published by the thread responsible for processing
    the MQTT network events for the PubNub MQTT client, and the web-based dashboard
    that uses the PubNub MQTT server as a data source will be updated. The next line
    prints a message with the payload that is being published to the PubNub MQTT server.
  prefs: []
  type: TYPE_NORMAL
- en: Running multiple clients
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we will run the surfboard sensor emulator and the surfboard monitor we
    recently coded. Make sure you run these Python programs after you have followed
    the necessary steps to activate the virtual environment in which we have been
    working.
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the following line to start the surfboard sensor emulator example on
    any computer or device that you want to use as the MQTT client that works as the
    surfboard sensor emulator and uses Linux or macOS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In Windows, you must execute the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'After a few seconds, you will see the output shown in the next lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The program will continue publishing messages for the topics to the Mosquitto
    MQTT server. Keep the code running on your local computer or on the IoT board
    you have chosen to use as the surfboard sensor emulator for this example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, execute the following line to start the surfboard monitor example on
    any computer or device that you want to use as the MQTT client that receives messages
    from the Mosquitto MQTT server and publishes messages to the PubNub MQTT server
    and uses Linux or macOS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In Windows, you must execute the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'After a few seconds, you will see an output with messages similar to the next
    lines. Notice that the values will be different because the time at which you
    start running the program will make the values vary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The program will continue receiving messages form the surfboard sensor emulator
    and publishing messages to the PubNub MQTT server. Keep the code running on your
    local computer or on the IoT board you have chosen to use as the surfboard monitor
    for this example.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows two Terminal windows running on a computer with
    macOS. The Terminal on the left-hand side is displaying the messages shown by
    the Python client that works as the surfboard sensor emulator, that is, the `surfboard_sensors_emulator.py`
    script. The Terminal on the right-hand side displays the results of running the
    code for the Python client that works as the surfboard monitor, that is, the `surfboard_monitor.py`
    script:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/611ee552-ee5c-42ed-8915-edf10b548519.png)'
  prefs: []
  type: TYPE_IMG
- en: Building a web-based dashboard with freeboard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we are ready to use the PubNub MQTT server as a data source to build a
    real-time web-based dashboard. As previously explained, we will take advantage
    of freeboard.io to visualize the surfer and surfboard data in many gauges.
  prefs: []
  type: TYPE_NORMAL
- en: The freeboard.io requires us to sign up and create an account with a valid email
    and a password before we can build a web-based dashboard. We aren't required to
    enter any credit card or payment information. If you already have an account at
    freeboard.io, you can skip the next step.
  prefs: []
  type: TYPE_NORMAL
- en: Go to [http://freeboard.io](http://freeboard.io) in your web browser and click
    Start Now. You can also go straight to [https://freeboard.io/signup](https://freeboard.io/signup).
    Enter your desired user name in Pick a Username, your email in Enter Your Email,
    and the desired password in Create a Password. Once you have filled in all the
    fields, click Create My Account.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have created your account, you can go to [http://freeboard.io](http://freeboard.io)
    in your web browser and click Login. You can achieve the same goal by visiting
    [https://freeboard.io/login](https://freeboard.io/login). Then, enter your user
    name or email and password, and click Sign In. freeboard will display your freeboards,
    also known as dashboards.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter `Surfboard01` in the enter a name textbox on the left-hand side of the
    Create New button and then click on this button. freeboard.io will display an
    empty dashboard with many buttons that allow us to add panes and data sources,
    among other things. The following screenshot shows the empty dashboard:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/d7089651-6c62-4937-830d-7ecb05c946ba.png)'
  prefs: []
  type: TYPE_IMG
- en: Click on Add below Datasources and the website will open the Datasource dialog
    box. Select PubNub in the Type dropdown and the dialog box will display the fields
    required to define a PubNub datasource.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that it is also possible to use MQTT as a datasource for freeboard.io.
    However, this would require us to make our Mosquitto MQTT server publicly available.
    Instead, we take advantage of the PubNub MQTT interface which allows us to make
    the messages easily available on the PubNub network. However, you can definitely
    work with an MQTT server as a datasource in your projects that require a dashboard
    where freeboard.io provides you the with required features.
  prefs: []
  type: TYPE_NORMAL
- en: Enter `surfboard01` in Name.
  prefs: []
  type: TYPE_NORMAL
- en: Enter the subscribe key you have copied from the PubNub settings. Remember that
    the subscribe key is the one that usually starts with the `sub-c` prefix.
  prefs: []
  type: TYPE_NORMAL
- en: Enter `surfboard01` in Channel.
  prefs: []
  type: TYPE_NORMAL
- en: 'If any of the previous value names is wrong, the datasource won''t have the
    appropriate data. The following screenshot shows the configuration for the PubNub
    datasource with the subscribe displaying only the `sub-c` prefix:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/57fab197-993c-4ad3-b989-ef126e8dd77e.png)'
  prefs: []
  type: TYPE_IMG
- en: Click Save and the datasource will appear listed below Datasources. As the surfboard
    sensor emulator and the surfboard monitor are running, the time shown below Last
    Updated will change every second. If the time doesn't change every second, it
    means that the datasource has the wrong configuration or that any of the Python
    programs is not running as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Click on Add pane to add a new empty pane to the dashboard. Then, click on the
    plus sign (+) at the upper right corner of the new empty pane and freeboard will
    display the Widget dialog box.
  prefs: []
  type: TYPE_NORMAL
- en: Select Text in the Type dropdown and the dialog box will display the fields
    required to add a text widget to the pane within the dashboard. Enter `Status`
    in Title.
  prefs: []
  type: TYPE_NORMAL
- en: 'Click + Datasource on the right-hand side of the Value textbox, select surfboard01,
    and then select Status. After you make the selections, the following text will
    appear in the Value textbox, `datasources ["surfboard01"] ["Status"]`, as shown
    in the next screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/4d75a58e-0dbd-4025-ae1d-eba3a29f2c02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, click Save and freeboard will close the dialog box and add the new gauge
    to the previously created pane within the dashboard. The gauge will display the
    latest value that the surfboard monitor published to the PubNub MQTT interface
    for the status, that is, the value for the `Status` key in the JSON data that
    the code has published for the last time. The following screenshot shows the surfboard01
    datasource displaying the last updated time and the gauge showing the latest value
    for the status:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/f0a8e9fe-1230-4721-b40d-ef49df3aa008.png)'
  prefs: []
  type: TYPE_IMG
- en: Click on Add pane to add another new empty pane to the dashboard. Then, click
    on the plus sign (+) at the upper-right corner of the new empty pane and freeboard
    will display the Widget dialog box.
  prefs: []
  type: TYPE_NORMAL
- en: Select Gauge in the Type dropdown and the dialog box will display the fields
    required to add a gauge widget to the pane within the dashboard. Enter `Speed`
    in Title.
  prefs: []
  type: TYPE_NORMAL
- en: 'Click + Datasource at the right-hand side of the Value textbox, select surfboard01,
    and then select Speed MPH. After you make the selections, the following text will
    appear in the Value textbox: `datasources ["surfboard01"] ["Speed MPH"]`.'
  prefs: []
  type: TYPE_NORMAL
- en: Enter `MPH` in Units, `0` in Minimum, and `40` in Maximum. Then, click Save
    and freeboard will close the dialog box and add the new gauge to the previously
    created pane on the dashboard. The gauge will display the latest value that the
    surfboard monitor published to the PubNub MQTT interface for the speed, that is,
    the value for the `Speed MPH` key in the JSON data that the code has published
    for the last time.
  prefs: []
  type: TYPE_NORMAL
- en: The following screenshot shows the surfboard01 datasource displaying the last
    updated time and the added gauge showing the latest value for the speed in mph.
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/cacc5fe5-54e2-4cb2-8277-5692d568dd92.png)'
  prefs: []
  type: TYPE_IMG
- en: Click on Add pane to add another new empty pane to the dashboard. Then, click
    on the plus sign (+) at the upper-right corner of the new empty pane and freeboard
    will display the Widget dialog box.
  prefs: []
  type: TYPE_NORMAL
- en: Select Gauge in the Type dropdown and the dialog box will display the fields
    required to add a gauge widget to the pane on the dashboard. Enter `Altitude`
    in Title.
  prefs: []
  type: TYPE_NORMAL
- en: 'Click + Datasource at the right-hand side of the Value textbox, select surfboard01,
    and then select Altitude Feet. After you make the selections, the following text
    will appear in the Value textbox: `datasources ["surfboard01"] ["Altitude Feet"]`.'
  prefs: []
  type: TYPE_NORMAL
- en: Enter `Feet` in Units, `0` in Minimum, and `30` in Maximum. Then, click Save
    and freeboard will close the dialog box and add the new gauge to the previously
    created pane on the dashboard. The gauge will display the latest value that the
    surfboard monitor published to the PubNub MQTT interface for the altitude, that
    is, the value for the `Altitude Feet` key in the JSON data that the code has published
    for the last time.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will add the last pane. Click on Add pane to add another new empty pane
    to the dashboard. Then, click on the plus sign (+) at the upper-right corner of
    the new empty pane and freeboard will display the Widget dialog box.
  prefs: []
  type: TYPE_NORMAL
- en: Select Gauge in the Type dropdown and the dialog box will display the fields
    required to add a gauge widget to the pane on the dashboard. Enter `Water temperature`
    in Title.
  prefs: []
  type: TYPE_NORMAL
- en: 'Click + Datasource at the right-hand side of the Value textbox, select surfboard01,
    and then select Water Temperature F. After you make the selections, the following
    text will appear in the Value textbox: `datasources ["surfboard01"] ["Water Temperature
    F"]`.'
  prefs: []
  type: TYPE_NORMAL
- en: Enter `ºF` in Units, `0` in Minimum, and `80` in Maximum. Then, click Save and
    freeboard will close the dialog box and add the new gauge to the previously created
    pane on the dashboard. The gauge will display the latest value that the surfboard
    monitor published to the PubNub MQTT interface for the water temperature, that
    is, the value for the `Water Temperature F` key in the JSON data that the code
    has published for the last time.
  prefs: []
  type: TYPE_NORMAL
- en: Drag and drop the panes to locate the panes with the layout shown in the next
    screenshot. The screenshot shows the dashboard we built with four panes and three
    gauges that refresh the data automatically every second when our surfboard monitor
    publishes data to the PubNub MQTT interface.
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/226d41e2-1a7c-46d7-a9c7-ae613fca5ce5.png)We can access the recently
    built dashboard on any device by entering the URL that our web browser displays
    at the time we are working with the dashboard. The URL is composed of the `https://freeboard.io/board/`
    prefix followed by letters and numbers. For example, if the URL is `https://freeboard.io/board/EXAMPLE`,
    we just need to enter it in any web browser running on any device or computer
    connected to the internet, and we can watch the gauges and they will be refreshed
    as new data is being published from our surfboard monitor.'
  prefs: []
  type: TYPE_NORMAL
- en: The combination of the PubNub as our datasource and freeboard.io as our web-based
    dashboard made it easy for us to monitor the data retrieved from the sensors in
    the surfer's wetsuit and his surfboard. We can monitor the data on any device
    that provides a web browser. The combination of these two cloud-based services
    for IoT is just one example of how we can easily combine different services with
    MQTT in our solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Test your knowledge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s see whether you can answer the following questions correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The PubNub MQTT interface requires us to use a client ID composed as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`publish_key/subscribe_key/device_id`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`device_id/publish_key/subscribe_key`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`publish_key/device_id`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When we publish a message to the PubNub MQTT interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is only available on the PubNub MQTT subnetwork
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It becomes available on the PubNub network
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It requires a specific payload prefix to become available on the PubNub network
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Which of the following methods of the `paho.mqtt.client.Client` instance allows
    us to specify the callback function that the client has to call when it receives
    a message in a specific topic:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`message_callback_add`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`message_arrived_to_topic_callback`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`message_on_topic`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we combined everything we learned in the previous chapters
    to build a web-based dashboard with freeboard that displayed data in gauges every
    second. We built the solution from scratch. First, we analyzed the requirements
    and we understood how the IoT board embedded in a surfboard was going to provide
    us with the necessary data.
  prefs: []
  type: TYPE_NORMAL
- en: We coded a surfboard sensor emulator to work in the same way that the IoT board
    was working. Then, we configured the PubNub MQTT interface and we coded a surfboard
    monitor that collected data from the surfboard sensor emulator and published the
    data to the cloud-based PubNub MQTT interface. We coded a Python program that
    worked with two MQTT clients with two threaded loop interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we could take advantage of the fact that the messages published to
    the PubNub MQTT interface are also available on the PubNub network to easily build
    a web-based dashboard with freeboard.
  prefs: []
  type: TYPE_NORMAL
- en: 'We were able to create code that was capable of running on the most popular
    and powerful IoT boards. We are ready to use MQTT in all kinds of projects, in
    one of the most popular and versatile programming languages: Python 3.'
  prefs: []
  type: TYPE_NORMAL
