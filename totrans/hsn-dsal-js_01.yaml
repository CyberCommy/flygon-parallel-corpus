- en: Building Stacks for Application State Management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Stacks are one of the most common data structures that one can think of. They
    are ubiquitous in both personal and professional setups. Stacks are a **last in
    first out** (**LIFO**) data structure, that provides some common operations, such
    as push, pop, peek, clear, and size.
  prefs: []
  type: TYPE_NORMAL
- en: In most **object-oriented programming** (**OOP**) languages, you would find
    the stack data structure built-in. JavaScript, on the other hand, was originally
    designed for the web; it does not have stacks baked into it, yet. However, don't
    let that stop you. Creating a stacks using JS is fairly easy, and this is further
    simplified by the use of the latest version of JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, our goal is to understand the importance of stack in the new-age
    web and their role in simplifying ever-evolving applications. Let''s explore the
    following aspects of the stack:'
  prefs: []
  type: TYPE_NORMAL
- en: A theoretical understanding of the stack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Its API and implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use cases in real-world web
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before we start building a stack, let's take a look at some of the methods that
    we want our stack to have so that the behavior matches our requirements. Having
    to create the API on our own is a blessing in disguise. You never have to rely
    on someone else's library *getting it right* or even worry about any missing functionality.
    You can add what you need and not worry about performance and memory management
    until you need to.
  prefs: []
  type: TYPE_NORMAL
- en: Prerequisites
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are the requirements for the following chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: A basic understanding of JavaScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A computer with Node.js installed (downloadable from[ https://nodejs.org/en/download/](https://nodejs.org/en/download/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code sample for the code shown in this chapter can be found at [https://github.com/NgSculptor/examples](https://github.com/NgSculptor/examples).
  prefs: []
  type: TYPE_NORMAL
- en: Terminology
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Throughout the chapter, we will use the following terminology specific to Stacks,
    so let''s get to know more about it:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Top**: Indicates the top of the stack'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Base**: Indicates the bottom of the stack'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is the tricky part, as it is very hard to predict ahead of time what kinds
    of method your application will require. Therefore, it''s usually a good idea
    to start off with whatever is the norm and then make changes as your applications
    demand. Going by that, you would end up with an API that looks something like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Push**: Pushes an item to the top of the stack'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pop**: Removes an item from the top of the stack'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Peek**: Shows the last item pushed into the stack'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Clear**: Empties the stack'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Size**: Gets the current size of the stack'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](assets/00895cb7-ce03-49c1-866a-6ebc7c158459.png)'
  prefs: []
  type: TYPE_IMG
- en: Don't we have arrays for this?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: From what we have seen so far, you might wonder why one would need a stack in
    the first place. It's very similar to an array, and we can perform all of these
    operations on an array. Then, what is the real purpose of having a stack?
  prefs: []
  type: TYPE_NORMAL
- en: 'The reasons for preferring a stackover an array are multifold:'
  prefs: []
  type: TYPE_NORMAL
- en: Using stacksgives a more semantic meaning to your application. Consider this
    analogy where you have a backpack (an array) and wallet (a stack). Can you put
    money in both the backpack and wallet? Most certainly; however, when you look
    at a backpack, you have no clue as to what you may find inside it, but when you
    look at a wallet, you have a very good idea that it contains money. What kind
    of money it holds (that is, the data type), such as Dollars, INR, and Pounds,
    is, however, still not known (supported, unless you take support from TypeScript).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Native array operations have varying time complexities. Let's take `Array.prototype.splice` and `Array.prototype.push`,for
    example. Splice has a worst-case time complexity of O(n), as it has to search
    through all the index and readjust it when an element is splicedout of the array.
    `Push` has a worst case complexity of O(n) when the memory buffer is full but
    is amortized O(1). Stacks avoid elements being accessed directly and internally
    rely on a `WeakMap()`, which is memory efficient as you will see shortly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a stack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we know when and why we would want to use a stack, let''s move on
    to implementing one. As discussed in the preceding section, we will use a `WeakMap()`for
    our implementation. You can use any native data type for your implementation,
    but there are certain reasons why `WeakMap()` would be a strong contender. `WeakMap()`
    retains a weak reference to the keys that it holds. This means that once you are
    no longer referring to that particular key, it gets garbage-collected along with
    the value. However, `WeakMap()`come with its own downsides: keys can only be nonprimitives
    and are not enumerable, that is, you cannot get a list of all the keys, as they
    are dependent on the garbage collector. However, in our case, we are more concerned
    with the values that our `WeakMap()` holds rather than keys and their internal
    memory management.'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing stack methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Implementing a stack is a rather easy task. We will follow a series of steps,
    where we will use the ES6 syntax, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define a `constructor`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `WeakMap()` to store the stack items:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the methods described in the preceding API  in the `Stack` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'So, the final implementation of the `Stack` will look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This is an overarching implementation of a JavaScript stack, which by no means
    is comprehensive and can be changed based on the application's requirements. However,
    let's go through some of the principles employed in this implementation.
  prefs: []
  type: TYPE_NORMAL
- en: We have used a `WeakMap()` here, which as explained in the preceding paragraph,
    helps with internal memory management based on the reference to the stack items.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another important thing to notice is that we have wrapped the `Stack` class
    inside an IIFE, so the constants `items `and `sKey` are available to the `Stack`
    class internally but are not exposed to the outside world. This is a well-known
    and debated feature of the current JSClas*s *implementation, which does not allow
    class-level variables to be declared. TC39 essentially designed the ES6 Class
    in such a way that it should only define and declare its members, which are prototype
    methods in ES5\. Also, since adding variables to prototypes is not the norm, the
    ability to create class-level variables has not been provided. However, one can
    still do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: However, this would make the `items`accessible also from outside our `Stack`methods,
    which is something that we want to avoid.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the stack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To test the `Stack` we have just created, let''s instantiate a new stack and
    call out each of the methods and take a look at how they present us with data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: When we run the above script we see the logs as specified in the comments above.
    As expected, the stackprovides what appears to be the expected output at each
    stage of the operations.
  prefs: []
  type: TYPE_NORMAL
- en: Using the stack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To use the `Stack`class created previously, you would have to make a minor
    change to allow the stack to be used based on the environment in which you are
    planning to use it. Making this change generic is fairly straightforward; that
    way, you do not need to worry about multiple environments to support and can avoid
    repetitive code in each application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Once we add this logic to the stack, it is multi-environment ready. For the
    purpose of simplicity and brevity, we will not add it everywhere we see the stack;
    however, in general, it's a good thing to have in your code.
  prefs: []
  type: TYPE_NORMAL
- en: If your technology stack comprises ES5, then you need to transpile the preceding
    stack code to ES5\. This is not a problem, as there are a plethora of options
    available online to transpile code from ES6 to ES5.
  prefs: []
  type: TYPE_NORMAL
- en: Use cases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have implemented a `Stack` class, let's take a look at how we can
    employ this in some web development challenges.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an Angular application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To explore some practical applications of the stackin web development, we will
    create an Angularapplication first and use it as a base application, which we
    will use for subsequent use cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting off with the latest version of Angularis pretty straightforward. All
    you need as a prerequisite is to have Node.js preinstalled in your system. To
    test whether you have Node.js installed on your machine, go to the Terminal on
    the Mac or the command prompt on Windows and type the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'That should show you the version of Node.js that is installed. If you have
    something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This means that you do not have Node.js installed on your machine.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have Node.js set up on your machine, you get access to `npm`, also
    known as the node package manager command-line tool, which can be used to set
    up global dependencies. Using the `npm`command, we will install the Angular CLI
    tool, which provides us with many Angular utility methods, including—but not limited
    to—creating a new project.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Angular CLI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To install the Angular CLI in your Terminal, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: That should install the Angular CLI globally and give you access to the `ng`command
    to create new projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test it, you can run the following command, which should show you a list
    of features available for use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Creating an app using the CLI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s create the Angular application. We will create a new application
    for each example for the sake of clarity. You can club them into the same application
    if you feel comfortable. To create an Angular application using the CLI, run the
    following command in the Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace `project-name`with the name of your project; if everything goes well,
    you should see something similar on your Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: If you run into any issues, ensure that you have angular-cli installed as described
    earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Before we write any code for this application, let's import the stack that we
    earlier created into the project. Since this is a helper component, I would like
    to group it along with other helper methods under the `utils`directory in the
    root of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a stack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since the code for an Angularapplication is now in TypeScript, we can further
    optimize the stack that we created. Using TypeScript makes the code more readable
    thanks to the `private` variables that can be created in a TypeScript class.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, our TypeScript-optimized code would look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'To use the `Stack` created previously, you can simply import the stack into
    any component and then use it. You can see in the following screenshot that as
    we made the `WeakMap()`and the keyprivate members of the `Stack`class, they are
    no longer accessible from outside the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '>![](assets/ae8a74de-f5d0-4369-93d7-75702f697ae2.png)Public methods accessible
    from the Stack class'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a custom back button for a web application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These days, web applications are all about user experience, with flat design
    and small payloads. Everyone wants their application to be quick and compact.
    Using the clunky browser back button is slowly becoming a thing of the past. To
    create a custom Back button for our application, we will need to first create
    an Angularapplication from the previously installed `ng`cli client, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Setting up the application and its routing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have the base code set up, let''s list the steps for us to build
    an app that will enable us to create a custom Back button in a browser:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating states for the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Recording when the state of the application changes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Detecting a click on our custom Back button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Updating the list of the states that are being tracked.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's quickly add a few states to the application, which are also known as routesin Angular*. *All
    SPA frameworks have some form of routing module, which you can use to set up a
    few routes for your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have the routes and the routing set up, we will end up with a directory
    structure, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/f819036a-8697-4aed-b7ab-8a045a320b86.png)Directory structure after
    adding routes'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s set up the navigation in such a way that we can switch between the
    routes. To set up routing in an Angular application, you will need to create the
    component to which you want to route and the declaration of that particular route.
    So, for instance, your `home.component.ts`would look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The `home.routing.ts`filewould be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We can set up a similar configuration for as many routes as needed, and once
    it's set up, we will create an app-level file for application routing and inject
    all the routes and the `navigatableComponents` in that file so that we don't have
    to touch our main module over and over.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, your file `app.routing.ts`would look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'You will note that we are doing something particularly interesting here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This is Angular*'*s way of setting default route redirects, so that, when the
    app loads, it's taken directly to the `/home` path, and we no longer have to set
    up the redirects manually.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting application state changes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To detect a state change, we can, luckily, use the Angularrouter''s change
    event and take actions based on that. So, import the `Router`module in your `app.component.ts` and
    then use that to detect any state change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Any action that the user takes that results in a state change is now being saved
    into our stack, and we can move on to designing our layout and the back button
    that transitions the states.
  prefs: []
  type: TYPE_NORMAL
- en: Laying out the UI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will use angular-material to style the app, as it is quick and reliable.
    To install `angular-material`,run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Once angular-material is saved into the application, we can use the `Button` component
    provided to create the UI necessary, which will be fairly straightforward. First,
    import the `MatButtonModule` that we want to use for this view and then inject
    the module as the dependency in your main `AppModule`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final form of `app.module.ts` would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We will place four buttons at the top to switch between the four states that
    we have created and then display these states in the `router-outlet`directive
    provided by Angularfollowed by the back button. After all this is done, we will
    get the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Navigating between states
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To add logic to the back button from here on is relatively simpler. When the
    user clicks on the Back button, we will navigate to the previous state of the
    application from the stack. If the stack was empty when the user clicks the Back
    button, meaning that the user is at the starting state, then we set it back into
    the stack because we do the `pop()` operation to determine the current state of
    the stack.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Note here that we are using `urlAfterRedirects`instead of plain `url`*. *This
    is because we do not care about all the hops a particular URL made before reaching
    its final form, so we can skip all the redirected paths that it encountered earlier
    and send the user directly to the final URL after the redirects. All we need is
    the final state to which we need to navigate our user because that's where they
    were before navigating to the current state.
  prefs: []
  type: TYPE_NORMAL
- en: Final application logic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So, now our application is ready to go. We have added the logic to stack the
    states that are being navigated to and we also have the logic for when the user
    hits the Back button. When we put all this logic together in our `app.component.ts`*, *we
    have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We also have some supplementary stylesheets used in the application. These are
    obvious based on your application and the overall branding of your product; in
    this case, we are going with something very simple.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the AppComponent styling, we can add component-specific styles in `app.component.scss`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'For the overall theme of the application, we add styles to the `theme.scss` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This preceding theme file is taken from the Angular material design documentation and
    can be changed as per your application's color scheme.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we are ready with all our changes, we can run our application by running
    the following command from the root folder of our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: That should spin up the application, which can be accessed at `http://localhost:4200`.
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/1a715dff-96aa-4aaa-b8d8-9dd6e7c85b5a.png)'
  prefs: []
  type: TYPE_IMG
- en: From the preceding screenshot, we can see that the application is up-and-running,
    and we can navigate between the different states using the Back button we just
    created.
  prefs: []
  type: TYPE_NORMAL
- en: Building part of a basic JavaScript syntax parser and evaluator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main intent of this application is to show concurrent usage of multiple
    stacksin a computation-heavy environment. We are going to parse and evaluate expressions
    and generate their results without having to use the evil eval.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if you want to build your own `plnkr.co`or something similar, you
    would be required to take steps in a similar direction before understanding more
    complex parsers and lexers, which are employed in a full-scale online editor.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use a similar base project to the one described earlier. To create
    a new application with angular-cli we will be using the CLI tool we installed
    earlier. To create the app run the following command in the Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Building a basic web worker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once we have the app created and instantiated, we will create the `worker.js`file
    first using the following commands from the root of your app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This will generate the `utils` folder and the `worker.js` file in it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note the following two things here:'
  prefs: []
  type: TYPE_NORMAL
- en: It is a simple JS file and not a TypeScript file, even though the entire application
    is in TypeScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is called `worker.js`*, *which means that we will be creating a web worker
    for the parsing and evaluation that we are about to perform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Web workers are used to simulate the concept of **multithreading**in JavaScript,
    which is usually not the case. Also, since this threadruns in isolation, there
    is no way for us to provide dependencies to that. This works out very well for
    us because our main app is only going to accept the user's input and provide it
    to the worker on every key stroke while it's the responsibility of the workerto
    evaluate this expression and return the result or the error if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since this is an external file and not a standard Angular file, we will have
    to load it up as an external script so that our application can use it subsequently.
    To do so, open your `.angular-cli.json` file and update the `scripts` option to
    look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will be able to use the injected worker, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: First, we will add the necessary changes to the `app.component.ts` file so that
    it can interact with `worker.js` as needed.
  prefs: []
  type: TYPE_NORMAL
- en: Laying out the UI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will use angular-material once more as described in the preceding example.
    So, install and use the components as you see fit to style your application''s
    UI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We will use `MatGridListModule` to create our application''s UI. After importing
    it in the main module, we can create the template as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: We are laying down two tiles; the first one contains the `textarea` to write
    the code and the second one displays the result generated.
  prefs: []
  type: TYPE_NORMAL
- en: We have bound the input area with `ngModel`, which is going to provide the two-way
    binding that we need `between` our view and the component. Further, we leverage
    the `keyup` event to trigger the method called `codeChange()`, which will be responsible
    for passing our expression into the worker.
  prefs: []
  type: TYPE_NORMAL
- en: The implementation of the `codeChange()` method will be relatively easy.
  prefs: []
  type: TYPE_NORMAL
- en: Basic web worker communication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As the component loads, we will want to set up the worker so that it is not
    something that we have to repeat several times. So, imagine if there were a way
    in which you can set up something conditionally and perform an action only when
    you want it to. In our case, you can add it to the constructor or to any of the
    lifecycle hooks that denote what phase the component is in such as `OnInit`, OnContentInit,
    `OnViewInit` and so on, which are provided by Angular as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Once initialized, we then use the `addEventListener()` method to listen for
    any new messages—that is, results coming from our worker.
  prefs: []
  type: TYPE_NORMAL
- en: 'Any time the code is changed, we simply pass that data to the worker that we
    have now set up. The implementation for this looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: As you can note, the main application component is intentionally lean. We are
    leveraging workers for the sole reason that CPU-intensive operations can be kept
    away from the main thread. In this case, we can move all the logic including the
    validations into the worker, which is exactly what we have done.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling web worker communications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that the app component is set and ready to send messages, the worker needs
    to be enabled to receive the messages from the main thread. To do that, add the
    following code to your `worker.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we added the capability of listening for any messagethat might
    be sent to the workerand then the worker simply takes that data and applies some
    basic validation on it before trying to evaluate and return any value for the
    expression. In our validation, we simply rejected any characters that are alphabetic
    because we want our users to only provide valid numbers and operators.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, start your application using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the app come up at `localhost:4200`*. *Now, simply enter any
    code to test your application; for example, enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'You would see the following error pop up on the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/56deb8ae-ddfd-4ae8-a322-1437289322ae.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s get a detailed understanding of the algorithm that is in play.
    The algorithm will be split into two parts: parsing and evaluation*.  *A step-by-step
    breakdown of the algorithm would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Converting input expression to a machine-understandable expression.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Evaluating the `postfix` expression.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Returning the expression's value to the parent component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Transforming input to machine-understandable expression
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The input (anything that the user types) will be an expression in the infix
    notation, which is human-readable. Consider this for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: However, this is not something that we can evaluate as it is, so we convert
    it into a `postfix` notation or reverse polish notation.
  prefs: []
  type: TYPE_NORMAL
- en: 'To convert an infix to a `postfix` notation is something that takes a little
    getting used to. What we have  is a watered-down version of that algorithm in
    Wikipedia, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Take the input expression (also known as, the infix expression) and tokenize
    it, that is, split it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Evaluate each token iteratively, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the token to the output string (also known as the `postfix` notation) if
    the encountered character is a number
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If it is `(` that is, an opening parenthesis, add it to the output string.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If it is `)` that is, a closed parenthesis, pop all the operators as far as
    the previous opening parenthesis into the output string.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the character is an operator, that is, `*`, `^`, `+`, `-`, `/`, and `,`then
    check the precedence of the operator first before popping it out of the stack.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pop all remaining operators in the tokenized list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return the resultant output string or the `postfix` notation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Before we translate this into some code, let's briefly talk about the precedence
    and associativity of the operators, which is something that we need to predefine
    so that we can use it while we are converting the infix expression to `postfix`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Precedence, as the name suggests, determines the `priority` of that particular
    operator whereas associativity dictates whether the expression is evaluated from
    left to right or vice versa in the absence of a parenthesis. Going by that, since
    we are only supporting simple operators, let''s create a map of operators, their
    `priority`, and `associativity`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, going by the algorithm, the first step is to tokenize the input string.
    Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'It would be converted as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: To achieve this, we basically remove all extra spaces, replace all white spaces
    with empty strings, and split the remaining string on any of the *`*`, `^`, `+`,
    `-`, `/` *operators and remove any occurrences of an empty string.
  prefs: []
  type: TYPE_NORMAL
- en: Since there is no easy way to remove all empty strings `""`from an array, we
    can use a small utility method called clean, which we can create in the same file.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be translated into code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'So, the final expression becomes as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have the input string split, we are ready to analyze each of the
    tokens to determine what type it is and take action accordingly to add it to the `postfix`
    notation output string. This is *Step 2 *of the preceding algorithm, and we will
    use a Stack to make our code more readable. Let''s include the stack into our
    worker,as it cannot access the outside world. We simply convert our stack to ES5
    code, which would look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the methods are attached to the `prototype`and voilà we have
    our stack ready.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s consume this stack in the infix to postfix conversion. Before we
    do the conversion, we will want to check that the user-entered input is valid,
    that is, we want to check that the parentheses are balanced. We will be using
    the simple `isBalanced()` method as described in the following code, and if it
    is not balanced we will return an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'We are going to need the stack to hold the operators that we are encountering
    so that we can rearrange them in the `postfix` string based on their `priority`
    and `associativity`. The first thing we will need to do is check whether the token
    encountered is a number; if it is, then we append it to the `postfix` result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we check whether the encountered token is an open bracket, and if it
    is, then we push it to the operators'' stack waiting for the closing bracket.
    Once the closing bracket is encountered, we group everything (operators and numbers)
    in between and pop into the `postfix` output, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The last (and a slightly complex) step is to determine whether the token is
    one of `*`, `^`, `+`, `-`, `/`, and then we check the `associativity` of the current
    operator first. When it's left to right, we check to make sure that the priority
    of the current operator is *less than or equal* to the priority of the previous
    operator. When it's right to left, we check whether the priority of the current
    operator is *strictly less* than the priority of the previous operator. If any
    of these conditions are satisfied, we pop the operators until the conditions fail,
    append them to the `postfix` output string, and then add the current operator
    to the operators' stack for the next iteration.
  prefs: []
  type: TYPE_NORMAL
- en: The reason why we do a strict check for a right to left but not for a left to
    right `associativity` is that we have multiple operators of that `associativity`
    with the same `priority`.
  prefs: []
  type: TYPE_NORMAL
- en: After this, if any other operators are remaining, we then add them to the `postfix`
    output string.
  prefs: []
  type: TYPE_NORMAL
- en: Converting infix to postfix expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Putting together all the code discussed above, the final code for converting
    the infix expression to `postfix` looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: This converts the infix operator provided into the `postfix` notation.
  prefs: []
  type: TYPE_NORMAL
- en: Evaluating postfix expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'From here on, executing this `postfix` notation is fairly easy. The algorithm
    is relatively straightforward; you pop out each of the operators onto a final
    result stack*. *If the operator is one of `*`*,* `^`*,* `+`*,* `-`*,* `/`*,* then
    evaluate it accordingly; otherwise, keep appending it to the output string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Here, we use some helper methods such as `getParseMethod()`to determine whether
    we are dealing with an integer or float so that we do not round any number unnecessarily.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we need to do is to instruct our worker to return the data result
    that it has just calculated. This is done in the same way as the error message
    that we return, so our `init()` method changes as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There we have it, real-world web examples using stacks*. *The important thing
    to note in both examples is that the majority of the logic as expected does not
    revolve around the data structure itself. It is a supplementary component, that
    greatly simplifies access and protects your data from unintentional code smells
    and bugs.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we covered the basics of why we need a specific stack data
    structure instead of in-built arrays, simplifying our code using the said data
    structure, and noted the applications of the data structure. This is just the
    exciting beginning, and there is a lot more to come.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore the **queues** data structure along the
    same lines and analyze some additional performance metrics to check whether it's
    worth the hassle to build and/or use custom data structures.
  prefs: []
  type: TYPE_NORMAL
