- en: RTC Drivers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Real Time Clock** (**RTC** ) are devices used to tracks absolute time in
    nonvolatile memory, which may be internal to the processor, or externally connected
    through the I2C or SPI bus.'
  prefs: []
  type: TYPE_NORMAL
- en: 'One may use an RTC to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Read and set the absolute clock, and generate interrupts during clock updates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generate periodic interrupts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set alarms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'RTCs and the system clock have different purposes. The former is a hardware
    clock that maintains absolute time and date in a nonvolatile manner, whereas the
    last is a software clock maintained by the kernel and used to implement the `gettimeofday(2)`
    and `time(2)` system calls, as well as setting timestamps on files, and so on.
    The system clock reports seconds and microseconds from a start point, defined
    to be the POSIX epoch: `1970-01-01 00:00:00 +0000 (UTC)` .'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing RTC framework API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Describing such driver's architecture, along with a dummy driver example
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dealing with alarms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing RTC devices from user space, either through the sysfs interface, or
    using the hwclock tool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RTC framework data structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are three main data structures used by the RTC framework on Linux systems.
    They are `strcut rtc_time` , `struct rtc_device` , and `struct rtc_class_ops`
    structures. The former is an opaque structure that represents a given date and
    time; the second structure represents the physical RTC device; and the last one
    represents a set of operations exposed by the driver and used by the RTC core
    to read/update a device's date/time/alarm.
  prefs: []
  type: TYPE_NORMAL
- en: 'The only header needed to pull RTC functions from within your driver is :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The same file contains all of the three structures enumerated in the preceding
    section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This structure is similar to the `struct tm` in `<time.h>` , used to pass time.
    The next structure is `struct rtc_device,` which represent the chip in the kernel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are the meanings of the elements of the structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dev` : This is the device structure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`owner` : This is the module that owns this RTC device. Using `THIS_MODULE`
    will be enough.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`id` : This is the global index given to the RTC device by the kernel `/dev/rtc<id>`
    .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`name` : This is the name given to the RTC device.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ops` : This is a set of operations (like read/set time/alarm) exposed by this
    RTC device to be managed by the core or from user space.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ops_lock` : This is a mutex used internally by the kernel to protect ops functions
    call.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cdev` : This is the char device associated to this RTC, `/dev/rtc<id>` .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The next important structure is `struct rtc_class_ops` , which is a set of
    functions used as callback to perform standard and limited on the RTC device.
    It is the communication interface between top-layer and bottom-layer RTC drivers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: All of the hooks in the preceding code are given a `struct device` structure
    as parameter, which is the same as the one embedded in the `struct rtc_device`
    structure. This means that from within these hooks, one can access the RTC device
    itself at any given time, using the `to_rtc_device()` macro, which is built on
    top of the `container_of()` macro.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `open()` , `release()` , and `read_callback()` hooks are internally called
    by the kernel when the `open()` , `close()` , or `read()` functions are called
    on the device from user space.
  prefs: []
  type: TYPE_NORMAL
- en: '`read_time()` is a driver function that reads the time from the device and
    fills the `struct rtc_time` output argument. This function should return `0` on
    success, or else the negative error code.'
  prefs: []
  type: TYPE_NORMAL
- en: '`set_time()` is a driver function that updates the device''s time according
    to the `struct rtc_time` structure given as the input parameter. Return parameter''s
    remarks are the same as the `read_time` function.'
  prefs: []
  type: TYPE_NORMAL
- en: If your device supports an alarm feature, `read_alarm()` and `set_alarm()` should
    be provided by the driver to read/set the alarm on the device. The `struct rtc_wkalrm`
    will be described later in the chapter. `alarm_irq_enable()` should be provided
    too, to enable the alarm.
  prefs: []
  type: TYPE_NORMAL
- en: RTC API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An RTC device is represented in the kernel as an instance of the `struct rtc_device`
    structure. Unlike other kernel framework devices registrations(where the device
    is given as parameter to the registering function), the RTC device is built by
    the core, and registered first before the `rtc_device` structure gets returned
    to the driver. The device is built and registered with the kernel using the `rtc_device_register()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'One can see the meaning of each parameter of the functions, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`name` : This is your RTC device name. It could be the chip''s name, for example:
    ds1343.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dev` : This is the parent device, used for device model purposes. For chips
    sitting on I2C or SPI buses, for example, `dev` could be set with `spi_device.dev`
    , or `i2c_client.dev` .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ops` : This is your RTC ops, filled according to the features the RTC has,
    or those your driver can support.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`owner` : This is the module to which this RTC device belongs. In most cases,
    `THIS_MODULE` is enough.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The registration should be performed in the `probe` function, and obviously,
    one can use the resource-managed version of this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Both functions return a pointer on a `struct rtc_device` structure built by
    the kernel on success, or a pointer error on which you should use `IS_ERR` and
    `PTR_ERR` macros.
  prefs: []
  type: TYPE_NORMAL
- en: 'Associated reverse operations are `rtc_device_unregister()` and `devm_ rtc_device_unregister()`
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Reading and setting time
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The driver is responsible for providing functions to read and set the device's
    time. These are the least an RTC driver can provide. When it comes to reading,
    the read callback function is given a pointer to an allocated/zeroed `struct rtc_time`
    structure, which the driver has to fill. Therefore, RTCs almost always store/restitute
    time in **Binary Coded Decimal** (**BCD** ), where each quartet (series of 4 bits)
    represents a number between 0 and 9 (rather than between 0 and 15). The kernel
    provides two macros, `bcd2bin()` and `bin2bcd()` , to convert respectively from
    BCD-encoding to decimal, or from decimal to BCD. The next things you should pay
    attention to are some `rtc_time` fields, which have some boundaries requirements,
    and where some translation must be done. Data is read in BCD from the device,
    and should be converted using `bcd2bin()` .
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the `struct rtc_time` structure is complex, the kernel provides the `rtc_valid_tm()`
    helper, in order to validate a given `rtc_time` structure, and which returns `0`
    on success, meaning the structure represents a valid date/time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The following sample describes an RTC-read operation callback:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The following header is necessary prior to using BCD-conversion functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'When it comes to the `set_time` function, a pointer to a `struct rtc_time`
    is given as an input parameter. This parameter is already filled with values to
    be stored in the RTC chip. Unfortunately, these are decimal-encoded, and should
    be converted into BCD prior to being sent to the chip. `bin2bcd` does the conversion.
    The same attention should be paid to some fields of the `struct rtc_time` structure.
    The following is a pseudo-code describing a generic `set_time` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: RTC's epoch differs from the POSIX epoch, which is only used for the system
    clock. If the year according to the RTC's epoch and the year register is less
    than 1970, it is assumed to be 100 years later, that is, between 2000 and 2069.
  prefs: []
  type: TYPE_NORMAL
- en: Driver example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One can summarize the preceding concepts in a simple and fake driver, which
    simply registers an RTC device on the system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Playing with alarms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'RTC alarms are programmable events to be triggered by the device at a given
    time. An RTC alarm is represented as an instance of the `struct rtc_wkalarm` structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The driver should provide `set_alarm()` and `read_alarm()` operations, to set
    and read time at which the alarm should occur, as well as `alarm_irq_enable()`
    , which is a function used to enable/disable the alarm. When the `set_alarm()`
    function is invoked, it is given as an input parameter, a pointer to a `struct
    rtc_wkalrm` , whose `.time` field contains the time the alarm must be set to.
    It is up to the driver to extract each value in a correct manner (using `bin2dcb()`
    if necessary), and write it into the device in appropriate registers. `rtc_wkalrm.enabled`
    tell if the alarm should be enabled right after it has been set. If true, the
    driver must enable the alarm in the chip. The same is true for `read_alarm()`
    that is given a pointer to `struct rtc_wkalrm` , but as an output parameter this
    time. The driver has to fill the structure with data read from the device.
  prefs: []
  type: TYPE_NORMAL
- en: '`{read | set}_alarm()` and `{read | set}_time()` functions behave the same
    way, except that each pair of functions reads/stores data from/into different
    sets of registers in the device.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Prior to report alarm event to the system, it is mandatory to connect the RTC
    chip to an IRQ line of the SoC. It relies on INT line of the RTC driven low when
    the alarm occur. Depending on the manufacturer, the line remains low until a status
    register get read, or a special bit get cleared:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Image00037.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At this point we can use a generic IRQ API, such as `request_threaded_irq()`
    , in order to register the alarm IRQ''s handler. From within the IRQ handler,
    it is important to inform the kernel about the RTC IRQ event, using the `rtc_update_irq()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '`rtc` : This is the rtc device that raised the IRQ'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`num` : This shows how many IRQs are being reported (usually one)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`events` : This is a mask of `RTC_IRQF` with one or more of `RTC_PF` , `RTC_AF`
    , `RTC_UF`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'That function can be called from any context, atomic or not. The IRQ handler
    could look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Keep in mind that RTC devices that have the alarm feature can be used as a
    wake-up source. That said, the system can be woken up from suspend mode whenever
    the alarm triggers. This feature relies on the interrupt raised by the RTC device.
    One declares a device as being wake-up source using the `device_init_wakeup()`
    function. The IRQ that actually wakes the system up must be registered with the
    power management core too, using the `dev_pm_set_wake_irq()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We will not discuss power management in detail in this book. The idea is just
    to give you an overview of how RTC devices may improve your system. The driver
    `drivers/rtc/rtc-ds1343.c` may help to implement such functions. Let us put everything
    together by writing a fake `probe` function for an SPI foo RTC device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: RTCs and user space
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: On Linux systems, there are two kernel options one needs to care about in order
    to properly manage RTCs from user space. These are `CONFIG_RTC_HCTOSYS` and `CONFIG_RTC_HCTOSYS_DEVICE`
    .
  prefs: []
  type: TYPE_NORMAL
- en: '`CONFIG_RTC_HCTOSYS` includes the code file `drivers/rtc/hctosys.c` in kernel
    build process, which sets system time from the RTC on startup and resume. Once
    this option is enabled, the system time will be set using the value read from
    the specified RTC device. RTC devices should be specified in `CONFIG_RTC_HCTOSYS_DEVICE`
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we tell the kernel to set the system time from the
    RTC, and we specify that the RTC to use is `rtc0` .
  prefs: []
  type: TYPE_NORMAL
- en: The sysfs interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The kernel code responsible for instantiating RTC attributes in sysfs is defined
    in `drivers/rtc/rtc-sysfs.c` , in the kernel source tree. Once registered, an
    RTC device will create a `rtc<id>` directory under `/sys/class/rtc` . That directory
    contains a set of read-only attributes, among which the most important are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`date` : This file prints the current date of the RTC interface:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '`time` : This prints the current time of this RTC:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '`hctosys` : This attribute indicates whether the RTC device is the one specified
    in `CONFIG_RTC_HCTOSYS_DEVICE` , meaning that this RTC is used to set system time
    on startup and resume. Read `1` as true, and `0` as false:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '`dev` : This attribute shows the device''s major and minor. Read as major:minor:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '`since_epoch` : This attribute will print the number of seconds elapsed since
    the UNIX epoch (since January 1rst 1970):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The hwclock utility
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Hardware clock** (**hwclock** ) is a tool used to access RTC devices. The
    `man hwclock` command will probably be much more meaningful than everything discussed
    in this section. That said, let us write some commands, to set hwclock RTC from
    the system clock:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding example assumes the host has a network connection on which it
    can access an NTP server. It is also possible to set the system time manually:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'If not given as argument, `hwclock` assumes the RTC device file is `/dev/rtc`
    , which is actually a symbolic link to the real RTC device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter introduced you to the RTC framework and its API. Its reduced set
    of functions and data structures make it the most lightweight framework, and easy
    to master. Using skills described in this chapter, you will be able to develop
    a driver for most of the existing RTC chips, and even go further and handle such
    devices from the user space, easily setting up date and time, as well as alarms.
    The next chapter, PWM drivers, has nothing common with this one, but is a must-know
    for embedded engineers.
  prefs: []
  type: TYPE_NORMAL
