- en: Chapter 9. Avoiding the Roadblocks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up to this point in the book, we have covered many of the new and exciting aspects
    of web development with HTML5\. However, during this time we have only ever looked
    at each feature as an individual aspect rather than a piece of a larger project.
    When it comes to building applications for the real world, you will inevitably
    have to begin merging these new features together to build the appropriate feature
    set within your app. In this chapter, we will build a playable game using some
    of the new and old features available to you as a web developer. Beginning with
    a version built-in Flash, we will then build a direct port of the application
    into HTML5 and discuss the differences and issues you may encounter while dealing
    with assets and functionality that you have become used to in the ActionScript
    and Flash world of development.
  prefs: []
  type: TYPE_NORMAL
- en: The Jet Pack game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The application we will build is a simple 2D, side scrolling game with simplistic
    controls that can easily be converted to touch event for mobile devices. To keep
    things easy to explain and understand, I have modeled this game after the popular
    Helicopter Game ([http://www.helicopter-game.org/](http://www.helicopter-game.org/))
    that has been played all over the Internet for many years.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the Helicopter Game:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Jet Pack game](img/3325OT_09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Although there are already many versions of this game on the Internet, the most
    popular ones are written in Flash, cutting out many users on mobile and desktop
    browsers from playing it. The gameplay and controls are extremely simplistic and
    only require the player to use a single key on their keyboard or use their mouse
    to click instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rather than attempt to directly copy this popular game, we will use it as a
    starting point for gameplay design. To add our own personal touch to the game,
    we will switch the helicopter character to a little man with a jet pack. Before
    we get started, take a look at the following screenshot of the game in action
    to get a better idea of what our end result will look like. Of course you can
    always play the game yourself by checking out the Flash and HTML versions of this
    application located with the example files for this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Jet Pack game](img/3325OT_09_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You play this game as the character, the Jet Pack man, displayed on the left
    of the previous screenshot. Your goal is to control the character's altitude by
    activating his jetpack. As your character travels deeper into the cave system,
    not only will the cave become increasingly tighter, but there will be randomly
    placed obstacles which you will need to pilot yourself around. Gravity plays an
    important role as well since when your jetpack is not activated, your player will
    begin falling back down to the ground. The level objects are dynamically generated
    in real time as the player travels deeper into the cave and constrained to tighter
    positions as the difficulty increases. During every interval of the game source
    code, each section of the level is checked for collision with the player to determine
    if the game is over or not. Each interval of the game also increases the player's
    current score, so the deeper into the cave you travel, the higher your score will
    be. High scores are tracked within the game instance and displayed within the
    UI to allow the player to easily see what the next attempt's goal will be.
  prefs: []
  type: TYPE_NORMAL
- en: As I mentioned before, we will initially look at this game's source code written
    in ActionScript 3 to get an understanding of how I have written it. Of course
    this comes with the disclaimer that although some aspects of this games code may
    work for you in other projects, the source code for this game has been set up
    to aid in our learning and understanding of ActionScript 3 to HTML5 conversions.
    This game has not been optimized to the point it should be for public release
    and I will do my best during this chapter to point out what some of these short
    comings are. With all of this in mind, let's jump right into the source structure
    of the Flash version of this Jet Pack game.
  prefs: []
  type: TYPE_NORMAL
- en: Building the game in Flash
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To keep things easy to understand we will keep the line and file count to a
    minimum for this game. We will begin with the base class for our ActionScript
    project named `Game`. Check out the following condensed base class example to
    get an idea of the game''s code structure. You can always look at the full version
    in the downloadable chapter example files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This single class manages to take care of the majority of the gameplay and user
    interactions. The game is constantly updated based on the current difficulty factor
    set within the game. As the game progresses, the difficulty is translated into
    scrolling speed as each asset within the level is updated and set to change its
    x position value in larger amounts. Although there are two more classes to support
    the creation of the Player as well as all of the LevelBlock, I will leave that
    to you to dig into.
  prefs: []
  type: TYPE_NORMAL
- en: Converting game assets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To start preparing this game to be ported to HTML5, we will begin with the
    assets used within the game, converting and preparing each of them for the web.
    To create the user interface and player object within this game, I have created
    and published a Flash SWC which is included into this ActionScript project in
    Flash Builder. The assets within the SWC contain not only the objects and animations
    used in the game, but the sounds as well as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Converting game assets](img/3325OT_09_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see in the previous screenshot, my crudely hand drawn Jet Pack man
    has a timeline based key frame animation sequence attached to him to allow him
    to visually turn on and off his jetpack as well as explode when he impacts any
    wall. This timeline animation has some simple ActionScript appended to some of
    the frames which allow for easy stopping and looping for the animation sequence.
  prefs: []
  type: TYPE_NORMAL
- en: 'To convert the Player MovieClip into an HTML5 ready asset, we will use the
    Sprite Sheet Generator tool we discussed in previous chapters as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Converting game assets](img/3325OT_09_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After condensing the image into the smallest layout possible and optimizing
    the output properties in the **Generate Sprite Sheet** window, set the **Data
    format** property to **JSON** and export the data. The compiled Sprite Sheet as
    well as the **JSON** file will be used to replicate the Player's animation from
    our HTML5 conversion. Once we have prepped the Player Sprite Sheet, we can put
    it aside for the time being while we convert the remainder of the assets.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's move on to preparing the audio used within the game. The audio assets
    within the Flash SWF can easily be prepared for HTML5 by simply locating the source
    MP3 files and placing them within the HTML5 game project directory. Since the
    MP3 files are supported for use within HTML5 under the `<audio>` element, no further
    preparation will be needed in order to get the audio ready for our conversion.
    The tricky part with HTML5 audio only comes when you need to deal with it in the
    code, which we will get into shortly.
  prefs: []
  type: TYPE_NORMAL
- en: Without the use of the Flash Timeline or any other HTML5 sprite sheet library,
    we will have to import and manipulate the Sprite Sheet data of our Player completely
    on our own. Handy calls like `gotoAndPlay();` and `stop();` do not exist in JavaScript,
    so we will need to recreate that functionality on our own. This may sound like
    a monumental task, but rest assured, Sprite Sheets images and datasets contain
    all of the necessary information required for you to display them properly. All
    you need is to understand the data format and the properties that need referencing.
    Since Sprite Sheets are broken up into frames, the concept of playback control
    via numerical frame referencing should be extremely familiar to you. The frames
    that have been exported within the Sprite Sheet dataset will directly correspond
    to the numerical value of the frames within the source MovieClip in Flash. However,
    since the frame data in the **JSON** file is in an array, we will encounter an
    `off by one` error if we don't compensate for the fact numerical array keys start
    at 0 and not 1\. Again, it's worth mentioning that this method of displaying the
    Sprite Sheet is just one of thousands of implementations of Sprite Sheets in HTML5\.
    Many developers have created their own open source projects to alleviate much
    of the stress of having to do this yourself within every one of your projects.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are a ton of great open source resources on the web that can aid in Sprite
    Sheet integration into your HTML5 project. One library worth checking out is [http://www.spritely.net](http://www.spritely.net),
    a fully HTML5 and jQuery based Sprite Sheet library.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the condensed version of the converted `JetPackMan` class which
    is shown in the following JavaScript. This will give you a much clearer idea of
    frame control for this Sprite Sheet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This method of graphic manipulation, though similar to the concepts used in
    the Flash Timeline, differ in that we are using 100 percent bitmap data which
    requires us to manually redraw the visible area of the Sprite Sheet on each frame
    interval. During each update interval to the animation sequence, we utilize the
    built in `drawImage();` method to append the updated frame location to the HTML
    `<canvas>` element. This means that if the pre-existing visible data that had
    been drawn to the canvas in the previous frame is not manually removed from the
    canvas, the next `drawImage();` call will just append the new frames graphics
    over top of the old. To avoid this issue we call another built in method, `clearRect();`,
    with the position values of where the pre-existing graphic was located. This may
    understandably sound confusing, however there is a very easy way to visualize
    this Sprite Sheet manipulation in action. If you open the HTML5 version of the
    Jet Pack game included within this chapter's example files and comment out the
    `clearRect();` within the `runAnimation` function, you can now play the game and
    see what the Player element will look like during runtime. As time passes and
    more frames are displayed on top of each other, it can quickly become a mess of
    layered images that will never get updated. As annoying as this is, it does serve
    a great purpose as it could be utilized for some very interesting visualizations.
    However, since we only want one character in our game at a time we must be sure
    to clean up the canvas display on each interval.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although it is avoided in this example, another important note worth making
    about integrating this Sprite Sheet is the issues you may encounter while attempting
    to import the **JSON** dataset containing the Sprite Sheet frame properties as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If used for external data loading, the popular jQuery `getJSON` method ([http://api.jquery.com/jQuery.getJSON/](http://api.jquery.com/jQuery.getJSON/))
    will attempt an AJAX request to the external data source in order to read the
    data and pass it back into the return method. However if you are executing the
    JavaScript from your local machine without the use of a web server, your browser
    will not accept the request and display a warning that looks something like the
    following console screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Converting game assets](img/3325OT_09_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: One way of fixing this issue is by simply publishing your HTML5 project to a
    working web server. From there you can open up the reference to the data from
    the website URL in a browser. You could also setup your own web server on your
    computer to have the ability to connect to `http://localhost` in order to view
    your content. Projects like WAMP ([http://www.wampserver.com/en/](http://www.wampserver.com/en/))
    and MAMP ([http://www.mamp.info/en/index.html](http://www.mamp.info/en/index.html))
    are all-in-one packages including the Apache web server, MySQL Server and PHP.
    These server setups, traditionally run on Linux servers, allow you to easily emulate
    the environment that your website will eventually reside on and give you all the
    benefits from the software stack described above.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course the content you run on your local web server will not be public on
    the Internet, so you won''t be able to share it with your friends unless you start
    performing some network configuration (you can search for "port forwarding" on
    Google if you''re interested). The final and probably the more logical way to
    fix this issue when attempting to run this code locally without a web server is
    to strip the data from inside the JSON Sprite Sheet output and append it into
    the JavaScript source which is included in the HTML document of the game as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: By simply appending the JSON object as it is exported from Flash to a standard
    JavaScript variable, we can now call the `JetPackManData` variable rather than
    a jQuery `getJSON()` call allowing us to run this game locally with no further
    Access Control issues.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Mozilla Developer Network has a great resource for more detailed information
    as to why Access Control issues may occur ([https://developer.mozilla.org/en-US/docs/HTTP/Access_control_CORS](https://developer.mozilla.org/en-US/docs/HTTP/Access_control_CORS)).
  prefs: []
  type: TYPE_NORMAL
- en: Another issue you may encounter, depending on the browser size you use to play
    this game on, is browser page scrolling or other unwanted actions when the user
    is attempting to control the player within the game.
  prefs: []
  type: TYPE_NORMAL
- en: Converting ActionScript classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since you have already got a glimpse of the converted game source by checking
    out the `Player` class which has been modified to deal with Sprite Sheets rather
    than the Flash Timeline, let's continue down that road by looking at how we can
    set up the base class of the application in HTML5\. To aid in a couple of event
    listeners and element selection, I have included the jQuery library within this
    project. I have already made note of this controversial decision in the previous
    chapters of this book, but it is worth noting again that many developers dislike
    the usage of jQuery simply for use with element selection. Since the game we are
    currently converting to HTML5 is extremely simplistic, there really is no need
    for jQuery within this example. However, if you were to take this simple game
    source and extend it into a more developed game with rich UI and better game play,
    the use of a library like jQuery will easily become extremely valid.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following source is a simplified copy of the `Game.js` file which is included
    within the HTML5 version of this game. I have simplified the code and further
    added commented documentation to aid in understanding how the flow of this game
    source operates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In print, this may seem like a ton of code but in reality this is a very simplistic
    example of a 2D game built in JavaScript. Be sure to read over the comments included
    in the code which highlight what each part of the code accomplishes and how it
    is laid out. When all is said and done and the main `index.html` file is opened
    up in a HTML5 compliant web browser, you will hopefully see the resulting Jet
    Pack game in 100 percent HTML5 as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Converting ActionScript classes](img/3325OT_09_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Notice that we have even managed to get a statistics readout at the top right
    corner of the game area just like in our Flash version. Just like how we reviewed
    in [Chapter 7](ch07.html "Chapter 7. Choosing How You Develop"), *Choosing How
    You Develop*, we utilize the stats display made possible by the same developer
    (Ricardo Cabello Miguel also known as Mr. Doob) who provided us with the stats
    display we used in Flash. Checkout the GitHub page for `Stats.js` ([https://github.com/mrdoob/stats.js/](https://github.com/mrdoob/stats.js/))
    to learn more about the project.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with audio and playback
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using the knowledge we have gained during the overview of HTML5 audio file
    type and codec support in this book, we can set up the audio for this game pretty
    easily. Rather than using the SWC importing method that was used in our Flash
    project, when importing audio into an HTML5 project, we can just append the reference
    to the source directly into the body of the HTML document inside of a `<audio>`
    element as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'By default the audio will not play and because we excluded the option to create
    playback controls, there will be no visible element created within the HTML document
    during page render. Therefore to begin utilizing the audio in JavaScript, which
    will allow us to play it on-demand, we begin by referencing the element that was
    appended into the HTML document as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'With the audio file referenced, we can easily begin to control the playback
    by calling the `play()` method on the `_jetPackSound` variable. However, to avoid
    overlapping the same audio track multiple times during the game play, we can also
    append an event listener to the element to be called when the sound playback has
    completed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: By creating the event handler for this listener, we can also update the `_soundPlaying`
    Boolean variable located in the `JetPackMan` class. From this point forward, we
    can now easily determine if the sound effect is playing or not from anywhere within
    the `JetPackMan` object.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can find some more detailed information on HTML5 audio and video playback
    control in JavaScript on the Mozilla Developer Network website [https://developer.mozilla.org/en-US/docs/HTML/Using_HTML5_audio_and_video](https://developer.mozilla.org/en-US/docs/HTML/Using_HTML5_audio_and_video).
  prefs: []
  type: TYPE_NORMAL
- en: Rewriting AS3 code that can't be directly converted
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As I mentioned in one of the previous code examples earlier, the lack of the
    commonly used `hitTestObject()` method from ActionScript 3 in any HTML5 project
    means that many of these common yet complex pieces of functionality need to be
    written yourself. In the example Jet Pack game in HTML5, we use one of the more
    simplistic methods of collision detection by checking over the Players bounding
    box or the area that the Player takes up and compare it with each one of the LevelBlocks
    that has been generated. This condition, when simplified, looks something like
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: One of the tricky aspects of implementing a functionality like collision detection
    is that with the advent of the Canvas element in HTML5, there are multiple ways
    to create and manipulate elements within your HTML document. Flash applications
    have the advantage of utilizing some great built-in functionality because the
    development structure is far more structured. When developing HTML5 applications
    that are heavily dependent on JavaScript, the development flow becomes a little
    more of a wild west setting.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When digging around to see how other developers may have implemented a feature
    like collision detection, a great resource as always is Github. The Github project
    search allows you to narrow your searches down to a specific programming language
    making it that much easier to find an open source project that may help you out
    ([https://github.com/search?l=JavaScript&q=Collision+Detection&ref=cmdform&type=Repositories](https://github.com/search?l=JavaScript&q=Collision     +Detection&ref=cmdform&type=Repositories)).'
  prefs: []
  type: TYPE_NORMAL
- en: Mobile platform support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since we now have an HTML5 ready version of our game, one of the initial benefits
    that we can consider is the fact that most mobile device browsers will support
    the playback of this application. However, because we have set up the game specifically
    to be controlled via the user''s keyboard, we have not created a control method
    for users that don''t have access to one. Correcting this issue in the case of
    our Jet Pack game is actually pretty easy since our control system only uses one
    input. In reality, we have two options as to how we implement this feature as
    almost every mobile browser that supports touch events registers them as click
    events as well. This means that we can either implement the same keyboard event
    listener as a specific touch event or as a common mouse click event. The upside
    of setting the mouse event over the touch event is that the mouse event will also
    register for any user who happens to play the game on a device with a mouse as
    well. Using only default JavaScript syntax we can accomplish this with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, since we don''t condition the key press in the `onKeyDown`
    or `onKeyUp` methods, we can simply tie the mouse event to the same event handler
    and call it a day. Depending on whether you have rather used touch events instead
    of mouse events, we would only have to modify the event parameter within the `addEventListener`
    call as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Mozilla Developer Network also contains a detailed outline of what Touch
    Events and the properties within are available to you when developing the touch-enabled
    HTML5 applications ([https://developer.mozilla.org/en-US/docs/DOM/Touch_events](https://developer.mozilla.org/en-US/docs/DOM/Touch_events)).
    Although this is a Mozilla site, most of the documentation is cross browser compliant.
  prefs: []
  type: TYPE_NORMAL
- en: 'Probably one of the most troubling aspects of testing this game on a mobile
    device is the fact that the canvas element utilized to display the game elements
    has a static width and height. The width and height I chose to originally create
    the game are 1000px by 600px. These dimensions may render properly on some mobile
    devices, but the chances are if you were to play this on a phone, some area of
    the canvas will either be cut off from display, or presented in a manner that
    scales the canvas to fit the screen as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Mobile platform support](img/3325OT_09_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The previous screenshot is taken directly from a Samsung Galaxy S2 and clearly
    shows how the game is cut off from the default view in the landscape display.
    Zooming in and out of the page is still available as an interactive browser feature,
    but even when zoomed out when the game is in landscape display, I am unable to
    view the entire viewable game area. Now check out the next screenshot taken on
    the same phone of the game in portrait display:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Mobile platform support](img/3325OT_09_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now with the page view completely zoomed out, we can see the entire game area
    but the bottom half of the viewable area is wasted as the game is set up to display
    in a 1000px x 600px display. This issue, though painful to deal with, is actually
    very common to many Flash developers. If you have developed any web applications
    in Flash that require a scalable display, you would have had to write event listeners
    in your application to watch for window resizing and move the position of the
    elements within your application accordingly. You can update the canvas size from
    JavaScript easily with calls to your elements width and height properties with
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This setup covers all of your bases by updating the CSS style of the element
    as well as the base element width and height values. Of course, with this update
    you will also have to manually update the position values for all of the playable
    elements that are being displayed in this game. If you wish to continue digging
    more into the source of this game, I advise either attempting to extend the gameplay
    or working with the Canvas element resizing for dynamic window display sizes.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By using an application originally built in Flash, in this chapter we have covered
    some more interesting aspects of HTML5 development. By developing the HTML5 Version
    of our game without the use of any third party JavaScript libraries, we can easily
    compare the two development paradigms. In reality, Flash and HTML5 development
    are extremely similar. Asset preparation and manipulation stands out as one of
    the most complicated aspects of transitioning your ActionScript and Flash development
    experience over to HTML5 development. Understanding your limitations, regardless
    of whether they are browser or device specific is a key factor in making sure
    you're ready to display your content to as many users as possible.
  prefs: []
  type: TYPE_NORMAL
- en: In the next and final chapter of the book, we will continue putting together
    working HTML5 applications with more emphasis on preparation for public release.
    We will attempt to push the limits of what HTML5 can do with peripherals like
    the webcams and microphones, and discuss what your next steps in HTML5 development
    could be once you have finished this book.
  prefs: []
  type: TYPE_NORMAL
