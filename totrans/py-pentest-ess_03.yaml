- en: Sniffing and Penetration Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When I was pursuing my Master of engineering (M.E) degree, I used to sniff the
    networks in my friends' hostel with my favorite tool, *Cain and Abel*. My friends
    would usually surf e-commerce websites. The next day, when I told them that the
    shoes they were shopping for were good, they would be amazed. They always wondered
    how I got this information. Well, this is all due to sniffing the network.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will study sniffing a network, and will cover the following
    topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The concept of a sniffer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The types of network sniffing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Network sniffing using Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Packet crafting using Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ARP spoofing concept and implementation by Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing security by custom-packet crafting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing a network sniffer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sniffing is a process of monitoring and capturing all data packets that pass
    through a given network using software (an application) or a hardware device.
    Sniffing is usually done by a network administrator. However, an attacker might
    use a sniffer to capture data, and this data, at times, might contain sensitive
    information, such as a username and password. Network admins use a switch `SPAN`
    port. The switch sends one copy of the traffic to the `SPAN` port. The admin uses
    this `SPAN` port to analyze the traffic. If you are a hacker, you must have used
    the *Wireshark* tool. Sniffing can only be done within a subnet. In this chapter,
    we will learn about sniffing using Python. However, before this, we need to know
    that there are two sniffing methods. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Passive sniffing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Active sniffing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passive sniffing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Passive sniffing refers to sniffing from a hub-based network. By placing a packet
    sniffer on a network in the promiscuous mode, a hacker can capture the packets
    within a subnet.
  prefs: []
  type: TYPE_NORMAL
- en: Active sniffing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This type of sniffing is conducted on a switch-based network. A switch is smarter
    than a hub. It sends packets to the computer after checking in a MAC table. Active
    sniffing is carried out by using ARP spoofing, which will be explained further
    in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a network sniffer using Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before learning about the implementation of a network sniffer, let''s learn
    about a particular `struct` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '`struct.pack(fmt, v1, v2, ...)`: This method returns a string that contains
    the values `v1`, `v2`, and so on, packed according to the given format'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`struct.unpack(fmt, string)`: This method unpacks the string according to the
    given format'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s discuss the code in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The output for the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: First, import the `struct` module, and then pack the `1`, `2`, and `3` integers
    in the `hhl` format. The packed values are like machine code. Values are unpacked
    using the same `hhl` format; here, `h` means a short integer and `l` means a long
    integer. More details are provided in the subsequent sections.
  prefs: []
  type: TYPE_NORMAL
- en: Consider the situation of the client-server model; let's illustrate it by means
    of an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the `struct1.py`. file. The server-side code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The entire code is the same as we saw previously, with `msz= struct.pack('hhl',
    1, 2, 3)` packing the message and `conn.send(msz)` sending the message.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the `unstruc.py` file. The client-side code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The client-side code accepts the message and unpacks it in the given format.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output for the client-side code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The output for the server-side code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now, you should have a decent idea of how to pack and unpack the data.
  prefs: []
  type: TYPE_NORMAL
- en: Format characters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have seen the format in the pack and unpack methods. In the following table,
    we have **C-type** and **Python-type** columns. It denotes the conversion between
    C and Python types. The **Standard size** column refers to the size of the packed
    value in bytes:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Format** | **C type** | **Python type** | **Standard size** |'
  prefs: []
  type: TYPE_TB
- en: '| x | pad byte | no value |  |'
  prefs: []
  type: TYPE_TB
- en: '| c | char | string of length 1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| b | signed char | integer | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| B | unsigned char | integer | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| ? | _Bool | bool | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| h | short | integer | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| H | unsigned short | integer | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| i | int | integer | 4 |'
  prefs: []
  type: TYPE_TB
- en: '| I | unsigned int | integer | 4 |'
  prefs: []
  type: TYPE_TB
- en: '| l | long | integer | 4 |'
  prefs: []
  type: TYPE_TB
- en: '| L | unsigned long | integer | 4 |'
  prefs: []
  type: TYPE_TB
- en: '| q | long long | integer | 8 |'
  prefs: []
  type: TYPE_TB
- en: '| Q | unsigned long long | integer | 8 |'
  prefs: []
  type: TYPE_TB
- en: '| f | float | float | 4 |'
  prefs: []
  type: TYPE_TB
- en: '| d | double | float | 8 |'
  prefs: []
  type: TYPE_TB
- en: '| s | char[] | string |  |'
  prefs: []
  type: TYPE_TB
- en: '| p | char[] | string |  |'
  prefs: []
  type: TYPE_TB
- en: '| P | void * | integer |  |'
  prefs: []
  type: TYPE_TB
- en: 'Let''s check what will happen when one value is packed in different formats:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We packed the number `2` in three different formats. From the preceding table,
    we know that *b* and *B* are one byte each, which means that they are the same
    size. However, `*h*` is two bytes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s use the long `int`, which is eight bytes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If we work on a network, `!` should be used in the following format. `!` is
    used to avoid the confusion of whether network bytes are little-endian or big-endian.
    For more information on big-endian and little-endian, you can refer to the Wikipedia
    page on Endianness:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: You can see the difference when using `!` in the format.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before proceeding to sniffing, you should be aware of the following definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**PF_PACKET**: It operates at the device-driver layer. The `pcap` library for
    Linux uses `PF_PACKET` sockets. To run this, you must be logged in as a root.
    If you want to send and receive messages at the most basic level, below the internet
    protocol layer, then you need to use `PF_PACKET`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Raw socket**: It does not care about the network layer stack and provides
    a shortcut to send and receive packets directly with the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following socket methods are used for byte-order conversion:'
  prefs: []
  type: TYPE_NORMAL
- en: '`socket.ntohl(x)`: This is the network to host long. It converts a 32-bit positive
    integer from the network to host the byte order.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`socket.ntohs(x)`: This is the network to host short. It converts a 16-bit
    positive integer from the network to host the byte order.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`socket.htonl(x)`: This is the host to network long. It converts a 32-bit positive
    integer from the host to the network byte order.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`socket.htons(x)`: This is the host to network short. It converts a 16-bit
    positive integer from the host to the network byte order.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, what is the significance of the preceding four methods?
  prefs: []
  type: TYPE_NORMAL
- en: Consider a 16-bit number, 0000000000000011\. When you send this number from
    one computer to another, its order might get changed. The receiving computer might
    receive it in another form, such as 1100000000000000\. These methods convert from
    your native byte order to the network byte order and back again. Now, let's look
    at the code to implement a network sniffer, which will work on three layers of
    the TCP/IP, that is, the physical layer (Ethernet), the network layer (IP), and
    the TCP layer (port).
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we look at the code, you should know about the headers of all three
    layers:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The physical layer**: This layer deals with the Ethernet frame, as shown
    in the following image:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/8b41b288-afb2-42e6-9ee1-66278654c99c.png)'
  prefs: []
  type: TYPE_IMG
- en: The structure of the Ethernet frame IEEE 802.3
  prefs: []
  type: TYPE_NORMAL
- en: 'The explanation for the preceding diagram is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The **Preamble** consists of seven bytes, all of the form 10101010, and is used
    by the receiver to allow it to establish bit synchronization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Start frame delimiter** consists of a single byte, 10101011, which is
    a frame flag that indicates the start of a frame
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The destination and source addresses are the Ethernet addresses usually quoted
    as a sequence of six bytes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are interested only in the source address and destination address. The data
    part contains the IP and TCP headers.
  prefs: []
  type: TYPE_NORMAL
- en: One thing that you should always remember is that when the frame comes to our
    program buffer, it does not contain the **Preamble** and **Start frame delimiter**
    fields.
  prefs: []
  type: TYPE_NORMAL
- en: MAC addresses, such as `AA:BB:CC:56:78:45`, contain 12 hexadecimal characters,
    and each byte contains two hexadecimal values. To store MAC addresses, we will
    use six bytes of memory.
  prefs: []
  type: TYPE_NORMAL
- en: '**The network or IP layer**: In this layer, we are interested in the IP address
    of the source and destination.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let''s move on to our IPv4 header, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f167844a-aed1-4d01-836c-ed9d0f5f9fa5.png)'
  prefs: []
  type: TYPE_IMG
- en: The IPv4 header
  prefs: []
  type: TYPE_NORMAL
- en: 'The IPv4 packet header consists of 14 fields, of which only 13 are required.
    The 14th field is optional. This header is 20 bytes long. The last eight bytes
    contain our source IP address and destination IP address. The bytes from 12 to
    16 contain the source IP address, and the bytes from 17 to 20 contain the destination
    IP address:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The TCP header**: In this header, we are interested in the source port and
    the destination port address. If you note the TCP header, you will realize that
    it too is 20 bytes long, and the header''s starting two bytes provide the source
    port and the next two bytes provide the destination port address. You can see
    the TCP header in the following diagram:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/48d8e2b8-f201-4128-84c9-bb60fa6f0a6e.png)'
  prefs: []
  type: TYPE_IMG
- en: The TCP header
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, start the promiscuous mode of the interface card and give the command
    as superuser. So, what is the promiscuous or promisc mode? In computer networking,
    the promiscuous mode allows the network interface card to read packets that arrive
    in its subnet. For example, in a hub environment, when a packet arrives at one
    port, it is copied to the other ports and only the intended user reads that packet.
    However, if other network devices are working in promiscuous mode, that device
    can also read that packet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Check the effect of the preceding command, as shown in the following screenshot,
    by typing the `ifconfig` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/80d8f576-8d9b-4761-8c40-cb4d6486e756.png)'
  prefs: []
  type: TYPE_IMG
- en: Showing the promiscuous mode
  prefs: []
  type: TYPE_NORMAL
- en: The preceding screenshot shows the `eth0` network card and that it is working
    in promiscuous mode.
  prefs: []
  type: TYPE_NORMAL
- en: Some cards cannot be set to the promiscuous mode because of their drivers, kernel
    support, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, it''s time to code. First, let''s look at the following snippet in its
    entirety and then understand it line by line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We have already defined the `socket.PF_PACKET, socket.SOCK_RAW` lines. The
    `socket.htons(0x0800)` syntax shows the protocol of interest. The `0x0800` code
    defines the `ETH_P_IP` protocol. You can find all the code in the `if_ether.h`
    file located in `/usr/include/linux`. The `pkt = s.recvfrom(2048)` statement creates
    a buffer of 2,048\. Incoming frames are stored in the `pkt` variable. If you print
    this `pkt`, it shows the tuples, but our valuable information resides in the first
    tuple. The `ethhead = pkt[0][0:14]` statement takes the first 14 bytes from the
    `pkt`. The Ethernet frame is 14 bytes long, and it comes first, as shown in the
    following diagram, and that''s why we use the first 14 bytes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d6a4895e-4ca3-4853-80b2-058b75a93041.png)'
  prefs: []
  type: TYPE_IMG
- en: Configuration of headers
  prefs: []
  type: TYPE_NORMAL
- en: In the `eth = struct.unpack("!6s6s2s",ethhead)` statement, `!` shows network
    bytes, and `6s` shows six bytes, as we discussed earlier. The `binascii.hexlify(eth[0])`
    statement returns the hexadecimal representation of the binary data. Every byte
    of `eth[0]` is converted into the corresponding two-digit hex representation.
    The `ip_length = (int(num)%10)*4` syntax tells us the size of the IPv4 header.
    The `ipheader = pkt[0][14:ip_last_range]` statement extracts the data between
    the range. Next is the IP header and the `ip_hdr =struct.unpack("!12s4s4s",ipheader)`
    statement, which unpacks the data into three parts, out of which our destination
    and source IP addresses reside in the second and third parts, respectively. The
    `socket.inet_ntoa(ip_hdr[3])` statement converts a 32-bit packed IPv4 address
    (a string that is four characters in length) to its standard dotted-quad string
    representation.
  prefs: []
  type: TYPE_NORMAL
- en: The `tcpheader **=** pkt[0][ip_last_range:ip_last_range+20]` statement extracts
    the next 20 bytes of data. The `tcp_hdr = struct.unpack("!HH9sB6s",tcpheader)`
    statement is divided into five parts, that is, `HH9sB6s` first, and then the source
    and destination port number. The fourth part, B, represents the flag value. The `str1
    = bin(flags)[2:].zfill(8)`syntax is used to convert the flag int value to a binary
    value of eight bits.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of `sniffer_new.py` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Our sniffer is now working fine. Let''s discuss the outcomes of the output.
    The Ethernet frame shows the destination MAC and the source MAC. The IP header
    tells the source IP where the packet is arriving from, and the destination IP
    is another operating system that is running on our subnet. The TCP header shows
    the `Source port`, the `Destination port`, and the `Flag`. The source port is
    `443`, which shows that someone is browsing a website. Now that we have an IP
    address, let''s check which website is running on `91.198.174.192`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The preceding results show the `text-lb.esams.wikimedia.org`[ ](http://text-lb.esams.wikimedia.org)website.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the output, two packets are shown. If you print`tcp_hdr[3]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b42e4674-f2e5-425f-99d0-5dc9d080f4cf.png)'
  prefs: []
  type: TYPE_IMG
- en: Flags values
  prefs: []
  type: TYPE_NORMAL
- en: If `16` comes, then the `bin(flag1)[2:].zfill(8**)**` syntax will return `00010000`,
    which means the ACK bit is on. The integer 25 means 00011001, which indicates
    the **Ack**, **Push**, and **Fin** bits are on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s make some amendments to the code. Add one more line at the end
    of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s check how the output is changed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'At times, we are interested in TTL, which is a part of the IP header. This
    means we''ll have to change the unpack function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s check the output of `sniffer_ttl.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `TTL` value is `128`. So how does it work? It's very simple; we have unpacked
    the value in the format 8sB3s4s4s, and our TTL field comes at the ninth byte.
    After 8s means, after the eighth byte, we get the TTL field in the form of B.
  prefs: []
  type: TYPE_NORMAL
- en: Learning about packet crafting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is a technique by which a hacker or pentester can create customized packets.
    By using a customized packet, a hacker can perform many tasks, such as probing
    firewall rule sets, port scans, and the behavior of the operating system. Lots
    of tools are available for packet crafting, such as Hping and Colasoft packet
    builder. Packet crafting is a skill. You can perform it with no tools, as you
    have Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we create Ethernet packets and then send them to the victim. Let''s
    take a look at the entire code of `eth.py` and then understand it line by line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: You've already seen `s = socket.socket(socket.PF_PACKET, socket.SOCK_RAW, socket.ntohs(0x0800))` in
    the packet sniffer. Now, decide on the network interface. We choose the eth0 interface
    to send the packet. The `s.bind(("eth0",socket.htons(0x0800)))` statement binds
    the eth0 interface with the protocol value. The next two lines define the source
    and destination MAC addresses. The `code ='x08x00'` statement shows the protocol
    of interest. This is the code of the IP protocol. The `eth = des+sor+code` statement
    is used to assemble the packet. The next line, `s.send(eth)`, sends the packet.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing ARP spoofing and implementing it using Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**ARP** (**Address Resolution Protocol**) is used to convert the IP address
    to its corresponding Ethernet (MAC) address. When a packet comes to the network
    layer (OSI), it has an IP address and a data-link layer packet that needs the
    MAC address of the destination device. In this case, the sender uses the ARP.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The term **address resolution** refers to the process of finding the MAC address
    of a computer in a network. The following are the two types of ARP messages that
    might be sent by the ARP:'
  prefs: []
  type: TYPE_NORMAL
- en: The ARP request
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ARP reply
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ARP request
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A host machine might want to send a message to another machine in the same subnet.
    The host machine only knows the IP address, while the MAC address is required
    to send the message at the data-link layer. In this situation, the host machine
    broadcasts the ARP request. All machines in the subnet receive the message. The
    Ethernet-protocol type of the value is `0x806`.
  prefs: []
  type: TYPE_NORMAL
- en: The ARP reply
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The intended user responds with their MAC address. This reply is unicast and
    is known as the ARP reply.
  prefs: []
  type: TYPE_NORMAL
- en: The ARP cache
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To reduce the number of address resolution requests, a client normally caches
    the resolved addresses for a short period of time. The ARP cache is a finite size.
    When any device wants to send data to another target device in a subnet, it must
    first determine the MAC address of that target even though the sender knows the
    receiver''s IP address. These IP to MAC address mappings are derived from an ARP
    cache maintained on each device. An unused entry is deleted, which frees some
    space in the cache. Use the `arp –a` command to see the ARP cache, as shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/79a028ae-7eff-40e2-a4e1-9323e982c44b.png)'
  prefs: []
  type: TYPE_IMG
- en: The ARP cache
  prefs: []
  type: TYPE_NORMAL
- en: ARP spoofing, also known as ARP cache poisoning, is a type of attack where the
    MAC address of the victim machine, in the ARP cache of the gateway, along with
    the MAC address of the gateway, in the ARP cache of the victim machine, is changed
    by the attacker. This technique is used to attack the local area networks. The
    attacker can sniff the data frame over the LAN. In ARP spoofing, the attacker
    sends a fake reply to the gateway as well as to the victim. The aim is to associate
    the attacker's MAC address with the IP address of another host (such as the default
    gateway). ARP spoofing is used for active sniffing.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we are going to use an example to demonstrate ARP spoofing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The IP address and MAC address of all the machines in the network are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Machine''s name** | **IP address** | **MAC address** |'
  prefs: []
  type: TYPE_TB
- en: '| Windows XP (victim) | `192.168.0.11` | `00:0C:29:2E:84:7A` |'
  prefs: []
  type: TYPE_TB
- en: '| Linux (attacker) | `192.168.0.10` | `00:0C:29:4F:8E:35` |'
  prefs: []
  type: TYPE_TB
- en: '| Windows 7 (gateway) | `192.168.0.1` | `00:50:56:C0:00:08` |'
  prefs: []
  type: TYPE_TB
- en: 'Let''s take a look at the ARP protocol header, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3021d565-f923-4660-880d-3016357b854d.png)'
  prefs: []
  type: TYPE_IMG
- en: The ARP header
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go through the code to implement ARP spoofing and discuss it line by
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In the packet-crafting section explained previously, you created the Ethernet
    frame. In this code, we have used three MAC addresses, which are also shown in
    the preceding table. Here, we used `code ='x08x06'`, which is the code of the
    ARP protocol. The two Ethernet packets crafted are `eth1` and `eth2`. The next
    line, `htype = 'x00x01'`, denotes the Ethernet. Everything is in order as shown
    in the ARP header, `protype = 'x08x00'`, which indicates the protocol type; `hsize
    = 'x06'` shows the hardware address size; `psize = 'x04'` gives the IP address
    length; and `opcode = 'x00x02'` shows it is a reply packet. The `gate_ip = '192.168.0.1'`
    and `victim_ip = '192.168.0.11'` statements are the IP addresses of the gateway
    and victim, respectively. The `socket.inet_aton ( gate_ip )` method converts the
    IP address to a hexadecimal format. In the end, we assemble the entire code according
    to the ARP header. The `s.send()` method also puts the packets on the cable.
  prefs: []
  type: TYPE_NORMAL
- en: Now, it's time to see the output. Run the `arpsp.py` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s check the victim''s ARP cache:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c97cc4e2-236b-4234-8e37-6c55fef80370.png)'
  prefs: []
  type: TYPE_IMG
- en: The ARP cache of the victim
  prefs: []
  type: TYPE_NORMAL
- en: The preceding screenshot shows the ARP cache before and after the ARP spoofing
    attack. It is clear from the screenshot that the MAC address of the gateway's
    IP has been changed. Our code is working fine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s check the gateway''s ARP cache:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a3f826fc-2fee-43ee-8667-548dd7de270e.png)'
  prefs: []
  type: TYPE_IMG
- en: The gateway's ARP cache
  prefs: []
  type: TYPE_NORMAL
- en: The preceding screenshot shows that our code has run successfully. The victim
    and the attacker's IPs have the same MAC address. Now, all the packets intended
    for the gateway will go through the attacker's system, and the attacker can effectively
    read the packets that travel back and forth between the gateway and the victim's
    computer.
  prefs: []
  type: TYPE_NORMAL
- en: In pentesting, you have to attack (ARP spoofing) the gateway to investigate
    whether it is vulnerable to ARP spoofing or not.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the security system using custom packet crafting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will see some special types of scans. In [chapter 2](b36d9bb9-7532-496b-a791-1b8aa69da5ea.xhtml), *Scanning
    Pentesting*, you saw the port scanner, which works based on the TCP connect scan.
    A three-way handshake is the underlying concept of the TCP connect scan.
  prefs: []
  type: TYPE_NORMAL
- en: A half-open scan
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The half-open scan or stealth scan, as the name suggests, is a special type
    of scanning. Stealth-scanning techniques are used to bypass firewall rules and
    avoid being detected by logging systems. However, it is a special type of scan
    that is done by using packet crafting, which was explained earlier in the chapter.
    If you want to make an IP or TCP packet, then you have to mention each section.
    I know this is very painful and you will be thinking about *Hping*. However, Python's
    library will make it simple.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's take a look at using scapy. Scapy is a third-party library that allows
    you to make custom-made packets. We will write a simple and short code so that
    you can understand scapy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before writing the code, let''s understand the concept of the half-open scan.
    The following steps define the stealth scan:'
  prefs: []
  type: TYPE_NORMAL
- en: The client sends a SYN packet to the server on the intended port
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the port is open, then the server responds with the `SYN`/`ACK` packet
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the server responds with an `RST` packet, it means the port is closed
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The client sends the `RST` to close the initiation
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, let''s go through the code, which will also be explained, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The first line imports all the modules of scapy. The next line, `ip1 = IP(src="img/192.168.0.10",
    dst ="192.168.0.3" )`, defines the IP packet. The name of the IP packet is `ip1`,
    which contains the source and destination address. The `tcp1 = TCP(sport =1024,
    dport=80, flags="S", seq=12345)` statement defines a `TCP` packet named `tcp1`,
    and this packet contains the source port and destination port. We are interested
    in port `80` as we have defined the previous steps of the stealth scan. For the
    first step, the client sends a `SYN` packet to the server. In our `tcp1` packet,
    the `SYN` flag has been set as shown in the packet, and seq is given randomly.
  prefs: []
  type: TYPE_NORMAL
- en: The next line, `packet= ip1/tcp1`, arranges the IP first and then the `TCP`.
    The `p =sr1(packet, inter=1)` statement receives the packet. The `sr1()` function
    uses the sent and received packets but it only receives one answered packet, `inter=
    1`, which indicates an interval of one second because we want a gap of one second
    to be present between two packets. The next line, `p.show()`, gives the hierarchical
    view of the received packet. The `rs1 = TCP(sport =1024, dport=80, flags="R",
    seq=12347)` statement will send the packet with the `RST` flag set. The lines
    following this line are easy to understand. Here, `p1.show` is not needed because
    we are not accepting any responses from the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'So we have received our answered packet. The source and destination seem fine.
    Take a look at the `TCP` field and note the flag''s value. We have SA, which denotes
    the `SYN` and `ACK` flag. As we discussed earlier, if the server responds with
    a `SYN` and `ACK` flag, it means that the port is open. *Wireshark* also captures
    the response, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e98f4962-63b4-4a9f-8079-19212937f167.png)'
  prefs: []
  type: TYPE_IMG
- en: The Wireshark output
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s do it again but, this time, the destination will be different.
    From the output, you will know what the destination address was:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This time, it returns the `RA` flag, which means `RST` and `ACK`. This means
    that the port is closed.
  prefs: []
  type: TYPE_NORMAL
- en: The FIN scan
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes firewalls and **Intrusion Detection Systems** (**IDS**) are configured
    to detect `SYN` scans. In a FIN scan attack, a `TCP` packet is sent to the remote
    host with only the FIN flag set. If no response comes from the host, it means
    that the port is open. If a response is received, it contains the `RST`/`ACK`
    flag, which means that the port is closed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the code for the FIN scan:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The packet is the same as the previous one, with only the FIN flag set. Now,
    check the response from different machines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The incoming packet contains the `RST`/`ACK` flag, which means that the port
    is closed. Now, we will change the destination to `192.168.0.3` and check the
    response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: No response was received from the destination, which means that the port is
    open.
  prefs: []
  type: TYPE_NORMAL
- en: ACK flag scanning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `ACK` scanning method is used to determine whether the host is protected
    by some kind of filtering system.
  prefs: []
  type: TYPE_NORMAL
- en: In this scanning method, the attacker sends an `ACK` probe packet with a random
    sequence number where no response means that the port is filtered (a stateful
    inspection firewall is present in this case); if an RST response comes back, this
    means the port is closed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s go through this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the flag has been set to `ACK`, and the destination port
    is `137`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, check the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The packet has been sent but no response was received. You do not need to worry
    as we have our Python sniffer to detect the response. So run the sniffer, there
    is no need to run it in promiscuous mode, and send the `ACK` packet again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The return packet shows `Flag 04`, which means `RST`. It means that the port
    is not filtered.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s set up a firewall and check the response of the `ACK` packet again.
    Now that the firewall is set, let''s send the packet again. The output will be
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The output of the sniffer shows nothing, which means that the firewall is present.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the beginning of this chapter, we learned about the concept of a sniffer,
    and the use of a sniffer over the network, which at times might reveal big secrets,
    such as passwords and chats. In today's world, switches are mostly used, so you
    should know how to perform active sniffing. We also learned how to make up a layer-4
    sniffer. Then we learned how to perform ARP spoofing. You should test the network
    by ARP spoofing and write your findings in the report. Then, we looked at the
    topic of testing the network by using custom packets. The network disassociation
    attack is similar to the ARP cache poisoning attack, which was also explained.
    Half-open, FIN scan, and `ACK` flag scans are special types of scanning that we
    touched upon too. Lastly, ping of death, which is related to the DDOS attack,
    was explained.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 4](ffe663be-bc5c-4b4a-a11d-ed029eadd7f4.xhtml), *Network Attacks
    and Prevention*, we will learn the network attacks and prevention of network attacks.
  prefs: []
  type: TYPE_NORMAL
