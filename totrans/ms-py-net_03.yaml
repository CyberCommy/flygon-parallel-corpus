- en: APIs and Intent-Driven Networking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 2](8cefc139-8dfa-4250-81bf-928231e20b22.xhtml), *Low-Level Network
    Device Interactions*, we looked at ways to interact with the network devices using
    Pexpect and Paramiko. Both of these tools use a persistent session that simulates
    a user typing in commands as if they are sitting in front of a Terminal. This
    works fine up to a point. It is easy enough to send commands over for execution
    on the device and capture the output. However, when the output becomes more than
    a few lines of characters, it becomes difficult for a computer program to interpret
    the output. The returned output from Pexpect and Paramiko is a series of characters
    meant to be read by a human being. The structure of the output consists of lines
    and spaces that are human-friendly but difficult to be understood by computer
    programs.
  prefs: []
  type: TYPE_NORMAL
- en: In order for our computer programs to automate many of the tasks we want to
    perform, we need to interpret the returned results and make follow-up actions
    based on the returned results. When we cannot accurately and predictably interpret
    the returned results, we cannot execute the next command with confidence.
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, this problem was solved by the internet community. Imagine the difference
    between a computer and a human being when they are both reading a web page. The
    human sees words, pictures, and spaces interpreted by the browser; the computer
    sees raw HTML code, Unicode characters, and binary files. What happens when a
    website needs to become a web service for another computer? The same web resources
    need to accommodate both human clients and other computer programs. Doesn't this
    problem sound familiar to the one that we presented before? The answer is the **Application
    Program Interface** (**API**). It is important to note that an API is a concept
    and not a particular technology or framework, according to Wikipedia.
  prefs: []
  type: TYPE_NORMAL
- en: In computer programming, an **Application Programming Interface** (**API**)
    is a set of subroutine definitions, protocols, and tools for building application
    software. In general terms, it's a set of clearly defined methods of communication
    between various software components. A good API makes it easier to develop a computer
    program by providing all the building blocks, which are then put together by the
    programmer.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our use case, the set of clearly defined methods of communication would
    be between our Python program and the destination device. The APIs from our network
    devices provide a separate interface for the computer programs. The exact API
    implementation is vendor specific. One vendor will prefer XML over JSON, some
    might provide HTTPS as the underlying transport protocol, and others might provide
    Python libraries as wrappers. Despite the differences, the idea of an API remains
    the same: it is a separate communication method optimized for other computer programs.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will look at the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Treating infrastructure as code, intent-driven networking, and data modeling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cisco NX-API and the application-centric infrastructure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Juniper NETCONF and PyEZ
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arista eAPI and PyEAPI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Infrastructure as code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a perfect world, network engineers and architects who design and manage networks
    should focus on what they want the network to achieve instead of the device-level
    interactions. In my first job as an intern for a local ISP, wide-eyed and excited,
    my first assignment was to install a router on a customer's site to turn up their
    fractional frame relay link (remember those?). How would I do that? I asked. I
    was handed a standard operating procedure for turning up frame relay links. I
    went to the customer site, blindly typed in the commands, and looked at the green
    lights flashing, then happily packed my bag and patted myself on the back for
    a job well done. As exciting as that first assignment was, I did not fully understand
    what I was doing. I was simply following instructions without thinking about the
    implication of the commands I was typing in. How would I troubleshoot something
    if the light was red instead of green? I think I would have called back to the
    office and cried for help (tears optional).
  prefs: []
  type: TYPE_NORMAL
- en: Of course, network engineering is not about typing in commands into a device,
    but it is about building a way that allows services to be delivered from one point
    to another with as little friction as possible. The commands we have to use and
    the output that we have to interpret are merely means to an end. In other words,
    we should be focused on our intent for the network. What we want our network to
    achieve is much more important than the command syntax we use to get the device
    to do what we want it to do. If we further extract that idea of describing our
    intent as lines of code, we can potentially describe our whole infrastructure
    as a particular state. The infrastructure will be described in lines of code with
    the necessary software or framework enforcing that state.
  prefs: []
  type: TYPE_NORMAL
- en: Intent-Driven Networking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since the publication of the first edition of this book, the term **Intent-Based
    Networking** has seen an uptick in use after major network vendors chose to use
    it to describe their next-generation devices. In my opinion, **Intent-Driven Networking**
    is the idea of defining a state that the network should be in and having software
    code to enforce that state. As an example, if my goal is to block port 80 from
    being externally accessible, that is how I should declare it as the intention
    of the network. The underlying software will be responsible for knowing the syntax
    of configuring and applying the necessary access-list on the border router to
    achieve that goal. Of course, Intent-Driven Networking is an idea with no clear
    answer on the exact implementation. But the idea is simple and clear, I would
    hereby argue that we should focus as much on the intent of the network and abstract
    ourselves from the device-level interaction.
  prefs: []
  type: TYPE_NORMAL
- en: In using an API, it is my opinion that it gets us closer to a state of intent-driven
    networking. In short, because we abstract the layer of a specific command executed
    on our destination device, we focus on our intent instead of the specific commands.
    For example, going back to our `block port 80` access-list example, we might use
    access-list and access-group on a Cisco and filter-list on a Juniper. However,
    in using an API, our program can start asking the executor for their intent while
    masking what kind of physical device it is they are talking to. We can even use
    a higher-level declarative framework, such as Ansible, which we will cover in
    [Chapter 4](2784e1ec-c5d2-4b04-9e57-7db3caf0e310.xhtml), *The Python Automation
    Framework – Ansible Basics*. But for now, let's focus on network APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Screen scraping versus API structured output
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Imagine a common scenario where we need to log into the network device and
    make sure all the interfaces on the devices are in an up/up state (both the status
    and the protocol are showing as `up`). For the human network engineers getting
    into a Cisco NX-OS device, it is simple enough to issue the `show IP interface
    brief` command in the Terminal to easily tell from the output which interface
    is up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The line break, white spaces, and the first line of the column title are easily
    distinguished from the human eye. In fact, they are there to help us line up,
    say, the IP addresses of each interface from line one to line two and three. If
    we were to put ourselves in the computer''s position, all these spaces and line
    breaks only takes us away from the really important output, which is: which interfaces
    are in the up/up state? To illustrate this point, we can look at the Paramiko
    output for the same operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If we were to parse out that data, here is what I would do in a pseudo-code
    fashion (simplified representation of the code I would write):'
  prefs: []
  type: TYPE_NORMAL
- en: Split each line via the line break.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: I may or may not need the first line that contains the executed command of `show
    ip interface brief`. For now, I don't think I need it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Take out everything on the second line up until the VRF, and save it in a variable
    as we want to know which VRF the output is showing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the rest of the lines, because we do not know how many interfaces there
    are, we will use a regular expression statement to search if the line starts with
    possible interfaces, such as `lo` for loopback and `Eth` for Ethernet interfaces.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will need to split this line into three sections via space, each consisting
    of the name of the interface, IP address, and then the interface status.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The interface status will then be split further using the forward slash (`/`)
    to give us the protocol, link, and the admin status.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Whew, that is a lot of work just for something that a human being can tell
    at a glance! You might be able to optimize the code and the number of lines, but
    in general this is what we need to do when we need to screen scrap something that
    is somewhat unstructured. There are many downsides to this method, but some of
    the bigger problems that I can see are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Scalability**: We spent so much time on painstaking details to parse out
    the outputs from each command. It is hard to imagine how we can do this for the
    hundreds of commands that we typically run.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Predictability**: There is really no guarantee that the output stays the
    same between different software versions. If the output is changed ever so slightly,
    it might just render our hard-earned battle of information gathering useless.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Vendor and software lock-in**: Perhaps the biggest problem is that once we
    spend all this time parsing the output for this particular vendor and software
    version, in this case, Cisco NX-OS, we need to repeat this process for the next
    vendor that we pick. I don''t know about you, but if I were to evaluate a new
    vendor, the new vendor is at a severe on-boarding disadvantage if I have to rewrite
    all the screen scrap code again.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s compare that with an output from an NX-API call for the same `show IP
    interface brief` command. We will go over the specifics of getting this output
    from the device later in this chapter, but what is important here is to compare
    the following output to the previous screen scraping output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: NX-API can return output in XML or JSON, and this is the JSON output that we
    are looking at. Right away, you can see the output is structured and can be mapped
    directly to the Python dictionary data structure. There is no parsing required—you
    can simply pick the key and retrieve the value associated with the key. You can
    also see from the output that there are various metadata in the output, such as
    the success or failure of the command. If the command fails, there will be a message
    telling the sender the reason for the failure. You no longer need to keep track
    of the command issued, because it is already returned to you in the `input` field.
    There is also other useful metadata in the output, such as the NX-API version.
  prefs: []
  type: TYPE_NORMAL
- en: This type of exchange makes life easier for both vendors and operators. On the
    vendor side, they can easily transfer configuration and state information. They
    can add extra fields when the need to expose additional data arises using the
    same data structure. On the operator side, they can easily ingest the information
    and build their infrastructure around it. It is generally agreed on that automation
    is much needed and a good thing. The questions are usually centered on the format
    and structure of the automation. As you will see later in this chapter, there
    are many competing technologies under the umbrella of API. On the transport side
    alone, we have REST API, NETCONF, and RESTCONF, among others. Ultimately, the
    overall market might decide about the final data format in the future. In the
    meantime, each of us can form our own opinions and help drive the industry forward.
  prefs: []
  type: TYPE_NORMAL
- en: Data modeling for infrastructure as code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'According to Wikipedia ([https://en.wikipedia.org/wiki/Data_model](https://en.wikipedia.org/wiki/Data_model)),
    the definition for a data model is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A data model is an abstract model that organizes elements of data and standardizes
    how they relate to one another and to properties of the real-world entities. For
    instance, a data model may specify that the data element representing a car be
    composed of a number of other elements which, in turn, represent the color and
    size of the car and define its owner.
  prefs: []
  type: TYPE_NORMAL
- en: 'The data modeling process can be illustrated in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/2c817be7-d41c-47bd-929a-130e1a63fd87.png)Data modeling process'
  prefs: []
  type: TYPE_NORMAL
- en: When applied to the network, we can apply this concept as an abstract model
    that describes our network, be it a data center, campus, or global wide area network.
    If we take a closer look at a physical data center, a layer 2 Ethernet switch
    can be thought of as a device containing a table of MAC addresses mapped to each
    port. Our switch data model describes how the MAC address should be kept in a
    table, which includes the keys, additional characteristics (think of VLAN and
    private VLAN), and more. Similarly, we can move beyond devices and map the whole
    data center in a model. We can start with the number of devices in each of the
    access, distribution, and core layers, how they are connected, and how they should
    behave in a production environment. For example, if we have a fat-tree network,
    how many links should each of the spine routers have, how many routes they should
    contain, and how many next-hops should each of the prefixes have? These characteristics
    can be mapped out in a format that can be referenced against the ideal state that
    we should always check against.
  prefs: []
  type: TYPE_NORMAL
- en: One of the relatively new network data modeling languages that is gaining traction
    is **Yet Another Next Generation** (**YANG**) (despite common belief, some of
    the IETF workgroups do have a sense of humor). It was first published in RFC 6020
    in 2010, and has since gained traction among vendors and operators. At the time
    of writing, the support for YANG has varied greatly from vendors to platforms.
    The adaptation rate in production is therefore relatively low. However, it is
    a technology worth keeping an eye out for.
  prefs: []
  type: TYPE_NORMAL
- en: The Cisco API and ACI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cisco Systems, the 800-pound gorilla in the networking space, have not missed
    out on the trend of network automation. In their push for network automation,
    they have made various in-house developments, product enhancements, partnerships,
    as well as many external acquisitions. However, with product lines spanning routers,
    switches, firewalls, servers (unified computing), wireless, the collaboration
    software and hardware, and analytic software, to name a few, it is hard to know
    where to start.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since this book focuses on Python and networking, we will scope this section
    to the main networking products. In particular, we will cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Nexus product automation with NX-API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cisco NETCONF and YANG examples
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Cisco application-centric infrastructure for the data center
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Cisco application-centric infrastructure for the enterprise
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the NX-API and NETCONF examples here, we can either use the Cisco DevNet
    always-on lab devices or locally run Cisco VIRL. Since ACI is a separate product
    and is licensed with the physical switches for the following ACI examples, I would
    recommend using the DevNet labs to get an understanding of the tools. If you are
    one of the lucky engineers who has a private ACI lab that you can use, please
    feel free to use it for the relevant examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the similar lab topology as we did in [Chapter 2](8cefc139-8dfa-4250-81bf-928231e20b22.xhtml),
    *Low-Level Network Device Interactions*, with the exception of one of the devices
    running nx-osv:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/f905b772-b032-4d3a-b935-4d5cdd6b0faf.png) Lab topology'
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at NX-API.
  prefs: []
  type: TYPE_NORMAL
- en: Cisco NX-API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nexus is Cisco's primary product line of data center switches. The NX-API ([http://www.cisco.com/c/en/us/td/docs/switches/datacenter/nexus9000/sw/6-x/programmability/guide/b_Cisco_Nexus_9000_Ser](http://www.cisco.com/c/en/us/td/docs/switches/datacenter/nexus9000/sw/6-x/programmability/guide/b_Cisco_Nexus_9000_Series_NX-OS_Programmability_Guide/b_Cisco_Nexus_9000_Series_NX-OS_Programmability_Guide_chapter_011.html)[ies_NX-OS_Programmability_Guide/b_Cisco_Nexus_9000_Series_NX-OS_Programmability_Guide_chapter_011.html](http://www.cisco.com/c/en/us/td/docs/switches/datacenter/nexus9000/sw/6-x/programmability/guide/b_Cisco_Nexus_9000_Series_NX-OS_Programmability_Guide/b_Cisco_Nexus_9000_Series_NX-OS_Programmability_Guide_chapter_011.html))
    allows the engineer to interact with the switch outside of the device via a variety
    of transports including SSH, HTTP, and HTTPS.
  prefs: []
  type: TYPE_NORMAL
- en: Lab software installation and device preparation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are the Ubuntu packages that we will install. You may already have some
    of the packages such `pip` and `git`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: If you are using Python 2, use the following packages instead: `sudo apt-get
    install -y python-dev libxml2-dev libxslt1-dev libffi-dev libssl-dev zlib1g-dev
    python-pip git python-requests`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ncclient` ([https://github.com/ncclient/ncclient](https://github.com/ncclient/ncclient))
    library is a Python library for NETCONF clients. We will install this from the
    GitHub repository so that we can install the latest version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'NX-API on Nexus devices is turned off by default, so we will need to turn it
    on. We can either use the user that is already created (if you are using VIRL
    auto-config), or create a new user for the NETCONF procedures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'For our lab, we will turn on both HTTP and the sandbox configuration, as they
    should be turned off in production:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We are now ready to look at our first NX-API example.
  prefs: []
  type: TYPE_NORMAL
- en: NX-API examples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'NX-API sandbox is a great way to play around with various commands, data formats,
    and even copy the Python script directly from the web page. In the last step,
    we turned it on for learning purposes. It should be turned off in production.
    Let''s launch a web browser and take a look at the various message formats, requests,
    and responses based on the CLI commands that we are already familiar with:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/3d7aec04-66a7-4ecb-95c2-f19b17fd399a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the following example, I have selected `JSON-RPC` and the `CLI` command
    type for the `show version` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/48fbd88d-cc73-4a69-aa66-fff954aaa457.png)'
  prefs: []
  type: TYPE_IMG
- en: The sandbox comes in handy if you are unsure about the supportability of the
    message format, or if you have questions about the response data field keys for
    the value you want to retrieve in your code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our first example, we are just going to connect to the Nexus device and
    print out the capabilities exchanged when the connection was first made:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The connection parameters of the host, port, username, and password are pretty
    self- explanatory. The device parameter specifies the kind of device the client
    is connecting to. We will see a different response in the Juniper NETCONF sections
    when using the ncclient library. The `hostkey_verify` bypasses the `known_host`
    requirement for SSH; if not, the host needs to be listed in the `~/.ssh/known_hosts`
    file. The `look_for_keys` option disables public-private key authentication, but
    uses a username and password for authentication.
  prefs: []
  type: TYPE_NORMAL
- en: If you run into an issue with [https://github.com/paramiko/paramiko/issues/748](https://github.com/paramiko/paramiko/issues/748) with
    Python 3 and Paramiko, please feel free to use Python 2\. Hopefully, by the time
    you read this section, the issue is already fixed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output will show the XML and NETCONF supported features by this version
    of NX-OS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Using ncclient and NETCONF over SSH is great because it gets us closer to the
    native implementation and syntax. We will use the same library later on in this
    book. For NX-API, it might be easier to deal with HTTPS and JSON-RPC. In the earlier
    screenshot of NX-API Developer Sandbox, if you noticed, in the Request box, there
    is a box labeled Python. If you click on it, you will be able to get an automatically
    converted Python script based on the request library.
  prefs: []
  type: TYPE_NORMAL
- en: The following script uses an external Python library named `requests`. `requests`
    is a very popular, self-proclaimed HTTP for the human library used by companies
    like Amazon, Google, NSA, and more. You can find more information about it on
    the official site ([http://docs.python-requests.org/en/master/](http://docs.python-requests.org/en/master/)).
  prefs: []
  type: TYPE_NORMAL
- en: 'For the `show version` example, the following Python script is automatically
    generated for you. I am pasting in the output without any modification:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `cisco_nxapi_2.py` script, you will see that I have only modified the
    URL, username, and password of the preceding file. The output was parsed to include
    only the software version. Here is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The best part about using this method is that the same overall syntax structure
    works with both configuration commands as well as show commands. This is illustrated
    in the `cisco_nxapi_3.py` file. For multiline configuration, you can use the ID
    field to specify the order of operations. In `cisco_nxapi_4.py`, the following
    payload was listed for changing the description of the interface Ethernet 2/12
    in the interface configuration mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We can verify the result of the previous configuration script by looking at
    the running-configuration of the Nexus device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will look at some examples for Cisco NETCONF and the
    YANG model.
  prefs: []
  type: TYPE_NORMAL
- en: The Cisco and YANG models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Earlier in this chapter, we looked at the possibility of expressing the network
    by using the data modeling language YANG. Let's look into it a little bit more
    with examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'First off, we should know that the YANG model only defines the type of data
    sent over the NETCONF protocol without dictating what the data should be. Secondly,
    it is worth pointing out that NETCONF exists as a standalone protocol, as we saw
    in the NX-API section. YANG, being relatively new, has a spotty supportability
    across vendors and product lines. For example, if we run the same capability exchange
    script that we have used before for a Cisco 1000v running IOS-XE, this is what
    we will see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Compare this to the output that we saw for NX-OS. Clearly, IOS-XE supports the
    YANG model features more than NX-OS. Industry-wide, network data modeling when
    supported, is clearly something that can be used across your devices, which is
    beneficial for network automation. However, given the uneven support of vendors
    and products, it is not yet mature enough to be used exclusively for the production network,
    in my opinion. For this book, I have included a script called `cisco_yang_1.py`
    that shows how to parse out the NETCONF XML output with YANG filters called `urn:ietf:params:xml:ns:yang:ietf-interfaces`
    as a starting point to see the existing tag overlay.
  prefs: []
  type: TYPE_NORMAL
- en: You can check the latest vendor support on the YANG GitHub project page ([https://github.com/YangModels/yang/tree/master/vendor](https://github.com/YangModels/yang/tree/master/vendor)).
  prefs: []
  type: TYPE_NORMAL
- en: The Cisco ACI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Cisco **Application Centric Infrastructure** (**ACI**) is meant to provide
    a centralized approach to all of the network components. In the data center context,
    it means that the centralized controller is aware of and manages the spine, leaf,
    and top of rack switches, as well as all the network service functions. This can
    be done through GUI, CLI, or API. Some might argue that the ACI is Cisco's answer
    to the broader controller-based software-defined networking.
  prefs: []
  type: TYPE_NORMAL
- en: One of the somewhat confusing points for ACI is the difference between ACI and
    APIC-EM. In short, ACI focuses on data center operations while APIC-EM focuses
    on enterprise modules. Both offer a centralized view and control of the network
    components, but each has its own focus and share of tool sets. For example, it
    is rare to see any major data center deploy a customer-facing wireless infrastructure,
    but a wireless network is a crucial part of enterprises today. Another example
    would be the different approaches to network security. While security is important
    in any network, in the data center environment, lots of security policies are
    pushed to the edge node on the server for scalability. In enterprise security,
    policies are somewhat shared between the network devices and servers.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike NETCONF RPC, ACI API follows the REST model to use the HTTP verb (`GET`,
    `POST`, `DELETE`) to specify the operation that's intended.
  prefs: []
  type: TYPE_NORMAL
- en: We can look at the `cisco_apic_em_1.py` file, which is a modified version of
    the Cisco sample code on `lab2-1-get-network-device-list.py` ([https://github.com/CiscoDevNet/apicem-1.3-LL-sample-codes/blob/master/basic-labs/lab2-1-get-network-device-list.py](https://github.com/CiscoDevNet/apicem-1.3-LL-sample-codes/blob/master/basic-labs/lab2-1-get-network-device-list.py)).
  prefs: []
  type: TYPE_NORMAL
- en: The abbreviated version without comments and spaces are listed in the following
    section.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first function named `getTicket()` uses HTTPS `POST` on the controller
    with the path of `/api/v1/ticket` with a username and password embedded in the
    header. This function will return the parsed response for a ticket that is only
    valid for a limited time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The second function then calls another path called `/api/v1/network-devices`
    with the newly acquired ticket embedded in the header, then parses the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This is a pretty common workflow for API interactions. The client will authenticate
    itself with the server in the first request and receive a time-based token. This
    token will be used in subsequent requests and will be served as a proof of authentication.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output displays both the raw JSON response output as well as a parsed table.
    A partial output when executed against a DevNet lab controller is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we only query a single controller device, but we are able to
    get a high-level view of all the network devices that the controller is aware
    of. In our output, the Catalyst 2960-C switch, 3500 Access Points, 4400 ISR router,
    and 5500 Wireless Controller can all be explored further. The downside is, of
    course, that the ACI controller only supports Cisco devices at this time.
  prefs: []
  type: TYPE_NORMAL
- en: The Python API for Juniper networks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Juniper networks have always been a favorite among the service provider crowd.
    If we take a step back and look at the service provider vertical, it would make
    sense that automating network equipment is on the top of their list of requirements.
    Before the dawn of cloud-scale data centers, service providers were the ones with
    the most network equipment. A typical enterprise network might have a few redundant
    internet connections at the corporate headquarter with a few hub-and-spoke remote
    sites connected back to the HQ using the service provider's private MPLS network.
    To a service provider, they are the ones who need to build, provision, manage,
    and troubleshoot the connections and the underlying networks. They make their
    money by selling the bandwidth along with value-added managed services. It would
    make sense for the service providers to invest in automation to use the least
    amount of engineering hours to keep the network humming along. In their use case,
    network automation is the key to their competitive advantage.
  prefs: []
  type: TYPE_NORMAL
- en: In my opinion, the difference between a service provider's network needs compared
    to a cloud data center is that, traditionally, service providers aggregate more
    services into a single device. A good example would be **Multiprotocol Label Switching**
    (**MPLS**) that almost all major service providers provide but rarely adapt in
    the enterprise or data center networks. Juniper, as they have been very successful,
    has identified this need and excel at fulfilling the service provider requirements
    of automating. Let's take a look at some of Juniper's automation APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Juniper and NETCONF
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The **Network Configuration Protocol** (**NETCONF**) is an IETF standard, which
    was first published in 2006 as [RFC 4741](https://tools.ietf.org/html/rfc4741)
    and later revised in [RFC 6241](https://tools.ietf.org/html/rfc6241). Juniper
    networks contributed heavily to both of the RFC standards. In fact, Juniper was
    the sole author for RFC 4741\. It makes sense that Juniper devices fully support
    NETCONF, and it serves as the underlying layer for most of its automation tools
    and frameworks. Some of the main characteristics of NETCONF include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: It uses **Extensible Markup Language** (**XML**) for data encoding.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It uses **Remote Procedure Calls** (**RPC**), therefore in the case of HTTP(s)
    as the transport, the URL endpoint is identical while the operation intended is
    specified in the body of the request.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'It is conceptually based on layers from top to bottom. The layers include the
    content, operations, messages, and transport:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](assets/46006bbf-bde4-4219-b26e-451e09a7d384.png)NETCONF model'
  prefs: []
  type: TYPE_NORMAL
- en: Juniper networks provide an extensive NETCONF XML management protocol developer
    guide ([https://www.juniper.net/techpubs/en_US/junos13.2/information-products/pathway-pages/netconf-guide/netconf.html#overview](https://www.juniper.net/techpubs/en_US/junos13.2/information-products/pathway-pages/netconf-guide/netconf.html#overview))
    in its technical library. Let's take a look at its usage.
  prefs: []
  type: TYPE_NORMAL
- en: Device preparation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to start using NETCONF, let''s create a separate user as well as turn
    on the required services:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: For the Juniper device lab, I am using an older, unsupported platform called
    **Juniper Olive**. It is solely used for lab purposes. You can use your favorite
    search engine to find out some interesting facts and history about Juniper Olive.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the Juniper device, you can always take a look at the configuration either
    in a flat file or in XML format. The `flat` file comes in handy when you need
    to specify a one-liner command to make configuration changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The XML format comes in handy at times when you need to see the XML structure
    of the configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We have installed the necessary Linux libraries and the ncclient Python library
    in the Cisco section. If you have not done so, refer back to that section and
    install the necessary packages.
  prefs: []
  type: TYPE_NORMAL
- en: We are now ready to look at our first Juniper NETCONF example.
  prefs: []
  type: TYPE_NORMAL
- en: Juniper NETCONF examples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will use a pretty straightforward example to execute `show version`. We
    will name this file `junos_netconf_1.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: All the fields in the script should be pretty self-explanatory, with the exception
    of `device_params`. Starting with ncclient 0.4.1, the device handler was added
    to specify different vendors or platforms. For example, the name can be juniper,
    CSR, Nexus, or Huawei. We also added `hostkey_verify=False` because we are using
    a self-signed certificate from the Juniper device.
  prefs: []
  type: TYPE_NORMAL
- en: 'The returned output is `rpc-reply` encoded in XML with an `output` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We can parse the XML output to just include the output text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In `junos_netconf_2.py`, we will make configuration changes to the device.
    We will start with some new imports for constructing new XML elements and the
    connection manager object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We will lock the configuration and make configuration changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Under the build configuration section, we create a new element of `system` with
    subelements of `host-namre` and `domain-name`. If you were wondering about the
    hierarchy structure, you can see from the XML display that the node structure
    with `system` is the parent of `host-name` and `domain-name`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'After the configuration is built, the script will push the configuration and
    commit the configuration changes. These are the normal best practice steps (lock,
    configure, unlock, commit) for Juniper configuration changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Overall, the NETCONF steps map pretty well to what you would have done in the
    CLI steps. Please take a look at the `junos_netconf_3.py` script for a more reusable
    code. The following example combines the step-by-step example with a few Python
    functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This file can be executed by itself, or it can be imported to be used by other
    Python scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Juniper also provides a Python library to be used with their devices called
    PyEZ. We will take a look at a few examples of using the library in the following
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Juniper PyEZ for developers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**PyEZ** is a high-level Python implementation that integrates better with
    your existing Python code. By utilizing the Python API, you can perform common
    operation and configuration tasks without the extensive knowledge of the Junos
    CLI.'
  prefs: []
  type: TYPE_NORMAL
- en: Juniper maintains a comprehensive Junos PyEZ developer guide at [https://www.juniper.net/techpubs/en_US/junos-pyez1.0/information-products/pathway-pages/junos-pyez-developer-guide.html#configuration](https://www.juniper.net/techpubs/en_US/junos-pyez1.0/information-products/pathway-pages/junos-pyez-developer-guide.html#configuration)
    on their technical library. If you are interested in using PyEZ, I would highly
    recommend at least a glance through the various topics in the guide.
  prefs: []
  type: TYPE_NORMAL
- en: Installation and preparation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The installation instructions for each of the operating systems can be found
    on the *Installing Junos PyEZ* ([https://www.juniper.net/techpubs/en_US/junos-pyez1.0/topics/task/installation/junos-pyez-server-installing.html](https://www.juniper.net/techpubs/en_US/junos-pyez1.0/topics/task/installation/junos-pyez-server-installing.html))
    page. We will show the installation instructions for Ubuntu 16.04.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are some dependency packages, many of which should already be
    on the host from running previous examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '`PyEZ` packages can be installed via pip. Here, I have installed for both Python
    3 and Python 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'On the Juniper device, NETCONF needs to be configured as the underlying XML
    API for PyEZ:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'For user authentication, we can either use password authentication or an SSH
    key pair. Creating the local user is straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'For the `ssh` key authentication, first, generate the key pair on your host:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, the public key will be called `id_rsa.pub` under `~/.ssh/`, while
    the private key will be named `id_rsa` under the same directory. Treat the private
    key like a password that you never share. The public key can be freely distributed.
    In our use case, we will move the public key to the `/tmp` directory and enable
    the Python 3 HTTP server module to create a reachable URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: For Python 2, use `python -m SimpleHTTPServer` instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the Juniper device, we can create the user and associate the public key
    by downloading the public key from the Python 3 web server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we try to `ssh` with the private key from the management station, the
    user will be automatically authenticated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s make sure that both of the authentication methods work with PyEZ. Let''s
    try the username and password combination:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also try to use the SSH key authentication:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Great! We are now ready to look at some examples for PyEZ.
  prefs: []
  type: TYPE_NORMAL
- en: PyEZ examples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous interactive prompt, we already saw that when the device connects,
    the object automatically retrieves a few facts about the device. In our first
    example, `junos_pyez_1.py`, we were connecting to the device and executing an
    RPC call for `show interface em1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The device class has an `rpc` property that includes all operational commands.
    This is pretty awesome because there is no slippage between what we can do in
    CLI versus API. The catch is that we need to find out the `xml rpc` element tag.
    In our first example, how do we know `show interface em1` equates to `get_interface_information`?
    We have three ways of finding out this information:'
  prefs: []
  type: TYPE_NORMAL
- en: We can reference the *Junos XML API Operational Developer Reference*
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can use the CLI and display the XML RPC equivalent and replace the dash (`-`)
    between the words with an underscore (`_`)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can also do this programmatically by using the PyEZ library
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'I typically use the second option to get the output directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an example of using PyEZ programmatically (the third option):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, we will need to make configuration changes as well. In the `junos_pyez_2.py`
    configuration example, we will import an additional `Config()` method from PyEZ:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'We will utilize the same block for connecting to a device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The `new Config()` method will load the XML data and make the configuration
    changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The PyEZ examples are simple by design. Hopefully, they demonstrate the ways
    you can leverage PyEZ for your Junos automation needs.
  prefs: []
  type: TYPE_NORMAL
- en: The Arista Python API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Arista Networks** have always been focused on large-scale data center networks.
    In its corporate profile page ([https://www.arista.com/en/company/company-overview](https://www.arista.com/en/company/company-overview)),
    it is stated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '"Arista Networks was founded to pioneer and deliver software-driven cloud networking
    solutions for large data center storage and computing environments."'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the statement specifically called out **large data centers**, which
    we already know are exploded with servers, databases, and, yes, network equipment.
    It makes sense that automation has always been one of Arista's leading features.
    In fact, they have a Linux underpin behind their operating system, allowing many
    added benefits such as Linux commands and a built-in Python interpreter.
  prefs: []
  type: TYPE_NORMAL
- en: Like other vendors, you can interact with Arista devices directly via eAPI,
    or you can choose to leverage their `Python` library. We will see examples of
    both. We will also look at Arista's integration with the Ansible framework in
    later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Arista eAPI management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Arista's eAPI was first introduced in EOS 4.12 a few years ago. It transports
    a list of show or configuration commands over HTTP or HTTPS and responds back
    in JSON. An important distinction is that it is a **Remote Procedure Call** (**RPC**)
    and **JSON-RPC**, instead of a pure RESTFul API that's served over HTTP or HTTPS.
    For our intents and purposes, the difference is that we make the request to the
    same URL endpoint using the same HTTP method (`POST`). Instead of using HTTP verbs
    (`GET`, `POST`, `PUT`, `DELETE`) to express our action, we simply state our intended
    action in the body of the request. In the case of eAPI, we will specify a `method`
    key with a `runCmds` value for our intention.
  prefs: []
  type: TYPE_NORMAL
- en: For the following examples, I am using a physical Arista switch running EOS
    4.16.
  prefs: []
  type: TYPE_NORMAL
- en: The eAPI preparation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The eAPI agent on the Arista device is disabled by default, so we will need
    to enable it on the device before we can use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we have turned off the HTTP server and are using HTTPS as the
    sole transport instead. Starting from a few EOS versions ago, the management interfaces,
    by default, reside in a VRF called **management.** In my topology, I am accessing
    the device via the management interface; therefore, I have specified the VRF for
    eAPI management. You can check that API management state via the "show management
    api http-commands" command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'After enabling the agent, you will be able to access the exploration page for
    eAPI by going to the device''s IP address. If you have changed the default port
    for access, just append it at the end. The authentication is tied into the method
    of authentication on the switch. We will use the username and password configured
    locally on the device. By default, a self-signed certificate will be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/3df6e19b-b674-427d-8fd8-e2b40dbfae9a.png)Arista EOS explorer'
  prefs: []
  type: TYPE_NORMAL
- en: 'You will be taken to an explorer page where you can type in the CLI command
    and get a nice output for the body of your request. For example, if I want to
    see how to make a request body for `show version`, this is the output I will see
    from the explorer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/8579af8e-eb72-4dc3-baab-1ab7d8c937be.png)Arista EOS explorer viewer'
  prefs: []
  type: TYPE_NORMAL
- en: The overview link will take you to the sample use and background information
    while the command documentation will serve as reference points for the show commands.
    Each of the command references will contain the returned value field name, type,
    and a brief description. The online reference scripts from Arista use jsonrpclib
    ([https://github.com/joshmarshall/jsonrpclib/](https://github.com/joshmarshall/jsonrpclib/)),
    which is what we will use. However, as of the time of writing this book, it has
    a dependency of Python 2.6+ and has not yet ported to Python 3; therefore, we
    will use Python 2.7 for these examples.
  prefs: []
  type: TYPE_NORMAL
- en: By the time you read this book, there might be an updated status. Please read
    the GitHub pull request ([https://github.com/joshmarshall/jsonrpclib/issues/38](https://github.com/joshmarshall/jsonrpclib/issues/38))
    and the GitHub README ([https://github.com/joshmarshall/jsonrpclib/](https://github.com/joshmarshall/jsonrpclib/))
    for the latest status.
  prefs: []
  type: TYPE_NORMAL
- en: 'Installation is straightforward using `easy_install` or `pip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: eAPI examples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can then write a simple program called `eapi_1.py` to look at the response
    text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Note that, since this is Python 2, in the script, I used the `from __future__
    import print_function` to make future migration easier. The `ssl`-related lines
    are for Python version > 2.7.9\. For more information, please see [https://www.python.org/dev/peps/pep-0476/](https://www.python.org/dev/peps/pep-0476/).
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the response I received from the previous `runCms()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the result is a list containing one dictionary item. If we
    need to grab the serial number, we can simply reference the item number and the
    key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will contain only the serial number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: To be more familiar with the command reference, I recommend that you click on
    the Command Documentation link on the eAPI page, and compare your output with
    the output of show version in the documentation.
  prefs: []
  type: TYPE_NORMAL
- en: As noted earlier, unlike REST, the JSON-RPC client uses the same URL endpoint
    for calling the server resources. You can see from the previous example that the
    `runCmds()` method contains a list of commands. For the execution of configuration
    commands, you can follow the same framework, and configure the device via a list
    of commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of configuration commands named `eapi_2.py`. In our example,
    we wrote a function that takes the switch object and the list of commands as attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output of the command''s execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, do a quick check on the `switch` to verify the command''s execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Overall, eAPI is fairly straightforward and simple to use. Most programming
    languages have libraries similar to `jsonrpclib`, which abstracts away JSON-RPC
    internals. With a few commands, you can start integrating Arista EOS automation
    into your network.
  prefs: []
  type: TYPE_NORMAL
- en: The Arista Pyeapi library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Python client Pyeapi ([http://pyeapi.readthedocs.io/en/master/index.html](http://pyeapi.readthedocs.io/en/master/index.html))
    library is a native Python library wrapper around eAPI. It provides a set of bindings
    to configure Arista EOS nodes. Why do we need Pyeapi when we already have eAPI?
    Picking between Pyeapi versus eAPI is mostly a judgment call if you are in a Python
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: However, if you are in a non-Python environment, eAPI is probably the way to
    go. From our examples, you can see that the only requirement of eAPI is a JSON-RPC
    capable client. Thus, it is compatible with most programming languages. When I
    first started out in the field, Perl was the dominant language for scripting and
    network automation. There are still many enterprises that rely on Perl scripts
    as their primary automation tool. If you're in a situation where the company has
    already invested a ton of resources and the code base is in another language than
    Python, eAPI with JSON-RPC would be a good bet.
  prefs: []
  type: TYPE_NORMAL
- en: However, for those of us who prefer to code in Python, a native `Python` library
    means a more natural feeling in writing our code. It certainly makes extending
    a Python program to support the EOS node easier. It also makes keeping up with
    the latest changes in Python easier. For example, we can use Python 3 with Pyeapi!
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing this book, Python 3 (3.4+) support is officially a work-in-progress,
    as stated in the documentation ([http://pyeapi.readthedocs.io/en/master/requirements.html](http://pyeapi.readthedocs.io/en/master/requirements.html)).
    Please check the documentation for more details.
  prefs: []
  type: TYPE_NORMAL
- en: Pyeapi installation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Installation is straightforward with pip:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Note that pip will also install the netaddr library as it is part of the stated
    requirements [(](http://pyeapi.readthedocs.io/en/master/requirements.html)[http://pyeapi.readthedocs.io/en/master/requirements.html](http://pyeapi.readthedocs.io/en/master/requirements.html)[)
    for Pyeapi.](http://pyeapi.readthedocs.io/en/master/requirements.html)
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, the Pyeapi client will look for an INI style hidden (with a period
    in front) file called `eapi.conf` in your home directory. You can override this
    behavior by specifying the `eapi.conf` file path, but it is generally a good idea
    to separate your connection credential and lock it down from the script itself.
    You can check out the Arista Pyeapi documentation ([http://pyeapi.readthedocs.io/en/master/configfile.html#configfile](http://pyeapi.readthedocs.io/en/master/configfile.html#configfile))
    for the fields contained in the file. Here is the file I am using in the lab:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The first line, `[connection:Arista1]`, contains the name that we will use
    in our Pyeapi connection; the rest of the fields should be pretty self-explanatory.
    You can lock down the file to be read-only for the user using this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Pyeapi examples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we are ready to take a look around the usage. Let''s start by connecting
    to the EOS node by creating an object in the interactive Python shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'We can execute show commands to the node and receive the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The configuration field can be either a single command or a list of commands
    using the `config()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that command abbreviation (`show run` versus `show running-config`) and
    some extensions will not work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'However, you can always catch the results and get the desired value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'So far, we have been doing what we have been doing with eAPI for show and configuration
    commands. Pyeapi offers various APIs to make life easier. In the following example,
    we will connect to the node, call the VLAN API, and start to operate on the VLAN
    parameters of the device. Let''s take a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s verify that VLAN 10 was created on the device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the Python native API on the EOS object is really where Pyeapi
    excels beyond eAPI. It abstracts the lower-level attributes into the device object
    and makes the code cleaner and easier to read.
  prefs: []
  type: TYPE_NORMAL
- en: For a full list of ever increasing Pyeapi APIs, check the official documentation
    ([http://pyeapi.readthedocs.io/en/master/api_modules/_list_of_modules.html](http://pyeapi.readthedocs.io/en/master/api_modules/_list_of_modules.html)).
  prefs: []
  type: TYPE_NORMAL
- en: 'To round up this chapter, let''s assume that we repeat the previous steps enough
    times that we would like to write another Python class to save us some work. The `pyeapi_1.py` script
    is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from the script, we automatically connect to the node and set
    the hostname and `running_config` upon connection. We also create a method to
    the class that creates VLAN by using the `VLAN` API. Let''s try out the script
    in an interactive shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Vendor-neutral libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are several excellent efforts of vendor-neutral libraries such as Netmiko
    ([https://github.com/ktbyers/netmiko](https://github.com/ktbyers/netmiko)) and
    NAPALM ([https://github.com/napalm-automation/napalm](https://github.com/napalm-automation/napalm)).
    Because these libraries do not come natively from the device vendor, they are
    sometimes a step slower to support the latest platform or features. However, because
    the libraries are vendor-neutral, if you do not like vendor lock-in for your tools,
    then these libraries are a good choice. Another benefit of using these libraries
    is the fact that they are normally open source, so you can contribute back upstream
    for new features and bug fixes.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, because these libraries are community supported, they are
    not necessarily the ideal fit if you need to rely on somebody else to fix bugs
    or implement new features. If you have a relatively small team that still needs
    to comply with certain service-level assurances for your tools, you might be better
    off using a vendor-backed library.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at various ways to communicate and manage network
    devices from Cisco, Juniper, and Arista. We looked at both direct communication
    with the likes of NETCONF and REST, as well as using vendor-provided libraries
    such as PyEZ and Pyeapi. These are different layers of abstractions, meant to
    provide a way to programmatically manage your network devices without human intervention.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 4](2784e1ec-c5d2-4b04-9e57-7db3caf0e310.xhtml), *The Python Automation
    Framework – Ansible Basics*, we will take a look at a higher level of vendor-neutral
    abstraction framework called **Ansible**. Ansible is an open source, general purpose
    automation tool written in Python. It can be used to automate servers, network
    devices, load balancers, and much more. Of course, for our purpose, we will focus
    on using this automation framework for network devices.
  prefs: []
  type: TYPE_NORMAL
