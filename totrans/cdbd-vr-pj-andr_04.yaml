- en: Chapter 4. Launcher Lobby
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This project creates a Cardboard VR app that can be used to launch the other
    Cardboard apps installed on your device. We'll call it **LauncherLobby**. When
    you open LauncherLobby, you will see up to 24 icons arranged horizontally. As
    you turn your head to the right or left, the icons scroll as if they are inside
    a cylinder. You can open an app by gazing at its icon and pulling the Cardboard
    trigger.
  prefs: []
  type: TYPE_NORMAL
- en: For this project, we take a minimal approach to creating stereoscopic views.
    The project simulates parallax using standard Android ViewGroup layouts and simply
    shifts the images to the left or right in each eye, creating the parallax visual
    effect. We do not use 3D graphics. We do not use OpenGL directly, though most
    modern versions of Android render views with OpenGL. In fact, we hardly use the
    Cardboard SDK at all; we only use it to paint the split screen overlay and get
    the head orientation. The view layout and image shifting logic, however, is derived
    from Google's Treasure Hunt sample (where it is used to draw a text overlay).
  prefs: []
  type: TYPE_NORMAL
- en: The advantages of this approach are multifold. It illustrates how it's possible
    to build Cardboard apps even without high-level graphics, matrix math, render
    engines, and physics. Of course, these are often required, but in this case, they're
    not. If you have experience with Android development, the classes and patterns
    used here may be especially familiar. This project demonstrates how Cardboard
    VR, at a minimum, only needs a Cardboard SDK head transform and a split-screen
    layout to produce a stereoscopic application.
  prefs: []
  type: TYPE_NORMAL
- en: Practically speaking, we chose this approach so that we can use Android's TextView.
    Rendering arbitrary text in 3D is actually pretty complicated (though certainly
    possible), so for the sake of simplicity, we are constraining this project to
    2D views and Android layouts.
  prefs: []
  type: TYPE_NORMAL
- en: To build the project, we'll first walk you through some basics of putting a
    text string and icon image on the screen and viewing them stereoscopically. Then,
    we'll design a virtual screen that works like the inside of a cylinder unraveled.
    Turning your head horizontally will be like panning across this virtual screen.
    The screen will be divided into slots, each containing the icon and the name of
    a Cardboard app. Gazing at and clicking on one of the slots will launch the corresponding
    application. If you've used the Cardboard Samples app (so called at the time of
    writing), this interface will be familiar.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new Cardboard project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a *Hello Virtual World* text overlay
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using virtual screen space
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Responding to head look
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding an icon to the view
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Listing installed Cardboard apps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Highlighting the current app shortcut
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the trigger to pick and launch an app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The source code for this project can be found on the Packt Publishing website
    and on GitHub at [https://github.com/cardbookvr/launcherlobby](https://github.com/cardbookvr/launcherlobby)
    (with each topic as a separate commit).
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you''d like more details and an explanation of these steps, refer to the
    *Creating a new Cardboard project* section of [Chapter 2](ch02.html "Chapter 2. The
    Skeleton Cardboard Project"), *The Skeleton Cardboard Project*, and follow along
    there:'
  prefs: []
  type: TYPE_NORMAL
- en: With Android Studio opened, create a new project. Let's name it `LauncherLobby`
    and target **Android 4.4 KitKat (API 19)** with an **Empty Activity**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the Cardboard SDK `common.aar` and `core.aar` library files to your project
    as new modules, using **File** | **New** | **New Module...**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the library modules as dependencies to the project app, using **File** |
    **Project Structure**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Edit the `AndroidManifest.xml` file as explained in [Chapter 2](ch02.html "Chapter 2. The
    Skeleton Cardboard Project"), *The Skeleton Cardboard Project*, being careful
    to preserve the `package` name for this project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Edit the `build.gradle` file as explained in [Chapter 2](ch02.html "Chapter 2. The
    Skeleton Cardboard Project"), *The Skeleton Cardboard Project*, to compile against
    SDK 22.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Edit the `activity_main.xml` layout file as explained in [Chapter 2](ch02.html
    "Chapter 2. The Skeleton Cardboard Project"), *The Skeleton Cardboard Project*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Edit the `MainActivity` Java class so that it extends `CardboardActivity` and
    implements `CardboardView.StereoRenderer`. Modify the class declaration line as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Add the stub method overrides for the interface (using intellisense **Implement
    Methods** or pressing *Ctrl* + *I*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Lastly, edit `onCreate()` by adding the `CardboadView` instance as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Adding Hello Virtual World text overlay
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For starters, we''re just going to put some text on the screen that you might
    use for a toast message to the user, or a **heads-up display** (**HUD**) with
    informative content. We''re going to implement this incrementally in small steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a simple overlay view with some text.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Center it on the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add parallax for stereoscopic viewing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A simple text overlay
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, we'll add some overlay text in a simple way, not stereoscopically, just
    text on the screen. This will be our initial implementation of the `OverlayView`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `activity_main.xml` file, and add the following lines to add an `OverlayView`
    to your layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note that we reference the `OverlayView` class with just `.OverlayView`. You
    may do this if your view class is in the same package as your `MainActivity` class.
    We did the same earlier for `.MainActivity`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we write the Java class. Right-click on the `app/java` folder (`app/src/main/java/com.cardbookvr.launcherlobby/`),
    and navigate to **New** | **Java Class**. Name it `OverlayView`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Define the class so that it extends `LinearLayout`, and add a constructor method,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `OverlayView()` constructor method creates a new `TextView` instance with
    a pleasant greenish color and the text **Hello Virtual World!**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the app, and you will notice our text in the top-left corner of the screen,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A simple text overlay](img/B05144_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Center the text using a child view
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Next, we create a separate view group and use it to control the text object.
    Specifically, to center it in the view.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `OverlayView` constructor, replace the `TextView` with an instance of
    a different `ViewGroup` helper class that we''re going to write called `EyeView`.
    Presently, it''s monoscopic but soon we''ll use this class to create two views:
    one for each eye:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We create a new instance of `OverlayEye` named eye, set its color, and add the
    text string.
  prefs: []
  type: TYPE_NORMAL
- en: When using a `ViewGroup` class, you need to specify `LayoutParams` to tell the
    parent how to lay out the view, which we want to be full screen size with no margins
    (refer to [http://developer.android.com/reference/android/view/ViewGroup.LayoutParams.html](http://developer.android.com/reference/android/view/ViewGroup.LayoutParams.html)).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the same `OverlayView.java` file, we''re going to add the private class
    named `OverlayEye`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We have separated the `TextView` creation from the `OverlayEye` constructor.
    The reason for this will soon become clear.
  prefs: []
  type: TYPE_NORMAL
- en: The `OverlayEye` constructor registers the context and attributes needed to
    add new content views to the group.
  prefs: []
  type: TYPE_NORMAL
- en: Then, `addContent` creates the `TextView` instance and adds it to the layout.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we define `onLayout` for `OverlayEye`, which sets the margins of textview,
    specifically the top margin, as a mechanism to force the text to be vertically
    centered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: To center the text vertically, we push it down from the top of the screen using
    a top margin. The text will be positioned vertically just below the center of
    the screen, as specified by `verticalTextPos`, a percentage value where 1.0 is
    the full height of the screen. We picked a value of 0.52 to push the top of the
    text down to an extra 2% just below the middle of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the app, and you will notice that our text is now centered on the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Center the text using a child view](img/B05144_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Create stereoscopic views for each eye
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, we get real. Virtually, that is. For VR, we need stereoscopic left and
    right eye views. Fortunately, we have this handy `OverlayEye` class that we can
    reuse for each eye.
  prefs: []
  type: TYPE_NORMAL
- en: Your eyes are separated by a measurable distance, which is referred to as your
    **interpupillary distance** (**IPD**). When you view a stereoscopic image in a
    Cardboard headset, there are separate views for each eye, offset (horizontally)
    by a corresponding distance.
  prefs: []
  type: TYPE_NORMAL
- en: Let's assume that our text is on a plane perpendicular to the view direction.
    That is, we're looking straight at the text plane. Given a numeric value corresponding
    to the distance of the text from your eyes, we can shift the views for the left
    and right eyes horizontally by a fixed number of pixels to create the parallax
    effect. We'll call this the `depthOffset` value. A larger depth offset will cause
    the text to appear closer; a smaller depth offset will cause the text to appear
    further away. A depth offset of zero will indicate no parallax, as if the text
    is very far away (greater than 20 feet).
  prefs: []
  type: TYPE_NORMAL
- en: For our application, we're going to choose a depth offset factor of 0.01, or
    1% measured in screen coordinates (a fraction of screen size). The icons will
    appear to be about 2 meters away (6 feet), which is a comfortable distance for
    VR, although this value is an ad hoc approximation. Using percentages of screen
    size instead of actual pixel amounts, we can ensure that our application will
    adapt to any screen/device size.
  prefs: []
  type: TYPE_NORMAL
- en: Let's implement this now.
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin, declare variables for the `leftEye` and `rightEye` values at the
    top of the `OverlayView` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Initialize them in the `OverlayView` constructor method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Notice the six lines in the middle where we define `leftView` and `rightView`
    and call `addView` for them. The `setDepthFactor` call will set that value in
    the views.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the setter methods for the depth, color, and text content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Important: notice that for the `rightEye` value we use a negative of the offset
    value. To create the parallax effect, it needs to be shifted to the opposite direction
    of the left eye view. We can still achieve parallax by only shifting one eye,
    but then all of the content will appear to be slightly off center.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `OverlayEye` class needs the depth factor setter, which we convert to pixels
    as `depthOffset`. Also, declare a variable for the physical view width (in pixels):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In `onLayout`, set the view width in pixels after it''s been calculated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Define the setter method, which converts the depth factor to a pixel offset:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when we create `textView` in `addContent`, we can shift it by the `depthOffset`
    value in pixels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run the app, your screen will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Create stereoscopic views for each eye](img/B05144_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The text is now in stereo views, although it's "stuck to your face" as it doesn't
    move when your head moves. It's attached to a visor or HUD.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling the overlay view from MainActivity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next step is to remove some of the hardcoded properties and control them
    from the `MainActivity` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `MainActivity.java`, add an `overlayView` variable at the top of the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Initialize its value in `onCreate`. We''ll display the text using the `addContent()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Don''t forget to remove the call to `addContent` from the `OverlayView` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Run the app one more time. It should look the same as shown earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use code like this to create a 3D toast, such as a text notification
    message. Or, it can be used to construct a HUD panel to share in-game status or
    report the current device attributes. For example, to show the current screen
    parameters you can put them into `MainActivity`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This will show the phone's physical width and height in pixels.
  prefs: []
  type: TYPE_NORMAL
- en: Using a virtual screen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In virtual reality, the space you are looking into is bigger than what is on
    the screen at a given time. The screen is like a viewport into the virtual space.
    In this project, we're not calculating 3D views and clipping planes, and we're
    constraining the head motion to left/right yaw rotation.
  prefs: []
  type: TYPE_NORMAL
- en: You can think of the visible space as the inside surface of a cylinder, with
    your head at the center. As you rotate your head, a portion of the unraveled cylinder
    is displayed on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: '![Using a virtual screen](img/B05144_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The height of the virtual screen in pixels is the same as the physical device.
  prefs: []
  type: TYPE_NORMAL
- en: We need to calculate the virtual width. One way to do this, for example, would
    be to figure out the number of pixels in one degree of head rotation. Then, the
    width of a full rotation would be *pixels per degree * 360*.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can easily find the physical width of the display in pixels. In fact, we
    already found it in `onLayout` as the `viewWidth` variable. Alternatively, it
    can be retrieved from the Cardboard SDK call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'From the SDK, we can also get the **field of view** (**FOV**) angle of the
    Cardboard headset (in degrees). This value will vary from one device to the next
    and is part of the Cardboard device configuration parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Given this, we can calculate the number of pixels per degree and the total width
    in pixels of the virtual screen. For example, on my Nexus 4, the device width
    (landscape mode) is 1,280, and using a Homido viewer, the FOV is 40.0 degrees.
    Thus, the split screen view is 640 pixels, giving us 16.0 pixels per degree and
    a virtual screen width of 5,760 pixels.
  prefs: []
  type: TYPE_NORMAL
- en: While we're at it, we can also calculate and remember the `pixelsPerRadian`
    value, which will be useful to determine the head offset based on the current
    user's `HeadTransform` (given in radians).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add it. At the top of the `OverlayView` class, add these variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, add the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `onCreate` method of `MainActivity`, add the following call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Note that the FOV value reported from the device parameters is a rough approximation
    defined by the headset manufacturer, and, in some devices, may be overestimated
    and padded. The actual FOV can be retrieved from the eye object passed to `onDrawEye()`,
    since that represents the actual frustum that should be rendered. Once the project
    is working, you might consider making this change to your own code.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can use these values to respond to the user's head look rotation.
  prefs: []
  type: TYPE_NORMAL
- en: Responding to head look
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's make the text move with our head, so it doesn't appear to be stuck to
    your face! As you look left or right, we'll move the text in the opposite direction,
    so it appears to be stationary in space.
  prefs: []
  type: TYPE_NORMAL
- en: To do this, we'll start in `MainActivity`. In the `onNewFrame` method, we'll
    determine the horizontal head rotation angle and pass that to the `overlayView`
    object.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `MainActivity`, define `onNewFrame`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `onNewFrame` method receives the current `HeadTransform` instance as an
    argument, which is an object that provides the current head pose.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are various ways to mathematically represent the head pose, such as a
    forward XYZ direction vector, or a combination of angles. The `getEulerAngles`
    method gets the pose as three angles called **Euler angles** (pronounced *oiler*),
    about the three axes for pitch, yaw, and roll:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Pitch** turns your head as if nodding "yes"'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Yaw** turns your head to the left/right (as if shaking "no")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Roll** turns your head from ear to shoulders ("Do a barrel roll!")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These axes correspond to the *X*, *Y*, and *Z* coordinate axes, respectively.
    We're going to constrain this experience to yaw, as you look left or right to
    select from a row of menu items. Therefore, we send just the second Euler angle,
    `angles[1]`, to the `overlayView` class.
  prefs: []
  type: TYPE_NORMAL
- en: Note the use of `runOnUiThread`, which ensures that the `overlayView` update
    is run on the UI thread. Otherwise, we'll cause all sorts of exceptions and break
    the UI (you can refer to [http://developer.android.com/reference/android/app/Activity.html#runOnUiThread(java.lang.Runnable)](http://developer.android.com/reference/android/app/Activity.html#runOnUiThread(java.lang.Runnable))).
  prefs: []
  type: TYPE_NORMAL
- en: 'So, back in `OverlayView`, add a variable to `headOffset` and a method to set
    it, `setHeadYaw`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The idea here is to convert the head rotation into a positional offset for the
    text object on the screen. When your head turns to the left, move the objects
    to the right. When your head turns to the right, move the objects to the left.
    Thus, the objects scroll on the screen as you turn your head.
  prefs: []
  type: TYPE_NORMAL
- en: The yaw angle (rotation about the vertical *Y* axis) that we get from the Cardboard
    SDK is in radians. We calculate the number of pixels to offset the view, in the
    opposite direction from the head. Thus, we take the angle and multiply that by
    `pixelsPerRadian`. Why don't we negate the angle? It just turns out that the clockwise
    rotation is registered as a negative rotation in the *Y* axis. Go figure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, in `OverlayEye`, define the `setHeadOffset` method to change the X
    position of the view objects. Make sure that you include the `depthOffset` variable
    as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Run the app. When you move your head, the text should scroll in the opposite
    direction.
  prefs: []
  type: TYPE_NORMAL
- en: Adding an icon to the view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Next, we'll add an icon image to the view.
  prefs: []
  type: TYPE_NORMAL
- en: For now, let's just use a generic icon, such as `android_robot.png`. A copy
    of this can be found on the Internet, and there's a copy included with the files
    for this chapter. Paste the `android_robot.png` file into your project's `app/res/drawable/`
    folder. Don't worry, we'll be using the actual app icons later.
  prefs: []
  type: TYPE_NORMAL
- en: We want to display both the text and an icon together, so we can add the code
    in order to add the image views to the `addContent` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `onCreate` method of `MainActivity`, modify the `addContent` call to
    pass the icon as a second parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'In `addContent` of `OverlayView`, add the icon parameter and pass it to the
    `OverlayEye` views:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now for the `OverlayEye` class. At the top of `OverlayEye`, add a variable
    to the `ImageView` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Modify `addContent` of `OverlayEye` in order to also take a `Drawable` icon
    and create the `ImageView` instance for it. The modified method now looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Using `imageView.setScaleType.CENTER_INSIDE` tells the view to scale the image
    from its center. Setting `setAdjustViewBounds` to `true` tells the view to preserve
    the image's aspect ratio.
  prefs: []
  type: TYPE_NORMAL
- en: 'Set the layout parameters of `ImageView` in the `onLayout` method of `OverlayEye`.
    Add the following code to the bottom of the `onLayout` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: When the image is drawn, it will fit within the top and bottom margins, scaled
    automatically. In other words, given a desired image size (such as 10% of the
    screen height, or 0.1f), the image margin factor is *(1 - size)/2*, multiplied
    by the pixel height of the screen to get the margin in pixels. We also add a small
    vertical offset (negative, to move it up) for spacing between the icon and the
    text below it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, add the `imageView` offset to the `setHeadOffset` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Run the app. Your screen will look like this. When you move your head, both
    the icon and text will scroll.
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding an icon to the view](img/B05144_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Listing installed Cardboard apps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you haven't forgotten, the purpose of this LauncherLobby app is to show a
    list of Cardboard apps on the device and let the user pick one to launch it.
  prefs: []
  type: TYPE_NORMAL
- en: If you like what we've built so far, you may want to save a copy for future
    reference. The changes we're going to make next will significantly modify the
    code to support a list of views as shortcuts to your apps.
  prefs: []
  type: TYPE_NORMAL
- en: We're going to replace the `addContent` method with `addShortcut` and the `imageView`
    and `textView` variables with a list of shortcuts. Each shortcut consists of an
    `ImageView` and a `TextView` to display the shortcut, as well as an `ActivityInfo`
    object for the purpose of launching the app. The shortcut images and text will
    appear on top of each other, as shown earlier, and will be arranged horizontally
    in a line, a fixed distance apart.
  prefs: []
  type: TYPE_NORMAL
- en: Queries for Cardboard apps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, let''s get the list of Cardboard apps installed on the device. At the
    end of the `onCreate` method of `MainActivity`, add a call to a new method, `getAppList`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, define this method in `MainActivity`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Run it, and review the `logcat` window in Android Studio. The code gets the
    list of Cardboard apps on the current device (`pkgAppsList`) and prints their
    label (`name`) to the debug console.
  prefs: []
  type: TYPE_NORMAL
- en: Cardboard apps are identified by having the `CARDBOARD` intent category, so
    we filter by that. The call to `addFlags` and specifying the flag in `queryIntentActivities`
    are important, because otherwise we won't get the list of intent filters and note
    of the apps will match the `CARDBOARD` category. Also, note that we're using the
    `Activity` class's `getPackageManager()` function. If you need to put this method
    in another class, it will need a reference to the activity. We will be using intents
    again later on in this book. For more information on the package manager and Intents,
    refer to [http://developer.android.com/reference/android/content/pm/PackageManager.html](http://developer.android.com/reference/android/content/pm/PackageManager.html)
    and [http://developer.android.com/reference/android/content/Intent.html](http://developer.android.com/reference/android/content/Intent.html).
  prefs: []
  type: TYPE_NORMAL
- en: Create the Shortcut class for apps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Next, we'll define a `Shortcut` class that holds the details we require of each
    Cardboard app in a convenient object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new Java class named `Shortcut`. Define it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'In `MainActivity`, modify `getAppList()` to build shortcuts from `pkgAppsList`
    and add them to `overlayView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: We need to limit the number of shortcuts that will fit within our view cylinder.
    In this case, I chose 24 as a reasonable number.
  prefs: []
  type: TYPE_NORMAL
- en: Add shortcuts to OverlayView
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, we modify `OverlayView` to support a list of shortcuts that will be rendered.
    First, declare a list variable, `shortcuts`, to hold them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The `addShortcut` method is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this calls the `addShortcut` method in the `OverlayEye` class.
    This builds a list of `TextView` and `ImageView` instances for the layout.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note the `maxShortcuts` and `shortcutWidth` variables. `maxShortcuts` defines
    the maximum number of shortcuts we want to fit on the virtual screen, and `shortcutWidth`
    will be the width of each shortcut slot on the screen. Initialize `shortcutWidth`
    in `calcVirtualWidth()`, adding the following line of code at the end of `calcVirtualWidth`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Using view lists in OverlayEye
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At the top of `OverlayEye`, replace the `textView` and `imageView` variables
    with lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we''re ready to write the `addShortcut` method in `OverlayEye`. It looks
    very much like the `addContent` method we''re replacing. It creates `textView`
    and `imageView` (as mentioned earlier) but then stuffs them into a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Setting `setAdjustViewBounds` to `true` preserves the image aspect ratio.
  prefs: []
  type: TYPE_NORMAL
- en: Delete the obsolete `addContent` method definitions in both the `OverlayView`
    and `OverlayEye` classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `onLayout`, we now iterate over the list of `textViews`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'We also iterate over the list of `imageViews`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we also need to iterate over the list in `setHeadOffset`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Run the app. You will now see your Cardboard shortcuts neatly arranged in a
    horizontal menu that you can scroll by turning your head.
  prefs: []
  type: TYPE_NORMAL
- en: '![Using view lists in OverlayEye](img/B05144_04_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that some Java programmers out there might point out that the list of shortcuts
    and the list of views in each `OverlayEye` class are redundant. They are, indeed,
    but it turns out to be quite complicated to refactor the draw functionality per-eye
    into the `Shortcut` class. We found that this way was the simplest and easiest
    to understand.
  prefs: []
  type: TYPE_NORMAL
- en: Highlighting the current shortcut
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When the user gazes at a shortcut, it should be able to indicate that it is
    selectable. In the next section, we'll wire it up to highlight the selected item
    and to actually launch the corresponding app.
  prefs: []
  type: TYPE_NORMAL
- en: The trick here is to determine which slot is in front of the user. To highlight
    it, we'll brighten the text color.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write a helper method to determine which slot is currently in the gaze,
    based on the `headOffset` variable (which was calculated from the head yaw angle).
    Add the `getSlot` method to the `OverlayView` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: One half of the `shortcutWidth` value is added to the `headOffset` value, so
    we detect gazing at the center of the shortcut. Then, we add the negative of `headOffset`
    since that was originally calculated as the positional offset, which is opposite
    of the view direction. Negative values of `headOffset` actually correspond to
    slot numbers greater than zero.
  prefs: []
  type: TYPE_NORMAL
- en: '`getSlot` should return a number between 0 and the number of slots in our virtual
    layout; in this case, its 24\. Since it is possible to look to the right and set
    a positive `headOffset` variable, `getSlot` can return negative numbers, so we
    check the boundary conditions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can highlight the currently selected slot. We''ll do it by changing
    the text label color. Modify `setHeadOffset` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Run the app and the item in front of your gaze will become highlighted. Of course,
    there may be other interesting ways to highlight the selected app, but this is
    good enough for now.
  prefs: []
  type: TYPE_NORMAL
- en: Using the trigger to pick and launch the app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The final piece is to detect which shortcut the user is gazing at and respond
    to a trigger (click) by launching the app.
  prefs: []
  type: TYPE_NORMAL
- en: When we launch a new app from this one, we need to reference the `MainActivity`
    object. One way to do it is to make it a singleton object. Let's do that now.
    Note that you can get into trouble defining activities as singletons. Android
    can launch multiple instances of a single `Activity` class, but even across apps,
    static variables are shared.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top of the `MainActivity` class, add an `instance` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Initialize it in `onCreate`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Now in `MainActivity`, add a handler to the Cardboard trigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in `OverlayView`, add the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: We're using `getSlot` to index into our shortcuts list. Because we checked the
    boundary conditions in `getSlot` itself, we don't need to worry about `ArrayIndexOutOfBounds`
    exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, add a `launch()` method to `Shortcut`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: We use the `ActivityInfo` object that we stored in the `Shortcut` class to create
    a new `Intent` instance, and then call `MainActivity.instance.startActivity` with
    it as an argument to launch the app.
  prefs: []
  type: TYPE_NORMAL
- en: Note that once you've launched a new app, there's no system-wide way to get
    back to LauncherLobby from within VR. The user will have to remove the phone from
    the Cardboard Viewer, and then click on the back button. However, the SDK does
    support `CardboardView.setOnCardboardBackButtonListener` which can be added to
    your Cardboard apps if you want to present a back or exit button.
  prefs: []
  type: TYPE_NORMAL
- en: There you have it! LauncherLobby is ready to rock and roll.
  prefs: []
  type: TYPE_NORMAL
- en: Further enhancements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Some ideas for how to improve and enhance this project include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Support more than 24 shortcuts, perhaps adding multiple rows or an infinite
    scrolling mechanic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reuse images and text view objects; you only ever see a few at a time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Currently, really long app labels will overlap, tweak your view code to make
    the text wrap, or introduce an ellipsis (...) when the label is too long
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a cylindrical background image (skybox)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Alternative ways to highlight the current shortcut, perhaps with a glow, or
    move it closer by adjusting its parallax offset
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add sounds and/or vibrations to enhance the experience and reinforce the selection
    feedback
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we built the LauncherLobby app, which can be used to launch
    other Cardboard apps on your device. Rather than using 3D graphics and OpenGL,
    we implemented this using Android GUI and a virtual cylindrical screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part of the implementation was largely instructional: how to add
    a `TextView` overlay, center it in the view group, and then display it stereoscopically
    with left/right eye parallax views. Then, we determined the size of the virtual
    screen, an unraveled cylinder, based on the current physical device size and the
    current Cardboard device field of view parameters. Objects are scrolled on the
    virtual screen as the user moves his head left and right (yaw rotation). Finally,
    we queried the Android device for installed Cardboard apps, displayed their icons
    and titles in a horizontal menu, and allowed you to pick one to launch by gazing
    at it and clicking on the trigger.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we go back to 3D graphics and OpenGL. This time, we're
    building a software abstraction layer that helps encapsulate much of the lower
    level details and housekeeping. This engine will be reusable for other projects
    in this book as well.
  prefs: []
  type: TYPE_NORMAL
