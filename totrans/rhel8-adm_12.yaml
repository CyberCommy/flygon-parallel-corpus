- en: '*Chapter 10*: Keeping Your System Hardened with SELinux'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are going to familiarize ourselves with SELinux. SELinux
    has been around for a while, but a lack of understanding regarding how it works
    leads many people to suggest disabling it.
  prefs: []
  type: TYPE_NORMAL
- en: This is not something we want, as it would be similar to telling a user to forego
    a password because it is hard to remember.
  prefs: []
  type: TYPE_NORMAL
- en: We will introduce the origins of SELinux, and what the default modes and policies
    are. Then, we will understand how SELinux applies to our files, folders, and processes,
    and how to restore them to the system defaults.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, we will explore how to fine-tune the policies using Booleans
    and troubleshoot common issues with the help of the following sections:'
  prefs: []
  type: TYPE_NORMAL
- en: SELinux usage in enforcing and permissive modes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reviewing the SELinux context for files and processes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tweaking the policy with semanage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Restoring changed file contexts to the default policy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using SELinux Boolean settings to enable services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SELinux troubleshooting and common fixes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end, we will better understand how to use SELinux properly and how to
    benefit from the additional protection that it provides to our system.
  prefs: []
  type: TYPE_NORMAL
- en: During the chapter, there will be detailed explanations of how SELinux works
    to aid our understanding of the way it operates, even if using it, in reality,
    is a lot simpler. We will also use these examples to illustrate cases where SELinux
    prevents attacks or misconfigurations.
  prefs: []
  type: TYPE_NORMAL
- en: Let's get hands-on with SELinux!
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is possible to continue the practice of using the virtual machine created
    at the beginning of this book in [*Chapter 1*](B16799_01_Final_SK_ePub.xhtml#_idTextAnchor014),
    *Installing RHEL8*. Any additional packages required for this chapter will be
    indicated alongside the text and can be downloaded from [https://github.com/PacktPublishing/Red-Hat-Enterprise-Linux-8-Administration](https://github.com/PacktPublishing/Red-Hat-Enterprise-Linux-8-Administration).
  prefs: []
  type: TYPE_NORMAL
- en: SELinux usage in enforcing and permissive modes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Security-Enhanced Linux** (**SELinux**) was introduced in December of 2000
    via the Linux-Kernel mailing list as a product started by the **National Security
    Agency** (**NSA**) to improve the security of the operating system by means of
    mandatory access controls and role-based access control, as opposed to the traditional
    discretionary access controls that were available in the system.'
  prefs: []
  type: TYPE_NORMAL
- en: Before SELinux was introduced in the Linux kernel, discussions took place regarding
    the proper way to do it, and finally, a kernel framework named **Linux Security
    Modules (LSM)** was introduced and SELinux was implemented using it so that other
    approaches could use LSM, too, and not just SELinux.
  prefs: []
  type: TYPE_NORMAL
- en: SELinux provides security improvements to Linux as access to files made by users,
    processes, or even other resources can be controlled in a very granular way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take one example to make it clearer when SELinux comes into play: when
    a web server is serving pages from users, it reads files from the user''s home
    directory inside the `public_html` or `www` folders (the most standard ones).
    Being able to read files from the user''s home directory can reveal the contents
    in the event that the web server process is hijacked by an attacker, and this
    precise moment is when SELinux comes into play, as it will automatically block
    access to files that should not be accessible for a web server.'
  prefs: []
  type: TYPE_NORMAL
- en: SELinux then confines the processes and services to only perform what they are
    supposed to, and only using the resources that are authorized. This is a really
    important feature that keeps things under control, even in the event of software
    bugs that may lead to unexpected files or resources being accessed. SELinux will
    block it if it has not been authorized by the active policy.
  prefs: []
  type: TYPE_NORMAL
- en: Important tip
  prefs: []
  type: TYPE_NORMAL
- en: SELinux permissions always arise following regular **Discretionary Access Controls**
    (**DAC**) if a user has no access to a file because of improper file permissions.
    SELinux has nothing to do there.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, the system installation should deploy it in `enforcing` mode and
    using the `targeted` policy. It is possible to check your current system status
    via execution of `sestatus`, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1 – Output of sestatus for our system'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_10_001.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.1 – Output of sestatus for our system
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, our system has SELinux `enabled`, using the `targeted` policy,
    and is currently `enforcing`. Let's learn about what this means.
  prefs: []
  type: TYPE_NORMAL
- en: SELinux works by defining a `dnf list selinux-policy-*` in your system, with
    `targeted` and `mls` being the most common ones.
  prefs: []
  type: TYPE_NORMAL
- en: We will focus on the targeted policy, but to make an analogy regarding `mls`,
    the `su` or `sudo`, they would still have the original label attached so permissions
    could be reduced if the root login happened over a local terminal or a remote
    connection and `sudo` execution.
  prefs: []
  type: TYPE_NORMAL
- en: The mode, listed as `enforcing`, means that the policy is currently being enforced,
    which is the opposite of `permissive`. We can consider this as being active and
    offering protection, while permissive entails being active but only providing
    a warning, and not offering protection.
  prefs: []
  type: TYPE_NORMAL
- en: Why do we have `permissive` instead of just disabling it? This question is a
    bit tricky, so let's explain a bit more about how it works to provide a better
    answer.
  prefs: []
  type: TYPE_NORMAL
- en: SELinux uses extended attributes in the filesystem to store the labels. Each
    time a file is created, a label is assigned based on the policy, but this only
    happens while SELinux is active, so this makes SELinux `disabled` different from
    SELinux `permissive`, because the first one will not create those labels for the
    new files created.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, SELinux in `permissive` mode allows us to see the errors that
    will be raised if a program has not received a good policy for it or if a file
    has no proper labels.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is really easy to switch from `enforcing` to `permissive` and vice versa
    and always via the `setenforce` command, while we can use `getenforce` to retrieve
    the current status, as we can see in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.2 – Changing SELinux enforcing status'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_10_002.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.2 – Changing SELinux enforcing status
  prefs: []
  type: TYPE_NORMAL
- en: It might look basic, but it really is as easy as that, a matter of running a
    command. However, if the status was disabled, it would be a completely different
    story.
  prefs: []
  type: TYPE_NORMAL
- en: SELinux status is configured by editing the `/etc/selinux/config` file, but
    changes only take effect after a system reboot; that is, we can switch from `enforcing`
    to `permissive` in real time or from permissive to enforcing, but when changing
    the policy from `disabling` to `enabling`, or vice versa, SELinux will require
    us to reboot the system.
  prefs: []
  type: TYPE_NORMAL
- en: The general advice is to leave SELinux in enforcing mode, but if, for whatever
    reason, it was disabled, the recommendation is to switch SELinux to `permissive`
    as the first step when moving from `disabled`. This will allow us to check that
    the system actually works without being locked out of it because of a kernel blocking
    access to files and resources.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: During the reboot after switching from `disabled` to `permissive` or `enforcing`,
    the system will force a relabeling of the filesystem based on the policy. This
    is accomplished by the creation of a file in the root folder of our filesystem
    named `/.autorelabel`, which will trigger the process and reboot again afterward.
  prefs: []
  type: TYPE_NORMAL
- en: But why opt for disabling instead of `permissive`? For example, some software
    might require to set it in disabled mode even if later, it can be re-enabled for
    operations or for other reasons, but bear in mind that SELinux is a security feature
    that protects your system and should be kept.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that SELinux uses `/var/log/audit/audit.log` file as well as system
    journals, and yes, it's a cache, so rules are not checked as frequently so as
    to speed up operations.
  prefs: []
  type: TYPE_NORMAL
- en: Let's go back to the idea of the filesystem storing labels and let's jump into
    the next section to see how they relate to processes, files, and the RBAC provided
    by SELinux.
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing the SELinux context for files and processes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'SELinux uses labels, also referred to as the security context attached to each
    file, and defines several aspects. Let''s check one example in our home folder
    with the `ls –l` command, but with a special modifier, `Z`, that will show SELinux
    attributes as well, as we can see in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.3 – File listing showing SELinux attributes'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_10_003.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.3 – File listing showing SELinux attributes
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s focus on the output for one of the files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The SELinux attributes are the ones listed as `unconfined_u:object_r:admin_home_t:s0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`unconfined_u`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`object_r`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`admin_home_t`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`s0` in multi-level security and multi-category security'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Something similar happens with processes, and similarly, we can append `Z`
    to many of the common commands to get the contexts, for example, with `ps Z`,
    as we can see in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.4 – ps output with SELinux contexts'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_10_004.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.4 – ps output with SELinux contexts
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, let''s examine one of the lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, we can see the same approach: user, role, type, and level for multi-level
    security and multi-category security.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've introduced what it looks like, let's focus on how it works in
    the targeted policy.
  prefs: []
  type: TYPE_NORMAL
- en: The targeted policy allows everything to run as if SELinux was not enabled in
    the system, except for the services targeted by it. This makes a good compromise
    between security and usability.
  prefs: []
  type: TYPE_NORMAL
- en: During development of the policy, new services are added, while others are refined,
    and many of the most common services have policies written for protecting them.
  prefs: []
  type: TYPE_NORMAL
- en: SELinux also features something named **transitions**. A transition allows one
    process started by a user, with a binary with some specific role, to transition
    via the execution into some other role, which is used later to define what the
    permissions are for it.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you might imagine, our user also has a SELinux context, and similarly, we
    can use the `id -Z` command for checking it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: So, going back to the first example, Apache Web Server is provided by the `httpd`
    package, which can be installed via `dnf –y install httpd`. Once installed, let's
    start it with `systemctl start httpd` and enable it with `systemctl enable httpd`,
    and then open the firewall with `firewall-cmd --add-service=http` and `firewall-cmd
    --add-service=https`, as we've done with other services in previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Previous commands can be found in the following script: [https://github.com/PacktPublishing/Red-Hat-Enterprise-Linux-8-Administration/blob/main/chapter-10-selinux/apache.sh](https://github.com/PacktPublishing/Red-Hat-Enterprise-Linux-8-Administration/blob/main/chapter-10-selinux/apache.sh).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how all that comes into play in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.5 – Web server SELinux contexts'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_10_005.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.5 – Web server SELinux contexts
  prefs: []
  type: TYPE_NORMAL
- en: Here, we can see how the executable on disk has the context `httpd_exec_t`,
    the process is `httpd_t`, and the files/folder served by it is `httpd_sys_content_t`,
    and it works!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now create an `index.htm` file in our `home` folder and move it to the
    `Apache Web Root` folder as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see what happens when we try to access the files as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.6 – Apache behavior with the generated files'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_10_006.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.6 – Apache behavior with the generated files
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, each file has one SELinux context, but on top of that, Apache
    is denying access to the one we moved (`index1.htm`), but showing the contents
    for the one we copied (`index2.htm`).
  prefs: []
  type: TYPE_NORMAL
- en: What has happened here? We copied one file and move the other, out of the same
    source, but they got two different SELinux contexts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s extend the test as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.7 – Retrying with SELinux in permissive mode'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_10_007.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.7 – Retrying with SELinux in permissive mode
  prefs: []
  type: TYPE_NORMAL
- en: As we can see in the preceding screenshot, we are now able to access file contents,
    so you could say *"What is wrong with SELinux that does not allow my site to work?"*,
    but the right way to express it would be *"Look how SELinux has protected us from
    disclosing a personal file on a website"*.
  prefs: []
  type: TYPE_NORMAL
- en: If, instead of directly moving a file into the Apache's `/var/www/html`), it
    was an attacker trying to reach our home folder files, SELinux would have denied
    those accesses by default. The `httpd_t` process cannot access the `admin_home_t`
    context.
  prefs: []
  type: TYPE_NORMAL
- en: A similar thing happens when we try to get Apache or any other service under
    the targeted policy to listen on a port that is not the one configured by default,
    and the best way to get familiar with what we can or cannot do is to learn about
    the `semanage` utility.
  prefs: []
  type: TYPE_NORMAL
- en: Using `semanage`, we can list, edit, add, or delete the different values in
    the policy, and even export and import our customizations, so let's use it to
    learn a bit more about it using our example with `httpd`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's learn about `semanage` in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Tweaking the policy with semanage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we introduced earlier, the targeted policy contains some configurations that
    are enforced for the services it has defined, allowing the protection of those
    services while not interfering with the ones it does not know about.
  prefs: []
  type: TYPE_NORMAL
- en: Still, sometimes we need to tweak a number of settings, such as allowing `http`
    or the `ssh` daemon to listen on alternate ports or accessing some other file
    types, but without losing the additional layer of protection provided by SELinux.
  prefs: []
  type: TYPE_NORMAL
- en: First, let's ensure that `policycoreutils` and `policycoreutils-python-utils`
    are installed in our system with `dnf –y install policycoreutils-python-utils
    policycoreutils` as they provide the tools we will use in this and the next sections
    of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s learn with the help of an example. Let''s see which ports `httpd_t`
    can access with `semanage port -l|grep http`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, `http_port_t`, used by Apache Daemon, is allowed, by default,
    to use the ports `80`, `81`, `443`, `488`, `8008`, `9009`, `8443`, and `9000`
    via `tcp`.
  prefs: []
  type: TYPE_NORMAL
- en: That means that if we want to run Apache on any of those ports, no changes to
    policy will be required.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we repeat the command but for `ssh`, we only see port `22` opened (executing
    `semanage port -l|grep ssh`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, we might want to add another port, let''s say `2222`, to the list
    of possible ports, so that we hide the standard one being tested by port scanners.
    We will be able to do it via `semanage port -a -p tcp -t ssh_port_t 2222` and
    then validate with the prior command `semanage port –l|grep ssh`, which now shows
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, port `2222` has been added to the list of available ports for
    the `ssh_port_t` type, and that enables the `ssh` daemon to start listening on
    it (this, of course, requires additional configuration for the `ssh` daemon configuration
    and to the firewall before we get a working service).
  prefs: []
  type: TYPE_NORMAL
- en: In the same way, for example, some web services require writing to specific
    folders for storing configurations, but by default, the context on `/var/www/html`
    is `httpd_sys_content_t`, which does not allow writing to disk.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can check the available file contexts with `semanage fcontext –l` in a similar
    way to what we did with the ports, but the list of files is huge, as a web server
    might use common locations such as `logs` and `cgi-bin`, as well as filesystem
    files for certificates, configuration, and home directories, and extensions such
    as PHP and others. When you check the contexts with the preceding command, pay
    attention to the different types that are available and what the structure is
    for one listing, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, there is a regular expression that matches the files in the `wp-content`
    folder inside the `/var/www/html` path applying to all files and sets a SELinux
    context of `httpd_sys_rw_content_t`, which allows read-write access. This folder
    is used by the popular blog software **WordPress**, so the policy is already prepared
    for covering some of the most popular services, folders, and requirements without
    requiring system administrators to write them ad hoc.
  prefs: []
  type: TYPE_NORMAL
- en: 'When invoking `semanage`, it will output that it has some subcommands we can
    use, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`import`: This allows the importing of local modifications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`export`: This allows the exporting of local changes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`login`: This allows the login and SELinux user associations to be managed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`user`: This manages SELinux users with roles and levels.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`port`: This manages port definitions and types.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ibpkey`: This manages InfiniBand definitions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ibendport`: This manages end port InfiniBand definitions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`interface`: This defines network interface definitions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`module`: This manages policy modules for SELinux.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`node`: This manages definitions of network nodes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fcontext`: This manages file context definitions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`boolean`: This manages Booleans for tweaking policies.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`permissive`: This manages the enforcing mode.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dontaudit`: This manages the `dontaudit` rules in the policy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For each one of the preceding commands, we can use the `-h` argument to list,
    help, and learn about the extra arguments that can be used for each one.
  prefs: []
  type: TYPE_NORMAL
- en: For the day-to-day use case, most of the time we'll be using `port` and `fcontext`
    as those will cover extending or tuning the available services that come with
    Red Hat Enterprise Linux, like the example we have showcased with `ssh` listening
    on an additional port.
  prefs: []
  type: TYPE_NORMAL
- en: Important tip
  prefs: []
  type: TYPE_NORMAL
- en: Traditionally, `semanage`, `regexp` for the path that will be used. When following
    this approach, if the filesystem is relabeled or the context restored, the application
    will continue to work.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see how to manually set the context for files and how to restore the defaults
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Restoring changed file contexts to the default policy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we mentioned how `semanage` enables us to perform changes
    to the policy, which is the recommended way to perform changes and to persist
    them for future files and folders, but that is not the only way we can perform
    operations.
  prefs: []
  type: TYPE_NORMAL
- en: From the command line, we can use the `chcon` utility to change the context
    for a file. This will allow us to define the user, the role, and the type for
    the file we want to alter, and similar to other filesystem utilities such as `chmod`
    or `chown`, we can also affect files recursively, so it's easy to set a full folder
    hierarchy to the desired context.
  prefs: []
  type: TYPE_NORMAL
- en: One feature that I always found very interesting is the ability to copy the
    context of a file via the `--reference` flag, so that the same context as the
    referenced file is applied to the target one.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we were introducing the example of `httpd` earlier in this chapter, we
    did a test with two files, `index1.htm` and `index2.htm`, that were moved and
    copied to the `/var/www/html` folder. To go deeper into this example, we will
    make additional copies of `index1.htm` to demonstrate in the next screenshot the
    usage of `chcon`. Bear in mind that creating the files directly in the `/var/www/html`
    folder will set the files to have the proper context, so we need to create them
    at `/root` and then move them to the target folder, as we can see in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.8 – Demonstrating chcon usage'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_10_008.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.8 – Demonstrating chcon usage
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, both the `index1.htm` and `index3.htm` files now have the proper
    context, in the first case, using the reference, and in the second, defining the
    type to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, this is not the only method. As we indicated earlier, the recommended
    way for setting context for applications is to define the `regexps` path via `semanage`,
    and this empowers us to use the `restorecon` command to apply the right context,
    according to the configuration, to the files. Let''s check how it operates in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.9 – Using restorecon to restore context'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_10_009.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.9 – Using restorecon to restore context
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, we used `restorecon –vR /var/www/html/` and it automatically
    changed the `index3.htm` file into `httpd_sys_content_t`, which is defined for
    that folder as we saw when we were testing `semanage` to list the contexts. The
    arguments used, `v` and `R`, make the utility report the changes (verbose) and
    work recursively on the paths provided.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say we have messed the system up by running `chcon` over the root filesystem.
    What would be the way to fix it? In this case, as we mentioned earlier, we should
    do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Set the operation mode to `permissive` to not block further access via `setenforce
    0`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Put the marker to have the filesystem relabeled via `touch /.autorelabel`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modify the `/etc/selinux/config` file to set the boot mode to `permissive`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reboot the system to let relabeling happen.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once the system reboots, edit `/etc/selinux/config` again to define the operation
    mode as `enforcing`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By operating in this way, instead of just running `restorecon -R /`, we are
    making sure that the system is operational and will continue to operate after
    reboot and a full relabel is applied to the filesystem, so it is left ready to
    re-enable the `enforcing` mode safely.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, let's see how to tune the policy within itself, using the
    Booleans to tune how it works.
  prefs: []
  type: TYPE_NORMAL
- en: Using SELinux Boolean settings to enable services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many services have a wide range of configuration options for many common cases,
    but not always the same. For example, the `http` server should not access user
    files, but at the same time, it's a common way of operation to enable personal
    websites from the `www` or `public_html` folders in each user's home directory.
  prefs: []
  type: TYPE_NORMAL
- en: To overcome that use case and, at the same time, provide enhanced security,
    the SELinux policy makes use of Booleans.
  prefs: []
  type: TYPE_NORMAL
- en: 'A Boolean is a tunable that can be set by the administrator that can enable
    or disable conditionals in the policy code. Let''s see, for example, a list of
    Booleans available for `httpd` by executing `getsebol -a|grep ^http` (list reduced):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This list is a reduced subset of the Booleans available, but it does give us
    an idea of what it can accomplish; for example, `http`, by default, cannot use
    the network to connect to other hosts, or send an email (usually done in PHP scripts),
    or can't even access home folders for users.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if we want to enable users in a system to publish their personal
    web pages from the `www` folder in their home directory, that is `/home/user/www/`,
    we will have to enable the `httpd_enable_homedirs` Boolean by running the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This will tweak the policy to enable `http` to access the user's home directory
    to serve the pages there. If, additionally, the servers will be stored on a **Network
    FileSystem** (**NFS**) or **Common Internet FileSystem** (**CIFS**) mount, additional
    Booleans will be required. We're still using the same targeted policy, but we've
    enabled the internal conditionals to permit that the accesses are not to be blocked
    by SELinux.
  prefs: []
  type: TYPE_NORMAL
- en: Important tip
  prefs: []
  type: TYPE_NORMAL
- en: The `–P` parameter to `setsebool` is required to make the change *permanent*.
    That means writing the change so that it is persisted; without it, the change
    will be lost once we restart our server.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we''ve seen, `getsebool` and `setsebool` allow us to query and to set the
    values for the Booleans that tune the policy, but also, `semanage boolean -l`
    can help here, as we can see in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.10 – Using semanage to manage Booleans'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_10_010.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.10 – Using semanage to manage Booleans
  prefs: []
  type: TYPE_NORMAL
- en: In the previous screenshot, we can see not only the Boolean we edited using
    `setsebool`, but also a description of the intended behavior.
  prefs: []
  type: TYPE_NORMAL
- en: One of the benefits is that `semanage`, as we introduced, allows us to export
    and import the local changes to the policy, so any customization made can be exported
    and imported to another system to ease the setup of similar server profiles.
  prefs: []
  type: TYPE_NORMAL
- en: All the possible Booleans in the policy can be checked with `semanage boolean
    –l`, similar to what we did to list the binding ports for applications in our
    `http` example.
  prefs: []
  type: TYPE_NORMAL
- en: We have learned about using Booleans to tune how the policy is adapting to some
    specific but pretty common cases. Next, we will explore probably the most frequently
    used part for administrators, that is, troubleshooting, but with the focus on
    SELinux.
  prefs: []
  type: TYPE_NORMAL
- en: SELinux troubleshooting and common fixes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the main problems in getting used to SELinux is that many people who
    are not familiar with it blame it for things not working; however, this argument
    is getting a bit outdated: SELinux was introduced in Red Hat Enterprise Linux
    4, which was back in 2005\.'
  prefs: []
  type: TYPE_NORMAL
- en: Most of the time, issues with SELinux and our systems are related to changed
    file contexts and changing ports for services, and fewer time issues with the
    policy itself.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, there are several places where we can check for errors, but in
    our list we should start with the audit log or the system messages. For example,
    we can start with the `/var/log/audit/audit.log` file that we introduced earlier
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Also bear in mind that SELinux **Mandatory Access Control** (**MAC**) only plays
    once we have cleared access from regular **Discretionary Access Controls** (**DAC**),
    that is, if we've no permission to check a file (for example, mode 400 and our
    user not being the owner). In this case, it's highly unlikely that SELinux is
    blocking access.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the time, our system will have installed the `setroubleshoot-server`
    and `setroubleshoot-plugins` packages that provide several tools, including `sealert`,
    to query the received SELinux messages and many times, also, to suggest changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s cover some of the basics that we should always validate:'
  prefs: []
  type: TYPE_NORMAL
- en: Review all the other controls (user and group ownership and permissions are
    properly set).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do not disable SELinux.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a program is not working properly and it was shipped with the OS, it might
    be a bug and should be reported via a support case or Bugzilla at [https://bugzilla.redhat.com](https://bugzilla.redhat.com).
  prefs: []
  type: TYPE_NORMAL
- en: Only if a program is not working properly might it be made to run unconfined,
    but leaving all remaining system services protected via the targeted policy.
  prefs: []
  type: TYPE_NORMAL
- en: Think about what was done before the error happened if this is an existing program.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Perhaps files were moved instead of copied or created upon reaching their destination,
    or perhaps the ports or folders for the software were changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having arrived at this point, we should check `audit.log` for relevant messages.
    For example, as regards the example we mentioned regarding the wrong context with
    the files in `/var/www/html/`, an example audit entry would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: It looks strange, but if we check the parameters, we see the path of the affected
    file, the PID, the source context (`scontext`), and the target context (`tcontext`),
    so in brief, we can see that `httpd_t` tried to access (get attributes) for a
    target context `admin_home_t` and that was denied.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the same time, if we''re using `setroubleshoot`, we will get a message like
    this in the system journal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.11 – setroubleshoot logging in the system journal'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16799_10_011.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.11 – setroubleshoot logging in the system journal
  prefs: []
  type: TYPE_NORMAL
- en: As we can see in the preceding screenshot, it already identified that one of
    the plugins suggests applying the command `restorecon` over the file, as it's
    not matching the one for the folder it's in, and even suggests the exact command
    to use for restoring the label.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another plugin suggests generating a custom policy using the following two
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: However, this kind of recommendation should be taken with knowledge of what
    is being done, which means that the preceding commands will fix `httpd_t` in terms
    of getting access to the `home_admin_t` file. We can learn about what would happen
    by only running the first command, together with the `audit2allow` pipe.
  prefs: []
  type: TYPE_NORMAL
- en: Running `ausearch –c 'httpd' --raw | audit2allow –M my-httpd` creates several
    files named `my-httpd` in the current folder, one named `my-httpd.te`, and another
    named `my-httpd.pp`. The second command that we will *not use* installs the modified
    policy, but please, don't ever do that until you have an understanding of what's
    going on, as we will see in the following lines.
  prefs: []
  type: TYPE_NORMAL
- en: 'The interesting file for us now is the `my-httpd.te` one (where *te* means
    *type enforcement*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: From there, we can see that it uses a requirements session for the types involved,
    and later, the rule itself, which allows `httpd_t` access to `admin_home_t` files
    for using the `getattr` function, nothing else, nothing more.
  prefs: []
  type: TYPE_NORMAL
- en: As has been said previously, will this fix our issue? It will effectively allow
    `httpd_t` to obtain access to the `index3.html` file, so there will no longer
    be any errors, but this comes with a significant cost. From that point, `httpd_t`
    could also read home directory files without any complaints.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: I don't know how many times this fact needs to be reinforced, but think twice
    before acting on a system. SELinux is a protection mechanism for increasing the
    safety of your system; do not disable it, do not blindly accept `audit2allow`
    created policies without some initial investigation and understanding of what
    the issue might be and what the proposed resolution does, as it may almost be
    equivalent to disabling SELinux.
  prefs: []
  type: TYPE_NORMAL
- en: 'If, at this point, we have installed that module, we can use `semodule` to
    do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: List `semodule -l`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Install `semodule -i $MODULE_NAME`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remove `semodule –r $MODULE_NAME`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the preceding commands, we can check or alter the current status for the
    policy-loaded modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'Going back to reviewing system logs, we may realize that something is actually
    failing sometime after it began, but not from the very beginning, so using `ausearch`
    or passing the full logs to `audit2allow` might not prove helpful; however, we
    can use the command suggested by `setroubleshootd` to list them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: If we execute `sealert –l <ID>`, we will receive the output provided by the
    different plugins to fix the issue as well as context information similar to what
    is shown in *Figure 10.11*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of new software being deployed that has no SELinux support, we
    can do the following checks the other way around in a test system:'
  prefs: []
  type: TYPE_NORMAL
- en: Set SELinux to `permissive` mode.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploy the software.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analyze all the alerts received to see whether anything is unexpected.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Contact software vendors and initiate a support case with Red Hat to work on
    a policy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In case we''re getting locked out of our system because SELinux is enforcing
    and we have badly messed the labels up, for example, by running a bad `chcon`
    command recursively against our root folder (for example, scripting a context
    change depending on a variable and that variable being empty), we still have the
    following ways to get out of trouble:'
  prefs: []
  type: TYPE_NORMAL
- en: Use `setenforce 0` to put SELinux in `permissive` mode.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run `touch /.autorelabel`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reboot the host so that at the next boot, SELinux restores the appropriate labels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we are in a really bad situation and, for example, are unable to use `setenforce
    0` or the system cannot even boot or perform relabeling correctly, there is still
    hope, but some additional steps are required.
  prefs: []
  type: TYPE_NORMAL
- en: When a system is rebooting, we can see the list of installed kernels at the
    grub prompt and use it to edit the kernel boot parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Using the `selinux=0` parameter, we completely disable SELinux, and this is
    something we don't want, but we can use `enforcing=0` to accomplish having SELinux
    enabled, but in `permissive` mode.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have our system booting into `permissive` mode, we can repeat the previous
    procedure to get back to the previous behavior and continue debugging the situation
    within the system itself with the prior indications given (checking system logs,
    and others).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter has introduced SELinux, how it works, how we can check the processes,
    files, and ports, and how to fine-tune them either by adding new options or using
    Booleans. We also covered several initial troubleshooting skills that we should
    explore further to enhance our knowledge and experience.
  prefs: []
  type: TYPE_NORMAL
- en: SELinux, as we've seen, is a powerful tool for keeping our system secured with
    an extra layer that protects our system even from unknown issues that might come
    from defects in the software itself.
  prefs: []
  type: TYPE_NORMAL
- en: We have covered how to find the SELinux context in files and processes, how
    those are applied via the policy, and how to tune it so that our system is protected
    and still able to provide the expected service.
  prefs: []
  type: TYPE_NORMAL
- en: Troubleshooting SELinux is a skill that will help us in adapting the software
    that doesn't come with Red Hat Enterprise Linux to still perform properly.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about security profiles with OpenSCAP to
    continue keeping our system safe.
  prefs: []
  type: TYPE_NORMAL
