- en: Chapter 3. Application Considerations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now it's time to deal with real-world applications! As mentioned before, one
    of Node.js platform's killer features is the wealth of modules and rapidly moving
    community. It is still important to audit every module that you use for security,
    but using modules is likely going to become an indispensable part of your workflow.
  prefs: []
  type: TYPE_NORMAL
- en: Because of its immense popularity, I will be writing my code examples to specifically
    targeting **Express** applications. This should cover the vast majority of Node.js
    applications out there today, but many of the concepts we will cover apply to
    any platform.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Express
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Express is a minimal web development framework for Node.js that focuses on remaining
    small, yet robust. It is built on top of another framework called **Connect**,
    which is a platform for writing HTTP servers with small plugins known as middleware.
  prefs: []
  type: TYPE_NORMAL
- en: The architecture of Connect and Express allows you to use only what you require,
    and nothing else. This works very nicely into the security discussion, as you
    aren't incorporating lots of functionality that you don't use, which leaves the
    doors open for security vulnerabilities that may go unchecked.
  prefs: []
  type: TYPE_NORMAL
- en: 'Connect is bundled with over 20 commonly used middleware, adding capabilities,
    such as logging, sessions, cookie parsing, request body parsing, and more. While
    defining a Connect or Express app, you simply add the middleware that you intend
    to use as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are creating an application with three middleware: `favicon`, `basicAuth`,
    and a custom one of our own. The first two are provided by Connect, and they can
    each take configuration to specify their exact behavior.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Middleware is always executed in the order it was attached, which is something
    to keep in mind while you are determining what and when to attach.
  prefs: []
  type: TYPE_NORMAL
- en: Connect uses continuation-passing style, which means that each middleware function
    is given control, and must pass control to the next middleware in the continuation
    when it has completed. In terms of our application here, each middleware is given
    the request and response object and has full control over the life cycle of the
    request.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since they are executed in order, let us examine how a request/response cycle
    operates for this application. Since middleware has full control, it can take
    one of the following three main courses of action:'
  prefs: []
  type: TYPE_NORMAL
- en: Respond to the request outright, ending the continuation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modify the request or response object for other middleware in the continuation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do nothing and simply initiate the next layer of middleware
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Luckily for us, we have examples of all the three right here! First, when an
    application comes into this server, it is run through the `favicon` middleware.
    It checks the **uniform resource identifier** (**URI**), and if it matches `/favicon.ico`,
    it responds with a `favicon` icon for the browser. If the URI does not match,
    it simply passes over to the next middleware.
  prefs: []
  type: TYPE_NORMAL
- en: Next up, if the request proceeds, is the `basicAuth` middleware. This prompts
    the user to provide a username and password combination using **HTTP Basic Authentication**
    . If the user does not provide the correct credentials, the server responds with
    **401 (Unauthorized)** and ends the request. If the user successfully provides
    the correct username and password, the request object is modified to include the
    user's information and then the next middleware is initiated.
  prefs: []
  type: TYPE_NORMAL
- en: Last up is our custom middleware, which is probably the simplest one you could
    have. All it does is send **Hello World** as the response body. This means that
    no matter what URI we request (other than `/favicon.ico` of course), and as long
    as we provide the correct credentials, we will see **Hello World**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you have a basic understanding of how middleware works, let''s move
    on to Express, and what it adds to Connect. Express adds routing, HTTP helpers,
    a view system, content negotiation, and other features using the Connect system.
    In fact, an Express app looks very similar to a Connect app as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Express automatically includes the Connect middleware within its own namespace,
    so you can use them without needing to explicitly require Connect. In addition,
    it adds some powerful features of its own, notably the routing feature we are
    using here.
  prefs: []
  type: TYPE_NORMAL
- en: Express was heavily inspired by the **Sinatra** web framework for **Ruby** .
    Each HTTP verb (`GET`, `POST`, and so on) has a corresponding function on the
    app object. Here, we are saying that an HTTP `GET` request for the URL `/` will
    send **Hello World**. Any other URL will get a **404 (Not Found)** error, except
    `/favicon.ico`, which is covered by the favicon middleware.
  prefs: []
  type: TYPE_NORMAL
- en: Express is minimalistic and remains out of your way to develop your application
    as you see fit. It doesn't lock you into an MVC framework, or a particular view
    engine, and allows you to include whatever npm modules you like to power your
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Authentication is a process of determining that a user is who they claim to
    be, when they are attempting to perform some action through your application.
    There are many ways to accomplish this, and I will cover some of the more common
    ones here. With a few exceptions, my examples will boil down to a couple of available
    npm modules. You are more than welcome to use others to accomplish the same goals.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP Basic Authentication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first is the **HTTP Basic Authentication**, and it is one of the simplest
    techniques available. It allows a username and password to be submitted along
    with an HTTP request, and allows the server to restrict access if the expected
    credentials are not sent.
  prefs: []
  type: TYPE_NORMAL
- en: While using a web browser, a page that requires the HTTP Basic Authentication
    will prompt the user with a dialog box asking for their username and password.
    After the user enters their information, the browser typically stores those credentials
    for a set period of time, rather than constantly prompting the user on each page.
  prefs: []
  type: TYPE_NORMAL
- en: The main advantage of this method is that it is very simple to implement. In
    fact, it can be done in as little as one line with Connect. In addition, this
    method is completely stateless and requires no out-of-band information with the
    request.
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of important disadvantages, first of which is that it is
    not confidential. In other words, a basic HTTP request includes the username and
    password in plain text. Technically it is encoded as `base64`, but that is not
    an encryption method. As a result, this technique must be combined with some sort
    of encryption, such as HTTPS. Otherwise, the request can be intercepted by packet
    sniffers, and the credentials are no longer secret.
  prefs: []
  type: TYPE_NORMAL
- en: Also, the efficiency of this method is less than ideal. When a request is made
    for a page that requires the HTTP Basic Authentication, the server effectively
    has to process that first request twice. On the first attempt, the request is
    denied, and the user needs to supply their credentials. On the second attempt,
    the credentials are sent with the request itself, and the server has to process
    the authentication again. Depending on how the username and password are validated,
    this can be an unacceptable delay that is incurred for each request.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, there is no implemented way for browsers to log out while using
    this method, aside from closing the browser itself. The credentials are stored
    by the browser, and the user is not prompted to control how long it is stored,
    or when it should expire. To my understanding, only Internet Explorer provides
    such a feature, but it requires JavaScript in order to be triggered.
  prefs: []
  type: TYPE_NORMAL
- en: Last, as a developer, you have no control over the appearance of the login screen;
    it is entirely up to the browser. While this could boil down to simple aesthetics,
    it could be argued that it is more secure than a custom solution. If you desire
    to implement it, it is very easy to do so. One of the bundled middleware that
    Connect (and by extension, Express) affords is for this very purpose. It is called
    the `basicAuth` middleware, and it can be configured in several ways.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While using middleware, remember the order is very important! Make sure to place
    your authentication middleware early in the chain so you are authenticating all
    your requests, and not running unnecessary processing before verifying your user's
    identity.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you can simply provide a single username and password to the middleware,
    giving you a single valid set of credentials for your application as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have set up our application to require the username `"admin"` and the
    password `"123456"` via the HTTP Basic Authentication. This is the simplest method
    of adding this authentication method.
  prefs: []
  type: TYPE_NORMAL
- en: 'A more advanced usage is to provide a synchronous callback function that can
    perform a slightly more sophisticated authentication scheme, for example, you
    can include a JavaScript object with username and password combinations that you
    can use to perform an in-memory lookup. This is illustrated in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We have set up `basicAuth` to check our `users` object for a corresponding username
    and password combination that is valid. If the callback function returns `true`,
    the authentication was successful. Otherwise, the authentication fails and the
    server responds appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: 'Both of the methods we just used require some sort of hardcoding of credentials
    within our application''s source code. The last method is more than likely the
    method you will employ if you use the HTTP Basic Authentication. This is asynchronous
    callback verification. This allows you to validate the request against some external
    source, such as a text file or database. Refer the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we have a similar configuration in that we are using a function
    parameter. This function, unlike the previous example, has three arguments. It
    receives the username and password as before, but also receives a callback function
    that it needs to execute, when it has finished validating the credentials. For
    the sake of brevity, I have not included specific implementation details.
  prefs: []
  type: TYPE_NORMAL
- en: The point is that you can perform the action asynchronously, and the callback
    function takes two parameters of its own. In Node.js fashion, the first parameter
    is an `Error` object, if the authentication fails. The second parameter is the
    user's information that will be added to `req.user` by the middleware, allowing
    the user's information to be accessed by later middleware functions.
  prefs: []
  type: TYPE_NORMAL
- en: After all is said and done, HTTP Basic Authentication is likely to be insufficient
    for most applications. Next, we will discuss **HTTP Digest Authentication** ,
    which was originally designed to be the successor to HTTP Basic Authentication.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP Digest Authentication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: HTTP Digest Authentication aims to be more secure than the HTTP Basic Authentication
    by not sending the credentials as plain text. Instead, it employs the **MD5**
    one-way hashing algorithm to encrypt the user's authentication information. It
    is worth noting that MD5 is no longer considered a safe algorithm, which is one
    strike against this particular mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: I am including this explanation simply for the sake of completeness. It is not
    popular and seldom recommended for use today, so I will not include any further
    details or examples.
  prefs: []
  type: TYPE_NORMAL
- en: It operates in the same way as the HTTP Basic Authentication in several ways.
    First, the initial request by the client is rejected when authentication is required,
    and the server indicates that the client needs to use the HTTP Digest Authentication.
    The client computes a hash of the user's credentials and the server's authentication
    realm. There are optional features available according to the specification for
    improving the hashing algorithms and preventing hijacking by malicious agents.
  prefs: []
  type: TYPE_NORMAL
- en: The one advantage that the HTTP Digest Authentication has is that the password
    is not transmitted over the network in plain text. This authentication method
    was devised in an era, where running HTTPS/SSL for all network transactions was
    prohibitively expensive both in terms of money and processing power. Now that
    era has passed, and you should be using HTTPS consistently through your application.
    With that being the case, the advantages of the HTTP Digest Authentication over
    the HTTP Basic Authentication are practically nonexistent.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Passport.js
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, I will be introducing a project that is a very popular authentication layer
    for Connect and Express applications. The project is Passport.js ([http://passportjs.org/](http://passportjs.org/)),
    and it is actually a collection of modules that aim to provide a consistent API
    for authenticating, using many different methods and providers. The rest of the
    examples for this section will use the Passport.js API, and I will explain some
    of the more common protocols along the way.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use Passport.js in your application, you will need to configure the following
    three pieces:'
  prefs: []
  type: TYPE_NORMAL
- en: Authentication strategies
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Application middleware
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sessions (optional)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Passport.js uses the term "strategies" to refer to a method of authenticating
    a request. This could be a username and password, even third-party authentication,
    such as OpenID, or OAuth. This is the first thing you will configure, and it will
    depend on what methods of authentication you choose to support.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a starting example, we''ll look at the local strategy, where you take an
    HTTP `POST` request with a username and password in the body to authenticate against
    your own data store as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'For the sake of simplicity, this does not wire into our application, this just
    demonstrates Passport.js middleware''s API. What we are doing here is configuring
    a local strategy. This strategy takes a single verify callback that has three
    arguments: the username, password, and a callback function to be called once the
    authentication is complete. (Passport.js handles extracting the username and password
    from the `POST` request) The callback function takes three arguments of its own:
    an `Error` object (if applicable), the user''s information (if applicable, false
    if the authentication fails), and an options hash.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, the verify callback calls some sort of user API (the specifics
    of that are not important) to find a user matching the supplied username, then
    it proceeds with that data into the following checks:'
  prefs: []
  type: TYPE_NORMAL
- en: If a fatal error occurs (such as the database is down, or the network is disconnected),
    then the callback is issued with that `Error` object as its only argument, which
    will be passed outside of Passport.js to be handled by your application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If that username does not exist, or the password is invalid, then the callback
    is issued with null as the first argument (since no error occurred), `false` as
    its second argument (since the authentication itself failed), and an object with
    a single `message` property that we can use to display a message to the user (this
    third argument is optional).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the user passes these checks, then the authentication was successful. The
    callback is issued with `null` first and the user's information object second.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The use of a callback in this fashion allows Passport.js to remain completely
    unaware of the underlying implementation. Now, let's move onto the middleware
    configuration step. Passport.js was specifically designed to use in Connect and
    Express applications, but it will work in anything that uses the same middleware
    style.
  prefs: []
  type: TYPE_NORMAL
- en: 'After configuring Passport.js and your strategies, you will need to attach
    at least one middleware to initialize Passport.js in your application as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a basic Express application, and we are attaching two Passport-related
    middleware: the initialization and the optional session support. Remember, the
    order is important, so you to initialize Passport.js after middleware like `bodyParser`
    and `session`, but before your application router.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The session-support middleware is optional, but recommended for most applications,
    as it is a very common use case, and it must be attached after Express'' own `session`
    middleware. Last, we will configure the session support itself as shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Storing all of the available user data, especially as the number of concurrent
    users increases, can be costly. As a result, Passport.js gives developers a way
    to configure what is stored into the session, as well as the ability to retrieve
    the user's data for a single request (rather than holding it constantly in memory).
    This is by no means required, as using a shared database to store your session
    information can alleviate this problem.
  prefs: []
  type: TYPE_NORMAL
- en: The `serializeUser` function in the preceding example receives a callback that
    is executed, when the session is being initialized. Here, we are storing only
    the user's ID into the session, keeping it as light as possible, while still giving
    us the information we need to find their information later.
  prefs: []
  type: TYPE_NORMAL
- en: The corresponding `deserializeUser` function is called on each subsequent request,
    and adds the corresponding user's data to the request object. In this case, we
    are using a generic API to find a user, based on their ID, and issuing the callback
    with that data.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, configuring and using Passport.js is easy and it fits right
    into the Connect and Express methodology. There are over 120 strategies available
    for Passport.js, and you can find much more documentation and examples on their
    website ([http://passportjs.org/](http://passportjs.org/)).
  prefs: []
  type: TYPE_NORMAL
- en: OpenID
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'OpenID is an open standard for authentication on the Web by the use of a third-party
    service. The aim is to allow users to have a single identity on the Web that they
    can then use with many applications, rather than needing to register with each
    individual application. OpenID has no central authority, each provider is independent,
    and the user may choose any provider that he trusts. There are many major providers
    out there today, including: Google, Yahoo!, PayPal, and many others.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The OpenID authentication process operates something like this (this is a simplified
    explanation): a user is presented with an OpenID login form by a consumer. The
    user enters their provider''s URL. The consumer redirects the user to their provider,
    the provider authenticates the user, and asks the user what information, if any,
    should be shared with the consumer. The provider then redirects the user back
    to the consumer, and the consumer allows the user to use their service.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To include OpenID in your application, we will use the `passport-openid` module.
    This module is a first class module of the Passport.js project, and it gives you
    a strategy for implementing a generic OpenID authentication process. First, let''s
    look at the following Passport.js configuration required:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We have included the `passport` and `passport-openid` modules, and have configured
    the OpenID strategy. The configuration object (first argument) has two required
    properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`returnURL`: This is the URL that the OpenID provider will redirect the user
    back to in your application'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`realm`: This is what the provider will show to the user to identify your application'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The second argument is the verify callback, which only takes two arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '`identifier`: This is how the user identifies himself with your application'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`done`: This is the callback your application issues after looking up the user
    based on the identifier'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, you will need to configure the Express routes that you need to process
    the login requests, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We have two configured routes, the first one takes the user's login request
    via `POST`, and Passport.js takes care of redirecting the user to the provider.
    The provider has been configured to send the user back to the `returnURL`, which
    corresponds to the second route we have configured earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, you will need an HTML form on your login page that `POST` to the route,
    we configured earlier. This is illustrated in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The only required HTML input is one that has the name `"openid_identifier"`.
    Each strategy has its own requirements, so make sure to read the documentation
    for each one as you are implementing them.
  prefs: []
  type: TYPE_NORMAL
- en: What we have configured here is a basic implementation of OpenID authentication
    using Passport.js. Now, we will move onto configuring a basic OAuth implementation
    for authentication as well.
  prefs: []
  type: TYPE_NORMAL
- en: Where OpenID aims to allow your identity to be authenticated by a trusted third-party,
    OAuth aims to allow users to share information between different applications
    without needing to give up their credentials to each separate party. If you need
    shared data with another service in your application, it is likely that you will
    be consuming an OAuth API from that particular service. If all you need is to
    verify an identity, OpenID will likely be the mechanism of choice for that service.
  prefs: []
  type: TYPE_NORMAL
- en: OAuth
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: OAuth allows a user to share resources from one application to another without
    needing to share their username and password with both services. In addition,
    it also has the added capability of giving limited access. This limitation can
    be time-based, where access is revoked after a certain amount of time elapses.
    It could also restrict access to only a particular set of data, and potentially
    give the user more control over what they decide to share.
  prefs: []
  type: TYPE_NORMAL
- en: This process works by using a few different sets of keys (three to be more precise).
    Each stage of the authorization process builds upon the previous set of keys to
    construct the keys for the next step. In addition, between each step the user
    is redirected between the other applications, ensuring that the user only gives
    each application the minimum amount of information needed. The explanation I will
    give here is simplified, and does not cover the more technical details about topics
    like encryption and signatures.
  prefs: []
  type: TYPE_NORMAL
- en: The best metaphor for what OAuth does is like a "valet key". Some luxury cars
    have a special key that is limited in access. What I mean is that this special
    key only allows the car to be driven for a short distance, and only allows the
    valet driver to access the car as long as they have that key. This is very similar
    to what OAuth accomplishes, it allows the owner to give temporary and limited
    access to a resource that they own, while never giving up full control of that
    resource.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are usually three parties involved: a `client`, a `server`, and a `resource
    owner`. The client is going to be requesting resources from the server on behalf
    of the resource owner.'
  prefs: []
  type: TYPE_NORMAL
- en: To use the same real-world example that the OAuth specification uses, imagine
    Jane has uploaded some personal photos to a photo-sharing site and wishes to have
    them printed by another online service.
  prefs: []
  type: TYPE_NORMAL
- en: In order for the print service (the client) to access the photos stored with
    the photo service (the server), they will need approval from Jane (the resource
    owner). First, any client application will need to register themselves with any
    server application in order to obtain the first set of keys, the client keys.
    These keys are known by both the client and server, and allow the server to validate
    the client's identity first and foremost.
  prefs: []
  type: TYPE_NORMAL
- en: Jane is ready to get her photos printed, so she visits the print service to
    begin the process. She wishes to have her photos pulled from the photo service
    rather than needing to upload them to another service, so she tells the print
    service that she would like photos from the photo service to be used.
  prefs: []
  type: TYPE_NORMAL
- en: Now, the printer service sends their client keys to the photo service (through
    a secured HTTPS request) to retrieve a set of temporary keys. These keys are used
    to identify a specified authorization request throughout the various redirects
    that take place.
  prefs: []
  type: TYPE_NORMAL
- en: Once the temporary keys are retrieved, the print service redirects Jane to the
    photo service. While there, Jane needs to verify her identity through whatever
    methods the photo service uses. In addition, the photo service can present Jane
    with options to limit the duration and scope of the authorization.
  prefs: []
  type: TYPE_NORMAL
- en: Once this verification is complete, Jane is redirected back to the print service
    with the temporary tokens. She has authorized the print service access to the
    photo service, which now exchanges the temporary keys for the last set of keys,
    the token keys.
  prefs: []
  type: TYPE_NORMAL
- en: This "access token" can now be used by the print service to request information
    from the photo service under the parameters that Jane has allowed, and can be
    revoked at any time by Jane or the photo service. Rather than using the generic
    `passport-oauth` module in the following examples I will stick to the Facebook
    module that uses OAuth v2.0\. I have chosen this path to avoid needing to show
    all the variations of OAuth in use today, since each implementation may have their
    own variations. In addition, the examples here will give enough of an introduction
    to Passport's API that you can apply the approach to any other provider.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will need to install the `passport-facebook` module, and then we
    will configure the Passport.js strategy as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In order to use Facebook authentication, you will need to create and register
    an application account with Facebook Developers ([https://developers.facebook.com/](https://developers.facebook.com/)).
    This will likely be a similar process for other services; you will need some sort
    of registration on their side in order to coordinate safely with their users.
    From there, you can obtain a `clientID` and a `clientSecret`, which you put into
    the preceding configuration. You will also need to specify a `callbackURL`, which
    behaves very much like the OpenID `returnURL`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, you will need to configure routes for your Express application as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This is very similar to the routes we set up for OpenID, but with one major
    difference. The initial route is not an HTML form `POST`; it is a simple HTTP
    `GET`. This means you can just set up a simple HTML anchor that will point them
    to this route as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Passport will send the user off to Facebook for authentication. When Facebook
    is finished, it will redirect back to the second route, where you can redirect
    the user as needed (just like the OpenID implementation).
  prefs: []
  type: TYPE_NORMAL
- en: Passport.js is a great API for abstracting all of your authentication needs,
    so dig into its API documentation ([http://passportjs.org/](http://passportjs.org/))
    and leverage any combination of the over 120 strategies they have available.
  prefs: []
  type: TYPE_NORMAL
- en: Authorization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Authorization is determining what access a user has to the restricted resources
    or actions in your application. Authentication deals specifically with who the
    user is, whereas authorization assumes we know who they are and must determine
    what they can do. Express gives us an elegant way of adding authorization built
    right into our routes, which is usually the layer where authorization takes place.
  prefs: []
  type: TYPE_NORMAL
- en: 'What many do not realize at first about express routing is that you are able
    to pass multiple handlers while defining a route. Each of them behaves like any
    other middleware as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Our restrict function checks for user data (assume it is set by our authentication
    layer), and if the user is valid, it allows the chain to proceed. If the user
    is not logged in, it will simply respond with **403 (Forbidden)**.
  prefs: []
  type: TYPE_NORMAL
- en: The point here is that you can use multiple route handlers as an opportunity
    to handle pre-conditions, such as checking the user's authentication status, their
    roles, or any other rules regarding access. Much of this is highly dependent on
    how you structure your application, and how you determine what the user has access
    to.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the more popular authorization schemes is role-based authorization.
    A user can have any number of roles, such as: `"member"`, `"moderator"` or `"admin"`.
    Each of these roles can be used to determine what access they have on a per-action
    basis.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have a list of available users. Assuming we have an
    authentication layer in place that loads a user profile data when logged in, let's
    look at the two middleware, we have defined.
  prefs: []
  type: TYPE_NORMAL
- en: First, `loadUser` is a simple middleware function that loads the user for the
    specified route (this may be a different user from the logged in user). Here,
    we just have a hard-coded list, but it could be a database call that we make asynchronously.
  prefs: []
  type: TYPE_NORMAL
- en: Second, the `requireRole` middleware is a bit sophisticated if you are not familiar
    with closure or first-class functions. What we are doing here is returning the
    middleware function, rather than simply using a named one. Through closure, we
    have access to the `role` argument inside the returned function. This middleware
    function ensures that the authenticated user has the role we are requiring.
  prefs: []
  type: TYPE_NORMAL
- en: We have two routes, the first (showing user data) is public, so it simply loads
    the user data via middleware and does no authorization check. The second route
    (deleting a user) requires that the authenticated user is an admin. If that check
    passes, the user's data is loaded and the route proceeds as expected.
  prefs: []
  type: TYPE_NORMAL
- en: There are many authorization methods available to you, with many good modules
    to pick from. Role-based authorization, as we have demonstrated here, is easy
    to implement in Express and it's generally easy to understand logically. As with
    authentication, your implementation depends on how you end up structuring your
    application. My main intent here is to define authorization and show you some
    examples to help you keep that mechanism as distinct as possible from the rest
    of your application logic.
  prefs: []
  type: TYPE_NORMAL
- en: Security logging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another important aspect of security is logging, or recording various events
    within your application so that they can be analyzed for anomalies. These anomalies
    could be reviewed to detect places where attackers are attempting to bypass your
    security methods, and by detecting these activities before an actual intrusion,
    further steps can be taken to mitigate those risks. Beyond just security, logging
    can also help to detect cases in your program that cause problems for your users,
    and allow you to more easily reproduce and fix those problems.
  prefs: []
  type: TYPE_NORMAL
- en: Your specific application and environment will be what drives your logging methods.
    By methods, I mean how your logs are recorded and stored, such as the use of flat
    files in your filesystem, using some sort of database or even using third-party
    logging services. While these may differ greatly from project to project, the
    types of events recorded and the related information to save should be fairly
    consistent across the board.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Open Web Application Security Project** (**OWASP**) has a great guide
    for determining a logging strategy on their website (visit [https://www.owasp.org/index.php/Logging_Cheat_Sheet](https://www.owasp.org/index.php/Logging_Cheat_Sheet)
    for further information). They recommend the following recording logs for these
    specific types of events:'
  prefs: []
  type: TYPE_NORMAL
- en: Input validation failures (for example, protocol violations, unacceptable encodings,
    invalid parameter names, and values)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Output validation failures (for example, database record set mismatch and invalid
    data encoding)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authentication successes and failures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authorization failures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Session management failures (for example, cookie session identification value
    modification)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application errors and system events (for example, syntax and runtime errors,
    connectivity problems, performance issues, third party service error messages,
    file system errors, file upload virus detection, and configuration changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application and related systems start-ups and shut-downs, and logging initialization
    (starting and stopping)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use of higher-risk functionality (for example, network connections, addition
    or deletion of users, changes to privileges, assigning users to tokens, adding
    or deleting tokens, use of administrative privileges, access by application administrators,
    access to payment cardholder data, use of data encrypting keys, key changes, creation
    and deletion of system-level objects, data import and export including screen-based
    reports, and submission of user-generated content especially file uploads)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Legal and other opt-ins (for example, permissions for mobile phone capabilities,
    terms of use, terms and conditions, personal data usage consent, and permission
    to receive marketing communications)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In addition to their recommendations, OWASP also presents the following events
    as optional:'
  prefs: []
  type: TYPE_NORMAL
- en: Sequencing failure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Excessive use
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fraud and other criminal activities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Suspicious, unacceptable, or unexpected behavior
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modifications to configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application code file and/or memory changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'While determining what data to store for logs, OWASP recommends avoiding the
    following types of data:'
  prefs: []
  type: TYPE_NORMAL
- en: Application source code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Session identification values (consider replacing with a hashed value if needed
    to track session specific events)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Access tokens
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sensitive personal data and some forms of personally identifiable information
    (PII)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Authentication passwords
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Database connection strings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encryption keys
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bank account or payment card holder data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data of a higher security classification than the logging system is allowed
    to store
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Commercially-sensitive information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Information it is illegal to collect in the relevant jurisdiction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Information a user has opted out of collection, or not consented to, for example,
    use of do not track, or where consent to collect has expired
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In some cases, the following information can be useful during investigations,
    but should be carefully reviewed before including it in application logs:'
  prefs: []
  type: TYPE_NORMAL
- en: File paths
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Database connection strings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Internal network names and addresses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Non sensitive personal data (for example, personal names, telephone numbers,
    e-mail addresses)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because each application and environment is different, the approaches logging
    can be equally diverse. The npm module we will look at here aims to provide a
    consistent API across many different methods, in addition to allowing you to use
    more than one at a time depending on the context.
  prefs: []
  type: TYPE_NORMAL
- en: The winston module ([https://github.com/flatiron/winston](https://github.com/flatiron/winston))
    provides a clean and easy to use API for writing logs. In addition, it supports
    many methods of logging, including the capability for adding your own custom transports.
    A transport can be described as the storage or display mechanism for a given set
    of logs.
  prefs: []
  type: TYPE_NORMAL
- en: The `winston` module has built-in transports (as known as core modules) for
    logging to the console, logging to a file and sending logs over HTTP. Beyond the
    core modules, there are officially supported modules for transports, such as `CouchDB`,
    `Redis`, `MongoDB`, `Riak`, and `Loggly`. Lastly, there is a vibrant community
    using the `winston` API as well, with over 23 different custom transports out
    there today, including an e-mail transport and various cloud services like Amazon's
    **SimpleDB** and **Simple Notification Service** (**SNS**). The point is, it is
    likely that whatever transport you may require for your logging, there may be
    a module already available, and of course you are always able to write your own
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started with `winston`, install in via npm and you can use it right
    away using the "default logger" as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This is by far the easiest way to get started quickly with `winston`, but it
    only uses the console transport by default. While the default logger can be extended
    with more transports and configuration, the more flexible approach is to create
    your own instances of `winston` that you can use in various contexts within your
    application. This can be done as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Within your application code, I typically place the boilerplate code for such
    modules in their own file. From there, you can export a pre-configured object
    that can be imported and used throughout your application, for example, you can
    create a file called `lib/logger.js` that looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Then within other parts of your application, you can include the logger and
    use it easily as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In addition, `winston` also includes other advanced features, such as custom
    log levels, additional transport configuration, and dealing with unhandled exceptions.
    Also, `winston` is not the only logging API available for Node.js, there are other
    alternatives that you can consider depending on your own needs. This is not even
    to mention developing your own custom solution to give you complete control.
  prefs: []
  type: TYPE_NORMAL
- en: Error handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the important aspects of any application is how it handles errors. As
    mentioned before, uncaught exceptions can crash your application, so being able
    to handle errors properly is an important part of your development cycle.
  prefs: []
  type: TYPE_NORMAL
- en: Responding to errors within your own application is the key, so refer back to
    [Chapter 2](ch02.html "Chapter 2. General Considerations"), *General Considerations*,
    for a general introduction to how to deal with errors in Node.js. Here, we will
    deal specifically with Connect and Express.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, do not throw errors directly in your route handlers. While Express is
    smart enough to try/catch errors directly on the route handler, this will not
    help you if you are performing some sort of asynchronous operation (this is the
    case most of the time), as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Both of the preceding handlers throw exceptions. As mentioned before, Express
    will execute your handler in a `try/catch` to handle exceptions thrown in the
    handler itself. However, asynchronous code, such as the second route does not
    work with typical try/catch and end up becoming uncaught exceptions. In short,
    don't use `throw` while handling errors!
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the request and response objects passed to your handlers, there
    is a third argument you can utilize like any other middleware. This is commonly
    named the "next" callback, and you use it like you would in middleware, to pass
    along to the next item in the continuation. This is illustrated in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: If you execute the next callback with an `Error` object as the first argument,
    then Connect will take that error and delegate to any error-handling middleware
    that you have configured. When you set up a middleware that takes four arguments,
    it is always treated as error-handling middleware.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This special error-handling middleware goes last in your application stack,
    and you are able to set up more than one if that is necessary. You can pass along
    control via next like any other middleware, in case you set up multiple layers
    of error-handling, for example, one layer can send an e-mail, one can log to a
    file, and one (the last one) can send a response to the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Connect also has a special middleware that you can utilize to deal with errors
    without needing to hard code your own middleware. This is the `errorHandler` middleware,
    and it will automatically respond with either plain text, JSON, or HTML (depending
    on the client''s headers) when an error occurs. This middleware is expressed as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Typically, this helper is just for development use, as your production application
    likely has more work to do when dealing with errors you need to be in complete
    control of.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, always use the "next" callback function in your route handlers to
    communicate errors, never use throw. In addition, always configure some sort of
    error-handling middleware by adding a middleware function with four arguments.
    Use the built-in handler from Connect for development, and have your own place
    for production.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we examined high-level security considerations that apply to
    applications in general, such as authentication, authorization, and error-handling.
    In the next chapter, we will examine vulnerabilities that appear during the request
    phase of your applications.
  prefs: []
  type: TYPE_NORMAL
