- en: Basics of Asynchronous Programming in Node.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you''ve read any article about Node, you''d have probably come across four
    terms: asynchronous, non-blocking, event-based, and single-threaded. All of those
    are accurate terms to describe Node; the problem is it usually stops there, and
    it''s really abstract. The topic of asynchronous programming in Node.js has been
    divided into three chapters. The goal in these upcoming three chapters is to make
    asynchronous programming super practical by putting all these terms to use in
    our weather application. That''s the project we''re going to be building in these
    chapters.'
  prefs: []
  type: TYPE_NORMAL
- en: This chapter is all about the basics of asynchronous programming. We'll look
    into the basic concepts, terms, and technology related to async programming. We'll
    look into making requests to Geolocation APIs. We'll need to make asynchronous
    HTTP requests. Let's dive in, looking at the very basics of async programming
    in Node.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, we''ll look into the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The basic concept of asynchronous program
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Call stack and event loop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Callback functions and APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTTPS requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The basic concept of asynchronous program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we're going to create our first asynchronous non-blocking program.
    This means our app will continue to run while it waits for something else to happen.
    In this section, we'll look at a basic example; however, in the chapter, we'll
    be building out a weather app that communicates with third-party APIs, such as
    the Google API and a weather API. We'll need to use asynchronous code to fetch
    data from these sources.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this, all we need to do is make a new folder on the desktop for this chapter.
    I''ll navigate onto my desktop and use `mkdir` to make a new directory, and I''ll
    call this one `weather-app`. All I need to do is navigate into the weather app:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/04b2a143-975a-478c-8e13-e45f3c7b0cc7.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, I'll use the `clear` command to clear the Terminal output.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can open up that new `weather app` directory inside of Atom:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ac8857e7-30de-4a55-9e5c-67806357a18c.png)'
  prefs: []
  type: TYPE_IMG
- en: This is the directory we'll use throughout this entire chapter. In this section,
    we'll not be building out the weather app just yet, we'll just play around with
    the async features. So inside `weather-app` we'll make the `playground` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'This code is not going to be a part of the weather app, but it will be really
    useful when it comes to creating the weather app in the later sections. Now inside
    `playground`, we can make the file for this section. We''ll name it `async-basics.js`
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/96badf4f-66db-407f-8eeb-17b0fcd09f0b.png)'
  prefs: []
  type: TYPE_IMG
- en: Illustrating the async programming model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To illustrate how the asynchronous programming model works, we''ll get started
    with a simple example using `console.log`. Let''s get started by adding a couple
    of `console.log` statements in a synchronous way. We''ll create one `console.log`
    statement at the beginning of the app that will say `Starting app`, and we will
    add a second one to the end, and the second one will print `Finishing up`, as
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Now these are always going to run synchronously. No matter how many times you
    run the program, `Starting app` is always going to show up before `Finishing up`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to add some asynchronous code, we''ll take a look at a function that
    Node provides called `setTimeout`. The `setTimeout` function is a great method
    for illustrating the basics of non-blocking programming. It takes two arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: The first one is a function. This will be referred to as callback function,
    and it will get fired after a certain amount of time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second argument is a number, which tells the number of milliseconds you
    want to wait. So if you want to wait for one second, you would pass in a thousand
    milliseconds.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s call `setTimeout`, passing in an arrow function (`=>`) as our first
    argument. This will be callback function. It will get fired right away; that is,
    it will get fired after the timeout is up, after our two seconds. And then we
    can set up our second argument which is the delay, `2000` milliseconds, which
    equals those two seconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the arrow function (`=>`), all we''ll do is use a `console.log` statement
    so that we can figure out exactly when our function fires, because the statement
    will print to the screen. We''ll add `console.log` and then inside callback to
    get the job done, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'With this in place, we''re actually ready to run our very first async program,
    and I''ll not use `nodemon` to execute it. I''ll run this file from the Terminal
    using the basic Node command; `node playground` and the file inside the `playground`
    folder which is `async-basic.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now pay close attention to exactly what happens when we hit e*nter*. We''ll
    see two messages show up right away, then two seconds later our final message,
    `Inside of callback`, prints to the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/510326df-2908-422e-b443-97b9c45037b7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The sequence in which these messages are shown is: first we got `Starting app`;
    almost immediately after this, `Finishing up` prints to the screen and finally
    (two seconds later), `Inside of callback` was printed as shown in the previous
    code. Inside the file, this is not the order in which we wrote the code, but it
    is the order the code executes in.'
  prefs: []
  type: TYPE_NORMAL
- en: The `Starting app` statement prints to the screen as we expect. Next, we call
    `setTimeout`, but we're not actually telling it to wait two seconds. We're registering
    a callback that will get fired in two seconds. This will be an asynchronous callback,
    which means that Node can do other things while these two seconds are happening.
    In this case, the other thing it moves down to the `Finishing up` message. Now
    since we did register this callback by using `setTimeout`, it will fire at some
    point in time, and two seconds later we do see `Inside of callback` printing to
    the screen.
  prefs: []
  type: TYPE_NORMAL
- en: By using non-blocking I/O, we're able to wait, in this case two seconds, without
    preventing the rest of the program from executing. If this was blocking I/O, we
    would have to wait two seconds for this code to fire, then the `Finishing up`
    message would print to the screen, and obviously that would not be ideal.
  prefs: []
  type: TYPE_NORMAL
- en: Now this is a pretty contrived example, we will not exactly use `setTimeout`
    in our real-world apps to create unnecessary arbitrary delays, but the principles
    are the same. For example, when we fetch data from the Google API we'll need to
    wait about 100 to 200 milliseconds for that data to come back, and we don't want
    the rest of the program to just be idle, it will continue. We'll register a callback,
    and that callback will get fired once the data comes back from the Google servers.
    The same principles applies even though what's actually happening is quite different.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we want to write another `setTimeout` right here. We want to register
    a `setTimeout` function that prints a message; something like `Second setTimeout
    works`. This will be inside the callback, and we want to register a delay of `0`
    milliseconds, no delay at all. Let''s fill out the async basics `setTimeout`.
    I''ll call `setTimeout` with my arrow function (`=>`), passing in a delay of `0`
    milliseconds, as shown in the following code. Inside the arrow function (`=>`),
    I''ll use `console.log` so I can see exactly when this function executes, and
    I''ll use `Second setTimeout` as the text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have this in place, we can run the program from the Terminal, and
    it''s really important to pay attention to the order in which the statements print.
    Let''s run the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Right away we get three statements and then at the very end, two seconds later,
    we get our final statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/23b9c478-6bd3-439f-a4a1-3a0eed3ad0dd.png)'
  prefs: []
  type: TYPE_IMG
- en: We start with `Starting app`, which makes sense, it's at the top. Then we get
    `Finishing up`. After `Finishing up` we get `Second setTimeout`, which seems weird,
    because we clearly told Node we want to run this function after `0` milliseconds,
    which should run it right away. But in our example, `Second setTimeout` printed
    after `Finishing up`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, `Inside of callback` printed to the screen. This behavior is completely
    expected. This is exactly how Node.js is supposed to operate, and it will become
    a lot clearer after the next section, where we'll go through this example exactly,
    showing you what happens behind the scenes. We'll get started with a more basic
    example showing you how the call stack works, we'll talk all about that in the
    next section, and then we'll go on to a more complex example that has some asynchronous
    events attached to it. We'll discuss the reason why `Second setTimeout` comes
    up after the `Finishing up` message after the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Call stack and event loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last section, we ended up creating our very first asynchronous application,
    but unfortunately we ended up asking more questions than we got answers. We don't
    exactly know how async programming works even though we've used it. Our goal for
    this section is to understand why the program runs the way it does.
  prefs: []
  type: TYPE_NORMAL
- en: For example, why does the two-second delay in the following code not prevent
    the rest of the app from running, and why does a `0` second delay cause the function
    to be executed after `Finishing up` prints to the screen?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: These are all questions we'll answer in this section. This section will take
    you behind the scenes into what happens in V8 and Node when an async program runs.
    Now let's dive right into how the async program runs. We'll start with some basic
    synchronous examples and then move on to figuring out exactly what happens in
    the async program.
  prefs: []
  type: TYPE_NORMAL
- en: A synchronous program example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following is example number one. On the left-hand side we have the code,
    a basic synchronous example, and on the right-hand side we have everything that
    happens behind the scenes, the Call Stack, our Node APIs, the Callback Queue,
    and the Event Loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9462dc2e-caf3-45d0-ac4e-b9dc70e780b2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now if you've ever read an article or watched any video lesson on how Node works,
    you've most likely heard about one or more of these terms. In this section, we'll
    be exploring how they all fit together to create a real-world, working Node application.
    Now for our first synchronous example, all we need to worry about is the Call
    Stack. The Call Stack is part of a V8, and for our synchronous example it's the
    only thing that's going to run. We're not using any Node APIs and we're not doing
    any asynchronous programming.
  prefs: []
  type: TYPE_NORMAL
- en: The call stack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Call Stack is a really simple data structure that keeps track of program
    execution inside of a V8\. It keeps track of the functions currently executing
    and the statements that are fired. The Call Stack is a really simple data structure
    that can do two things:'
  prefs: []
  type: TYPE_NORMAL
- en: You can add something on top of it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can remove the top item
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This means if there's an item at the bottom of the data structure and there's
    an item above it, you can't remove the bottom item, you have to remove the top
    item. If there's already two items and you want to add something on to it, it
    has to go on because that's how the Call Stack works.
  prefs: []
  type: TYPE_NORMAL
- en: 'Think about it like a can of Pringles or a thing of tennis balls: if there''s
    already an item in there and you drop one in, the item you just dropped will not
    be the bottom item, it''s going to be the top item. Also, you can''t remove the
    bottom tennis ball from a can of tennis balls, you have to remove the one on top
    first. That''s exactly how the Call Stack works.'
  prefs: []
  type: TYPE_NORMAL
- en: Running the synchronous program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now when we start executing the program shown in the following screenshot, the
    first thing that will happen is Node will run the main function. The main function
    is the wrapper function we saw over in nodemon (refer to, *Installing the nodemon
    module* section in [Chapter 2](9e56dc82-3ad8-4376-81b7-27ba482bd4e2.xhtml), *Node
    Fundamentals Part-1*) that gets wrapped around all of our files when we run them
    through Node. In this case, by telling V8 to run the main function we are starting
    the program.
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in the following screenshot, the first thing we do in the program
    is create a variable `x`, setting it equal to `1`, and that''s the first statement
    that''s going to run:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/70060c29-23bb-4f89-b2fa-cfc7b5d7cd0f.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Notice it comes in on top of main. Now this statement is going to run, creating
    the variable. Once it''s done, we can remove it from the Call Stack and move on
    to the next statement, where we make the variable `y`, which gets set equal to
    `x`, which is `1` plus `9`. That means `y` is going to be equal to `10`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/19d054e3-7f09-4d91-8de5-fef056d46fcb.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As shown in the previous screenshot, we do that and move on to the next line.
    The next line is our `console.log` statement. The `console.log` statement will
    print `y` is `10` to the screen. We use template strings to inject the `y` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run this line it gets popped on to the Call Stack, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/306ebfce-aff9-4024-a01e-0bbed6a0d391.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Once the statement is done, it gets removed. At this point, we've executed all
    the statements inside our program and the program is almost ready to be complete.
    The main function is still running but since the function ends, it implicitly
    returns, and when it returns, we remove main from the Call Stack and the program
    is finished. At this point, our Node process is closed. Now this is a really basic
    example of using the Call Stack. We went into the main function, and we moved
    line by line through the program.
  prefs: []
  type: TYPE_NORMAL
- en: A complex synchronous program example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s go over a slightly more complex example, our second example. As shown
    in the following code, we start off by defining an `add` function. The `add` function
    takes arguments `a` and `b`, adds them together storing that in a variable called
    `total`, and returns `total`. Next, we add up `3` and `8`, which is `11`, storing
    it in the `res` variable. Then, we print out the response using the `console.log`
    statement, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s it, nothing synchronous is happening. Once again we just need the Call
    Stack. The first thing that happens is we execute the main function; this starts
    the program we have here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6ec5b5ab-7d5e-462c-a768-7e8e0ea744ad.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Then we run the first statement where we define the `add` variable. We''re
    not actually executing the function, we''re simply defining it here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/63ff443b-843d-4f82-b65a-9a1c92420682.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding image, the `add()` variable gets added on to the Call Stack,
    and we define `add`. The next line, line `7`, is where we call the `add` variable
    storing the return value on the response variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dc68ead6-954e-4a52-96b6-2a28c73d04b1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you call a function, it gets added on top of the Call Stack. When you return
    from a function, it gets removed from the Call Stack.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we''ll call a function. So we''re going to add `add()` on
    to the Call Stack, and we''ll start executing that function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/014ad652-75db-4d3b-a2f4-261afbacce6a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As we know, when we add main we start executing main and, when we add `add()`
    we start executing add. The first line inside `add` sets the `total` variable
    equal to `a + b`, which would be `11`. We then return from the function using
    the `return total` statement. That''s the next statement, and when this runs,
    `add` gets removed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6194fada-6e7e-45a8-b471-18aa71102281.png)'
  prefs: []
  type: TYPE_IMG
- en: 'So when `return total` finishes, `add()` gets removed, then we move on to the
    final line in the program, our `console.log` statement, where we print `11` to
    the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b78be88d-6449-4055-8f3c-051c24e50d8a.png)'
  prefs: []
  type: TYPE_IMG
- en: The `console.log` statement will run, print `11` to the screen and finish the
    execution, and now we're at the end of the main function, which gets removed from
    the stack when we implicitly return. This is the second example of a program running
    through the V8 Call Stack.
  prefs: []
  type: TYPE_NORMAL
- en: An async program example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far we haven''t used Node APIs, the Callback Queue, or the Event Loop. The
    next example will use all four (Call Stack, the Node APIs, the Callback Queue,
    and the Event Loop). As shown on the left-hand side of the following screenshot,
    we have our async example, exactly the same as we wrote it in the last section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e43204f3-ed6a-49d5-a851-f00f726b4741.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In this example, we will be using the Call Stack, the Node APIs, the Callback
    Queue, and the Event Loop. All four of these are going to come into play for our
    asynchronous program. Now things are going to start off as you might expect. The
    first thing that happens is we run the main function by adding it on to the Call
    Stack. This tells a V8 to kick off the code we have on the left side in the previous
    screenshot, shown here again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The first statement in this code is really simple, a `console.log` statement
    that prints `Starting app` to the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2d83849c-ded9-4fde-86a4-9d8840f0ba69.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This statement runs right away and we move on to the second statement. The
    second statement is where things start to get interesting, this is a call to `setTimeout`,
    which is indeed a Node API. It''s not available inside a V8, it''s something that
    Node gives us access to:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7b6ac225-620b-4319-ad4a-5c77643b586a.png)'
  prefs: []
  type: TYPE_IMG
- en: The Node API in async programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we call the `setTimeout (2 sec)` function, we''re actually registering
    the event callback pair in the Node APIs. The event is simply to wait two seconds,
    and the callback is the function we provided, the first argument. When we call
    `setTimeout`, it gets registered right in the Node APIs as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/60a18658-2f1b-4eb0-bb20-6ce701ece9f2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now this statement will finish up, the Call Stack will move on, and the `setTimeout`
    will start counting down. Just because the `setTimeout` is counting down, it doesn''t
    mean the Call Stack can''t continue to do its job. The Call Stack can only run
    one thing at a time, but we can have events waiting to get processed even when
    the Call Stack is executing. Now the next statement that runs is the other call
    to `setTimeout`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e7d396b0-ba1e-4070-b54c-6f456ba39ad6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In this, we register a `setTimeout` callback function with a delay of `0` milliseconds,
    and the exact same thing happens. It''s a Node API and it''s going to get registered
    as shown in the following screenshot. This essentially says that after zero seconds,
    you can execute this callback:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/110b8bc0-920b-4467-9024-0bb618a6985c.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `setTimeout (0 sec)` statement gets registered and the Call Stack removes
    that statement.
  prefs: []
  type: TYPE_NORMAL
- en: The callback queue in async programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At this point let''s assume that `setTimeout`, the one that has a zero second
    delay, finishes. When it finishes, it''s not going to get executed right away;
    it''s going to take that callback and move it down into the Callback Queue, as
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/74fbf540-71b8-499a-a7cf-2da14ed034de.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The Callback Queue is all the callback functions that are ready to get fired.
    In the previous screenshot, we move the function from Node API into the Callback
    Queue. Now the Callback Queue is where our callback functions will wait; they
    need to wait for the Call Stack to be empty.
  prefs: []
  type: TYPE_NORMAL
- en: When the Call Stack is empty we can run the first function. There's another
    function after it. We'll have to wait for that first function to run before the
    second one does, and this is where the Event Loop comes into play.
  prefs: []
  type: TYPE_NORMAL
- en: The event loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Event Loop takes a look at the Call Stack. If the Call Stack is not empty,
    it doesn't do anything because it can't, there is nothing it can do you can only
    run one thing at a time. If the Call Stack is empty, the Event Loop says great
    let's see if there's anything to run. In our case, there is a callback function,
    but because we don't have an empty Call Stack, the Event Loop can't run it. So
    let's move on with the example.
  prefs: []
  type: TYPE_NORMAL
- en: Running the async code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next thing that happens in our program is we run our `console.log` statement,
    which prints `Finishing up` to the screen. This is the second message that shows
    up in the Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6b591f34-12a2-410f-b7d2-3911a9d3f9d3.png)'
  prefs: []
  type: TYPE_IMG
- en: This statement runs, our main function is complete, and it gets removed from
    the Call Stack.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, the Event Loop says hey I see that we have nothing in the call
    stack and we do have something in the Callback Queue, so let''s run that callback
    function. It will take the callback and move it into the Call Stack; this means
    the function is executing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7ee2ab4f-d118-48c1-bf7f-aecc519e88c5.png)'
  prefs: []
  type: TYPE_IMG
- en: It will run the first line which is sitting on line `8`, `console.log`, printing
    `Second setTimeout` to the screen. This is why `Second setTimeout` shows up after
    `Finishing up` in our previous section examples, because we can't run our callback
    until the Call Stack is complete. Since `Finishing up` is part of the main function,
    it will always run before `Second setTimeout`.
  prefs: []
  type: TYPE_NORMAL
- en: 'After our `Second setTimeout` statement finishes, the function is going to
    implicitly return and callback will get removed from the Call Stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0e185b6b-e029-4292-91f9-cf15147fe72c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'At this point, there''s nothing in the Call Stack and nothing in the Callback
    Queue, but there is still something in our Node APIs, we still have an event listener
    registered. So the Node process is not yet completed. Two seconds later, the `setTimeout(2
    sec)` event is going to fire, and it''s going to take that callback function and
    move it into the Callback Queue. It gets removed from the Node APIs and it gets
    added to the Callback Queue:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b50be7e7-2306-42f7-8a85-d2b2b31d6a67.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At this point, the Event Loop will take a look at the Call Stack and see it''s
    empty. Then it will take a quick look at the Callback Queue and see there is indeed
    something to run. What will it do? It will take that callback, add it on to the
    Call Stack, and start the process of executing it. This means that we''ll run
    our one statement inside callback. After that''s finished, the callback function
    implicitly returns and our program is complete:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e2aea224-9be5-4a15-b9ef-7d950c526818.png)'
  prefs: []
  type: TYPE_IMG
- en: This is exactly how our program ran. This illustrates how we're able to register
    our events using Node APIs, and why when we use a `setTimeout` of zero the code
    doesn't run right away. It needs to go through the Node APIs and through the Callback
    Queue before it can ever execute on the Call Stack.
  prefs: []
  type: TYPE_NORMAL
- en: Now as I mentioned in the beginning of this section, the Call Stack, the Node
    APIs, the Callback Queue, and the Event Loop are pretty confusing topics. A big
    reason why they're confusing is because we never actually directly interact with
    them; they're happening behind the scenes. We're not calling the Callback Queue,
    we're not firing an Event Loop method to make these things work. This means we're
    not aware they exist until someone explains them. These are topics that are really
    hard to grasp the first time around. By writing real asynchronous code it's going
    to become a lot clearer how it works.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we got a little bit of an idea about how our code executes behind the
    scenes, we'll move on with the rest of the chapter and start creating a weather
    app that interacts with third-party APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Callback functions and APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll take an in-depth look at callback functions, and use
    them to fetch some data from a Google Geolocation API. That's going to be the
    API that takes an address and returns the latitude and longitude coordinates,
    and this is going to be great for the weather app. This is because the weather
    API we use requires those coordinates and it returns the real-time weather data,
    such as the temperature, five-day forecast, wind speed, humidity, and other pieces
    of weather information.
  prefs: []
  type: TYPE_NORMAL
- en: The callback function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we get started making the HTTPS request, let''s talk about callback
    functions, and we have already used them. Refer to the following code (we used
    it in the previous section):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `setTimeout` function we used a `callback` function. In general,
    a `callback` function is defined as a function that gets passed as an argument
    to another function and is executed after some event happens. Now this is a general
    definition, there is no strict definition in JavaScript, but it does satisfy the
    function in this case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Here we have a function and we pass it as an argument to another function, `setTimeout`,
    and it does get executed after some event—two-second pass. Now the event could
    be other things, it could be a database query finishes, it could be an HTTP request
    comes back. In those cases, you will want a callback function, like the one in
    our case, to do something with that data. In the case of `setTimeout`, we don't
    get any data back because we're not requesting any; we're just creating an arbitrary
    delay.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the callback function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now before we actually make an HTTP request to Google, let''s create a callback
    function example inside our `playground` folder. Let''s make a new file called
    `callbacks.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/13d07457-a4b6-4ac5-a217-c8f4465160f4.png)'
  prefs: []
  type: TYPE_IMG
- en: Inside the file, we'll create a contrived example of what a callback function
    would look like behind the scenes. We'll be making real examples throughout the
    book and use many functions that require callbacks. But for this chapter, we'll
    start with a simple example.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started, let''s make a variable called `getUser`. This will be the function
    we''ll define that will show us exactly what happens behind the scenes when we
    pass a callback to another function. The `getUser` callback will be something
    that simulates what it would look like to fetch a user from a database or some
    sort of web API. It will be a function, so we''ll set it as such using arrow function
    (`=>`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The arrow function (`=>`) is going to take some arguments. The first argument
    it will take is the `id`, which will be some sort of a unique number that represents
    each user. I might have an `id` of `54`, you might have an `id` of `2000`; either
    way we''re going to need the `id` to find a user. Next up we''ll get a callback
    function, which is what we will call later with the data, with that user object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This is exactly what happens when you pass a function to `setTimeout`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `setTimeout` function definition looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`var getUser = (callback, delay) => {`'
  prefs: []
  type: TYPE_NORMAL
- en: '`};`'
  prefs: []
  type: TYPE_NORMAL
- en: It has a callback and a delay. You take the callback, and after a certain amount
    of time passes, you call it. In our case, though, we'll switch the order with
    an `id` first and the callback second.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can call this function before actually filling it out. We''ll call `getUser`,
    just like we did with `setTimeout` in the previous code example. I''ll call `getUser`,
    passing in those two arguments. The first one will be some `id`; since we''re
    faking it for now it doesn''t really matter, and I''ll go with `31`. The second
    argument will be the function that we want to run when the user data comes back,
    and this is really important. As shown, we''ll define that function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the callback alone isn''t really useful; being able to run this function
    after the user data comes back only works if we actually get the user data, and
    that''s what we''ll expect here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll expect that the `user` objects, things like `id`, `name`, `email`, `password`,
    or whatever, comes back as an argument to the callback function. Then inside the
    arrow function (`=>`), we can actually do something with that data, for example,
    we could show it on a web app, respond to an API request, or in our case we can
    simply print it to the console, `console.log(user)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have the call in place, let's fill out the `getUser` function to
    work like we have it defined.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing I''ll do is create a dummy object that''s going to be the `user`
    object. In the future, this is going to come from database queries, but for now
    we''ll just create a variable `user` setting it equal to some object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s set an `id` property equal to whatever `id` the user passes in, and
    we''ll set a `name` property equal to some name. I''ll use `Vikram`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our `user` object, what we want to do is call the callback,
    passing it as an argument. We''ll then be able to actually run, `getUser(31, (user)`
    function, printing the `user` to the screen. In order to do this, we would call
    the callback function like any other function, simply referencing it by name and
    adding our parentheses like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now if we call the function like this, we''re not passing any data from `getUser`
    back to the callback. In this case, we''re expecting a `user` to get passed back,
    which is why we are going to specify `user` as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the naming isn''t important, I happen to call it `user`, but I could easily
    call this `userObject` and `userObject` as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: All that matters is the arguments, position. In this case, we call the first
    argument `userObject` and the first argument pass back is indeed that `userObject`.
    With this in place we can now run our example.
  prefs: []
  type: TYPE_NORMAL
- en: Running the callback function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the Terminal, we''ll run the callback function using `node`, which is in
    the `playground` folder, and we call the file `callbacks.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run the file, right away our data prints to the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/376f22d6-d06e-41ce-9522-2f56296d9fb6.png)'
  prefs: []
  type: TYPE_IMG
- en: We've created a callback function using synchronous programming. Now as I mentioned,
    this is still a contrived example because there is no need for a callback in this
    case. We could simply return the user object, but in that case, we wouldn't be
    using a callback, and the whole point here is to explore what happens behind the
    scenes and how we actually call the function that gets passed in as an argument.
  prefs: []
  type: TYPE_NORMAL
- en: Simulating delay using setTimeout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we can also simulate a delay using `setTimeout`, so let''s do that. In
    our code, just before the `callback (user)` statement, we''ll use `setTimeout`
    just like we did before in the previous section. We''ll pass an arrow function
    (`=>`) in as the first argument, and set a delay of 3 seconds using `3000` milliseconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now I can take my callback call, delete it from line 10, and add it inside
    of the callback function, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Now we'll not be responding to the `getUser` request until three seconds have
    passed. Now this will be more or less similar to what happens when we create real-world
    examples of callbacks, we pass in a callback, some sort of delay happens whether
    we're requesting from a database or from an HTTP endpoint, and then the callback
    gets fired.
  prefs: []
  type: TYPE_NORMAL
- en: 'If I save `callbacks.js` and rerun the code from the Terminal, you''ll see
    we wait those three seconds, which is the simulated delay, and then the `user`
    object prints to the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a1425890-0edd-436d-9b0a-725045975d3c.png)'
  prefs: []
  type: TYPE_IMG
- en: This is exactly the principle that we need to understand in order to start working
    with callbacks, and that is exactly what we'll start doing in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Making request to Geolocation API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The requests that we'll be making to that Geolocation API can actually be simulated
    over in the browser before we ever make the request in Node, and that's exactly
    what we want to do to get started. So follow along for the URL, [https://maps.googleapis.com/maps/api/geocode/json](https://maps.googleapis.com/maps/api/geocode/json).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now this is the actual endpoint URL, but we do have to specify the address
    for which we want the geocode. We''ll do that using query strings, which will
    be provided right after the question mark. Then, we can set up a set of key value
    pairs and we can add multiples using the ampersand in the URL, for example: [https://maps.googleapis.com/maps/api/geocode/json?key=value&keytwo=valuetwo](https://maps.googleapis.com/maps/api/geocode/json?key=value&keytwo=valuetwo).'
  prefs: []
  type: TYPE_NORMAL
- en: In our case, all we need is one query string address, [https://maps.googleapis.com/maps/api/geocode/json?address](https://maps.googleapis.com/maps/api/geocode/json?address),
    and for the address query string we'll set it equal to an address. In order to
    fill out that query address, I'll start typing `1301 lombard street philadelphia`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that we are using spaces in the URL. This is just to illustrate a point:
    we can use spaces in the browser because it''s going to automatically convert
    those spaces to something else. However, inside Node we''ll have to take care
    of that ourselves, and we''ll talk about that a little later in the section. For
    now if we leave the spaces in, hit e*nter*, and we can see they automatically
    get converted for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8c3c2305-5da7-4618-9a47-2bcaad4f493e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Space characters get converted to `%20`, which is the encoded version of a
    space. In this page, we have all of the data that comes back:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c9b78df0-de39-482f-9373-1abf4b76cb54.png)'
  prefs: []
  type: TYPE_IMG
- en: Now we'll use an extension called JSONView, which is available for Chrome and
    Firefox.
  prefs: []
  type: TYPE_NORMAL
- en: I highly recommend installing JSONView, as we should see a much nicer version
    of our JSON data. It lets us minimize and expand various properties, and it makes
    it super easy to navigate.
  prefs: []
  type: TYPE_NORMAL
- en: Now as shown in the preceding screenshot, the data on this page has exactly
    what we need. We have an address_components property, we don't need that. Next,
    we have a formatted address which is really nice, it includes the state, the zip
    code, and the country, which we didn't even provide in the address query.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we have what we really came for: in geometry, we have location, and this
    includes the latitude and longitude data.'
  prefs: []
  type: TYPE_NORMAL
- en: Using Google Maps API data in our code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, what we got back from the Google Maps API request is nothing more than
    some JSON data, which means we can take that JSON data, convert it to a JavaScript
    object, and start accessing these properties in our code. To do this, we'll use
    a third-party module that lets us make these HTTP requests inside of our app;
    this one is called request.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can visit it by going to [https://www.npmjs.com/package/request](https://www.npmjs.com/package/request).
    When we visit this page, we''ll see all the documentation and all the different
    ways we can use the request package to make our HTTP requests. For now, though,
    we''ll stick to some basic examples. On the request documentation page, on the
    right-hand side, we can see this is a super popular package and it has seven hundred
    thousand downloads in the last day:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d6b8a05a-c1ca-4ded-b928-9b9c0f4eb9cd.png)'
  prefs: []
  type: TYPE_IMG
- en: In order to get started we're going to install the package inside our project,
    and we'll make a request to this URL.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the request package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To install the package, we''ll go to the Terminal and install the module using
    `npm init`, to create the `package.json` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9a57438c-a172-4d10-aa76-d8246f6307ea.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We''ll run this command and use e*nter* to use the defaults for every single
    option:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/79dcf48c-a7f7-41e0-bc08-3de90317979c.png)'
  prefs: []
  type: TYPE_IMG
- en: At the end, we'll type `yes` and hit e*nter* again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have our `package.json` file we can use `npm install`, followed
    by the module name, request, and I will specify a version. You can always find
    the latest version of modules on the npm page. The latest version at the time
    of writing is `2.73.0`, so we''ll add that, `@2.73.0`. Then we can specify the
    save flag because we do want to save this module in our `package.json` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: It will be critical for running the weather application.
  prefs: []
  type: TYPE_NORMAL
- en: Using request as a function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have the request module installed, we can start using it. Inside
    Atom we'll wrap up the section by making a request to that URL, in a new file
    in the root of the project called `app.js`. This will be the starting point for
    the weather application. The weather app will be the last command-line app we
    create. In the future we'll be making the backend for web apps as well as real-time
    apps using Socket.IO. But to illustrate asynchronous programming, a command-line
    app is the nicest way to go.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we have our app file, and we can get started by loading in `request` just
    like we did with our other npm modules. We''ll make a constant variable, call
    it `request`, and set it equal to `require(request)`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now what we need to do is make a `request`. In order to do this, we''ll have
    to call the `request` function. Let''s call it, and this function takes two arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: The first argument will be an options object where we can configure all sorts
    of information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second one will be a callback function, which will be called once the data
    comes back from the HTTP endpoint
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'In our case, it''s going to get called once the JSON data, the data from the
    Google Maps API, comes back into the Node application. We can add the arguments
    that are going to get passed back from `request`. Now, these are arguments that
    are outlined in the `request` documentation, I''m not making up the names for
    these:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/10684375-fffa-435f-ba8c-94f30382a37f.png)'
  prefs: []
  type: TYPE_IMG
- en: In the documentation, you can see they call it **error**, **response**, and
    **body**. That's exactly what well call ours. So, inside Atom, we can add `error`,
    `response`, and `body`, just like the docs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can fill out that options object, which is where we are going to specify
    the things unique to our `request`. In this case, one of the unique things is
    the URL. The URL specifies exactly what you want to request, and in our case,
    we have that in the browser. Let''s copy the URL exactly as it appears, pasting
    it inside of the string for the URL property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have the URL property in place, we can add a comma at the very
    end and hit e*nter*. Because we will specify one more property, we''ll set `json`
    equal to `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This tells `request` that the data coming back is going to be JSON data, and
    it should go ahead, take that JSON string, and convert it to an object for us.
    That lets us skip a step, it's a really useful option.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this in place, we can now do something in the callback. In the future
    we''ll be taking this longitude and latitude and fetching weather. For now, we''ll
    simply print the `body` to the screen by using `console.log`. We''ll pass the
    body argument into `console.log`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have our very first HTTP request set up, and we have a callback
    that's going to fire when the data comes back, we can run it from the Terminal.
  prefs: []
  type: TYPE_NORMAL
- en: Running the request
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To run the request, we''ll use `node` and run the `app.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'When we do this, the file will start executing and there will be a really short
    delay before the body prints to the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b60c8eb8-7f66-4289-9dfa-019b6045ba86.png)'
  prefs: []
  type: TYPE_IMG
- en: What we get back is exactly what we saw in the browser. Some of the properties,
    such as `address_components`, show object in this case because we're printing
    it to the screen. But those properties do indeed exist; we'll talk about how to
    get them later in the chapter. For now, though, we do have our `formatted_address`
    as shown in the preceding screenshot, the `geometry` object, the `place_id`, and
    `types`. This is what we'll be using to fetch the longitude and latitude, and
    later to fetch the weather data.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have this in place, we are done. We have the first step of the process
    complete. We've made a request to the Google Geolocation API, and we're getting
    the data back. We'll continue creating the weather app in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Pretty printing objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we continue learning about HTTP and what exactly is inside of `error`,
    `response`, and `body`, let's take a quick moment to talk about how we can pretty
    print an object to the screen. As we saw in the last subsection, when we ran our
    app with `node app.js`, the body prints to the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'But since there is a lot of objects nested inside of each other, JavaScript
    starts clipping them:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1bddd246-d407-41f7-9df9-9f03dc10223f.png)'
  prefs: []
  type: TYPE_IMG
- en: As shown in the preceding screenshot, it tells us an object is in the `results`,
    but we don't get to see exactly what the properties are. This takes place for
    `address_components`, `geometry`, and `types`. Obviously this is not useful; what
    we want to do is see exactly what's in the object.
  prefs: []
  type: TYPE_NORMAL
- en: Using the body argument
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To explore all of the properties, we''re going to look at a way to pretty print
    our objects. This is going to require a really simple function call, a function
    we''ve actually already used, `JSON.stringify`. This is the function that takes
    your JavaScript objects, which `body` is, remember we used the `json: true` statement
    to tell `request` to take the JSON and convert it into an object. In the `console.log`,
    statement we''ll take that object, pass `body` in, and provide the arguments as
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, this is how we''ve usually used `JSON.stringify`, in the past we provided
    just one argument, the object we want to `stringify`, in this case we''re going
    to provide a couple of other arguments. The next argument is used to filter out
    properties. We don''t want to use that, it''s usually useless, so we''re going
    to leave it as undefined as of now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The reason we need to provide it, is because the third argument is the thing
    we want. The third argument will format the JSON, and we''ll specify exactly how
    many spaces we want to use per indentation. We could go with `2` or `4` depending
    on your preference. In this case, we''ll pick `2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll save the file and rerun it from the Terminal. When we `stringify` our
    JSON and print it to the screen, as we''ll see when we rerun the app, we get the
    entire object showing up. None of the properties are clipped off, we can see the
    entire address_components array, everything shows up no matter how complex it
    is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c7d02d6e-293b-4a01-9646-7ae9ad08770a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we have our geometry object, this is where our latitude and longitude
    are stored, and you can see them as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1a5555bb-a957-4db1-97ff-65a218a78d98.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then below that, we have our `types`, which was cut off before, even though
    it was an array with one item, which is a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ea97b02b-f35f-46cd-b775-1772187d7037.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that we know how to pretty print our objects, it will be a lot easier to
    scan data inside of the console—none of our properties will get clipped, and it's
    formatted in a way that makes the data a lot more readable. In the next section,
    we'll start diving into HTTP and all of the arguments in our callback.
  prefs: []
  type: TYPE_NORMAL
- en: Making up of the HTTPS requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The goal in the previous section was not to understand how HTTP works, or what
    exactly the arguments, `error`, `response`, and `body` are the goal was to come
    up with a real-world example of a callback, as opposed to the contrived examples
    that we''ve been using so far with `setTimeout`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding case, we had a real callback that got fired once the HTTP request
    came back from the Google servers. We were able to print the `body`, and we saw
    exactly what we had in the website. In this section, we'll dive into these arguments,
    so let's kick things off by taking a look at the `body` argument. This is the
    third argument that `request` passes to the callback.
  prefs: []
  type: TYPE_NORMAL
- en: Now the `body` is not something unique to the `request` module (`body` is part
    of HTTP, which stands for the **Hypertext Transfer Protocol**). When you make
    a request to a website, the data that comes back is the body of the request. We've
    actually used the body about a million times in our life. Every single time we
    request a URL in the browser, what we get rendered inside the screen is the body.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of [https://www.npmjs.com](https://www.npmjs.com), the body that
    comes back is an HTML web page that the browser knows how to render. The body
    could also be some JSON information, which is the case in our Google API request.
    Either way, the body is the core data that comes back from the server. In our
    case, the body stores all of the location information we need, and we'll be using
    that information to pull out the formatted address, the latitude, and the longitude
    in this section.
  prefs: []
  type: TYPE_NORMAL
- en: The response object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we dive into the body, let''s discuss about the `response` object. We
    can look at the `response` object by printing it to the screen. Let''s swap out
    body in the `console.log` statement for `response` in the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Then save the file and rerun things inside of the Terminal by running the `node
    app.js` command. We''ll get that little delay while we wait for the request to
    come back, and then we get a really complex object:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/60be856d-a1a4-4bd8-8fd5-f3885a7dc9c4.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding screenshot, we can see the first thing we have in the `response`
    object is a status code. The status code is something that comes back from an
    HTTP request; it's a part of the response and tells you exactly how the request
    went.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, `200` means everything went great, and you're probably familiar
    with some status codes, like 404 which means the page was not found, or 500 which
    means the server crashed. There are other body codes we'll be using throughout
    the book.
  prefs: []
  type: TYPE_NORMAL
- en: We'll be making our very own HTTP API, so you'll become intimately familiar
    with how to set and use status codes.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, all we care about is that the status code is `200`, which means
    things went well. Next up in the `response` object, we actually have the `body`
    repeated because it is part of the `response`. Since it's the most useful piece
    of information that comes back, the request module developers chose to make it
    the third argument, although you could access it using `response.body` as you
    can clearly see in this case. Here, we have all of the information we've already
    looked at, address components, formatted address geometry, so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next to the body argument, we have something called `headers`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/285426a4-9865-41b7-8cb4-8a61cbbf808d.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, `headers` are part of the HTTP protocol, they are key-value pairs as you
    can see in the preceding screenshot, where the key and the value are both strings.
    They can be sent in the request, from the Node server to the Google API server,
    and in the response from the Google API server back to the Node server.
  prefs: []
  type: TYPE_NORMAL
- en: Headers are great, there's a lot of built-in ones like `content-type`. The `content-type`
    is HTML for a website, and in our case, it's `application/json`. We'll talk about
    headers more in the later chapters. Most of these headers are not important to
    our application, and most we're never ever going to use. When we go on and create
    our own API later in the book, we'll be setting our own headers, so we'll be intimately
    familiar with how these headers work. For now, we can ignore them completely,
    all I want you to know is that these headers you see are set by Google, they're
    headers that come back from their servers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next to the headers we have the request object, which stores some information
    about the request that was made:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8b7078fe-8c57-45f5-ba3e-5a2803c86959.png)'
  prefs: []
  type: TYPE_IMG
- en: As shown in the preceding screenshot, you can see the protocol HTTPS, the host,
    the `maps.googleapis.com` website, and other things such as the address parameters,
    the entire URL, and everything else about the request, which is stored in this
    part.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we also have our own headers. These are headers that were sent from Node
    to the Google API:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/55dfdbb1-e595-4fde-a400-570c02a49890.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This header got set when we added `json: true` to options object in our code.
    We told request we want JSON back and request went on to tell Google, *Hey, we
    want to accept some JSON data back, so if you can work with that format send it
    back!* And that''s exactly what Google did.'
  prefs: []
  type: TYPE_NORMAL
- en: This is the `response` object, which stores information about the `response`
    and about the request. While we'll not be using most of the things inside the
    `response` argument, it is important to know they exist. So if you ever need to
    access them, you know where they live. We'll use some of this information throughout
    the book, but as I mentioned earlier, most of it is not necessary.
  prefs: []
  type: TYPE_NORMAL
- en: For the most part, we're going to be accessing the body argument. One thing
    we will use is the status. In our case it was `200`. This will be important when
    we're making sure that the request was fulfilled successfully. If we can't fetch
    the location or if we get an error in the status code, we do not want to go on
    to try to fetch the weather because obviously we don't have the latitude and longitude
    information.
  prefs: []
  type: TYPE_NORMAL
- en: The error argument
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For now, we can move on to the final thing which is error. As I just mentioned,
    the status code can reveal that an error occurred, but this is going to be an
    error on the Google servers. Maybe the Google servers have a syntax error and
    their program is crashing, maybe the data that you sent is invalid, for example,
    you sent an address that doesn't exist. These errors are going to become evident
    via the status code.
  prefs: []
  type: TYPE_NORMAL
- en: 'What the error argument contains is errors related to the process of making
    that HTTP request. For example, maybe the domain is wrong: if I delete `s` and
    the dot with `go` in the URL, in our code, I get a URL that most likely doesn''t
    exist:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: In this case, I'll get an error in the error object because Node cannot make
    the HTTP request, it can't even connect it to the server. I could also get an
    error if the machine I'm making the request from does not have access to the internet.
    It's going to try to reach out to the Google servers, it's going to fail, and
    we're going to get an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can check out the error object by deleting those pieces of text from
    the URL and making a request. In this case, I''ll swap out response for `error`,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, inside the Terminal, let''s rerun the application by running the `node
    app.js` command, and we can see exactly what we get back:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8d245a95-3e14-43ce-a952-406ef0d38ddc.png)'
  prefs: []
  type: TYPE_IMG
- en: When we make the bad request, we get our error object printing to the screen,
    and the thing we really care about is the error code. In this case we have the
    `ENOTFOUND` error. This means that our local machine could not connect to the
    host provided. In this case `mapogleapis.com`, it doesn't exist so we'll get an
    error right here.
  prefs: []
  type: TYPE_NORMAL
- en: These are going to be the system errors, things such as your program not being
    able to connect to the internet or the domain not being found. This is also going
    to be really important when it comes to creating some error handling for our application
    there is a chance that the user's machine won't be connected to the internet.
    We're going to want to make sure to take the appropriate action and we'll do that
    depending on what is inside the error object.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we can fix the URL, setting it back to [maps.googleapis.com](https://developers.google.com/maps/),
    and make the exact same request by using the up arrow key and the *enter* key,
    the request error object it''s going to be empty, and you can see null print to
    the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2a0914db-1015-4b3c-8ca1-0469123b5f9b.png)'
  prefs: []
  type: TYPE_IMG
- en: In this case, everything went great, there was no error, and it was able to
    successfully fetch the data, which it should be able to because we have a valid
    URL. That is a quick rundown of the body, the `response`, and the error argument.
    We will use them in more detail as we add error handling.
  prefs: []
  type: TYPE_NORMAL
- en: Printing data from the body object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we'll print some data from the body to the screen. Let's get started by
    printing the formatted address, and then we will be responsible for printing both
    the latitude and the longitude.
  prefs: []
  type: TYPE_NORMAL
- en: Printing the formatted address
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll start with figure out where the formatted address is. For this, we''ll
    go to the browser and use JSONView. At the bottom of the browser page, you can
    see that little blue bar shows up when we highlight over items, and it changes
    as we switch items. For formatted address, for example, we access the `results`
    property, results is an array. In the case of most addresses, you''ll only get
    one result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b87f0474-ed72-4227-874f-d769284acb61.png)'
  prefs: []
  type: TYPE_IMG
- en: We'll use the first result every time, so we have the index of `0`, then it's
    the `.formatted_address` property. This bottom line is exactly what we need to
    type inside of our Node code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside Atom, in our code, we''ll delete the `console.log` statement, and replace
    it with a new `console.log` statement. We''ll use template strings to add some
    nice formatting to this. We''ll add `Address` with a colon and a space, then I''ll
    inject the address using the dollar sign and the curly braces. We''ll access the
    body, results, and the first item in the results array followed by formatted address,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'With this in place, I can now add a semicolon at the end and save the file.
    Next, we''ll rerun the application inside of the Terminal, and this time around
    we get our address printing to the screen, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/88e40c01-c715-4a9d-8ce6-ea184038e29d.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that we have the address printing to the screen, what we would like to print
    both the latitude and the longitude next.
  prefs: []
  type: TYPE_NORMAL
- en: Printing latitude and longitude
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to get started, inside Atom, we'll add another `console.log` line right
    next to the `console.log` we added for formatted address. We'll use template strings
    again to add some nice formatting. Let's print the latitude first.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this, we''ll add latitude followed by a colon. Then we can inject our variable
    using the dollar sign with the curly braces. Then, the variable we want is on
    the body. Just like the formatted address, it''s also in the first results item;
    results at the index of zero. Next, we''ll be going into geometry. From geometry,
    we''ll grab the location property, the latitude, `.lat`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have this in place, we''ll do the exact same thing for longitude.
    We''ll add another `console.log` statement in the next line of the code. We''ll
    use template strings once again, typing longitude first. After that, we''ll put
    a colon and then inject the value. In this case, the value is on the body; it''s
    in that same results item, the first one. We''ll go into geometry location again.
    Instead of `.lat`, we''ll access `.lng`. Then we can add a semicolon at the end
    and save the file. This will look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we''ll test it from the Terminal. We''ll rerun the previous command, and
    as shown in the following screenshot, you can see we have the latitude, `39.94`,
    and the longitude, `-75.16` printing to the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ecf9866f-0d5c-413c-86a2-5962c33fbda4.png)'
  prefs: []
  type: TYPE_IMG
- en: And these are the exact same values we have inside the Chrome browser, `39.94`,
    `-75.16`. With this in place, we've now successfully pulled off the data we need
    to make that request to the weather API.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have gone through a basic example of asynchronous programming.
    Next, we talked about what happens behind the scenes when you run asynchronous
    code. We got a really good idea about how your program runs and what tools and
    tricks are happening behind the scenes to make it run the way it does. We through
    a few examples that illustrate how the Call Stack, Node APIs, the Callback Queue,
    and the Event Loop work.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we learned how to use the request module to make an HTTP request for some
    information, the URL we requested was a Google Maps Geocoding URL, and we passed
    in the address we want the latitude and the longitude for. Then we used a callback
    function that got fired once that data came back.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of the section *Callback functions and APIs*, we looked into a quick
    tip on how we can format objects when we want to print them to the console. Last,
    we looked into what makes up the HTTPS request.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll add some error handling to this callback because
    that's going to be really important for our HTTP requests. There's a chance that
    things will go wrong, and when they do, we'll want to handle that error by printing
    a nice error message to the screen.
  prefs: []
  type: TYPE_NORMAL
