- en: Implementing Mandatory Access Control with SELinux and AppArmor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we saw in the previous chapters, Discretionary Access Control allows users
    to control who can access their own files and directories. But, what if your company
    needs to have more administrative control over who accesses what? For this, we
    need some sort of Mandatory Access Control or MAC.
  prefs: []
  type: TYPE_NORMAL
- en: The best way I know to explain the difference between DAC and MAC is to hearken
    back to my Navy days.  I was riding submarines at the time, and I had to have
    a Top Secret clearance to do my job. With DAC, I had the physical ability to take
    one of my Top Secret books to the mess decks, and hand it to a cook who didn't
    have that level of clearance. With MAC, there were rules that prevented me from
    doing so. On operating systems, things work pretty much the same way.
  prefs: []
  type: TYPE_NORMAL
- en: There are several different MAC systems that are available for Linux. The two
    that we'll cover in this chapter are SELinux and AppArmor.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What SELinux is and how it can benefit a system's administrator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to set security contexts for files and directories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use setroubleshoot to troubleshoot SELinux problems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Looking at SELinux policies and how to create custom policies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What AppArmor is and how it can benefit a systems administrator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Looking at AppArmor policies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with AppArmor command-line utilities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Troubleshooting AppArmor problems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How SELinux can benefit a systems administrator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'SELinux is a free open source software project that was developed by the U.S.
    National Security Agency. While it can theoretically be installed on any Linux
    distro, the Red Hat-type distros are the only ones that come with it already set
    up and enabled. It uses code in Linux kernel modules, along with filesystem-extended
    attributes, to help ensure that only authorized users and processes can access
    either sensitive files or system resources. There are three ways in which SELinux
    can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: It can help prevent intruders from exploiting a system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can be used to ensure that only users with the proper security clearance
    can access files that are labeled with a security classification
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition to MAC, SELinux can also be used as a type of role-based access
    control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, I'll only be covering the first of these three uses because
    that is the most common way in which SELinux is used. There's also the fact that
    covering all three of these uses would require writing a whole book, which I don't
    have space to do here.
  prefs: []
  type: TYPE_NORMAL
- en: If you go through this introduction to SELinux and find that you still need
    more SELinux information, you'll find whole books and courses on just this subject
    at the Packt Publishing website.
  prefs: []
  type: TYPE_NORMAL
- en: So how can SELinux benefit the busy systems administrator? Well, you might remember
    when a few years ago, news about the *Shellshock* bug hit the world's headlines.
    Essentially, Shellshock was a bug in the Bash shell that allowed intruders to
    break into a system and to exploit it by gaining root privileges. For systems
    that were running SELinux, it was still possible for the bad guys to break in,
    but SELinux would have prevented them from successfully running their exploits.
  prefs: []
  type: TYPE_NORMAL
- en: SELinux is also yet another mechanism that can help protect data in users' home
    directories. If you have a machine that's set up as a Network File System server,
    a Samba server, or a web server, SELinux will prevent those daemons from accessing
    users' home directories, unless you explicitly configure SELinux to allow that
    behavior.
  prefs: []
  type: TYPE_NORMAL
- en: On web servers, you can use SELinux to prevent the execution of malicious CGI
    scripts or PHP scripts. If you don't need for your server to run CGI or PHP scripts,
    you can disable them in SELinux.
  prefs: []
  type: TYPE_NORMAL
- en: With older versions of Docker and without Mandatory Access Control, it was trivially
    easy for a normal user to break out of a Docker container and gain root-level
    access to the host machine. Although Docker security has since improved, SELinux
    is still a useful tool for hardening servers that run Docker containers.
  prefs: []
  type: TYPE_NORMAL
- en: So now, you're likely thinking that everyone would use such a great tool, right?
    Sadly, that's not the case. In its beginning, SELinux got a reputation for being
    difficult to work with, and many administrators would just disable it. In fact,
    a lot of tutorials you see on the web or on YouTube have *disable SELinux* as
    the first step. In this section, I'd like to show you that things have improved
    and that SELinux no longer deserves its bad reputation.
  prefs: []
  type: TYPE_NORMAL
- en: Setting security contexts for files and directories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Think of SELinux as a glorified labeling system. It adds labels, known as *security
    contexts*, to files and directories through extended file attributes. It also
    adds the same type of labels, known as domains, to system processes. To see these
    contexts and domains on your CentOS machines, use the `-Z` option with either
    `ls` or `ps`.  For example, files and directories in my own home directory would
    look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Processes on my system would look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s break this down. In the outputs of both the `ls -Z` and `ps -Z`
    commands, we have the following parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The SELinux user**: In both cases, the SELinux user is the generic `unconfined_u`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The SELinux role**: In the `ls -Z` example, we see that the role is `object_r`,
    and in the `ps -Z` example it''s `unconfined_r`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The type**: It''s `user_home_t` in the `ls -Z` output, and `unconfined_t`
    in the `ps -Z` output'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The sensitivity**: In the `ps -Z` output it''s `s0`. In the `ps -Z` output
    it''s `s0-s0`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The category**: We don''t see a category in the `ls -Z` output, but we do
    see `c0.c1023` in the `ps -Z` output'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Out of all of the preceding security context and security domain components,
    the only one that interests us now is the type. For the purposes of this chapter,
    we're only interested in covering what a normal Linux administrator would need
    to know to keep intruders from exploiting the system, and the type is the only
    one of these components that we need to use for that. All of the other components
    come into play when we set up advanced, security classification-based access control
    and role-based access control.
  prefs: []
  type: TYPE_NORMAL
- en: Okay, here's the somewhat over-simplified explanation of how this helps a Linux
    administrator maintain security. What we want is for system processes to only
    access objects that we allow them to access. (System processes include things
    like the web server daemon, the FTP daemon, the Samba daemon, and the Secure Shell
    daemon. Objects include things such as files, directories, and network ports.)
    To achieve this, we'll assign a *type* to all of our processes and all of our
    objects. We'll then create *policies* that define which process types can access
    which object types.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, whenever you install any Red Hat-type distro, pretty much all of
    the hard work has already been done for you. Red Hat-type distros all come with
    SELinux already enabled and set up with the targeted policy. Think of this targeted
    policy as a somewhat relaxed policy, which allows a casual desktop user to sit
    down at the computer and actually conduct business without having to tweak any
    SELinux settings. But, if you're a server administrator, you may find yourself
    having to tweak this policy in order to allow server daemons to do what you need
    them to do.
  prefs: []
  type: TYPE_NORMAL
- en: The targeted policy, which comes installed by default, is what a normal Linux
    administrator will use in his or her day-to-day duties. If you look in the repositories
    of your CentOS virtual machine, you'll see that there are also several others,
    which we won't cover in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the SELinux tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For some bizarre reason that I''ll never understand, the tools that you need
    to administer SELinux don''t get installed by default, even though SELinux itself
    does. So, the first thing you''ll need to do on your CentOS virtual machine is
    to install them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In a later portion of this chapter, we''ll be looking at how to use setroubleshoot
    to help diagnose SELinux problems. In order to have some cool error messages to
    look at when we get there, go ahead and install setroubleshoot now, and activate
    it by restarting the `auditd` daemon.  (There''s no setroubleshoot daemon because
    setroubleshoot is meant to be controlled by the `auditd` daemon.) We have the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: One of the little systemd quirks that we have to deal with is that you can't
    stop or restart the `auditd` daemon with the normal `systemctl` command, as you're
    supposed to do when working with systemd daemons. However, the old-fashioned `service`
    command works. (And no, I don't know why that is.)
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the type of installation that you chose when installing CentOS,
    you might or might not already have setroubleshoot installed. To be sure, go ahead
    and run the command to install it. It won't hurt anything if setroubleshoot is
    already there.
  prefs: []
  type: TYPE_NORMAL
- en: You now have what you need to get started.
  prefs: []
  type: TYPE_NORMAL
- en: Creating web content files with SELinux enabled
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s look at what can happen if you have web content files that are
    set with the wrong SELinux type. First, we''ll install, enable, and start the
    Apache web server on our CentOS virtual machines. (Note that including the `--now`
    option allows us to enable and start a daemon all in one single step.) We have
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If you haven''t done so already, you''ll want to configure the firewall to
    allow access to the web server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'When we look at the SELinux information for the Apache processes, we''ll see
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As I said before, we're not interested in the user or the role. However, we
    are interested in the type, which in this case is `httpd_t`.
  prefs: []
  type: TYPE_NORMAL
- en: 'On Red Hat-type systems, we would normally place web content files in the `/var/www/html`
    directory. Let''s look at the SELinux context for that `html` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The type is `httpd_sys_content`, so it stands to reason that the `httpd` daemon
    should be able to access this directory. It''s currently empty, so let''s `cd`
    into it and create a simple index file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'I''ll put this into the file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Okay, as I said, it's simple, as my HTML hand-coding skills aren't what they
    used to be. But still, it serves our present purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking at the SELinux context, we see that the file has the same type as the
    `html` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'I can now navigate to this page from the web browser of my trusty OpenSUSE
    workstation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/07aefddb-cadc-4600-a7f2-6ab2909e6b16.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now though, let''s see what happens if I decide to create content files in
    my own home directory and then move them to the `html` directory. First, let''s
    see what the SELinux context is for my new file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The context type is now `user_home_t`, which is a sure-fire indicator that
    I created this in my home directory. I''ll now move the file to the `html` directory,
    overwriting the old file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Even though I moved the file over to the `/var/www/html` directory, the SELinux
    type is still associated with users'' home directories. Now, I''ll go to the browser
    of my host machine to refresh the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/09ce2e91-df19-4295-a74d-a3414d56fa64.png)'
  prefs: []
  type: TYPE_IMG
- en: So, I have a slight bit of a problem. The type that's assigned to my file doesn't
    match with the type of the httpd daemon processes, so SELinux doesn't allow the
    `httpd` processes to access the file.
  prefs: []
  type: TYPE_NORMAL
- en: Had I copied the file to the `html` directory instead of moving it, the SELinux
    context would have changed to match that of the destination directory.
  prefs: []
  type: TYPE_NORMAL
- en: Fixing an incorrect SELinux context
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Okay, so I have this web content file that nobody can access, and I really
    don''t feel up to creating a new one. So, what do I do? Actually, we have three
    different utilities for fixing this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`chcon`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`restorecon`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`semanage`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using chcon
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two ways to use `chcon` to fix an incorrect SELinux type on a file
    or directory.  The first is to just manually specify the proper type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We can use `chcon` to change any part of the context, but as I keep saying,
    we're only interested in the type, which gets changed with the `-t` option. You
    can see in the `ls -Z` output that the command was successful.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other way to use `chcon` is to reference a file that has the proper context. 
    For demo purposes, I changed the `index.html` file back to the home directory
    type and have created a new file within the `/var/www/html` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, any files that I create within this directory will automatically
    have the proper SELinux context settings. Now, let''s use that new file as a reference
    in order to set the proper context on the `index.html` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: So, I used the `--reference` option and specified the file that I wanted to
    use as a reference. The file that I wanted to change is listed at the end of the
    command.
  prefs: []
  type: TYPE_NORMAL
- en: Now, that's all good, but I want to find an easier way that doesn't require
    quite as much typing. After all, I am an old man, and I don't want to overexert
    myself. So, let's take a look at the `restorecon` utility.
  prefs: []
  type: TYPE_NORMAL
- en: Using restorecon
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using `restorecon` is easy. Just type `restorecon`, followed by the name of
    the file that you need to change. Once again, I''ve changed the context of the
    `index.html` file back to the home directory type. This time though, I''m using
    `restorecon` to set the correct type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: And, that's all there is to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use `chcon` and `restorecon` to change the context of an entire
    directory and its contents. For either one, just use the `-R` option. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sudo chcon -R -t httpd_sys_content_t /var/www/html/`'
  prefs: []
  type: TYPE_NORMAL
- en: '`sudo restorecon -R /var/www/html/`'
  prefs: []
  type: TYPE_NORMAL
- en: (Remember:  `-R` stands for recursive.)
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s still one last thing to take care of, even though it isn''t really
    affecting our ability to access this file. That is, I need to change ownership
    of the file to the Apache user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Using semanage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the scenario I've just presented, either `chcon` or `restorecon` will suit
    your needs just fine. The active SELinux policy mandates what the security contexts
    in certain directories are supposed to look like. As long as you're using `chcon`
    or `restorecon` within directories that are defined in the active SELinux policy,
    you're good. But let's say that you've created a directory elsewhere that you
    want to use for serving out web content files. You would need to set the `httpd_sys_content_t`
    type on that directory and all of the files within it. However, if you use `chcon`
    or `restorecon` for that, the change won't survive a system reboot. To make the
    change permanent, you'll need to use `semanage`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For some strange reason, let''s say that I want to serve web content out of
    a directory that I''ve created in the `/home` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Because I had to use my powers of sudo to create the directory here, it''s
    associated with the root user''s `home_root_t` type, instead of the normal `user_home_dir_t`
    type. Any files that I create within this directory will have the same type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to use `semanage` to add a permanent mapping of this directory
    and the `httpd_sys_content_t` type to the active policy''s context list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Okay, here''s the breakdown of the `semanage` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '`fcontext`: Because `semanage` has many purposes, we have to specify that we
    want to work with a file context.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-a`: This specifies that we''re adding a new record to the context list for
    the active SELinux policy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-t`: This specifies the type that we want to map to the new directory. In
    this case, we''re creating a new mapping with the `httpd_sys_content` type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/home/webdir(/.*)?`: This bit of gibberish is what''s known as a *regular
    expression*. I can''t go into the nitty-gritty details of regular expressions
    here, so suffice it to say that *regular expressions* is a language that we use
    to match text patterns. (And yes, I did mean to say *is* instead of *are*, since
    regular expressions is the name of the overall language.) In this case, I had
    to use this particular regular expression in order to make this `semanage` command
    recursive because `semanage` doesn''t have a `-R` option switch. With this regular
    expression, I''m saying that I want for anything that gets created in this directory
    to have the same SELinux type as the directory itself.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The final step is to do a `restorecon -R` on this directory to ensure that
    the proper labels have been set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Yeah, I know. You're looking at this and saying, "*But, this 'ls -Zd' output
    looks the same as it did after you did the semanage command.*" And, you're right.
    After running the `semanage` command, the type seems to be set correctly. But
    the `semanage-fcontext` man page says to run `restorecon` anyway, so I did.
  prefs: []
  type: TYPE_NORMAL
- en: For more information on how to use `semanage` to manage security contexts, see
    the man page by entering `man semanage-fcontext`.
  prefs: []
  type: TYPE_NORMAL
- en: Hands-on lab – SELinux type enforcement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this lab, you'll install the Apache web server and the appropriate SELinux
    tools. You'll then view the effects of having the wrong SELinux type assigned
    to a web content file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Install Apache, along with all the required SELinux tools:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Activate setroubleshoot by restarting the `auditd` service:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Enable and start the Apache service and open port `80` on the firewall:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `/var/www/html` directory, create an `index.html` file with the following
    contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'View the SELinux information about the `index.html` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In your host machine's web browser, navigate to the IP address of the CentOS
    virtual machine. You should be able to view the page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Induce an SELinux violation by changing the type of the `index.html` file to
    something that''s incorrect:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Go back to your host machine's web browser, and reload the document. You should
    now see a Forbidden message.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use `restorecon` to change the file back to its correct type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Reload the page in your host machine's web browser. You should now be able to
    view the page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Troubleshooting with setroubleshoot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, you're now scratching your head and saying, "*When I can't access something
    that I should be able to, how do I know that it's an SELinux problem?*" Ah, I'm
    glad you asked.
  prefs: []
  type: TYPE_NORMAL
- en: Viewing setroubleshoot messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Whenever something happens that violates an SELinux rule, it gets logged in
    the `/var/log/audit/audit.log` file. Tools are available that can let you directly
    read that log, but to diagnose SELinux problems, it''s way better to use setroubleshoot.
    The beauty of setroubleshoot is that it takes the cryptic, hard-to-interpret SELinux
    messages from the `audit.log` file and translates them into plain, natural language.
    The messages that it sends to the `/var/log/messages` file even contain suggestions
    about how to fix the problem. To show how this works, let''s go back to our problem
    where a file in the `/var/www/html` directory had been assigned the wrong SELinux
    type. Of course, we knew right away what the problem was because there was only
    one file in that directory and a simple `ls -Z` showed the problem with it. However,
    let''s ignore that for the moment and say that we didn''t know what the problem
    was. By opening the `/var/log/messages` file in `less` and searching for `sealert`,
    we''ll find this message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The first line of this message tells us what the problem is. It's saying that
    SELinux is preventing us from accessing the `/var/www/html/index.html` file because
    it's set with the wrong type. It then gives us several suggestions on how to fix
    the problem, with the first one being to run the `restorecon` command, as I've
    already shown you how to do.
  prefs: []
  type: TYPE_NORMAL
- en: A good rule-of-thumb to remember when reading these setroubleshoot messages
    is that the first suggestion in the message is normally the one that will fix
    the problem.
  prefs: []
  type: TYPE_NORMAL
- en: Using the graphical setroubleshoot utility
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, I''ve only talked about using setroubleshoot on text-mode servers.
    After all, it''s very common to see Linux servers running in text-mode, so all
    of us Linux folk have to be text-mode warriors. But on desktop systems or on servers
    that have a desktop interface installed, there is a graphical utility that will
    automatically alert you when setroubleshoot detects a problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f2530e17-4614-4b86-a18b-1da0df26283a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on that alert icon, and you''ll see this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/656400bc-80a6-446d-b273-812c6b3b8a6d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Click the Troubleshoot button, and you''ll see your list of suggestions for
    how to fix the problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/504f1e45-c038-4b24-b932-dc96eec50a48.png)'
  prefs: []
  type: TYPE_IMG
- en: As it is often the case with GUI thingies, this is mostly self-explanatory,
    so you shouldn't have any problem with figuring it out.
  prefs: []
  type: TYPE_NORMAL
- en: Troubleshooting in permissive mode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you're dealing with a simple problem like the one I've just shown you, then
    you can probably assume that you're safe in doing what the first suggestion in
    the setroubleshoot message tells you to do. But there will be times when things
    get a bit more complex, where you might have more than one problem. For times
    like these, you need to use *permissive mode*.
  prefs: []
  type: TYPE_NORMAL
- en: When you first install your Red Hat or CentOS system, SELinux is in *enforcing
    mode*, which is the default. This means that SELinux will actually stop actions
    that are in violation of the active SELinux policy. This also means that if you
    have multiple SELinux problems when you try to perform a certain action, SELinux
    will stop the action from taking place after the first violation occurs. When
    it happens, SELinux won't even see the remaining problems, and they won't show
    up in the `messages` log file. If you try to troubleshoot these types of problems
    while in enforcing mode, you'll be like the proverbial dog who chases its own
    tail.  You'll go round and round and will accomplish nothing.
  prefs: []
  type: TYPE_NORMAL
- en: In permissive mode, SELinux allows actions that violate policy to occur, but
    it will log them.  By switching to permissive mode and doing something to induce
    the problem that you were seeing, the prohibited actions will take place, but
    setroubleshoot will log all of them in the `messages` file. This way, you'll get
    a better view of what you need to do to get things working properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s use `getenforce` to verify what our current mode is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s temporarily place the system into permissive mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'When I say *temporarily*, I mean that this will only last until you do a system
    reboot. After a reboot, you''ll be back in enforcing mode. Also, note that a `0`
    after the `setenforce` denotes that I''m setting permissive mode. To get back
    to enforcing mode after you''re done with troubleshooting, replace the `0` with
    a `1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We're now back in enforcing mode.
  prefs: []
  type: TYPE_NORMAL
- en: At times, you may need to make permissive mode persist after a system reboot.
    An example of this would be if you ever have to deal with a system that has had
    SELinux disabled for a long period of time. In a case like that, you wouldn't
    want to just put SELinux into enforcing mode and reboot. If you try that, it will
    take forever for the system to properly create the file and directory labels that
    make SELinux work, and the system might lock up before it's done. By placing the
    system into permissive mode first, you'll avoid having the system lock up, although
    it will still take a long time for the relabeling process to complete.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make permissive mode persistent across system reboots, you''ll edit the
    `selinux` file in the `/etc/sysconfig` directory. Here''s what it looks like by
    default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The two important things you see here are that SELinux is in enforcing mode,
    and that it''s using the targeted policy. To switch to permissive mode, just change
    the `SELINUX=` line, and save the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The `sestatus` utility shows us lots of cool information about what''s going
    on with SELinux:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The two items that interest us here are current mode and mode from a configuration
    file. By changing the configuration file to permissive, we haven't changed the
    current running mode. So, we're still in enforcing mode. The switch to permissive
    won't happen until I either reboot this machine or until I manually switch by
    issuing a `sudo setenforce 0` command. And of course, you don't want to stay in
    permissive mode forever. As soon as you no longer need permissive mode, change
    the configuration file back to enforcing and do a `sudo setenforce 1` to change
    the running mode.
  prefs: []
  type: TYPE_NORMAL
- en: Working with SELinux policies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, all we've looked at is what happens when we have an incorrect SELinux
    type set on a file and what to do to set the correct type. Another problem we
    may have would come about if we need to allow an action that is prohibited by
    the active SELinux policy.
  prefs: []
  type: TYPE_NORMAL
- en: Viewing the Booleans
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Booleans are part of what makes up an SELinux policy, and each Boolean represents
    a binary choice. In SELinux policies, a Boolean either allows something or it
    prohibits something. To see all of the Booleans on your system, run the `getsebool
    -a` command. (It''s a long list, so I''ll only show partial output here.):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'To view more than one Boolean, the `-a` switch is mandatory. If you just happen
    to know the name of the Boolean that you want to see, leave the `-a` out and list
    the Boolean. In keeping with the Apache web server theme that we''ve had going,
    let''s see whether we''re allowing Apache to access files in users'' home directories:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The fact that this Boolean is `off` means that the Apache server daemon isn't
    allowed to access any content within the users' home directories. This is an important
    protection, and you really don't want to change it. Instead, just put web content
    files elsewhere so that you don't have to change this Boolean.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most likely, you''ll rarely want to look at the entire list, and you likely
    won''t know the name of the specific Boolean that you want to see. Rather, you''ll
    probably want to filter the output through `grep` in order to look at just certain
    things. For example, to see all of the Booleans that affect a web server, follow
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: It's also a rather long list, but scroll down a ways, and you'll find the Boolean
    that you seek.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the Booleans
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Realistically, you''ll likely never have reason to allow users to serve web
    content out of their home directories. It''s much more probable that you''ll set
    up something like a Samba server, which would allow users on Windows machines
    to use their graphical Windows Explorer to access their home directories on Linux
    servers. But if you set up a Samba server and don''t do anything with SELinux,
    users will be complaining about how they don''t see any of their files in their
    home directories of the Samba server. Because you''re the proactive type and you
    want to avoid the pain of listening to complaining users, you''ll surely just
    go ahead and configure SELinux to allow the Samba daemon to access users'' home
    directories. You might not know the exact name of the Boolean, but you can find
    it easily enough, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Okay, you knew that the Boolean name probably had the word `home` in it, so
    you filtered for that word. About half-way down the list, you see `samba_enable_home_dirs
    --> off`.  You''ll need to change this to `on` to let users access their home
    directories from their Windows machines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Users can now access their home directories as they should be able to, but
    only until you do a system reboot. Without the `-P` option, any changes you make
    with `setsebool` will only be temporary. So, let''s make the change permanent
    with `-P`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Congratulations, you've just made your first change to SELinux policy.
  prefs: []
  type: TYPE_NORMAL
- en: Protecting your web server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Look at the output of the `getsebool -a | grep 'http'` command again, and you'll
    see that most of the httpd-related Booleans are turned off by default, with only
    a few turned on. There are two of them that you'll commonly need to turn on when
    setting up a web server.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you ever need to set up a website with some sort of PHP-based content management
    system, such as Joomla or Wordpress, you may have to turn on the `httpd_unified`
    Boolean. With this Boolean turned off, the Apache web server won''t be able to
    interact properly with all of the components of the PHP engine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The other Boolean that you''ll commonly need to turn on is the `httpd_can_sendmail`
    Boolean. If you ever need for a website to send mail out through a form or if
    you need to set up a mail server with a web-based frontend, you''ll definitely
    need to set this to `on`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, there are some Booleans that are turned on by default, and
    you might want to consider whether you really need them turned on. For example,
    allowing CGI scripts to run on a web server does represent a potential security
    risk. If an intruder were to somehow upload a malicious CGI script to the server
    and run it, much damage could occur as a result. Yet, for some bizarre reason,
    the default SELinux policy allows CGI scripts to run. If you''re absolutely certain
    that nobody who hosts websites on your server will ever need to run CGI scripts,
    you might want to consider turning this Boolean off:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Protecting network ports
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Each network daemon that's running on your system has a specific network port
    or set of network ports assigned to it, on which it will listen.  The `/etc/services`
    file contains the list of common daemons and their associated network ports, but
    it doesn't prevent someone from configuring a daemon to listen on some non-standard
    port. So, without some mechanism to prevent it, some sneaky intruder could potentially
    plant some sort of malware that would cause a daemon to listen on a non-standard
    port, possibly listening for commands from its master.
  prefs: []
  type: TYPE_NORMAL
- en: 'SELinux protects against this sort of malicious activity by only allowing daemons
    to listen on certain ports. Use `semanage` to look at the list of allowed ports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'This is yet another of those very long lists, so I''m only showing partial
    output. However, let''s narrow things down a bit. Let''s say that I only want
    to look at the list of ports on which the Apache web server can listen. For this,
    I''ll use my good friend, `grep`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Several `http` items come up, but I'm only interested in the `http_port_t` item
    because it's the one that affects normal web server operation. We see here that
    SELinux will allow Apache to listen on ports `80`, `81`, `443`, `488`, `8008`,
    `8009`, `8443`, and `9000`. As the Apache server is the most likely daemon for
    which you'd ever have a legitimate reason for adding a non-standard port, let's
    demo with it.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s go into the `/etc/httpd/conf/httpd.conf` file and look at the
    ports on which Apache is currently listening. Search for `Listen`, and you''ll
    see the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'I don''t have the SSL module installed on this machine, but if I did, I would
    have an `ssl.conf` file in the `/etc/httpd/conf.d` directory with the following
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'So for normal, non-encrypted website connections, the default configuration
    only has Apache listening on port `80`. For secure, encrypted website connections,
    Apache listens on port `443`. Now, let''s go into the `httpd.conf` file and change
    `Listen 80` to a port number that SELinux doesn''t allow. For example, port `82`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'After saving the file, I''ll restart Apache to read in the new configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Yes, I have a problem. I''ll look in the `/var/log/messages` file to see if
    setroubleshoot gives me a clue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The problem that SELinux is preventing `httpd` from binding to port `82` is
    defined in the first line of the message. The first suggestion we see for fixing
    this is to use `semanage` to add the port to the list of allowed ports. So, let''s
    do that and look at the list of Apache ports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: It's not clear in the setroubleshoot message, but you need to specify the port
    number that you want to add after the `port -a`.  The `-t http_port_t` specifies
    the type for which you want to add the port, and the `-p tcp` specifies that you
    want to use the TCP protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, for the moment of truth.  Will the Apache daemon start this time? Let''s
    see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'It works, and we have achieved coolness. But now, I''ve decided that I no longer
    need this oddball port. Deleting it is just as easy as adding it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: All I had to do was to replace the `port -a` with `port -d`.  And of course,
    I still need to go into the `/etc/httpd/conf/httpd.conf` file to change `Listen
    82` back to `Listen 80`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating custom policy modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, you'll run into a problem that you can't fix by either changing the
    type or by setting a Boolean. In times like these, you'll need to create a custom
    policy module, and you'll use the `audit2allow` utility to do that.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a screenshot of a problem I had several years ago, when I was helping
    a client set up a Postfix mail server on CentOS 7:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/55240bb0-a151-4c3c-9506-f742ee4855b8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'So, for some strange reason that I never understood, SELinux wouldn''t allow
    Dovecot, the Mail Delivery Agent component of the mail server, to read its own
    `dict` file. There''s no Boolean to change and there wasn''t a type problem, so
    setroubleshoot suggested that I create a custom policy module. It''s easy enough
    to do, but you do need to be aware that this won''t work with sudo on your normal
    user account. This is one of those rare times when you''ll just have to go to
    the root user command prompt, and you''ll also need to be in the root user''s
    home directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Before you do it, be sure to put SELinux into the permissive mode and then do
    something to induce the SELinux error. This way, you'll be sure that one problem
    isn't masking others.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you run the command to create the new policy module, be sure to replace
    `mypol` with a custom policy name of your own choosing. In my case, I named the
    module `dovecot_dict`, and the command looked like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: What I'm doing here is using `grep` to search through the `audit.log` file for
    SELinux messages that contain the word `dict`. I then piped the output of that
    into `audit2allow` and used the `-M` option to create a custom module with the
    name, `dovecot_dict`.
  prefs: []
  type: TYPE_NORMAL
- en: 'After I created the new policy module, I inserted it into the SELinux policy
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'There was a also a second problem that required another custom module, but
    I just repeated this procedure to produce another module of a different name.
    After I got all that done, I reloaded the SELinux policy, in order to get my new
    modules to take effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: With `semodule`, the `-R` switch stands for reload, rather than recursive, as
    it does with most Linux commands.
  prefs: []
  type: TYPE_NORMAL
- en: With all that done, I put SELinux back into enforcing mode and exited back to
    my own user account. And, I tested the setup to make sure that I had fixed the
    problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, you also want to bear in mind that you don''t want to just modify
    SELinux policy or contexts every time you see an `sealert` message in the log
    files. For example, consider this snippet from the `messages` file of my Oracle
    Linux 7 machine, which I set up mainly to run Docker and Docker containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: These messages were caused by an early version of Docker trying to access resources
    on the host machine. As you can see, Docker is trying to access some rather sensitive
    files, and SELinux is preventing Docker from doing so. With early versions of
    Docker and without some sort of Mandatory Access Control, it would have been a
    trivial matter for a normal, unprivileged user to escape from the Docker container
    and have root user privileges on the host system. Naturally, when you see these
    sorts of messages, you don't want to automatically tell SELinux to allow the prohibited
    actions. It just may be that SELinux is preventing something truly bad from taking
    place.
  prefs: []
  type: TYPE_NORMAL
- en: Be sure to get your copy of *The SELinux Coloring Book* at: [https://opensource.com/business/13/11/selinux-policy-guide.](https://opensource.com/business/13/11/selinux-policy-guide)
  prefs: []
  type: TYPE_NORMAL
- en: Hands-on lab – SELinux Booleans and ports
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this lab, you''ll view the effects of having Apache try to listen on an
    unauthorized port:'
  prefs: []
  type: TYPE_NORMAL
- en: 'View the ports that SELinux allows the Apache web server daemon to use:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the `/etc/httpd/conf/httpd.conf` file in your favorite text editor. Find
    the line that says `Listen 80` and change it to `Listen 82`. Restart Apache by
    entering the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'View the error message you receive by entering:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Add port `82` to the list of authorized ports and restart Apache:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Delete the port that you just added:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Go back into the `/etc/httpd/conf/httpd.conf` file, and change `Listen 82` back
    to `Listen 80`. Restart the Apache daemon to return to normal operation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How AppArmor can benefit a systems administrator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'AppArmor is the Mandatory Access Control system that comes installed with the
    SUSE and the Ubuntu families of Linux. Although it''s designed to do pretty much
    the same job as SELinux, its mode of operation is substantially different:'
  prefs: []
  type: TYPE_NORMAL
- en: SELinux labels all system processes and all objects such as files, directories,
    or network ports. For files and directories, SELinux stores the labels in their
    respective inodes as extended attributes. (An inode is the basic filesystem component
    that contains all information about a file, except for the file name.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AppArmor uses pathname enforcement, which means that you specify the path to
    the executable file that you want for AppArmor to control. This way, there's no
    need to insert labels into the extended attributes of files or directories.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With SELinux, you have system-wide protection out of the box.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With AppArmor, you have a profile for each individual application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With either SELinux or AppArmor, you might occasionally find yourself having
    to create custom policy modules from scratch, especially if you're dealing with
    either third-party applications or home-grown software. With AppArmor, this is
    easier, because the syntax for writing AppArmor profiles is much easier than the
    syntax for writing SELinux policies. And, AppArmor comes with utilities that can
    help you automate the process.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Just as SELinux can, AppArmor can help prevent malicious actors from ruining
    your day and can help protect user data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, you see that there are advantages and disadvantages to both SELinux and
    AppArmor, and a lot of Linux administrators have strong feelings about which one
    they prefer. (To avoid being subjected to a flame-war, I'll refrain from stating
    my own preference.) Also, note that even though we're working with an Ubuntu virtual
    machine, the information I present here, other than the Ubuntu-specific package
    installation commands, also works with the SUSE Linux distos.
  prefs: []
  type: TYPE_NORMAL
- en: Looking at AppArmor profiles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the `/etc/apparmor.d` directory, you''ll see the AppArmor profiles for your
    system.  (The SELinux folk say policies, but the AppArmor folk say profiles.):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: The `sbin.dhclient` file and the `usr.*` files are all AppArmor profiles. You'll
    find a few other profiles in the `lxc` and `lxc-containers` subdirectories. Still,
    though, there's not a whole lot there in the way of application profiles.
  prefs: []
  type: TYPE_NORMAL
- en: 'For some reason, a default installation of OpenSUSE comes with more installed
    profiles than does Ubuntu Server.  To install more profiles on Ubuntu, use the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sudo apt install apparmor-profiles apparmor-profiles-extra`'
  prefs: []
  type: TYPE_NORMAL
- en: In the `abstractions` subdirectory, you'll find files that aren't complete profiles,
    but that can be included in complete profiles. Any one of these abstraction files
    can be included in any number of profiles. This way, you don't have to write the
    same code over and over every time you create a profile. Just include an abstraction
    file instead.
  prefs: []
  type: TYPE_NORMAL
- en: If you're familiar with programming concepts, just think of abstraction files
    as include files by another name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a partial listing of the abstraction files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'To get a feel for how AppArmor rules work, let''s peek inside the web-data
    abstraction file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'This file is nothing but a list of directories from which the Apache daemon
    is allowed to read files.  Let''s break it down:'
  prefs: []
  type: TYPE_NORMAL
- en: Note that each rule ends with `r,`. This denotes that we want for Apache to
    have read access on each listed directory. Also note that each rule has to end
    with a comma.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/srv/www/htdocs/ r,` means that the listed directory itself has read access
    for Apache.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/srv/www.htdocs/* * r,` the `* *` wildcards make this rule recursive. In other
    words, Apache can read all files in all subdirectories of this specified directory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`# mod_userdir` if installed, this Apache module allows Apache to read web
    content files from a subdirectory that''s within a user''s home directory. The
    next two lines go along with that.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@{HOME}/public_html/ r,` and `@{HOME}/public_html/ r,` the `@{HOME}` variable
    allows this rule to work with any user''s home directory. (You''ll see this variable
    defined in the `/etc/apparmor.d/tunables/home` file.)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that there's no specific rule that prohibits Apache from reading from other
    locations. It's just understood that anything that's not listed here is off-limits
    to the Apache web server daemon.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `tunables` subdirectory contains files that have predefined variables.
    You can also use this directory to  either define new variables or make profile
    tweaks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Space doesn''t permit me to show you the details of how to write your own profiles
    from scratch, and thanks to the suite of utilities that we''ll look at in the
    next section, you might never need to do that. Still, just to give you a better
    understanding about how AppArmor does what it does, here''s a chart of some example
    rules that you might find in any given profile:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `/var/run/some_program.pid rw,` | The process will have read and write privileges
    for this process ID file. |'
  prefs: []
  type: TYPE_TB
- en: '| `/etc/ld.so.cache r,` | The process will have read privileges for this file.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `/tmp/some_program.* l,` | The process will be able to create and delete
    links with the `some_program` name. |'
  prefs: []
  type: TYPE_TB
- en: '| `/bin/mount ux` | The process has executable privileges for the `mount` utility,
    which will then run unconstrained. (Unconstrained means, without an AppArmor profile.)
    |'
  prefs: []
  type: TYPE_TB
- en: Working with AppArmor command-line utilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Whether or not you have all the AppArmor utilities you need will depend on
    which Linux distro you have. On my OpenSUSE Leap workstation, the utilities were
    there out of the box.  On my Ubuntu Server virtual machine, I had to install them
    myself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'First, let''s look at the status of AppArmor on the Ubuntu machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: The first thing to note here is that AppArmor has an enforce mode and a complain
    mode.  The enforce mode does the same job as its enforcing mode counterpart in
    SELinux. It prevents system processes from doing things that the active policy
    doesn't allow, and it logs any violations. The complain mode is the same as the
    permissive mode in SELinux. It allows processes to perform actions that are prohibited
    by the active policy, but it records those actions in either the `/var/log/audit/audit.log`
    file, or the system log file, depending on whether you have `auditd` installed.
    (Unlike the Red Hat-type distros, `auditd` doesn't come installed by default on
    Ubuntu.) You would use the complain mode to either help with troubleshooting or
    to test new profiles.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the enforce mode profiles we see here have to do with either network
    management or with `lxc` container management. Two exceptions we see are the two
    profiles for `snapd`, which is the daemon that makes the snap packaging technology
    work. The third exception is for the `mysqld` profile.
  prefs: []
  type: TYPE_NORMAL
- en: Snap packages are universal binary files that are designed to work on multiple
    distros. Snap technology is currently available for Ubuntu and Fedora.
  prefs: []
  type: TYPE_NORMAL
- en: Curiously, when you install a daemon package on Ubuntu, you'll sometimes get
    a predefined profile for that daemon and sometimes you won't. Even when a profile
    does come with the package that you've installed, it's sometimes already in the
    enforce mode and sometimes it isn't. For example, if you're setting up a **Domain
    Name Service** (**DNS**) server and you install the `bind9` package for it, you'll
    get an AppArmor profile that's already in enforce mode.  If you're setting up
    a database server and install the `mysql-server` package, you'll also get a working
    profile that's already in the enforce mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'But, if you''re setting up a database server and you prefer to install the
    `mariadb-server` instead of `mysql-server`, you''ll get an AppArmor profile that''s
    completely disabled and that can''t be enabled. When you look in the `usr.sbin.mysqld`
    profile file that gets installed with the `mariadb-server` package, you''ll see
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Okay, so apparently, AppArmor isn't good for *everything*. (And, whoever wrote
    this needs to take spelling lessons.)
  prefs: []
  type: TYPE_NORMAL
- en: 'And then, there''s Samba, which is a special case in more ways than one. When
    you install the `samba` package to set up a Samba server, you don''t get any AppArmor
    profiles at all.  For Samba and several other different applications as well,
    you''ll need to install the AppArmor profiles separately:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'When you install these two profile packages, the profiles will all be in the
    complain mode.  That''s okay, because we have a handy utility to put them into
    enforce mode.  Since Samba has two different daemons that we need to protect,
    there are two different profiles that we''ll need to place into enforce mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll use `aa-enforce` to activate enforce mode for both of these profiles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: To use `aa-enforce`, you first need to specify the path to the executable file
    of the process that you want to protect. (Fortunately, you normally won't even
    have to look that up, since the path name is normally part of the profile filename.)
    The last part of the command is the name of the profile. Note that you'll need
    to restart the Samba daemon to get this AppArmor protection to take effect.
  prefs: []
  type: TYPE_NORMAL
- en: 'Placing a profile into other modes is just as easy. All you have to do is to
    replace the `aa-enforce` utility with the utility for the mode that you need to
    use. Here''s a chart of the utilities for the other modes:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `aa-audit` | Audit mode is the same as enforce mode, except that allowed
    actions get logged, as well as the actions that have been blocked. (Enforce mode
    only logs actions that have been blocked.) |'
  prefs: []
  type: TYPE_TB
- en: '| `aa-disable` | This completely disables a profile. |'
  prefs: []
  type: TYPE_TB
- en: '| `aa-complain` | This places a profile into complain mode. |'
  prefs: []
  type: TYPE_TB
- en: Troubleshooting AppArmor problems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, I've been here racking my brain for the past several days, trying to come
    up with a good troubleshooting scenario. It turns out that I didn't need to. The
    Ubuntu folk have handed me a good scenario on a silver platter, in the form of
    a buggy Samba profile.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you''ve just seen, I used `aa-enforce` to put the two Samba-related profiles
    into enforce mode. But, watch what happens now when I try to restart Samba in
    order to get the profiles to take effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Okay, that''s not good.  Looking at the status for the `smbd` service, I see
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: The important things to see here are all of the places where some form of the
    word fail shows up.
  prefs: []
  type: TYPE_NORMAL
- en: 'The original error message said to use `journalctl -xe` to view the log message.
    But, `journalctl` has this bad habit of truncating lines of output at the right
    edge of the screen. So instead, I''ll just use either `less` or `tail` to look
    in the regular `/var/log/syslog` log file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: So, we see `apparmor=DENIED`. Obviously, Samba is trying to do something that
    the profile doesn't allow. Samba needs to write temporary files to the `/run/samba/msg.lock`
    directory, but it isn't allowed to. I'm guessing that the profile is missing a
    rule that allows that to happen.
  prefs: []
  type: TYPE_NORMAL
- en: 'But, even if this log file entry were to give me no clue at all, I could just
    cheat, using a troubleshooting technique that has served me well for many years.
    That is, I could just copy and paste the error message from the log file into
    my favorite search engine. Pretty much every time I''ve ever done that, I''ve
    found that other people before me have already had the same problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2863fea5-dc91-4895-8bdb-503a1a4e85f7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Okay, I didn''t paste in the entire error message, but I did paste in enough
    for DuckDuckGo to work with. And, lo and behold, it worked:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b67de595-546a-4e65-8351-2ed4f3c5487a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Hmmm, it looks like my profile file might be missing an important line. So,
    I''ll open the `usr.sbin.smbd` file and place this line at the end of the rule
    set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'This line will allow read and write access to everything in the `/run/samba`
    directory. After making the edit, I''ll need to reload this profile because it''s
    already been loaded with `aa-enforce`. For this, I''ll use the `apparmor_parser`
    utility:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'All you need to do is use the `-r` option for reloading and list the name of
    the profile file.  Now, let''s try to restart Samba:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: And, it works.  The two Samba profiles are in enforce mode, and Samba finally
    starts up just fine.
  prefs: []
  type: TYPE_NORMAL
- en: The odd part about this is that I had this same problem with both Ubuntu 16.04
    and Ubuntu 17.10\. So, the bug has been there for a long time, and it would seem
    that the Ubuntu folk either don't know about it or don't care to fix it. In a
    way, I hope that it never does get fixed because getting it fixed would ruin a
    perfectly good training demo for me.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at the basic principles of Mandatory Access Control
    and compared two different Mandatory Access Control systems. We saw what SELinux
    and AppArmor are and how they can help safeguard your systems from malicious actors.
    We then looked at the basics of how to use them and the basics of how to troubleshoot
    them. We also saw that even though they're both meant to do the same job, they
    work in vastly different ways.
  prefs: []
  type: TYPE_NORMAL
- en: Whether you're working with AppArmor or with SELinux, you'll always want to
    thoroughly test a new system in either complain or permissive mode before you
    put it into production.  Make sure that what you want to protect gets protected,
    while at the same time, what you want to allow gets allowed. After you place the
    machine into production, don't just assume that you can automatically change a
    policy setting every time you see a policy violation occur. It could be that nothing
    is wrong with your Mandatory Access Control setup and that MAC is just doing its
    job in protecting you from the bad guys.
  prefs: []
  type: TYPE_NORMAL
- en: There's a lot more to both of these topics than we can cover here. Hopefully,
    though, I've given you enough to whet your appetite and enough to help you out
    in your day-to-day duties.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll look at scanning, auditing, and hardening.  I'll
    see you there.
  prefs: []
  type: TYPE_NORMAL
