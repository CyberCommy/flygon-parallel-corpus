- en: Writing Clean and Lean Code with Vue
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Vue编写干净、精简的代码
- en: In this section, we'll be investigating how a Vue.js instance works at a lower
    level by looking at how this is handled by Vue. We'll also be looking at the various
    properties on our instance such as data, computed, watch, as well as best practices
    when using each one. Furthermore, we'll be looking at the various lifecycle hooks
    available within our Vue instance, allowing us to call particular functions at
    various stages of our application. Finally, we'll be investigating the **Document
    Object Model** (**DOM**) and why Vue implements a Virtual DOM for enhanced performance.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将调查Vue.js实例在更低级别上的工作方式，看看Vue是如何处理this的。我们还将查看实例上的各种属性，如数据、计算、观察，以及在使用每个属性时的最佳实践。此外，我们将查看Vue实例中可用的各种生命周期钩子，允许我们在应用程序的各个阶段调用特定函数。最后，我们将调查**文档对象模型**（**DOM**）以及为什么Vue实现了虚拟DOM以提高性能。
- en: 'By the end of this chapter you will:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将：
- en: Have a greater understanding of how `this` keyword works within JavaScript
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更好地理解JavaScript中`this`关键字的工作原理
- en: Understand how Vue proxies `this` keyword within Vue instances
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解Vue如何在Vue实例中代理`this`关键字
- en: Use data properties to create reactive bindings
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用数据属性创建响应式绑定
- en: Use computed properties to create declarative functions based on our data model
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用计算属性基于我们的数据模型创建声明性函数
- en: Use watched properties to access asynchronous data and build upon the foundations
    of computed properties
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用观察属性访问异步数据，并在计算属性的基础上构建
- en: Use lifecycle hooks to activate functionality at particular stages of the Vue
    lifecycle
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用生命周期钩子在Vue生命周期的特定阶段激活功能
- en: Investigate the DOM and Virtual DOM for an understanding of how Vue renders
    data to the screen
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调查DOM和虚拟DOM，以了解Vue如何将数据渲染到屏幕上
- en: To begin, let's start off by looking into how this works within JavaScript and
    how this relates to the context within our Vue instances.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们来看看在JavaScript中this是如何工作的，以及它如何与我们的Vue实例中的上下文相关联。
- en: Proxying
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代理
- en: 'So far, you may have interacted with a Vue application and thought to yourself:
    How does `this` work the way it does? Before looking into how Vue.js handles `this`,
    let''s have a look at how it works within JavaScript.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您可能已经与Vue应用程序进行了交互，并想过：`this`是如何工作的？在查看Vue.js如何处理`this`之前，让我们先看看它在JavaScript中是如何工作的。
- en: How 'this' works within JavaScript
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解JavaScript中的'this'工作原理
- en: 'Within JavaScript, `this` has varying contexts that range from the global window
    context to eval, newable, and function contexts. As the default context for this
    relates to the global scope, this is our window object:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，`this`具有不同的上下文，从全局窗口上下文到eval、可实例化和函数上下文。由于默认上下文与全局范围相关，因此this是我们的窗口对象：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The context of this changes depending on where we are in scope. This means,
    that if we had a `Student` object with particular values, such as `firstName`,
    `lastName`, `grades`, and so on, the context of `this` would be related to the
    object itself:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: this的上下文会根据我们所处的范围而改变。这意味着，如果我们有一个`Student`对象，具有特定的值，比如`firstName`、`lastName`、`grades`等，那么`this`的上下文将与对象本身相关联：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'When we run the preceding code with `console.log(Student.toString())`, we get
    this: `Student Paul Halliday scored 315/500` as the context of this is now scoped
    to the object itself rather than the global window scope.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行上述代码并使用`console.log(Student.toString())`时，我们会得到这个结果：`Student Paul Halliday
    scored 315/500`，因为此时this的上下文现在是对象本身，而不是全局窗口范围。
- en: 'If we wanted to display this in the document we could do it like so:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要在文档中显示this，我们可以这样做：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Notice that, with the preceding code, once again we don't have to use `this`
    as it isn't needed with the global context.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在上述代码中，我们再次不必使用`this`，因为它在全局上下文中不需要。
- en: Now that we have an understanding of how `this` works at a basic level, we can
    investigate how Vue proxies `this` inside of our instances to make interacting
    with the various properties much easier.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: How Vue handles 'this'
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may have noticed up to this point that we're able to reference values inside
    of our data, methods, and other objects using `this` syntax, but the actual structure
    of our instance is `this.data.propertyName` or `this.methods.methodName`; all
    of this is possible due to the way Vue proxies our instance properties.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a very simple Vue application that has one instance. We have a `data`
    object that has a `message` variable and a method named `showAlert`; how does
    Vue know how to access our alert text with `this.message`?
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Vue proxies the instance properties to the top level object, allowing us to
    access these properties via this. If we were to log out the instance to the console
    (with the help of Vue.js devtools), we''d get the following result:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/50163bb3-787a-4250-b7fd-4f3aec51aad6.png)Console logout'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: The key properties to look at within the preceding screenshot are `message`
    and `showAlert`, both of which are defined on our Vue instance yet proxied to
    the root object instance at initialization time.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Data properties
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we add a variable to our data object, we''re essentially creating a reactive
    property that updates the view any time it changes. This means that, if we had
    a data object with a property named `firstName`, that property would be re-rendered
    on the screen each time the value changes:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This reactivity does not extend to objects added to our Vue instance after
    the instance has been created outside of the data object. If we had another example
    of this, but this time including appending another property such as `fullName`
    to the instance itself:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Even though this item is on the root instance (the same as our `firstName` variable),
    `fullName` is not reactive and will not re-render upon any changes. This does
    not work because, when the Vue instance is initialized, it maps over each one
    of the properties and adds a getter and setter to each data property, thus, if
    we add a new property after initialization, it lacks this and is not reactive.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: 'How does Vue achieve reactive properties? Currently, it uses `Object.defineProperty`
    to define a custom getter/setter for items inside of the instance. Let''s create
    our own property on an object with standard `get`/`set` features:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As the watchers are set with a custom property setter/getter, merely adding
    a property to the instance after initialization doesn't allow for reactivity.
    This is likely to change within Vue 3 as it will be using the newer ES2015+ Proxy
    API (but potentially lacking support for older browsers).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: There's more to our Vue instance than a data property! Let's use computed to
    create reactive, derived values based on items inside of our data model.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Computed properties
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll be looking at computed properties within our Vue instance.
    This allows us to create small, declarative functions that return a singular value
    based on items inside of our data model. Why is this important? Well, if we kept
    all of our logic inside of our templates, both our team members and our future
    self would have to do more work to understand what our application does.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, we can use computed properties to vastly simplify our templates and
    create variables that we can reference instead of the logic itself. It goes further
    than an abstraction; computed properties are cached and will not be recalculated
    unless a dependency has changed.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a simple project to see this in action:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Interpolation is powerful; for example, inside of our Vue.js templates we can
    take a string (for example, `firstName`) and reverse this using the `reverse()`
    method:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We'll now be showing a reversed version of our `firstName`, so Paul would become
    luaP. The issue with this is that it's not very practical to keep logic inside
    of our templates. If we'd like to reverse multiple fields, we have to then add
    another `split()`, `reverse()`, and `join()` on each property. To make this more
    declarative, we can use computed properties.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside of `App.vue`, we can add a new computed object, that contains a function
    named `reversedName`; this takes our logic for reversing our string and allows
    us to abstract this into a function containing logic that would otherwise pollute
    the template:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We could then see more information about our computed properties within Vue.js
    devtools:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/87c61f6b-3255-4c45-a91c-25b30ef83b86.png)Using devtools to display
    data'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: In our simple example, it's important to realize that, while we could make this
    a method, there are reasons why we should keep this as a computed property. Computed
    properties are cached and are not re-rendered unless their dependency changes,
    which is especially important if we have a larger data-driven application.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Watched properties
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Computed properties are not always the answer to our reactive data problems,
    sometimes we need to create our own custom watched properties. Computed properties
    can only be synchronous, must be pure (for example, no observed side-effects),
    and return a value; this is in direct contrast to a watched property, which is
    often used to deal with asynchronous data.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: 'A watched property allows us to reactively execute a function whenever a piece
    of data changes. This means that we can call a function every time an item from
    our data object changes, and we''ll have access to this changed value as a parameter.
    Let''s take a look at this with a simple example:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: 'Note: `Axios` is a library that will need to be added to the project. To do
    so, head to [https://github.com/axios/axios](https://github.com/axios/axios) and
    follow the installation steps provided.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In this example, any time our text box changes with a new `id` (1-10), we get
    information about that particular user, like so:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/1224f47e-0825-4425-8944-6b071bbcb57d.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
- en: This is effectively watching for any changes on the `id` and calling the `getDataForUser`
    method, retrieving new data about this user.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: Although watched properties do have a lot of power, the benefits of computed
    properties on performance and ease of use should not be understated; therefore
    wherever possible, favor computed properties over watched properties.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: Lifecycle hooks
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have access to a variety of lifecycle hooks that fire at particular points
    during the creation of our Vue instance. These hooks range from prior to creation
    with `beforeCreate`, to after the instance is `mounted`, `destroyed`, and many
    more in between.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: As the following figure shows, the creation of a new Vue instance fires off
    functions at varying stages of the instance lifecycle.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll be looking at how we can activate these hooks within this section:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/97a8afa9-3bb9-4a72-8ee6-c4e2da52ebcc.png)Vue.js instance lifecycle
    hooks'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: 'Taking advantage of the lifecycle hooks ([https://vuejs.org/v2/guide/instance.html](https://vuejs.org/v2/guide/instance.html))
    can be done in a similar way to any other property on our Vue instance. Let''s
    take a look at how we can interact with each one of the hooks, starting from the
    top; I''ll be creating another project based on the standard `webpack-simple`
    template:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Notice how we''ve simply added these functions to our instance without any
    extra imports or syntax. We then get two different log statements in our console,
    one prior to the creation of our instance and one after it has been created. The
    next stage for our instance is the `beforeMounted` and `mounted` hooks; if we
    add these, we''ll be able to see a message on the console once again:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If we then modified our template so it had a button that updated one of our
    data properties, we''d be able to fire a `beforeUpdated` and `updated` hook:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Whenever we select the `Update Message` button, our `beforeUpdated` and `updated`
    hooks both fire. This allows us to perform an action at this stage in the lifecycle,
    leaving us only with `beforeDestroy` and destroyed yet to cover. Let''s add a
    button and a method to our instance that call `$destroy`, allowing us to trigger
    the appropriate lifecycle hook:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We can then add the `remove` method to our instance, as well as the functions
    that allow us to capture the appropriate hooks:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: When we select the `destroy` instance button, the `beforeDestroy` and `destroy`
    lifecycle hooks will fire. This allows us to clean up any subscriptions or perform
    any other action(s) when destroying an instance. In a real-world scenario, lifecycle
    control should be left up to data-driven directives, such as `v-if` and `v-for`.
    We'll be looking at these directives in more detail in the next chapter.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: Vue.js and the Virtual DOM
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: On the topic of performance improvements, let's consider why Vue.js makes extensive
    use of the Virtual DOM to render our elements on the screen. Before looking at
    the Virtual DOM, we need to have a foundational understanding of what the DOM
    actually is.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: DOM
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The DOM is what is used to describe the structure of an HTML or XML page. It
    creates a tree-like structure that provides us with the ability to do everything
    from creating, reading, updating, and deleting nodes to traversing the tree and
    many more features, all within JavaScript. Let''s consider the following HTML
    page:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We''re able to look at the HTML and see that we have one **div**, two **p**,
    one **ul**, and **li** tags. The browser parses this HTML and produces the DOM
    Tree, which at a high level looks similar to this:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/485fcd82-ca94-4e09-ba7e-97939f5f35bc.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
- en: 'We can then interact with the DOM to get access to these elements by `TagName`
    using `document.getElementsByTagName()`, returning a HTML collection. If we wanted
    to map over these collection objects, we could create an array of these elements
    using `Array.from`. The following is an example:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This should then log the `innerHTML` of each item to the console inside of
    our array(s), thus showing how we can access items inside of the DOM:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/7d4c9117-6dba-4c11-97fd-50b7cfa44e38.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
- en: Virtual DOM
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Updating DOM nodes is computationally expensive and depending on the size of
    your application, this can substantially slow down the performance of your application.
    The Virtual DOM takes the concept of the DOM and provides us an abstraction, which
    allows for a diffing algorithm to be used to update DOM nodes. To fully take advantage
    of this, these nodes are no longer accessed with the document prefix and instead
    are often represented as JavaScript objects.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: This allows Vue to work out exactly *what* changed and only re-render items
    in the actual DOM that is different from the previous.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned more about the Vue instance and how we can take
    advantage of a variety of property types such as data, watchers, computed values,
    and more. We've learned about how `this` works in JavaScript and the differences
    when using it inside of a Vue instance. Furthermore, we've investigated the DOM
    and why Vue uses the Virtual DOM to create performant applications.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: In summary, data properties allow for reactive properties within our templates,
    computed properties allow us to take our template and filtering logic and separate
    it into performant properties that can be accessed within our templates, and watched
    properties allow us to work with the complexities of asynchronous operations.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll be taking an in-depth look at Vue directives, such
    as `v-if`, `v-model`, `v-for`, and how they can be used to create powerful reactive
    applications.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
