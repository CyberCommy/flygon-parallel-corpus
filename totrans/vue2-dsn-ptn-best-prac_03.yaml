- en: Writing Clean and Lean Code with Vue
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll be investigating how a Vue.js instance works at a lower
    level by looking at how this is handled by Vue. We'll also be looking at the various
    properties on our instance such as data, computed, watch, as well as best practices
    when using each one. Furthermore, we'll be looking at the various lifecycle hooks
    available within our Vue instance, allowing us to call particular functions at
    various stages of our application. Finally, we'll be investigating the **Document
    Object Model** (**DOM**) and why Vue implements a Virtual DOM for enhanced performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end of this chapter you will:'
  prefs: []
  type: TYPE_NORMAL
- en: Have a greater understanding of how `this` keyword works within JavaScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand how Vue proxies `this` keyword within Vue instances
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use data properties to create reactive bindings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use computed properties to create declarative functions based on our data model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use watched properties to access asynchronous data and build upon the foundations
    of computed properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use lifecycle hooks to activate functionality at particular stages of the Vue
    lifecycle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Investigate the DOM and Virtual DOM for an understanding of how Vue renders
    data to the screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To begin, let's start off by looking into how this works within JavaScript and
    how this relates to the context within our Vue instances.
  prefs: []
  type: TYPE_NORMAL
- en: Proxying
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, you may have interacted with a Vue application and thought to yourself:
    How does `this` work the way it does? Before looking into how Vue.js handles `this`,
    let''s have a look at how it works within JavaScript.'
  prefs: []
  type: TYPE_NORMAL
- en: How 'this' works within JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Within JavaScript, `this` has varying contexts that range from the global window
    context to eval, newable, and function contexts. As the default context for this
    relates to the global scope, this is our window object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The context of this changes depending on where we are in scope. This means,
    that if we had a `Student` object with particular values, such as `firstName`,
    `lastName`, `grades`, and so on, the context of `this` would be related to the
    object itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run the preceding code with `console.log(Student.toString())`, we get
    this: `Student Paul Halliday scored 315/500` as the context of this is now scoped
    to the object itself rather than the global window scope.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we wanted to display this in the document we could do it like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Notice that, with the preceding code, once again we don't have to use `this`
    as it isn't needed with the global context.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have an understanding of how `this` works at a basic level, we can
    investigate how Vue proxies `this` inside of our instances to make interacting
    with the various properties much easier.
  prefs: []
  type: TYPE_NORMAL
- en: How Vue handles 'this'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may have noticed up to this point that we're able to reference values inside
    of our data, methods, and other objects using `this` syntax, but the actual structure
    of our instance is `this.data.propertyName` or `this.methods.methodName`; all
    of this is possible due to the way Vue proxies our instance properties.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a very simple Vue application that has one instance. We have a `data`
    object that has a `message` variable and a method named `showAlert`; how does
    Vue know how to access our alert text with `this.message`?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Vue proxies the instance properties to the top level object, allowing us to
    access these properties via this. If we were to log out the instance to the console
    (with the help of Vue.js devtools), we''d get the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/50163bb3-787a-4250-b7fd-4f3aec51aad6.png)Console logout'
  prefs: []
  type: TYPE_NORMAL
- en: The key properties to look at within the preceding screenshot are `message`
    and `showAlert`, both of which are defined on our Vue instance yet proxied to
    the root object instance at initialization time.
  prefs: []
  type: TYPE_NORMAL
- en: Data properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we add a variable to our data object, we''re essentially creating a reactive
    property that updates the view any time it changes. This means that, if we had
    a data object with a property named `firstName`, that property would be re-rendered
    on the screen each time the value changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This reactivity does not extend to objects added to our Vue instance after
    the instance has been created outside of the data object. If we had another example
    of this, but this time including appending another property such as `fullName`
    to the instance itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Even though this item is on the root instance (the same as our `firstName` variable),
    `fullName` is not reactive and will not re-render upon any changes. This does
    not work because, when the Vue instance is initialized, it maps over each one
    of the properties and adds a getter and setter to each data property, thus, if
    we add a new property after initialization, it lacks this and is not reactive.
  prefs: []
  type: TYPE_NORMAL
- en: 'How does Vue achieve reactive properties? Currently, it uses `Object.defineProperty`
    to define a custom getter/setter for items inside of the instance. Let''s create
    our own property on an object with standard `get`/`set` features:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As the watchers are set with a custom property setter/getter, merely adding
    a property to the instance after initialization doesn't allow for reactivity.
    This is likely to change within Vue 3 as it will be using the newer ES2015+ Proxy
    API (but potentially lacking support for older browsers).
  prefs: []
  type: TYPE_NORMAL
- en: There's more to our Vue instance than a data property! Let's use computed to
    create reactive, derived values based on items inside of our data model.
  prefs: []
  type: TYPE_NORMAL
- en: Computed properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll be looking at computed properties within our Vue instance.
    This allows us to create small, declarative functions that return a singular value
    based on items inside of our data model. Why is this important? Well, if we kept
    all of our logic inside of our templates, both our team members and our future
    self would have to do more work to understand what our application does.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, we can use computed properties to vastly simplify our templates and
    create variables that we can reference instead of the logic itself. It goes further
    than an abstraction; computed properties are cached and will not be recalculated
    unless a dependency has changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a simple project to see this in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Interpolation is powerful; for example, inside of our Vue.js templates we can
    take a string (for example, `firstName`) and reverse this using the `reverse()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We'll now be showing a reversed version of our `firstName`, so Paul would become
    luaP. The issue with this is that it's not very practical to keep logic inside
    of our templates. If we'd like to reverse multiple fields, we have to then add
    another `split()`, `reverse()`, and `join()` on each property. To make this more
    declarative, we can use computed properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside of `App.vue`, we can add a new computed object, that contains a function
    named `reversedName`; this takes our logic for reversing our string and allows
    us to abstract this into a function containing logic that would otherwise pollute
    the template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We could then see more information about our computed properties within Vue.js
    devtools:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/87c61f6b-3255-4c45-a91c-25b30ef83b86.png)Using devtools to display
    data'
  prefs: []
  type: TYPE_NORMAL
- en: In our simple example, it's important to realize that, while we could make this
    a method, there are reasons why we should keep this as a computed property. Computed
    properties are cached and are not re-rendered unless their dependency changes,
    which is especially important if we have a larger data-driven application.
  prefs: []
  type: TYPE_NORMAL
- en: Watched properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Computed properties are not always the answer to our reactive data problems,
    sometimes we need to create our own custom watched properties. Computed properties
    can only be synchronous, must be pure (for example, no observed side-effects),
    and return a value; this is in direct contrast to a watched property, which is
    often used to deal with asynchronous data.
  prefs: []
  type: TYPE_NORMAL
- en: 'A watched property allows us to reactively execute a function whenever a piece
    of data changes. This means that we can call a function every time an item from
    our data object changes, and we''ll have access to this changed value as a parameter.
    Let''s take a look at this with a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note: `Axios` is a library that will need to be added to the project. To do
    so, head to [https://github.com/axios/axios](https://github.com/axios/axios) and
    follow the installation steps provided.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, any time our text box changes with a new `id` (1-10), we get
    information about that particular user, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/1224f47e-0825-4425-8944-6b071bbcb57d.png)'
  prefs: []
  type: TYPE_IMG
- en: This is effectively watching for any changes on the `id` and calling the `getDataForUser`
    method, retrieving new data about this user.
  prefs: []
  type: TYPE_NORMAL
- en: Although watched properties do have a lot of power, the benefits of computed
    properties on performance and ease of use should not be understated; therefore
    wherever possible, favor computed properties over watched properties.
  prefs: []
  type: TYPE_NORMAL
- en: Lifecycle hooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have access to a variety of lifecycle hooks that fire at particular points
    during the creation of our Vue instance. These hooks range from prior to creation
    with `beforeCreate`, to after the instance is `mounted`, `destroyed`, and many
    more in between.
  prefs: []
  type: TYPE_NORMAL
- en: As the following figure shows, the creation of a new Vue instance fires off
    functions at varying stages of the instance lifecycle.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll be looking at how we can activate these hooks within this section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/97a8afa9-3bb9-4a72-8ee6-c4e2da52ebcc.png)Vue.js instance lifecycle
    hooks'
  prefs: []
  type: TYPE_NORMAL
- en: 'Taking advantage of the lifecycle hooks ([https://vuejs.org/v2/guide/instance.html](https://vuejs.org/v2/guide/instance.html))
    can be done in a similar way to any other property on our Vue instance. Let''s
    take a look at how we can interact with each one of the hooks, starting from the
    top; I''ll be creating another project based on the standard `webpack-simple`
    template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice how we''ve simply added these functions to our instance without any
    extra imports or syntax. We then get two different log statements in our console,
    one prior to the creation of our instance and one after it has been created. The
    next stage for our instance is the `beforeMounted` and `mounted` hooks; if we
    add these, we''ll be able to see a message on the console once again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If we then modified our template so it had a button that updated one of our
    data properties, we''d be able to fire a `beforeUpdated` and `updated` hook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Whenever we select the `Update Message` button, our `beforeUpdated` and `updated`
    hooks both fire. This allows us to perform an action at this stage in the lifecycle,
    leaving us only with `beforeDestroy` and destroyed yet to cover. Let''s add a
    button and a method to our instance that call `$destroy`, allowing us to trigger
    the appropriate lifecycle hook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then add the `remove` method to our instance, as well as the functions
    that allow us to capture the appropriate hooks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: When we select the `destroy` instance button, the `beforeDestroy` and `destroy`
    lifecycle hooks will fire. This allows us to clean up any subscriptions or perform
    any other action(s) when destroying an instance. In a real-world scenario, lifecycle
    control should be left up to data-driven directives, such as `v-if` and `v-for`.
    We'll be looking at these directives in more detail in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Vue.js and the Virtual DOM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: On the topic of performance improvements, let's consider why Vue.js makes extensive
    use of the Virtual DOM to render our elements on the screen. Before looking at
    the Virtual DOM, we need to have a foundational understanding of what the DOM
    actually is.
  prefs: []
  type: TYPE_NORMAL
- en: DOM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The DOM is what is used to describe the structure of an HTML or XML page. It
    creates a tree-like structure that provides us with the ability to do everything
    from creating, reading, updating, and deleting nodes to traversing the tree and
    many more features, all within JavaScript. Let''s consider the following HTML
    page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re able to look at the HTML and see that we have one **div**, two **p**,
    one **ul**, and **li** tags. The browser parses this HTML and produces the DOM
    Tree, which at a high level looks similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/485fcd82-ca94-4e09-ba7e-97939f5f35bc.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can then interact with the DOM to get access to these elements by `TagName`
    using `document.getElementsByTagName()`, returning a HTML collection. If we wanted
    to map over these collection objects, we could create an array of these elements
    using `Array.from`. The following is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This should then log the `innerHTML` of each item to the console inside of
    our array(s), thus showing how we can access items inside of the DOM:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/7d4c9117-6dba-4c11-97fd-50b7cfa44e38.png)'
  prefs: []
  type: TYPE_IMG
- en: Virtual DOM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Updating DOM nodes is computationally expensive and depending on the size of
    your application, this can substantially slow down the performance of your application.
    The Virtual DOM takes the concept of the DOM and provides us an abstraction, which
    allows for a diffing algorithm to be used to update DOM nodes. To fully take advantage
    of this, these nodes are no longer accessed with the document prefix and instead
    are often represented as JavaScript objects.
  prefs: []
  type: TYPE_NORMAL
- en: This allows Vue to work out exactly *what* changed and only re-render items
    in the actual DOM that is different from the previous.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned more about the Vue instance and how we can take
    advantage of a variety of property types such as data, watchers, computed values,
    and more. We've learned about how `this` works in JavaScript and the differences
    when using it inside of a Vue instance. Furthermore, we've investigated the DOM
    and why Vue uses the Virtual DOM to create performant applications.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, data properties allow for reactive properties within our templates,
    computed properties allow us to take our template and filtering logic and separate
    it into performant properties that can be accessed within our templates, and watched
    properties allow us to work with the complexities of asynchronous operations.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll be taking an in-depth look at Vue directives, such
    as `v-if`, `v-model`, `v-for`, and how they can be used to create powerful reactive
    applications.
  prefs: []
  type: TYPE_NORMAL
