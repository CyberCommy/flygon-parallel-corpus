- en: '*Chapter 9*: Helm Security Considerations'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you have likely come to realize throughout this book, Helm is a powerful
    tool that presents many deployment possibilities to users. This power can, however,
    get out of hand if certain security paradigms are not recognized and followed.
    Luckily, Helm provides many ways to incorporate security into everyday usage in
    ways that are simple to achieve, from the moment the Helm CLI is downloaded to
    the moment a Helm chart is installed on a Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Data provenance and integrity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Helm chart security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additional considerations around RBAC, values, and chart repositories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter will make use of the following technologies:'
  prefs: []
  type: TYPE_NORMAL
- en: '`minikube`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kubectl`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Helm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GNU Privacy Guard** (**GPG**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The installation and configuration of Minikube, Kubectl, and Helm was covered
    in [*Chapter 2*](B15458_02_Final_JM_ePub.xhtml#_idTextAnchor098), *Preparing a
    Kubernetes and Helm Environment*.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will also leverage the `guestbook` chart from the Packt repository, located
    at [https://github.com/PacktPublishing/-Learn-Helm](https://github.com/PacktPublishing/-Learn-Helm),
    for a later example in this chapter. If you have not already cloned this repository,
    be sure to do so with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Data provenance and integrity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When working with any kind of data, there are two often-overlooked questions
    that should be considered:'
  prefs: []
  type: TYPE_NORMAL
- en: Does the data come from a reliable source or from the source that you expected
    it to?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does the data contain all of the contents that you expected it to?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first question refers to the topic of **data provenance**. Data provenance
    is about determining where data originated from.
  prefs: []
  type: TYPE_NORMAL
- en: The second question refers to the topic of **data integrity**. Data integrity
    is about determining whether the contents you received from a remote location
    represent what you expected to receive and can help determine whether the data
    was tampered with as it was sent through the wire. Both data provenance and data
    integrity can be verified using a concept called **digital signatures**. An author
    can create a unique signature based on cryptography to sign data and the consumer
    of that data can use cryptographic tools to verify the authenticity of that signature.
  prefs: []
  type: TYPE_NORMAL
- en: If the authenticity is verified, then the consumer knows that the data originates
    from the expected source and was not tampered with as it was transferred.
  prefs: []
  type: TYPE_NORMAL
- en: Authors can create a digital signature by first creating a **Pretty Good Privacy**
    (**PGP**) keypair. PGP, in this context, refers to OpenPGP, which is a set of
    standards based on encryption. PGP focuses on establishing asymmetric encryption,
    which is based on the use of two different keys—private and public.
  prefs: []
  type: TYPE_NORMAL
- en: Private keys are meant to be kept secret, while public keys are designed to
    be shared. For digital signatures, the private key is used to encrypt data, while
    a public key is used by consumers to decrypt that data. The PGP keypair is often
    created using a tool called GPG, which is an open source tool that implements
    the OpenPGP standard.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the PGP keypair is created, the author can use GPG to sign the data. When
    the data is signed, GPG performs the following steps in the background:'
  prefs: []
  type: TYPE_NORMAL
- en: A hash is calculated based on the contents of the data. The output is a fixed-length
    string called the **message digest**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The message digest is encrypted using the author's private key. The output is
    the digital signature.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To verify the signature, consumers must use the author's public key to decrypt
    it. This verification can also be performed using GPG.
  prefs: []
  type: TYPE_NORMAL
- en: 'Digital signatures play a role in Helm in two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: First, each Helm download has an accompanying digital signature from one of
    the maintainers that can be used to verify the authenticity of the binary. The
    signature can be used to verify the origin of the download, as well as its integrity.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Second, Helm charts can also be digitally signed to benefit from the same verifications.
    Authors of a chart sign the chart during packaging and the chart users verify
    the validity of the chart by using the author's public key.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With an understanding of how data provenance and integrity come into play as
    they relate to digital signatures, let's create a GPG keypair on your local work
    station, if you do not already have one, that will be used to elaborate on many
    of the previously described concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a GPG keypair
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to create a keypair, you must first have GPG installed on your local
    machine. Use the following instructions as a guide to install GPG on your local
    machine. Note that on Linux systems, you probably already have GPG installed:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For Windows, you can use the Chocolatey package manager, as in the following
    command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You can also download the installer for Win[dows from https://gpg4win.org/dow](https://gpg4win.org/download.html)nload.html.
  prefs: []
  type: TYPE_NORMAL
- en: 'For macOS, you can use the Homebrew package manager using the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: You can also download the macOS-based insta[lled from https://sourceforge.net/p/gpgosx/docu](https://sourceforge.net/p/gpgosx/docu/Download/)/Download/.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Debian-based Linux distributions, you can use the `apt` package manager,
    as shown:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'For RPM-based Linux distributions, you can use the `dnf` package manager, as
    shown:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Once you have installed GPG, you can create your own GPG keypair, which we will
    use throughout our discussion on data provenance and integrity.
  prefs: []
  type: TYPE_NORMAL
- en: 'The steps to configure this keypair are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to create a new keypair. This command can be run
    from any directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Follow the prompts to enter your name and email address. These will be used
    to identify you as the owner of the keypair and will be the name and email address
    seen by people who receive your public key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press the *O* key to continue.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will then be prompted to enter your private key password. Enter and confirm
    the desired passphrase that will be used for encryption and decryption operations..
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will see an output similar to the following once your GPG keypair has been
    created:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1: The output after the successful creation of the GPG keypair'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_9.1.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.1: The output following successful creation of the GPG keypair'
  prefs: []
  type: TYPE_NORMAL
- en: The output displays information about the public (`pub`) and private (`sub`)
    keys, as well as the fingerprint of the public key (the second line of the output).
    The fingerprint is a unique identifier used to identify you as the owner of that
    key. The third line, beginning with `uid`, displays the name and email address
    that you entered as you generated your GPG keypair.
  prefs: []
  type: TYPE_NORMAL
- en: With your `gpg` keypair now created, continue to the next section to learn how
    a Helm download can be verified.
  prefs: []
  type: TYPE_NORMAL
- en: Verifying Helm downloads
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As discussed in *Chapter 2*, *Preparing a Kubernetes and Helm Environment*,
    one of the ways Helm can be installed is by downloading an archive from GitHub.
    These archives can be installed from Helm''s GitHub releases page ([https://github.com/helm/helm/releases](https://github.com/helm/helm/releases))
    by selecting one of the links shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.2: The Installation section from Helm’s GitHub releases page'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_9.2.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.2: The Installation section from Helm''s GitHub releases page'
  prefs: []
  type: TYPE_NORMAL
- en: At the bottom of the **Installation** section, you'll notice a paragraph explaining
    that the release was signed. Each Helm release is signed by a Helm maintainer
    and can be verified against the digital signature that corresponds to the downloaded
    Helm release. Each of the digital signatures are located under the **Assets**
    section.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows how these are represented:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.3: The Assets section from Helm’s GitHub releases page'
  prefs: []
  type: TYPE_NORMAL
- en: '](image/Figure_9.3.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.3: The Assets section from Helm''s GitHub releases page'
  prefs: []
  type: TYPE_NORMAL
- en: To verify the provenance and integrity of your Helm download, you should also
    download the corresponding `.asc` file. Note that `.sha256.asc` files are used
    to verify the integrity only. In this example, we will download the corresponding
    `.asc` file, which will verify both the provenance and integrity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Begin verifying a Helm release by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Download the Helm archive under the installation that corresponds with your
    operating system. Although the Helm binary is likely already installed, you can
    still download an archive to follow along with the example. Once you have finished
    with the example, you can remove the archive from your workstation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Download the `.asc` file that corresponds with your operating system. For example,
    if you are running an AMD64-based Linux system, you would download the `helm-v3.0.0-linux-amd64.tar.gz.asc`
    file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The version contained in the filename corresponds to the actual Helm version
    you are downloading.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once both files are downloaded, you should see two similar files in the same
    directory on the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The next step involves importing the Helm maintainer's public key to your local
    `gpg` keyring. This allows you to decrypt the digital signature contained in the
    `.asc` file to verify the provenance and integrity of your download. The maintainer's
    public key can be retrieved by following the link to their keybase account. The
    link can be found by hovering your cursor over the `keybase account` words. In
    the example from *Figure 9.2*, this location resolves to [https://keybase.io/bacongobbler](https://keybase.io/bacongobbler).
    The public key can then be downloaded by adding `/pgp_keys.asc` to the end, making
    the [resulting link https://keybase.io/bacongobbl](https://keybase.io/bacongobbler/pgp_keys.asc)er/pgp_keys.asc.
  prefs: []
  type: TYPE_NORMAL
- en: Note that there are multiple Helm maintainers, so your link may differ if you
    are performing verification on a different release. Be sure that you are downloading
    the correct public key that corresponds to the key that signed the release.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s continue with the verification process:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the command line, download the public key corresponding to the Helm release
    signature:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Once downloaded, you need to import the public key to your gpg keyring. This
    is done by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'If the import is successful, you will see the following message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that the public key of the digital signature has been imported, you can
    verify the Helm installation''s release by leveraging the `--verify` subcommand
    of GPG. This should be run against the `helm*.asc` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This command will attempt to decrypt the digital signature contained in the
    `.asc` file. If it is successful, it means that the Helm download (the file ending
    in `.tar.gz`) was signed by the person you expect (`Matthew Fisher` for this release)
    and the download was not modified or altered in any way. A successful output is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Upon further inspection of this output, you may notice the `WARNING` message
    indicating that the key was not certified, which may lead you to question the
    validity of whether this was actually successful. The verification was successful,
    but you have not instructed gpg that the maintainer's public key is certified
    to belong to the person they say it belongs to.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can perform this certification by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check that the last 64 bits (8 characters) of the primary key fingerprint displayed
    at the end of the output match the 64-bit fingerprint displayed in the Helm releases
    page. As you will recall from *Figure 9.2*, the fingerprint was displayed, as
    shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from the preceding code, the last 64 bits of the **primary key
    fingerprint** is displayed on the Helm releases page, so we know that this public
    key does belong to who we expect it to. As a result, we can safely certify the
    maintainer''s public key. This can be done by signing the public key using your
    own `gpg` keypair. Perform this step by using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In the `Really sign?` prompt, enter `y`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now that you have signed the maintainer''s public key, the key is now certified.
    The verification can now be run without displaying a `WARNING` message in the
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Digital signatures also play a role in verifying the provenance and integrity
    of Helm charts. We will continue this discussion in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Signing and verifying Helm charts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Similar to how the Helm maintainers sign releases, you can sign your own Helm
    charts so that users can verify that the chart they install actually came from
    you and contains the expected contents. To sign a chart, you must first have a
    `gpg` keypair present on your local workstation.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you can leverage certain flags from the `helm package` command to sign
    your chart with a specified key.
  prefs: []
  type: TYPE_NORMAL
- en: Let's demonstrate how this can be accomplished by leveraging the `guestbook`
    chart from the Packt repository. This chart is located in the `Learn-Helm/helm-charts/charts/guestbook`
    folder. We will assume that you already have a gpg keypair on your local workstation,
    but if you do not, you can follow the instructions from the *Setup* section of
    the *Data provenance and integrity* section of this chapter to configure your
    keypair.
  prefs: []
  type: TYPE_NORMAL
- en: One important point to note before signing the `guestbook` chart is that you
    must export your public and secret keyrings to a legacy format if you are using
    GPG version `2` or greater. Previous versions of GPG stored keyrings in a `.gpg`
    file format, which is the format that Helm expects your keyring to be in (at the
    time of writing). Newer versions of GPG store keyrings in the `.kbx` file format,
    which is not currently supported.
  prefs: []
  type: TYPE_NORMAL
- en: 'Begin the signing process by converting your GPG public and secret keyrings
    into the `.gpg` file format:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Find your `gpg` version by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'If your `gpg` version is `2` or greater, export your public and secret keyring
    using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Once your keyrings have been exported, you will be able to sign and package
    your Helm charts. The `helm package` command provides three key (pun intended)
    flags that allow you to sign and package a chart:'
  prefs: []
  type: TYPE_NORMAL
- en: '`--sign`: Allows you to sign a chart using a PGP private key'
  prefs: []
  type: TYPE_NORMAL
- en: '`--key`: The name of the key to use when signing'
  prefs: []
  type: TYPE_NORMAL
- en: '`--keyring`: The location of the keyring containing the PGP private key'
  prefs: []
  type: TYPE_NORMAL
- en: In the next step, these flags will be used with the `helm package` command to
    sign and package the guestbook Helm chart.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following `helm package` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `$KEY_NAME` variable can refer to either the email, name, or fingerprint
    associated with the desired key. These details can be discovered by leveraging
    the `gpg --list-keys` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'When using the `helm package` command without signing, you would expect to
    see one file produced as output—the `tgz` archive containing the Helm chart. In
    this case, when signing and packaging the `guestbook` Helm chart, you will see
    that the following two files are created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `guestbook-1.0.0.tgz.prov` file is called a **provenance** file. The provenance
    file contains a provenance record, which displays the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The chart metadata from the `Chart.yaml` file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The sha256 hash of the Helm `guestbook-1.0.0.tgz` file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The PGP digital signature of the `guestbook-1.0.0.tgz` file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Users of a Helm chart will leverage the provenance file to verify the data provenance
    and integrity of the chart. When pushing a chart to a chart repository, developers
    should be sure to upload both the `.tgz` archive of the Helm chart and the `.tgz.prov`
    provenance file.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have packaged and signed your Helm chart, you will need to export the
    public key that corresponds to the private key used to encrypt your digital signature.
    This will allow users to download your public key and use it during the verification
    process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Export your public key to the `ascii-armor` format by using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: If you are releasing the `guestbook` chart publicly, this key can then be saved
    to a downloadable location by your chart users, such as Keybase. Users could then
    import this public key by leveraging the `gpg --import` command described in the
    *Verifying Helm releases* section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Chart users can leverage the `helm verify` command to verify a chart's data
    provenance and integrity before installation. This command is designed to be run
    against a locally downloaded `.tgz` chart archive and `.tgz.prov` provenance file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command provides an example of running this process against the
    `guestbook` Helm chart and assumes that your public key has been imported to a
    keyring called `~/.gnupg/pubring.gpg`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'If the verification is successful, no output will be displayed. Otherwise,
    an error message will be returned. The verification could fail for a variety of
    reasons, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The .tgz and .tgz.prov files are not in the same directory.
  prefs: []
  type: TYPE_NORMAL
- en: The .tgz.prov file is corrupt.
  prefs: []
  type: TYPE_NORMAL
- en: The file hashes do not match, indicating a loss of integrity.
  prefs: []
  type: TYPE_NORMAL
- en: The public key used to decrypt the signature does not match the private key
    used to originally encrypt it.
  prefs: []
  type: TYPE_NORMAL
- en: The `helm verify` command is designed to be run on locally downloaded charts,
    so users may find it better to instead leverage the `helm install --verify` command,
    which performs verification and installation in a single command, assuming that
    the `.tgz` and `.tgz.prov` files are both downloadable from a chart repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command describes how the `helm install --verify` command can
    be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: By using the methodologies described in this section for signing and verifying
    Helm charts, both you and your users can ensure that you are installing charts
    that both belong to you and have been unaltered.
  prefs: []
  type: TYPE_NORMAL
- en: With an understanding of how data provenance and integrity play a role in Helm,
    let's continue discussing the Helm security considerations by moving on to our
    next topic—security in relation to Helm charts and Helm chart development.
  prefs: []
  type: TYPE_NORMAL
- en: Developing secure Helm charts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While provenance and integrity play a major role in the security of Helm, they
    are not the only concerns you need to consider. Chart developers should ensure
    that, during the development process, they are adhering to best practices regarding
    security to prevent vulnerabilities from being introduced when a user installs
    the chart in a Kubernetes cluster. In this section, we will discuss many of the
    primary concerns around security as it relates to Helm chart development and what
    you, as a developer, can do to write Helm charts with security as a priority.
  prefs: []
  type: TYPE_NORMAL
- en: We will begin by first discussing the security around any container images that
    your Helm chart may use.
  prefs: []
  type: TYPE_NORMAL
- en: Using secure images
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since the goal of Helm (and Kubernetes) is to deploy container images, the image
    itself is a major security concern. To start, chart developers should be aware
    of the differences between image tags and image digests.
  prefs: []
  type: TYPE_NORMAL
- en: A tag is a human-readable reference to a given image and provides both developers
    and consumers with an easy method for determining the contents of an image. However,
    tags can present a security concern as there are no guarantees that the contents
    of a given tag will always remain the same. The image owner may choose to provide
    an updated image using the same tag, for example, to address security vulnerabilities,
    which would result in a different underlying image being executed at runtime,
    even though the tag is the same. Performing these modifications against the same
    tag introduces the possibility of regressions, which can cause unexpected adverse
    effects to users. Instead of referencing an image by tag, images can also be referenced
    by digest. An image digest is a computed SHA-256 value of an image that not only
    provides an immutable identifier to an exact image, but also allows for the container
    runtime to verify that the image retrieved from the remote image registry contains
    the expected contents. This removes the risk of deploying an image that contains
    an accidental regression against a given tag, and can also remove the risks of
    a man-in-the-middle attack, where the tag's contents are modified with malicious
    intent.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, instead of referencing an image as `quay.io/bitnami/redis:5.0.9`
    in a chart template, it can instead be referenced by digest as `quay.io/bitnami/redissha256:70b816f2127afb5d4af7ec9d6e8636b2f0f
    973a3cd8dda7032f9dcffa38ba11f`. Notice that instead of there being a tag after
    the name of the image, the SHA-256 digest is explicitly specified. This assures
    you that the image content will not change over time, even if the tag changes,
    thus strengthening your security posture.
  prefs: []
  type: TYPE_NORMAL
- en: Over time, you can expect a tag or a digest associated with an image to become
    unsafe to deploy as vulnerabilities are eventually likely to be published against
    packages or OS versions that this image may contain. There are many different
    ways to determine the vulnerabilities associated with a given image. One way is
    to leverage the native capabilities of the registry that the image belongs to.
    Many different image registries contain capabilities around image vulnerability
    scanning that can help provide insight as to when an image is vulnerable.
  prefs: []
  type: TYPE_NORMAL
- en: The Quay container registry, for example, can automatically scan images at specified
    intervals to determine the number of vulnerabilities an image contains. The Nexus
    and Artifactory container registries are also examples of container registries
    that have this capability. Outside of native scanning capabilities provided by
    container registries, other tools can be leveraged, such as Clair (which is also
    the backing scanning technology of **Quay**), Anchore, Vuls, and OpenSCAP. When
    your image registry or standalone scanning tool reports that an image is vulnerable,
    you should immediately update your chart's image to a newer version if available
    to prevent vulnerabilities from being introduced to your users' Kubernetes clusters.
  prefs: []
  type: TYPE_NORMAL
- en: To help simplify the process around updating the container image, you can develop
    a regular cadence where image updates are checked. This helps to prevent you from
    getting to a point where your target image contains vulnerabilities that make
    it unfit for deployment. Many teams and organizations also specify that images
    can only be sourced from trusted registries to reduce the potential of running
    images that do contain vulnerabilities. This setting is configured at the container
    runtime level and the location and specific configurations vary based on each
    runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from image vulnerability scanning and content sourcing, you should also
    avoid deploying images that require elevated permissions or capabilities. Capabilities
    are used to give a process a subset of root permissions. Some examples of capabilities
    are `NET_ADMIN`, which allows a process to perform network-related operations,
    and `SYS_TIME`, which allows a process to modify a system's clock. Running a container
    as root gives the container access to all the capabilities, which should be limited
    whenever possible. A list of capabilities can be found in the *CAPABILITIES(7)*
    pa[ge of the Linux manual pages (http://man7.org/linux/man-](http://man7.org/linux/man-pages/man7/capabilities.7.html)pages/man7/capabilities.7.html).
  prefs: []
  type: TYPE_NORMAL
- en: Granting a container capability or allowing it to run as root gives malicious
    processes more leverage to damage the underlying host. Not only does this impact
    the container that introduced the vulnerability, but also any other container
    running on that host and, potentially, the entire Kubernetes cluster. If a container
    does have vulnerabilities but does not have any capabilities granted to it, the
    attack vector is much smaller and could possibly be prevented altogether. When
    developing a Helm chart, both an image's vulnerabilities and permission requirements
    must be taken into account to keep your users, as well as other tenants of the
    Kubernetes cluster, safe.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the container image that is deployed, chart developers should
    also focus on the resources granted to an application. We will dive into this
    topic in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Setting resource limits
  prefs: []
  type: TYPE_NORMAL
- en: A pod uses the resources that belong to its underlying node. Without the proper
    defaults in place, it is possible for a pod to exhaust the `node of resources`,
    causing issues such as CPU throttling and pod eviction. Exhausting the underlying
    node will also prevent other workloads from being scheduled there. Because of
    the issues that can occur when resource limits are not in check, chart developers
    should be concerned about setting reasonable defaults either in their Helm chart
    or in the Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'Many charts allow the deployment `resources` field to be declared as a Helm
    value. A chart developer can default the `resources` field in the `values.yaml`
    file, setting what is believed by the developer to be the amount of resources
    that the application should need. The following code shows an example of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: If left at the default, this example value would be used to set the pod's CPU
    limit to `500m` and the memory limit to `2Gi`. Setting this default value in the
    `values.yaml` file prevents the pod from exhausting the node resources, while
    also providing a suggested value for the amount of application resources required.
    Users can then choose to override the resource limits if necessary. Note that
    the chart developers can also set a default for the resource requests, but this
    will not prevent the pod from exhausting the node resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'While you should consider setting default resource limits in the `values.yaml`
    file, you can also set limit ranges and resource quotas in the Kubernetes namespace
    that the chart will be installed on. These are resources that are typically not
    included in a Helm chart but are instead created by a cluster administrator before
    application deployment. Limit ranges are used to determine the number of resources
    a container is allowed to use within a namespace. Limit ranges are also used to
    set the default resource limits for each container deployed to the namespace that
    does not already have resource limits defined. The following is an example limit
    range defined by a `LimitRange` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '`LimitRange` enforces the specified restrictions in the namespace where the
    `LimitRange` object was created. It sets the maximum amount of allowed container
    resources to `1` core of `cpu` and `4Gi` of `memory`. If a resource limit is not
    defined, it automatically sets the resource limit to `500m` of `cpu` and `2Gi`
    of `memory`. Limit ranges can also be applied at the pod level by setting the
    `type` field to `Pod`. This would ensure that the sum of resource utilization
    of all containers in the pod are under the specified limits. In addition to setting
    limits against CPU and memory utilization, you can also set a `LimitRange` object
    to default the storage claimed by a `PersistentVolumeClaim` object by setting
    the `type` field to `PersistentVolumeClaim`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This would allow you to create the following resource to set a storage limit
    for a single PVC:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Of course, you could also set a default storage amount in your Helm chart's
    `values.yaml` file. The default set in the `values.yaml` file reflects the amount
    of storage you think is required for a default installation, with the `LimitRange`
    object enforcing an absolute maximum that the user can override to.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to limit ranges, you can also set resource quotas to add additional
    restrictions against a namespace''s resource usage. While limit ranges enforce
    resources at a per-container, -pod, or -PVC level, resource quotas enforce resource
    usage at a per-namespace level. They are used to define the maximum number of
    resources a namespace can utilize. The following is an example resource quota:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The preceding `ResourceQuota` object, when applied to a Kubernetes namespace,
    sets the maximum CPU utilization to `4` cores, the maximum memory utilization
    to `8Gi`, and the maximum storage request to `20Gi` for the sum of all workloads
    in the namespace. Resource quotas can also be used to set a maximum amount of
    `secrets`, `ConfigMaps`, and other Kubernetes resources per namespace. By using
    `resource quotas`, you can prevent a single namespace from over-utilizing cluster
    resources.
  prefs: []
  type: TYPE_NORMAL
- en: By setting reasonable default resource limits in your Helm chart, along with
    the existence of `LimitRange` and `ResourceQuota`, you can ensure that users of
    your Helm chart do not exhaust cluster resources and cause disruptions or outages.
    With an understanding of how you can enforce resource limits, let's move on to
    the next topic around Helm chart security—handling secrets in Helm charts.
  prefs: []
  type: TYPE_NORMAL
- en: Handling secrets in Helm charts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Handling secrets is a common concern when working with Helm charts. Consider
    the WordPress application from [*Chapter 3*](B15458_03_Final_JM_ePub.xhtml#_idTextAnchor147),
    *Installing Your First Helm Chart*, where you were required to provide a password
    to configure an admin user. This password was not provided by default in the `values.yaml`
    file because this would have left the application vulnerable if you forgot to
    override the `password` value. Chart developers should be in the habit of not
    providing defaults for secret values such as passwords and should instead require
    users to provide an explicit value. This can easily be done by leveraging the
    `required` function. Helm also has the ability to generate random strings using
    the `randAlphaNum` function.
  prefs: []
  type: TYPE_NORMAL
- en: Note, however, that this function generates a new random string each time the
    chart is upgraded. For that reason, developers should design charts with the expectation
    that users will provide their own password or other secret key, with the `required`
    function serving as a gate to ensure that a value is provided.
  prefs: []
  type: TYPE_NORMAL
- en: When a user provides a secret during chart installation, that value should be
    saved in `secret`, not `ConfigMap`. ConfigMaps display values in plain text and
    are not designed to contain credentials or other secret values. Secrets, on the
    other hand, provide obfuscation by Base64-encoding its contents. Secrets also
    allow you to mount its contents to a pod as a `tmpfs` mount, meaning the contents
    are mounted to the pod in volatile memory instead of on a disk. As a chart developer,
    you should ensure that all credentials and secret configuration managed by your
    Helm charts are created using Kubernetes Secrets.
  prefs: []
  type: TYPE_NORMAL
- en: While chart developers should ensure that secrets are handled appropriately
    using Kubernetes Secrets and the `required` function, chart users should ensure
    that secrets such as credentials are provided to a Helm chart securely. Values
    are most commonly provided to a Helm chart with the `--values` flag, where additional
    or overridden values are declared in a separate `values` file and are passed to
    the Helm CLI during installation. This is an appropriate method when working with
    regular values, but caution should be taken when using this approach with secret
    values. Users should be sure that the `values` files that contain secrets are
    not checked into a `git` repository or an otherwise public location where those
    secrets could be exposed. One way that users can avoid exposing secrets is by
    leveraging the `--set` flag to pass secrets inline from their local command line.
    This reduces the risk of credentials being exposed, but users should be aware
    that this would reveal the credentials in the bash history.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way that users can avoid exposing secrets is by leveraging an encryption
    tool to encrypt `values` files that contain secrets. This would continue to allow
    users to apply the `--values` flag and push the `values` file to a remote location,
    such as a git repository. The `values` file could then only be decrypted by users
    who have the appropriate key and would remain encrypted for all other users, only
    allowing trusted members access to the data. Users can simply leverage GPG to
    encrypt the `values` files, or they can levera[ge a special tool such as **Sops**.](https://github.com/mozilla/sops)
    **Sops** (https://github.com/mozilla/sops) is a tool designed to encrypt the values
    of YAML or JSON files but leave the keys unencrypted. The following code shows
    a secret key/value pair from a Sops-encrypted file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Notice how the `password` key is unencrypted but the value is encrypted. This
    allows you to easily see what kind of values are contained in the file without
    exposing their secrets.
  prefs: []
  type: TYPE_NORMAL
- en: There are other tools capable of encrypting the `values` files that contain
    se[crets. Some examples include `git-`](https://github.com/AGWA/git-crypt)`crypt`
    ([https://github.com/AGWA/git-crypt](https://github.com/AGWA/git-crypt)) and `blackbox`
    ([https://github.com/StackExchange/blackbox](https://github.com/StackExchange/blackbox)).
    Additionally, tools such as HashiCorp's `Vault` or CyberArk Conjur can be used
    to encrypt secrets in the form of key/value stores. Secrets can then be retrieved
    by authenticating with a secret management system and then by utilizing them within
    Helm by passing them with `--set`.
  prefs: []
  type: TYPE_NORMAL
- en: With an understanding of how security plays a role in Helm chart development,
    let's now discuss how **Role-Based Access Control** (**RBAC**) can be applied
    in Kubernetes to provide greater security to your users.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring RBAC rules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The ability of an authenticated user in Kubernetes to perform actions is governed
    through a set of RBAC policies. As introduced in *Chapter 2*, *Preparing a Kubernetes
    and Helm Environment*, policies, known as roles, can be associated with users
    or service accounts, and Kubernetes contains several default roles that can be
    associated. RBAC has been enabled by default in Kubernetes since version `1.6`.
    When thinking about Kubernetes RBAC in the context of Helm usage, you need to
    consider two factors:'
  prefs: []
  type: TYPE_NORMAL
- en: The user installing a Helm chart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The service account associated with the pod running the workload
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In most cases, the individual responsible for installing a Helm chart is associated
    with a Kubernetes user. However, Helm charts can be installed through other means,
    such as by a Kubernetes operator with an associated service account.
  prefs: []
  type: TYPE_NORMAL
- en: By default, users and service accounts have minimal permissions in a Kubernetes
    cluster. Additional permissions are granted through the use of roles that are
    scoped to an individual namespace, or cluster roles that grant access at a cluster
    level. These are then associated with a user or service account using either a
    role binding or a cluster role binding, depending on the type of policy being
    targeted. While Kubernetes has a number of included roles that can be applied,
    the concept of **least-privileged access** should be used wherever possible. Least-privileged
    access refers to a user or application that is granted only the minimum set of
    permissions that is needed to properly function. For example, take the `guestbook`
    chart that we developed earlier. Imagine we wanted to add new functionality that
    can query the metadata of pods in the `guestbook` application's namespace.
  prefs: []
  type: TYPE_NORMAL
- en: While Kubernetes contains a built-in role called **view** that provides the
    necessary permissions to read pod manifests in a given namespace, it also gives
    access to other resources, such as ConfigMaps and deployments. To minimize the
    level of access that is granted to an application, a custom policy in the form
    of a role or cluster role can be created that provides only the necessary permissions
    that the application needs. Since most typical users of a Kubernetes cluster do
    not have access to create resources at a cluster level, let's create a role that
    is applied to the namespace that the Helm chart is deployed in.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a new role, the `kubectl create role` command can be used. A basic
    role contains two key elements:'
  prefs: []
  type: TYPE_NORMAL
- en: The type of action (verb) made against the Kubernetes API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The list of Kubernetes resources to target
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As an example, to demonstrate how RBAC can be configured in Kubernetes, let's
    configure a set of RBAC rules to allow an authenticated user to view pods within
    a namespace.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: If you want to run through this example on your local workstation, make sure
    that Minikube is started first by running `minikube start`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can then create a new namespace called `chapter9` by running `kubectl create
    ns chapter9`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the `kubectl` CLI to create a new role called `guestbook-pod-viewer`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: With this new role created, it needs to be associated with a user or service
    account. Since we want to associate it with an application running in Kubernetes,
    we will apply the role to a service account. When a pod is created, it makes use
    of a service account called `default`. When attempting to abide by the least-privileged
    access principle, it is recommended that a separate service account is used. This
    is to ensure that no other workloads are deployed in the same namespace as the
    `guestbook` application as it would also inherit the same permissions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new service account called `guestbook` by executing the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create a role binding called `guestbook-pod-viewers` to associate `guestbook-pod-viewer`
    with `guestbook ServiceAccount`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Finally, to run the `guestbook` application itself using the newly created `guestbook`
    `ServiceAccount`, the name of the service account would need to be applied to
    the deployment.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following shows how the `serviceAccount` configuration appears in the deployment
    YAML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: You can easily install the `guestbook` application by using the chart you created
    in [*Chapter 5*](B15458_05_Final_JM_ePub.xhtml#_idTextAnchor265), *Building Your
    First Helm Chart*, or by using [the chart located in the Packt repository at https://github.com/PacktPublishing/-Learn](https://github.com/PacktPublishing/-Learn-Helm/tree/master/helm-charts/charts/guestbook)-Helm/tree/master/helm-charts/charts/guestbook.
    This chart exposes a set of values for configuring the deployment's service account.
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the `guestbook` Helm chart by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Notice that in *step 4*, the `serviceAccount.create` value is set to `false`.
    When you scaffolded your Helm chart in [*Chapter 5*](B15458_05_Final_JM_ePub.xhtml#_idTextAnchor265),
    *Building Your first Helm Chart,* using the `helm create` command, the ability
    to create a service account upon chart installation was provided. Since you already
    created a service account using `kubectl` previously, this was not needed. However,
    the ability to create additional resources related to RBAC during chart installation
    does not need to end at creating service accounts. In fact, you could perform
    steps 1, 2, and 3 in a single chart installation if your Helm chart contained
    the YAML resources necessary to create roles and role bindings as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, the `guestbook` application has the permissions necessary to
    list and get pods. To verify this assumption, `kubectl` has a command that queries
    whether a user or service account has the authority to perform an action. Execute
    the following command to verify that the `ServiceAccount` guestbook has access
    to query all the pods in the `guestbook` namespace:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The `--as` flag makes use of the user impersonation feature in Kubernetes to
    allow the debugging of authorization policies.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result of the command should print `yes` as output. To confirm that the
    service account cannot access a resource that it should not be able to, such as
    listing deployments, execute the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Feel free to delete your release with the `helm uninstall` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also stop your Minikube instance, which is not needed for the remainder
    of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the output of `no`, the expected policies are in place.
  prefs: []
  type: TYPE_NORMAL
- en: When used effectively, Kubernetes RBAC aids in providing Helm chart developers
    with the tools needed to enforce least-privilege access, protecting users and
    applications from potential errant or malicious actions.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will discuss how chart repositories can be secured and accessed in
    a way that enhances the overall security of Helm.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing secure chart repositories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Chart repositories provide the ability to discover Helm charts and install
    them on your Kubernetes cluster. Repositories were introduced in *"*[*Chapter
    1*](B15458_01_Final_JM_ePub.xhtml#_idTextAnchor017)*: Understanding Kubernetes
    and Helm" on page 305*, *Understanding Kubernetes and Helm*, as an HTTP server
    that includes an `index.yaml` file containing metadata related to charts present
    in the repository. In previous chapters, we made use of charts that were sourced
    from various upstream repositories and also implemented our own repository using
    GitHub Pages. Each of these repositories is freely available for use for whoever
    may be interested. However, Helm does support incorporating additional security
    measures to protect the content stored within the repository, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Secure Sockets Layer**/**Transport Layer Security** (**SSL**/**TLS**) encryption'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'While the majority of public Helm repositories do not require any form of authentication,
    Helm does allow users to perform basic and certificate-based authentication against
    a secured chart repository. For basic authentication, a username and password
    can be provided when adding a repository using the `helm repo add` command through
    the use of the `--username` and `--password` flags. For example, if you want to
    access a repository that is protected using basic authentication, adding the repository
    would take the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Then, the repository can be interacted with without needing to repeatedly provide
    the credentials.
  prefs: []
  type: TYPE_NORMAL
- en: For certificate-based authentication, the `helm repo add` command provides the
    `--ca-file`, `--cert-file`, and `--key-file` flags. The `--ca-file` flag is used
    to verify the chart repository's certificate authority, while the `--cert-file`
    and `--key-file` flags are used to specify your client certificate and key, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling basic authentication and certificate authentication on the chart repository
    itself depends on the repository implementation that is used. For example, ChartMuseum,
    the popular chart repository, provides the `--basic-auth-user` and `--basic-auth-pass`
    flags that can be used at startup to configure the username and password for basic
    authentication. It also provides the `--tls-ca-cert` flag to configure the **Certificate
    Authority** (**CA**) certificate for certificate authentication. Other chart repository
    implementations may provide other flags or require you to provide a configuration
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Even with authentication in place, it is important that the transmission between
    the HTTP server and your Helm client is facilitated securely. This can be performed
    using Secure Sockets Layer (SSL) / Transport Layer Security (TLS) based encryption
    to secure communication between your Helm client and your Helm chart repository.
    While a requirement for certificate authentication, repositories requiring basic
    authentication (and unauthenticated repositories) can still benefit from encrypting
    network traffic as this will protect authentication attempts as well as the contents
    of the repository. As with authentication, configuring TLS on the chart repository
    depends on the repository implementation that is used. ChartMuseum provides the
    `--tls-cert` and `--tls-key` flags to provide the certificate chain and key files.
    More general web servers, such as NGINX, typically require a configuration file
    that provides the location of the certificate and key files on the server. Offerings
    such as GitHub Pages already have TLS configured.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each of the Helm repositories that we have used so far have used certificates
    signed by publicly available CAs that are stored in both your web browser as well
    as your underlying operating system. Many large organizations have their own CAs
    that can be used to produce the certificates configured in the chart repository.
    Since this certificate is likely not from a publicly available CA, the Helm CLI
    may not trust the certificate, and adding the repository results in the following
    error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: To allow the Helm CLI to trust the chart repository's certificate, the CA certificate,
    or CA bundle containing multiple certificates, can either be added to the trust
    store of the operating system or explicitly specified using the `--ca-file` flag
    of the `helm repo add` command. This allows the command to be executed without
    error.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, depending on how the chart repository is configured, additional metrics
    can also be obtained to perform request-level auditing and logging to determine
    who has attempted to access the repository.
  prefs: []
  type: TYPE_NORMAL
- en: Through the use of authentication and managing certificates governing the transport
    layer, additional capabilities are realized for enhancing the security footprint
    of Helm repositories.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about some of the different topics around security
    that need to be considered when working with Helm. First, you learned how data
    provenance and the integrity of Helm releases and Helm charts can be proven. Next,
    you learned about Helm chart security and how a chart developer can employ best
    practices around security to write a stable and secure Helm chart. Finally, you
    learned how RBAC can be used to create an environment based on the concept of
    least privilege access and how chart repositories can be secured to provide HTTPS
    encryption and to require authentication. Now, with these concepts, you are better
    equipped to create a secure Helm architecture and working environment.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To learn more about data provenance [and integrity in the context of Helm c](https://helm.sh/docs/topics/provenance/)harts,
    go to [https://helm.sh/docs/topics/provenance/](https://helm.sh/docs/topics/provenance/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To learn more about Kubernetes RBAC, check out the *Using RBAC Auth*[*orization*
    page from the Kubernetes documentation at https://k](https://kubernetes.io/docs/reference/access-authn-authz/rbac/)ubernetes.io/docs/reference/access-authn-authz/rbac/.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check out the chart repository guide from the Helm docu[mentation to learn more
    about chart repositor](https://helm.sh/docs/topics/chart_repository/)ies at [https://helm.sh/docs/topics/chart_repository/](https://helm.sh/docs/topics/chart_repository/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is data provenance and integrity? How are data provenance and data integrity
    different?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Imagine you want to prove the data provenance and integrity of a Helm download.
    Besides the release archive, what file does a user need to download from Helm's
    GitHub release page to accomplish this?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What commands can a user run to verify the data provenance and integrity of
    a Helm chart?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As a Helm chart developer, what can you do to ensure that you are deploying
    a stable container image?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is it important to set resource limits on your Helm chart? What other Kubernetes
    resources can be used to configure a pod and namespace's resource limits?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the concept of least privilege access? Which Kubernetes resources allow
    you to configure authorization and help achieve least privilege access?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What command and set of flags can be used to authenticate against a chart repository?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
