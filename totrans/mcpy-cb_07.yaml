- en: Fruity Tunes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will learn how to create a musical instrument with Circuit
    Playground Express and some bananas. We will connect four bananas to the touchpads
    on the board so that you can play a certain musical sound for each banana you
    touch. We'll add some visual feedback to the project by lighting up a pixel next
    to each touchpad each time you make contact with it. This project will show a
    creative, fun way to bring your capacitive touch projects to life.
  prefs: []
  type: TYPE_NORMAL
- en: By using unexpected objects such as bananas in your projects, you can add a
    unique twist to your mundane MicroPython projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will be covering the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a class to react to touch events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a function to enable speaker output
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a function to play audio files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the NeoPixel object to control pixels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a touch handler to play sounds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a touch handler to light up pixels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an event loop to handle all touch events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code files for this chapter can be found in the `Chapter07` folder in the
    GitHub repository, at [https://github.com/PacktPublishing/MicroPython-Cookbook](https://github.com/PacktPublishing/MicroPython-Cookbook).
  prefs: []
  type: TYPE_NORMAL
- en: Many of the recipes in this chapter require four audio files to be transferred
    to the Circuit Playground Express board. They can all be downloaded from the `Chapter07`
    folder in the GitHub repository. They should be saved in the top-level folder
    with your `main.py` file.
  prefs: []
  type: TYPE_NORMAL
- en: Circuit Playground Express touchpads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Circuit Playground Express comes with seven capacitive touchpads. Each of them
    can be connected to any object that can conduct electricity, and touching that
    object will, in turn, trigger the sensor. You can use good electrical conductors,
    such as metal, and even weaker ones, such as a banana.
  prefs: []
  type: TYPE_NORMAL
- en: 'Water conducts electricity, and the surfaces of many fruits have enough moisture
    for the touchpads to detect a touch event. Many fruits, such as bananas, limes,
    oranges, and apples, will do the job. You can use alligator clips to connect the
    fruit to the touchpads. The following photograph shows a bundle of alligator clips:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/a34c1b12-42b9-465a-8d1d-00e82740e562.png)'
  prefs: []
  type: TYPE_IMG
- en: 'These alligator clips come in a variety of different colors. It''s a good idea
    to use a different color wire for each touchpad. It will make it easier to trace
    which fruit is connected to which touchpad. In this project, we will use green,
    red, yellow, and white wires. We''ll set the color of the pixels next to each
    pad to also be green, red, yellow, and white. The next photograph shows a single
    banana connected to one of the touchpads:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/3b3aa8f7-7cf8-4e04-b03e-4fabb1cb7126.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The alligator clips work very well, as they don''t require any soldering and
    can easily connect to both the board and a variety of objects. The teeth on the
    alligator clips will also create a good grip, so that a good electrical connection
    can be established between the board and the banana. The following photograph
    gives a closer view of the alligator teeth that are attached to the banana:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/155c7ec9-f0c3-49ef-bd49-97fc9e918997.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The next photograph shows a closer view of the alligator teeth that are attached
    to the touchpad:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/52b29bc0-114d-40e6-8884-e58bc97b6eef.png)'
  prefs: []
  type: TYPE_IMG
- en: In previous chapters, we used the Circuit Playground Express library to interact
    with the different components on the board. When you play audio files with this
    library, the library will block your code until the playback of the file is complete.
    In this project, we want the ability to respond to touch events immediately, and
    to play new sounds without waiting for the current audio file to finish playback.
  prefs: []
  type: TYPE_NORMAL
- en: This level of control can only be achieved if we use the CircuitPython libraries
    that control audio playback and the touchpads directly. For this reason, none
    of the code in this chapter will use the Circuit Playground Express library. By
    taking this approach, we will also get see how to get more fine-tuned control
    of the components on the board.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a class to react to touch events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to define a class that can help you use handle
    touch events on a particular touchpad. When you create an instance of this class,
    you specify the pad name and a callback function that will be called each time
    a touch event starts and ends. We can use this class as a building block to have
    a callback called for each of the four touchpads that will be connected to bananas.
    You can use this style of code in your own projects, whenever you want to handle
    a variety of events with a set of callback functions.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need access to the REPL on Circuit Playground Express to run the code
    presented in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s go over the steps required for this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following lines of code in the REPL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: At this stage, we have defined a function that will handle touch events by printing
    the name of the touchpad and whether the pad is being touched.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the next block of code to create a class that will check for touch events.
    After defining the class, it will create one instance and then print out the current
    touch state of the pad:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Hold down your finger on touchpad A1 while running the next block of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the next block of code to create a class with a method to process touch
    events:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Hold down your finger on touchpad A1 while running the next block of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code should be put into the `main.py` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: When executed, this script will repeatedly print a message whenever a touch
    event starts or ends on touchpad A1.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `TouchEvent` class is defined to help us keep track of the last known state
    of the touchpad and to respond to a change in its state by making a call to the
    specified callback function. A default touch threshold of `400` is defined so
    that subclasses of this class can override the value. The constructor expects
    the first argument to be the name of the touchpad to monitor and the callback
    function that will be called when a state change is detected.
  prefs: []
  type: TYPE_NORMAL
- en: The name and callback function are saved with attributes on the instance. The
    last known state is initialized to the `False` value. Then, the pin value for
    the named touchpad is retrieved from the `board` Python module. This pin is used
    to create a `TouchIn` instance, which is also saved as an attribute on the object.
    Finally, the threshold is set on this touchpad as part of the initialization process.
  prefs: []
  type: TYPE_NORMAL
- en: The other method that is defined on the class will be called regularly, to check
    for any changes in the touchpad state and to process this state change by calling
    the defined callback function. This is done by getting the current touch state
    and comparing it to the last known value. If they differ, the callback is called
    and the value is saved for future reference.
  prefs: []
  type: TYPE_NORMAL
- en: A simple function is defined to handle any touch events by simply printing out
    the name of the touchpad that had a state change and what the current state is.
  prefs: []
  type: TYPE_NORMAL
- en: After these class and function definitions, we create one instance of this class
    that will watch touchpad A1\. We then enter into an infinite loop that repeatedly
    checks for state changes and prints out a message each time one occurs.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's always a good idea to set a touch threshold on your touchpads. If you don't,
    you will get a lot of false positives when interacting with the touchpad. The
    value that has been chosen, `400`, is a value that is suitable to this specific
    setup of connecting bananas with alligator clips. It's best to connect the actual
    objects intended for use with your project, and then fine-tune this value to a
    suitable value.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we have mixed the uses of functions and classes. This approach
    is perfectly fine in Python, and it lets you have the best of both worlds. We
    needed to keep track of the state between each call to the process method, which
    is why we chose a class for that purpose. The callback doesn't need to keep track
    of any states between calls, so a simple function does the job just fine.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are a few references:'
  prefs: []
  type: TYPE_NORMAL
- en: Documentation on the `TouchIn` class can be found at [https://circuitpython.readthedocs.io/en/3.x/shared-bindings/touchio/TouchIn.html](https://circuitpython.readthedocs.io/en/3.x/shared-bindings/touchio/TouchIn.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documentation on the `board` Python module can be found at [https://circuitpython.readthedocs.io/en/3.x/shared-bindings/board/__init__.html#module-board](https://circuitpython.readthedocs.io/en/3.x/shared-bindings/board/__init__.html#module-board).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a function to enable speaker output
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to create a function that, when called, will
    enable the speaker. If you don't enable the speaker before audio playback, then
    it will be played through pin A0, which can have a headphone connected to it.
  prefs: []
  type: TYPE_NORMAL
- en: This project will use the speaker on the board instead of headphones, so we
    will need this function to enable the speaker at the start of our script. Beyond
    showing you how to enable the speaker, this recipe will also introduce you to
    ways of digitally controlling input/output pins.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need access to the REPL on Circuit Playground Express to run the code
    presented in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s go over the steps required for this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the next block of code in the REPL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'At this stage, we have created an object that is connected to the pin, which
    will enable the speaker. Run the next block of code to enable the speaker:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Reload the board and enter the REPL again. The next block of code will define
    the function to enable the speaker, and will call it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `enable_speakers` function is defined first. It doesn't receive any arguments,
    as there is only one speaker on the board to enable, and it returns nothing, as
    once the speaker is enabled, its pin doesn't need to be interacted with again.
    The `DigitalInOut` object is used to interact with the pin that will enable the
    speaker. Once this object is created, the `switch_to_output` method is called
    to enable speaker output. After the function is defined, it is called to enable
    the speakers.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `DigitalInOut` object that is used in this recipe can be used to interact
    with a wide range of pins. On this board, for example, it can be used to connect
    the pins that read input from push button A and push button B. Once you connect
    and configure these push button pins correctly, you can start polling the pin’s
    value to check whether the push button is pressed.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are a few references:'
  prefs: []
  type: TYPE_NORMAL
- en: Example usage of the `DigitalInOut` object can be found at [https://learn.adafruit.com/adafruit-circuit-playground-express/circuitpython-digital-in-out](https://learn.adafruit.com/adafruit-circuit-playground-express/circuitpython-digital-in-out).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documentation on the `DigitalInOut` object can be found at [https://circuitpython.readthedocs.io/en/3.x/shared-bindings/digitalio/DigitalInOut.html](https://circuitpython.readthedocs.io/en/3.x/shared-bindings/digitalio/DigitalInOut.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a function to play audio files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to create a function that, when called, will
    play a specific audio file on the built-in speakers. This recipe will illustrate
    how to get access to the audio output device, as well as how to read the contents
    of a `.wav` file, convert it to an audio stream, and feed that audio stream to
    the onboard audio playback device. The techniques shown in this recipe can be
    used in all sorts of projects that need more fine control over the way audio files
    are played back.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need access to the REPL on Circuit Playground Express to run the code
    presented in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s go over the steps required for this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the REPL to run the following lines of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'At this stage, we have enabled the speaker and have created an object to feed
    audio data to the speakers. When you run the next block of code, you should hear
    a piano note play on the speakers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the next block of code to hear the same piano note again, but this time,
    played back through a function call:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code should be put into the `main.py` file and, when executed,
    it will play a single piano note each time the board is reloaded:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, the speakers are enabled so that we can hear the audio playback without
    headphones. The `AudioOut` class is then used to access the audio output device.
    The `play_file` function is then called with the speaker audio object and the
    path to the audio file that will be played. This function opens the file in binary
    mode.
  prefs: []
  type: TYPE_NORMAL
- en: This file object is then used to create a `WaveFile` object, which will return
    us the data as an audio stream. This audio data is then given to the `play` method
    on the `AudioOut` object to start playback. This method immediately returns, and
    doesn't wait for playback to complete. This is why the `sleep` method is called
    afterward, to give the board a chance to play the audio stream before the main
    script ends execution.
  prefs: []
  type: TYPE_NORMAL
- en: If you exclude this line of code from the file and reload the code, then the
    script will exit before the board has a chance to play the file, and you won’t
    hear any audio being played back.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using this function, you can play any number of audio files by just passing
    the audio output object and the file path. You can also use this recipe as a starting
    point to experiment further with the audio playback library that comes with this
    board. For example, there's a method to poll and check whether the last provided
    stream is still playing, or if it has finished playback.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are a few references:'
  prefs: []
  type: TYPE_NORMAL
- en: Documentation on the `AudioOut` object can be found at [https://circuitpython.readthedocs.io/en/3.x/shared-bindings/audioio/AudioOut.html](https://circuitpython.readthedocs.io/en/3.x/shared-bindings/audioio/AudioOut.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documentation on the `WaveFile` object can be found at [https://circuitpython.readthedocs.io/en/3.x/shared-bindings/audioio/WaveFile.html](https://circuitpython.readthedocs.io/en/3.x/shared-bindings/audioio/WaveFile.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the NeoPixel object to control pixels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to control the pixels on the board using
    the NeoPixel object. We covered a lot of the methods in this object in previous
    chapters, but this is the first time we will directly create a NeoPixel object.
    It’s useful to have the skills to directly use the NeoPixel object, instead of
    accessing it through another object. You will need these skills if you decide
    to add an additional ring or strip of pixels to your project. In those cases,
    you will need direct access to this object to control the pixels.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need access to the REPL on Circuit Playground Express to run the code
    presented in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s go over the steps required for this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following lines of code in the REPL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'After running the previous block of code, the first pixel should become the
    color red. Run the next block of code to make the second pixel green:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the next block of code to turn off the first pixel:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code should be put into the `main.py` file and, when executed,
    it will color the first two pixels red and green:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `NeoPixel` class is used to access the array of pixels on the board. When
    we create this object, we have to specify the pin on the board to connect to and
    the number of pixels connected to that pin.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of Circuit Playground Express, there are 10 pixels on the board.
    We keep this value in a global constant to improve code readability. We then set
    the brightness of the pixels to 5%.
  prefs: []
  type: TYPE_NORMAL
- en: The names and hex codes for the five different colors we need in the project
    are defined in a global dictionary. The colors white, green, red, and yellow,
    each relate to the four colors of the attached wires. The color black is used
    to switch off a pixel. We then set the first and second pixels to the colors red
    and green. Finally, we run an infinite loop, so that we can see these colors and
    stop the script from exiting.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This code has everything required to interact with any of the 10 pixels that
    come with the board. You can take this base code and start experimenting with
    the different methods available on the provided object. Using these different
    methods, you can change the color of all the pixels in one call. You can also
    turn off the default auto-write feature, and then have direct control over when
    the changes you make to colors get applied. This low-level control of the pixels
    is all available through this library.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are a few references:'
  prefs: []
  type: TYPE_NORMAL
- en: Documentation on ways of testing the pixel features can be found at [https://circuitpython.readthedocs.io/projects/neopixel/en/latest/examples.html](https://circuitpython.readthedocs.io/projects/neopixel/en/latest/examples.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An overview of the NeoPixel driver can be found at [https://circuitpython.readthedocs.io/projects/neopixel/en/latest/](https://circuitpython.readthedocs.io/projects/neopixel/en/latest/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a touch handler to play sounds
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will create the first version of our touch handler. This
    first version will play a specific audio file each time a touch event is detected.
    We can then use this handler in later recipes, in order to map each touchpad to
    a specific audio file. We will also expand the functionality of this handler in
    future recipes to add light, as well as sound, to the touch event. Event handlers
    are a common part of many software systems. This recipe will help you see how
    you can use this common approach with your MicroPython projects.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need access to the REPL on Circuit Playground Express to run the code
    presented in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s go over the steps required for this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the next block of code in the REPL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, we have enabled the speakers and have set up an object to play
    audio files on the speaker. In the next block of code, we will define a `Handler`
    class and then create an instance of it that will use our `speaker` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run the next block of code, you should hear a piano sound on the speaker:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code should be put into the `main.py` file and, when executed,
    it will play a piano sound each time the touchpad A1 is touched:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Handler` class that is defined will be used to react to touch events. It
    expects one argument in the constructor, which is the `speaker` object that will
    handle audio playback. This object is saved to an attribute on the object instance.
    This class then defines a method that will be called each time a touch event has
    occurred. The method expects the first argument to be the name of the touchpad,
    and the second argument is a Boolean value that indicates the state of the touchpad.
  prefs: []
  type: TYPE_NORMAL
- en: When the method is called, it checks whether the pad is being touched; if so,
    it calls the `play_file` function to play the piano sound. The remainder of the
    code in the recipe supports the process of continually checking for new touch
    events and calls the defined handler.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The recipe in this example only plays one sound as a single touchpad is pressed.
    However, it also creates the core structure for us to expand. You can experiment
    with this recipe and try two touchpads, each playing a different sound. You could
    do this by having multiple defined event objects connected to different handlers.
    In later recipes, you will see that a single event class definition and a single
    handler class definition can be used to connect to four different pads and play
    four different sounds.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are a few references:'
  prefs: []
  type: TYPE_NORMAL
- en: The source code for the `AudioOut` class can be found at [https://github.com/adafruit/circuitpython/blob/3.x/shared-bindings/audioio/AudioOut.c](https://github.com/adafruit/circuitpython/blob/3.x/shared-bindings/audioio/AudioOut.c).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The source code for the `WaveFile` class can be found at [https://github.com/adafruit/circuitpython/blob/3.x/shared-bindings/audioio/WaveFile.c](https://github.com/adafruit/circuitpython/blob/3.x/shared-bindings/audioio/WaveFile.c).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a touch handler to light up pixels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will create a touch handler that will react to touch events
    by playing sounds and lighting up pixels. When the touch sensor gets triggered,
    the handler will play a sound and light up a specific pixel. When the touch sensor
    detects that you have released your finger, the specific pixel that was lit up
    will turn off.
  prefs: []
  type: TYPE_NORMAL
- en: In this way, you can hear and see the board react to each of the configured
    touchpads uniquely. This recipe shows a useful way to create different types of
    output, based on different triggered input. Many projects can come to life when
    you add a mix of unique audio and visual output that will react to different types
    of human input.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need access to the REPL on Circuit Playground Express to run the code
    presented in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s go over the steps required for this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the REPL to run the following lines of code. This will set up the speakers
    and create an object to interact with the pixels:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In the next block of code, we will define a `Handler` class and then create
    an instance of it to which we will pass the objects to deal with the speaker and
    pixels:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run the next block of code, you should hear a piano sound on the speaker,
    and the first pixel should turn red:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the next block of code, and you should see the first pixel light switch
    off:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code should be put into the `main.py` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: When the script is executed, it will play a piano sound and light up a pixel
    each time touchpad A1 is touched.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Handler` class that is defined will play sounds and light up pixels each
    time a touch event is detected. The constructor of this class takes the speaker
    and pixel objects and saves them to the instance for later use. Each time the
    `handle` method is called, it checks whether the touchpad is currently pressed.
  prefs: []
  type: TYPE_NORMAL
- en: If it is pressed, a pixel is lit up and a sound is played. If the pad is released,
    that same pixel is turned off. The remainder of the script is in charge of initializing
    the speaker and pixels so that they can be used by the handler, and for creating
    an infinite loop that will keep calling the handler each time an event is detected.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The script in this recipe lights up a specific pixel each time. You can extend
    it to use a random color each time the touchpad is pressed. There are ways to
    light up more pixels the longer a touchpad is pressed. Another fun experiment
    to try would be to have the board play a random sound each time an event occurred.
    Now that we have added sound and light, there are more options to apply creativity
    to this project and to create a more unique project.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are a few references:'
  prefs: []
  type: TYPE_NORMAL
- en: A project that connects limes to Circuit Playground Express can be found at
    [https://learn.adafruit.com/circuit-playground-express-piano-in-the-key-of-lime/](https://learn.adafruit.com/circuit-playground-express-piano-in-the-key-of-lime/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The source code for the `TouchIn` class can be found at [https://github.com/adafruit/circuitpython/blob/3.x/shared-bindings/touchio/TouchIn.c](https://github.com/adafruit/circuitpython/blob/3.x/shared-bindings/touchio/TouchIn.c).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an event loop to handle all touch events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This final recipe in this chapter takes all the previous recipes in this chapter
    and combines them to complete the banana power musical machine. Beyond the previous
    recipes, we will need to create an event loop that combines all this logic into
    one structure that can handle all the four touchpads and their related audio files
    and pixels. After going through this recipe, you will be able to create generic
    event loops and handlers that can be extended to meet the varying needs of the
    embedded projects you might create.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need access to the REPL on Circuit Playground Express to run the code
    presented in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s go over the steps required for this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following lines of code in the REPL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We have now imported all the libraries we need and have created the main data
    structures that we need in our script. Run the next block of code, and the speakers
    should play a piano sound:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the next block of code to create an instance of our event handler:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the next block of code to simulate a touch event on pad 2\. You should
    hear a piano sound and see one of the pixels turn red:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code should be put into the `main.py` file and, when executed,
    it will play different sounds and light up different pixels each time one of the
    four configured touchpads is pressed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `main` function contains our event loop. This function first initializes
    the speakers and pixels. Then, it creates a single handler instance. This single
    handler instance is generic enough that it will be used as the handler for all
    four of the touchpads.
  prefs: []
  type: TYPE_NORMAL
- en: Then, a list of events is created, where each one is connected to one of the
    four pads. An infinite loop is started that loops through each event object and
    calls its `process` method to call the event handler whenever a change in the
    touchpad state is detected.
  prefs: []
  type: TYPE_NORMAL
- en: The constants at the top of the script are used to specify the names of the
    touchpads to use, which sound files to play for each pad, and the pixel position
    and color to set when a pad is pressed.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This script makes heavy use of a number of data structures, so that values don't
    need to be hardcoded in the function and class definitions. Dictionaries are used
    as a natural structure to map each pad name to the audio filename that should
    be played. A list of data structures is used to define the names of the touchpads
    that will be connected. Finally, a dictionary of tuples is used to map the touchpad
    to its related pixel position and color. Python has a rich set of data structures
    that, when leveraged effectively, can make code much more readable and maintainable.
  prefs: []
  type: TYPE_NORMAL
- en: 'This project connects four bananas to the board, with each banana playing a
    different sound when touched. Because the code was constructed to respond to each
    touch immediately, you can even have two people play at the same time. The next
    photograph shows two people, each with a pair of bananas, creating music and controlling
    the pixels on the board:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/1f1a81c1-81e3-46f5-9b39-db853ae75ba1.png)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are a few references:'
  prefs: []
  type: TYPE_NORMAL
- en: Documentation on providing audio output with CircuitPython can be found at [https://learn.adafruit.com/adafruit-circuit-playground-express/circuitpython-audio-out](https://learn.adafruit.com/adafruit-circuit-playground-express/circuitpython-audio-out).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The source code for the `NeoPixel` class can be found at [https://github.com/adafruit/Adafruit_CircuitPython_NeoPixel](https://github.com/adafruit/Adafruit_CircuitPython_NeoPixel).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
