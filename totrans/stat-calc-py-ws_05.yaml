- en: 5\. More Mathematics with Python
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5. 用Python进行更多数学
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: By the end of this chapter, you will be able to grasp the basic concepts of
    sequences and series and write Python functions that implement these concepts.
    You will understand the relationships between basic trigonometric functions and
    their applications, such as the famous Pythagorean theorem. You will practice
    vector calculus and know where it is applicable by performing vector algebra in
    Python. Finally, you will feel happy knowing that complex numbers are not any
    less a type of number; they are intimately connected to trigonometry and are useful
    for real-world applications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，你将能够掌握序列和级数的基本概念，并编写实现这些概念的Python函数。你将了解基本三角函数及其应用之间的关系，比如著名的毕达哥拉斯定理。你将练习向量微积分，并通过在Python中进行向量代数来了解它的适用性。最后，你会感到高兴，因为复数并不比其他类型的数字差；它们与三角学密切相关，并且对现实世界的应用很有用。
- en: Introduction
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In the previous chapter, we covered functions and algebra with Python, starting
    with basic functions before working through transformations and solving equations.
    In this chapter, we'll introduce sequences and series, which have many applications
    in the real world, such as finance, and also form the basis for an understanding
    of calculus. Additionally, we will explore trigonometry, vectors, and complex
    numbers to give us a better understanding of the mathematical world.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们用Python介绍了函数和代数，从基本函数开始，然后进行变换和解方程。在本章中，我们将介绍序列和级数，在现实世界中有许多应用，比如金融，也是理解微积分的基础。此外，我们还将探讨三角学、向量和复数，以便更好地理解数学世界。
- en: The core skills of any exceptional Python programmer include a solid understanding
    of the background mathematics and an effective application of them. Think of vectors
    and complex numbers as valuable extensions to our *mathematical toolbox* that,
    later on, will contribute to efficiently describing, quantifying, and tackling
    real-world problems from the finance, science, or business and social domains.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 任何出色的Python程序员的核心技能包括对背景数学的深刻理解以及有效地应用它们。把向量和复数看作是我们*数学工具箱*的有价值扩展，它们将有助于有效地描述、量化和解决来自金融、科学、商业和社会领域的现实问题。
- en: Sequences and series, among others, appear in situations where profits, losses,
    dividends, or other payments occur on a regular basis. Trigonometry and trigonometric
    functions are necessary to solve geospatial problems, while vectors are applied
    widely in physics and engineering, machine learning, and more, where several different
    values are grouped together and the notion of direction is pivotal. Complex numbers
    are some of the most fundamental concepts that enjoy wide applications in electromagnetism,
    optics, quantum mechanics, and computer science.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 序列和级数等在利润、损失、股利或其他支付定期发生的情况中出现。三角学和三角函数对解决地理空间问题至关重要，而向量在物理学和工程学、机器学习等领域得到广泛应用，其中多个不同的值被分组在一起，方向的概念至关重要。复数是一些最基本的概念，在电磁学、光学、量子力学和计算机科学等领域有广泛的应用。
- en: Sequences and Series
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 序列和级数
- en: 'If you were to participate in a TV show where the $10,000 question was *"Given
    the numbers 2, 4, 8, 16, and 32, what comes next in the sequence?"*, what would
    your best guess be? If your response is 64, then congratulations—you just came
    closer to understanding one of the key concepts in mathematical abstraction: that
    of a sequence. A **sequence** is, pretty much like in the ordinary sense of the
    word, a particular order in which things follow each other. Here, *things* are
    (in most cases) integers or real numbers that are related. The order of the elements
    matters. The elements are also called the members or terms of the sequence.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你参加一个电视节目，其中1万美元的问题是“给定数字2、4、8、16和32，序列中接下来是什么？”，你最好的猜测是什么？如果你的回答是64，那么恭喜你——你刚刚更接近理解数学抽象中的一个关键概念：序列。**序列**就像普通意义上的顺序一样，是一种事物相互跟随的特定顺序。在这里，*事物*（在大多数情况下）是相关的整数或实数。元素的顺序很重要。元素也被称为序列的成员或术语。
- en: For example, in the preceding sequence of the TV show you participated in, every
    term stems from the number prior being multiplied by 2; there is no end in this
    sequence as there is no end in the number of terms (integer numbers) you can come
    up with. In other instances, elements in a sequence can appear more than once.
    Think of the number of days in the months of a year, or just the sequence of the
    outcomes of a random event, say, the toss of a coin. A well-known sequence that
    has been known since the ancient Indian times is the Fibonacci sequence—1, 1,
    2, 3, 5, 8, 13…. This is the sequence where each *new* term is the sum of the
    two previous terms.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在你参与的电视节目的前述序列中，每个术语都是前一个数字乘以2得到的；这个序列没有结束，因为可以无限产生整数数字。在其他情况下，序列中的元素可以出现多次。想想一年中每个月的天数，或者随机事件的结果序列，比如抛硬币的结果。自古印度以来就已知的一个著名序列是斐波那契数列——1、1、2、3、5、8、13……这个序列中，每个*新*术语都是前两个术语的和。
- en: That is, we need to know at least two terms before we can derive any other.
    In other words, we need to read the two first numbers (in the preceding sequence,
    1 and 1, but generally any two numbers) before we are capable of deriving and
    predicting the third number. We know that some sequences, such as the Fibonacci
    sequence, include some logic inside them; a basic rule that we can follow and
    derive any term of the sequence.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，我们需要知道至少两个术语才能推导出其他任何术语。换句话说，我们需要读取前两个数字（在前述序列中是1和1，但通常是任意两个数字）才能推导和预测第三个数字。我们知道一些序列，比如斐波那契数列，其中包含一些内在的逻辑；我们可以遵循一个基本规则，并推导出序列的任何术语。
- en: 'In this chapter, we will be focusing on basic sequences, also known as **progressions**,
    that are repeatedly found across many fields in applied mathematics and programming
    that fall in either of the three basic categories: arithmetic, geometric, and
    recursive. These are not the only possibilities; they are, nonetheless, the most
    popular families of sequences and illustrate the logic that they entail.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将重点关注基本序列，也称为**级数**，这些序列在应用数学和编程的许多领域中反复出现，属于三种基本类别之一：等差、等比和递归。这些不是唯一的可能性；然而，它们是最受欢迎的序列家族，并且说明了它们所蕴含的逻辑。
- en: A **sequence** of numbers {αn} = {α1, α2, α3, ..., αΝ, ...} is an ordered collection
    of terms (elements or members) for which there is a rule that associates each
    natural number n = 1, 2, 3, ..., N with just one of the terms in the sequence.
    The length of the sequence (that is, the number of its terms) can be finite or
    infinite, and the sequence is hence called finite or infinite, accordingly.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一系列数字{αn} = {α1, α2, α3, ..., αΝ, ...}是一个有序的术语（元素或成员）的集合，对于这个集合有一个规则，将每个自然数n
    = 1, 2, 3, ..., N与序列中的一个术语关联起来。序列的长度（即其术语的数量）可以是有限的或无限的，因此相应地称为有限或无限序列。
- en: 'A **series** is a mathematical sequence that is summed as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 一个**级数**是一个按照以下方式求和的数学序列：
- en: '![Figure 5.1: Equation of series'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 5.1: 级数方程'
- en: '](image/B15968_05_01.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_05_01.jpg)'
- en: 'Figure 5.1: Equation of series'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1：级数方程
- en: 'This can also be summed using the summation sign, as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这也可以使用求和符号进行求和，如下所示：
- en: '![Figure 5.2: Equation of an infinite series'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.2：无限级数的方程'
- en: '](image/B15968_05_02.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_05_02.jpg)'
- en: 'Figure 5.2: Equation of an infinite series'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2：无限级数的方程
- en: In the preceding case, our series is infinite (that is, it is the sum of all
    the terms of an infinite sequence). However, a series, such as a sequence, can
    also be finite. Why would a sum have infinite terms? Because it turns out that,
    in many cases, the summation is carried out computationally more efficiently by
    applying known formulas. Moreover, the summation can converge to a number (not
    infinite) or some function, even when the sequence is infinite. Due to this, series
    can be considered the *building blocks* of known functions, and their terms can
    be used to represent functions of increasing complexity, thus making the study
    of their properties intuitive. Series and sequences are ubiquitous in mathematics,
    physics, engineering, finance, and beyond and have been known since ancient times.
    They appear and are particularly useful as infinite sums in the definition of
    derivates and other functions as well.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的情况下，我们的级数是无限的（即，它是无限序列的所有项的和）。然而，一个级数，就像一个序列一样，也可以是有限的。为什么一个总和会有无限个项？因为事实证明，在许多情况下，通过应用已知的公式进行计算更有效。此外，即使序列是无限的，求和也可以收敛到一个数字（不是无穷大）或某个函数。由于这个原因，级数可以被认为是已知函数的*构建块*，它们的术语可以用来表示越来越复杂的函数，从而使得对它们的性质的研究变得直观。级数和序列在数学、物理、工程、金融等领域中无处不在，并且自古以来就为人所知。它们出现并且作为无限和的定义在导数和其他函数中特别有用。
- en: Arithmetic Sequences
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 等差数列
- en: 'Like most mathematical concepts, sequences can be found everywhere in our daily
    lives. You might not have thought about it before, but every time you ride a cab,
    a sequence is *running* in the background to calculate the total cost of your
    ride. There is an initial charge that increments, by a fixed amount, for every
    kilometer (or mile) you ride. So, at any given moment, there''s a real, corresponding
    number (the price of the ride so far). The ordered set of all these subtotals
    forms a sequence. Similarly, your body height as you grow up is a sequence of
    real numbers (your height expressed in centimeters or inches) in time (days or
    months). Both these examples constitute sequences that are non-decreasing in time—in
    other words, every term is either larger than or equal to any previous term, but
    never smaller. However, there is a subtle difference between the two examples:
    while the rate at which we gain height as we grow differs (growth is fast for
    kids, slow for teenagers, and zero for adults), the rate at which the taxi fare
    increases is constant. This leads us to need to introduce a special class of sequences—arithmetic
    sequences—which are defined as follows.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 像大多数数学概念一样，序列无处不在我们的日常生活中。你可能以前没有想过，但每次你乘坐出租车时，后台都会运行一个序列来计算你的乘车总费用。有一个初始费用，每公里（或英里）增加一个固定金额。因此，在任何给定时刻，都有一个实际的对应数字（到目前为止的乘车费用）。所有这些小计的有序集合形成一个序列。同样，随着你的成长，你的身高是一个随时间（天或月）变化的实数序列（以厘米或英寸表示的身高）。这两个例子都构成了随时间非递减的序列——换句话说，每个术语要么大于等于任何先前的术语，但从不小于。然而，这两个例子之间存在微妙的差异：随着我们的成长，我们增加身高的速度不同（儿童增长速度快，青少年增长速度慢，成年人增长速度为零），而出租车费用增加的速度是恒定的。这导致我们需要引入一种特殊类别的序列——等差数列，其定义如下。
- en: 'Sequences where the difference between any two consecutive terms is constant
    are called **arithmetic**. Hence, the formula for arithmetic sequences is as follows:
    *α*n+1*- α*n *= d*'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 任意两个连续项之间的差是恒定的序列称为**等差**。因此，等差数列的公式如下：*α*n+1*- α*n *= d*
- en: 'Here, *d* is constant and must hold for all *n*. Of course, it becomes clear
    that, if you know the parameter *d* and some (any) term *α*n, then the term *α*n+1
    can be found by a straightforward application of the preceding relation. By repetition,
    all the terms, *α*n+2, *α*n+3 ..., as well as the terms *α*n-1, *α*n-2 can be
    found. In other words, all of the terms of our sequence are known (that is, uniquely
    determined) if you know the parameter *d*, and the first term of the sequence
    *α*1. The general formula that gives us the *n*th term of the sequence becomes
    the following:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，*d*是常数，必须对所有*n*成立。当然，很明显，如果你知道参数*d*和一些（任何）项*α*n*，那么项*α*n+1可以通过前面的关系直接找到。通过重复，所有项*α*n+2，*α*n+3
    ...，以及项*α*n-1，*α*n-2都可以找到。换句话说，如果你知道参数*d*和序列的第一项*α*1，那么所有项（即唯一确定的）的序列都是已知的。给出我们序列的第*n*项的一般公式如下：
- en: '*α*n *= α*1 *+ (n – 1)d*'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*α*n *= α*1 *+ (n – 1)d*'
- en: Here, *d* is known as the common difference.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，*d*被称为公差。
- en: 'Inversely, to test whether a generic sequence is an arithmetic one, it suffices
    to check all of the pairwise differences, *α*n+1 – *α*n, of its terms and see
    whether these are the same constant number. In the corresponding arithmetic series,
    the sum of the preceding sequence becomes the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，要测试一个通用序列是否是等差数列，只需检查其项的所有成对差异*α*n+1 – *α*n，并查看这些是否是相同的常数。在相应的等差数列中，前面序列的和变成了下面的形式：
- en: '*Σ*nj *α*j *= Σ*nj *[ α*1 *+ (j – 1)d ] = n(α*1 *+ α*n*)/2*'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '*Σ*nj *α*j *= Σ*nj *[ α*1 *+ (j – 1)d ] = n(α*1 *+ α*n*)/2*'
- en: This means that by knowing the length, *n*, the first, and the last term of
    the sequence, we can determine the sum of all terms from *α*1 to *α*n. Note that
    the sum (*α*1 + *α*n) gives twice the arithmetic mean of the whole sequence, so
    the series is nothing more than *n* times the arithmetic mean.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着通过知道长度*n*，序列的第一个和最后一个项，我们可以确定从*α*1到*α*n的所有项的和。请注意，和（*α*1 + *α*n）给出整个序列的算术平均数的两倍，因此该序列不过是算术平均数的*n*倍。
- en: 'Now, we know what the main logic and constituents of the arithmetic sequence
    are. Now, let''s look at some concrete examples. For now, we do not need to import
    any particular libraries in Python as we will be creating our own functions. Let''s
    remind ourselves that these always need to begin with `def`, followed by a space,
    the function name (anything that we like), and a list of arguments that the function
    takes inside brackets, followed by a semi-colon. The following lines are indented
    (four places to the right) and are where the logic, that is, the algorithm or
    method of the function, is written. For instance, consider the following example:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们知道算术序列的主要逻辑和组成部分。现在，让我们看一些具体的例子。目前，我们不需要在Python中导入任何特定的库，因为我们将创建自己的函数。让我们提醒自己，这些函数总是需要以`def`开头，后面跟着一个空格，函数名（任何我们喜欢的东西），以及函数在括号内接受的参数列表，后面跟着一个分号。接下来的行是缩进的（向右缩进四个空格），并且是函数的逻辑，也就是函数的算法或方法。例如，考虑以下例子：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'What follows the final statement, `result`, is what is being returned from
    the function. So, for instance, if we are programming the preceding `my_function`
    definition, which receives two input numbers, `arg1` and `arg2`, then we can pass
    it to a new variable, say, the following one:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在最终语句`result`之后，返回的是函数的返回值。因此，例如，如果我们正在编写前面的`my_function`定义，该定义接收两个输入数字`arg1`和`arg2`，那么我们可以将它传递给一个新变量，比如以下变量：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The output will be as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, `summed` is a new variable that is exactly what is being returned (produced)
    by `my_function`. Note that if the `return` statement within the definition of
    a function is missing, then the syntax is still correct and the function can still
    be called. However, the `summed` variable will be equal to `None`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`summed`是一个新变量，它正是由`my_function`返回（生成）的。请注意，如果在函数定义中缺少`return`语句，则语法仍然正确，函数仍然可以被调用。但是，`summed`变量将等于`None`。
- en: 'Now, if we want to create a (any) sequence of numbers, we should include an
    iteration inside our function. This is achieved in Python with either a `for`
    or a `while` loop. Let''s look at an example, where a function gives a sequence
    of `n` sums as the output:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们想创建一个（任何）数字序列，我们应该在我们的函数内包含一个迭代。在Python中，可以通过`for`或`while`循环来实现这一点。让我们看一个例子，一个函数输出一个`n`个和的序列：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here, we initiate the variable result (to zero) and then iteratively add to
    it the sum, `arg1 + arg2`. This iteration happens `n` times, where `n` is also
    an argument of our new function, `my_sequence`. Every time the loop (what follows
    the `for` statement) is executed, the `result` increases by `arg1 + arg2` and
    is then printed on-screen. We have omitted the `return` statement here for simplicity.
    Here, we used Python''s built-in `range()` method, which generates a sequence
    of integer numbers that starts at 0 and ends at one number before the given stop
    integer (the number that we provide as input). Let''s call our function:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们初始化变量result（为零），然后迭代地将`arg1 + arg2`加到它上面。这个迭代发生了`n`次，其中`n`也是我们新函数`my_sequence`的一个参数。每次循环（跟在`for`语句后面的）执行时，`result`增加了`arg1
    + arg2`，然后打印在屏幕上。为简单起见，我们在这里省略了`return`语句。在这里，我们使用了Python内置的`range()`方法，它生成一个整数序列，从0开始，以给定的停止整数之前的一个数结束（我们提供的数字）。让我们调用我们的函数：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We will obtain the following output:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将获得以下输出：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Had we used a `while` loop, we would have arrived at the same result:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用了`while`循环，我们将得到相同的结果：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If we were to call the `my_sequence` function, we would obtain the same output
    that we received previously for the same input.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们调用`my_sequence`函数，我们将得到与先前相同输入的相同输出。
- en: Generators
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成器
- en: 'One more interesting option for sequential operations in Python is the use
    of generators. **Generators** are objects, similar to functions, that return an
    iterable set of items, one value at a time. Simply speaking, if a function contains
    at least one `yield` statement, it becomes a generator function. The benefit of
    using generators as opposed to functions is that we can call the generator as
    many times as desired (here, an infinite amount) without cramming our system''s
    memory. In some situations, they can be invaluable tools. To obtain one term of
    a sequence of terms, we use the `next()` method. First, let''s define our function:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中进行顺序操作的另一个有趣选项是使用生成器。**生成器**是类似于函数的对象，返回一组可迭代的项目，一次一个值。简单地说，如果一个函数包含至少一个`yield`语句，它就成为一个生成器函数。使用生成器而不是函数的好处是，我们可以根据需要（这里是无限次数）调用生成器，而不会使系统的内存过载。在某些情况下，它们可以是无价的工具。要获取一系列项的一个项，我们使用`next()`方法。首先，让我们定义我们的函数：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, let''s call the `next()` method multiple times:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们多次调用`next()`方法：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The following is the output:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Call the method for the second time:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 第二次调用该方法：
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The following is the output:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出：
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Call it for the third time:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 第三次调用它：
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The following is the output:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出：
- en: '[PRE13]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Call the method for the fourth time:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 第四次调用该方法：
- en: '[PRE14]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The following is the output:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出：
- en: '[PRE15]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'So, we obtained the same results as in the previous example, but one at a time.
    If we call the `next()` method repetitively, we will get an error message since
    we have *exhausted* our generator:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们得到了与上一个示例相同的结果，但是一次一个。如果我们重复调用`next()`方法，我们将收到错误消息，因为我们已经*耗尽*了我们的生成器：
- en: '[PRE16]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now, we are ready to implement the relations of sequences we learned in Python
    code.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备在Python代码中实现我们学到的序列关系。
- en: 'Exercise 5.01: Determining the nth Term of an Arithmetic Sequence and Arithmetic
    Series'
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习5.01：确定算术序列和算术级数的第n项
- en: 'In this exercise, we will create a finite and infinite arithmetic sequence
    using a simple Python function. As inputs, we want to provide the first term of
    the sequence, `a1`, the common difference, `d`, and the length of the sequence,
    `n`. Our goal is to obtain the following:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用一个简单的Python函数创建有限和无限的算术序列。作为输入，我们希望提供序列的第一项`a1`，公差`d`和序列的长度`n`。我们的目标是获得以下内容：
- en: Just one term (the *n*th term) of the sequence.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 序列的一个项（第*n*项）。
- en: The full sequence of numbers.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完整的数字序列。
- en: The sum of *n* terms of the arithmetic sequence, in order to compare it to our
    result of the arithmetic series given previously.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 算术序列的*n*项的和，以便将其与先前给出的算术级数的结果进行比较。
- en: 'To calculate the preceding goals, we need to provide the first term of the
    sequence, `a1`, the common difference, `d`, and the length of the sequence, `n`,
    as inputs. Let''s implement this exercise:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 为了计算前面的目标，我们需要提供序列的第一项`a1`，公差`d`和序列的长度`n`作为输入。让我们实现这个练习：
- en: 'First, we want to write a function that returns just the *n*th term, according
    to the general formula *α*n *= α*1 *+ (n – 1)d*:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们想要编写一个函数，根据通用公式*α*n *= α*1 *+ (n – 1)d* 返回第*n*项：
- en: '[PRE17]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'By doing this, we obtain the *n*th term of the sequence without needing to
    know any other preceding terms. For example, let''s call our function with arguments
    `(4, 3, 10)`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，我们获得了序列的第*n*项，而无需知道任何其他前面的项。例如，让我们用参数`(4, 3, 10)`调用我们的函数：
- en: '[PRE18]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We will get the following output:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得到以下输出：
- en: '[PRE19]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, let''s write a function that increments the initial term, `a1`, by `d`,
    `n` times and stores all terms in a list:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们编写一个函数，它将初始项`a1`递增`d`，`n`次，并将所有项存储在列表中：
- en: '[PRE20]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To check the resulting list, add the following code:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要检查结果列表，请添加以下代码：
- en: '[PRE21]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The output will be as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE22]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here, we obtained the arithmetic sequence, which has a length of 10, starts
    at `4`, and increases by 3.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们得到了一个长度为10的算术序列，从`4`开始，增加3。
- en: 'Now, let''s generate the infinite sequence. We can achieve this using Python
    generators, which we introduced earlier:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们生成无限序列。我们可以使用之前介绍的Python生成器来实现这一点：
- en: '[PRE23]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: If you run the preceding code, you will notice that we have to abort the execution
    manually; otherwise, the `for` loop will print out the elements of the sequence
    eternally. An alternative way of using Python generators is, as explained previously,
    to call the `next()` method directly on the generator object (here, this is `infinite_a_sequence()`).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果运行上述代码，您会注意到我们必须手动中止执行；否则，`for`循环将永远打印出序列的元素。使用Python生成器的另一种方法是，如前所述，直接在生成器对象（这里是`infinite_a_sequence()`）上调用`next()`方法。
- en: 'Let''s calculate the sum of the terms of our sequence by calling the `sum()`
    Python method:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过调用`sum()` Python方法来计算我们序列的项的和：
- en: '[PRE24]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The output will be as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE25]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Finally, implement the *α*n *= α*1 *+ (n – 1)d* formula, which gives us the
    arithmetic series so that we can compare it with our result for the sum:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，实现*α*n *= α*1 *+ (n – 1)d* 公式，这给我们算术级数，以便我们可以将其与我们的求和结果进行比较：
- en: '[PRE26]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Run the function, as follows:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行函数，如下：
- en: '[PRE27]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The output is as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE28]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Note
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/2D2S52c.](https://packt.live/2D2S52c
    )
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅[https://packt.live/2D2S52c.](https://packt.live/2D2S52c )
- en: You can also run this example online at [https://packt.live/31DjRfO.](https://packt.live/31DjRfO
    )
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在[https://packt.live/31DjRfO.](https://packt.live/31DjRfO )上在线运行此示例
- en: With that, we have arrived at the same result for the summation of elements
    of an arithmetic sequence by using either a sequence or series. The ability to
    cross-validate a given result with two independent mathematical methods is extremely
    useful for programmers at all levels and lies at the heart of scientific validation.
    Moreover, knowing different methods (here, the two methods that we used to arrive
    at the series result) that can solve the same problem, and the advantages (as
    well as the disadvantages) of each method can be vital for writing code at an
    advanced level.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: 'We will study a different, but also fundamental, category of sequences: geometric
    ones.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: Geometric Sequences
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An infectious disease spreads from one person to another or more, depending
    on the density of the population in a given community. In a situation such as
    a pandemic, for a moderately contagious disease, it is realistic that, on average,
    each person who has the disease infects two people per day. So, if on day 1 there
    is just one person that's infected, on day 2 there will be two newly infected,
    and on day 3, another two people will have contracted the disease for each of
    the two previously infected people, bringing the number of the newly infected
    to four. Similarly, on day 4, eight new cases appear, and so on. We can see that
    the rate that a disease expands at is not constant since the number of new cases
    depends on the number of existing cases at a given moment—and this explains how
    pandemics arise and spread exponentially.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding numbers (1, 2, 4, 8...) form a sequence. Note that now, the requirement
    of the arithmetic sequence hasn''t been met: the difference between two successive
    terms is not constant. The ratio, nonetheless, is constant. This exemplifies the
    preceding sequence as a special type of sequence, known as **geometric**, and
    is defined as a sequence or a collection of ordered numbers where the ratio of
    any two successive terms is constant.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: In the compact language of mathematics, we can write the preceding behavior
    as *α*n+1 *= r α*n.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: Here, *α*n is the number of *cases* on day *n*, *α*n+1 is the number of new
    cases on day *n+1*, and *r>0* is a coefficient that defines how fast (or slow)
    the increase happens. This is known as the common ratio. The preceding formula
    is universal, meaning that it holds for all members, *n*. So, if it holds true
    for *n*, it does so for *n-1*, *n-2*, and so on. By working with the preceding
    relationship recursively, we can easily arrive at *α*n *= r*n-1*α* equation.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Here, we give the *n*th term of the geometric sequence once the first term,
    *α=α*1, and the common ratio, *r*, have been given. The term *α* is known as the
    **scale factor**.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that *r* can have any non-zero value. If *r>1*, every generation, *α*n+1,
    is larger than the one prior and so the sequence is ever-increasing, while the
    opposite is true if *r<1: α*n+1 tends towards zero as *n* increases. So, in the
    initial example of an infectious disease, *r>1* means that the transmission is
    increasing, while *r<1* yields a decreasing transmission.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write a Python function that calculates the *n*th term of a geometric
    function, based on the *α*n *= r*n-1*α* formula:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The inputs in that function are `r`, the common ratio, `a`, the scale factor,
    and `n`, the *n*th term that we want to find. Let''s call this function with some
    arguments, `(2, 3, 10)`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The output is as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Similarly, for the case of the arithmetic sequence, we define a geometric series
    as the sum of the terms of the sequence of length *n*:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3: A geometric sequence'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_05_03.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.3: A geometric sequence'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, we can express this as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4: Alternative expression for a geometric sequence'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_05_04.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.4: Alternative expression for a geometric sequence'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: 'To get a better understanding of the geometric series, let''s check out how
    it works in Python and visualize it. We need to define a function that admits
    `r`, `a`, and `n` (as we did previously) as input and calculate the second formula,
    that is, the series up to term *n*:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解几何级数，让我们看看它在Python中是如何工作并进行可视化的。我们需要定义一个函数，接受`r`、`a`和`n`（就像之前一样）作为输入，并计算第二个公式，即到第*n*项的级数：
- en: '[PRE32]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, call the function for arguments `(2, 3, 10)`, as we did previously:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，像之前一样，为参数`(2, 3, 10)`调用函数：
- en: '[PRE33]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The output is as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE34]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Have a look at the following example plot of geometric sequences, where the
    value increases for *r>1*:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下几何序列的以下示例图，其中值对*r>1*递增：
- en: '![Figure 5.5: Geometric sequences increasing for r>1'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.5：几何序列r>1递增'
- en: '](image/B15968_05_05.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_05_05.jpg)'
- en: 'Figure 5.5: Geometric sequences increasing for r>1'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.5：几何序列r>1递增
- en: 'Have a look at the following example plot of geometric sequences, where the
    value decreases for *r<1*:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下几何序列的以下示例图，其中值对*r<1*递减：
- en: '![Figure 5.6: Geometric sequences decreasing for r<1'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.6：几何序列r<1递减'
- en: '](image/B15968_05_06.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_05_06.jpg)'
- en: 'Figure 5.6: Geometric sequences decreasing for r<1'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.6：几何序列r<1递减
- en: In this section, we have seen how a geometric sequence progresses and how we
    can easily find the terms of it in Python, as well as the geometric series. We
    are now ready to implement what we've learned in an exercise in order to obtain
    a better understanding of sequences and their applications.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们已经看到了几何序列的进展以及如何在Python中轻松找到它的项，以及几何级数。我们现在准备在练习中实现我们所学到的内容，以便更好地理解序列及其应用。
- en: 'Exercise 5.02: Writing a Function to Find the Next Term of the Sequence'
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习5.02：编写一个函数来找到序列的下一个项
- en: 'The number of bacteria in a Petri dish increases as a geometric sequence. Given
    the population (number) of bacteria per day, across a number of days, *n*, write
    a function that calculates the population on day *n+1*. Follow these steps to
    complete this exercise:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 培养皿中细菌数量以几何序列增加。给定每天的细菌数量，跨越一定天数*n*，编写一个函数，计算第*n+1*天的细菌数量。按照以下步骤完成这个练习：
- en: 'Write a function that admits a variable number of arguments (`*args`) and calculates
    the ratio between any element and its preceding element (starting from the second
    element). Then, check whether all the ratios found are identical and return their
    unique value. Otherwise, the function returns `-1` (the sequence does not possess
    a unique common ratio):'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个函数，接受可变数量的参数（`*args`）并计算任何元素与其前一个元素之间的比率（从第二个元素开始）。然后，检查找到的所有比率是否相同，并返回它们的唯一值。否则，函数返回`-1`（序列没有唯一的公共比率）：
- en: '[PRE35]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, check the `find_ratio` function for two distinct cases. First, let''s
    use the following sequence:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，检查`find_ratio`函数的两种不同情况。首先，让我们使用以下序列：
- en: '[PRE36]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The output is as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE37]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now, let''s use the following sequence:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们使用以下序列：
- en: '[PRE38]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The output is as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE39]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: As shown in the preceding outputs, the `find_ratio` function prints out the
    ratio, if it exists, or prints `-1` if the sequence is not geometric.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的输出所示，`find_ratio`函数打印出比率，如果存在的话，或者如果序列不是几何序列，则打印`-1`。
- en: 'Now, write a second function that reads in a sequence and prints out what the
    next term will be. To do so, read in a (comma-separated) list of numbers, find
    their ratio, and from that, predict the next term:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，编写第二个函数，读取一个序列并打印出下一个项将是什么。为此，读取一个（逗号分隔的）数字列表，找到它们的比率，然后预测下一个项：
- en: '[PRE40]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Note that we want to check whether the sequence possesses a common ratio by
    calling the `find_ratio()` function we wrote previously. If it doesn't, raise
    an error; if it does, find the next term and return it.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们要通过调用我们之前编写的`find_ratio()`函数来检查序列是否具有公共比率。如果没有，就引发一个错误；如果有，就找到下一个项并返回它。
- en: 'Check if it works by using the following sequence:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用以下序列来检查它是否有效：
- en: '[PRE41]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The following is the output of the preceding code:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面代码的输出：
- en: '[PRE42]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now, try this with a different sequence:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，尝试使用不同的序列：
- en: '[PRE43]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The output is as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE44]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: It does work. In the first case, the obvious result, `8.0`, was printed. In
    the second case, the less obvious result of the decreasing geometric sequence
    was found and printed out. To summarize, we are able to write a function that
    detects a geometric sequence, finds its ratio, and uses that to predict the next-in-sequence
    term. This is extremely useful in real-life scenarios, such as in cases where
    the compound interest rate needs to be verified.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 它有效。在第一种情况下，明显的结果`8.0`被打印出来。在第二种情况下，找到并打印出了递减的几何序列的不太明显的结果。总之，我们能够编写一个函数，检测几何序列，找到它的比率，并用它来预测下一个序列项。这在现实生活中非常有用，比如需要验证复利利率的情况。
- en: Note
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/2NUyT8N.](https://packt.live/2NUyT8N
    )
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问此特定部分的源代码，请参阅[https://packt.live/2NUyT8N](https://packt.live/2NUyT8N)。
- en: You can also run this example online at [https://packt.live/3dRMwQV.](https://packt.live/3dRMwQV
    )
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以在[https://packt.live/3dRMwQV](https://packt.live/3dRMwQV)上在线运行此示例。
- en: In the previous sections, we saw that sequences, either arithmetic or geometric,
    can be defined in two equivalent ways. We saw that the *n*th term of the sequence
    is determined by knowing a given term of the sequence (commonly the first, but
    not necessarily) and the common difference, or common ratio. More interestingly,
    we saw that the *n*th term of a sequence can be found by knowing the *(n-1)*th
    term, which, in turn, can be found by knowing the *(n-2)*th term, and so on. So,
    there is an interesting pattern here that dictates both sequence types that we
    studied and which, in fact, extends beyond them. It turns out that we can generalize
    this behavior and define sequences in a purely recursive manner that isn't necessarily
    arithmetic or geometric. Now, let's move on to the next section, where we will
    understand recursive sequences.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: Recursive Sequences
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **recursive sequence** is a sequence of elements, *υ*n, that are produced
    via a recursive relation, that is, each element uniquely stems from the preceding
    ones.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '*υ*n can depend on one or more elements preceding it. For example, the Fibonacci
    series that we saw earlier in this chapter is a recursive sequence where knowledge
    of the *n*th term requires knowing both the *(n-1)*th and *(n-2)*th terms. On
    the other hand, the factorial only needs the element that precedes it. Specifically,
    it is defined by the recurrence relation, *n! = n(n-1)! , n > 0*, and the initial
    condition, *0! = 1*.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s convert the preceding formulas into Python code:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The preceding code is a recursive implementation of the factorial function:
    to calculate the result for *n*, we call the function for *n-1*, which, in turn,
    calls the function for *n-2* and so on until *n=2* is reached.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: 'If we execute the preceding function for the case *n=11*, we obtain the following:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The output is as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Note that while the first two categories of sequences that we've seen so far
    (arithmetic and geometric) are mutually exclusive, the recursive family of sequences
    is not, meaning that sequences can be both recursive and arithmetic or recursive
    and geometric. Conventionally, we use the term *recursive* for these types of
    sequences that, unlike geometric and arithmetic, cannot be expressed in a non-recursive
    manner.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have explored the basic concepts of recursive sequences, we can
    implement this in Python and write code that calculates any number of elements
    of any sequence that is recursively defined.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 5.03: Creating a Custom Recursive Sequence'
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will create a custom recursive sequence using the concepts
    we explained in the previous section. Given the first three elements of the sequence,
    *P*n, that is, *P*1*=1*, *P*2*=7*, and *P*3*=2*, find the next seven terms of
    the sequence that is recursively defined via the relation: *P*n+3*= (3*P*n+1 *-
    P*n+2*)/(P*n *– 1)*. Follow these steps to complete this exercise:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: 'Define a Python function that is recursive and implements the relation given
    previously for the *n*th element of the sequence:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Here, we started by defining the base cases, that is, the known result as given
    in the brief: if *n=1*, then *P=1*, if *n=2*, then *P=7*, and if *n=3*, then *P=2*.
    We also included the case where *n<1*. This is invalid input and, as is customary,
    our function returns the value `-1`. This makes our function *bounded* and protected
    from entering infinite loops and invalid input. Once these cases have been taken
    care of, then we have defined the recursive relation.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s test our function and print out the first 10 values of the sequence
    (three that correspond to the base cases and seven of them that are for our task):'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The output is as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: As you can see from the preceding output, our function works and gives back
    both the known values (*P*1 *= 1*, *P*2 *= 7*, and *P*3 *= 2*) of the sequence
    and the next terms (*P_1* to *P_10*) that we were looking for.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: 'As a bonus, let''s plot our findings by using the `matplotlib` module. We will
    create a list that holds the first nine values of the sequence and then plot it
    with `pyplot`:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为奖励，让我们使用`matplotlib`模块绘制我们的发现。我们将创建一个包含序列前九个值的列表，然后用`pyplot`绘制它：
- en: '[PRE51]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The output is as follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 5.7: Plot created using the matplotlib library'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.7：使用matplotlib库创建的图表'
- en: '](image/B15968_05_07.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_05_07.jpg)'
- en: 'Figure 5.7: Plot created using the matplotlib library'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.7：使用matplotlib库创建的图表
- en: Note
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To access the source code for this specific section, please refer to [https://packt.live/2D3vlPF.](https://packt.live/2D3vlPF
    )
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问本节的源代码，请参阅[https://packt.live/2D3vlPF](https://packt.live/2D3vlPF)。
- en: You can also run this example online at [https://packt.live/3eY05Q4.](https://packt.live/3eY05Q4
    )
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以在[https://packt.live/3eY05Q4](https://packt.live/3eY05Q4)上在线运行此示例。
- en: We can see that a simple and well-defined recursive relation can lead to apparently
    random or chaotic results. Indeed, if you continue plotting the terms of the preceding
    sequence, you will soon notice that there is no apparent regularity in the pattern
    of the terms as they widely and asymmetrically oscillate around 0\. This prompts
    us to arrive at the conclusion that even though defining a recursive sequence
    and predicting its *n*th term is straightforward, the opposite is not always true.
    As we saw, given a sequence (a list of numbers), it is quite simple to check whether
    it forms an arithmetic sequence, a geometric sequence, or neither. However, to
    answer whether a given sequence has been derived by a recursive relation—let alone
    what this recursion is—is a non-trivial task that, in most cases, cannot be answered.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，一个简单而明确定义的递归关系可以导致明显随机或混沌的结果。实际上，如果您继续绘制前述序列的项，很快就会注意到在项的模式中没有明显的规律，它们在0周围广泛且不对称地振荡。这促使我们得出结论，即使定义了一个递归序列并预测了它的第n项是直接的，相反的情况并不总是成立。正如我们所看到的，鉴于一个序列（一系列数字），检查它是否形成等差数列、等比数列或两者都不是，是非常简单的。然而，要回答一个给定的序列是否由递归关系导出——更不用说这个递归是什么——是一个非平凡的任务，在大多数情况下都无法回答。
- en: 'In this section, we have presented what sequences are, why they are important,
    and how they are connected to another important concept in mathematics: series.
    We studied three general types of sequences, namely arithmetic, geometric, and
    recursive, and saw how they can be implemented in Python in a few simple steps.
    In the next section, we''ll delve into trigonometry and learn how trigonometric
    problems can be easily solved using Python.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了序列是什么，为什么它们很重要，以及它们与数学中另一个重要概念的联系：级数。我们研究了三种一般类型的序列，即等差、等比和递归，并看到它们如何可以在Python中通过几个简单的步骤实现。在下一节中，我们将深入研究三角学，并学习如何使用Python轻松解决三角学问题。
- en: Trigonometry
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 三角学
- en: Trigonometry is about studying triangles and, in particular, the relation of
    their angles to their edges. The ratio of two of the three edges (sides) of a
    triangle gives information about a particular angle, and to such a pair of sides,
    we give it a certain name and call it a function. The beauty of trigonometry and
    mathematics in general is that these functions, which are born inside a triangle,
    make (abstract) sense in any other situation where triangles are not present and
    operate as independent mathematical objects. Hence, functions such as the tangent,
    cosine, and sine are found across most fields of mathematics, physics, and engineering
    without any reference to the triangle.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 三角学是研究三角形，特别是它们的角与边的关系。三角形的三条边（边）中的两条的比值提供了关于特定角的信息，并且对于这样一对边，我们给它一个特定的名称，并称之为函数。三角学和数学的美妙之处在于这些函数，它们诞生于三角形内部，在三角形不存在的任何其他情况下都有（抽象的）意义，并且作为独立的数学对象运行。因此，诸如正切、余弦和正弦之类的函数在大多数数学、物理和工程领域都可以找到，而无需参考三角形。
- en: Let's look at the most fundamental trigonometric functions and their usage.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看最基本的三角函数及其用法。
- en: Basic Trigonometric Functions
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本三角函数
- en: 'We will start by defining a right-angled triangle (or simply a right triangle),
    triangle ABC. One of its angles (the angle BCA in the following diagram) is a
    **right angle**, that is, a 90-degree angle. The side opposite the right angle
    is called the **hypotenuse** (side *h* in the following diagram), while the other
    sides (*a* and *b*) are known as legs. They are also referred to as *opposite*
    and *adjacent* to the respective angle. For instance, side *b* is adjacent to
    the lower right angle in the following diagram (angle CAB or *θ*), while it is
    opposite when we refer to the top angle (angle CBA):'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从定义一个直角三角形（或简称直角三角形）开始，三角形ABC。它的一个角（下图中的角BCA）是一个**直角**，即90度角。直角的对边称为**斜边**（下图中的边*h*），而其他两边（*a*和*b*）称为腿。它们也被称为相对于各自角的*对边*和*邻边*。例如，边*b*是相邻于下图中的右下角的（角CAB或*θ*），而当我们提到顶角（角CBA）时，它是对边：
- en: '![Figure 5.8: A right-angled triangle'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.8：直角三角形'
- en: '](image/B15968_05_08.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_05_08.jpg)'
- en: 'Figure 5.8: A right-angled triangle'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.8：直角三角形
- en: 'The most common trigonometric functions are defined with the help of the preceding
    diagram and are defined as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的三角函数是通过前面的图表定义的，并且定义如下：
- en: '![Figure 5.9: Trigonometric functions'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.9：三角函数'
- en: '](image/B15968_05_09.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15968_05_09.jpg)'
- en: 'Figure 5.9: Trigonometric functions'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.9：三角函数
- en: For the tangent function, it also holds that *tanθ = sinθ/cosθ*.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 对于正切函数，也成立 *tanθ = sinθ/cosθ*。
- en: 'Also, for any angle, θ, the following identity always holds true: *sinθ*2 *+
    cosθ*2 *= 1*.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，对于任何角度θ，以下恒等式始终成立：*sinθ*2 *+ cosθ*2 *= 1*。
- en: By construction, the trigonometric functions are periodic. This means that,
    regardless of the sizes of the edges of a triangle, the preceding functions take
    on values that repeat themselves every 2π. This will become apparent in the next
    exercise, where we will be plotting them. The range of the sine and cosine functions
    is the interval [-1,1]. This means that the smallest value they can obtain is
    -1, and the largest is 1, no matter what the input θ is.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: 'Last but not least, the edges of the right-angled triangle are connected via
    the famous Pythagorean theorem: *h*2 *= a*2 *+ b*2'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: 'In Python code, a simple implementation of the Pythagorean theorem would be
    to write a function that calculates *h*, given *a* and *b*, with the help of the
    square root (`sqrt`) method of the `math` module; for instance:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Calling this function for *a=3* and *b=4* gives us the following:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The output is as follows:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Now, let's look at some concrete examples so that we can grasp these ideas.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 5.04: Plotting a Right-Angled Triangle'
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will write Python functions that will plot a right triangle
    for the given points, *p*1 and *p*2. The right-angled triangle will correspond
    to the endpoints of the legs of the triangle. We will also calculate the three
    trigonometric functions for either of the non-right angles. Let''s plot the basic
    trigonometry functions:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the `numpy` and `pyplot` libraries:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Now, write a function that returns the hypotenuse by using the Pythagorean
    theorem when given the two sides, *p*1 and *p*2, as inputs:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now, let''s write another function that implements the relations for the `sin`,
    `cos`, and `tan` functions. The inputs are the lengths of the adjacent, opposite,
    and hypotenuse of a given angle, and the result is a tuple of the trigonometric
    values:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Now, write the function that plots the triangle. For simplicity, place the
    right angle at the origin of the axes at (0,0), the first input point along the
    *x* axis at (p1, 0), and the second input point along the *y* axis at (0, p2):'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Here, we created the lists, `x` and `y`, that hold the points and one more list,
    `n`, for the labels. Then, we created a `pyplot` object that plots the points
    first, and then the edges. The last two lines are used to annotate our plot; that
    is, add the labels (from the list, `n`) next to our points.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to choose two points in order to define a triangle. Then, we need to
    call our functions to display the plot:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The first line prints the values of the three trigonometric functions, `sin`,
    `cos`, and `tan`, respectively. Then, we plot our triangle, which in this case
    is isosceles since it has two sides that are of equal length.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: 'The output will be as follows:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.10: Plotting the isosceles triangle'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_05_10.jpg)'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.10: Plotting the isosceles triangle'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: The results are expected and correct—upon rounding the error—since the geometry
    of this particular shape is simple (an isosceles orthogonal triangle that has
    two angles equal to π/4). Then, we checked the result (note that in NumPy, the
    value of pi can be directly called `np.pi`).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, to get a general overview of the `sin` and `cos` trigonometric functions,
    let''s plot them:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The output will be as follows:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.11: Plot of the sin and cos trigonometric functions'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_05_11.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.11: Plot of the sin and cos trigonometric functions'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we kick-started our explorations of the sphere of trigonometry
    and saw how to arrive at useful visualizations in Python.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/2Zz0TnU.](https://packt.live/2Zz0TnU
    )
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/2AoxS63.](https://packt.live/2AoxS63
    )
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: 'With that, we have established the main trigonometric functions and saw how
    these provide an operation between an angle and an associated trigonometric value,
    given by either the sin, cos, or tan function. Moreover, we saw that these three
    functions are periodic, that is, repeated every 2π, while the first two are bounded,
    that is, the values they can take never exceed the interval, [-1,1]. These values
    are directly found in Python or in a scientific pocket calculator. In many situations,
    however, the inverse process is desired: can I find the angle if I give the value
    of sin, cos, or tan to some function? Does such a function exist? We''ll answer
    these questions in the next section.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: Inverse Trigonometric Functions
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Inverse trigonometric functions are the inverse functions of the trigonometric
    functions and are just as useful as their counterparts. An inverse function is
    a function that *reverses* the operation or result of the original function. Recall
    that trigonometric functions admit angles as input values and output pure numbers
    (ratios). Inverse trigonometric functions do the opposite: they admit a pure number
    as input and give an angle as output. So, if, for instance, a point, π, is mapped
    to point -1 (as the cos function does), then its inverse needs to do exactly the
    opposite. This mapping needs to hold for every point where the inverse function
    is defined.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: 'The inverse function of the *sin(x)* function is called *arcsin(x)*: if *y=sin(x)*,
    then *x=arcsin(y)*. Recall that *sin* is a periodic function, so many different
    *x*''s are mapped to the same *y*. So, the inverse function would map one point
    to several different ones. This cannot be allowed since it clashes with the very
    definition of a function. To avoid this drawback, we need to restrict our domain
    of *arcsin* (and similarly for *arccos*) to the interval [-1,1], while the images,
    *y=arcsin(x)* and *y=arccos(x)*, are restricted to the ranges [-π/2,π/2] and [0,
    π] respectively.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: 'We can define the three basic inverse trigonometric functions as follows:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '*arcsin(x) = y such that arcsin(sin(x)) = x*'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*arccos(x) = y such that arccos(cos(x)) = x*'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*arctan(x) = y such that arctan(tan(x)) = x*'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In Python, these functions can be called either from the `math` module or from
    within the `numpy` library. Since most Python implementations of trigonometric
    inverse functions return radians, we may want to convert the outcome into degrees.
    We can do this by multiplying the radians by 180 and then dividing by π.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how this can be written in code. Note that the input, `x`, is expressed
    as a pure number between -1 and 1, while the output is expressed in radians. Let''s
    import the required libraries and declare the value of `x`:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Now, to print the inverse of cosine, add the following code:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The output is as follows:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'To print the inverse of sine, add the following code:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The output is as follows:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'To print the inverse of tan, add the following code:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The output is as follows:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Let''s try adding an input to the `acos` function that''s outside the range
    [-1,1]:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'We will get an error, as follows:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Something similar will happen for `asin`. This is to be expected since no angle,
    *φ*, exists that can return `-1.2` as cos (or sin). However, this input is permitted
    in the `atan` function:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The output is as follows:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Last, let''s check what the inverse of the inverse `arccos(cos(x))` function
    gives us:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The output is as follows:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: As expected, we retrieve the value of the input of the `cos` function.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: 'The inverse trigonometric functions have a variety of applications across mathematics,
    physics, and engineering. For example, calculating integrals can be done by using
    inverse trigonometric functions. The indefinite integrals are as follows:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.12: Inverse trigonometric functions'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_05_12.jpg)'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.12: Inverse trigonometric functions'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: Here, *a* is a parameter and *C* is a constant, and the integrals become immediately
    solvable with the help of inverse trigonometric functions.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 5.05: Finding the Shortest Way to the Treasure Using Inverse Trigonometric
    Functions'
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, you will be given a secret map that points to **B**, where
    some precious treasure has been lying for centuries. You are at point **A** and
    the instructions are clear: you have to navigate 20 km south then 33 km west so
    that you arrive at the treasure. However, the straight-line segment, **AB**, is
    the shortest. You need to find the angle **θ** on the map so that your navigation
    is correctly oriented:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.13: Graphical representation of the points A, B, and C'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_05_13.jpg)'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.13: Graphical representation of the points A, B, and C'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to find the angle **θ**, which is the angle between the segments **AB**
    and **AC**. Follow these steps:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the `atan` (arctan or inverse tangent) function:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Find the tangent of *θ* using `BC` and `AC`:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The output is as follows:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Next, find the angle by taking the inverse tangent function. Its argument is
    the tangent of *θ*:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Convert that into degrees and print the value:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The output is as follows:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: So, the answer is that we need to turn 31.22 degrees in order to navigate correctly.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: 'As a bonus point, calculate the distance that we will travel along the path
    `AB`. This is simply given by the Pythagorean theorem as follows:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*AB*2 *= AC*2 *+ BC*2'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: 'In Python, use the following code:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The output is as follows:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: The course will be 38.59 km.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: It is straightforward to calculate this in Python by calling the `find_hypotenuse()`
    function. As expected, this is much shorter than the path *AC + BC = 53* km.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/31CF4qr.](https://packt.live/31CF4qr
    )
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/38jfVlI.](https://packt.live/38jfVlI
    )
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 5.06: Finding the Optimal Distance from an Object'
  id: totrans-327
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You are visiting your local arena to watch your favorite show, and you are
    standing in the middle of the arena. Besides the main stage, there is also a viewing
    screen so that people can watch and not miss the details of the show. The bottom
    of the screen stands 3 m above your eye level, and the screen itself is 7 m high.
    The angle of vision is formed by looking at both the bottom and top of the screen.
    Find the optimal distance, *x*, between yourself and the screen so that the angle
    of vision is maximized:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.14: Angle of vision formed between the eyes and the screen'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_05_14.jpg)'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.14: Angle of vision formed between the eyes and the screen'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a slightly involved problem that requires a bit of algebra, but we
    will break it down into simple steps and explain the logic. First, note how much
    the plot of the problem guides us and helps us arrive at a solution. This apparently
    complex real-world problem translates into a much more abstract and simple geometric
    picture. Follow these steps to complete this exercise:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: 'Calculate *x*. This is the lower side of the triangle and also the adjacent
    side to the angle, *θ*1 (and also *θ=θ*1*+θ*2). The answer, *x*, will be given
    by the condition that the viewing angle, *θ*2 or equivalently, *tan(θ*2*)*), is
    maximized. From the preceding plot of the *screen*, we can immediately draw the
    following relations for the three angles: *θ*1 (the inner angle), *θ*2 (the outer
    angle), and *θ=θ*1*+θ*2:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*tan(θ*1*) = opposite/adjacent = 3/x*'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: '*tan(θ) = tan(θ*1*+θ*2*) = opposite/adjacent = (7+3)/x .*'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: Now, use algebra to work around these two relations and obtain a condition for
    *θ*2.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: 'A known identity for the tangent of a sum of two angles is as follows:![Figure
    5.15: Formula for tangent of a sum of two angles'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](image/B15968_05_15.jpg)'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.15: Formula for tangent of a sum of two angles'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: 'By substituting what we have found for *tan(θ)* and *tan(θ*1*)* in the latter
    relation and after working out the algebra, we arrive at the following:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: '*tan(θ*2*) = 7x/(30+x*2*) or*'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: '*θ*2 *= arctan(7x/(30+x*2*)).*'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: In other words, we have combined the elements of the problem and found that
    the angle, *θ*1, ought to change with the distance, *x*, as a function of *x*,
    which was given in the preceding line.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s plot this function to see how it changes. First, load the necessary
    libraries:'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Then, plot the function by defining the domain, `x`, and the values, `y`, by
    using the `arctan` method of `numpy`. These are easily plotted with the `plot()`
    method of `pyplot`, as follows:'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'The output will be as follows:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.16: Plot of the function using the arctan method'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_05_16.jpg)'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.16: Plot of the function using the arctan method'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: From the preceding graph, we can see that the functions obtain a maximum.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: 'Determine the function''s maximum value, `y`, and the position, `x`, where
    this occurs:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The output is as follows:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Lastly, convert the found angle into degrees:'
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'The output is as follows:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: So, the viewing angle, *θ*2, is at its maximum at 32.58 degrees and occurs when
    we stand 5.47 m away from the screen. We used the trigonometric and inverse trigonometric
    functions, implemented them in Python, and found the answer to a problem that
    arises from a *geometric* setup in a real-life situation. This sheds more light
    on how concepts from geometry and trigonometry can be usefully and easily coded
    to provide the expected results.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/2VB3Oez.](https://packt.live/2VB3Oez
    )
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/2VG9x2T.](https://packt.live/2VG9x2T
    )
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will move on and study another central concept in mathematics with
    a wide range of applications in algebra, physics, computer science, and applied
    data science: vectors.'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: Vectors
  id: totrans-366
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Vectors** are abstract mathematical objects with a magnitude (size) and direction
    (orientation). A vector is represented by an arrow that has a base (tail) and
    a head. The head shows the direction of the vector, while the length of the arrow''s
    body shows its magnitude.'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: A **scalar**, in contrast to a vector, is a sole number. It's a non-vector,
    that is, a pure integer, real or complex (as we shall see later), that has no
    elements and hence no direction.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: Vectors are symbolized by either a bold-faced letter **A**, a letter with an
    arrow on top, or simply by a regular letter, if there is no ambiguity regarding
    the notation in the discussion. The magnitude of the vector, **A**, is stylized
    as *|A|* or simply *A*. Now, let's have a look at the various vector operations.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: Vector Operations
  id: totrans-370
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Simply put, a vector is a collection (think of a list or array) of two, three,
    or more numbers that form a mathematical object. This object lives in a particular
    geometrical space called a vector space that has some properties, such as metric
    properties, and dimensionality. A vector space can be two-dimensional (think of
    the plane of a sheet of your book), three-dimensional (the ordinary Euclidean
    space around us), or higher, in many abstract situations in mathematics and physics.
    The elements or numbers that are needed to identify a vector equals the dimensionality
    of the space. Now that we have defined a vector space—the playground for vectors—we
    can equip it with a system of axes (the usual *x*, *y*, and *z* axes) that mark
    the origin and measure the space. In such a well-defined space, we need to determine
    a set of numbers (two, three, or more) in order to uniquely define a vector, since
    vectors are assumed to begin at the origin of axes. The elements of a vector can
    be integers, rational, real, or (rarely) complex numbers. In Python, they are,
    most commonly, represented by lists or NumPy arrays.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to real numbers, a set of linear operations is defined on vectors.
    Between two vectors, A = (a1, a2, a3) and B = (b1, b2, b3), we can define the
    following:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.17: Points A, B, and C and their relations while performing vector
    operations'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_05_17.jpg)'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.17: Points A, B, and C and their relations while performing vector
    operations'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let us see the various operations that can be performed on these vectors:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: '**Addition** as the operation that results in vector *C = A + B = (a*1 *+ b*1*,
    a*2 *+ b*2*, a*3 *+ b*3*)*.'
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Subtraction** as the operation that results in vector *C = A - B = (a*1 *-
    b*1*, a*2 *- b*2*, a*3 *- b*3*)*.'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dot** (or inner or scalar) *product* of the *scalar* *C = b. b = a*1 *b*1
    *+ a*2 *b*2 *+ a*3 *b*3.'
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cross** (or exterior) *product* of the vector *C = A x B*, which is perpendicular
    to the plane define by *A* and *B* and has elements (*a*2*b*3 *- a*3*b*2*, a*3*b*1
    *- a*1*b*3*, a*1*b*2 *– a*2*b*1).'
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Element-wise** or Hadamard *product* of two vectors, *A* and *B*, is the
    vector, *C*, whose elements are the pairwise product of elements of *A* and *B*;
    that is, *C = (a*1 *b*1*, a*2 *b*2*, a*3 *b*3).'
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can define and use the preceding formulas in Python code as follows:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Then, to find the sum of `A` and `B`, enter the following code:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'The output is as follows:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'To calculate the difference, enter the following code:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'The output is as follows:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'To find the element-wise product, enter the following code:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'The output is as follows:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'To find the dot product, use the following code:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'The output is as follows:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Finally, the cross product can be calculated as follows:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'The output is as follows:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Note that vector addition, subtraction, and the dot product are associative
    and commutative operations, whereas the cross product is associative but not commutative.
    In other words, a x b does not equal b x a, but rather b x a, which is why it
    is called **anticommutative**.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, a vector, *A*, can be multiplied by a scalar, *λ*. In that case, you
    simply have to multiply each vector element by the same number, that is, the scalar:
    *λ A = λ (a*1*, a*2*, a*3*) = (λ a*1*, λ a*2*, λ a*3)'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: Another important operation between vectors is the dot product, since it is
    arguably the most common operation to appear in mathematics, computer science,
    and its applications. The dot product is a funny type of operation that has no
    analog in the realm of real numbers. Indeed, it needs two vectors as input to
    produce a single scalar as output. This means that the result of the operation
    (scalar) is of a different type than its ingredients (vectors), and thus an inverse
    operation (a *dot division*) cannot generally exist.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: 'By definition, it is given as follows:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.18: Graphical representation of the θ angle'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_05_18.jpg)'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.18: Graphical representation of the θ angle'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be represented by the following equation:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: '*A.B = |A| |B| cos(θ)*'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: Here, *θ* is the angle between *A* and *B*.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at some typical cases:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: 'If *A* and *B* are orthogonal, then the dot product vanishes:'
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*A.B = 0* if and only if *θ = angle(A,B) = π/2*, since *|A|* and *|B|* are
    not zero.'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: If *A* and *B* are co-linear and co-directional, then *θ = 0*, *cos(θ)=1* and
    *A.B = |A| |B|*. If they are co-linear and have opposite directions, then *θ =
    π*, *cos(θ)=-1*, and *A.B = -|A| |B|*.
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It follows on from the definition for the dot product of a vector with itself:
    *A.A = |A| |A| or |A| = √(A.A)*'
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It follows directly from *A.B = |A| |B| cos(θ)*, where the angle between the
    two vectors is given as follows: *θ = arccos(A.B / |A| |B|)*'
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Here, *arccos* is the inverse *cos* function that we saw in the previous section.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can write a Python program that calculates the angle between
    any two given vectors with the help of `numpy` and the preceding relation that
    gives us the angle, *θ*:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'To find the norm (magnitude) of each vector, we can use the following code:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'As an alternative, you can also use the following code:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Print their values:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'You will get the following output:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: Both alternatives lead to the same result, which you can immediately check by
    printing `Amagn` and `Bmagn` once more.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we can find the angle, *θ*, as follows:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'The output is as follows:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: Now, let's have a look at exercise where will perform the various vector operations
    that we just learned about.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 5.07: Visualizing Vectors'
  id: totrans-437
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we will write a function that plots two vectors in a 2D space.
    We'll have to find their sum and the angle between them.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to complete this exercise:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the necessary libraries, that is, `numpy` and `matplotlib`:'
  id: totrans-440
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE106]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Create a function that admits two vectors as inputs, each as a list, plots
    them, and, optionally, plots their sum vector:'
  id: totrans-442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE107]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: The `vec1` and `vec2` lists hold two real numbers each. Each pair denotes the
    endpoint (head) coordinates of the corresponding vector, while the origin is set
    at (0,0). The labels are set to `"A"`, `"B"`, and `"A+B"`, but you could change
    them or even set them as variables of the `plot_vectors` function with (or without)
    default values. The Boolean variable, `isSum`, is, by default, set to `False`
    and the sum, `vec1+vec2`, will not be plotted unless it's explicitly set to `True`.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we put the coordinates on a `matplotlib.pyplot` object:'
  id: totrans-445
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE108]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: Here, we used the annotate method to add labels to our vectors, as well as the
    arrow method, in order to create our vectors. The star operator, `*`, is used
    to unpack the arguments within the list's `orig` and `vec1`, `vec2` so that they
    are read correctly from the `arrow()` method. `plt.grid()` creates a grid on the
    plot's background to guide the eye and is optional. The `e` parameter is added
    so that the plot limits are wide enough and the plot is readable.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we give our graph a title and plot it:'
  id: totrans-448
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE109]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Now, we will write a function that calculates the angle between the two input
    vectors, as explained previously, with the help of the dot (inner) product:'
  id: totrans-450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE110]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: First, we map our input lists to `numpy` arrays so that we can use the methods
    of this module. We calculate the dot product (named `product12`) and then divide
    that by the product of the magnitude of `vec1` with the magnitude of `vec2`. Recall
    that the magnitude of a vector is given by the square root (or `**0.5`) of the
    dot product with itself. As given by the definition of the dot product, we know
    that this quantity is the cos of the angle theta between the two vectors. Lastly,
    after rounding cos to avoid input errors in the next line, calculate theta by
    making use of the `arccos` method of `numpy`.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: 'We want to combine the two functions that we wrote—`find_angle` and `plot_vectors`—and
    call the former inside the latter. We also want to give the user the option to
    print the result for the angle either in radians (`isRadians=True`) or degrees
    (`isRadians=False`). We are now ready to try our function. First, let''s try this
    with two perpendicular vectors:'
  id: totrans-453
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE111]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'The output is as follows:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.19: Plot of two perpendicular vectors'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_05_19.jpg)'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.19: Plot of two perpendicular vectors'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: The plot looks good and the result is 90 degrees, as expected.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s try using the same function to create two co-linear vectors:'
  id: totrans-460
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE112]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'The output is as follows:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.20: Plot of two co-linear vectors'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_05_20.jpg)'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.20: Plot of two co-linear vectors'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: The output is 0 degrees, as expected.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, again, using the same function, let''s create two generic vectors:'
  id: totrans-467
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE113]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'The output is as follows:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.21: Plot of two generic vectors'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_05_21.jpg)'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.21: Plot of two generic vectors'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: In summary, we have studied vectors as mathematical objects that live in a vector
    space. We have learned how to construct and represent vectors in Python and how
    to visualize them. Vectors follow some simple rules, and performing operations
    with them is possible. Addition and subtraction follow exactly the same logic
    when dealing with real numbers. Multiplication is somewhat more involved and different
    types of products are defined. The most common product is the inner or dot product,
    which enjoys wide *popularity* in the mathematical and physics communities due
    to its simple geometric representation. We learned how to calculate the dot product
    of any two vectors in Python and, moreover, found the angle between the duet by
    using our knowledge (and some NumPy methods) of the dot product. In simple terms,
    a vector, in two dimensions, is a pair of numbers that form a geometric object
    with interesting properties.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/2Zxu7n5.](https://packt.live/2Zxu7n5
    )
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/2YPntJQ.](https://packt.live/2YPntJQ
    )
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will learn how a pair of two numbers can be combined into an even more
    exciting object, that of a complex number.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
- en: Complex Numbers
  id: totrans-478
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mathematical ideas have been evolving regarding numbers and their relationships
    since ancient numerical systems. Historically, mathematical ideas have evolved
    from concrete to abstract ones. For instance, a set of natural numbers was created
    so that all physical objects in the world around us directly correspond to some
    number within this set. Since arithmetic and algebra have developed, it has become
    clear that numbers beyond the naturals or integers are necessary, so decimal and
    rational numbers were introduced. Similarly, around the times of Pythagoras, it
    was found that rational numbers cannot solve all numerical problems that we could
    construct with the geometry that was known at that time. This happened when irrational
    numbers—numbers that result from taking the square root of other numbers and that
    have no representation as ratios—were introduced.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: Complex numbers are an extension of real numbers and include some special numbers
    that can provide a solution to some equations that real numbers cannot.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
- en: Such a number does, in fact, exist and has the symbol *i*. It is called an imaginary
    number or imaginary unit, even though there is nothing imaginary about it; it
    is as real as all the other numbers that we have seen and has, as we shall see,
    some very beautiful properties.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: Basic Definitions of Complex Numbers
  id: totrans-482
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We define the imaginary number *i* as follows:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: '*i*2 *= -1*'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: 'Any number that consists of a real and an imaginary number (part) is called
    a **complex number**. For example, consider the following numbers:'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
- en: '*z = 3 – i*'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
- en: '*z = 14/11 + i 3*'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
- en: '*z = -√5 – i 2.1*'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
- en: 'All the preceding numbers are all complex numbers. Their real part is symbolized
    as *Re(z)* and their imaginary part is symbolized as *Im(z)*. For the preceding
    examples, we get the following:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
- en: '*Re(z) = 3 , Im(z) = -1*'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
- en: '*Re(z) = 14/11 , Im(z) = 3*'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
- en: '*Re(z) = -√5 , Im(z) = -2.1*'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at some examples using code. In Python, the imaginary unit is symbolized
    with the letter *j* and a complex number is written as follows:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Here, `<real>` and `<imag>` are real numbers. Equivalently, a complex number
    can be defined as follows:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'In code, it becomes as follows:'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'The output is as follows:'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'We can also use the `real` and `imag` functions to separate the real and imaginary
    parts of any complex number, `z`. First, let''s use the `real` function:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'The output is as follows:'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'Now, use the `imag` function:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'The output is as follows:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: In other words, any complex number can be decomposed and written as *z=Re(z)
    + i Im(z)*. As such, a complex number is a pair of two real numbers and can be
    visualized as a vector that lives in two dimensions. Hence, the geometry and algebra
    of vectors, as discussed in the previous section, can be applied here as well.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
- en: Methods and functions that admit complex numbers as inputs are found in the
    `cmath` module. This module contains mathematical functions for complex numbers.
    The functions there accept integers, floating-point numbers, or complex numbers
    as input arguments.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
- en: 'A *complex conjugate* is defined as the complex number, *z** (also *z̄*), that
    has the same real part as the complex number, *z*, and the opposite imaginary
    part; that is, if *z = x+iy*, then *z* = x -iy*. Note that the product, *zz**,
    is the real number, *x*2*+y*2, which gives us the square of the *modulus* of *z*:'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
- en: '*zz* = z*z = |z|*2'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
- en: 'A complex number is plotted, similar to a vector, on the complex plane (as
    shown in the following diagram). This is the plane that''s formed by the real
    part on the *x* axis and the imaginary part on the *y* axis. The complex conjugate
    is simply a reflection of the vector with respect to the real axis:'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.22: A plot of a complex number'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_05_22.jpg)'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.22: A plot of a complex number'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
- en: A complex number, *z*, can be visualized as a vector with coordinates (x, y).
    Alternatively, we can write it as a vector with polar coordinates (r, φ). The
    complex conjugate, *z** or *z̄*, is a vector the same as *z* but reflected with
    respect to the *x* axis.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
- en: 'A complex number is zero if both its real and complex parts are zero. The following
    operations can be performed on two complex numbers, *z = x+iy* and *w = u+iv*:'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
- en: '**Addition**: *z+w = (x+u) + i(y+v)*'
  id: totrans-519
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Subtraction**: *z-w = (x-u) + i(y-v)*'
  id: totrans-520
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Multiplication**: *z w = (x+iy)(u+iv) = (xu-yv) + i(xv + yu)*'
  id: totrans-521
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Division**: *z/w = (x+iy)/(u+iv) = (ux+vy)+i(uy-xv) / (u2+v2)*'
  id: totrans-522
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Polar Representation and Euler's Formula
  id: totrans-523
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A complex number is easily visualized as a vector on the complex plane. As
    such, it has a magnitude, which is determined by the vector''s size, and an orientation,
    which is determined by the angle, *φ*, that is formed with the *x* (real) axis.
    To determine these two numbers, we need to find the absolute value (or modulus),
    *r*, of *z=x+iy*:'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
- en: '*r = |z| = √x*2*+y*2'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
- en: 'Its angle (also, called the argument, *arg*, or *phase*), *φ*, is as follows:'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
- en: '*φ = arg(z) = arctan(x+iy) = arctan(y/x)*'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
- en: Both of these relations stem from the geometry of the complex vector. The first
    relation is simply the application of the Pythagorean theorem, while the second
    comes from applying the tangent relation to the angle, *φ*.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
- en: 'By examining the graphical representation of the vector (see the preceding
    diagram), we can see the following:'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
- en: '*cos(φ) = x/r and*'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
- en: '*sin(φ) = y/r*'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
- en: Or
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
- en: '*x = r cos(φ) and*'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
- en: '*y = r sin(φ)*'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
- en: 'By substituting these with *z = x+iy*, we get the following:'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
- en: '*z = r (cos(φ) + i sin(φ))*'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
- en: 'We can write some code in Python to find (*r*, *φ*) (the polar coordinates)
    once (*x*, *y*) (the cartesian coordinates) are given and vice versa:'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'The output is as follows:'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'Equivalently, we can use the `polar` method from the `cmath` module:'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'The output is as follows:'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: Note
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
- en: The input (0,0) is not allowed since it leads to division by zero.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, a complex number can be represented by its modulus, *r*, and phase,
    *φ*, instead of its abscissa (*x*, the real part) and ordinate (*y*, the imaginary
    part). The modulus, *r*, is a real, non-negative number and the phase, *φ*, lies
    in the interval [-π,π]: it is *0* and *π* for purely real numbers and *π/2* or
    *-π/2* for purely imaginary numbers. The latter representation is called polar,
    while the former is known as rectangular or Cartesian; they are equivalent. The
    following representation is also possible:'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
- en: '*z = r e*iφ *= r (cos(φ) + i sin(φ))*'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the base of the natural logarithm. This is known as Euler''s formula.
    The special case, *φ=π*, gives us the following:'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
- en: '*e*iπ *+ 1 = 0*'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
- en: This is known as Euler's identity.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
- en: 'The benefit of using Euler''s formula is that complex number multiplication
    and division obtain a simple geometric representation. To multiply (divide) two
    complex numbers, *z*1 and *z*2, we simply multiply (divide) their respective moduli
    and add (subtract) their arguments:'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
- en: '*z*1 ** z*2 *= r e*iφ *= r*1 ** r*2 *e*i(φ1+φ2)'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s implement some mathematical operations with complex numbers in
    Python. We will code the addition, subtraction, multiplication, and division of
    two complex numbers:'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  id: totrans-555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'Now, let''s try these functions for a generic pair of complex numbers, *c1=10+2j/3*
    and *c2=2.9+1j/3*:'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  id: totrans-557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'The output is as follows:'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'We can do the same for a purely real number with a purely imaginary number:'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  id: totrans-561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'The output is as follows:'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  id: totrans-563
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'From the last line, we can easily see that *1/i = -i*, which is consistent
    with the definition of the imaginary unit. The `cmath` library also provides useful
    functions for complex numbers, such as `phase` and `polar`, as well as trigonometric
    functions for complex arguments:'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  id: totrans-565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'The output is as follows:'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  id: totrans-567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: Hence, calculating the modulus, phase, or conjugate of a given complex number
    becomes extremely simple. Note that the last line gives us back the rectangular
    (or Cartesian) form of a complex number, given its modulus and phase.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
- en: Now that we learned how the arithmetic and representation of complex numbers
    work, let's move on and look at an exercise that involves logic and combines what
    we have used and learned about in the previous sections.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 5.08: Conditional Multiplication of Complex Numbers'
  id: totrans-570
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, you will write a function that reads a complex number, `c`,
    and multiplies it by itself if the argument of the complex number is larger than
    zero, takes the square root of `c` if its argument is less than zero, and does
    nothing if the argument equals zero. Plot and discuss your findings:'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
- en: 'Import the necessary libraries and, optionally, suppress any warnings (this
    isn''t necessary but is helpful if you wish to keep the output tidy from warnings
    that depend on the versions of the libraries you''re using):'
  id: totrans-572
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE133]'
  id: totrans-573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'Now, define a function that uses Matplotlib''s `pyplot` function to plot the
    vector of the input complex number, `c`:'
  id: totrans-574
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE134]'
  id: totrans-575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'Now, create a function that reads the input complex number, `c`, plots it by
    calling the function defined previously, and then investigates the different cases,
    depending on the phase of the input. Plot the phases before and after the operation,
    as well as the result, in order to compare the resulting vector with the input
    vector:'
  id: totrans-576
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE135]'
  id: totrans-577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: Note that for negative phases, we take the square root of `c` (using the `math.sqrt()`
    method), whereas for positive phases, we take the square of `c`.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, transform a number that lies on the upper half of the complex plane:'
  id: totrans-579
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE136]'
  id: totrans-580
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'The output is as follows:'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.23: The plot of a number that lies on the upper half of the complex
    plane'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_05_23.jpg)'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.23: The plot of a number that lies on the upper half of the complex
    plane'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, a complex number with a positive argument, *φ* (blue vector), is being
    transformed (or mapped) to a new complex number (red vector) with a larger modulus
    and a new argument that is twice the previous value. This is expected: remember
    Euler''s formula for the polar representation of *c=r e*iφ? It becomes obvious
    that the square, *c*2, is a number with double the original argument, *φ*, and
    modulus, *r*2.'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, transform a number that lies on the lower half of the complex plane:'
  id: totrans-586
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE137]'
  id: totrans-587
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'The output is as follows:'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.24: Plot of a number that lies on the lower half of the complex
    plane'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_05_24.jpg)'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.24: Plot of a number that lies on the lower half of the complex plane'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the square root is calculated. Similar to the first example, the
    newly transformed vector has a modulus that is the square root of the modulus
    of the original vector and an argument that is half of the original one.
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
- en: 'Fun fact: In both cases, the vector has been rotated anti-clockwise.'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
- en: 'Write a `while` iteration that calls the `mult_complex()` function *n* times
    to check what happens if we keep the vectors rotating:'
  id: totrans-595
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE138]'
  id: totrans-596
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'The output is as follows:'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.25: Plot of rotating vectors'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
- en: '](image/B15968_05_25.jpg)'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 5.25: Plot of rotating vectors'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
- en: With that, we've seen how vectors and vector algebra can be used to visualize
    geometric operations. In particular, dividing and multiplying complex numbers
    results in acquiring a geometric representation that can be helpful when dealing
    with large sets of data and visualizations.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
- en: To access the source code for this specific section, please refer to [https://packt.live/31yU8W1.](https://packt.live/31yU8W1
    )
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
- en: You can also run this example online at [https://packt.live/2BXWJOw.](https://packt.live/2BXWJOw
    )
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 5.01: Calculating Your Retirement Plan Using Series'
  id: totrans-605
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In many countries, a retirement plan (also known as 401(k)) is offered by some
    employers. Such plans allow you to contribute directly from your paycheck, so
    they are an easy and effective way to save and invest for retirement. You have
    been tasked with writing some code that calculates and plots your monthly return
    based on the amount and duration of contributions.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
- en: 'A retirement plan accumulates in time, exactly like a geometric series does.
    It is an investment: you save money on a monthly basis in order to collect it
    later, on a monthly basis, with added value or interest. The main *ingredients*
    to calculate the retirement return are your current balance, a monthly contribution,
    the employer match (employer''s contribution), the retirement age, the rate of
    return (the average annual return you expect from your 401(k) investment), life
    expectancy, and any other fees. In a realistic case, *caps* are introduced: the
    employer match (typically between 50% and 100%) cannot be raised by more than
    6% of your annual salary. Similarly, the employee''s contribution cannot be larger
    than a given amount in a year (typically, this is 18 K), regardless of how high
    the salary is.'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to complete this activity:'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
- en: Identify the variables of our problem. These will be the variables of our functions.
    Make sure you read through the activity description carefully and *internalize*
    what is known and what is to be calculated.
  id: totrans-609
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Identify the sequence and write one function that calculates the value of the
    retirement plan at some year, *n*. The function should admit the current balance,
    annual salary, year, *n*, and more as inputs and return a tuple of contribution,
    employer's match, and total retirement value at year *n*.
  id: totrans-610
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Identify the series and write one function that calculates the accumulated value
    of the retirement plan *after n* years. The present function should read the input,
    call the previous function that calculates the value of the plan at each year,
    and sum all the (per year) savings. For visualization purposes, the contributions
    (per year), employer match (per year), and total value (per year) should be returned
    as lists in a tuple.
  id: totrans-611
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the function for a variety of chosen values and ensure it runs properly.
  id: totrans-612
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Plot the results with Matplotlib.
  id: totrans-613
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 672.
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-616
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you have been provided with a general and helpful exposition
    of the most central mathematical concepts in sequences, series, trigonometry,
    vectors, and complex numbers and, more importantly, their implementation in Python
    using concrete and short examples. As a real-life example, we examined a retirement
    plan and the progression of our savings in time. However, numerous other situations
    can be modeled after sequences or series and be studied by applying vectors or
    complex numbers. These concepts and methods are widely used in physics, engineering,
    data science, and more. Linear algebra, that is, the study of vectors, matrices,
    and tensors, heavily relies on understanding the concept of geometry and vectors
    and appears almost everywhere in data science and when studying neural networks.
    Geometry and trigonometry, on the other hand, are explicitly used to model physical
    motion (in video games, for instance) and more advanced concepts in geospatial
    applications. However, having background knowledge of these concepts makes using
    and applying data science methods more concrete and understandable.
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss matrices and how to apply them to solve
    real-world problems. We'll also examine Markov chains, which are used to tie concepts
    regarding probability, matrices, and limits together.
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
- en: NDN74
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
- en: ETB65
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
