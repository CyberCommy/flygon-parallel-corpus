- en: .NET Core Unit Testing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .NET Core单元测试
- en: '**Unit testing** has been one of the most discussed concepts in software development
    in the last few years. Unit testing is not a new concept in software development;
    it has been around for quite a while, since the early days of the Smalltalk programming
    language. Based on the increased advocacy for quality and robust software applications,
    software developers and testers have come to realize the great benefits unit testing
    can offer in terms of software product quality improvement.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**单元测试**是软件开发领域最近几年讨论最多的概念之一。单元测试并不是软件开发中的新概念；它已经存在了相当长的时间，自Smalltalk编程语言的早期。基于对质量和健壮软件应用程序的增加倡导，软件开发人员和测试人员已经意识到单元测试在软件产品质量改进方面所能提供的巨大好处。'
- en: Through unit testing, developers are able to identify errors in code quickly,
    which increases the development team's confidence in the quality of the software
    product being shipped. Unit testing is primarily carried out by programmers and
    tests, and this activity involves the breaking down of the requirements and functionalities
    of an application into units that can be tested separately.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 通过单元测试，开发人员能够快速识别代码中的错误，从而增加开发团队对正在发布的软件产品质量的信心。单元测试主要由程序员和测试人员进行，这项活动涉及将应用程序的要求和功能分解为可以单独测试的单元。
- en: Unit tests are meant to be small and run frequently, especially when changes
    are made to the code, to ensure the working functionalities in a code base are
    not broken. When doing TDD, the unit test must be written before writing the code
    to be tested. The test usually serves as an aid for designing and writing the
    code, and is effectively a documentation for the design and specification of the
    code.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试旨在保持小型并经常运行，特别是在对代码进行更改时，以确保代码库中的工作功能不会出现故障。在进行TDD时，必须在编写要测试的代码之前编写单元测试。测试通常用作设计和编写代码的辅助工具，并且有效地是代码设计和规范的文档。
- en: 'In this chapter, we will explain how to create basic unit tests and prove the
    results of our unit tests with xUnit assertions. This following topics will be
    covered in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将解释如何创建基本单元测试，并使用xUnit断言证明我们的单元测试结果。本章将涵盖以下主题：
- en: The attributes of a good unit test
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 良好单元测试的属性
- en: The current unit testing framework ecosystem for .NET Core and C#
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET Core和C#的当前单元测试框架生态系统
- en: Unit testing considerations for ASP.NET MVC Core
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ASP.NET MVC Core的单元测试考虑因素
- en: Structuring unit tests with xUnit
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用xUnit构建单元测试
- en: Proving unit test results with xUnit assertions
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用xUnit断言证明单元测试结果
- en: The test runners available on both .NET Core and Windows
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET Core和Windows上可用的测试运行器
- en: The attributes of a good unit test
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 良好单元测试的属性
- en: A unit test is a piece of code written to test another code. It is sometimes
    referred to as the lowest-level test because it is used to test code at the lowest
    level of an application. The unit test calls the method or class under test to
    validate and assert assumptions about the logic, function, and behavior of the
    code being tested.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试是编写用于测试另一段代码的代码。有时它被称为最低级别的测试，因为它用于测试应用程序的最低级别的代码。单元测试调用要测试的方法或类来验证和断言有关被测试代码的逻辑、功能和行为的假设。
- en: The main purpose of unit testing is to validate a unit of code under test, to
    ascertain that the piece of code does what it is designed to do and not otherwise.
    Through unit testing, the correctness of a unit of code can be proven, this can
    be achieved only if the unit test is written well. While unit testing will prove
    the correctness and help to discover bugs in code, code quality might not be improved
    if the code being tested is poorly designed and written.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试的主要目的是验证被测试代码单元，以确保代码片段执行其设计用途而不是其他用途。通过单元测试，可以证明代码单元的正确性，只有当单元测试编写得好时才能实现。虽然单元测试将证明正确性并有助于发现代码中的错误，但如果被测试的代码设计和编写不佳，代码质量可能不会得到改善。
- en: When you write your unit tests properly, you can to a certain degree, have confidence
    that your application will behave correctly when shipped. Through the test coverage
    obtainable from test suites, you can have the metrics of tests written for methods,
    classes, and other objects in your code base, and you are provided with meaningful
    information on how frequently they are being run, along with counts of how many
    times the tests pass or fail.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当您正确编写单元测试时，您可以在一定程度上确信您的应用程序在发布时会正确运行。通过测试套件获得的测试覆盖率，您可以获得有关代码库中方法、类和其他对象的测试写入频率的指标，并且您将获得有关测试运行频率以及测试通过或失败次数的有意义信息。
- en: With the available test metrics, every stakeholder involved in software development
    can have access to objective information that can be used to improve the software
    development process. Unit testing, when iteratively done, can add value to the
    code by improving the reliability and quality of the code. This is possible through
    testing the code for errors—the test is run repeatedly many times, a concept known
    as **regression testing**, to locate errors that might occur as the software application
    matures and components that were working earlier break.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 通过可用的测试指标，参与软件开发的每个利益相关者都可以获得客观信息，这些信息可用于改进软件开发过程。迭代进行单元测试可以通过测试代码中的错误来增加代码的价值，从而提高代码的可靠性和质量。这是通过对代码进行错误测试来实现的——测试会多次重复运行，这是一个被称为**回归测试**的概念，以便在软件应用程序成熟并且之前工作的组件出现故障时找到可能发生的错误。
- en: Readable
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可读性
- en: 'This characteristic of unit tests can not be overemphasized. Similar to the
    code under test, unit tests should be easy to read and understand. The coding
    standards and principles are also applicable to tests. Anti-patterns, such as
    magic numbers or constants, should be avoided as they can clutter tests and make
    them difficult to read. Integer `10` in the following test is a magic number,
    as it was directly used. This affects the test readability and clearity:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'There is a good test structuring pattern that can be adopted, it''s widely
    known as the **triple A** or **3A pattern**—`Arrange`, `Act`, and `Assert`—which
    separates the test setup from its verification. You are to ensure that the required
    data input by the test is arranged, followed by the lines of code to act on the
    method under test, and assert that the results from the method under test meet
    the expectation:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: While there is no strict naming convention for tests, you should ensure that
    the name of a test represents a specific business requirement. The test name should
    have the expected input as well as state the expected output, `Test_CheckPasswordLength_ShouldReturnTrue`,
    this is because, besides serving the purpose of testing application-specific functionality,
    unit tests are also a rich source of documentation of the source code.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Unit independence
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A unit test should basically be a unit, it should be designed and written in
    a form that allows it to run independently. The unit under test, in this case
    a method, should have been written to depend subtly on other methods. If possible,
    the data needed by the methods should be taken through the method parameters or
    should be provided within the unit, it should not have to request or set up data
    externally for it to function.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: The unit test should not depend on or be affected by any other tests. When unit
    tests are dependent on each other, if one of the tests fails when run, all other
    dependent tests will also fail. All the needed data by the code under test should
    be provided by the unit test.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to the *Single Responsibility Principle* discussed in [Chapter 2](fc097d14-900c-4069-a503-5ea22795abaf.xhtml),
    *Getting Started with .NET Core*, a unit should have only one responsibility and
    only once concern at any time. The unit should have a single task at any point
    in time to allow it to be testable as a unit. When you have a method that practically
    does more than a single task, it is simply a wrapper for units and should be decomposed
    into the basic units for easy testing:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The issue with the test in this snippet is that there is a lot happening at
    the same time. And if the test fails, there is no specific way to check which
    of the method calls caused the failure. This test can be broken down into different
    tests for clarity and easy maintenance.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Repeatable
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A unit test should be easy to run without having to modify it each time it
    is to run. In essence, a test should be ready to run repeatedly without modification.
    In the following test, the `Test_DeleteLoan_ShouldReturnNull` test method is not
    repeatable, because the test has to be modified each time it is run. To avoid
    this scenario, it is preferable to mock the `loanRepository` object:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Maintainable and runs fast
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unit tests should be written in a manner that allows them to run quickly. The
    test should be easy to implement and any member of a development team should be
    able to run it. Because software applications are dynamic and continue to evolve,
    tests for the code base should be easy to maintain as the underlying code under
    test changes. To have tests that run faster, try to minimize dependencies as much
    as you can.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Oftentimes, most programmers get this aspect of unit testing wrong, they write
    unit tests that have inherent dependencies, which in turn makes the tests slower
    to run. A quick rule of thumb to give you a clue that you are doing something
    wrong with your unit test, is that they are very slow to run. Also, when you have
    unit tests that make calls to backend servers or perform some tedious I/O operations,
    it is an indication of test smells.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Easy to set up, non-trivial, and with good coverage
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unit tests should be easy to set up and decoupled from any direct or external
    dependencies. The external dependencies should be mocked using a suitable mocking
    framework. Appropriate object setup should be done in setup methods or test class
    constructors.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: Avoid redundant codes that can clog the tests and ensure the tests contain only
    codes that are relevant to the methods being tested. Also, tests should be written
    for units or methods. For example, writing tests for class getters and setters
    might be considered too trivial.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, good unit tests should have good code coverage. All execution paths
    in a method under test should be covered and all the tests should have defined
    criteria that can be tested.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing framework ecosystem for .NET Core and C#
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The .NET Core development platform has been designed to fully support testing.
    This can be attributed to the adopted architecture. It makes TDD on the .NET Core
    platform relatively easy and worthwhile.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: There are several unit testing frameworks available for use in .NET and .NET
    Core. The frameworks essentially provide easy and flexible ways of writing and
    executing unit tests directly from your preferred IDEs, code editors, through
    dedicated test runners, or sometimes through the command line.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: There exists a thriving ecosystem of test frameworks and suites on the .NET
    platform. The frameworks contain a variety of adapters that are available for
    use in creating unit test projects and for continuous integration and deployment.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: This ecosystem of frameworks has been inherited by the .NET Core platform. This
    makes practicing TDDs on .NET Core very easy. Visual Studio IDE is open and extensive,
    making it faster and easy to install test plugins and adapters from different
    test frameworks from NuGet for use in test projects.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: There are quite a number of testing frameworks that are free and open source,
    used for various types of tests. The most popular of the frameworks are MSTest,
    NUnit, and xUnit.net.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: .NET Core testing with MSTest
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Microsoft MSTest is the default testing framework that ships with Visual Studio
    and is developed by Microsoft, which originally was part of the .NET framework
    but is also included in .NET Core. The MSTest framework is used to write load,
    functional, UI, and unit tests.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: MSTest can be used as a uniform application platform support as well as in testing
    a wide range of applications—Desktop, Store, **Universal Windows Platform** (**UWP**),
    and ASP.NET Core. MSTest is delivered as a NuGet package.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: 'MSTest-based unit test projects can be added to an existing solution containing
    projects to be tested following the steps of adding a new project to a solution
    in Visual Studio 2017:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Right-click the existing solution in Solution Explorer, select Add and select
    New Project. Or, to create a new test project from scratch, click on the File
    menu, select New, and select Project.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the displayed dialog box, select Visual C#, click the .NET Core option.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select MSTest Test Project (.NET Core) and give a desired name to the project.
    Then click OK:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d5683380-b9e2-453a-a8e8-cfa978ed3e2a.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
- en: 'Alternatively, when creating a new project or adding a new project to an existing
    solution, select the Class Libary (.NET Core) option and add references to MSTest
    from NuGet. Install the following packages to the class library project from NuGet,
    using the NuGet package manager console or GUI option. You can run the following
    command from the NuGet package manager console:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Irrespective of which method was used to create the MSTest test project, Visual
    Studio will automatically create a `UnitTest1` or `Class1.cs` file. You can rename
    the class or delete it to create a new test class, which will be decorated with
    an MSTest `TestClass` attribute, which indicates that the class will contain test
    methods.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: 'The actual test methods will be decorated with the `TestMethod` attribute,
    marking them as tests, which will make the tests runnable by the MSTest test runner.
    MSTest has a rich collection of `Assert` helper classes that can be used to verify
    the expectations of unit tests:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You can run the `Test_GetLoanById_ShouldReturnLoan` test method from the Test
    Explorer window in Visual Studio 2017\. This window can be opened from the `Test`
    menu, select Windows, and select Test Explorer. Right-click on the test and select
    Run Selected Tests:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a243401d-f9c6-4f6d-a09f-e70a5cbcfda9.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
- en: 'You can also run the tests from the console. Open the command prompt window
    and change the directory to the folder containing the test project, or the solution
    folder if you want to run all test projects in the solution. Run the `dotnet test` command.
    The projects will be built, while the available tests are discovered and executed:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d43da412-1305-4b9b-a03a-09e0d22ea6cf.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
- en: .NET Core testing with NUnit
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**NUnit** is a testing framework originally ported from Java''s JUnit and can
    be used to test projects written in all programming languages available on the
    .NET platform. Currently on Version 3, its open source testing framework was released
    under MIT License.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: NUnit testing framework includes an engine and console runners. Additionally,
    it has test runners that are used for testing applications that run on mobile
    devices—**Xamarin Runners**. The NUnit test adapters and generator can essentially
    make testing using Visual Studio IDE seamless and relatively easy.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Testing .NET Core or .NET Standards applications using NUnit requires that the
    NUnit 3 Version of Visual Studio test adapter be used. The NUnit test project
    template needs to be installed in order to be able to create an NUnit test project,
    which is usually done once.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: 'NUnit adapters can be installed into Visual Studio 2017 with these steps:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: Click the Tools menu, then select Extension and Updates
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the Online option and in the search text box, type `nunit` to filter
    to available NUnit adapters
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select NUnit 3 Test Adapter and click Download
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This will download the adapter and install it as a template into Visual Studio
    2017, you have to restart Visual Studio for this to take effect:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9c1256ab-f478-4a5d-8a8c-8b11f2352d06.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
- en: Alternatively, you can install the NUnit 3 Test Adapter directly from NuGet
    each time you want to create a test project.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: 'To add an NUnit test project to your existing solution, follow these steps:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: Right-click the solution in Solution Explorer, select Add, New Project.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the dialog box, select Visual C#, then select the .NET Core option.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select Class Library (.NET Core) then give the desired name to the project.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add `NUnit3TestAdapter` and `NUnit.ConsoleRunner` packages to the project from
    NuGet:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/22d45be3-58b5-45d9-91bc-90fdc32e8332.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
- en: After the project setup is complete, you can write and run unit tests. Similar
    to MSTest, NUnit has attributes that are used to set up test methods and test
    classes.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: The `TestFixture` attribute is used to mark a class as a container for test
    methods. The `Test` attribute is used to decorate test methods and make the methods
    callable from the NUnit test runner.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: 'NUnit has other attributes that are used for some setup and testing purposes.
    The `OneTimeSetup` attribute is used to decorate a method that is called one time
    only before all child tests are run. A similar attribute is `SetUp`, which is
    used to decorate a method that is called before each test is run:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The test can be run from the Test Explorer window, similar to the way it was
    run with the MSTest test project. Also, the test can be run from the command line,
    using `dotnet test`. However, you have to add **Microsoft.NET.Test.Sdk Version
    15.5.0** as reference to the NUnit test project:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8082dc4c-2b2e-4fbb-91c8-3194d14ad38e.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
- en: xUnit.net
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**xUnit.net** is an open source unit testing framework for the .NET platform
    that is used to test projects written in F#, VB.NET, C#, and other .NET-compliant
    programming languages. xUnit.net was written by the inventor of Version 2 of NUnit
    and is licensed under Apache 2.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: xUnit.net can be used to test traditional .NET platform applications, which
    includes console and ASP.NET applications, the UWP Application, mobile device
    applications, and .NET Core applications with ASP.NET Core inclusive.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: Unlike in NUnit or MSTest, where the test class is decorated with `TestFixture`
    and `TestClass` attributes, respectively, the xUnit.net test class does not require
    attribute decoration. The framework automatically detects all test methods in
    all public classes in the test project or assembly.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, the test setup and tear down attributes are not available in xUnit.net,
    a parameterless constructor can be used instead to set up test objects or mock
    dependencies. The test class can implement the `IDisposable` interface and do
    objects or dependencies cleanup in the `Dispose` method:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'xUnit.net supports two major types of tests—facts and theories. **Facts** are
    tests that are always true; they are tests without parameters. **Theories** are
    tests that will only be true when passed a particular set of data; they are essentially
    parameterized tests. `[Fact]` and `[Theory]` attributes are used to decorate facts
    and theories tests, respectively:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `[InlineData]` attribute is used in `TestMethod2` to decorate a theory test
    to supply test data to the test methods to be used during test execution.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: How to configure xUnit.net
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Configuration of xUnit.net comes in two flavors. xUnit.net allows the configuration
    file to be JSON or XML-based. The xUnit.net configuration must be done for each
    assembly under test. The configuration file to be used for xUnit.net is dependent
    on the development platform of the application being tested, though the JSON configuration
    file can be used on all platforms.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: 'To use a JSON configuration file, after creating your test project in Visual
    Studio 2017, you should add a new JSON file to the root folder of the test project
    and name it `xunit.runner.json`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/79a25dcb-05de-4af9-8986-68d0114476bd.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
- en: 'After adding the file to the project, you must instruct Visual Studio to copy
    the `.json` file to the output folder of your project, where it can be located
    by xUnit test runners. To do this, you should follow these steps:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: Right-click the JSON configuration file from Solution Explorer. Select Properties
    from the Menu option, this will display a dialog with title xunit.runner.json
    Property Pages.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'On the Properties Window page, change the option of Copy to Output Directory
    from Never to Copy if newer and click the OK button:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**![](img/ab8daaf8-0d7b-4cc1-94be-e036ec31aa6c.png)**'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: 'This will ensure that the configuration file is always copied to the output
    folder when changes are made. The supported configuration elements in xUnit are
    placed inside a top-level JSON object in the configuration file, as seen in the
    configuration here:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'When a version of Visual Studio that has JSON support is used, it will automatically
    detect the schema based on the configuration file name. Also, context help will
    be made available in Visual Studio IntelliSense while editing the `xunit.runner.json`
    file. The various configuration elements with their acceptable values are explained
    in this table:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '| **Key** | **Values** |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
- en: '| `appDomain` | The `appDomain` configuration element is the `enum` JSON schema
    type, which can take three values to determine whether application domains are
    used—`ifAvailable`, `required`, and `denied`. Application domains are used by
    desktop runners only and will be ignored by non-desktop runners.Default value
    should always be `ifAvailable`, which indicates that the application domain should
    be used if available. When set to `required`, it will require the use of application
    domains, and if set to `denied`, application domains will not be used. |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `appDomain` | `appDomain`配置元素是`enum` JSON模式类型，可以采用三个值来确定是否使用应用程序域——`ifAvailable`、`required`和`denied`。应用程序域仅由桌面运行器使用，并且将被非桌面运行器忽略。默认值应始终为`ifAvailable`，表示如果可用应该使用应用程序域。当设置为`required`时，将需要使用应用程序域，如果设置为`denied`，将不使用应用程序域。
    |'
- en: '| `diagnosticMessages`  | The `diagnosticMessages` configuration element is
    the `boolean` JSON schema type and should be set to `true` if you want to enable
    diagnostic messages during test discovery and execution. |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `diagnosticMessages` | `diagnosticMessages`配置元素是`boolean` JSON模式类型，如果要在测试发现和执行期间启用诊断消息，应将其设置为`true`。
    |'
- en: '| `internalDiagnosticMessages` | The `internalDiagnosticMessages` configuration
    element is the `boolean` JSON schema type and should be set to `true` if you want
    to enable internal diagnostic messages during test discovery and execution. |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `internalDiagnosticMessages` | `internalDiagnosticMessages`配置元素是`boolean`
    JSON模式类型，如果要在测试发现和执行期间启用内部诊断消息，应将其设置为`true`。 |'
- en: '| `longRunningTestSeconds`  | The `longRunningTestSeconds` configuration element
    is the `integer` JSON schema type. You should set this value to a positive integer
    if you want to enable a long-running test; setting the value to `0` disables the
    configuration. You should enable `diagnosticMessages` to get notifications for
    long-running tests. |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `longRunningTestSeconds` | `longRunningTestSeconds`配置元素是`integer` JSON模式类型。如果要启用长时间运行的测试，应将此值设置为正整数；将值设置为`0`会禁用该配置。您应该启用`diagnosticMessages`以获取长时间运行测试的通知。
    |'
- en: '| `maxParallelThreads`  | The `maxParallelThreads` configuration element is
    the `integer` JSON schema type. Set the value to the maximum number of threads
    to be used when parallelizing. Setting the value to `0` will maintain the default
    behavior, which is the number of logical processors on your computer. Setting
    to `-1` implies that you do not wish to set a limit to the number of threads used
    for tests parallelization. |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `maxParallelThreads` | `maxParallelThreads`配置元素是`integer` JSON模式类型。将值设置为要在并行化时使用的最大线程数。将值设置为`0`将保持默认行为，即计算机上的逻辑处理器数量。设置为`-1`意味着您不希望限制用于测试并行化的线程数。
    |'
- en: '| `methodDisplay` | The `methodDisplay` configuration element is the `enum`
    JSON schema type. When this is set to `method`, the display name will be the method
    excluding the class name. Set the value to `classAndMethod`, which is the default
    value, indicating that the default display name will be used, which is the class
    name and method name. |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| `methodDisplay` | `methodDisplay`配置元素是`enum` JSON模式类型。当设置为`method`时，显示名称将是方法，不包括类名。将值设置为`classAndMethod`，这是默认值，表示将使用默认显示名称，即类名和方法名。
    |'
- en: '| `parallelizeAssembly` | The `parallelizeAssembly` configuration element is
    the `boolean` JSON schema type. Setting the value to `true` will make the test
    assembly parallelize with other assemblies. |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| `parallelizeAssembly` | `parallelizeAssembly`配置元素是`boolean` JSON模式类型。将值设置为`true`将使测试程序集与其他程序集并行化。
    |'
- en: '| `parallelizeTestCollections` | The `parallelizeTestCollections` configuration
    element is the `boolean` JSON schema type. Setting the value to true will make
    the tests run in parallel in the assembly, which allows tests in the different
    test collections to be run in parallel. Tests in the same test collection will
    still run sequentially. Setting this to `false` will disable parallelization in
    the test assembly. |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| `parallelizeTestCollections` | `parallelizeTestCollections`配置元素是`boolean`
    JSON模式类型。将值设置为true将使测试在程序集中并行运行，这允许不同测试集中的测试并行运行。同一测试集中的测试仍将按顺序运行。将其设置为`false`将禁用测试程序集中的并行化。
    |'
- en: '| `preEnumerateTheories` | The `preEnumerateTheories` configuration element
    is the `boolean` JSON schema type and should be set to `true` to pre-enumerate
    theories to ensure there is an individual test case for each theory data row.
    When this is set to `false`, a single test case for each theory is returned without
    pre-enumerating the data ahead of time. |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| `preEnumerateTheories` | `preEnumerateTheories`配置元素是`boolean` JSON模式类型，如果要预先枚举理论以确保每个理论数据行都有一个单独的测试用例，应将其设置为`true`。当设置为`false`时，将返回每个理论的单个测试用例，而不会提前枚举数据。
    |'
- en: '| `shadowCopy` | The `shadowCopy` configuration element is the `boolean` JSON
    schema type and should be set to `true` if you want to enable shadow copying when
    running tests in different application domains. This configuration element is
    ignored if the tests are being run without application domains. |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| `shadowCopy` | `shadowCopy`配置元素是`boolean` JSON模式类型，如果要在不同应用程序域中运行测试时启用影子复制，应将其设置为`true`。如果测试在没有应用程序域的情况下运行，则将忽略此配置元素。
    |'
- en: The other configuration file option that can be used for desktop and PCL test
    projects in xUnit.net is the XML configuration. You should add an `App.Config`
    file to your test project if it does not already have one.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: xUnit.net用于桌面和PCL测试项目的另一个配置文件选项是XML配置。如果测试项目尚未具有`App.Config`文件，则应将其添加到测试项目中。
- en: 'In the `App.Config` file, under the `appSettings` section, you can add the
    configuration elements with their values. When using the XML configuration file,
    xUnit has to be appended to the configuration elements explained in the preceding
    table. For example, the `appDomain` element in the JSON configuration file will
    be written as `xunit.appDomain`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在`App.Config`文件的`appSettings`部分下，您可以添加配置元素及其值。在使用XML配置文件时，必须在前面表中解释的配置元素后面添加xUnit。例如，JSON配置文件中的`appDomain`元素将写为`xunit.appDomain`：
- en: '[PRE10]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: xUnit.net test runners
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In xUnit.net, there are two actors responsible for running unit tests written
    using the framework—xUnit.net runner and the test framework. A **test runner**
    is the program that can also be a third-party plugin that searches for tests in
    assemblies and activates the tests discovered. The xUnit.net test runner depends
    on the `xunit.runner.utility` library to discover and execute tests.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: The test framework is the code with the implementation of test discovery and
    execution. The test framework links the discovered test against the `xunit.core.dll`
    and `xunit.execution.dll` libraries. The libraries live alongside the unit tests.
    `xunit.abstractions.dll` is another useful library of xUnit.net that contains
    the abstractions that the test runners and tests frameworks use in communicating.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: Test parallelism
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Test parallelization** was introduced in xUnit.net as of Version 2\. This
    feature allows developers to run multiple tests in parallel. Test parallelization
    is needed because large code bases usually have several thousand tests running,
    which need to be run multiple times.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: These code bases have this huge number of tests because there needs to be assurance
    that the code for the features works and is not broken. They also take advantage
    of the super-fast computing resources now available to run parallel tests, thanks
    to advancements in computer hardware technology.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: You can write tests that use parallelization and take advantage of the cores
    available on the computer, thereby making tests run faster, or let xUnit.net run
    multiple tests in parallel. The latter is usually preferred, which ensures tests
    can be run at the speed of the computer running them. In xUnit.net, test parallelism
    can be at the framework level, where the framework support is running multiple
    tests in the same assembly in parallel, or parallelism in test runners, where
    a runner can run multiple test assemblies in parallel.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: 'Tests are run in parallel using test collections. Each test class is a test
    collection, and tests within a test collection will not be run in parallel against
    each other. For example, if the tests in `LoanCalculatorTest` are run, the test
    runner will run the two tests in the class sequentially because they belong to
    the same test collection:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Tests in separate test classes can run in parallel because they belong to separate
    test collections. Let''s modify `LoanCalculatorTest` and take the `TestCalculateRate`
    test method into a separate test class, `RateCalculatorTest`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If we run the tests, the total time spent running both `TestCalculateLoan`
    and `TestCalculateRate` will be reduced because they are in different test classes,
    which puts them in different test collections. Also, from the Test Explorer window,
    you can observe the running icon used to mark both tests, to indicate they are
    both running:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2b7a8086-5a87-443e-8d60-bb4c47a776ed.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
- en: 'Tests in separate test classes can be configured to not run in parallel. This
    is done by decorating the classes using the `Collection` attribute with the same
    name. If the `Collection` attribute is added to `LoanCalculatorTest` and `RateCalculatorTest`:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Tests in the `LoanCalculatorTest` and `RateCalculatorTest` classes will not
    be run in parallel because the classes belong to the same test collection based
    on the attribute decoration.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing consideration for ASP.NET MVC Core
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The ASP.NET Core MVC development paradigm breaks a web application down into
    three distinct parts—the `Model`, `View`, and `Controller`, as per the tenets
    of the MVC architectural pattern. The **Model-View-Controller** (**MVC**) pattern
    facilitates the creation of web applications that are easy to test and maintain,
    and have a clear separation of concerns and boundaries.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: The MVC pattern provides a clear separation between presentation logic and business
    logic, with easy scalability and maintainability. It was originally designed for
    use with desktop applications but has since gained much use and popularity with
    web applications.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: MVC 模式提供了清晰的演示逻辑和业务逻辑之间的分离，易于扩展和维护。它最初是为桌面应用程序设计的，但后来在 Web 应用程序中得到了广泛的使用和流行。
- en: The ASP.NET Core MVC projects can be tested in the same manner that you test
    other types of .NET Core projects. ASP.NET Core supports the unit testing of controller
    classes, razor pages, page models, business logic, and the application data access
    layer. To build robust MVC applications, the various application components have
    to be tested in isolation and later tested when integrated.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core MVC 项目可以以与测试其他类型的 .NET Core 项目相同的方式进行测试。ASP.NET Core 支持对控制器类、razor
    页面、页面模型、业务逻辑和应用程序数据访问层进行单元测试。为了构建健壮的 MVC 应用程序，各种应用程序组件必须在隔离环境中进行测试，并在集成后进行测试。
- en: Unit testing controllers
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制器单元测试
- en: The ASP.NET Core MVC Controller classes handle users interactions, which translates
    to the request on the browser. The controller gets the appropriate model and selects
    a view to render that displays the user interface. The controller reads a user's
    input data, events, and interactions from the view, and passes it to the model.
    The controller validates the input it receives from the view and then performs
    the business operation that modifies the state of the data model.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core MVC 控制器类处理用户交互，这转化为浏览器上的请求。控制器获取适当的模型并选择要呈现的视图，以显示用户界面。控制器从视图中读取用户的输入数据、事件和交互，并将其传递给模型。控制器验证来自视图的输入，然后执行修改数据模型状态的业务操作。
- en: The `Controller` classes should be lightweight and contain the minimal logic
    needed to render the view based on a user's interactions to allow easy testing
    and maintenance. The controller should verify the state of the model and ascertain
    the validity, call the appropriate code that performs business logic validation
    and manages data persistence, and later display the appropriate view to the user.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`Controller` 类应该轻量级，并包含渲染视图所需的最小逻辑，以便进行简单的测试和维护。控制器应该验证模型的状态并确定有效性，调用执行业务逻辑验证和管理数据持久性的适当代码，然后向用户显示适当的视图。'
- en: When unit testing the `Controller` class, the main aim is to test the controller
    action method's behavior in isolation, this should be done without muddling up
    the test with other important MVC constructs such as model binding, routing, filters,
    and other custom controller utility objects. These other constructs, if custom-written,
    should be unit tested differently and later tested as a whole with the controller
    using integration testing.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在对 `Controller` 类进行单元测试时，主要目的是在隔离环境中测试控制器动作方法的行为，这应该在不混淆测试与其他重要的 MVC 构造（如模型绑定、路由、过滤器和其他自定义控制器实用对象）的情况下进行。这些其他构造（如果是自定义编写的）应该以不同的方式进行单元测试，并在集成测试中与控制器一起进行整体测试。
- en: 'Review the `HomeController` class of the `LoanApplication` project, the `Controller`
    class contains the four action methods that are added when the project is created
    in Visual Studio:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 审查 `LoanApplication` 项目的 `HomeController` 类，`Controller` 类包含在 Visual Studio
    中创建项目时添加的四个动作方法：
- en: '[PRE14]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `HomeController` class currently contains action methods with the basic
    logic of returning views. In order to unit test the MVC project, a new xUnit.net
    test project should be added to the solution, to keep the tests separate from
    the actual project code. Add the `HomeControllerTest` test class to the newly
    created test project.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`HomeController` 类当前包含具有返回视图的基本逻辑的动作方法。为了对 MVC 项目进行单元测试，应向解决方案添加一个新的 xUnit.net
    测试项目，以便将测试与实际项目代码分开。将 `HomeControllerTest` 测试类添加到新创建的测试项目中。'
- en: 'The tests methods to be written in will verify that the `viewResult` objects
    are returned by both the `Index` and `About` action methods of the `HomeController`
    class:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 将要编写的测试方法将验证 `HomeController` 类的 `Index` 和 `About` 动作方法返回的 `viewResult` 对象：
- en: '[PRE15]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The tests written in the preceding controller test are basic and very simplistic.
    To demonstrate controller unit testing further, the `Controller` class code can
    be updated to support dependency injection, which will allow the methods to be
    tested through object mocking. Also, by using `AddModelError` to add errors, the
    invalid model state can be tested:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的控制器测试中编写的测试是基本的和非常简单的。为了进一步演示控制器单元测试，可以更新 `Controller` 类代码以支持依赖注入，这将允许通过对象模拟来测试方法。此外，通过使用
    `AddModelError` 来添加错误，可以测试无效的模型状态：
- en: '[PRE16]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`ILoanRepository` was injected into `HomeController` through the class constructor,
    and in the test class, `ILoanRepository` will be mocked using the Moq Framework.
    In the `TestIndex` test method, the mock object is set up with the list of `LoanType`
    required by the `Index` method in the `HomeController` class:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`ILoanRepository` 通过类构造函数注入到 `HomeController` 中，在测试类中，`ILoanRepository` 将使用
    Moq 框架进行模拟。在 `TestIndex` 测试方法中，使用 `LoanType` 列表设置了 `HomeController` 类中 `Index`
    方法所需的模拟对象：'
- en: '[PRE17]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Unit testing razor pages
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: razor 页面单元测试
- en: In ASP.NET MVC, views are the components that are used for rendering a web application's
    user interface. The view presents information contained in the model in a suitable
    and easy-to-understand output format, such as HTML, XML, XHTML, or JSON. The view
    generates output to the user based on the update performed on the model.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ASP.NET MVC 中，视图是用于呈现 Web 应用程序用户界面的组件。视图以适当且易于理解的输出格式（如 HTML、XML、XHTML 或 JSON）呈现模型中包含的信息。视图根据对模型执行的更新向用户生成输出。
- en: '**Razor pages** make coding features on pages relatively easier. A razor page
    is similar to a razor view, with the addition of the `@page` directive. The `@page`
    directive must be the first directive in the page, it automatically converts the
    file into an MVC action handling requests without going through the controller.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: In ASP.NET Core, razor pages can be tested to ensure they work correctly in
    isolation and as an integrated application. Razor page testing can involve testing
    the data access layer codes, page components, and page models.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet shows a unit test that verifies that a page model
    redirects correctly:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Structuring unit tests with xUnit
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Similar to the manner in which an application's code base is structured to allow
    easy readability and for effective source code maintenance, unit tests should
    be structured. This is to facilitate easy maintenance and quick running of tests
    using the test runners from Visual Studio IDE.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: A **testcase** is a test class containing test methods. It is usually common
    to have one test class per class under test. Another common practice of structuring
    tests among developers is to have a nested class for each method being tested
    or to have one base test class for the class under test and one subclass for every
    tested method. Also, there is the test class per feature approach, where all the
    test methods that collectively validate a feature of an application are grouped
    in a testcase.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: These test-structuring approaches promote the DRY principle and essentially
    faciliate code reusability while writing tests. There is no single approach that
    is best suited for all purposes, choosing a particular approach should be based
    on circumstances around the application development and come after effective communication
    with team members.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: 'Going the one-class-per-test or one-class-per-method route depends on individual
    preference and sometimes convention or agreement when working in a team, with
    each approach having it pros and cons. When you use the one-class-per-test approach,
    you have tests for methods in the class being tested all in the test class, as
    opposed to the one-class-per-method approach, where you have one test in the class
    as they pertain to the method being tested, though sometimes it is possible to
    have more than one test in the class as long as they are relevant to the method:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Two test classes, `IndexMethod` and `AboutMethod`, will be created. Both classes
    will extend the `HomeControllerTest` class and will have a method each, following
    the unit testing approach of one method per test class:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'It is important to note that giving test cases and test methods meaningful
    and descriptive names can go a long way in making them meaningful and easy to
    understand. It is appropriate that the name of the test methods should contain
    the names of the method or feature being tested. Optionally, it can be further
    descriptive to add the expected result in the name of the test method, prefixed
    by `Should`:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: xUnit.net shared test context
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The test context setup is done in the test class constructor, since the test
    setup is not applicable in xUnit. For every test, xUnit creates a new instance
    of the test class, which implies that the codes in the class constructor are run
    for each test.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: 'Oftentimes, it is desirable for unit test classes to share a test context because
    it can be expensive to create and clean up test contexts. xUnit offers three approaches
    to achieve this:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '**Constructor and dispose**: Sharing setup or cleanup code without having to
    share the object instances'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Class fixtures**: Sharing object instances across tests in a single class'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Collection fixtures**: Sharing object instances across multiple test classes'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You should use constructor and dispose when you want a fresh test context for
    every test in a test class. In the following code, the context object will be
    constructed and disposed for every test method in the `LoanModuleTest` class:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The class fixtures approach is used when you intend to create a test context
    that will be shared among all the tests in the class and will be cleaned up when
    the all the tests have finished running. To use the class fixture, you have to
    create a fixture class with a constructor that will contain the codes for the
    objects to be shared. The test class should implement `IClassFixture<>` and you
    should add the fixture class as a constructor argument to the test class:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `LoanModuleTest` class in the following snippet implements `IClassFixture`
    with `EFCoreFixture` passed as the parameter. `EFCoreFixture` is injected into
    the test class constructor:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Similar to class fixtures, collection fixtures is used to create a test context
    that is shared among tests, but this time the tests can be in several classes.
    The test context creation will be done once for all the test classes and the cleanup,
    if implemented, will be executed after all the tests in the test classes have
    finished running.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the collection fixture:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Create a fixture class with a constructor similar to the way you created it
    with class fixture.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can implement `IDisposable` on the fixture class if there should be a code
    cleanup, which will be put in the `Dispose` method:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'A definition class will be created that will have no code and have `ICollectionFixture<>`
    added, since it''s purpose is for defining the collection definition. Decorate
    the class with the `[CollectionDefinition]` attribute and give a name for the
    test collection:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Add the `[Collection]` attribute to the test classes and use the name earlier
    used for the collection definition class attribute.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a constructor with the fixture as argument if the test classes will require
    instances of the fixture:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Live unit testing with Visual Studio 2017 Enterprise
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Visual Studio 2017, Enterprise edition, has a live unit testing feature that
    automatically runs tests that are affected by the changes you make to your code
    base in real time. The tests are run in the background and the results are presented
    in Visual Studio. This is a cool IDE feature that provides you with instant feedback
    on the changes you are making to a project's source code.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: 'Live unit testing in Visual Studio currently supports NUnit, MSTest, and xUnit.
    Live unit testing can be configured from the Tools menu—select Options from the
    top-level menu, and select Live Unit Testing in the left pane of the Options dialog.
    The Live Unit Testing configuration options available can be tweaked from the
    Options dialog:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '**![](img/3326490e-3774-439d-a37a-544084bbfe44.png)**'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: 'Live Unit Testing can be enabled from the Test menu by selecting Live Unit
    Testing, and selecting Start:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7eae808b-dd25-42d2-93e2-13286fdbdbf1.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
- en: 'After Live Unit Testing is enabled, other available options on the Live Unit
    Testing menu will be displayed. In addition to Start, there will be Pause, Stop,
    and Reset Clean. The menus functions are described here:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: 'Pause: This temporarily suspends Live Unit Testing, which preservs unit testing
    data collected but hides the test coverage `visualization.rk` to catch up with
    all the edits that have been made while it was paused, and updates the glyphs
    appropriately'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Stop: Stops Live Unit Testing and deletes all collected unit test data'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Reset Clean: Restarts Live Unit Testing by stopping it and starting it again'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Options: Opens the Options dialog to configure Live Unit Testing'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the following screenshot, the coverage visualization can be seen when Live
    Unit Testing is enabled. Every line of code is updated and decorated with green,
    red, and blue to indicate that the line of code is covered by a passing test,
    a failing test, or not covered by any test:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '**![](img/8b8669dc-1d2d-43d3-9227-2662e2819334.png)**'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: Proving unit test results with xUnit.net assertions
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'xUnit.net assertions verify the behavior of methods under tests. An assertion
    validates the condition that is expected to be true for the results being expected.
    When an assertion fails, the current execution of the test is terminated and an
    exception is thrown. The following table explains the assertions available in
    xUnit.net:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '| **Assertion** | **Description** |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
- en: '| `Equal` | Validates that an object equals another object |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
- en: '| `NotEqual` | Validates that an object does not equal another object |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
- en: '| `Same` | Verifies that two objects are of the same type |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
- en: '| `NotSame` | Verifies that two objects are not of the same type |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
- en: '| `Contains` | Is an overloaded assertion/method and verifies that a stringcontains
    a given substring or a collection contains an object |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
- en: '| `DoesNotContain` | Is an overloaded assertion/method and verifies that a
    stringdoes not contain a given substring or a collection does not contain an object
    |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
- en: '| `DoesNotThrow` | Verifies that the code does not throw exceptions |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
- en: '| `InRange` | Verifies that a value is in a given inclusive range |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
- en: '| `IsAssignableFrom` | Verifies that an object is of a given type or derived
    type |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
- en: '| `Empty` | Verifies that a collection is empty |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
- en: '| `NotEmpty` | Verifies that a collection is not empty |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
- en: '| `False` | Verifies that an expression is false |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
- en: '| `True` | Verifies that an expression is true |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
- en: '| `IsType<T>` | Verifies that an object is of a given type |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
- en: '| `IsNotType<T>` | Verifies that an object is not of a given type |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
- en: '| `Null` | Verifies that an object reference is null |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
- en: '| `NotNull` | Verifies that an object reference is not null |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
- en: '| `NotInRange` | Verifies that a value is not in a given inclusive range |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
- en: '| `Throws<T>` | Verifies that the code throws an exact exception |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
- en: 'The following snippet uses some of the xUnit.net assertion methods described
    in the preceding table. The `Assertions` unit test method shows how assertion
    methods can be used when doing unit testing in xUnit.net, to verify methods behaviors:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The test runners available on both .NET Core and Windows
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The .NET platform has a large ecosystem of test runners that can be used with
    the popular test platforms NUnit, MSTest, and xUnit. The test frameworks have
    test runners shipped with them that facilitate the smooth running of the tests.
    Additionally, there are also several open source and commercial test runners that
    can be used with the available test platforms, one of which is ReSharper.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: ReSharper
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**ReSharper** is a Visual Studio extension for .NET Developers, developed by
    JetBrains. Its test runner is by far the most popular among the test runners available
    on the .NET platform, the ReSharper productivity tool provides other functionalities
    that enhance programmers'' productivity. It has a unit test runner that can assist
    you in running and debugging unit tests based on xUnit.net, NUnit, MSTest, and
    couple of other test frameworks.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: 'ReShaper can detect tests written on the .NET and .NET Core platforms for the
    available test frameworks. ReSharper adds icons to the editor, which can be clicked
    to Debug or Run tests:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1a7fe848-c074-4287-b547-2afc8e084063.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
- en: Unit tests are run by ReSharper using the *Unit Test Sessions* window. **ReSharper's
    Unit Test Sessions** window allows you to run any number of unit test sessions
    in parallel, independently of each other. But only one session can be run at a
    time when running in the debugging mode.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: 'You can filter the tests using the unit test tree, which gives you a structure
    of your tests. It shows which tests failed, passed, or have not been run. Also,
    by double-clicking on a test, you can directly navigate to the source:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c1435338-2fa0-4ef3-8cd4-7d648e60e84a.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
- en: Summary
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unit tests can improve the quality of your code and the overall quality of your
    application. The tests can also serve as a rich source of commentary and documentation
    for the source code. Creating high-quality unit tests is a skill that should be
    consciously learned following the guidelines discussed in this chapter.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, attributes of a good unit test were discussed. We also extensively
    discussed unit testing procedures using the testing features available in the
    xUnit.net framework. The live unit testing feature in Visual Studio 2017 was explained
    and, using the xUnit.net `Fact` attribute, assertions were used to create basic
    unit tests.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore data-driven unit tests, another important
    aspect of unit testing, which facilitates using data from different sources, such
    as from database or CSV files, to execute unit tests. This is made possible through
    the xUnit.net `Theory` attribute.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
