- en: .NET Core Unit Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Unit testing** has been one of the most discussed concepts in software development
    in the last few years. Unit testing is not a new concept in software development;
    it has been around for quite a while, since the early days of the Smalltalk programming
    language. Based on the increased advocacy for quality and robust software applications,
    software developers and testers have come to realize the great benefits unit testing
    can offer in terms of software product quality improvement.'
  prefs: []
  type: TYPE_NORMAL
- en: Through unit testing, developers are able to identify errors in code quickly,
    which increases the development team's confidence in the quality of the software
    product being shipped. Unit testing is primarily carried out by programmers and
    tests, and this activity involves the breaking down of the requirements and functionalities
    of an application into units that can be tested separately.
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests are meant to be small and run frequently, especially when changes
    are made to the code, to ensure the working functionalities in a code base are
    not broken. When doing TDD, the unit test must be written before writing the code
    to be tested. The test usually serves as an aid for designing and writing the
    code, and is effectively a documentation for the design and specification of the
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will explain how to create basic unit tests and prove the
    results of our unit tests with xUnit assertions. This following topics will be
    covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: The attributes of a good unit test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The current unit testing framework ecosystem for .NET Core and C#
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit testing considerations for ASP.NET MVC Core
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Structuring unit tests with xUnit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Proving unit test results with xUnit assertions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The test runners available on both .NET Core and Windows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The attributes of a good unit test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A unit test is a piece of code written to test another code. It is sometimes
    referred to as the lowest-level test because it is used to test code at the lowest
    level of an application. The unit test calls the method or class under test to
    validate and assert assumptions about the logic, function, and behavior of the
    code being tested.
  prefs: []
  type: TYPE_NORMAL
- en: The main purpose of unit testing is to validate a unit of code under test, to
    ascertain that the piece of code does what it is designed to do and not otherwise.
    Through unit testing, the correctness of a unit of code can be proven, this can
    be achieved only if the unit test is written well. While unit testing will prove
    the correctness and help to discover bugs in code, code quality might not be improved
    if the code being tested is poorly designed and written.
  prefs: []
  type: TYPE_NORMAL
- en: When you write your unit tests properly, you can to a certain degree, have confidence
    that your application will behave correctly when shipped. Through the test coverage
    obtainable from test suites, you can have the metrics of tests written for methods,
    classes, and other objects in your code base, and you are provided with meaningful
    information on how frequently they are being run, along with counts of how many
    times the tests pass or fail.
  prefs: []
  type: TYPE_NORMAL
- en: With the available test metrics, every stakeholder involved in software development
    can have access to objective information that can be used to improve the software
    development process. Unit testing, when iteratively done, can add value to the
    code by improving the reliability and quality of the code. This is possible through
    testing the code for errors—the test is run repeatedly many times, a concept known
    as **regression testing**, to locate errors that might occur as the software application
    matures and components that were working earlier break.
  prefs: []
  type: TYPE_NORMAL
- en: Readable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This characteristic of unit tests can not be overemphasized. Similar to the
    code under test, unit tests should be easy to read and understand. The coding
    standards and principles are also applicable to tests. Anti-patterns, such as
    magic numbers or constants, should be avoided as they can clutter tests and make
    them difficult to read. Integer `10` in the following test is a magic number,
    as it was directly used. This affects the test readability and clearity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'There is a good test structuring pattern that can be adopted, it''s widely
    known as the **triple A** or **3A pattern**—`Arrange`, `Act`, and `Assert`—which
    separates the test setup from its verification. You are to ensure that the required
    data input by the test is arranged, followed by the lines of code to act on the
    method under test, and assert that the results from the method under test meet
    the expectation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: While there is no strict naming convention for tests, you should ensure that
    the name of a test represents a specific business requirement. The test name should
    have the expected input as well as state the expected output, `Test_CheckPasswordLength_ShouldReturnTrue`,
    this is because, besides serving the purpose of testing application-specific functionality,
    unit tests are also a rich source of documentation of the source code.
  prefs: []
  type: TYPE_NORMAL
- en: Unit independence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A unit test should basically be a unit, it should be designed and written in
    a form that allows it to run independently. The unit under test, in this case
    a method, should have been written to depend subtly on other methods. If possible,
    the data needed by the methods should be taken through the method parameters or
    should be provided within the unit, it should not have to request or set up data
    externally for it to function.
  prefs: []
  type: TYPE_NORMAL
- en: The unit test should not depend on or be affected by any other tests. When unit
    tests are dependent on each other, if one of the tests fails when run, all other
    dependent tests will also fail. All the needed data by the code under test should
    be provided by the unit test.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to the *Single Responsibility Principle* discussed in [Chapter 2](fc097d14-900c-4069-a503-5ea22795abaf.xhtml),
    *Getting Started with .NET Core*, a unit should have only one responsibility and
    only once concern at any time. The unit should have a single task at any point
    in time to allow it to be testable as a unit. When you have a method that practically
    does more than a single task, it is simply a wrapper for units and should be decomposed
    into the basic units for easy testing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The issue with the test in this snippet is that there is a lot happening at
    the same time. And if the test fails, there is no specific way to check which
    of the method calls caused the failure. This test can be broken down into different
    tests for clarity and easy maintenance.
  prefs: []
  type: TYPE_NORMAL
- en: Repeatable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A unit test should be easy to run without having to modify it each time it
    is to run. In essence, a test should be ready to run repeatedly without modification.
    In the following test, the `Test_DeleteLoan_ShouldReturnNull` test method is not
    repeatable, because the test has to be modified each time it is run. To avoid
    this scenario, it is preferable to mock the `loanRepository` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Maintainable and runs fast
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unit tests should be written in a manner that allows them to run quickly. The
    test should be easy to implement and any member of a development team should be
    able to run it. Because software applications are dynamic and continue to evolve,
    tests for the code base should be easy to maintain as the underlying code under
    test changes. To have tests that run faster, try to minimize dependencies as much
    as you can.
  prefs: []
  type: TYPE_NORMAL
- en: Oftentimes, most programmers get this aspect of unit testing wrong, they write
    unit tests that have inherent dependencies, which in turn makes the tests slower
    to run. A quick rule of thumb to give you a clue that you are doing something
    wrong with your unit test, is that they are very slow to run. Also, when you have
    unit tests that make calls to backend servers or perform some tedious I/O operations,
    it is an indication of test smells.
  prefs: []
  type: TYPE_NORMAL
- en: Easy to set up, non-trivial, and with good coverage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unit tests should be easy to set up and decoupled from any direct or external
    dependencies. The external dependencies should be mocked using a suitable mocking
    framework. Appropriate object setup should be done in setup methods or test class
    constructors.
  prefs: []
  type: TYPE_NORMAL
- en: Avoid redundant codes that can clog the tests and ensure the tests contain only
    codes that are relevant to the methods being tested. Also, tests should be written
    for units or methods. For example, writing tests for class getters and setters
    might be considered too trivial.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, good unit tests should have good code coverage. All execution paths
    in a method under test should be covered and all the tests should have defined
    criteria that can be tested.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing framework ecosystem for .NET Core and C#
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The .NET Core development platform has been designed to fully support testing.
    This can be attributed to the adopted architecture. It makes TDD on the .NET Core
    platform relatively easy and worthwhile.
  prefs: []
  type: TYPE_NORMAL
- en: There are several unit testing frameworks available for use in .NET and .NET
    Core. The frameworks essentially provide easy and flexible ways of writing and
    executing unit tests directly from your preferred IDEs, code editors, through
    dedicated test runners, or sometimes through the command line.
  prefs: []
  type: TYPE_NORMAL
- en: There exists a thriving ecosystem of test frameworks and suites on the .NET
    platform. The frameworks contain a variety of adapters that are available for
    use in creating unit test projects and for continuous integration and deployment.
  prefs: []
  type: TYPE_NORMAL
- en: This ecosystem of frameworks has been inherited by the .NET Core platform. This
    makes practicing TDDs on .NET Core very easy. Visual Studio IDE is open and extensive,
    making it faster and easy to install test plugins and adapters from different
    test frameworks from NuGet for use in test projects.
  prefs: []
  type: TYPE_NORMAL
- en: There are quite a number of testing frameworks that are free and open source,
    used for various types of tests. The most popular of the frameworks are MSTest,
    NUnit, and xUnit.net.
  prefs: []
  type: TYPE_NORMAL
- en: .NET Core testing with MSTest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Microsoft MSTest is the default testing framework that ships with Visual Studio
    and is developed by Microsoft, which originally was part of the .NET framework
    but is also included in .NET Core. The MSTest framework is used to write load,
    functional, UI, and unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: MSTest can be used as a uniform application platform support as well as in testing
    a wide range of applications—Desktop, Store, **Universal Windows Platform** (**UWP**),
    and ASP.NET Core. MSTest is delivered as a NuGet package.
  prefs: []
  type: TYPE_NORMAL
- en: 'MSTest-based unit test projects can be added to an existing solution containing
    projects to be tested following the steps of adding a new project to a solution
    in Visual Studio 2017:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click the existing solution in Solution Explorer, select Add and select
    New Project. Or, to create a new test project from scratch, click on the File
    menu, select New, and select Project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the displayed dialog box, select Visual C#, click the .NET Core option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select MSTest Test Project (.NET Core) and give a desired name to the project.
    Then click OK:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d5683380-b9e2-453a-a8e8-cfa978ed3e2a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Alternatively, when creating a new project or adding a new project to an existing
    solution, select the Class Libary (.NET Core) option and add references to MSTest
    from NuGet. Install the following packages to the class library project from NuGet,
    using the NuGet package manager console or GUI option. You can run the following
    command from the NuGet package manager console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Irrespective of which method was used to create the MSTest test project, Visual
    Studio will automatically create a `UnitTest1` or `Class1.cs` file. You can rename
    the class or delete it to create a new test class, which will be decorated with
    an MSTest `TestClass` attribute, which indicates that the class will contain test
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'The actual test methods will be decorated with the `TestMethod` attribute,
    marking them as tests, which will make the tests runnable by the MSTest test runner.
    MSTest has a rich collection of `Assert` helper classes that can be used to verify
    the expectations of unit tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'You can run the `Test_GetLoanById_ShouldReturnLoan` test method from the Test
    Explorer window in Visual Studio 2017\. This window can be opened from the `Test`
    menu, select Windows, and select Test Explorer. Right-click on the test and select
    Run Selected Tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a243401d-f9c6-4f6d-a09f-e70a5cbcfda9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can also run the tests from the console. Open the command prompt window
    and change the directory to the folder containing the test project, or the solution
    folder if you want to run all test projects in the solution. Run the `dotnet test` command.
    The projects will be built, while the available tests are discovered and executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d43da412-1305-4b9b-a03a-09e0d22ea6cf.png)'
  prefs: []
  type: TYPE_IMG
- en: .NET Core testing with NUnit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**NUnit** is a testing framework originally ported from Java''s JUnit and can
    be used to test projects written in all programming languages available on the
    .NET platform. Currently on Version 3, its open source testing framework was released
    under MIT License.'
  prefs: []
  type: TYPE_NORMAL
- en: NUnit testing framework includes an engine and console runners. Additionally,
    it has test runners that are used for testing applications that run on mobile
    devices—**Xamarin Runners**. The NUnit test adapters and generator can essentially
    make testing using Visual Studio IDE seamless and relatively easy.
  prefs: []
  type: TYPE_NORMAL
- en: Testing .NET Core or .NET Standards applications using NUnit requires that the
    NUnit 3 Version of Visual Studio test adapter be used. The NUnit test project
    template needs to be installed in order to be able to create an NUnit test project,
    which is usually done once.
  prefs: []
  type: TYPE_NORMAL
- en: 'NUnit adapters can be installed into Visual Studio 2017 with these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Click the Tools menu, then select Extension and Updates
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the Online option and in the search text box, type `nunit` to filter
    to available NUnit adapters
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select NUnit 3 Test Adapter and click Download
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This will download the adapter and install it as a template into Visual Studio
    2017, you have to restart Visual Studio for this to take effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9c1256ab-f478-4a5d-8a8c-8b11f2352d06.png)'
  prefs: []
  type: TYPE_IMG
- en: Alternatively, you can install the NUnit 3 Test Adapter directly from NuGet
    each time you want to create a test project.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add an NUnit test project to your existing solution, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click the solution in Solution Explorer, select Add, New Project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the dialog box, select Visual C#, then select the .NET Core option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select Class Library (.NET Core) then give the desired name to the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add `NUnit3TestAdapter` and `NUnit.ConsoleRunner` packages to the project from
    NuGet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/22d45be3-58b5-45d9-91bc-90fdc32e8332.png)'
  prefs: []
  type: TYPE_IMG
- en: After the project setup is complete, you can write and run unit tests. Similar
    to MSTest, NUnit has attributes that are used to set up test methods and test
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: The `TestFixture` attribute is used to mark a class as a container for test
    methods. The `Test` attribute is used to decorate test methods and make the methods
    callable from the NUnit test runner.
  prefs: []
  type: TYPE_NORMAL
- en: 'NUnit has other attributes that are used for some setup and testing purposes.
    The `OneTimeSetup` attribute is used to decorate a method that is called one time
    only before all child tests are run. A similar attribute is `SetUp`, which is
    used to decorate a method that is called before each test is run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The test can be run from the Test Explorer window, similar to the way it was
    run with the MSTest test project. Also, the test can be run from the command line,
    using `dotnet test`. However, you have to add **Microsoft.NET.Test.Sdk Version
    15.5.0** as reference to the NUnit test project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8082dc4c-2b2e-4fbb-91c8-3194d14ad38e.png)'
  prefs: []
  type: TYPE_IMG
- en: xUnit.net
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**xUnit.net** is an open source unit testing framework for the .NET platform
    that is used to test projects written in F#, VB.NET, C#, and other .NET-compliant
    programming languages. xUnit.net was written by the inventor of Version 2 of NUnit
    and is licensed under Apache 2.'
  prefs: []
  type: TYPE_NORMAL
- en: xUnit.net can be used to test traditional .NET platform applications, which
    includes console and ASP.NET applications, the UWP Application, mobile device
    applications, and .NET Core applications with ASP.NET Core inclusive.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike in NUnit or MSTest, where the test class is decorated with `TestFixture`
    and `TestClass` attributes, respectively, the xUnit.net test class does not require
    attribute decoration. The framework automatically detects all test methods in
    all public classes in the test project or assembly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, the test setup and tear down attributes are not available in xUnit.net,
    a parameterless constructor can be used instead to set up test objects or mock
    dependencies. The test class can implement the `IDisposable` interface and do
    objects or dependencies cleanup in the `Dispose` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'xUnit.net supports two major types of tests—facts and theories. **Facts** are
    tests that are always true; they are tests without parameters. **Theories** are
    tests that will only be true when passed a particular set of data; they are essentially
    parameterized tests. `[Fact]` and `[Theory]` attributes are used to decorate facts
    and theories tests, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `[InlineData]` attribute is used in `TestMethod2` to decorate a theory test
    to supply test data to the test methods to be used during test execution.
  prefs: []
  type: TYPE_NORMAL
- en: How to configure xUnit.net
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Configuration of xUnit.net comes in two flavors. xUnit.net allows the configuration
    file to be JSON or XML-based. The xUnit.net configuration must be done for each
    assembly under test. The configuration file to be used for xUnit.net is dependent
    on the development platform of the application being tested, though the JSON configuration
    file can be used on all platforms.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use a JSON configuration file, after creating your test project in Visual
    Studio 2017, you should add a new JSON file to the root folder of the test project
    and name it `xunit.runner.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/79a25dcb-05de-4af9-8986-68d0114476bd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After adding the file to the project, you must instruct Visual Studio to copy
    the `.json` file to the output folder of your project, where it can be located
    by xUnit test runners. To do this, you should follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click the JSON configuration file from Solution Explorer. Select Properties
    from the Menu option, this will display a dialog with title xunit.runner.json
    Property Pages.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'On the Properties Window page, change the option of Copy to Output Directory
    from Never to Copy if newer and click the OK button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**![](img/ab8daaf8-0d7b-4cc1-94be-e036ec31aa6c.png)**'
  prefs: []
  type: TYPE_NORMAL
- en: 'This will ensure that the configuration file is always copied to the output
    folder when changes are made. The supported configuration elements in xUnit are
    placed inside a top-level JSON object in the configuration file, as seen in the
    configuration here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'When a version of Visual Studio that has JSON support is used, it will automatically
    detect the schema based on the configuration file name. Also, context help will
    be made available in Visual Studio IntelliSense while editing the `xunit.runner.json`
    file. The various configuration elements with their acceptable values are explained
    in this table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Key** | **Values** |'
  prefs: []
  type: TYPE_TB
- en: '| `appDomain` | The `appDomain` configuration element is the `enum` JSON schema
    type, which can take three values to determine whether application domains are
    used—`ifAvailable`, `required`, and `denied`. Application domains are used by
    desktop runners only and will be ignored by non-desktop runners.Default value
    should always be `ifAvailable`, which indicates that the application domain should
    be used if available. When set to `required`, it will require the use of application
    domains, and if set to `denied`, application domains will not be used. |'
  prefs: []
  type: TYPE_TB
- en: '| `diagnosticMessages`  | The `diagnosticMessages` configuration element is
    the `boolean` JSON schema type and should be set to `true` if you want to enable
    diagnostic messages during test discovery and execution. |'
  prefs: []
  type: TYPE_TB
- en: '| `internalDiagnosticMessages` | The `internalDiagnosticMessages` configuration
    element is the `boolean` JSON schema type and should be set to `true` if you want
    to enable internal diagnostic messages during test discovery and execution. |'
  prefs: []
  type: TYPE_TB
- en: '| `longRunningTestSeconds`  | The `longRunningTestSeconds` configuration element
    is the `integer` JSON schema type. You should set this value to a positive integer
    if you want to enable a long-running test; setting the value to `0` disables the
    configuration. You should enable `diagnosticMessages` to get notifications for
    long-running tests. |'
  prefs: []
  type: TYPE_TB
- en: '| `maxParallelThreads`  | The `maxParallelThreads` configuration element is
    the `integer` JSON schema type. Set the value to the maximum number of threads
    to be used when parallelizing. Setting the value to `0` will maintain the default
    behavior, which is the number of logical processors on your computer. Setting
    to `-1` implies that you do not wish to set a limit to the number of threads used
    for tests parallelization. |'
  prefs: []
  type: TYPE_TB
- en: '| `methodDisplay` | The `methodDisplay` configuration element is the `enum`
    JSON schema type. When this is set to `method`, the display name will be the method
    excluding the class name. Set the value to `classAndMethod`, which is the default
    value, indicating that the default display name will be used, which is the class
    name and method name. |'
  prefs: []
  type: TYPE_TB
- en: '| `parallelizeAssembly` | The `parallelizeAssembly` configuration element is
    the `boolean` JSON schema type. Setting the value to `true` will make the test
    assembly parallelize with other assemblies. |'
  prefs: []
  type: TYPE_TB
- en: '| `parallelizeTestCollections` | The `parallelizeTestCollections` configuration
    element is the `boolean` JSON schema type. Setting the value to true will make
    the tests run in parallel in the assembly, which allows tests in the different
    test collections to be run in parallel. Tests in the same test collection will
    still run sequentially. Setting this to `false` will disable parallelization in
    the test assembly. |'
  prefs: []
  type: TYPE_TB
- en: '| `preEnumerateTheories` | The `preEnumerateTheories` configuration element
    is the `boolean` JSON schema type and should be set to `true` to pre-enumerate
    theories to ensure there is an individual test case for each theory data row.
    When this is set to `false`, a single test case for each theory is returned without
    pre-enumerating the data ahead of time. |'
  prefs: []
  type: TYPE_TB
- en: '| `shadowCopy` | The `shadowCopy` configuration element is the `boolean` JSON
    schema type and should be set to `true` if you want to enable shadow copying when
    running tests in different application domains. This configuration element is
    ignored if the tests are being run without application domains. |'
  prefs: []
  type: TYPE_TB
- en: The other configuration file option that can be used for desktop and PCL test
    projects in xUnit.net is the XML configuration. You should add an `App.Config`
    file to your test project if it does not already have one.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `App.Config` file, under the `appSettings` section, you can add the
    configuration elements with their values. When using the XML configuration file,
    xUnit has to be appended to the configuration elements explained in the preceding
    table. For example, the `appDomain` element in the JSON configuration file will
    be written as `xunit.appDomain`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: xUnit.net test runners
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In xUnit.net, there are two actors responsible for running unit tests written
    using the framework—xUnit.net runner and the test framework. A **test runner**
    is the program that can also be a third-party plugin that searches for tests in
    assemblies and activates the tests discovered. The xUnit.net test runner depends
    on the `xunit.runner.utility` library to discover and execute tests.
  prefs: []
  type: TYPE_NORMAL
- en: The test framework is the code with the implementation of test discovery and
    execution. The test framework links the discovered test against the `xunit.core.dll`
    and `xunit.execution.dll` libraries. The libraries live alongside the unit tests.
    `xunit.abstractions.dll` is another useful library of xUnit.net that contains
    the abstractions that the test runners and tests frameworks use in communicating.
  prefs: []
  type: TYPE_NORMAL
- en: Test parallelism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Test parallelization** was introduced in xUnit.net as of Version 2\. This
    feature allows developers to run multiple tests in parallel. Test parallelization
    is needed because large code bases usually have several thousand tests running,
    which need to be run multiple times.'
  prefs: []
  type: TYPE_NORMAL
- en: These code bases have this huge number of tests because there needs to be assurance
    that the code for the features works and is not broken. They also take advantage
    of the super-fast computing resources now available to run parallel tests, thanks
    to advancements in computer hardware technology.
  prefs: []
  type: TYPE_NORMAL
- en: You can write tests that use parallelization and take advantage of the cores
    available on the computer, thereby making tests run faster, or let xUnit.net run
    multiple tests in parallel. The latter is usually preferred, which ensures tests
    can be run at the speed of the computer running them. In xUnit.net, test parallelism
    can be at the framework level, where the framework support is running multiple
    tests in the same assembly in parallel, or parallelism in test runners, where
    a runner can run multiple test assemblies in parallel.
  prefs: []
  type: TYPE_NORMAL
- en: 'Tests are run in parallel using test collections. Each test class is a test
    collection, and tests within a test collection will not be run in parallel against
    each other. For example, if the tests in `LoanCalculatorTest` are run, the test
    runner will run the two tests in the class sequentially because they belong to
    the same test collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Tests in separate test classes can run in parallel because they belong to separate
    test collections. Let''s modify `LoanCalculatorTest` and take the `TestCalculateRate`
    test method into a separate test class, `RateCalculatorTest`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run the tests, the total time spent running both `TestCalculateLoan`
    and `TestCalculateRate` will be reduced because they are in different test classes,
    which puts them in different test collections. Also, from the Test Explorer window,
    you can observe the running icon used to mark both tests, to indicate they are
    both running:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2b7a8086-5a87-443e-8d60-bb4c47a776ed.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Tests in separate test classes can be configured to not run in parallel. This
    is done by decorating the classes using the `Collection` attribute with the same
    name. If the `Collection` attribute is added to `LoanCalculatorTest` and `RateCalculatorTest`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Tests in the `LoanCalculatorTest` and `RateCalculatorTest` classes will not
    be run in parallel because the classes belong to the same test collection based
    on the attribute decoration.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing consideration for ASP.NET MVC Core
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The ASP.NET Core MVC development paradigm breaks a web application down into
    three distinct parts—the `Model`, `View`, and `Controller`, as per the tenets
    of the MVC architectural pattern. The **Model-View-Controller** (**MVC**) pattern
    facilitates the creation of web applications that are easy to test and maintain,
    and have a clear separation of concerns and boundaries.
  prefs: []
  type: TYPE_NORMAL
- en: The MVC pattern provides a clear separation between presentation logic and business
    logic, with easy scalability and maintainability. It was originally designed for
    use with desktop applications but has since gained much use and popularity with
    web applications.
  prefs: []
  type: TYPE_NORMAL
- en: The ASP.NET Core MVC projects can be tested in the same manner that you test
    other types of .NET Core projects. ASP.NET Core supports the unit testing of controller
    classes, razor pages, page models, business logic, and the application data access
    layer. To build robust MVC applications, the various application components have
    to be tested in isolation and later tested when integrated.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing controllers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The ASP.NET Core MVC Controller classes handle users interactions, which translates
    to the request on the browser. The controller gets the appropriate model and selects
    a view to render that displays the user interface. The controller reads a user's
    input data, events, and interactions from the view, and passes it to the model.
    The controller validates the input it receives from the view and then performs
    the business operation that modifies the state of the data model.
  prefs: []
  type: TYPE_NORMAL
- en: The `Controller` classes should be lightweight and contain the minimal logic
    needed to render the view based on a user's interactions to allow easy testing
    and maintenance. The controller should verify the state of the model and ascertain
    the validity, call the appropriate code that performs business logic validation
    and manages data persistence, and later display the appropriate view to the user.
  prefs: []
  type: TYPE_NORMAL
- en: When unit testing the `Controller` class, the main aim is to test the controller
    action method's behavior in isolation, this should be done without muddling up
    the test with other important MVC constructs such as model binding, routing, filters,
    and other custom controller utility objects. These other constructs, if custom-written,
    should be unit tested differently and later tested as a whole with the controller
    using integration testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Review the `HomeController` class of the `LoanApplication` project, the `Controller`
    class contains the four action methods that are added when the project is created
    in Visual Studio:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `HomeController` class currently contains action methods with the basic
    logic of returning views. In order to unit test the MVC project, a new xUnit.net
    test project should be added to the solution, to keep the tests separate from
    the actual project code. Add the `HomeControllerTest` test class to the newly
    created test project.
  prefs: []
  type: TYPE_NORMAL
- en: 'The tests methods to be written in will verify that the `viewResult` objects
    are returned by both the `Index` and `About` action methods of the `HomeController`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The tests written in the preceding controller test are basic and very simplistic.
    To demonstrate controller unit testing further, the `Controller` class code can
    be updated to support dependency injection, which will allow the methods to be
    tested through object mocking. Also, by using `AddModelError` to add errors, the
    invalid model state can be tested:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '`ILoanRepository` was injected into `HomeController` through the class constructor,
    and in the test class, `ILoanRepository` will be mocked using the Moq Framework.
    In the `TestIndex` test method, the mock object is set up with the list of `LoanType`
    required by the `Index` method in the `HomeController` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Unit testing razor pages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In ASP.NET MVC, views are the components that are used for rendering a web application's
    user interface. The view presents information contained in the model in a suitable
    and easy-to-understand output format, such as HTML, XML, XHTML, or JSON. The view
    generates output to the user based on the update performed on the model.
  prefs: []
  type: TYPE_NORMAL
- en: '**Razor pages** make coding features on pages relatively easier. A razor page
    is similar to a razor view, with the addition of the `@page` directive. The `@page`
    directive must be the first directive in the page, it automatically converts the
    file into an MVC action handling requests without going through the controller.'
  prefs: []
  type: TYPE_NORMAL
- en: In ASP.NET Core, razor pages can be tested to ensure they work correctly in
    isolation and as an integrated application. Razor page testing can involve testing
    the data access layer codes, page components, and page models.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet shows a unit test that verifies that a page model
    redirects correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Structuring unit tests with xUnit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Similar to the manner in which an application's code base is structured to allow
    easy readability and for effective source code maintenance, unit tests should
    be structured. This is to facilitate easy maintenance and quick running of tests
    using the test runners from Visual Studio IDE.
  prefs: []
  type: TYPE_NORMAL
- en: A **testcase** is a test class containing test methods. It is usually common
    to have one test class per class under test. Another common practice of structuring
    tests among developers is to have a nested class for each method being tested
    or to have one base test class for the class under test and one subclass for every
    tested method. Also, there is the test class per feature approach, where all the
    test methods that collectively validate a feature of an application are grouped
    in a testcase.
  prefs: []
  type: TYPE_NORMAL
- en: These test-structuring approaches promote the DRY principle and essentially
    faciliate code reusability while writing tests. There is no single approach that
    is best suited for all purposes, choosing a particular approach should be based
    on circumstances around the application development and come after effective communication
    with team members.
  prefs: []
  type: TYPE_NORMAL
- en: 'Going the one-class-per-test or one-class-per-method route depends on individual
    preference and sometimes convention or agreement when working in a team, with
    each approach having it pros and cons. When you use the one-class-per-test approach,
    you have tests for methods in the class being tested all in the test class, as
    opposed to the one-class-per-method approach, where you have one test in the class
    as they pertain to the method being tested, though sometimes it is possible to
    have more than one test in the class as long as they are relevant to the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Two test classes, `IndexMethod` and `AboutMethod`, will be created. Both classes
    will extend the `HomeControllerTest` class and will have a method each, following
    the unit testing approach of one method per test class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'It is important to note that giving test cases and test methods meaningful
    and descriptive names can go a long way in making them meaningful and easy to
    understand. It is appropriate that the name of the test methods should contain
    the names of the method or feature being tested. Optionally, it can be further
    descriptive to add the expected result in the name of the test method, prefixed
    by `Should`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: xUnit.net shared test context
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The test context setup is done in the test class constructor, since the test
    setup is not applicable in xUnit. For every test, xUnit creates a new instance
    of the test class, which implies that the codes in the class constructor are run
    for each test.
  prefs: []
  type: TYPE_NORMAL
- en: 'Oftentimes, it is desirable for unit test classes to share a test context because
    it can be expensive to create and clean up test contexts. xUnit offers three approaches
    to achieve this:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Constructor and dispose**: Sharing setup or cleanup code without having to
    share the object instances'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Class fixtures**: Sharing object instances across tests in a single class'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Collection fixtures**: Sharing object instances across multiple test classes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You should use constructor and dispose when you want a fresh test context for
    every test in a test class. In the following code, the context object will be
    constructed and disposed for every test method in the `LoanModuleTest` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The class fixtures approach is used when you intend to create a test context
    that will be shared among all the tests in the class and will be cleaned up when
    the all the tests have finished running. To use the class fixture, you have to
    create a fixture class with a constructor that will contain the codes for the
    objects to be shared. The test class should implement `IClassFixture<>` and you
    should add the fixture class as a constructor argument to the test class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The `LoanModuleTest` class in the following snippet implements `IClassFixture`
    with `EFCoreFixture` passed as the parameter. `EFCoreFixture` is injected into
    the test class constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Similar to class fixtures, collection fixtures is used to create a test context
    that is shared among tests, but this time the tests can be in several classes.
    The test context creation will be done once for all the test classes and the cleanup,
    if implemented, will be executed after all the tests in the test classes have
    finished running.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the collection fixture:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a fixture class with a constructor similar to the way you created it
    with class fixture.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can implement `IDisposable` on the fixture class if there should be a code
    cleanup, which will be put in the `Dispose` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'A definition class will be created that will have no code and have `ICollectionFixture<>`
    added, since it''s purpose is for defining the collection definition. Decorate
    the class with the `[CollectionDefinition]` attribute and give a name for the
    test collection:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Add the `[Collection]` attribute to the test classes and use the name earlier
    used for the collection definition class attribute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a constructor with the fixture as argument if the test classes will require
    instances of the fixture:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Live unit testing with Visual Studio 2017 Enterprise
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Visual Studio 2017, Enterprise edition, has a live unit testing feature that
    automatically runs tests that are affected by the changes you make to your code
    base in real time. The tests are run in the background and the results are presented
    in Visual Studio. This is a cool IDE feature that provides you with instant feedback
    on the changes you are making to a project's source code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Live unit testing in Visual Studio currently supports NUnit, MSTest, and xUnit.
    Live unit testing can be configured from the Tools menu—select Options from the
    top-level menu, and select Live Unit Testing in the left pane of the Options dialog.
    The Live Unit Testing configuration options available can be tweaked from the
    Options dialog:'
  prefs: []
  type: TYPE_NORMAL
- en: '**![](img/3326490e-3774-439d-a37a-544084bbfe44.png)**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Live Unit Testing can be enabled from the Test menu by selecting Live Unit
    Testing, and selecting Start:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7eae808b-dd25-42d2-93e2-13286fdbdbf1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After Live Unit Testing is enabled, other available options on the Live Unit
    Testing menu will be displayed. In addition to Start, there will be Pause, Stop,
    and Reset Clean. The menus functions are described here:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pause: This temporarily suspends Live Unit Testing, which preservs unit testing
    data collected but hides the test coverage `visualization.rk` to catch up with
    all the edits that have been made while it was paused, and updates the glyphs
    appropriately'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Stop: Stops Live Unit Testing and deletes all collected unit test data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Reset Clean: Restarts Live Unit Testing by stopping it and starting it again'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Options: Opens the Options dialog to configure Live Unit Testing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the following screenshot, the coverage visualization can be seen when Live
    Unit Testing is enabled. Every line of code is updated and decorated with green,
    red, and blue to indicate that the line of code is covered by a passing test,
    a failing test, or not covered by any test:'
  prefs: []
  type: TYPE_NORMAL
- en: '**![](img/8b8669dc-1d2d-43d3-9227-2662e2819334.png)**'
  prefs: []
  type: TYPE_NORMAL
- en: Proving unit test results with xUnit.net assertions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'xUnit.net assertions verify the behavior of methods under tests. An assertion
    validates the condition that is expected to be true for the results being expected.
    When an assertion fails, the current execution of the test is terminated and an
    exception is thrown. The following table explains the assertions available in
    xUnit.net:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Assertion** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Equal` | Validates that an object equals another object |'
  prefs: []
  type: TYPE_TB
- en: '| `NotEqual` | Validates that an object does not equal another object |'
  prefs: []
  type: TYPE_TB
- en: '| `Same` | Verifies that two objects are of the same type |'
  prefs: []
  type: TYPE_TB
- en: '| `NotSame` | Verifies that two objects are not of the same type |'
  prefs: []
  type: TYPE_TB
- en: '| `Contains` | Is an overloaded assertion/method and verifies that a stringcontains
    a given substring or a collection contains an object |'
  prefs: []
  type: TYPE_TB
- en: '| `DoesNotContain` | Is an overloaded assertion/method and verifies that a
    stringdoes not contain a given substring or a collection does not contain an object
    |'
  prefs: []
  type: TYPE_TB
- en: '| `DoesNotThrow` | Verifies that the code does not throw exceptions |'
  prefs: []
  type: TYPE_TB
- en: '| `InRange` | Verifies that a value is in a given inclusive range |'
  prefs: []
  type: TYPE_TB
- en: '| `IsAssignableFrom` | Verifies that an object is of a given type or derived
    type |'
  prefs: []
  type: TYPE_TB
- en: '| `Empty` | Verifies that a collection is empty |'
  prefs: []
  type: TYPE_TB
- en: '| `NotEmpty` | Verifies that a collection is not empty |'
  prefs: []
  type: TYPE_TB
- en: '| `False` | Verifies that an expression is false |'
  prefs: []
  type: TYPE_TB
- en: '| `True` | Verifies that an expression is true |'
  prefs: []
  type: TYPE_TB
- en: '| `IsType<T>` | Verifies that an object is of a given type |'
  prefs: []
  type: TYPE_TB
- en: '| `IsNotType<T>` | Verifies that an object is not of a given type |'
  prefs: []
  type: TYPE_TB
- en: '| `Null` | Verifies that an object reference is null |'
  prefs: []
  type: TYPE_TB
- en: '| `NotNull` | Verifies that an object reference is not null |'
  prefs: []
  type: TYPE_TB
- en: '| `NotInRange` | Verifies that a value is not in a given inclusive range |'
  prefs: []
  type: TYPE_TB
- en: '| `Throws<T>` | Verifies that the code throws an exact exception |'
  prefs: []
  type: TYPE_TB
- en: 'The following snippet uses some of the xUnit.net assertion methods described
    in the preceding table. The `Assertions` unit test method shows how assertion
    methods can be used when doing unit testing in xUnit.net, to verify methods behaviors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The test runners available on both .NET Core and Windows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The .NET platform has a large ecosystem of test runners that can be used with
    the popular test platforms NUnit, MSTest, and xUnit. The test frameworks have
    test runners shipped with them that facilitate the smooth running of the tests.
    Additionally, there are also several open source and commercial test runners that
    can be used with the available test platforms, one of which is ReSharper.
  prefs: []
  type: TYPE_NORMAL
- en: ReSharper
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**ReSharper** is a Visual Studio extension for .NET Developers, developed by
    JetBrains. Its test runner is by far the most popular among the test runners available
    on the .NET platform, the ReSharper productivity tool provides other functionalities
    that enhance programmers'' productivity. It has a unit test runner that can assist
    you in running and debugging unit tests based on xUnit.net, NUnit, MSTest, and
    couple of other test frameworks.'
  prefs: []
  type: TYPE_NORMAL
- en: 'ReShaper can detect tests written on the .NET and .NET Core platforms for the
    available test frameworks. ReSharper adds icons to the editor, which can be clicked
    to Debug or Run tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1a7fe848-c074-4287-b547-2afc8e084063.png)'
  prefs: []
  type: TYPE_IMG
- en: Unit tests are run by ReSharper using the *Unit Test Sessions* window. **ReSharper's
    Unit Test Sessions** window allows you to run any number of unit test sessions
    in parallel, independently of each other. But only one session can be run at a
    time when running in the debugging mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can filter the tests using the unit test tree, which gives you a structure
    of your tests. It shows which tests failed, passed, or have not been run. Also,
    by double-clicking on a test, you can directly navigate to the source:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c1435338-2fa0-4ef3-8cd4-7d648e60e84a.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unit tests can improve the quality of your code and the overall quality of your
    application. The tests can also serve as a rich source of commentary and documentation
    for the source code. Creating high-quality unit tests is a skill that should be
    consciously learned following the guidelines discussed in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, attributes of a good unit test were discussed. We also extensively
    discussed unit testing procedures using the testing features available in the
    xUnit.net framework. The live unit testing feature in Visual Studio 2017 was explained
    and, using the xUnit.net `Fact` attribute, assertions were used to create basic
    unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore data-driven unit tests, another important
    aspect of unit testing, which facilitates using data from different sources, such
    as from database or CSV files, to execute unit tests. This is made possible through
    the xUnit.net `Theory` attribute.
  prefs: []
  type: TYPE_NORMAL
