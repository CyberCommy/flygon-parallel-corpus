- en: Honeypot – Building Traps for Attackers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 5](acbc308f-dc4c-40e4-8bf4-d17a38233226.xhtml), *Wireless Pentesting*,
    you saw the various network attacks and how to prevent them. In this chapter,
    you will see some proactive approaches. In [Chapter 2](https://cdp.packtpub.com/python_penetration_testing_essentials__second_edition/wp-admin/post.php?post=52&action=edit),
    *Scanning Pentesting*, you learned about IP scanning using ping sweep and port
    scanning by using the TCP connect scan. But what happens when the ping-sweep and
    port-scanning codes give you fake targets? You would try to exploit the fake targets.
    The machine, which is set up to act as a decoy to lure attackers, records the maneuvers
    of the attacker. After seeing all the tricks and attacks, the admin can build
    a new strategy to harden the network. In this chapter, we will use Python code
    to accomplish the tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn about the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Fake ARP reply
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fake ping reply
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fake port-scanning reply
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fake OS-signature reply to nmap
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fake web server reply
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ARP protocol comes under the TCP/IP layer 1, Network Access Layer.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will be required to have Python 2.7.x installed on a system. Finally, to
    use the Git repository of this book, the user needs to install Git.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code files of this chapter can be found on GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Python-Penetration-Testing-Essentials-Second-Edition/tree/master/Chapter06](https://github.com/PacktPublishing/Python-Penetration-Testing-Essentials-Second-Edition/tree/master/Chapter06)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the code in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://goo.gl/jbgbBU](https://goo.gl/jbgbBU)'
  prefs: []
  type: TYPE_NORMAL
- en: Fake ARP reply
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will learn how to send a fake ARP reply. The fake ARP reply
    program is made for the fake ping reply because when the attacker sends the ping
    request to a particular IP, the attacker machine first sends an ARP request for
    the MAC address.
  prefs: []
  type: TYPE_NORMAL
- en: 'When an attacker is on the subnet of the honeypot or outside the subnet, a fake
    reply will be sent by the honeypot. Let''s see the topology diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8cf458f9-5822-4a0e-8c19-08ddcc9fbbfb.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'I have used three machines: Debian running honeypot codes, RHEL, as a gateway,
    and Kali Linux, as the attacker machine.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see the fake reply code. The code name is `arp_reply.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following modules will be used in the code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following code, two sockets have been created. One for the receiver
    and one for sending the reply packet. A global queue, `Q`, is created as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The following function receives the incoming frames. The `arp_l = struct.unpack("!2s2sss2s6s4s6s4s",arp_h)` code
    unpacks the ARP packets and the `if arp_l[4] == ''\x00\x01'':` syntax only broadcasts
    ARP packets. The `Q.put([eth,arp_l])` syntax puts the packets in the global queue, `Q`,
    as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The following function get the ARP packets from global queue. The function
    takes the MAC (current machine MAC) from the command-line argument, which is provided
    by the user. After forming Ethernet and ARP packets, the `mysocket_s.send(target_packet)` syntax
    sends the packet as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The following piece of code creates two threads that run the receiver and sender
    functions in parallel:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Before running the code, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command disables the built-in TCP/IP reply, because now our program
    will send the reply.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run the code by using the following command in the Debian machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In my machine, I''ve given it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now the `arp_reply` code is running. Now we have to run the fake code that would
    give the fake ping reply.
  prefs: []
  type: TYPE_NORMAL
- en: Fake ping reply
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you will learn how to send fake ping reply packets. In the
    fake ping reply code, I have not used any libraries.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s understand the code. The code name is `icmp_reply.py`. In order to run
    the code, you need to install the `ping` module from [https://pypi.python.org/pypi/ping/0.2](https://pypi.python.org/pypi/ping/0.2):'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following modules have been used in the code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code defines a queue, `Q`, and two sockets. One socket will be
    used to receive packets and the other will be used to send packet:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The following piece of code will be used to calculate the checksum of the ICMP
    reply packets. The code is very complicated:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The following function is used to calculate the checksum of the IPv4 packets:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The following function is responsible for making the IPv4 header for the ICMP
    reply packet:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The following function makes an ICMP reply packet. In the `ipv4_creator` and `icmp_creator`
    functions, I used different approaches to add fields. You can use whatever approach
    you like. In the `IPv4_creator` function, I used `ipv4_new_header = field1+ip_id+field2+''40''.decode(''hex'')+protocol+check_sum.decode(''hex'')+ip2+ip1`
    to add fields, and in `icmp_creator`, I used `struct.pack` to form the packets:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The following function creates the Ethernet header:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code receives the incoming request packet. Just for simplicity,
    I took 20 bytes for the IPv4 header:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The following function sends the ICMP reply packets:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The following piece of code two threads are created, which run the receiver
    and sender functions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that the coding part is complete, run `code icmp_reply.py`. Please make
    sure `arp_reply` is running. To test the code, just ping the different IPs from
    Kali Linux, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b725f338-2b23-45ab-a67a-4de33a8af68e.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The preceding output shows that the code is working fine.  Let''s test with
    the `ping_sweep_send_rec.py` code from [Chapter 2](b36d9bb9-7532-496b-a791-1b8aa69da5ea.xhtml),
    *Scanning Pentesting*. See the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f7077bea-933b-4cb2-826f-ed4f224546dd.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We are getting fake replies for 100 IPs. Our next aim is to give fake replies
    to the transport layer.
  prefs: []
  type: TYPE_NORMAL
- en: Fake port-scanning reply
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will look at how to give a fake reply at the TCP layer.
    The program will give fake replies to open ports. For this code, we are going
    to use the scapy library because the TCP header is very complicated to make. The
    program name is `tcp_trap.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following library and module:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'A raw socket has been created to receive incoming packets as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The following function receives the incoming TCP/IP packets. A lot of lines
    have already been discussed in [Chapter 3](4cbd4179-2d24-454b-b279-bcdae27210e2.xhtml),
    *Sniffing and Penetration Testing*. The  if (`D_port==445` or `D_port==135` or
    `D_port==80`): syntax shows that we are only interested in ports  `445`, `135`,
    and `80`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The following function sends the TCP SYN, ACK-flag-enabled response for ports
    `445` and `135`, and for port `80` RST, ACK flags are sent:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The following piece of code indicates the creation of threads, one to handle
    the receiver function and three to handle the sender function:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Due to scapy, the library code has become very short. Now run the `tcp_trap.py` code.
    Make sure the `arp_reply.py` and `icmp_reply.py` codes are also being run.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the attacker, the machine runs the `nmap`; see the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/705a9bfd-da56-4d7d-ac71-fcc9c8b8b5cb.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding output, we have used `nmap` and `portscanner_15.py` ([Chapter
    2](https://cdp.packtpub.com/python_penetration_testing_essentials__second_edition/wp-admin/post.php?post=52&action=edit),
    *Scanning Pentesting*). Both `nmap` and the Python code use the three-way handshake
    process. The output shows that ports `135` and `445` are open.
  prefs: []
  type: TYPE_NORMAL
- en: Fake OS-signature reply to nmap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we are going to create a fake OS signature. By using the following
    `nmap`, we can identify the OS of the victim machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '`nmap -O <ip-address>`: The `nmap` sends seven TCP/IP-crafted packets and evaluates
    the response with its own OS signature databases. For more details, you can read
    the web page at [https://nmap.org/misc/defeat-nmap-osdetect.html](https://nmap.org/misc/defeat-nmap-osdetect.html).'
  prefs: []
  type: TYPE_NORMAL
- en: The `nmap` needs at least one open and one closed port to identify the OS. Again,
    we are going to use all the previous codes. The ports `445` and `135` acts as
    open ports and `80` act as a closed port.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run `nmap` as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5dbde29f-8ac4-45ca-905a-89e97e228e46.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It is giving a different OS, not Debian. You can make the code more complicated
    by learning the `nmap` OS detection algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Fake web server reply
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you will learn how to create a fake web server signature. This
    is the application layer code. This section's code has no relation to the previous
    code. In order to get the server signature or banner grabbing, I am going to use
    the ID Servetool.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see the `fake_webserver.py` code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following modules in the program. The `logger1` module is used to create
    a log file. You will see the code of `logger1` later:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Look at the following piece of code carefully. The `fakewebserver ` class inherits
    the `BaseHTTPRequestHandler` class. The `send_response` method is overriding the
    method of the `BaseHTTPRequestHandler` class because we are sending our custom
    message as `self.send_header(''Server'', "mohit``raj")`. The `log_date_time_string` and
    `send_header` methods and the `client_address` instance variable are inherited
    from the `BaseHTTPRequestHandler` class. Here I am sending the `mohit raj` server
    name as:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The following method sends the header and response code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The following method gets invoked when a `GET` request comes:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The following method gets invoked when a `HEAD` request comes:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is used for an incoming `POST` request:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The following function is used to start the server. Port `80` would be used.
    The `serve_forever` method handles requests until an explicit `shutdown()` request
    is received. The method is inherited from the `SocketServer.BaseServer` class:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the code on another machine. I am using Windows 10 to run the code. From
    a second computer, use the tool ID server to find the server signature. I got
    the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9eb7b79d-f007-4e3d-be5c-192f8fd2a3f3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: From the output, we can say our code is running fine. So you can craft your
    own message.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see the code of `logger1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code creates a log file that tells us the client address of the
    incoming requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'See the output of the `live1.log` file as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/15541ec1-181d-475c-8b62-f1888ac140d9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you learned how to send a fake ICMP (ping) reply. In order
    to send the ICMP reply, the ARP protocol must be running. By running both the
    codes simultaneously, they create an illusion at the network layer. But, before
    running the code, a firewall must be set to drop the outgoing frames. At the transport
    layer, two experiments were performed: a fake port open and fake OS running. By
    learning more about `nmap`, an exact fake response of a particular OS can be created.
    At the application layer, a Python web server code is giving a fake server signature.
    You can change the server signature according to your needs.'
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 7](d120a8af-c365-43e1-9b66-1328a1e3ea74.xhtml), *Foot Printing a
    Web Server and a Web Application*, you will learn about footprinting a web server.
    You will also learn how to obtain the header of HTTP and about banner grabbing
  prefs: []
  type: TYPE_NORMAL
