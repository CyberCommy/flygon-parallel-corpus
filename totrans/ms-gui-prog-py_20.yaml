- en: Preparing Your Software for Distribution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up to this point in the book, we have primarily been concerned with writing
    a working piece of code. Our projects have all been single scripts with, at most,
    a handful of supporting data files. Producing a finished project doesn't end with
    writing the code, however; we also need our projects to be easily distributable
    so that we can share them with (or sell them to) other people.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we're going to look at ways to prepare our code for sharing
    and distribution.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll cover these topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Structuring a project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Distributing with `setuptools`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compiling with PyInstaller
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this chapter, you will need the basic Python and PyQt setup we have used
    throughout the book. You will also need the `setuptools`, `wheel`, and `pyinstaller`
    libraries available from PyPI with this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Windows users will want to install the 7-Zip program from [https://www.7-zip.org/](https://www.7-zip.org/)
    so that they can work with `tar.gz` files, and users on all platforms should install
    the UPX utility from [https://upx.github.io/](https://upx.github.io/).
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you will want the example code from the repository at [https://github.com/PacktPublishing/Mastering-GUI-Programming-with-Python/tree/master/Chapter17](https://github.com/PacktPublishing/Mastering-GUI-Programming-with-Python/tree/master/Chapter17).
  prefs: []
  type: TYPE_NORMAL
- en: Check out the following video to see the code in action: [http://bit.ly/2M5xH4J](http://bit.ly/2M5xH4J)
  prefs: []
  type: TYPE_NORMAL
- en: Structuring a project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far in this book, we've been putting all the Python code in each example
    project into a single file. Real-world Python projects, however, benefit from
    better organization. While there are no official standards on how to structure
    a Python project, there are some conventions and general concepts we can apply
    to our project structure that will not only keep things organized, but encourage
    others to contribute to our code.
  prefs: []
  type: TYPE_NORMAL
- en: To see how this works, we're going to create a simple tic-tac-toe game in PyQt,
    then spend the rest of the chapter getting it ready for distribution.
  prefs: []
  type: TYPE_NORMAL
- en: Tic-tac-toe
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our tic-tac-toe game is made up of three classes:'
  prefs: []
  type: TYPE_NORMAL
- en: An engine class that manages the logic of the game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A board class that provides a view of the game state and a way to make plays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The main window class that brings the other two together into a GUI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Open a new copy of the application template from [Chapter 4](9281bd2a-64a1-4128-92b0-e4871b79c040.xhtml),
    *Building Applications with QMainWindow*, and call it `ttt-qt.py`. Now let's create
    these classes.
  prefs: []
  type: TYPE_NORMAL
- en: The engine class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our game engine object's main responsibility is to keep track of plays and to
    check whether there is a winner or whether the game is a draw. The players will
    be represented simply by the `'X'` and `'O'` strings, and the board will be modeled
    as a list of nine items that will either be a player or `None`.
  prefs: []
  type: TYPE_NORMAL
- en: 'It begins like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `winning_sets` list contains `set` objects with every combination of board
    indexes that constitutes a win. We'll be using that list to check whether a player
    won. We've also defined signals to be emitted when the game is won or when there
    is a draw (that is, all the squares are filled and nobody won). The constructor
    populates the board list and sets the current player to `X`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll need a method to update the current player after each turn, which looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''ll add a method for marking a square:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This method first checks for any reason the given square shouldn't be marked,
    returning `False` if there is a reason; otherwise, we mark the square, swap to
    the next player, and return `True`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last method in this class will check the state of the board to see whether
    there is a winner or a draw:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This method uses some set operations to check each player's currently-marked
    squares against the list of winning combinations. If any match is found, the `game_won`
    signal is emitted and the method returns. If nobody has won yet, we also check
    to see whether there are any unmarked squares; if there aren't, the game is a
    draw. If neither of these cases is true, we do nothing.
  prefs: []
  type: TYPE_NORMAL
- en: The board class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the board GUI, we'll use a `QGraphicsScene` object just as we did for our
    tank game in [Chapter 12](1a25e80a-2680-47f4-b309-782cf9b8580f.xhtml), *Creating
    2D Graphics with QPainter*.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start with some class variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `square_rects` tuple defines a `QRectF` object for each of the nine squares
    on the board, and a `square_clicked` signal is emitted whenever a square is clicked
    on; the accompanying integer will indicate which square (0-8) was clicked on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the `=__init__()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This method sets the scene size and paints a cyan background, and then it draws
    each of the squares in `square_rects`. We then load up the `QPixmap` objects for
    the `'X'` and `'O'` images that will be used to mark the squares, and we create
    an empty list to keep track of the `QGraphicsSceneItem` objects for our marks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we''ll add a method to draw the current state of the board:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This method will take a list of the marks on our board and draw the appropriate
    pixmap in each square, keeping track of the `QGraphicsSceneItems` objects created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we''ll need a method to clear the board:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This method simply iterates through the saved pixmap items and removes them
    all.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last thing we need to do is handle mouse clicks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `mousePressEvent())` method is called by `QGraphicsScene` whenever the user
    makes a mouse click. It includes a `QMouseEvent` object that contains details
    about the event, including the position of the mouse click. We can check whether
    this click is inside any of our `square_rects` objects, and if so, we'll emit
    the `square_clicked` signal and exit the method.
  prefs: []
  type: TYPE_NORMAL
- en: The main window class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In `MainWindow.__init__()`, we''ll start by creating a board and a `QGraphicsView` object
    to display it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need to create an instance of the game engine and connect its signals.
    In order to allow us to start games over and over, we''ll create a separate method
    for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This method clears the board, and then it creates an instance of the game engine
    object, connecting the engine's signals to `MainWindow` methods to handle the
    two game-over scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back in `__init__()`, we''ll go ahead and call this method to set up the first
    game automatically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to enable player input. We''ll need a method that will try to
    mark the square in the engine and then check the board for a win or a draw if
    the mark was successful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'That method can be connected to the board''s `square_clicked` signal; back
    in `__init__()`, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to handle the two game-over scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In both cases, we're just going to display an appropriate message in `QMessageBox` and
    then restart the game.
  prefs: []
  type: TYPE_NORMAL
- en: This completes our game. Take a moment to run the game and make sure you understand
    how it responds when working correctly (maybe get a friend to play a few rounds
    with you; it helps if your friend is quite young or not particularly bright).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a working game, it's time to prepare it for distribution. The
    first thing we'll do is structure our project in a way that will make it easier
    for us to maintain and expand, and for other Python programmers to collaborate
    on.
  prefs: []
  type: TYPE_NORMAL
- en: Module-style structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As programmers, we tend to think of applications and libraries as two very different
    things, but, in truth, well-structured applications aren't that different from
    libraries. A library is just a collection of ready-made classes and functions.
    Our application is mostly just class definitions as well; it just happens to have
    a few lines of code at the end that allow it to be executed as an application.
    When we see things this way, structuring our application as a Python library module
    makes a lot of sense. To do this, we're going to convert our single Python file
    to a directory full of files, each containing an individual unit of code.
  prefs: []
  type: TYPE_NORMAL
- en: The first step is to consider our project's name; right now, that name is `ttt-qt.py`.
    It's not uncommon to come up with a quick and short name when you first start
    hacking on a project, but that doesn't need to be the name you stick with. In
    this case, our name is rather cryptic and doesn't work as a Python module name
    due to the hyphen. Instead, let's call it `qtictactoe`, a name that is more explicit
    and avoids the hyphen.
  prefs: []
  type: TYPE_NORMAL
- en: To begin, create a new directory called `QTicTacToe`; this will be our **project
    root**. The project root is the directory under which all our project files will
    go.
  prefs: []
  type: TYPE_NORMAL
- en: Inside that directory, we'll create a second directory called `qtictactoe`;
    this will be the **module directory** inside which the bulk of our source code
    will live.
  prefs: []
  type: TYPE_NORMAL
- en: Structuring the module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To begin our module, we're going to start by adding the code for our three classes.
    We're going to put each one in a separate file; this isn't strictly necessary,
    but it will help us to keep our code decoupled and make it easier to find the
    class we want to edit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, under `qtictactoe`, create three files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`engine.py` will hold our game engine class. Copy in the `TicTacToeEngine`
    definition along with the necessary `PyQt5` import statements for the classes
    it uses. In this case, you only need `QtCore`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`board.py` will hold the `TTTBoard` class. Copy in that code as well as the
    full set of `PyQt5` import statements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, `mainwindow.py` will hold the `MainWindow` class. Copy in the code
    for that class as well as the `PyQt5` imports.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mainwindow.py` also needs access to the `TicTacToeEngine` and `TTTBoard` classes
    from the other files. To provide this access, we need to use **relative imports**.
    A relative import is a way of importing submodules from the same module.'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top of `mainwindow.py`, add this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The dot in the import indicates that this is a relative import, and refers specifically
    to the current container module (in this case, `qtictactoe`). By using relative
    imports like this, we can ensure that we're importing these modules from our own
    project and not from some other Python library on the end user's system.
  prefs: []
  type: TYPE_NORMAL
- en: The next code we need to add to our module is code to make it actually run.
    This is the code we usually put under our `if __name__ == '__main__'` block.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the module, we''ll put it in a file called `__main__.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The `__main__.py` file serves a special purpose in a Python module. It is executed
    whenever our module is run using the `-m` switch, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Essentially, `__main__.py` is the module equivalent of the `if __name__ == '__main__':`
    block in a Python script.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we have placed our three main lines of code inside a function called
    `main()`. The reason for that will become apparent when we discuss the use of
    `setuptools`.
  prefs: []
  type: TYPE_NORMAL
- en: The last file we need to create inside our module is an empty file called `__init__.py`.
    The `__init__.py` file of a Python module is analogous to the `__init__()` method
    of a Python class. It is executed whenever the module is imported, and anything
    in its namespace is considered to be in the root namespace of the module. In this
    case, though, we're going to just leave it empty. That may seem pointless, but
    without this file many of the tools we're going to be working with won't recognize
    this folder of Python files as an actual module.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, your directory structure should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Now we can execute our program using `python3 -m qtictactoe`, but that's not
    terribly intuitive for most users. Let's help out a little by creating an obvious
    file for executing the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Directly under the project root (outside the module), create a file called
    `run.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This file's only purpose is to load the `main()` function from our module and
    execute it. Now you can execute `python run.py` and you'll find it launches just
    fine. However, there's a problem—when you click a square, nothing happens. That's
    because our image files are missing. We'll need to deal with those next.
  prefs: []
  type: TYPE_NORMAL
- en: Non-Python files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a PyQt program, the best way to deal with files such as our `X` and `O` images
    is to use the `pyrcc5` tool to generate a resources file that can then be added
    to your module like any other Python file (we learned about this in [Chapter 6](c3eb2567-0e73-4c37-9a9e-a0e2311e106c.xhtml),
    *Styling Qt Applications*). However, in this case, we're going to keep our images
    as PNG files so that we can explore our options for dealing with non-Python files.
  prefs: []
  type: TYPE_NORMAL
- en: There is little consensus on where these kinds of files should live inside a
    project directory, but since these images are a required component of the `TTTBoard`
    class, it makes sense to put them inside our module. For the sake of organization,
    put them in a directory called `images`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your directory structure should now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The way we have written `TTTBoard`, you can see that each image is loaded using
    a relative file path. In Python, relative paths are always relative to the current
    working directory—that is, the directory from which the user launched the script.
    Unfortunately, this is a rather brittle design, as we have no control over this
    directory. We also can't hardcode an absolute file path since we don't know where
    our application might be stored on a user's system (see our discussion of this
    problem in [Chapter 6](c3eb2567-0e73-4c37-9a9e-a0e2311e106c.xhtml), *Styling Qt
    Applications*, under the *Using Qt Resource files* section).
  prefs: []
  type: TYPE_NORMAL
- en: The ideal way to solve this problem in a PyQt application is to use Qt Resource
    files; however, we're going to try a different approach just to illustrate how
    to solve this problem in cases where that isn't an option.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get around this, we need to modify the way `TTTBoard` loads the images so
    that it''s relative to the location of our module, rather than the user''s current
    working directory. This will require us to use the `os.path` module from the Python
    standard library, so add this at the top of `board.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, down in `__init__()`, we''ll modify the lines that load in the images:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `__file__` variable is a built-in variable that always contains the absolute
    path to the current file (`board.py`, in this case). Using `path.dirname`, we
    can find the directory that contains this file. Then, we can use `path.join` to
    assemble a path that looks for the files under a folder called `images` in the
    same directory.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the program now, you should find that it works perfectly, just as
    before. We're not quite done yet, though.
  prefs: []
  type: TYPE_NORMAL
- en: Documentation and metadata
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Working and well-organized code is a great start for our project; however if
    you want others to use or contribute to your project, you'll need to address some
    of the questions they're likely to have. For example, they'll need to know how
    to install the program, what its prerequisites are, or what the legal terms of
    use or distribution are.
  prefs: []
  type: TYPE_NORMAL
- en: 'To answer these questions, we''ll include a series of standard files and directories:
    the `LICENSE` file, the `README` file, the `docs` directory, and the `requirements.txt`
    file.'
  prefs: []
  type: TYPE_NORMAL
- en: The LICENSE file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you share code, it's important to spell out exactly what others can or
    cannot do with that code. In most countries, a person who creates a piece of work such
    as a program is automatically the copyright holder of that work; that means you
    exercise control over the copying of your work. If you want others to contribute
    to or use what you've created, you need to grant them a **license** to do so.
  prefs: []
  type: TYPE_NORMAL
- en: The license that governs your project is usually provided in a plain-text file
    in the project root called `LICENSE`. In our example code, we've included such
    a file that contains a copy of the **MIT license**. The MIT license is a permissive
    open source license which basically allows anyone to do anything with the code
    as long as they retain our copyright notice. It also states that we aren't responsible
    for anything terrible that happens as a result of someone using our code.
  prefs: []
  type: TYPE_NORMAL
- en: This file is sometimes called `COPYING`, and may have a file extension such
    as `txt` as well.
  prefs: []
  type: TYPE_NORMAL
- en: You are certainly free to put any conditions you wish in your license; however,
    for PyQt applications, you need to make sure your license is compatible with the
    terms of PyQt's **General Public License** (**GPL**) GNU and Qt's **Lesser General
    Public License** (**LGPL**) GNU. If you intend to release commercial or restrictively-licensed
    PyQt software, remember from [Chapter 1](bce5f3b1-2979-4f78-817b-3986e7974725.xhtml),
    *Getting Started with PyQt,* that you will need to purchase commercial licenses
    from both the Qt company and Riverbank Computing.
  prefs: []
  type: TYPE_NORMAL
- en: For open source projects, the Python community strongly recommends you stick
    with well-known licenses such as the MIT, BSD, GPL, or LGPL. A list of recognized
    open source licenses can be found on the website of the Open Source Initiative
    at [https://opensource.org/licenses](https://opensource.org/licenses). You may
    also want to consult [https://choosealicense.com](https://choosealicense.com),
    a site that offers guidance on selecting a license that best matches your intentions.
  prefs: []
  type: TYPE_NORMAL
- en: The README file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `README` file is one of the oldest traditions in software distribution.
    Dating back to the mid 1970s, this plain-text file is usually meant to convey
    the most basic set of instructions and information to users of the program before
    they install or run the software.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although there is no standard for what a `README` file should contain, there
    are certain things a user would expect to find; some of these include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The name and home page of the software
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The author of the software (with contact information)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A short description of the software
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic usage instructions, including any command-line switches or arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instructions for reporting bugs or contributing to the project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A list of known bugs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notes such as platform-specific issues or instructions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whatever you include in the file, you should aim to keep it concise and organized.
    To facilitate some organizations, many modern software projects employ a markup
    language when writing a `README` file; this allows us to use elements such as
    headers, bullet lists, and even tables.
  prefs: []
  type: TYPE_NORMAL
- en: In Python projects, the preferred markup language is the **ReStructured Text**
    (**RST**). This language is part of the `docutils` project, which provides documentation
    utilities for Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll take a brief look at RST as we walk through creating a `README.rst`
    file for `qtictactoe`. Start with a title:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The equals signs around the top line indicate that it is a title; in this case,
    we've just used the name of our project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we''ll create a couple of sections for basic information about the project;
    we indicate section headers by simply underlining a line of text with symbols,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The symbols used for underlining section headers must be one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The order in which we use them isn't important, as RST interpreters will assume
    the first symbols used as an underline representing a top-level header, the next
    type of symbol is a second-level header, and so on. In this case, we're using
    the equals sign first, so it will indicate a level-one header wherever we use
    it throughout this document.
  prefs: []
  type: TYPE_NORMAL
- en: Note the double asterisks around the words `tic-tac-toe`; this indicates bold
    text. RST can also indicate underlines, italics, and similar typographic styles.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can indicate monospaced code text by using the backtick:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This example also shows a bullet list: each line is prefixed with a dash and
    space. We can alternately use the `+` or `*` symbols as well, and create subpoints
    by indenting.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s finish our `README.rst` file with some information about contributing
    and some notes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Contributing` section shows how to create a hyperlink: put the hyperlink
    text inside backticks, with the URL inside angle brackets, and add an underscore
    after the closing backtick. The `Notes` section demonstrates a block quote, which
    is accomplished by simply indenting the line four spaces.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Although our file is perfectly readable as text, many popular code-sharing
    sites will translate RST and other markup languages to HTML. For example, on GitHub
    this file will appear in the browser like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/74f798bd-47d8-4941-8a14-63b614ce31d7.png)'
  prefs: []
  type: TYPE_IMG
- en: This simple `README.rst` file is sufficient for our small application; as an
    application grows, it will warrant further expansion to document added features,
    contributors, community policies, and more. This is why we prefer to use a plain-text
    format such as RST and why we make it part of the project repository; it should
    be updated along with the code.
  prefs: []
  type: TYPE_NORMAL
- en: A quick reference for RST syntax can be found at [docutils.sourceforge.net/docs/user/rst/quickref.html](http://docutils.sourceforge.net/docs/user/rst/quickref.html).
  prefs: []
  type: TYPE_NORMAL
- en: The docs directory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While this `README` file is sufficient documentation for `QTicTacToe`, a more
    complex program or library may demand more robust documentation. The standard
    place to put such documentation is in the `docs` directory. This directory should
    be right under our project root, and can contain any sort of additional documentation,
    including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Sample configuration files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User manuals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API documentation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Database diagrams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since our program doesn't need any of these things, we don't need to add a `docs`
    directory to this project.
  prefs: []
  type: TYPE_NORMAL
- en: The requirements.txt file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python programs often require packages outside the standard library to operate,
    and users will need to know what to install in order for your project to run.
    You can (and probably should) put this information in the `README` file, but you
    should also put it in `requirements.txt`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The format for `requirements.txt` is one library per line, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The library names in this file should match what is used in PyPI, as this file
    can then be used by `pip` to install all the required libraries for the project,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We don't actually have to specify `PyQt5-sip` since it's a dependency of `PyQt5`
    and will be installed automatically. We added it here to show how multiple libraries
    are specified.
  prefs: []
  type: TYPE_NORMAL
- en: 'If specific versions of libraries are required, this can also be noted using
    version specifiers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we are specifying `PyQt5` version `5.12` or greater, and only
    version `4.19.4` of `PyQt5-sip`.
  prefs: []
  type: TYPE_NORMAL
- en: More information about the `requirements.txt` file can be found at [https://pip.readthedocs.io/en/1.1/requirements.html](https://pip.readthedocs.io/en/1.1/requirements.html).
  prefs: []
  type: TYPE_NORMAL
- en: Other files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These are the bare essentials of project documentation and metadata, but you
    may find some additional files useful in certain situations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`TODO.txt`: A shortlist of bugs or missing features that need work'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CHANGELOG.txt`: A log of the history of major project changes and releases'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tests`: A directory containing unit tests for your module'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scripts`: A directory containing Python or shell scripts that are useful to,
    but not part of, your module'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Makefile`: Some projects benefit from a scripted build process, and for that,
    a utility such as `make` can be helpful; alternatives include CMake, SCons, or
    Waf'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At this point, though, your project is ready to upload to your favorite source
    code-sharing site. In the next section, we'll look at getting it ready for PyPI.
  prefs: []
  type: TYPE_NORMAL
- en: Distributing with setuptools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many times throughout this book, you have installed Python packages using `pip`.
    You probably know that `pip` downloads these packages from PyPI and installs them
    to your system, Python virtual environment, or user environment. What you may
    not know is that the tool used to create and install these packages is called
    `setuptools`, and it's readily available to us if we want to make our own packages
    for PyPI or for personal use.
  prefs: []
  type: TYPE_NORMAL
- en: Although `setuptools` is the officially recommended tool for creating Python
    packages, it is not part of the standard library. However, it *is* included in
    the default distributions for most **operating systems** (**OS**es) if you elect
    to include `pip` during installation. If for some reason you don't have `setuptools`
    installed, consult the documentation at [https://setuptools.readthedocs.io/en/latest/](https://setuptools.readthedocs.io/en/latest/)
    to see how you can install it on your platform.
  prefs: []
  type: TYPE_NORMAL
- en: The main task involved in using `setuptools` is writing a `setup.py` script.
    In this section, we'll learn how to write and use our `setup.py` script to generate
    distributable packages.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the setuptools configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The primary purpose of `setup.py` is to call the `setuptools.setup()` function
    with keyword arguments, which will define our project's metadata as well as how
    our project should be packaged and installed.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the first thing we''ll do is import that function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The remaining code in `setup.py` will be keyword arguments to `setup()`. Let's
    go through the different categories of those arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Basic metadata arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The simplest arguments involve the basic metadata about the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Here, we've described the package name, version, short description, project
    URL, and license, as well as the author's name and email. This information will
    be written to the package metadata and used by sites such as PyPI to build a profile
    page for your project.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, look at the PyPI page for PyQt5:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/816fd19d-7d1a-4e06-88c6-53ff5541c532.png)'
  prefs: []
  type: TYPE_IMG
- en: Along the left-side of the page, you'll see a link to the project's home page,
    the author (with a hyperlinked email address), and the license. At the top, you
    see the project name and version, as well as a short description of the project.
    All of this kind of data can be extracted from a project's `setup.py` script.
  prefs: []
  type: TYPE_NORMAL
- en: If you plan to submit a package to PyPI, please see PEP 440 at [https://www.python.org/dev/peps/pep-0440/](https://www.python.org/dev/peps/pep-0440/)
    for how your version number should be specified.
  prefs: []
  type: TYPE_NORMAL
- en: 'The long text you see in the main body of this page comes from the `long_description`
    argument. We could just put a long string directly into this argument, but since
    we already have such a nice `README.rst` file, why not use that here? Since `setup.py`
    is a Python script, we can just read in the file''s contents, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: One advantage of using RST here is that PyPI (and many other code-sharing sites)
    will automatically render your markup into nicely-formatted HTML.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we wish to make our project easier to search for, we can include a string
    of space-separated keywords:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: In this case, a person who searched for "multiplayer pyqt5" in PyPI should find
    our project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you can include a dictionary of project-related URLs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The format is `{''label'': ''URL''}`; examples of things you might include
    here are the project''s bug tracker, documentation site, Wiki page, or source
    repository, especially if any of those are different to the home URL.'
  prefs: []
  type: TYPE_NORMAL
- en: Packages and dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Apart from establishing the basic metadata, `setup()` needs information about
    the actual code that needs to be included, or the environment that needs to be
    present on the system for this package to be executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first keyword we need to deal with here is `packages`, which defines the
    modules in our project that need to be included:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Note that we need to include both the `qtictactoe` module and the `qtictactoe.images`
    module explicitly; even though the `images` directory is under `qtictactoe`, it
    will not be included automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we had a lot of submodules and didn''t want to explicitly list them, `setuptools`
    offers an automatic solution as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: If you want to use `find_packages`, make sure each submodule has an `__init__.py`
    file in it so that `setuputils` can identify it as a module. In this case, you'd
    need to add an `__init__.py` file to the `images` folder or it will be ignored.
  prefs: []
  type: TYPE_NORMAL
- en: Both approaches have advantages and drawbacks; the manual approach is more work,
    but `find_packages` may sometimes fail to identify a library in certain circumstances.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to specify the external libraries that are needed for this project
    to run—in this case, `PyQt5`. That can be done with the `install_requires` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This keyword takes a list of names for packages that must be installed for the
    program to be installed. When your program is installed using `pip`, it will use
    this list to install all dependency packages automatically. You should include
    anything that isn't part of the standard library in this list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like the `requirements.txt` file, we can even be explicit about the version
    number of each dependency required:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: In this case, `pip` would make sure a version of PyQt5 greater than or equal
    to 5.12 is installed. If no version is specified, `pip` will install the latest
    version available from PyPI.
  prefs: []
  type: TYPE_NORMAL
- en: 'In some cases, we might require a certain version of Python as well; for example,
    our project uses f-strings, a feature only found in Python 3.6 or greater. We
    can specify that with the `python_requires` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also specify dependencies for optional features; for example, if we
    added an optional network-play feature to `qtictactoe`, which required the `requests`
    library, we would specify that like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The `extras_require` keyword accepts a mapping of feature names (which can
    be anything you want) to lists of package names. These modules won''t be automatically
    installed when your package is, but other modules can depend on these subfeatures.
    For example, another module can specify a dependency on our project''s `NetworkPlay`
    extra keywords like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: This would trigger a cascade of dependencies that would result in the `requests`
    library being installed.
  prefs: []
  type: TYPE_NORMAL
- en: Non-Python files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By default, `setuptools` will package the Python files it finds in our project,
    and other file types will be ignored. In almost any project, however, there are
    going to be non-Python files that we''re going to want to include in our distribution
    package. These files fall generally into two categories: those that are part of
    a Python module, such as our PNG files, and those that are not, such as the `README`
    file.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To incorporate files that are *not* part of a Python package, we need to create
    a file called `MANIFEST.in`. This file contains `include` directives for file
    paths underneath the project root. For example, if we want to include our documentation
    files, ours should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The format is simple: the word `include` followed by a filename, path, or pattern
    that will match a set of files. All paths are relative to the project root.'
  prefs: []
  type: TYPE_NORMAL
- en: To include files that are part of a Python package, we have two choices.
  prefs: []
  type: TYPE_NORMAL
- en: 'One way is to include them in the `MANIFEST.in` file, and then set `include_package_data`
    to `True` in `setup.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Another way to include non-Python files is to use the `package_data` keyword
    argument in `setup.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: This argument takes a `dict` object, where each item is a module path and a
    list of patterns that match the files included. In this case, we want to include
    all PNG files found in the `qtictactoe.images` module, and any TXT or RST files
    anywhere in the package. Keep in mind this argument only applies to files *in
    the module directory* (that is, files under `qtictactoe`). If we want to include
    files such as `README.rst` or `run.py`, those should be put in the `MANIFEST.in`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: You can use either approach to including files, but you cannot use *both* approaches
    in the same project; if you enable `include_package_data`, the `package_data`
    directives will be ignored.
  prefs: []
  type: TYPE_NORMAL
- en: Executables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We tend to think of PyPI as a tool to install Python libraries; in fact, it
    works well for installing applications as well, and many Python applications are
    available from it. Even if you are creating a library, it's likely your library
    will ship with executable utilities, such as the `pyrcc5` and `pyuic5` utilities
    that come with PyQt5.
  prefs: []
  type: TYPE_NORMAL
- en: To accommodate these, `setuputils` gives us a way to specify particular functions
    or methods as console scripts; when the package is installed, it will create a
    simple executable file, which will call that function or method when executed
    from the command line.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is specified using the `entry_points` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The `entry_points` dictionary has other uses, but the one we''re most concerned
    with is the `''console_scripts''` key. This key points to a list of strings that
    specify the functions we want set up as command-line scripts. The format for these
    strings is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: You can add as many console scripts as you wish; they just need to point to
    a function or method in the package that can be run directly. Note that you *must*
    specify an actual callable here; you can't just point to a Python file to run.
    This is why we've put all the execution code under a `main()` function inside
    `__main__.py`.
  prefs: []
  type: TYPE_NORMAL
- en: '`setuptools` contains many more directives to deal with less common situations;
    for a complete list, see [https://setuptools.readthedocs.io/en/latest/setuptools.html](https://setuptools.readthedocs.io/en/latest/setuptools.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Source distributions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that `setup.py` is ready to go, we can use it to actually create our package
    distributions. There are two basic types of package distributions: `source` and
    `built`. In this section, we''ll talk about how to use **source distributions**.'
  prefs: []
  type: TYPE_NORMAL
- en: A source distribution is a bundle of all the source code and extra files needed
    to build our project. It includes the `setup.py` file and is useful for distributing
    your project in a cross-platform way.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a source distribution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To build a source distribution, open Command Prompt in your project root and
    enter this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'This will create a couple of directories and many files:'
  prefs: []
  type: TYPE_NORMAL
- en: The `ProjectName.egg-info` directory (in our case, the `QTicTacToe.egg-info`
    directory) will contain several files of metadata generated from our `setup.py`
    arguments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `dist` directory will contain the `tar.gz` archive file containing our distribution.
    Ours is called `QTicTacToe-1.0.tar.gz`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Take a few minutes to explore the contents of `QTicTacToe.egg-info`; you'll
    see that all the information we specified in `setup()` is there in some form.
    This directory is also included inside the source distribution.
  prefs: []
  type: TYPE_NORMAL
- en: Also, take a moment to open the `tar.gz` file and see what it contains; you'll
    see all the files we specified in `MANIFEST.in`, as well as the `qtictactoe` module
    and all the files from `QTicTacToe.egg-info`. Essentially, this is a complete
    copy of our project directory.
  prefs: []
  type: TYPE_NORMAL
- en: Linux and macOS have native support for `tar.gz` archives; on Windows, you can
    use the free 7-Zip utility. See the *Technical requirements* section for information
    about 7-Zip.
  prefs: []
  type: TYPE_NORMAL
- en: Installing a source distribution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A source distribution can be installed using `pip`; to see how this works in
    a clean environment, we'll install our library in a Python **virtual environment**.
    Virtual environments are a way to create an isolated Python stack in which you
    can add or remove libraries independently of your system Python installation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a console window, create a new directory and then make it a virtual environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The `virtualenv` command copies the necessary files into the given directory
    so that Python can be run, as well as some scripts to activate and deactivate
    the environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start using your new environment, run this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Depending on your platform, your command-line prompt may change to indicate
    that you're in a virtual environment. Now when you run `python` or Python-related
    tools such as `pip`, they will do all the operations in the virtual environment
    rather than in your system Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s install our source distribution package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: This command will cause `pip` to extract our source distribution and execute
    `python setup.py install` inside the project root. The `install` directive will
    download any dependencies, build an entry point executable, and copy the code
    into the directory where your Python libraries are stored (in the case of our
    virtual environment, that would be `test_env/lib/python3.7/site-packages/`). Notice
    that a fresh copy of `PyQt5` is downloaded; your virtual environment has nothing
    but Python and the standard library installed, so any dependencies we listed in
    `install_requires` will have to be installed anew.
  prefs: []
  type: TYPE_NORMAL
- en: After `pip` finishes, you should be able to run the `qtictactoe` command and
    launch the application successfully. This command is stored in `test_env/bin`,
    in case your OS does not automatically append the virtual environment directories
    to your `PATH`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To remove the package from the virtual environment, you can run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: This should clean up the sources and all the generated files.
  prefs: []
  type: TYPE_NORMAL
- en: Built distributions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Source distributions are essential for developers, but they often contain many
    elements that aren't necessary for an end user, such as unit tests or example
    code. In addition to this, if the project contains compiled code (such as Python
    extensions written in C), that code will require compilation before it can be
    used on the target. To address this, `setuptools` offers a variety of **built
    distribution** types. A built distribution provides a ready-made set of files,
    which only need to be copied to the appropriate directories to use.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we'll talk about how to work with built distributions.
  prefs: []
  type: TYPE_NORMAL
- en: Types of built distributions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first step in creating a built distribution is determining the type of built
    distribution we want. The `setuptools` library offers a few different built distribution
    types, and we can install other libraries to add more options.
  prefs: []
  type: TYPE_NORMAL
- en: 'The built-in types are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Binary distribution**: This is a `tar.gz` file just like a source distribution,
    but unlike the source distribution it contains precompiled code (for example,
    the `qtictactoe` executable) and omits certain types of files (such as tests).
    The contents of a built distribution need to be extracted and copied to an appropriate
    location to be run.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Windows installer**: This is just like the binary distribution, except that
    it''s an executable that will launch an install wizard on Windows. The wizard
    merely serves to copy the files to the proper location for execution or library
    use.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**RPM Package Manager** (**RPM**) **installer**: Again, this one is just like
    the binary distribution, except that it packages code in an RPM file. RPM files
    are used by package management utilities on several Linux distributions (such
    as Red Hat, CentOS, Suse, Fedora, and more).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While you may find these distribution types useful in certain situations, they
    are all a bit dated in 2019; the standard way to distribute Python today is using
    a **wheel distribution**. These are the binary distribution packages you'll find
    on PyPI.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at creating and installing wheel packages.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a wheel distribution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To create a wheel distribution, you first need to make sure the `wheel` library
    is installed from PyPI (see the *Technical requirements* section). After that,
    `setuptools` will have an additional `bdist_wheel` option.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use that to create your wheel file like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Just as before, this command will create the `QTicTacToe.egg-info` directory
    and populate it with files containing your project metadata. It also creates a
    `build` directory, where compiled files are staged before being compacted into
    the `wheel` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Under `dist`, we''ll find our completed `wheel` file. In our case, it''s called
    `QTicTacToe-1.0-py3-none-any.whl`. The format for the filename is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The project name (`QTicTacToe`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The version (1.0).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The version of Python that is supported, whether 2, 3, or `universal` (`py3`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ABI` tag, which indicates a specific release of Python on whose binary
    interface our project depends (`none`). This will only be used if we have compiled
    the code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The platform (OS and CPU architecture). Ours is any because we aren't including
    any platform-specific binaries.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Binary distributions come in three types:'
  prefs: []
  type: TYPE_NORMAL
- en: A **Universal** type has only Python and is compatible with Python 2 or 3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **Pure Python** type has only Python but is compatible with Python 2 or Python
    3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **Platform** type includes a compiled code that only runs on a particular
    platform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As reflected in the distribution name, our package is of the pure Python variety
    since it contains no compiled code and only supports Python 3\. PyQt5 is an example
    of a platform package type since it includes the Qt libraries compiled for specific
    platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Recall from [Chapter 15](77583d1b-8a70-4118-8210-b0a5f09c9603.xhtml), *PyQt
    on the Raspberry Pi*, that we could not install PyQt from PyPI on the Raspberry
    Pi because there was no `wheel` file for the Linux ARM platform. Since PyQt5 is
    a platform package type, it can only be installed on platforms for which this
    `wheel` file has been generated.
  prefs: []
  type: TYPE_NORMAL
- en: Installing a built distribution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Just as with source distributions, we can install our wheel file using `pip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: If you try this in a fresh virtual environment, you should find that, once again,
    PyQt5 is downloaded from PyPI and installed and that you have the `qtictactoe`
    command available afterward. There isn't much difference to the end user in the
    case of a program such as `QTicTacToe`, but in the case of a library with binary
    files to compile (such as PyQt5), it makes the set up considerably less problematic.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, even a `wheel` file requires that the target system have Python and
    `pip` installed, as well as access to the internet and PyPI. This is still a lot
    to ask of many users or computing environments. In the next section, we're going
    to explore a tool that will allow us to create a standalone executable from our
    Python projects, which can run without any prerequisites.
  prefs: []
  type: TYPE_NORMAL
- en: Compiling with PyInstaller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After successfully writing their first application, the most common question
    many Python programmers have is *How do I make this code into an executable?.* Unfortunately,
    there isn't a single, official answer to this question. Over the years, many projects
    have been launched to address this task (such as Py2Exe, cx _Freeze, Nuitka, and
    PyInstaller to name a few), with varying degrees of support, simplicity of use,
    and consistency of results. In terms of these qualities, the current best option
    is **PyInstaller**.
  prefs: []
  type: TYPE_NORMAL
- en: PyInstaller overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python is an interpreted language; instead of being compiled to machine code
    the way C or C++ is, your Python code (or an optimized version of it called **bytecode**)
    is read and executed by the Python interpreter each time you run it. This allows
    Python to have some features that make it very easy to use, but also make it hard
    to compile into machine code to provide a traditional standalone executable.
  prefs: []
  type: TYPE_NORMAL
- en: PyInstaller steps around this problem by packaging your script with a Python
    interpreter, as well as any libraries or binaries required for it to run. These
    things are bundled together into either a directory or a single file to provide
    a distributable application that can be copied over to any system and executed,
    even if that system doesn't have Python.
  prefs: []
  type: TYPE_NORMAL
- en: To see how this works, make sure you have PyInstaller installed from PyPI (see
    the *Technical requirements* section) and let's create an executable for `QTicTacToe`.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the application packages created by PyInstaller are platform-specific
    and can only be run on an OS and CPU architecture compatible with that on which
    it was compiled. For example, if you build your PyInstaller executable on 64-bit
    Linux, it will not run on 32-bit Linux or 64-bit Windows.
  prefs: []
  type: TYPE_NORMAL
- en: Basic command-line usage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In theory, using PyInstaller is as simple as opening Command Prompt and typing
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: In fact, let's try this with our `qt_template.py` file from [Chapter 4](9281bd2a-64a1-4128-92b0-e4871b79c040.xhtml),
    *Building Applications with QMainWindow*; copy it to an empty directory, and run
    `pyinstaller qt_template.py` in that directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'You''ll get a great deal of output to the console and find that several directories
    and files were generated:'
  prefs: []
  type: TYPE_NORMAL
- en: The `build` and `__pycache__` directories mainly contain intermediate files
    generated during the build process. These may be helpful during debugging, but
    they are not part of the end product.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `dist` directory contains our distributable output.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `qt_template.spec` file holds the configuration data generated by PyInstaller.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By default, PyInstaller produces a directory containing the executable file
    plus all the libraries and data files required for it to work. The entire directory
    must be copied over to another computer if you want to run the executable.
  prefs: []
  type: TYPE_NORMAL
- en: Enter this directory and look for an executable file called `qt_template`. If
    you run it, you should see a blank `QMainWindow` object pop open.
  prefs: []
  type: TYPE_NORMAL
- en: If you'd rather just have a single file, PyInstaller can compress this directory
    into a single executable, which when run, extracts itself into a temporary location
    and runs the main executable.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be accomplished with the `--onefile` argument; delete the contents
    of `dist` and `build`, and then run this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Now, under `dist`, you'll just find a single `qt_template` executable file.
    Again, run it and you'll see our blank `QMainWindow`. Keep in mind, while this
    approach is tidier, it increases the start-up time (since the application needs
    to be extracted) and may create some complications if your application opens up
    local files, as we'll see next.
  prefs: []
  type: TYPE_NORMAL
- en: If you make significant changes to your code, environment, or build specifications,
    it's a good idea to delete the `build` and `dist` directories, and possibly the
    `.spec` file.
  prefs: []
  type: TYPE_NORMAL
- en: Before we attempt to package `QTicTacToe`, let's take a deeper look into the
    `.spec` file.
  prefs: []
  type: TYPE_NORMAL
- en: The .spec file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `.spec` file is a Python-syntax `config` file that contains all the metadata
    about our build. You can think of it as PyInstaller's answer to a `setup.py` file.
    Unlike `setup.py`, however, the `.spec` file is automatically generated. This
    happens whenever we run `pyinstaller`, using a combination of detected data from
    our script and data passed in through command-line switches. We can also just
    generate the `.spec` file (and not start the build) using the `pyi-makespec` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once generated, a `.spec` file can be edited and then passed back to `pyinstaller`
    to rebuild the distribution without having to specify command-line switches every
    time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'To see what kind of things we might edit in this file, run `pyi-makespec qt_template.py`
    again and open up `qt_template.spec` in your editor. Inside the file, you''ll
    find four kinds of objects being created: `Analysis`, `PYZ`, `EXE`, and `COLLECT`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Analysis` constructor receives information about our script, data files,
    and libraries. It uses this information to analyze the dependencies of the project
    and produces five tables of paths pointing to the files that should be included
    in the distribution. The five tables are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`scripts`: The Python files that serve as entry points and will be converted
    into executables'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pure`: The pure Python modules required by the scripts'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`binaries`: The binary libraries required by the scripts'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`datas`: The non-Python data files, such as text files or images'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`zipfiles`: Any zipped Python `.egg` files'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In our file, the `Analysis` portions look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'You see the name of the Python script, the path, and a lot of empty keyword
    arguments. Most of these arguments correspond to the output tables and are used
    to manually supplement the results of the analysis with things that PyInstaller
    fails to detect, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`binaries` correspond to the `binaries` table.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`datas` corresponds to the `datas` table.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hiddenimports` corresponds to the `pure` table.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`excludes` allows us to leave out modules that may have been automatically
    included but aren''t really needed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hookspath` and `runtime_hooks` allow you to manually specify PyInstaller **hooks**;
    hooks allow you to override aspects of the analysis. They''re typically used for
    dealing with troublesome dependencies.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The next object created is the `PYZ` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: A `PYZ` object represents a compressed archive of all the pure Python scripts
    detected in the analysis phase. All the pure Python scripts in our project will
    be compiled to bytecode (`.pyc`) files and packed into this archive.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note the `cipher` argument present in both `Analysis` and `PYZ`; this argument
    can be used to obfuscate our Python bytecode further using AES256 encryption.
    While it doesn''t fully prevent decryption and decompiling of the code, it can
    be a useful deterrent to the curious if you plan to distribute your code commercially.
    To use this option, specify an encryption string using the `--key` argument when
    creating the file, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'After the `PYZ` section, an `EXE()` object is generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: The `EXE` object represents the executable file. The positional arguments here
    represent all the file tables we're bundling into the executable. Right now, this
    is just the compressed Python libraries and the main scripts; if we had specified
    the `--onefile` option, the other tables (`binaries`, `zipfiles`, and `datas`)
    would also be included here.
  prefs: []
  type: TYPE_NORMAL
- en: 'The keyword arguments to `EXE` allow us to control aspects of the executable
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '`name` is the filename of the executable'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`debug` toggles the debugging output for the executable'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`upx` toggles whether the executable will be compressed with **UPX**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`console` toggles whether to run the program in console or GUI mode in Windows
    and macOS; in Linux, it has no effect'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: UPX is a free executable packer available for multiple platforms from [https://upx.github.io/](https://upx.github.io/).
    If you have it installed, enabling this argument can make your executables smaller.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final phase in the process is generating a `COLLECT` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: This object gathers all the necessary files into the final distribution directory.
    It only runs in one-directory mode, and its positional arguments include the components
    to be included in the directory. We can also override a few other aspects of the
    folder, such as whether to use UPX on the binaries and the name of the output
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand a bit more about how PyInstaller works, let's package
    QTicTacToe.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing QTicTacToe for PyInstaller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PyInstaller is simple enough when working with a single script, but how does
    it work with our module-style project arrangement? We cannot point PyInstaller
    at our module, as it will return an error; it needs to be pointed at a Python
    script that serves as the entry point, such as our `run.py` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'This seems to work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: However, the resulting distribution and executable are now called `run`, which
    is not so great. You might be tempted to change `run.py` to `qtictactoe.py`; in
    fact, some tutorials on Python packaging recommend this arrangement (that is,
    having the `run` script the same name as the main module).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you attempt this, however, you may find you got an error such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Because a Python module can be either a `.py` file or a directory, PyInstaller
    can't be sure which one constitutes the `qtictactoe` module, so having the same
    name for both will fail.
  prefs: []
  type: TYPE_NORMAL
- en: 'The correct approach is to use the `--name` switch when creating our `.spec`
    file or running `pyinstaller`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'This will create `qtictactoe.spec` and set the `name` arguments of `EXE` and
    `COLLECT` to `qtictactoe`, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: This can, of course, be done manually by editing the `.spec` file as well.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with non-Python files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our program runs, but we''re back to the old problem of the `''X''` and `''O''`
    images not showing up. There are two problems here: first, our PNG files aren''t
    being made part of the distribution and, second, the program can''t find them
    even when they are.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To deal with the first problem, we have to tell PyInstaller to include our
    files in the `datas` table during the `Analysis` phase of the build. We can do
    that in the command line, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: The `--add-data` argument takes a source path and a destination path separated
    by either a colon (on macOS and Linux) or a semicolon (on Windows). The source
    path is relative to the project root where we're running `pyinstaller` (`QTicTacToe`,
    in this case), and the destination path is relative to the distribution root folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we don''t want to make a long, complex command line, we can also update
    the `Analysis` section of the `qtictactoe.spec` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Here, the source and destination paths are just a tuple inside the `datas` list.
    The source value can also be a pattern such as `qtictactoe/images/*.png`. If you
    run `pyinstaller qtictactoe.spec` with these changes, you should find an `images`
    directory in `dist/qtictactoe`, which contains our PNG files.
  prefs: []
  type: TYPE_NORMAL
- en: This has solved the first problem with the images, but we still need to solve
    the second. In the *Distributing with setuptools* section, we solved the problem
    of locating our PNG files by using the `__file__` built-in variable. However,
    when you are running from a PyInstaller executable, the value of `__file__` is
    *not* the path to the executable; it's actually a path to a temporary directory
    where the executable unpacks the compressed bytecode. The location of this directory
    changes depending on whether we are in one-file or one-directory mode as well.
    To work around this problem, we'll need to update our code to detect whether the
    program has been made into an executable and, if so, use a different method to
    locate the files.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we run PyInstaller executables, PyInstaller adds two properties to the
    `sys` module to help us:'
  prefs: []
  type: TYPE_NORMAL
- en: The `sys.frozen` property, which is given a value of `True`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `sys._MEIPASS` property, which stores the path to the executable directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Thus, we can update our code in `board.py` to something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Now, when executing from a frozen PyInstaller environment, our code will be
    able to locate the files correctly. Re-run `pyinstaller qtictactoe.spec` and you
    should find that the `X` and `O` graphics display correctly. Hooray!
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned before, the far better solution in a PyQt5 application is to use
    the Qt Resource files discussed in [Chapter 6](c3eb2567-0e73-4c37-9a9e-a0e2311e106c.xhtml),
    *Styling Qt Applications*. For non-PyQt programs, the `setuptools` library has
    a tool called `pkg_resources` that might be helpful.
  prefs: []
  type: TYPE_NORMAL
- en: Further debugging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If your build continues to have trouble, there are a couple of ways to get more
    information about what's going on.
  prefs: []
  type: TYPE_NORMAL
- en: First, make sure your code runs correctly as a Python script. If there is a
    syntax error or other code problem in any of your module files, the distribution
    will be built without them. These omissions will neither halt the build nor be
    mentioned in the command-line output.
  prefs: []
  type: TYPE_NORMAL
- en: 'After confirming that, check the build directory for details on what PyInstaller
    is doing. Under `build/projectname/`, you should see a number of files that can
    help you debug, including these:'
  prefs: []
  type: TYPE_NORMAL
- en: '`warn-projectname.txt`: This contains warnings output by the `Analysis` process.
    Some of these are meaningless (often just failures to locate platform-specific
    libraries that don''t exist on your platform), but if libraries have errors or
    are not being found, those issues will be logged here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.toc` files: These contain the tables of contents created during the phases
    of the build process; for example, `Analysis-00.toc` shows the tables found in
    `Analysis()`. You can examine these to see whether the project''s dependencies
    are being incorrectly identified or pulled from an incorrect location.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`base_library.zip`: This archive should contain Python bytecode files for all
    the pure Python modules used by your application. You can inspect this to see
    whether anything is missing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you need more verbose output, you can use the `--log-level` switch to increase
    the detail of the output to `warn-projectname.txt`. A setting of `DEBUG` will
    provide more details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: More debugging tips can be found at [https://pyinstaller.readthedocs.io/en/latest/when-things-go-wrong.html](https://pyinstaller.readthedocs.io/en/latest/when-things-go-wrong.html).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to share your projects with others. You learned
    the optimal layout for your project directory to enable you to collaborate with
    other Python coders and Python tools. You learned how to work with `setuptools`
    to make distributable Python packages for sites such as PyPI. Finally, you learned
    how to convert your code into executables using PyInstaller.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You have finished this book. By now, you should feel confident
    in your ability to develop a compelling GUI application from scratch using Python
    and PyQt5\. From basic input forms to advanced network, database, and multimedia
    applications, you now have the tools to create and distribute amazing programs.
    Even with all the topics we've covered, there's still much more to discover inside
    PyQt. Keep learning, and make great things!
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Try answering these questions to test your knowledge from this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: You have written a PyQt application in a file called `Scan & Print Tool-box.py`.
    You want to convert this into a module-style organization; what change should
    you make?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Your PyQt5 database application has a set of `.sql` files containing queries
    used by the application. It worked when your app was a single script in the same
    directories as the `.sql` files, but now that you've converted it to a module-style
    organization, the queries can't be found. What should you do?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You're writing a detailed `README.rst` file to document your new application
    before uploading it to a code-sharing site. What characters should be used to
    underline your level 1, 2, and 3 headings, respectively?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You're creating a `setup.py` script for your project so that you can upload
    it to PyPI. You would like to include a URL for the project's FAQ page. How can
    you accomplish this?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You have specified `include_package_data=True` in your `setup.py` file, but
    for some reason, the `docs` folder is not being included in your distribution
    package. What's wrong?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You ran `pyinstaller fight_fighter3.py` to package your new game as an executable.
    Something went wrong, though; where can you find a log of the build process?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Despite the name, PyInstaller cannot actually generate installer programs or
    packages for your application. Research some options for your platform of choice.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For further information, please refer to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A tutorial on `ReStructuredText` markup can be found at [http://docutils.sourceforge.net/docs/user/rst/quickstart.html](http://docutils.sourceforge.net/docs/user/rst/quickstart.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More information on designing, structuring, documenting, and packaging Python
    GUI applications can be found in this author's first book, *Python GUI programming
    with Tkinter*, available from *Packt Publications*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you're interested in publishing a package to PyPI, see [https://blog.jetbrains.com/pycharm/2017/05/how-to-publish-your-package-on-pypi/](https://blog.jetbrains.com/pycharm/2017/05/how-to-publish-your-package-on-pypi/)
    for a tutorial on the process.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A better solution to the problem of including images in a Python library for
    a non-PyQt code is the `pkg_resources` tool provided by `setuptools`. You can
    read about it at [https://setuptools.readthedocs.io/en/latest/pkg_resources.html](https://setuptools.readthedocs.io/en/latest/pkg_resources.html).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advanced usage of PyInstaller is documented in the PyInstaller manual found
    at [https://pyinstaller.readthedocs.io/en/stable/](https://pyinstaller.readthedocs.io/en/stable/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
