- en: Chapter 9. Reporting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Converting Nmap XML to CSV
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extracting links from URLs to Maltego
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extracting e-mails to Maltego
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parsing Sslscan to CSV
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating graphs using `plot.ly`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ve got recipes throughout this book to perform various aspects of web application
    testing. So, we’ve got all this information. We’ve got console outputs from our
    recipes, but how do we collect all this into a useful format? Ideally, we’ll want
    the output to be in a format that we can use. Or we might want to convert the
    output from another application such as Nmap, into the format that we’re using.
    This can either be as **comma separated variables** (**CSV**), or possibly a Maltego
    transform, or any other format that you want to work with.
  prefs: []
  type: TYPE_NORMAL
- en: What’s this Maltego thing you just mentioned? I hear you ask. Maltego is an
    **Open Source Intelligence** (**OSINT**) and forensics application. It has a nice
    GUI that helps you visualize your information in a nice, pretty, and easy to understand
    way.
  prefs: []
  type: TYPE_NORMAL
- en: Converting Nmap XML to CSV
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nmap is a common tool used in the reconnaissance phase of a web application
    test. It is normally used to scan ports with a variety of options to help you
    customise the scan to exactly how you like it. For instance, do you want to do
    TCP or UDP? What TCP flags do you want to set? Is there a particular Nmap script
    that you would like to run, such as checking for **Network Time Protocol** (**NTP**)
    reflection, but on a non-default port? The list can be endless.
  prefs: []
  type: TYPE_NORMAL
- en: The Nmap output is easy to read, but not very easy to use in a programmatic
    way. This simple recipe will convert XML output from Nmap (through the use of
    the –oX flag when running an Nmap scan) and convert it to CSV output.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While this recipe is very simple in its implementation, you will need to install
    Python’s `nmap` module. You can do this by using `pip` or building it from the
    source files. You will also need XML output from an Nmap scan. You can get this
    from scanning a vulnerable virtual machine of your choice or a site that you have
    permission to run a scan on. You can use Nmap as it is or you can use Python’s
    `nmap` module to do this within a Python script.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Like I mentioned earlier, this recipe is very simple. This is mainly due to
    the fact that the `nmap` library has done most of the hard work for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the script that we are going to use for this task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So, after the importing of necessary modules, we have to initialize an Nmap’s
    `Portscanner` function. Although we won’t be doing any port scanning within this
    recipe, this is necessary to allow us to use the methods within the object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we have a `with` statement. What’s one of those? Previously, when you
    opened files in Python, you would have to remember to close it once you were finished.
    In this situation, the `with` statement will do that for you once all the code
    within it has been executed. It’s great if you don’t have a great memory and keep
    forgetting to close files in your code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'After the `with` statement, we read the contents of the file into a `content`
    variable (we could call this variable whatever we want, but why overcomplicate
    things?):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the `Portscanner` object we created earlier, we can now analyze the contents
    with a method that will parse the XML output we have provided, which we can then
    print out as a CSV:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Extracting links from a URL to Maltego
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is another recipe in this book that illustrates how to use the `BeautifulSoup`
    library to programmatically get domain names. This recipe will show you how to
    create a local Maltego transform, which you can then use within Maltego itself
    to generate information in an easy to use, graphical way. With the links gathered
    from this transform, this can then also be used as part of a larger spidering
    or crawling solution.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following code shows how you can create a script that will output the enumerated
    information into the correct format for Maltego:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First we import all the necessary modules for this recipe. You may have noticed
    that for `BeautifulSoup`, we have the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This is so that when we use `BeautifulSoup`, we just have to type `BeautifulSoup`
    instead of `bs4.BeautifulSoup`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then assign the target URL supplied in the argument into a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have done that, we check to see whether the target URL ends in a `/`.
    If it does, then we remove the last character by replacing the `tarurl` variable
    with all but the last character of `tarurl`, so that it can be used later on in
    the recipe when outputting relative links in full:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We then print out the tags that form part of a Maltego transform response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We then open the target `url` with `urllib2` and store this within `BeautifulSoup`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We now use soup to find all `<a>` tags. More specifically, we will be looking
    for the `<a>` tags with hypertext references (links):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If the first four characters of the link are `http`, we’ll output it into the
    correct format as an entity for Maltego:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If the first character is a `/`, which indicates that the link is a relative
    link, then we’ll output it to the correct format after we have prepended the target
    URL to the link. While this recipe shows how to deal with one example of a relative
    link, it is important to note that there are other types of relative links, such
    as just a filename (`example.php`), a directory, and also a relative path dot
    notation (`../../example.php`), as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'After we have processed all the links on the page, we close all the tags that
    we opened at the start of the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `BeautifulSoup` library contains other functions that could make your code
    simpler. One of these functions is called **SoupStrainer**. SoupStrainer will
    allow you to parse only the parts of the document that you want. We have left
    this as an exercise for you to explore.
  prefs: []
  type: TYPE_NORMAL
- en: Extracting e-mails to Maltego
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is another recipe in this book that illustrates how to extract e-mails
    from a website. This recipe will show you how to create a local Maltego transform,
    which you can then use within Maltego itself to generate information. It can be
    used in conjunction with URL spidering transforms to pull e-mails from entire
    websites.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following code shows how to extract e-mails from a website through the
    use of regular expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The top of the script imports the necessary modules. After this, we then assign
    the URL supplied as an argument to a variable and open the `url` list using `urllib2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We then create a regular expression that matches the format of a standard e-mail
    address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The preceding regular expression should match e-mail addresses in the format
    `email@address.com` or e-mail at address dot com.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then output the tags required for a valid Maltego transform output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we find all instances of text that match our regular expression inside
    the `url` content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We then take each e-mail address we have found and output it in the correct
    format for a Maltego transform response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We then close the open tags that we opened earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Parsing Sslscan into CSV
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sslscan is a tool used to enumerate the ciphers supported by HTTPS sites. Knowing
    the ciphers that are supported by a site is useful in web application testing.
    This is even more useful in a penetration test if some of the supported ciphers
    are weak.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This recipe will run Sslscan on a specified IP address and output the results
    into a CSV format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We first import the necessary modules and assign the filename supplied in the
    argument to a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The filename supplied should point to a file containing a list of IP addresses.
    We open this file as read-only:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We then open up a file for reading and writing output by using `w+` instead
    of `r`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our input and somewhere to write our output, we’re ready to
    rock and roll. We start by iterating through the IP addresses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'For each IP, we run Sslscan:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We then split up the output from the command into chunks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We then go through the output, line by line. If the line contains the word
    `Accepted`, then we arrange the elements of the line for CSV output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, if for any reason the attempt to run the SSL scan on the IP fails,
    we simply move on to the next IP address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Generating graphs using plot.ly
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes it’s really nice to have a visual representation of your data. In
    this recipe, we are going to look at using the `plot.ly` python API to generate
    a nice graph.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we will be using the `plot.ly` API to generate our graph. If
    you don’t already have one, you’ll need to sign up for an account at [https://plot.ly](https://plot.ly).
  prefs: []
  type: TYPE_NORMAL
- en: Once you have an account, you will need to prepare your environment for using
    `plot.ly`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The easiest way is to use `pip` to install it, so simply run the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you will need to run the following command (substituting the `{username}`,
    `{apikey}`, and `{streamids}` with your own, which are viewable under your account
    subscriptions on the `plot.ly` site):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are following along with this example, I used the `pcap` file that is
    available online here for testing: [http://www.snaketrap.co.uk/pcaps/hbot.pcap](http://www.snaketrap.co.uk/pcaps/hbot.pcap).'
  prefs: []
  type: TYPE_NORMAL
- en: We will be enumerating all the FTP packets from the `pcap` file and plotting
    them against time.
  prefs: []
  type: TYPE_NORMAL
- en: To parse the `pcap` file, we will be using the `dpkt` module. Like `Scapy`,
    which has been used in earlier recipes, `dpkt` can be use to parse and manipulate
    packets.
  prefs: []
  type: TYPE_NORMAL
- en: 'The easiest way is to use `pip` to install it. Simply run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This recipe will read a `pcap` file and extract the dates and times of any
    FTP packets before plotting this data to a graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We first import the necessary modules and assign the filename of our `pcap`
    file to a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we set up our lists that we will populate when we iterate over our `pcap`
    file. The `Full_datetime_list` variable will hold all the FTP packets dates while
    `dates` we will use to hold unique `datetime` from the full list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We then open up the `pcap` file for reading and iterate over it in a `for`
    loop. This section checks that the packet is an FTP packet and if it is, it then
    appends the time to our array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our list of `datetime` function for the FTP traffic, we can
    get the unique `datetime` function out of it and populate our `dates` array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We then sort the dates, so that they are in order on our graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we simply iterate over the unique dates and count all the packets sent/received
    during that time from our larger array and populate our counter array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'All that is left to do is make an API call to `plot.ly`, using our date array
    and count the array as the data points:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run the script, it should pop open the browser to your newly created
    `plot.ly` graph, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/B04044_09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: And that’s all there is to it. `plot.ly` has a lot of different methods to visualize
    your data and it is well worth having a play around with it. Think of how impressed
    your boss will be when they see all the pretty graphs that you start sending them.
  prefs: []
  type: TYPE_NORMAL
