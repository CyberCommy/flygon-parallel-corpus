- en: Chapter 2. Getting to Know Ansible Modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ansible modules are reusable piece of code that can be invoked using the Ansible
    API or through the Ansible Playbook. Modules form the backbone of Ansible. These
    are simple pieces of code that can be written in any language.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will introduce you to writing Ansible modules. The chapter is
    organized in four sections:'
  prefs: []
  type: TYPE_NORMAL
- en: Writing your first Ansible module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The module writing helper
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing facts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing and debugging modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing your first Ansible module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Ansible modules can be written in any language, though there are a few commandments
    one needs to abide by while writing them. These are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The module must output only valid JSON.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modules should be self-contained in one file to be automatically transferred
    by Ansible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Include as few dependencies as possible. If dependencies exist, document them
    at the top of the module file, and have the module raise the JSON error message
    when the import fails.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Execution environment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To write your own Ansible module, you first need to understand the execution
    environment (that is, where and how will your script execute).
  prefs: []
  type: TYPE_NORMAL
- en: Ansible executes the scripts or the play on the target machine. Thus, your script,
    or the compiled binary, will be copied over to the target machine and then executed.
    Beware that Ansible simply copies over the module files and generated code for
    the play on the target machine and makes no attempts to resolve any necessary
    dependencies. Hence, it is recommended to include as few dependencies as possible
    in your Ansible module file. Any dependencies in the module need to be properly
    documented and handled during or before the Ansible play.
  prefs: []
  type: TYPE_NORMAL
- en: Step 1 – module placement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once you have your module file ready, you need to know exactly where you should
    place it in order to use the module in the Ansible playbooks.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can place your module in different places where Ansible looks for modules:'
  prefs: []
  type: TYPE_NORMAL
- en: A path specified by the `library` variable in the configuration file, located
    at `/etc/ansible/ansible.cfg`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A path specified by the `–module-path` argument in the command line
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inside the `library` directory at the root of an Ansible playbook
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inside the `library` directory of the role, if used
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a basic Bash module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since Ansible modules can be written in any language, we will first try to write
    one simple Ansible module in Bash.
  prefs: []
  type: TYPE_NORMAL
- en: The first Bash module we will write will simply check for the target machine
    uptime and return output in JSON, as required by any Ansible module. We will name
    the module `chkuptime` and write a playbook to execute the same module on the
    target machine.
  prefs: []
  type: TYPE_NORMAL
- en: This module will be placed in the `library` directory in the root of the Ansible
    playbook and will be automatically included by Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a basic Bash module, which checks the uptime of a target machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Bash Module Code**: (`library/chkuptime`)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: For Ansible to include the above module code to be looked up while executing
    an Ansible playbook, we place it in the `library` directory in the root of the
    Ansible playbook.
  prefs: []
  type: TYPE_NORMAL
- en: To run this against a target host group, we will create an inventory file named
    `hosts`, which will include a grouped list of target machines. To test the module,
    we run it against only one target host.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will create an Ansible play for executing the newly created module.
    We name the play `basic_uptime.yml`.
  prefs: []
  type: TYPE_NORMAL
- en: '`basic_uptime.yml`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Directory structure of the playbook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Inventory File (`hosts`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we run this play, and it should return with the uptime of the target machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Reading arguments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you notice the above module, it does not accept any arguments. Let's call
    such a module a `static` module. The module is very limited in its functionality
    and behavior; otherwise, output cannot be altered. The module will execute on
    the target machine and return a fixed output. If the user is expecting output
    in some other form, this module is useless. The module provides no flexibility
    to the user. For the user to get an output as he or she desires, he or she will
    either have to search for an alternate of this module (if one exists), or else
    write one him or herself.
  prefs: []
  type: TYPE_NORMAL
- en: To make a module more flexible, it should be able to respond to the user requirements,
    modify the output as required, or at least provide ways by which a user can interact
    with it. This is done by allowing a module to accept arguments. Values to these
    arguments are specified by the user at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: The arguments, as expected by the module, should be well-defined. The arguments
    should also be well documented–both for code documentation as well as for generating
    module documentation. Argument type and default values (if any) should be explicitly
    defined.
  prefs: []
  type: TYPE_NORMAL
- en: Since a module can be written in any language, there can be different ways in
    which an Ansible module accepts an argument on the code level. However, passing
    arguments from the Ansible playbook remains unchanged irrespective of what language
    the module was written in. In Bash, the arguments are stored in variables with
    a number in the order of arguments at 1\. For example, with a first argument of
    $1, a second argument would be $2 and so on. However, argument type and default
    values for the argument need to be handled in the code itself. Ansible provides
    a Python API, which provides a better way of handling arguments. It allows you
    to explicitly define the type of argument, mandate an argument, and even specify
    a default value to the argument. Handling arguments through the Python API will
    be covered later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We will extend the last module to accept a user argument to print the system
    uptime in a more detailed format. Using the `detailed` flag, the user may request
    to print the uptime in full (that is days, hours, minutes, seconds), while the
    previous format (that is days, hours) is preserved if the `detailed` flag is omitted.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the extension of the `chkuptime` module, which returns output
    based on the user-specified value of the `detailed` flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Bash module**: (`library/chkuptime`)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The only change required in the Ansible play is to pass a Bool type `detailed`
    argument to the module when it's called.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible Play `(uptime_arg.yml)`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Executing the play, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: If you compare the output with the previous Ansible play's output, the uptime
    now includes minutes and seconds, which was missing in the previous example. The
    previous output can also be achieved by the new module by setting the `detailed`
    flag as false.
  prefs: []
  type: TYPE_NORMAL
- en: Handling errors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have already learned how to create a custom module and read user inputs.
    Since modules are designed to perform some function on the target machine, there
    are chances it may fail sometimes. Reasons for failure may range from a permission
    issue on the target machine to invalid user input, or anything else. Whatever
    the reason may be, your module should be able to handle errors and failures and
    return an error message with proper information for the user to understand the
    root cause. All failures should be explicitly reported by including `failed` in
    return data.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, let's create a simple module that accepts a process name from
    the user and returns it whether the specified service is running on the target
    machine or not. If the service is running, it simply returns a message containing
    the process ID of the requested process. If not, it explicitly fails the module
    execution by returning `failed` as `true`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a sample module that includes `failed` in the return data
    and explicitly fails the module execution:'
  prefs: []
  type: TYPE_NORMAL
- en: Module `library/chkprocess`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '**Ansible play** `chkprocess.yml`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we will be checking if the specified `httpd` process is running
    on the target host. If not, this should fail the Ansible run.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now execute the Ansible play against the target machines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As you may notice, since the `httpd` process was not running on the target host,
    Ansible failed the run as requested. Also, there was a meaningful message displayed
    in order to inform the user of the root cause of the failure.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Ansible modules in Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, you are familiar with the basic concepts of writing an Ansible
    module. We have also gone over some sample Ansible modules that were written in
    Bash.
  prefs: []
  type: TYPE_NORMAL
- en: While it's possible to write Ansible modules in any language, Ansible provides
    a friendlier environment for those written in Python.
  prefs: []
  type: TYPE_NORMAL
- en: While writing modules in different languages, as observed above, tasks like
    handling arguments, handling failures, checking inputs, and so on were handled
    in the module code itself. In Python, Ansible provides a few helpers and syntactic
    sugar to perform common tasks. For example, you do not need to parse the arguments
    as shown in the previous examples.
  prefs: []
  type: TYPE_NORMAL
- en: Common routines provided by Ansible are capable of handling return statuses,
    errors, failures, and check inputs. This syntactic sugar comes from the AnsibleModule
    boilerplate. Using the AnsibleModule boilerplate, you can handle arguments and
    return statuses in a much more efficient way. This will help you concentrate more
    on the module rather than having to put in explicit checks on inputs.
  prefs: []
  type: TYPE_NORMAL
- en: Let's get a better understanding of the AnsibleModule boilerplate.
  prefs: []
  type: TYPE_NORMAL
- en: The AnsibleModule boilerplate
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to benefit from the AnsibleModule boilerplate, all you need to do is
    import `ansible.module_utils.basic`.
  prefs: []
  type: TYPE_NORMAL
- en: Put the import at the end of the file, and make sure your actual module body
    is contained inside the conventional `main` function.
  prefs: []
  type: TYPE_NORMAL
- en: The AnsibleModule boilerplate also offers a specification language for the module
    arguments. It allows you to specify if the arguments are optional or required.
    It also handles a few data types such as enumeration.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code, the module accepts a mandatory argument, `username`,
    specified by the setting `required=True`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The object `module` uses a common function, `exit_json`, which returns `true`
    and also returns a success message to Ansible. The `module` object provides a
    set of common functions such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '`run_command`: This function runs an external command and gets a return code,
    `stdout`, `stderr`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`exit_json`: This function returns a success message to Ansible'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fail_json`: This function returns a failure and error message to Ansible'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arguments can be accessed by the `module.params` instance variable. There will
    be a key value pair for each argument.
  prefs: []
  type: TYPE_NORMAL
- en: The `AnsibleModule` helper, while parsing the arguments, will perform a series
    of validations and requested type conversions. The argument specification dictionary
    describes each possible argument to the module. An argument can be optional or
    required. Optional arguments may have a default value. Also, the possible inputs
    to a particular argument can be restricted using the `choice` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: Documenting modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are writing a module, it is very important to document it properly. Documentation
    is required for better understanding of what the module does. It is always recommended
    to document a module.
  prefs: []
  type: TYPE_NORMAL
- en: All you need to do is include a `DOCUMENTATION` global variable in your module
    file as shown in the following code. The contents of this variable should be a
    valid YAML.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This documentation can be read using the `ansible-doc` command. Unfortunately,
    this currently works only for Python-based modules.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to documentation outlining every option in detail, it is a good
    idea to provide a few examples that may cover some basic use cases for the module.
    This might be done by adding another global variable named `EXAMPLES`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Let's implement the AnsibleModule boilerplate and the preceding documentation
    in an Ansible module that checks if the user exists on the target machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a sample Ansible module, `chkuser`, built using the AnsibleModule
    boilerplate. The module also contains module documentation along with usage examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Module name**: `chkuser`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'To use this module, we create an Ansible play, which passes a username as an
    argument to the `chkuser` module, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ansible Play** : `chkuser.yml`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Executing the play against the target machine returns a message stating whether
    the queried user exists on the target machine or not.
  prefs: []
  type: TYPE_NORMAL
- en: Testing and debugging modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Writing modules was easy, but developing a module is not enough. You need to
    test if the module performs all operations as expected under all circumstances.
  prefs: []
  type: TYPE_NORMAL
- en: It's hard to get something right in the first attempt. Trying out things while
    you are working on them is a common technique. It's one of the main reasons why
    dynamic programming and programming environments with short edit and execute cycles
    have become very popular.
  prefs: []
  type: TYPE_NORMAL
- en: The next section, *Quick local execution*, deals with the problem of running
    your modules locally, isolated as much as possible from your Ansible environment.
    This can be of great help during early development and debugging.
  prefs: []
  type: TYPE_NORMAL
- en: Quick local execution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While developing a module, you might want to shorten your edit/run cycle and
    skip the overhead of actually executing your module through Ansible. As we saw
    in our previous Bash examples, the execution environment is very simple, and it's
    pretty straightforward to run the scripts in isolation until you get them right.
  prefs: []
  type: TYPE_NORMAL
- en: However, things get trickier with Python modules using the AnsibleModule boilerplate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ansible performs some black magic under the hood of your Python script in order
    to not require Ansible components to be installed on the target machine. You can
    explore this technique by employing two simple tricks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Executing this module locally will generate the file `/tmp/magicmirror`, which
    contains code that has been augmented by lining parts of Ansible runtime. It allows
    you to benefit from shared functionality and avoid introducing dependencies on
    the target machine.
  prefs: []
  type: TYPE_NORMAL
- en: Another way is to set the environment variable, `ANSIBLE_KEEP_REMOTE_FILES=1`,
    on the controller host to prevent Ansible from cleaning up the remote machine
    by not deleting the generated Ansible scripts, which can then be used for debugging
    your module.
  prefs: []
  type: TYPE_NORMAL
- en: Best practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A module can always be improved by following some best practices while they
    are being developed. This helps in keeping the modules sanitized and easy to understand
    and extend when required. Some of the best practices which should be followed
    are:'
  prefs: []
  type: TYPE_NORMAL
- en: The module must be self-contained
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reduce the dependencies to the minimum
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write the error cause in the `msg` key
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Try to return only useful output
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And don't forget the most important part of developing a module–it should return
    a valid JSON.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned the basics of writing a module. You grew to understand
    module placements and things to keep in mind while developing custom modules.
    You went through writing modules in Bash and moved forward with understanding
    the AnsibleModule boilerplate, hence ending up developing sample Ansible modules
    both in Bash and Python. The chapter also covered the best practices that should
    be followed.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will understand error handling and go through a real-life
    scenario where you can create an Ansible module and exploit the power of Ansible.
    The next chapter will also cover some complex data structures with Ansible.
  prefs: []
  type: TYPE_NORMAL
