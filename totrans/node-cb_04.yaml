- en: Chapter 4. Interfacing with Databases
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Writing to a CSV file
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting and sending SQL to a MySQL server
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing and retrieving data with MongoDB
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing and retrieving data with Mongoskin
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing data to CouchDB with Cradle
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retrieving data from CouchDB with Cradle
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing CouchDB changes stream with Cradle
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing and retrieving data with Redis
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing PubSub with Redis
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the complexity of our code and the demands of our objectives increase, we
    soon realize the need for a place to store our data.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: 'We then have to ask the question: What is the best way to store our data? The
    answer depends on the type of data we are working with since different challenges
    require different solutions.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: If we're doing something very simple, we could save our data as a flat CSV file,
    which has the added benefit of enabling users to view the CSV file in a spreadsheet
    application.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: If we are working with data that has clearly relational qualities, for instance
    accounting data whereby there are clear, distinct relationships between two sides
    of a transaction, then we would choose a relational database such as the popular
    MySQL.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: In many cases relational databases became a de facto standard for nearly all
    data scenarios. This led to the necessity of imposing relationships upon otherwise
    loosely-related data (such as website content) in an attempt to squeeze it into
    our relational mental model.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: In recent times, though, there has been a movement away from relational databases
    towards NoSQL, a non-relational paradigm. The driving force being that we tailor
    our technology to best suit our data rather than trying to fit our data into our
    technology.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will look into various data storage technologies with examples
    of their usage in Node.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Writing to a CSV file
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A flat file structure is one of the most elementary database models. Columns
    can either be fixed length, or use delimiters. The Comma Separated Values (CSV)
    convention conforms to the idea of delimited flat file structure databases. While
    it's called CSV, the term CSV is also applied as a broad blanket term for any
    basic delimited structure consisting of one record per line (for example, tab-separated
    values).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: 'We could follow a brittle approach for constructing CSV structures, simply
    by using a multidimensional array and the `join` method:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: However, the limitations of this technique quickly become apparent. What if
    one of our fields contains a comma? Now one field becomes two, thus corrupting
    our data. Furthermore, we are limited to just using commas as delimiters.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe we will use the third-party `ya-csv` module to store data in
    the CSV format.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's create a file called `write_to_csv.js`, we'll also need to retrieve `ya-csv`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: How to do it...
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We require the `ya-csv` module, call its `createCsvFileWriter` method to instantiate
    a CSV file writer and loop through our array, calling the `writeRecord` method
    of the CSV file writer:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Let's take a look at the file we saved to, `data.csv:`
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: How it works...
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The difficulty with writing to and reading from CSV files is the edge cases,
    such as commas or quotes embedded in text. `ya-csv` handles these edge cases for
    us.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: We load an instance of `CsvWriter` of `ya-csv` into the `writer` variable with
    `createCsvFileWriter`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: Then we simply loop through each array as `rec`, passing it to the `writeRecord`
    method of `CsvWriter` of `ya-csv`. Behind the scenes it re-factors each array
    and passes it to an instance of `fs.WriteStream`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: This recipe depends upon us using a basic data structure in our code. Multidimensional
    objects would have to be massaged into the right format as `writeRecord` only
    functions with arrays.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Could we easily create this functionality ourselves? Without a doubt. However,
    `ya-csv` provides an API for us to seamlessly customize the elements of our CSV
    files, and implements the more involved CSV parsing functionality.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Customizing the CSV elements
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If we save our recipe file as `write_to_custom_csv.js`, and pass an `options`
    object to `createCsvFileWriter`, we can alter the way our CSV files are constructed:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将我们的配方文件保存为 `write_to_custom_csv.js`，并将一个 `options` 对象传递给 `createCsvFileWriter`，我们可以改变我们的
    CSV 文件构造方式：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Notice the `escape` option. This sets the character which will prevent accidental
    closure of a CSV field. Let''s slip one into our array to see how `ya-csv` handles
    it:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `escape` 选项。这将设置防止意外关闭 CSV 字段的字符。让我们将其插入到我们的数组中，看看 `ya-csv` 如何处理它：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: After running our new code, let's take a look at `custom_data.csv:`
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 运行我们的新代码后，让我们看看 `custom_data.csv`：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: See how our pipe character in the `e` field has another pipe appended to it
    in order to escape it.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 看看我们在 `e` 字段中的管道字符后面添加了另一个管道以进行转义。
- en: Reading a CSV file
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 读取 CSV 文件
- en: We can also use `ya-csv` to read from a CSV file, its built-in parser converts
    each CSV record back into an array. Let's make `read_from_csv.js`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用 `ya-csv` 从 CSV 文件中读取，其内置解析器将每个 CSV 记录转换回数组。让我们制作 `read_from_csv.js`。
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If we want it to parse alternative delimiters and quotes, we simply pass these
    into the `options` object of `createCsvFileReader:`
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望解析替代分隔符和引号，我们只需将它们传递到 `createCsvFileReader` 的 `options` 对象中：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Manipulating CSV as a stream
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 操作 CSV 作为流
- en: '`ya-csv` interacts with CSV files as streams. This can reduce operational memory
    since streams allow us to process small chunks of information as they are loaded,
    instead of buffering the entire file into memory first.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`ya-csv` 与 CSV 文件交互作为流。这可以减少操作内存，因为流允许我们在加载时处理小块信息，而不是首先将整个文件缓冲到内存中。'
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: See also
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Connecting and sending SQL to a MySQL* server discussed in this chapter'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在本章中讨论了连接并向 MySQL 服务器发送 SQL*'
- en: '*Storing and retrieving data with Mongoskin* discussed in this chapter'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在本章中讨论了使用 Mongoskin 存储和检索数据*'
- en: '*Storing data to CouchDB with Cradle* discussed in this chapter'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 Cradle 将数据存储到 CouchDB* 在本章中讨论'
- en: '*Storing and retrieving data with Redis* discussed in this chapter'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在本章中讨论了使用 Redis 存储和检索数据*'
- en: Connecting and sending SQL to a MySQL server
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接并向 MySQL 服务器发送 SQL
- en: Structured Query Language has been a standard since 1986 and it's the prevailing
    language for relational databases. MySQL is the most popular SQL relational database
    server around, often appearing in the prevalent LAMP (Linux Apache MySQL PHP)
    stack.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 自1986年以来，结构化查询语言一直是标准，也是关系数据库的主要语言。MySQL 是最流行的 SQL 关系数据库服务器，经常出现在流行的 LAMP（Linux
    Apache MySQL PHP）堆栈中。
- en: If a relational database was conceptually relevant to our goals in a new project,
    or we were migrating a MySQL-backed project from another framework to Node, the
    third-party `mysql` module would be particularly useful.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果关系数据库在新项目的目标中概念上相关，或者我们正在将基于 MySQL 的项目从另一个框架迁移到 Node，第三方 `mysql` 模块将特别有用。
- en: In this task, we will discover how to connect to a MySQL server with Node and
    execute SQL queries across the wire.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个任务中，我们将发现如何使用 Node 连接到 MySQL 服务器并在网络上执行 SQL 查询。
- en: Getting ready
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Let's grab `mysql`, which is a pure JavaScript (as opposed to C++ bound) MySQL
    client module.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们获取 `mysql`，这是一个纯 JavaScript（而不是 C++ 绑定）的 MySQL 客户端模块。
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We'll need a MySQL server to connect to. By default, the `mysql` client module
    connects to `localhost`, so we'll have MySQL running locally.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个 MySQL 服务器进行连接。默认情况下，`mysql` 客户端模块连接到 `localhost`，因此我们将在本地运行 MySQL。
- en: 'On Linux and Mac OSX we can see if MySQL is already installed with the following
    command:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 和 Mac OSX 上，我们可以使用以下命令查看 MySQL 是否已安装：
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'And we can see if it is running using the following command:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令查看它是否正在运行：
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If it is installed but not running, we can do:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果已安装但未运行，我们可以执行：
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If MySQL isn't installed we can use the relevant package manager for our system
    (homebrew, apt-get/synaptic, yum, and so on), or if we're using Node on Windows
    we can head to [http://dev.mysql.com/downloads/mysql](http://dev.mysql.com/downloads/mysql)
    and download the installer.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 MySQL 没有安装，我们可以使用系统的相关软件包管理器（homebrew、apt-get/synaptic、yum 等），或者如果我们在 Windows
    上使用 Node，我们可以前往 [http://dev.mysql.com/downloads/mysql](http://dev.mysql.com/downloads/mysql)
    并下载安装程序。
- en: Once we're ready to go, let's create a file and call it `mysql.js`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们准备好，让我们创建一个文件并将其命名为 `mysql.js`。
- en: How to do it...
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'First, we require the third-party `mysql` driver, and create a connection to
    the server:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要第三方的 `mysql` 驱动程序，并创建与服务器的连接：
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We need a database to connect to. Let''s keep things interesting and make a
    `quotes` database. We can do that by passing SQL to the `query` method:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要连接的数据库。让我们保持有趣，创建一个 `quotes` 数据库。我们可以通过将 SQL 传递给 `query` 方法来实现：
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We've also called the `useDatabase` method to connect to the database, although
    we could achieve the same with `client.query('USE quotes')`. Now we'll create
    a table by the same name.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还调用了 `useDatabase` 方法来连接到数据库，尽管我们可以通过 `client.query('USE quotes')` 实现相同的效果。现在我们将创建一个同名的表。
- en: '[PRE16]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If we were to run our code more than once, we'd notice that an unhandled error
    is thrown and the program fails. This is due to the `mysql` driver emitting an
    error event in reflection of a MySQL server error. It's throwing an unhandled
    error because the `quotes` database (and table) cannot be created as they already
    exist.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行我们的代码超过一次，我们会注意到一个未处理的错误被抛出，程序失败。这是因为 `mysql` 驱动程序发出了一个错误事件，反映了 MySQL
    服务器的错误。它抛出了一个未处理的错误，因为 `quotes` 数据库（和表）无法创建，因为它们已经存在。
- en: 'We want our code to be versatile enough to create a database if necessary,
    but not throw an error if it''s not there. To do this, we''re going to catch any
    errors emitted by our client instance, filtering out the database/table exists
    errors:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望我们的代码足够灵活，可以在必要时创建数据库，但如果不存在则不会抛出错误。为此，我们将捕获客户端实例发出的任何错误，过滤掉数据库/表存在的错误：
- en: '[PRE17]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We'll place our error catcher just before the `client.query` method invocations.
    Finally, at the end of our code, we'll insert our first quote into the table and
    send a `COM_QUIT` packet (using `client.end)` to the MySQL server. This will only
    close the connection once all queued SQL has been executed.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`client.query`方法调用之前放置我们的错误捕获器。最后，在我们的代码末尾，我们将向表中插入我们的第一条引用，并发送一个`COM_QUIT`数据包（使用`client.end`）到MySQL服务器。这将只在所有排队的SQL被执行后关闭连接。
- en: '[PRE18]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: How it works...
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `createClient` method establishes a connection to the server and returns
    a client instance for us to interact with. We can pass it as an `options` object
    that may contain `host, port, user, password, database, flags`, and `debug` .
    Other than `user` and `password`, the default options are fine for our purposes
    though. If we uncomment `debug` we can see the raw data being sent to and from
    the server.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`createClient`方法建立与服务器的连接，并为我们返回一个客户端实例以便与之交互。我们可以将其作为一个`options`对象传递，该对象可能包含`host,
    port, user, password, database, flags`和`debug`。除了`user`和`password`之外，对于我们的目的来说，默认选项都是可以的。如果我们取消注释`debug`，我们可以看到被发送到服务器和从服务器接收的原始数据。'
- en: '`client.query` sends SQL to our database which is then executed by the MySQL
    server. With it, we `CREATE` a `DATABASE` named `quotes` and also a `TABLE` named
    `quotes`. Then we `INSERT` our first record (a quote by the inventor of C++) into
    our database.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`client.query`将SQL发送到我们的数据库，然后由MySQL服务器执行。使用它，我们`CREATE`一个名为`quotes`的`DATABASE`，还有一个名为`quotes`的`TABLE`。然后我们将我们的第一条记录（C++的发明者的引用）插入到我们的数据库中。'
- en: '`client.query` queues each piece of SQL passed to it, executing statements
    asynchronously alongside our other code, but sequentially within the SQL statement
    queue. When we call `client.end`, the connection closing task is added to the
    end of the queue. If we wanted to disregard the statement queue, and immediately
    end the connection, we would use `client.destroy`.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`client.query`将每个传递给它的SQL语句排队，与我们的其他代码异步执行语句，但在SQL语句队列中是顺序执行的。当我们调用`client.end`时，连接关闭任务将被添加到队列的末尾。如果我们想要忽略语句队列，并立即结束连接，我们将使用`client.destroy`。'
- en: Our `ignore` array holds two numbers, `1007` and `1050 — we` grab these numbers
    from the `mysql` object, which holds MySQL error codes. We want to ignore MySQL
    errors that occur when a table or database already exists, otherwise we could
    only run `mysql.js` once. After the first run it would crash since the database
    and table would already exist. Ignoring these codes means we can implicitly set
    up our database, and have just one file rather than a setup app and a separate
    app for inserting code.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`ignore`数组包含两个数字，`1007`和`1050 — 我们从`mysql`对象中获取这些数字，该对象包含MySQL错误代码。我们希望忽略MySQL在表或数据库已经存在时发生的错误，否则我们只能运行`mysql.js`一次。第一次运行后，它会崩溃，因为数据库和表已经存在。忽略这些代码意味着我们可以隐式地设置我们的数据库，并且只有一个文件，而不是一个用于设置和一个用于插入代码的单独的应用程序。
- en: In the `error` event listener we check if `err.number` is within our `ignore`
    array. If it is, we simply `return`, thus ignoring the error and gracefully continuing
    execution. If the error is of some other nature, we fall through to the usual
    behavior of throwing the error.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在`error`事件监听器中，我们检查`err.number`是否在我们的`ignore`数组中。如果是，我们简单地`return`，从而忽略错误并优雅地继续执行。如果错误是其他性质的，我们将继续执行抛出错误的通常行为。
- en: There's more...
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: We don't just send data to MySQL, we retrieve it. Furthermore, SQL queries are
    often generated from user input, but this can be open to exploitation if precautions
    aren't taken.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不仅将数据发送到MySQL，还会检索数据。此外，SQL查询通常是从用户输入生成的，但如果不采取预防措施，这可能会被利用。
- en: Using and cleaning user input
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用和清理用户输入
- en: As in other languages that build SQL statements with string concatenation, we
    must prevent the possibilities of SQL injection attacks to keep our server safe.
    Essentially, we must clean (which is, escape) any user input to eradicate the
    potential for unwanted SQL manipulation.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他使用字符串连接构建SQL语句的语言一样，我们必须防止SQL注入攻击的可能性，以保持服务器的安全。基本上，我们必须清理（即转义）任何用户输入，以消除不需要的SQL操纵的可能性。
- en: We'll copy `mysql.js` and call it `insert_quotes.js`. To implement the concept
    of user input in a simple way we'll pull arguments from the command line, but
    the principles and methods of data cleaning extend to any input method (for example,
    via a query string on a request).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将复制`mysql.js`并将其命名为`insert_quotes.js`。为了以简单的方式实现用户输入的概念，我们将从命令行中提取参数，但是数据清理的原则和方法适用于任何输入方法（例如，通过请求的查询字符串）。
- en: 'Our basic API will go like this:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的基本API将是这样的：
- en: '[PRE19]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Quotation marks are essential to divide the command-line arguments, but for
    the sake of brevity we won't be implementing any validation checks.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 引号是将命令行参数分隔的必要条件，但为了简洁起见，我们不会实现任何验证检查。
- en: Tip
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Command-line parsing module: optimist**'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**命令行解析模块：optimist**'
- en: For more advanced command-line functionality, check out the excellent `optimist`
    module , available at [https://www.github.com/substack/node-optimist](https://www.github.com/substack/node-optimist).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更高级的命令行功能，请查看优秀的`optimist`模块，网址为[https://www.github.com/substack/node-optimist](https://www.github.com/substack/node-optimist)。
- en: To receive an author and quote, we'll load the two quotes arguments into a new
    `params` object.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 为了接收作者和引用，我们将两个引用参数加载到一个新的`params`对象中。
- en: '[PRE20]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Our first argument is at `2` in the `process.argv` array because `0` and `1`
    hold `node` and `quotes.js`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个参数在`process.argv`数组中是`2`，因为`0`和`1`分别是`node`和`quotes.js`。
- en: 'Now let''s slightly modify our `INSERT` statement:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们稍微修改我们的`INSERT`语句：
- en: '[PRE21]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We've placed this just before our final `client.end` call in the main recipe.
    The `mysql` module can seamlessly clean user input for us. We simply use the question
    mark (?) as a placeholder and then pass our values (in order) as an array into
    the second parameter of `client.query`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这个放在主要的`client.end`调用之前。`mysql`模块可以无缝地为我们清理用户输入。我们只需使用问号（？）作为占位符，然后将我们的值（按顺序）作为数组传递到`client.query`的第二个参数中。
- en: Receiving results from the MySQL server
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从MySQL服务器接收结果
- en: Let's extend `insert_quotes.js` further by outputting all quotes for an author,
    whether or not a quote is provided. We'll save `insert_quotes.js` simply as `quotes.js`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过输出所有作者的引用来进一步扩展`insert_quotes.js`，无论是否提供了引用。我们将`insert_quotes.js`简单保存为`quotes.js`。
- en: 'Underneath our `INSERT` query, but above the final `client.end`, we''ll add
    the following code:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`INSERT`查询下面，但在最终的`client.end`之上，我们将添加以下代码：
- en: '[PRE22]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: On this occasion, we've used an alternative approach to clean user input with
    `client.escape`. This has exactly the same effect as the former, but only escapes
    a single input. Generally, if there's more than one variable, the former method
    would be preferable.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们使用了另一种方法来清理用户输入，即`client.escape`。这与前一种方法的效果完全相同，但只转义单个输入。通常，如果有多个变量，前一种方法更可取。
- en: The results of a `SELECT` statement can be accessed either by passing a callback
    function, or by listening for the `row` event. A `row` event listener allows us
    to interact with a MySQL server data stream, one row at a time.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过传递回调函数或监听`row`事件来访问`SELECT`语句的结果。`row`事件监听器允许我们逐行与MySQL服务器数据流交互。
- en: We can safely call `client.end` without putting it in the `end` event of our
    `SELECT` query because `client.end` only terminates a connection when all queries
    are done.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以安全地调用`client.end`，而不必将其放在我们的`SELECT`查询的`end`事件中，因为`client.end`只有在所有查询完成时才会终止连接。
- en: See also
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Storing and retrieving data with MongoDB* discussed in this chapter'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在本章中讨论的使用MongoDB存储和检索数据*'
- en: '*Storing and retrieving data with Redis* discussed in this chapter'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在本章中讨论的使用Redis存储和检索数据*'
- en: Storing and retrieving data with MongoDB
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用MongoDB存储和检索数据
- en: MongoDB is a NoSQL database offering that maintains a philosophy of performance
    over features. It's designed for speed and scalability. Instead of working relationally,
    it implements a document-based model that has no need for schemas (column definitions).
    The document model works well for scenarios where relationships between data are
    flexible and where minimal potential data loss is an acceptable cost for the speed
    enhancements (a blog for instance).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB是一种NoSQL数据库提供，坚持性能优于功能的理念。它专为速度和可扩展性而设计。它实现了一个基于文档的模型，不需要模式（列定义），而不是关系工作。文档模型适用于数据之间关系灵活且最小潜在数据丢失是速度增强的可接受成本的情况（例如博客）。
- en: While it's in the NoSQL family, MongoDB attempts to sit between two worlds,
    providing a syntax reminiscent of SQL but operating non-relationally.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然它属于NoSQL家族，但MongoDB试图处于两个世界之间，提供类似SQL的语法，但以非关系方式运行。
- en: In this task, we'll implement the same `quotes` database as in the previous
    recipe, using MongoDB instead of MySQL.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个任务中，我们将实现与之前的配方相同的`quotes`数据库，但使用MongoDB而不是MySQL。
- en: Getting ready
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We'll want to run a MongoDB server locally. It can be downloaded from [http://www.mongodb.org/downloads](http://www.mongodb.org/downloads).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要在本地运行一个MongoDB服务器。可以从[http://www.mongodb.org/downloads](http://www.mongodb.org/downloads)下载。
- en: 'Let''s start the MongoDB service, `mongod`, in the default debug mode:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以默认的调试模式启动MongoDB服务`mongod`：
- en: '[PRE23]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This allows us to observe the activities `mongod` as it interacts with our code,
    if we wanted to start it as a persistent background service we would use.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够观察`mongod`与我们的代码交互的活动，如果我们想要将其作为持久后台服务启动，我们将使用。
- en: '[PRE24]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Where `[p]` is our desired path.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 其中`[p]`是我们想要的路径。
- en: Tip
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: More information on starting and correctly stopping `mongod` can be found at
    [http://www.mongodb.org/display/DOCS/Starting+and+Stopping+Mongo](http://www.mongodb.org/display/DOCS/Starting+and+Stopping+Mongo).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 有关启动和正确停止`mongod`的更多信息，请访问[http://www.mongodb.org/display/DOCS/Starting+and+Stopping+Mongo](http://www.mongodb.org/display/DOCS/Starting+and+Stopping+Mongo)。
- en: To interact with MongoDB from Node, we'll need to install the `mongodb` native
    bindings driver module.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 要从Node与MongoDB交互，我们需要安装`mongodb`本机绑定驱动程序模块。
- en: '[PRE25]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We'll also create a new folder for our MongoDB-based project, with a new `quotes.js`
    file.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将为基于MongoDB的项目创建一个新文件夹，其中包含一个新的`quotes.js`文件。
- en: How to do it...
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: We must require the `mongodb` driver, initiate a MongoDB server instance, and
    create a client which loads the quotes database and connects to the MongoDB server.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须要求`mongodb`驱动程序，启动一个MongoDB服务器实例，并创建一个客户端，加载引用数据库并连接到MongoDB服务器。
- en: '[PRE26]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Notice we've also inserted our `params` object for reading user input from the
    command line.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们还插入了我们的`params`对象，以从命令行读取用户输入。
- en: Now we open a connection to our `quotes` database and load (or create if necessary)
    our `quotes` collection (a table would be the closest similar concept in SQL).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们打开到我们的`quotes`数据库的连接，并加载（或创建如果需要）我们的`quotes`集合（在SQL中，表将是最接近的类似概念）。
- en: '[PRE27]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Next, we'll insert a new document (in SQL terms this would be a record) according
    to a user-defined author and quote.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将根据用户定义的作者和引用插入一个新文档（在SQL术语中，这将是一条记录）。
- en: We'll also output any quotes by the specified author to the console.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将在控制台上输出指定作者的任何引用。
- en: '[PRE28]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We can see our MongoDB backed quotes application in action in the following
    screenshot:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在以下截图中看到我们基于MongoDB的引用应用程序的运行情况：
- en: '![How to do it...](img/7188-04-01.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![操作步骤...](img/7188-04-01.jpg)'
- en: How it works...
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: When we create a new instance of `mongo.Db`, we pass in the name of the database
    as the first parameter. MongoDB will intelligently create this database if it
    doesn't exist.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建一个新的`mongo.Db`实例时，我们将数据库的名称作为第一个参数传递进去。如果数据库不存在，MongoDB会智能地创建这个数据库。
- en: We use the `open` method of the `Db` instance, which we named `client`, to open
    a connection to our database. Once the connection is made, our callback function
    is executed where we can interact with the database via the `client` parameter.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`Db`实例的`open`方法，我们将其命名为`client`，以打开与数据库的连接。一旦连接建立，我们的回调函数就会被执行，我们可以通过`client`参数与数据库进行交互。
- en: We start off by making a `Collection` instance. `Collection` is similar to an
    SQL table in that it holds all our database fields. However, rather than field
    values being grouped by column, a collection contains multiple documents (like
    records) where each field holds both the field name and its value (documents are
    very much like JavaScript objects).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个`Collection`实例。`Collection`类似于SQL表，它包含了所有我们的数据库字段。但是，与字段值按列分组不同，集合包含多个文档（类似记录），其中每个字段都包含字段名和其值（文档非常类似于JavaScript对象）。
- en: If both `quote` and `author` are defined, we invoke the `insert` method of our
    `Collection` instance, passing in an object as our document.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`quote`和`author`都被定义了，我们就调用我们的`Collection`实例的`insert`方法，传入一个对象作为我们的文档。
- en: Finally, we use `find` which is comparable to the `SELECT` SQL command, passing
    in an object that specifies the author field and desired value. The `mongodb`
    driver provides a convenience method (each) that can be chained with the `find`
    method. `each` executes the callback passed to it for each document as it's found.
    The last loop of `each` passes in `doc` as `null`, which conveniently signals
    that MongoDB has returned all records.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用`find`，它类似于`SELECT` SQL命令，传入一个指定作者字段和所需值的对象。`mongodb`驱动程序提供了一个方便的方法（each），可以与`find`方法链接。`each`执行传递给它的回调，对于每个找到的文档都会执行。`each`的最后一个循环将`doc`作为`null`传递，这方便地表示MongoDB已经返回了所有记录。
- en: So as long as `doc` is truthy, we pass the `author` and `quote` properties of
    every `doc` found. Once `doc` is `null`, we allow the interpreter to discover
    the last part of the callback, `client.close`, by not returning early from the
    callback.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 只要`doc`是真实的，我们就传递每个找到的`doc`的`author`和`quote`属性。一旦`doc`是`null`，我们允许解释器通过不从回调中提前返回来发现回调的最后部分，`client.close`。
- en: The second and final `client.close` situated at the end of the `client.open`
    callback is invoked only when there are no arguments defined via the command line.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在`client.open`回调的最后，第二个也是最后一个`client.close`只有在没有通过命令行定义参数时才会被调用。
- en: There's more...
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Let's check out some other useful MongoDB features.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些其他有用的MongoDB功能。
- en: Indexing and aggregation
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 索引和聚合
- en: Indexing causes MongoDB to create a list of values from a chosen field. Indexed
    fields accelerate query speeds because a smaller set of data can be used to cross
    reference and pull from a larger set. We can apply an index to the author field
    and see performance benefits, especially as our data grows. Additionally, MongoDB
    has various commands allowing us to aggregate our data. We can group, count, and
    return distinct values.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 索引会导致MongoDB从所选字段创建一个值列表。索引字段可以加快查询速度，因为可以使用更小的数据集来交叉引用和从更大的数据集中提取数据。我们可以将索引应用到作者字段，并看到性能的提升，特别是当我们的数据增长时。此外，MongoDB有各种命令允许我们对数据进行聚合。我们可以分组、计数和返回不同的值。
- en: Note
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For more advanced needs or larger sets of data, map/reduce functions can aggregate.
    CouchDB also uses map/reduce to generate views (stored queries), See *Retrieving
    data from CouchDB with Cradle*.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更高级的需求或更大的数据集，map/reduce函数可以进行聚合。CouchDB也使用map/reduce来生成视图（存储的查询），参见*使用Cradle从CouchDB检索数据*。
- en: Let's create and output a list of authors found in our database, and save our
    code to a file called `authors.js`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建并输出在我们的数据库中找到的作者列表，并将我们的代码保存到一个名为`authors.js`的文件中。
- en: '[PRE29]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: As usual, we opened up a connection to our `quotes` database, grabbing our `quotes`
    collection. Using `ensureIndex` creates an index only if one doesn't already exist.
    We pass in `safe:true` so that MongoDB returns any errors and our callback works
    as expected. Inside the callback, we invoke the `distinct` method on our `collection`,
    passing in `author`. The result is passed as an array through as `result`. We
    `join` the array into a string using new lines and output to the console. .
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，我们打开了与我们的“quotes”数据库的连接，获取了我们的“quotes”集合。使用`ensureIndex`只有在索引不存在时才会创建一个索引。我们传入`safe:true`，这样MongoDB会返回任何错误，并且我们的回调函数可以正常工作。在回调函数中，我们在我们的`collection`上调用`distinct`方法，传入`author`。结果作为数组传递，我们使用换行符将数组`join`成一个字符串并输出到控制台。
- en: Updating modifiers, sort, and limit
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新修改器、排序和限制
- en: We could make it possible for a hypothetical user to indicate if they were inspired
    by a quote (such as a **Like** button), then we could use the `sort` and `limit`
    commands to output the top ten most inspiring quotes.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以让一个假设的用户指示他们是否受到引用的启发（例如**Like**按钮），然后我们可以使用`sort`和`limit`命令来输出前十个最具启发性的引用。
- en: In reality, this would be implemented with some kind of user interface (for
    example, in a browser), but we'll again emulate user interactions using the command
    line; let's create a new file called `quotes_votes.js`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这将通过某种用户界面来实现（例如，在浏览器中），但我们将再次使用命令行来模拟用户交互；让我们创建一个名为`quotes_votes.js`的新文件。
- en: 'First, in order to vote for a quote, we''ll need to reference it, which can
    be done by the unique `_id` property. So in `quotes_votes.js` let''s write:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，为了对引用进行投票，我们需要引用它，这可以通过唯一的`_id`属性完成。因此在`quotes_votes.js`中，让我们写：
- en: '[PRE30]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now when we run `quotes_votes.js` with `node`, we''ll see a list of IDs and
    quotes. To vote for a quote, we''ll simply copy an ID and use it as our command-line
    parameter. So let''s do our vote handling as shown in the following code:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当我们用`node`运行`quotes_votes.js`时，我们将看到一个ID和引用列表。要为引用投票，我们只需复制一个ID并将其用作我们的命令行参数。因此，让我们按照以下代码所示进行投票处理：
- en: '[PRE31]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: MongoDB IDs must be encoded as a BSON (Binary JSON) ObjectID. Otherwise, the
    `update` command will look for `param.id` as a string, failing to find it. So
    we create a `new mongo.ObjectID(param.id)` to convert `param.id` from a JavaScript
    string to a BSON ObjectID.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB的ID必须编码为BSON（二进制JSON）ObjectID。否则，`update`命令将查找`param.id`作为字符串，找不到它。因此，我们创建一个`new
    mongo.ObjectID(param.id)`来将`param.id`从JavaScript字符串转换为BSON ObjectID。
- en: '`$inc` is a MongoDB modifier that performs the incrementing action inside the
    MongoDB server, essentially allowing us to outsource the calculation. To use it,
    we pass a document (object) alongside it containing the key to increment and the
    amount to increase it by. So we pass `votes` and `1`.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '`$inc` will create the `votes` field if it doesn''t exist, and increment it
    by one (we can also decrement using minus figures). Next are the options to be
    passed to MongoDB. We''ve set `safe` to `true`, which tells MongoDB to check that
    the command was successful and send any errors if it wasn''t. For the callback
    to work correctly, `safe:true` must be passed, otherwise errors are not caught,
    and the callback occurs immediately.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Upserting**'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: Another useful option we can set is `upsert:true`. This is a really convenient
    MongoDB feature that either updates a record or inserts it if it doesn't exist.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `update` callback we run a chain of `find.sort.limit.each. find`,
    without any parameters, which returns all our records. `sort` requires keys and
    a positive or negative `1`, indicating ascending or descending. `limit` takes
    an integer of maximum records, and `each` loops through our records. Inside the
    `each` callback, we output every `author, quote`, and `votes` of `doc`, closing
    the connection when no `docs` are left.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Connecting and sending SQL to a MySQL server* discussed in this chapter'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Storing and retrieving data with Mongoskin* discussed in this chapter'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Storing data to CouchDB with Cradle* discussed in this chapter'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing and retrieving data with Mongoskin
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mongoskin is a convenience library providing a high-level interface for `mongodb`
    without blocking access to the existing `mongodb` methods.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: For this recipe, we'll re-implement the `quotes` database in MongoDB using Mongoskin.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll need the `mongoskin` module.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We can also create a new folder, with a new `quotes.js` file.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll require `mongoskin` and use it to make a `client` and a `collection` instance.
    We don't need to create a `server` instance, nor manually open the client as in
    the former recipe, `mongoskin` takes care of that.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: As in the previous recipe, we've defined our `params` object for user input.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Instead of requiring us to use JavaScript's potentially human error prone `new`
    keyword, `mongoskin` provides a builder method (`mongo.db`), allowing us to define
    our host, port, and database name with the familiar URI schema.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: See [http:// www. yuiblog.com/blog/2006/11/13/javascript-we-hardly-new-ya/](http://
    www. yuiblog.com/blog/2006/11/13/javascript-we-hardly-new-ya/) for why the `new`
    prefix could be considered error prone.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we don''t need to `open` our `client (mongoskin` opens it for us), we
    can just go ahead and implement our `insert` and `find` operations:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: And we're done.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We transparently connect to our database using Mongoskin's `db` method, and
    we're immediately able to grab our collection.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: As in our previous recipe, we check for the `author` and `quote` command-line
    arguments, and then call the `mongodb insert` method which is inherently available
    through the `mongoskin` module.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Next, after checking for author, we use the `findEach` method of `mongoskin`.
    The `findEach` method wraps `collection.find.each` as used in the previous recipe.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: Within `findEach` we output the `author` and `quote` properties of each `doc`
    to the console. When there's no documents left, we explicitly `close` the `client`
    connection.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Mongoskin does an excellent job of making our lives easier. Let's look at another
    Mongoskin feature that simplifies our interactions with MongoDB.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: Collection binding
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Mongoskin provides a `bind` method that makes a collection available as a property
    of our `client` object. So if we did:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We could access the quotes collection via `client.quotes`.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: 'This means we can discard the `collection` variable and use binding instead.
    The `bind` method also accepts an object of methods, which then applies to the
    bound collection. For instance, if we defined a method called `store`, we would
    access it as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们可以丢弃`collection`变量并改用绑定。`bind`方法还接受一个方法对象，然后应用于绑定的集合。例如，如果我们定义了一个名为`store`的方法，我们将按以下方式访问它：
- en: '[PRE36]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: So let's create a new file called `quotes_bind.js` to re-implement `quotes.js`
    in Mongoskin, this time using the collection binding approach.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们创建一个名为`quotes_bind.js`的新文件，以使用集合绑定方法重新实现Mongoskin中的`quotes.js`。
- en: 'We''ll begin with our top-level variables:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从我们的顶级变量开始：
- en: '[PRE37]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We have no need for a `collection` variable since we'll be accessing our collection
    via `bind`.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将通过`bind`访问我们的集合，因此我们不需要`collection`变量。
- en: 'Now let''s define a `store` method for inserts and a `show` method for displaying
    quotes:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们为插入定义一个`store`方法和一个用于显示引用的`show`方法：
- en: '[PRE38]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Then our logic to interact with our new bound methods:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们的逻辑与我们的新绑定方法进行交互：
- en: '[PRE39]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `bind` method of Mongoskin painlessly abstracts involved database operations
    into an easy dot-notation format.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: Mongoskin的`bind`方法将复杂的数据库操作无缝地抽象成易于使用的点符号格式。
- en: Note
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We baked some of our `params` checking functionality into our `store` method,
    only calling `insert` if a quote exists. In all our recipes, we only needed to
    check for the second argument (`params.quote`), we couldn't have `params.quote`
    without `params.author`. Both arguments were checked in the prior recipes to demonstrate
    how it might work in other scenarios (for instance, if we received our parameters
    via a POST request).
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将一些`params`检查功能嵌入到我们的`store`方法中，只有在引用存在时才调用`insert`。在我们所有的示例中，我们只需要检查第二个参数（`params.quote`），我们不能有`params.quote`而没有`params.author`。在之前的示例中，这两个参数都进行了检查，以演示在其他情况下它可能如何工作（例如，如果我们通过POST请求接收到我们的参数）。
- en: See also
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Storing and retrieving data with MongoDB* discussed in this chapter'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在本章中讨论了使用MongoDB存储和检索数据*'
- en: '*Storing data to CouchDB with Cradle* discussed in this chapter'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在本章中讨论了使用Cradle将数据存储到CouchDB*'
- en: '*Retrieving data from CouchDB with Cradle* discussed in this chapter'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在本章中讨论了使用Cradle从CouchDB检索数据*'
- en: Storing data to CouchDB with Cradle
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Cradle将数据存储到CouchDB
- en: In order to achieve stellar performance speeds, MongoDB has a relaxed view towards
    ACID (Atomicity Consistency Isolation Durability) compliance. However, this means
    there is an (unlikely) chance that data can become corrupted (especially if there
    was a power cut in the middle of an operation). CouchDB, on the other hand, is
    ACID compliant to the extent that, when replicated and synchronized, data eventually
    becomes consistent. Therefore, while slower than MongoDB, it has the added reliability
    advantage.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现出色的性能速度，MongoDB对ACID（原子性一致性隔离持久性）合规性有一定的放松。然而，这意味着数据可能会变得损坏的可能性（尤其是在操作中断的情况下）。另一方面，CouchDB在复制和同步时是符合ACID的，数据最终变得一致。因此，虽然比MongoDB慢，但它具有更高的可靠性优势。
- en: CouchDB is entirely administrated via HTTP REST calls, so we could do all of
    our work with CouchDB using `http.request`. Nevertheless, we can use Cradle to
    interact with CouchDB in an easy, high-level way, along with the added speed enhancement
    of automated caching.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: CouchDB完全通过HTTP REST调用进行管理，因此我们可以使用`http.request`来完成与CouchDB的所有工作。尽管如此，我们可以使用Cradle以一种简单、高级的方式与CouchDB进行交互，同时还可以获得自动缓存的速度增强。
- en: In this recipe, we'll use Cradle to store famous quotes to CouchDB.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将使用Cradle将著名的引用存储到CouchDB中。
- en: Getting ready
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We'll need to install and run CouchDB, we can head on to [http://wiki.apache.org/couchdb/Installation](http://wiki.apache.org/couchdb/Installation)
    for instructions on how to install for your particular operating system.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要安装和运行CouchDB，可以前往[http://wiki.apache.org/couchdb/Installation](http://wiki.apache.org/couchdb/Installation)获取有关如何在特定操作系统上安装的说明。
- en: After installation, we can check if CouchDB is running and access the Futon
    administration panel by pointing our browser to [http://localhost:5984/_utils](http://localhost:5984/_utils).
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，我们可以检查CouchDB是否正在运行，并通过将浏览器指向[http://localhost:5984/_utils](http://localhost:5984/_utils)来访问Futon管理面板。
- en: We'll also need the `cradle` module.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要`cradle`模块。
- en: '[PRE40]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: And we can create a new folder with a new `quotes.js` file in it.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以在其中创建一个新的`quotes.js`文件的新文件夹。
- en: How to do it...
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'First, we require `cradle` and load our quotes database, creating it if necessary.
    We''ll also define an error-handling function and our `params` object for easy
    command-line interaction:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要`cradle`并加载我们的引用数据库，如果需要的话创建它。我们还将定义一个错误处理函数和我们的`params`对象，以便轻松进行命令行交互：
- en: '[PRE41]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Before we can write to our database, we need to know it exists:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以写入数据库之前，我们需要知道它是否存在：
- en: '[PRE42]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Notice that we pass in `checkAndSave` as the callback of `db.create`, the following
    function goes above the `db.exists` invocation:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们将`checkAndSave`作为`db.create`的回调传入，以下函数位于`db.exists`调用之上：
- en: '[PRE43]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The `err` parameter we are handling in `checkAndSave` would have been passed
    in from `db.create`.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`checkAndSave`中处理的`err`参数将从`db.create`中传入。
- en: How it works...
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'CouchDB is administrated via HTTP requests, but Cradle provides an interface
    for making these requests. When we invoke `db.exists`, Cradle sends a HEAD request
    to `http://localhost:5984/quotes` and checks whether the reply status is `404
    Not Found` or `200 OK`. We could perform the same check with command-line program''s
    `curl` and `grep` as follows:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: CouchDB通过HTTP请求进行管理，但Cradle提供了一个接口来进行这些请求。当我们调用`db.exists`时，Cradle会向`http://localhost:5984/quotes`发送一个HEAD请求，并检查回复状态是否为`404
    Not Found`或`200 OK`。我们可以使用命令行程序的`curl`和`grep`执行相同的检查，如下所示：
- en: '[PRE44]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This would output `1` if the database exists, and `0` if it does not. If our
    database doesn''t exist, we call the `db.create` method of `cradle` which sends
    an HTTP PUT request to the CouchDB server. In `curl` this would be:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数据库存在，则会输出`1`，如果不存在，则会输出`0`。如果我们的数据库不存在，我们调用`cradle`的`db.create`方法，该方法会向CouchDB服务器发送一个HTTP
    PUT请求。在`curl`中，这将是：
- en: '[PRE45]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We pass in our `checkAndSave` function as the callback of `db.create`, or we
    call it from the callback of `db.exists` if the database does exist. This is essential.
    We cannot save data to a database that doesn't exist and we have to wait for the
    HTTP response before we know whether it exists (or whether it has been created).
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将我们的`checkAndSave`函数作为`db.create`的回调传入，或者如果数据库存在，我们将它从`db.exists`的回调中调用。这是必要的。我们不能将数据保存到不存在的数据库中，我们必须等待HTTP响应，然后才知道它是否存在（或者是否已创建）。
- en: '`checkAndSave` looks for command-line arguments, and then saves the data accordingly.
    For instance, if we ran the following from the command line:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`checkAndSave`查找命令行参数，然后相应地保存数据。例如，如果我们从命令行运行以下命令：'
- en: '[PRE46]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '`checkAndSave` would realize there are two parameters passing these as `author`
    and `quote` to `db.save`. Cradle would then POST the following, with `Content-Type`
    set to `application/json:`'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`checkAndSave`会意识到有两个参数传递给`author`和`quote`，然后将它们传递给`db.save`。Cradle然后会POST以下内容，`Content-Type`设置为`application/json:`'
- en: '[PRE47]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: On top of this, Cradle adds a caching layer, which in our example is of little
    use since caching data is lost whenever our application exits. However, in server
    implementation, the caching would become very useful in answering similar requests
    quickly and efficiently.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，Cradle还添加了一个缓存层，在我们的示例中几乎没有用处，因为缓存数据在应用程序退出时会丢失。然而，在服务器实现中，缓存将在快速高效地响应类似请求时变得非常有用。
- en: There's more...
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Couch stands for **Cluster Of Unreliable Commodity Hardware**, let's take a
    brief look at the clustering side of CouchDB.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: Couch代表**Cluster Of Unreliable Commodity Hardware**，让我们简要看一下CouchDB的集群方面。
- en: Scaling CouchDB with BigCouch
  id: totrans-260
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用BigCouch扩展CouchDB
- en: Scaling is about making your application responsive to an anticipated demand,
    but different projects have different characteristics. Therefore, each scaling
    venture requires an individualized approach.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展是关于使您的应用程序对预期需求做出响应的，但不同的项目具有不同的特点。因此，每个扩展项目都需要个性化的方法。
- en: If a web service was heavily built around database interaction, scaling the
    database layer would be a priority when responding to changes in service demand.
    Scaling CouchDB (or anything else) can be a very in-depth procedure, necessarily
    so for specialized projects.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个Web服务主要建立在数据库交互上，那么在响应服务需求变化时，扩展数据库层将成为一个优先考虑的问题。扩展CouchDB（或其他任何东西）可能是一个非常深入的过程，对于专门的项目来说是必要的。
- en: However, the Open Source BigCouch project has an ability to scale CouchDB in
    a transparent and generic fashion. With BigCouch, we can scale CouchDB across
    servers, but interact with it as if it was on one server. BigCouch can be found
    at [https://www. github.com/cloudant/bigcouch](https://www. github.com/cloudant/bigcouch).
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，开源的BigCouch项目具有以透明和通用的方式扩展CouchDB的能力。使用BigCouch，我们可以在服务器之间扩展CouchDB，但与之交互就像它在一个服务器上一样。BigCouch可以在[https://www.
    github.com/cloudant/bigcouch](https://www. github.com/cloudant/bigcouch)找到。
- en: See also
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '*Retrieving data from CouchDB with Cradle* discussed in this chapter'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在本章中讨论的使用Cradle从CouchDB检索数据*'
- en: '*Storing and retrieving data with MongoDB* discussed in this chapter'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在本章中讨论的使用MongoDB存储和检索数据*'
- en: '*Storing and retrieving data with Redis* discussed in this chapter'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在本章中讨论的使用Redis存储和检索数据*'
- en: Retrieving data from CouchDB with Cradle
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Cradle从CouchDB检索数据
- en: CouchDB doesn't use the same query paradigm that MySQL and MongoDB subscribe
    to. Instead, it uses a pre-created view to retrieve the desired data.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: CouchDB不使用与MySQL和MongoDB相同的查询范式。相反，它使用预先创建的视图来检索所需的数据。
- en: In this example, we'll use Cradle to obtain an array of quotes according to
    the specified author, outputting our quotes to the console.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将使用Cradle根据指定的作者获取一个引用数组，并将我们的引用输出到控制台。
- en: Getting ready
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: As in the previous recipe, *Storing data to CouchDB with Cradle*, we'll need
    CouchDB installed on our system, along with `cradle`. We can also take the `quotes.js`
    file from that recipe, placing it in a new directory.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 与前一个配方*使用Cradle将数据存储到CouchDB*一样，我们需要在系统上安装CouchDB，以及`cradle`。我们还可以从该配方中获取`quotes.js`文件，并将其放在一个新的目录中。
- en: How to do it...
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We''re working on the `quotes.js` file from the prior task where we called
    `checkAndSave` if our database existed, or we called it from the callback of `db.create`
    if it didn''t exist. Let''s modify `checkAndSave` slightly as shown in the following
    code:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在从之前的任务中的`quotes.js`文件中进行工作，在那里如果我们的数据库存在，我们调用`checkAndSave`，或者如果它不存在，我们就从`db.create`的回调中调用它。让我们稍微修改`checkAndSave`，如下面的代码所示：
- en: '[PRE48]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: We've added a new function invocation, `outputQuotes`, to the end of `checkAndSave`
    and also as the callback of `db.save. outputQuotes` is going to access a special
    CouchDB `_design` document called a view.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`checkAndSave`的末尾添加了一个新的函数调用`outputQuotes`，并且也作为`db.save`的回调。`outputQuotes`将访问一个名为视图的特殊CouchDB
    `_design`文档。
- en: 'Before we look at `outputQuotes`, let''s look into another new function we''ll
    be creating called `createQuotesView`. It should be placed just under `errorHandler`
    but above the rest of the code as follows:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看`outputQuotes`之前，让我们来看看另一个我们将要创建的新函数，名为`createQuotesView`。它应该放在`errorHandler`的下面，但在代码的其余部分之上，如下所示：
- en: '[PRE49]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '`createQuotesView` also calls the `outputQuotes` function from the `db.save`
    callback parameter. `outputQuotes` is now called from three places: the `db.save`
    callback of `checkAndSave`, the end of `checkAndSave`, and in the `db.save` callback
    of `createQuotesView`.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '`createQuotesView`还从`db.save`的回调参数中调用`outputQuotes`函数。`outputQuotes`现在从三个地方调用：`checkAndSave`的`db.save`回调，`checkAndSave`的末尾，以及`createQuotesView`的`db.save`回调。'
- en: Let's take a look at `outputQuotes:`
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看`outputQuotes:`
- en: '[PRE50]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '`outputQuotes` goes before `checkAndSave`, but after `createQuotesView`.'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '`outputQuotes`在`checkAndSave`之前，但在`createQuotesView`之后。'
- en: How it works...
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The key to querying a CouchDB database is views. There are two types of views:
    permanent and temporary. In `createQuotesView` we define a permanent view using
    `db.save`, setting the document ID to `_design/quotes`. We then define a `views`
    field containing an object called `byAuthor` which holds a key called `map` whose
    value is a string formatted function.'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: Temporary views would be stored with an ID of `quotes/_temp_view`. However,
    these should only be used for testing,. They're very expensive computationally
    and shouldn't be used for production.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: 'The mapping function is string formatted because it''s passed to CouchDB via
    an HTTP request. CouchDB `map` functions are not executed with Node, they run
    within the CouchDB server. A `map` function defines the query we wish to run on
    the database through the CouchDB servers `emit` function. The first argument of
    `emit` specifies which field to query, (in our case `doc.author)`, and the second
    specifies what to output as a result of the query (we want the whole `doc)`. If
    we wanted to search for Albert Einstein, we would make a GET request to: `http://localhost:5984/quotes/_design/quotes/_view/byAuthor?key="Albert
    Einstein"`.'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: Cradle provides a shorthand method for this request, `db.view`, which appears
    in our `outputQuotes` function. `db.view` allows us to simply pass in `quotes/byAuthor`
    with a second object containing the `key` parameter (that is, our query), essentially
    filling in the special underscore routes for us.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '`db.view` parses the incoming JSON and provides it via the second parameter
    of its callback, which we named `rowsArray`. We loop through the array using `forEach`
    and finish off by outputting `author` and `quote` to the console, as in previous
    recipes.'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: However, before we loop through the array we need to check that our view actually
    exists. Views only need to be generated once. After this, they are stored in the
    CouchDB database. Therefore, we don't want to create a view every time we run
    our application. So when we call `db.view` we look to see if a `not_found` error
    occurs in the `db.view` callback. If our view isn't found, we call `createQuotesView`.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: 'In broad terms, the process goes something like this:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/7188_04_02.jpg)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
- en: There's more...
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: CouchDB is great for getting to grips right out of the box. However, there are
    certain security considerations we must be attuned to before deploying a CouchDB-backed
    app to the web.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: Creating an admin user
  id: totrans-294
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'CouchDB requires no initial authorization settings, which is fine for development.
    However, as soon as we expose CouchDB to the outside world, anyone on the Internet
    has permission to edit our entire database: data designs, configuration, users,
    and so on.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: 'So before deploying, we want to set a username and password. We can achieve
    this with the `_config` API:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: We have created the admin user `dave` and set the password to `cookit`. Now
    the right to certain calls will be denied without authentication, including the
    creation or deletion of databases, modifying design documents (for example, for
    views), or access to the `_config` API.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, say we wanted to view all admin users, we could say:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'CouchDB will reply:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'However, if we include authentication information:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We get our only admin user along with a hash of his password:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Using this method to remotely administer a CouchDB database is not without its
    security flaws. It forces us to send passwords as plain text over non-secure HTTP.
    Ideally, we need to host CouchDB behind an HTTPS proxy so the password becomes
    encrypted as it's sent. See the recipe *Setting up an HTTPS server* discussed
    In [Chapter 7](ch07.html "Chapter 7. Implementing Security, Encryption, and Authentication"),Implementing
    Security, Encryption, and Authentication
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: 'If CouchDB is behind HTTPS, `cradle` can connect to it as follows:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: We pass an `options` object when we create our connection. The `secure` property
    tells `cradle` we are using SSL, and `auth` contains a sub-object with login details.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, we create a Node app to authenticate with a local CouchDB instance
    (so that no password is sent to an external HTTP address) and act as a layer between
    external requests and CouchDB.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: Locking all modifying operations to an admin user
  id: totrans-312
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Even if an admin user is set, unauthenticated users still have permission to
    modify existing databases. If we were only writing to CouchDB server side (but
    reading from either server or clients), we could lock all write operations for
    non-admin users with a validation function.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: 'A validation function is written in JavaScript and runs on the CouchDB server
    (like a map function). Once a validation function is defined, it''s executed against
    all user input for the database it is applied to. Three objects appear as parameters
    in the function: the new document (`newDoc`), the previous currently stored document
    (`savedDoc`), and the user context (`userCtx`), which holds authenticated user
    information.'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: Within a validation function we can examine and qualify these objects, calling
    CouchDB's `throw` function to reject operation requests that fail to meet our
    requirements.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s make a new file called `database_lockdown.js`, and begin by connecting
    to our database:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: We pass in an `options` object to the new cradle connection. It contains authentication
    information which will now be necessary to create a validation function if we
    have set a new admin user according to the previous subsection *Creating an admin
    user*.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create our validation function, and save it as a `_design` document:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'As soon as we execute:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: All write-related operations will now require authorization.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: Like views, we store validation functions within a document that has a `_design/`
    prefixed ID. The other part of the ID can be anything, but we named it `_auth`
    which reflects conventional practice when a validation function serves this type
    of purpose. The field name, though, must be called `validate_doc_update`.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: By default Cradle assumes any `_design` documents passed to `db.save` are a
    view. In order to prevent Cradle from wrapping our `validate_update_doc` field
    into a view, we specify an empty object to the `views` property.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: '`validate_update_doc` must be passed a string-formatted function, so we define
    our function under the `admin_lock` variable and call `toString` on it as it''s
    passed into `db.save`.'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: '`admin_lock` is never intended for execution by Node. It''s an aesthetic approach
    to constructing our function before passing it to CouchDB.'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: When an operation occurs on the database, our `admin_lock` function (which becomes
    CouchDB's `validate_update_doc` function) asks CouchDB to check if the user requesting
    the operation has the `_admin` user role. If not, it tells CouchDB to throw an
    unauthorized error thus denying access.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: Exposing the CouchDB HTTP interface to remote connections
  id: totrans-329
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'By default, CouchDB binds to `127.0.0.1`. This ensures that only local connections
    can be made to the database ensuring safety prior to security enforcements. Once
    we have CouchDB set up behind HTTPS with at least one admin user set, we can bind
    CouchDB to `0.0.0.0` which makes the REST interface accessible via any IP address.
    This means that remote users can access our CouchDB HTTP interface via our server''s
    public IP address, or more likely via our server''s domain name. We can set the
    bind address with `_config` as follows:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Where `u` and `p` are the admin username and password, respectively.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-333
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Storing data to CouchDB with Cradle* discussed in this chapter'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Storing and retrieving data with MongoDB* discussed in this chapter'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Setting Up and HTTPS Web Server discussed in* [Chapter 7](ch07.html "Chapter 7. Implementing
    Security, Encryption, and Authentication"),Implementing Security, Encryption,
    and Authentication'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing CouchDB changes stream with Cradle
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of CouchDB's most noteworthy features is the `_changes` API. With it we
    can view all alterations to a database via HTTP.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: For instance, to see all changes made to our `quotes` database we can make a
    GET request to `http://localhost:5984/quotes/_changes`. Even better, if we wanted
    to hook up to a live stream, we would add the query parameter `?feed=continuous`.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: Cradle provides an attractive interface to the `_changes` API, which we'll explore
    in this recipe.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-341
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll need a functioning CouchDB database and a way to write to it. We can use
    the `quotes.js` example used in *Storing data to CouchDB with Cradle*, so let's
    copy that into a new directory and then create a file alongside it called `quotes_stream.js`.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: 'If we followed the *Creating an admin user* and *Locking all modifying operations
    to an admin user* sections of the previous recipe''s *There''s more..*. section,
    we will need to modify the second line of `quotes.js` in order to continue to
    insert quotes in our database:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Where `dave` and `cookit` are the example username and password.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-346
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We require `cradle` and make a connection to our `quotes` database. Our stream
    is intended for use with a pre-existing database, so we won't be checking for
    database existence.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Next, we call the `changes` method of `cradle` and listen to its `response`
    event, in turn listening to the passed in `response` emitter''s `data` event:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'To test our `changes` stream implementation we''ll open two terminals. In one
    we''ll run the following command:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: In the other terminal window we can add some quotes using `quotes.js:`
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '![How to do it...](img/7188-04-03.jpg)'
  id: totrans-355
  prefs: []
  type: TYPE_IMG
- en: As each new quote is added in the left-hand terminal, it appears in the right.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: '`quotes_stream.js` was opened up before any new quotes were added, and immediately
    displayed the `Albert Einstein` quote which was added in the *Storing data to
    CouchDB with Cradle* recipe. After this, new quotes appeared in the stream as
    they were added.'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-358
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `changes` method can be passed a callback, which simply returns all changes
    up to the present and then exits. If we do not pass a callback to `changes` it
    adds the `?feed=continuous` parameter to the HTTP CouchDB REST call and returns
    `EventEmitter`. CouchDB then returns a streamed HTTP response to Cradle which
    is sent through as the `response` parameter of the `response` event. The `response`
    parameter is also `EventEmitter`, and we listen for changes via the `data` event.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: On each `data` event, the callback handles the `change` parameter. Two data
    events are fired for each change, one is a JSON string, the other is a JavaScript
    object containing the equivalent JSON data. We check that the `change` parameter's
    type is an object (`changeIsObj`) before proceeding. The `change` object holds
    metadata for our database entries. It has a sequence number (`change.seq`), a
    revision number (`change.changes[0].rev`), it sometimes contains a deleted property
    (`changes.deleted`), and always has an `id` property.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: If the `deleted` property is found, we need to `return` early as `db.get` can't
    fetch a deleted record. Otherwise, we pass `change.id` into `db.get`, which provides
    access to a document ID. The `doc` is passed into the callback of `db.get`. We
    only want to output changes regarding our quotes, so we check for `author` and
    `quote` fields and log them to the console.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-362
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Storing data to CouchDB with Cradle* discussed in this chapter'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Retrieving data from CouchDB with Cradle* discussed in this chapter'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Implementing PubSub with Redis* discussed in this chapter'
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing and retrieving data with Redis
  id: totrans-366
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Redis** is a non-traditional database, dubbed a data structures server, which
    functions in operational memory with blazingly fast performance.'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: Redis is excellent for certain tasks, as long as the data model is fairly simple
    and isn't so large that it swamps your server RAM. Good examples of where Redis
    shines are in site analytics, server-side session cookies, and providing a list
    of logged-in users in real time.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: In the spirit of our theme, we will re-implement our quotes database with Redis.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-370
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll be using the `node_redis` client.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: We also need to install the Redis server, which can be downloaded from [http://www.redis.io/download](http://www.redis.io/download)
    along with installation instructions.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: Let's also create a new directory with a new `quotes.js` file.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-375
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's create the `redis` module, create a connection, and listen for the `ready`
    event emitted by the `redis client`, not forgetting to load the command-line arguments
    into the `params` object.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Next, we''ll check for `author` and `quote` via the command line. If they''re
    defined, we''ll insert these as hash (an object structure) into Redis, inside
    our `ready` event callback:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Not only did we add our data to Redis, we also constructed a basic index on
    the fly enabling us to search for quotes by author in our next piece of code.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: We check for the existence of the first command-line argument, the author, and
    then output quotes by that author.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: How it works...
  id: totrans-383
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If both `author` and `quote` are specified via the command line, we go ahead
    and generate a random key prefixed with `Quote:`. So each key will look something
    like `Quote:08d780a57b035f`. This helps us to identify keys in debugging and it's
    also common convention to prefix the Redis keys with names delimited by a colon.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: 'We pass this key into `client.hmset`, a wrapper for the Redis `HMSET` command,
    which allows us to create multiple hashes. Unlike the raw `HMSET, client.hmset`
    also accepts a JavaScript object (instead of an array) to create multiple key
    assignments. With the standard Redis command-line client, `redis-cli`, we would
    have to say:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: We could hold to this format by using an array containing keys next to values,
    but an object seems kinder and more familiar to the eyes of a JavaScript folk.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: Every time we store a new quote with `client.hmset`, we add the `randKey` for
    that quote to the relevant author set via the second parameter of `client.sadd.
    client.sadd` allows us to add a member to a Redis set (a set is like an array
    of strings). The key for our `SADD` command is based on the intended author. So
    in the Steve Jobs quote used above, the key to pass into `client.sadd` would be
    `Author:Steve Jobs`.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: Next, if an author is specified we perform an `SMEMBERS` using `client.smembers`.
    This returns all the values we stored to a specific authors' set, being the keys
    for all quotes relating to that author.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: We loop through these keys using `forEach`, passing every key into `client.hgetall`.
    Redis `HGETALL` returns hash (object) that we passed into `client.hmset` earlier.
    Each author and quote is then logged to the console, and `client.quit` gracefully
    exits our script once all Redis commands have been executed.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: A `client.quit` is also included at the end of the `ready` event on? occasions
    where no command-line arguments have been specified.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-392
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Redis is a speed freak's dream, but we can still make optimizations.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: Speeding up node Redis module
  id: totrans-394
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'By default, the `redis` module uses a pure JavaScript parser. However, the
    Redis project provides a Node `hiredis` module: a C bindings module which binds
    to the official Redis client, Hiredis. Hiredis is faster (being written in C)
    than the JavaScript parser.'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: The `redis` module will interface with the `hiredis` module if it is installed.
    Therefore, we can achieve performance benefits simply by installing `hiredis:`
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Overcoming network latency by pipelining commands
  id: totrans-398
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Redis can receive multiple commands at once. The `redis` module has a `multi`
    method which sends collated commands en masse. If the latency (time taken for
    data to travel) was 20 ms per command, for 10 combined commands we save 180 ms
    (10 x 20 - 20 = 180).
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: 'If we copy `quotes.js` to `quotes_multi.js` we can alter it accordingly:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: We can see our original Redis commands highlighted, only they have been chained
    with `client.multi`. Once all commands have been added to `client.multi`, we invoke
    its `exec` method. Finally, we use the callback of `exec` to verify that our data
    was successfully added.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: We didn't provision `SMEMBERS` for pipelining. `SMEMBERS` must be called after
    the quote has been added, or else the new quote won't be displayed. If `SMEMBERS`
    was combined with `HMSET` and `SADD` it would be executed asynchronously alongside
    them. There's no guarantee that the new quote would be available to `SMEMBERS`.
    In fact, it's unlikely since `SMEMBERS` is more complex than `SADD`, so it takes
    longer to process.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-404
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Storing and retrieving data with Mongoskin* discussed in this chapter'
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Connecting and sending SQL to a MySQL server* discussed in this chapter'
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Implementing PubSub with Redis* discussed in this chapter'
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing PubSub with Redis
  id: totrans-408
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Redis exposes a Publish-Subscribe messaging pattern (not so dissimilar to the
    CouchDB `changes` stream), which can be used to listen to specific data change
    events. Data from these events could be passed between processes to, for instance,
    instantly update a web app with fresh new data.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: With PubSub, we publish a message to a specific channel, this channel can then
    be picked up by any amount of subscribers. The publishing mechanism doesn't care
    who's listening or how many, it chats away regardless.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will create a publishing process and a subscribing process.
    For publishing, we'll extend our `quotes.js` file from the previous recipe *Storing
    and retrieving data with Redis*, and we'll write the code to a new file for the
    subscription mechanism.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-412
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's create a new directory, copy `quotes.js` from the previous recipe, and
    rename it to `quotes_publish.js`. We will also create a file called `quotes_subscribe.js`.
    We'll need to ensure that Redis is running. If it isn't installed and running
    globally, we can navigate to the directory Redis was unpacked to and run `./redis-server`
    from the `src` folder.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-414
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In `quotes_publish.js` we add one extra line of code inside our first conditional
    statement, just after our `client.sadd` call.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: This means every time we add an author and quote, we publish the quote to a
    channel named after the author. We subscribe to channels using `quotes_subscribe.js`,
    so let's code it.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: 'First, it must require the `redis` module and create a client:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: We're going to provide the option to subscribe to multiple channels, again using
    the command line as our elementary input method. To achieve this, we'll loop through
    `process.argv:`
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Now that we are subscribing to channels, we need to listen to messages:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'We can test our PubSub functionality by first running `quotes_subscribe.js`
    along with some specified authors:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Then we open a new terminal and run several authors and quotes through `quotes_publish.js`.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Let''s see it in action:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/7188-04-04.jpg)'
  id: totrans-429
  prefs: []
  type: TYPE_IMG
- en: Only the channels we subscribed to appeared on the `quotes_subscribe.js` terminal.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-431
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We access the Redis `PUBLISH` command in `quotes_publish.js` via `client.publish`,
    setting the channel name by author name.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: In `quotes_subscribe.js` we loop through any arguments given via command line.
    (We apply `forEach` to `process.argv.slice(2)`. This removes the first two elements
    of the `process.argv` array, which would hold the command (`node`) and the path
    to our script. Each relevant argument is passed to `client.subscribe`, telling
    Redis we wish to `SUBSCRIBE` to that channel.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: When a message arrives due to a subscription, the `redis` module `client` will
    emit a `message` event. We listen for this event and pass the incoming `channel`
    and `msg` (which will be `author` and `quote` accordingly) to `console.log`.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-435
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Finally, we'll take a look at Redis security.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: Redis authentication
  id: totrans-437
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can set authentication for Redis with the `redis.conf` file, found in the
    directory we installed Redis to. To set a password in `redis.conf`, we simply
    add (or uncomment) `requirepass ourpassword`.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we make sure that our Redis server points to the configuration file. If
    we are running it from the `src` directory, we would initiate with the following
    command:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'If we wanted to set a password quickly we could say:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'We could set a password from within Node with the `CONFIG SET` Redis command:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: To authenticate with a Redis server within Node, we can use the `redis` module's
    `auth` method, before any other calls (that is, prior to `client.ready)`.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: The password has to be sent before any other commands. The `redis` module's
    `auth` function takes of things like reconnections by pushing the password into
    the `redis` module's internal operations. Essentially, we can call `auth` at the
    top of our code and never concern ourselves with authentication for that script
    again.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: Securing Redis from external connections
  id: totrans-448
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If there was no need for external connections to Redis, we could bind it to
    `127.0.0.1`, inhibiting all external traffic.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: 'We can achieve this with a configuration file, for instance `redis.conf`, and
    add (or uncomment):'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Then, if running from the `src` folder, initialize our Redis server with:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Alternatively, we could do it as follows:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Or in Node with the `redis` module''s `config` method:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Note
  id: totrans-458
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If we installed Redis via a package manager it may already be configured to
    block external connections.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-460
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Accessing CouchDB changes stream with Cradle* discussed in this chapter'
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Storing and retrieving data with Redis* discussed in this chapter'
  id: totrans-462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
