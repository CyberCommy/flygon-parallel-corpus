- en: Chapter 4. Interfacing with Databases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Writing to a CSV file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting and sending SQL to a MySQL server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing and retrieving data with MongoDB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing and retrieving data with Mongoskin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing data to CouchDB with Cradle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retrieving data from CouchDB with Cradle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing CouchDB changes stream with Cradle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing and retrieving data with Redis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing PubSub with Redis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the complexity of our code and the demands of our objectives increase, we
    soon realize the need for a place to store our data.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then have to ask the question: What is the best way to store our data? The
    answer depends on the type of data we are working with since different challenges
    require different solutions.'
  prefs: []
  type: TYPE_NORMAL
- en: If we're doing something very simple, we could save our data as a flat CSV file,
    which has the added benefit of enabling users to view the CSV file in a spreadsheet
    application.
  prefs: []
  type: TYPE_NORMAL
- en: If we are working with data that has clearly relational qualities, for instance
    accounting data whereby there are clear, distinct relationships between two sides
    of a transaction, then we would choose a relational database such as the popular
    MySQL.
  prefs: []
  type: TYPE_NORMAL
- en: In many cases relational databases became a de facto standard for nearly all
    data scenarios. This led to the necessity of imposing relationships upon otherwise
    loosely-related data (such as website content) in an attempt to squeeze it into
    our relational mental model.
  prefs: []
  type: TYPE_NORMAL
- en: In recent times, though, there has been a movement away from relational databases
    towards NoSQL, a non-relational paradigm. The driving force being that we tailor
    our technology to best suit our data rather than trying to fit our data into our
    technology.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will look into various data storage technologies with examples
    of their usage in Node.
  prefs: []
  type: TYPE_NORMAL
- en: Writing to a CSV file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A flat file structure is one of the most elementary database models. Columns
    can either be fixed length, or use delimiters. The Comma Separated Values (CSV)
    convention conforms to the idea of delimited flat file structure databases. While
    it's called CSV, the term CSV is also applied as a broad blanket term for any
    basic delimited structure consisting of one record per line (for example, tab-separated
    values).
  prefs: []
  type: TYPE_NORMAL
- en: 'We could follow a brittle approach for constructing CSV structures, simply
    by using a multidimensional array and the `join` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: However, the limitations of this technique quickly become apparent. What if
    one of our fields contains a comma? Now one field becomes two, thus corrupting
    our data. Furthermore, we are limited to just using commas as delimiters.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe we will use the third-party `ya-csv` module to store data in
    the CSV format.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's create a file called `write_to_csv.js`, we'll also need to retrieve `ya-csv`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We require the `ya-csv` module, call its `createCsvFileWriter` method to instantiate
    a CSV file writer and loop through our array, calling the `writeRecord` method
    of the CSV file writer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Let's take a look at the file we saved to, `data.csv:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The difficulty with writing to and reading from CSV files is the edge cases,
    such as commas or quotes embedded in text. `ya-csv` handles these edge cases for
    us.
  prefs: []
  type: TYPE_NORMAL
- en: We load an instance of `CsvWriter` of `ya-csv` into the `writer` variable with
    `createCsvFileWriter`.
  prefs: []
  type: TYPE_NORMAL
- en: Then we simply loop through each array as `rec`, passing it to the `writeRecord`
    method of `CsvWriter` of `ya-csv`. Behind the scenes it re-factors each array
    and passes it to an instance of `fs.WriteStream`.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe depends upon us using a basic data structure in our code. Multidimensional
    objects would have to be massaged into the right format as `writeRecord` only
    functions with arrays.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Could we easily create this functionality ourselves? Without a doubt. However,
    `ya-csv` provides an API for us to seamlessly customize the elements of our CSV
    files, and implements the more involved CSV parsing functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing the CSV elements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If we save our recipe file as `write_to_custom_csv.js`, and pass an `options`
    object to `createCsvFileWriter`, we can alter the way our CSV files are constructed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice the `escape` option. This sets the character which will prevent accidental
    closure of a CSV field. Let''s slip one into our array to see how `ya-csv` handles
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: After running our new code, let's take a look at `custom_data.csv:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: See how our pipe character in the `e` field has another pipe appended to it
    in order to escape it.
  prefs: []
  type: TYPE_NORMAL
- en: Reading a CSV file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can also use `ya-csv` to read from a CSV file, its built-in parser converts
    each CSV record back into an array. Let's make `read_from_csv.js`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: If we want it to parse alternative delimiters and quotes, we simply pass these
    into the `options` object of `createCsvFileReader:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Manipulating CSV as a stream
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`ya-csv` interacts with CSV files as streams. This can reduce operational memory
    since streams allow us to process small chunks of information as they are loaded,
    instead of buffering the entire file into memory first.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Connecting and sending SQL to a MySQL* server discussed in this chapter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Storing and retrieving data with Mongoskin* discussed in this chapter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Storing data to CouchDB with Cradle* discussed in this chapter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Storing and retrieving data with Redis* discussed in this chapter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting and sending SQL to a MySQL server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Structured Query Language has been a standard since 1986 and it's the prevailing
    language for relational databases. MySQL is the most popular SQL relational database
    server around, often appearing in the prevalent LAMP (Linux Apache MySQL PHP)
    stack.
  prefs: []
  type: TYPE_NORMAL
- en: If a relational database was conceptually relevant to our goals in a new project,
    or we were migrating a MySQL-backed project from another framework to Node, the
    third-party `mysql` module would be particularly useful.
  prefs: []
  type: TYPE_NORMAL
- en: In this task, we will discover how to connect to a MySQL server with Node and
    execute SQL queries across the wire.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's grab `mysql`, which is a pure JavaScript (as opposed to C++ bound) MySQL
    client module.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We'll need a MySQL server to connect to. By default, the `mysql` client module
    connects to `localhost`, so we'll have MySQL running locally.
  prefs: []
  type: TYPE_NORMAL
- en: 'On Linux and Mac OSX we can see if MySQL is already installed with the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'And we can see if it is running using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If it is installed but not running, we can do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: If MySQL isn't installed we can use the relevant package manager for our system
    (homebrew, apt-get/synaptic, yum, and so on), or if we're using Node on Windows
    we can head to [http://dev.mysql.com/downloads/mysql](http://dev.mysql.com/downloads/mysql)
    and download the installer.
  prefs: []
  type: TYPE_NORMAL
- en: Once we're ready to go, let's create a file and call it `mysql.js`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we require the third-party `mysql` driver, and create a connection to
    the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We need a database to connect to. Let''s keep things interesting and make a
    `quotes` database. We can do that by passing SQL to the `query` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We've also called the `useDatabase` method to connect to the database, although
    we could achieve the same with `client.query('USE quotes')`. Now we'll create
    a table by the same name.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: If we were to run our code more than once, we'd notice that an unhandled error
    is thrown and the program fails. This is due to the `mysql` driver emitting an
    error event in reflection of a MySQL server error. It's throwing an unhandled
    error because the `quotes` database (and table) cannot be created as they already
    exist.
  prefs: []
  type: TYPE_NORMAL
- en: 'We want our code to be versatile enough to create a database if necessary,
    but not throw an error if it''s not there. To do this, we''re going to catch any
    errors emitted by our client instance, filtering out the database/table exists
    errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We'll place our error catcher just before the `client.query` method invocations.
    Finally, at the end of our code, we'll insert our first quote into the table and
    send a `COM_QUIT` packet (using `client.end)` to the MySQL server. This will only
    close the connection once all queued SQL has been executed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `createClient` method establishes a connection to the server and returns
    a client instance for us to interact with. We can pass it as an `options` object
    that may contain `host, port, user, password, database, flags`, and `debug` .
    Other than `user` and `password`, the default options are fine for our purposes
    though. If we uncomment `debug` we can see the raw data being sent to and from
    the server.
  prefs: []
  type: TYPE_NORMAL
- en: '`client.query` sends SQL to our database which is then executed by the MySQL
    server. With it, we `CREATE` a `DATABASE` named `quotes` and also a `TABLE` named
    `quotes`. Then we `INSERT` our first record (a quote by the inventor of C++) into
    our database.'
  prefs: []
  type: TYPE_NORMAL
- en: '`client.query` queues each piece of SQL passed to it, executing statements
    asynchronously alongside our other code, but sequentially within the SQL statement
    queue. When we call `client.end`, the connection closing task is added to the
    end of the queue. If we wanted to disregard the statement queue, and immediately
    end the connection, we would use `client.destroy`.'
  prefs: []
  type: TYPE_NORMAL
- en: Our `ignore` array holds two numbers, `1007` and `1050 — we` grab these numbers
    from the `mysql` object, which holds MySQL error codes. We want to ignore MySQL
    errors that occur when a table or database already exists, otherwise we could
    only run `mysql.js` once. After the first run it would crash since the database
    and table would already exist. Ignoring these codes means we can implicitly set
    up our database, and have just one file rather than a setup app and a separate
    app for inserting code.
  prefs: []
  type: TYPE_NORMAL
- en: In the `error` event listener we check if `err.number` is within our `ignore`
    array. If it is, we simply `return`, thus ignoring the error and gracefully continuing
    execution. If the error is of some other nature, we fall through to the usual
    behavior of throwing the error.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We don't just send data to MySQL, we retrieve it. Furthermore, SQL queries are
    often generated from user input, but this can be open to exploitation if precautions
    aren't taken.
  prefs: []
  type: TYPE_NORMAL
- en: Using and cleaning user input
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As in other languages that build SQL statements with string concatenation, we
    must prevent the possibilities of SQL injection attacks to keep our server safe.
    Essentially, we must clean (which is, escape) any user input to eradicate the
    potential for unwanted SQL manipulation.
  prefs: []
  type: TYPE_NORMAL
- en: We'll copy `mysql.js` and call it `insert_quotes.js`. To implement the concept
    of user input in a simple way we'll pull arguments from the command line, but
    the principles and methods of data cleaning extend to any input method (for example,
    via a query string on a request).
  prefs: []
  type: TYPE_NORMAL
- en: 'Our basic API will go like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Quotation marks are essential to divide the command-line arguments, but for
    the sake of brevity we won't be implementing any validation checks.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Command-line parsing module: optimist**'
  prefs: []
  type: TYPE_NORMAL
- en: For more advanced command-line functionality, check out the excellent `optimist`
    module , available at [https://www.github.com/substack/node-optimist](https://www.github.com/substack/node-optimist).
  prefs: []
  type: TYPE_NORMAL
- en: To receive an author and quote, we'll load the two quotes arguments into a new
    `params` object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Our first argument is at `2` in the `process.argv` array because `0` and `1`
    hold `node` and `quotes.js`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s slightly modify our `INSERT` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We've placed this just before our final `client.end` call in the main recipe.
    The `mysql` module can seamlessly clean user input for us. We simply use the question
    mark (?) as a placeholder and then pass our values (in order) as an array into
    the second parameter of `client.query`.
  prefs: []
  type: TYPE_NORMAL
- en: Receiving results from the MySQL server
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's extend `insert_quotes.js` further by outputting all quotes for an author,
    whether or not a quote is provided. We'll save `insert_quotes.js` simply as `quotes.js`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Underneath our `INSERT` query, but above the final `client.end`, we''ll add
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: On this occasion, we've used an alternative approach to clean user input with
    `client.escape`. This has exactly the same effect as the former, but only escapes
    a single input. Generally, if there's more than one variable, the former method
    would be preferable.
  prefs: []
  type: TYPE_NORMAL
- en: The results of a `SELECT` statement can be accessed either by passing a callback
    function, or by listening for the `row` event. A `row` event listener allows us
    to interact with a MySQL server data stream, one row at a time.
  prefs: []
  type: TYPE_NORMAL
- en: We can safely call `client.end` without putting it in the `end` event of our
    `SELECT` query because `client.end` only terminates a connection when all queries
    are done.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Storing and retrieving data with MongoDB* discussed in this chapter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Storing and retrieving data with Redis* discussed in this chapter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing and retrieving data with MongoDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MongoDB is a NoSQL database offering that maintains a philosophy of performance
    over features. It's designed for speed and scalability. Instead of working relationally,
    it implements a document-based model that has no need for schemas (column definitions).
    The document model works well for scenarios where relationships between data are
    flexible and where minimal potential data loss is an acceptable cost for the speed
    enhancements (a blog for instance).
  prefs: []
  type: TYPE_NORMAL
- en: While it's in the NoSQL family, MongoDB attempts to sit between two worlds,
    providing a syntax reminiscent of SQL but operating non-relationally.
  prefs: []
  type: TYPE_NORMAL
- en: In this task, we'll implement the same `quotes` database as in the previous
    recipe, using MongoDB instead of MySQL.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll want to run a MongoDB server locally. It can be downloaded from [http://www.mongodb.org/downloads](http://www.mongodb.org/downloads).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start the MongoDB service, `mongod`, in the default debug mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This allows us to observe the activities `mongod` as it interacts with our code,
    if we wanted to start it as a persistent background service we would use.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Where `[p]` is our desired path.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: More information on starting and correctly stopping `mongod` can be found at
    [http://www.mongodb.org/display/DOCS/Starting+and+Stopping+Mongo](http://www.mongodb.org/display/DOCS/Starting+and+Stopping+Mongo).
  prefs: []
  type: TYPE_NORMAL
- en: To interact with MongoDB from Node, we'll need to install the `mongodb` native
    bindings driver module.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We'll also create a new folder for our MongoDB-based project, with a new `quotes.js`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We must require the `mongodb` driver, initiate a MongoDB server instance, and
    create a client which loads the quotes database and connects to the MongoDB server.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Notice we've also inserted our `params` object for reading user input from the
    command line.
  prefs: []
  type: TYPE_NORMAL
- en: Now we open a connection to our `quotes` database and load (or create if necessary)
    our `quotes` collection (a table would be the closest similar concept in SQL).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Next, we'll insert a new document (in SQL terms this would be a record) according
    to a user-defined author and quote.
  prefs: []
  type: TYPE_NORMAL
- en: We'll also output any quotes by the specified author to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see our MongoDB backed quotes application in action in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/7188-04-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we create a new instance of `mongo.Db`, we pass in the name of the database
    as the first parameter. MongoDB will intelligently create this database if it
    doesn't exist.
  prefs: []
  type: TYPE_NORMAL
- en: We use the `open` method of the `Db` instance, which we named `client`, to open
    a connection to our database. Once the connection is made, our callback function
    is executed where we can interact with the database via the `client` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: We start off by making a `Collection` instance. `Collection` is similar to an
    SQL table in that it holds all our database fields. However, rather than field
    values being grouped by column, a collection contains multiple documents (like
    records) where each field holds both the field name and its value (documents are
    very much like JavaScript objects).
  prefs: []
  type: TYPE_NORMAL
- en: If both `quote` and `author` are defined, we invoke the `insert` method of our
    `Collection` instance, passing in an object as our document.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we use `find` which is comparable to the `SELECT` SQL command, passing
    in an object that specifies the author field and desired value. The `mongodb`
    driver provides a convenience method (each) that can be chained with the `find`
    method. `each` executes the callback passed to it for each document as it's found.
    The last loop of `each` passes in `doc` as `null`, which conveniently signals
    that MongoDB has returned all records.
  prefs: []
  type: TYPE_NORMAL
- en: So as long as `doc` is truthy, we pass the `author` and `quote` properties of
    every `doc` found. Once `doc` is `null`, we allow the interpreter to discover
    the last part of the callback, `client.close`, by not returning early from the
    callback.
  prefs: []
  type: TYPE_NORMAL
- en: The second and final `client.close` situated at the end of the `client.open`
    callback is invoked only when there are no arguments defined via the command line.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's check out some other useful MongoDB features.
  prefs: []
  type: TYPE_NORMAL
- en: Indexing and aggregation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Indexing causes MongoDB to create a list of values from a chosen field. Indexed
    fields accelerate query speeds because a smaller set of data can be used to cross
    reference and pull from a larger set. We can apply an index to the author field
    and see performance benefits, especially as our data grows. Additionally, MongoDB
    has various commands allowing us to aggregate our data. We can group, count, and
    return distinct values.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more advanced needs or larger sets of data, map/reduce functions can aggregate.
    CouchDB also uses map/reduce to generate views (stored queries), See *Retrieving
    data from CouchDB with Cradle*.
  prefs: []
  type: TYPE_NORMAL
- en: Let's create and output a list of authors found in our database, and save our
    code to a file called `authors.js`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: As usual, we opened up a connection to our `quotes` database, grabbing our `quotes`
    collection. Using `ensureIndex` creates an index only if one doesn't already exist.
    We pass in `safe:true` so that MongoDB returns any errors and our callback works
    as expected. Inside the callback, we invoke the `distinct` method on our `collection`,
    passing in `author`. The result is passed as an array through as `result`. We
    `join` the array into a string using new lines and output to the console. .
  prefs: []
  type: TYPE_NORMAL
- en: Updating modifiers, sort, and limit
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We could make it possible for a hypothetical user to indicate if they were inspired
    by a quote (such as a **Like** button), then we could use the `sort` and `limit`
    commands to output the top ten most inspiring quotes.
  prefs: []
  type: TYPE_NORMAL
- en: In reality, this would be implemented with some kind of user interface (for
    example, in a browser), but we'll again emulate user interactions using the command
    line; let's create a new file called `quotes_votes.js`.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, in order to vote for a quote, we''ll need to reference it, which can
    be done by the unique `_id` property. So in `quotes_votes.js` let''s write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now when we run `quotes_votes.js` with `node`, we''ll see a list of IDs and
    quotes. To vote for a quote, we''ll simply copy an ID and use it as our command-line
    parameter. So let''s do our vote handling as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: MongoDB IDs must be encoded as a BSON (Binary JSON) ObjectID. Otherwise, the
    `update` command will look for `param.id` as a string, failing to find it. So
    we create a `new mongo.ObjectID(param.id)` to convert `param.id` from a JavaScript
    string to a BSON ObjectID.
  prefs: []
  type: TYPE_NORMAL
- en: '`$inc` is a MongoDB modifier that performs the incrementing action inside the
    MongoDB server, essentially allowing us to outsource the calculation. To use it,
    we pass a document (object) alongside it containing the key to increment and the
    amount to increase it by. So we pass `votes` and `1`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`$inc` will create the `votes` field if it doesn''t exist, and increment it
    by one (we can also decrement using minus figures). Next are the options to be
    passed to MongoDB. We''ve set `safe` to `true`, which tells MongoDB to check that
    the command was successful and send any errors if it wasn''t. For the callback
    to work correctly, `safe:true` must be passed, otherwise errors are not caught,
    and the callback occurs immediately.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Upserting**'
  prefs: []
  type: TYPE_NORMAL
- en: Another useful option we can set is `upsert:true`. This is a really convenient
    MongoDB feature that either updates a record or inserts it if it doesn't exist.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `update` callback we run a chain of `find.sort.limit.each. find`,
    without any parameters, which returns all our records. `sort` requires keys and
    a positive or negative `1`, indicating ascending or descending. `limit` takes
    an integer of maximum records, and `each` loops through our records. Inside the
    `each` callback, we output every `author, quote`, and `votes` of `doc`, closing
    the connection when no `docs` are left.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Connecting and sending SQL to a MySQL server* discussed in this chapter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Storing and retrieving data with Mongoskin* discussed in this chapter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Storing data to CouchDB with Cradle* discussed in this chapter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing and retrieving data with Mongoskin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mongoskin is a convenience library providing a high-level interface for `mongodb`
    without blocking access to the existing `mongodb` methods.
  prefs: []
  type: TYPE_NORMAL
- en: For this recipe, we'll re-implement the `quotes` database in MongoDB using Mongoskin.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll need the `mongoskin` module.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We can also create a new folder, with a new `quotes.js` file.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll require `mongoskin` and use it to make a `client` and a `collection` instance.
    We don't need to create a `server` instance, nor manually open the client as in
    the former recipe, `mongoskin` takes care of that.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: As in the previous recipe, we've defined our `params` object for user input.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of requiring us to use JavaScript's potentially human error prone `new`
    keyword, `mongoskin` provides a builder method (`mongo.db`), allowing us to define
    our host, port, and database name with the familiar URI schema.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: See [http:// www. yuiblog.com/blog/2006/11/13/javascript-we-hardly-new-ya/](http://
    www. yuiblog.com/blog/2006/11/13/javascript-we-hardly-new-ya/) for why the `new`
    prefix could be considered error prone.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we don''t need to `open` our `client (mongoskin` opens it for us), we
    can just go ahead and implement our `insert` and `find` operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: And we're done.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We transparently connect to our database using Mongoskin's `db` method, and
    we're immediately able to grab our collection.
  prefs: []
  type: TYPE_NORMAL
- en: As in our previous recipe, we check for the `author` and `quote` command-line
    arguments, and then call the `mongodb insert` method which is inherently available
    through the `mongoskin` module.
  prefs: []
  type: TYPE_NORMAL
- en: Next, after checking for author, we use the `findEach` method of `mongoskin`.
    The `findEach` method wraps `collection.find.each` as used in the previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Within `findEach` we output the `author` and `quote` properties of each `doc`
    to the console. When there's no documents left, we explicitly `close` the `client`
    connection.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Mongoskin does an excellent job of making our lives easier. Let's look at another
    Mongoskin feature that simplifies our interactions with MongoDB.
  prefs: []
  type: TYPE_NORMAL
- en: Collection binding
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Mongoskin provides a `bind` method that makes a collection available as a property
    of our `client` object. So if we did:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: We could access the quotes collection via `client.quotes`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This means we can discard the `collection` variable and use binding instead.
    The `bind` method also accepts an object of methods, which then applies to the
    bound collection. For instance, if we defined a method called `store`, we would
    access it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: So let's create a new file called `quotes_bind.js` to re-implement `quotes.js`
    in Mongoskin, this time using the collection binding approach.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll begin with our top-level variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We have no need for a `collection` variable since we'll be accessing our collection
    via `bind`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s define a `store` method for inserts and a `show` method for displaying
    quotes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Then our logic to interact with our new bound methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The `bind` method of Mongoskin painlessly abstracts involved database operations
    into an easy dot-notation format.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We baked some of our `params` checking functionality into our `store` method,
    only calling `insert` if a quote exists. In all our recipes, we only needed to
    check for the second argument (`params.quote`), we couldn't have `params.quote`
    without `params.author`. Both arguments were checked in the prior recipes to demonstrate
    how it might work in other scenarios (for instance, if we received our parameters
    via a POST request).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Storing and retrieving data with MongoDB* discussed in this chapter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Storing data to CouchDB with Cradle* discussed in this chapter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Retrieving data from CouchDB with Cradle* discussed in this chapter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing data to CouchDB with Cradle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to achieve stellar performance speeds, MongoDB has a relaxed view towards
    ACID (Atomicity Consistency Isolation Durability) compliance. However, this means
    there is an (unlikely) chance that data can become corrupted (especially if there
    was a power cut in the middle of an operation). CouchDB, on the other hand, is
    ACID compliant to the extent that, when replicated and synchronized, data eventually
    becomes consistent. Therefore, while slower than MongoDB, it has the added reliability
    advantage.
  prefs: []
  type: TYPE_NORMAL
- en: CouchDB is entirely administrated via HTTP REST calls, so we could do all of
    our work with CouchDB using `http.request`. Nevertheless, we can use Cradle to
    interact with CouchDB in an easy, high-level way, along with the added speed enhancement
    of automated caching.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we'll use Cradle to store famous quotes to CouchDB.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll need to install and run CouchDB, we can head on to [http://wiki.apache.org/couchdb/Installation](http://wiki.apache.org/couchdb/Installation)
    for instructions on how to install for your particular operating system.
  prefs: []
  type: TYPE_NORMAL
- en: After installation, we can check if CouchDB is running and access the Futon
    administration panel by pointing our browser to [http://localhost:5984/_utils](http://localhost:5984/_utils).
  prefs: []
  type: TYPE_NORMAL
- en: We'll also need the `cradle` module.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: And we can create a new folder with a new `quotes.js` file in it.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we require `cradle` and load our quotes database, creating it if necessary.
    We''ll also define an error-handling function and our `params` object for easy
    command-line interaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we can write to our database, we need to know it exists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that we pass in `checkAndSave` as the callback of `db.create`, the following
    function goes above the `db.exists` invocation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The `err` parameter we are handling in `checkAndSave` would have been passed
    in from `db.create`.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'CouchDB is administrated via HTTP requests, but Cradle provides an interface
    for making these requests. When we invoke `db.exists`, Cradle sends a HEAD request
    to `http://localhost:5984/quotes` and checks whether the reply status is `404
    Not Found` or `200 OK`. We could perform the same check with command-line program''s
    `curl` and `grep` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'This would output `1` if the database exists, and `0` if it does not. If our
    database doesn''t exist, we call the `db.create` method of `cradle` which sends
    an HTTP PUT request to the CouchDB server. In `curl` this would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: We pass in our `checkAndSave` function as the callback of `db.create`, or we
    call it from the callback of `db.exists` if the database does exist. This is essential.
    We cannot save data to a database that doesn't exist and we have to wait for the
    HTTP response before we know whether it exists (or whether it has been created).
  prefs: []
  type: TYPE_NORMAL
- en: '`checkAndSave` looks for command-line arguments, and then saves the data accordingly.
    For instance, if we ran the following from the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '`checkAndSave` would realize there are two parameters passing these as `author`
    and `quote` to `db.save`. Cradle would then POST the following, with `Content-Type`
    set to `application/json:`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: On top of this, Cradle adds a caching layer, which in our example is of little
    use since caching data is lost whenever our application exits. However, in server
    implementation, the caching would become very useful in answering similar requests
    quickly and efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Couch stands for **Cluster Of Unreliable Commodity Hardware**, let's take a
    brief look at the clustering side of CouchDB.
  prefs: []
  type: TYPE_NORMAL
- en: Scaling CouchDB with BigCouch
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Scaling is about making your application responsive to an anticipated demand,
    but different projects have different characteristics. Therefore, each scaling
    venture requires an individualized approach.
  prefs: []
  type: TYPE_NORMAL
- en: If a web service was heavily built around database interaction, scaling the
    database layer would be a priority when responding to changes in service demand.
    Scaling CouchDB (or anything else) can be a very in-depth procedure, necessarily
    so for specialized projects.
  prefs: []
  type: TYPE_NORMAL
- en: However, the Open Source BigCouch project has an ability to scale CouchDB in
    a transparent and generic fashion. With BigCouch, we can scale CouchDB across
    servers, but interact with it as if it was on one server. BigCouch can be found
    at [https://www. github.com/cloudant/bigcouch](https://www. github.com/cloudant/bigcouch).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Retrieving data from CouchDB with Cradle* discussed in this chapter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Storing and retrieving data with MongoDB* discussed in this chapter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Storing and retrieving data with Redis* discussed in this chapter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retrieving data from CouchDB with Cradle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CouchDB doesn't use the same query paradigm that MySQL and MongoDB subscribe
    to. Instead, it uses a pre-created view to retrieve the desired data.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we'll use Cradle to obtain an array of quotes according to
    the specified author, outputting our quotes to the console.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As in the previous recipe, *Storing data to CouchDB with Cradle*, we'll need
    CouchDB installed on our system, along with `cradle`. We can also take the `quotes.js`
    file from that recipe, placing it in a new directory.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''re working on the `quotes.js` file from the prior task where we called
    `checkAndSave` if our database existed, or we called it from the callback of `db.create`
    if it didn''t exist. Let''s modify `checkAndSave` slightly as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: We've added a new function invocation, `outputQuotes`, to the end of `checkAndSave`
    and also as the callback of `db.save. outputQuotes` is going to access a special
    CouchDB `_design` document called a view.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we look at `outputQuotes`, let''s look into another new function we''ll
    be creating called `createQuotesView`. It should be placed just under `errorHandler`
    but above the rest of the code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '`createQuotesView` also calls the `outputQuotes` function from the `db.save`
    callback parameter. `outputQuotes` is now called from three places: the `db.save`
    callback of `checkAndSave`, the end of `checkAndSave`, and in the `db.save` callback
    of `createQuotesView`.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at `outputQuotes:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '`outputQuotes` goes before `checkAndSave`, but after `createQuotesView`.'
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The key to querying a CouchDB database is views. There are two types of views:
    permanent and temporary. In `createQuotesView` we define a permanent view using
    `db.save`, setting the document ID to `_design/quotes`. We then define a `views`
    field containing an object called `byAuthor` which holds a key called `map` whose
    value is a string formatted function.'
  prefs: []
  type: TYPE_NORMAL
- en: Temporary views would be stored with an ID of `quotes/_temp_view`. However,
    these should only be used for testing,. They're very expensive computationally
    and shouldn't be used for production.
  prefs: []
  type: TYPE_NORMAL
- en: 'The mapping function is string formatted because it''s passed to CouchDB via
    an HTTP request. CouchDB `map` functions are not executed with Node, they run
    within the CouchDB server. A `map` function defines the query we wish to run on
    the database through the CouchDB servers `emit` function. The first argument of
    `emit` specifies which field to query, (in our case `doc.author)`, and the second
    specifies what to output as a result of the query (we want the whole `doc)`. If
    we wanted to search for Albert Einstein, we would make a GET request to: `http://localhost:5984/quotes/_design/quotes/_view/byAuthor?key="Albert
    Einstein"`.'
  prefs: []
  type: TYPE_NORMAL
- en: Cradle provides a shorthand method for this request, `db.view`, which appears
    in our `outputQuotes` function. `db.view` allows us to simply pass in `quotes/byAuthor`
    with a second object containing the `key` parameter (that is, our query), essentially
    filling in the special underscore routes for us.
  prefs: []
  type: TYPE_NORMAL
- en: '`db.view` parses the incoming JSON and provides it via the second parameter
    of its callback, which we named `rowsArray`. We loop through the array using `forEach`
    and finish off by outputting `author` and `quote` to the console, as in previous
    recipes.'
  prefs: []
  type: TYPE_NORMAL
- en: However, before we loop through the array we need to check that our view actually
    exists. Views only need to be generated once. After this, they are stored in the
    CouchDB database. Therefore, we don't want to create a view every time we run
    our application. So when we call `db.view` we look to see if a `not_found` error
    occurs in the `db.view` callback. If our view isn't found, we call `createQuotesView`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In broad terms, the process goes something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/7188_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: CouchDB is great for getting to grips right out of the box. However, there are
    certain security considerations we must be attuned to before deploying a CouchDB-backed
    app to the web.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an admin user
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'CouchDB requires no initial authorization settings, which is fine for development.
    However, as soon as we expose CouchDB to the outside world, anyone on the Internet
    has permission to edit our entire database: data designs, configuration, users,
    and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So before deploying, we want to set a username and password. We can achieve
    this with the `_config` API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: We have created the admin user `dave` and set the password to `cookit`. Now
    the right to certain calls will be denied without authentication, including the
    creation or deletion of databases, modifying design documents (for example, for
    views), or access to the `_config` API.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, say we wanted to view all admin users, we could say:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'CouchDB will reply:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if we include authentication information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'We get our only admin user along with a hash of his password:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Using this method to remotely administer a CouchDB database is not without its
    security flaws. It forces us to send passwords as plain text over non-secure HTTP.
    Ideally, we need to host CouchDB behind an HTTPS proxy so the password becomes
    encrypted as it's sent. See the recipe *Setting up an HTTPS server* discussed
    In [Chapter 7](ch07.html "Chapter 7. Implementing Security, Encryption, and Authentication"),Implementing
    Security, Encryption, and Authentication
  prefs: []
  type: TYPE_NORMAL
- en: 'If CouchDB is behind HTTPS, `cradle` can connect to it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: We pass an `options` object when we create our connection. The `secure` property
    tells `cradle` we are using SSL, and `auth` contains a sub-object with login details.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, we create a Node app to authenticate with a local CouchDB instance
    (so that no password is sent to an external HTTP address) and act as a layer between
    external requests and CouchDB.
  prefs: []
  type: TYPE_NORMAL
- en: Locking all modifying operations to an admin user
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Even if an admin user is set, unauthenticated users still have permission to
    modify existing databases. If we were only writing to CouchDB server side (but
    reading from either server or clients), we could lock all write operations for
    non-admin users with a validation function.
  prefs: []
  type: TYPE_NORMAL
- en: 'A validation function is written in JavaScript and runs on the CouchDB server
    (like a map function). Once a validation function is defined, it''s executed against
    all user input for the database it is applied to. Three objects appear as parameters
    in the function: the new document (`newDoc`), the previous currently stored document
    (`savedDoc`), and the user context (`userCtx`), which holds authenticated user
    information.'
  prefs: []
  type: TYPE_NORMAL
- en: Within a validation function we can examine and qualify these objects, calling
    CouchDB's `throw` function to reject operation requests that fail to meet our
    requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s make a new file called `database_lockdown.js`, and begin by connecting
    to our database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: We pass in an `options` object to the new cradle connection. It contains authentication
    information which will now be necessary to create a validation function if we
    have set a new admin user according to the previous subsection *Creating an admin
    user*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create our validation function, and save it as a `_design` document:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as we execute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: All write-related operations will now require authorization.
  prefs: []
  type: TYPE_NORMAL
- en: Like views, we store validation functions within a document that has a `_design/`
    prefixed ID. The other part of the ID can be anything, but we named it `_auth`
    which reflects conventional practice when a validation function serves this type
    of purpose. The field name, though, must be called `validate_doc_update`.
  prefs: []
  type: TYPE_NORMAL
- en: By default Cradle assumes any `_design` documents passed to `db.save` are a
    view. In order to prevent Cradle from wrapping our `validate_update_doc` field
    into a view, we specify an empty object to the `views` property.
  prefs: []
  type: TYPE_NORMAL
- en: '`validate_update_doc` must be passed a string-formatted function, so we define
    our function under the `admin_lock` variable and call `toString` on it as it''s
    passed into `db.save`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`admin_lock` is never intended for execution by Node. It''s an aesthetic approach
    to constructing our function before passing it to CouchDB.'
  prefs: []
  type: TYPE_NORMAL
- en: When an operation occurs on the database, our `admin_lock` function (which becomes
    CouchDB's `validate_update_doc` function) asks CouchDB to check if the user requesting
    the operation has the `_admin` user role. If not, it tells CouchDB to throw an
    unauthorized error thus denying access.
  prefs: []
  type: TYPE_NORMAL
- en: Exposing the CouchDB HTTP interface to remote connections
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'By default, CouchDB binds to `127.0.0.1`. This ensures that only local connections
    can be made to the database ensuring safety prior to security enforcements. Once
    we have CouchDB set up behind HTTPS with at least one admin user set, we can bind
    CouchDB to `0.0.0.0` which makes the REST interface accessible via any IP address.
    This means that remote users can access our CouchDB HTTP interface via our server''s
    public IP address, or more likely via our server''s domain name. We can set the
    bind address with `_config` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Where `u` and `p` are the admin username and password, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Storing data to CouchDB with Cradle* discussed in this chapter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Storing and retrieving data with MongoDB* discussed in this chapter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Setting Up and HTTPS Web Server discussed in* [Chapter 7](ch07.html "Chapter 7. Implementing
    Security, Encryption, and Authentication"),Implementing Security, Encryption,
    and Authentication'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing CouchDB changes stream with Cradle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of CouchDB's most noteworthy features is the `_changes` API. With it we
    can view all alterations to a database via HTTP.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, to see all changes made to our `quotes` database we can make a
    GET request to `http://localhost:5984/quotes/_changes`. Even better, if we wanted
    to hook up to a live stream, we would add the query parameter `?feed=continuous`.
  prefs: []
  type: TYPE_NORMAL
- en: Cradle provides an attractive interface to the `_changes` API, which we'll explore
    in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll need a functioning CouchDB database and a way to write to it. We can use
    the `quotes.js` example used in *Storing data to CouchDB with Cradle*, so let's
    copy that into a new directory and then create a file alongside it called `quotes_stream.js`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we followed the *Creating an admin user* and *Locking all modifying operations
    to an admin user* sections of the previous recipe''s *There''s more..*. section,
    we will need to modify the second line of `quotes.js` in order to continue to
    insert quotes in our database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Where `dave` and `cookit` are the example username and password.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We require `cradle` and make a connection to our `quotes` database. Our stream
    is intended for use with a pre-existing database, so we won't be checking for
    database existence.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we call the `changes` method of `cradle` and listen to its `response`
    event, in turn listening to the passed in `response` emitter''s `data` event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'To test our `changes` stream implementation we''ll open two terminals. In one
    we''ll run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: In the other terminal window we can add some quotes using `quotes.js:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '![How to do it...](img/7188-04-03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As each new quote is added in the left-hand terminal, it appears in the right.
  prefs: []
  type: TYPE_NORMAL
- en: '`quotes_stream.js` was opened up before any new quotes were added, and immediately
    displayed the `Albert Einstein` quote which was added in the *Storing data to
    CouchDB with Cradle* recipe. After this, new quotes appeared in the stream as
    they were added.'
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `changes` method can be passed a callback, which simply returns all changes
    up to the present and then exits. If we do not pass a callback to `changes` it
    adds the `?feed=continuous` parameter to the HTTP CouchDB REST call and returns
    `EventEmitter`. CouchDB then returns a streamed HTTP response to Cradle which
    is sent through as the `response` parameter of the `response` event. The `response`
    parameter is also `EventEmitter`, and we listen for changes via the `data` event.
  prefs: []
  type: TYPE_NORMAL
- en: On each `data` event, the callback handles the `change` parameter. Two data
    events are fired for each change, one is a JSON string, the other is a JavaScript
    object containing the equivalent JSON data. We check that the `change` parameter's
    type is an object (`changeIsObj`) before proceeding. The `change` object holds
    metadata for our database entries. It has a sequence number (`change.seq`), a
    revision number (`change.changes[0].rev`), it sometimes contains a deleted property
    (`changes.deleted`), and always has an `id` property.
  prefs: []
  type: TYPE_NORMAL
- en: If the `deleted` property is found, we need to `return` early as `db.get` can't
    fetch a deleted record. Otherwise, we pass `change.id` into `db.get`, which provides
    access to a document ID. The `doc` is passed into the callback of `db.get`. We
    only want to output changes regarding our quotes, so we check for `author` and
    `quote` fields and log them to the console.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Storing data to CouchDB with Cradle* discussed in this chapter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Retrieving data from CouchDB with Cradle* discussed in this chapter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Implementing PubSub with Redis* discussed in this chapter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing and retrieving data with Redis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Redis** is a non-traditional database, dubbed a data structures server, which
    functions in operational memory with blazingly fast performance.'
  prefs: []
  type: TYPE_NORMAL
- en: Redis is excellent for certain tasks, as long as the data model is fairly simple
    and isn't so large that it swamps your server RAM. Good examples of where Redis
    shines are in site analytics, server-side session cookies, and providing a list
    of logged-in users in real time.
  prefs: []
  type: TYPE_NORMAL
- en: In the spirit of our theme, we will re-implement our quotes database with Redis.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We'll be using the `node_redis` client.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: We also need to install the Redis server, which can be downloaded from [http://www.redis.io/download](http://www.redis.io/download)
    along with installation instructions.
  prefs: []
  type: TYPE_NORMAL
- en: Let's also create a new directory with a new `quotes.js` file.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's create the `redis` module, create a connection, and listen for the `ready`
    event emitted by the `redis client`, not forgetting to load the command-line arguments
    into the `params` object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''ll check for `author` and `quote` via the command line. If they''re
    defined, we''ll insert these as hash (an object structure) into Redis, inside
    our `ready` event callback:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Not only did we add our data to Redis, we also constructed a basic index on
    the fly enabling us to search for quotes by author in our next piece of code.
  prefs: []
  type: TYPE_NORMAL
- en: We check for the existence of the first command-line argument, the author, and
    then output quotes by that author.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If both `author` and `quote` are specified via the command line, we go ahead
    and generate a random key prefixed with `Quote:`. So each key will look something
    like `Quote:08d780a57b035f`. This helps us to identify keys in debugging and it's
    also common convention to prefix the Redis keys with names delimited by a colon.
  prefs: []
  type: TYPE_NORMAL
- en: 'We pass this key into `client.hmset`, a wrapper for the Redis `HMSET` command,
    which allows us to create multiple hashes. Unlike the raw `HMSET, client.hmset`
    also accepts a JavaScript object (instead of an array) to create multiple key
    assignments. With the standard Redis command-line client, `redis-cli`, we would
    have to say:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: We could hold to this format by using an array containing keys next to values,
    but an object seems kinder and more familiar to the eyes of a JavaScript folk.
  prefs: []
  type: TYPE_NORMAL
- en: Every time we store a new quote with `client.hmset`, we add the `randKey` for
    that quote to the relevant author set via the second parameter of `client.sadd.
    client.sadd` allows us to add a member to a Redis set (a set is like an array
    of strings). The key for our `SADD` command is based on the intended author. So
    in the Steve Jobs quote used above, the key to pass into `client.sadd` would be
    `Author:Steve Jobs`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, if an author is specified we perform an `SMEMBERS` using `client.smembers`.
    This returns all the values we stored to a specific authors' set, being the keys
    for all quotes relating to that author.
  prefs: []
  type: TYPE_NORMAL
- en: We loop through these keys using `forEach`, passing every key into `client.hgetall`.
    Redis `HGETALL` returns hash (object) that we passed into `client.hmset` earlier.
    Each author and quote is then logged to the console, and `client.quit` gracefully
    exits our script once all Redis commands have been executed.
  prefs: []
  type: TYPE_NORMAL
- en: A `client.quit` is also included at the end of the `ready` event on? occasions
    where no command-line arguments have been specified.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Redis is a speed freak's dream, but we can still make optimizations.
  prefs: []
  type: TYPE_NORMAL
- en: Speeding up node Redis module
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'By default, the `redis` module uses a pure JavaScript parser. However, the
    Redis project provides a Node `hiredis` module: a C bindings module which binds
    to the official Redis client, Hiredis. Hiredis is faster (being written in C)
    than the JavaScript parser.'
  prefs: []
  type: TYPE_NORMAL
- en: The `redis` module will interface with the `hiredis` module if it is installed.
    Therefore, we can achieve performance benefits simply by installing `hiredis:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Overcoming network latency by pipelining commands
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Redis can receive multiple commands at once. The `redis` module has a `multi`
    method which sends collated commands en masse. If the latency (time taken for
    data to travel) was 20 ms per command, for 10 combined commands we save 180 ms
    (10 x 20 - 20 = 180).
  prefs: []
  type: TYPE_NORMAL
- en: 'If we copy `quotes.js` to `quotes_multi.js` we can alter it accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: We can see our original Redis commands highlighted, only they have been chained
    with `client.multi`. Once all commands have been added to `client.multi`, we invoke
    its `exec` method. Finally, we use the callback of `exec` to verify that our data
    was successfully added.
  prefs: []
  type: TYPE_NORMAL
- en: We didn't provision `SMEMBERS` for pipelining. `SMEMBERS` must be called after
    the quote has been added, or else the new quote won't be displayed. If `SMEMBERS`
    was combined with `HMSET` and `SADD` it would be executed asynchronously alongside
    them. There's no guarantee that the new quote would be available to `SMEMBERS`.
    In fact, it's unlikely since `SMEMBERS` is more complex than `SADD`, so it takes
    longer to process.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Storing and retrieving data with Mongoskin* discussed in this chapter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Connecting and sending SQL to a MySQL server* discussed in this chapter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Implementing PubSub with Redis* discussed in this chapter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing PubSub with Redis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Redis exposes a Publish-Subscribe messaging pattern (not so dissimilar to the
    CouchDB `changes` stream), which can be used to listen to specific data change
    events. Data from these events could be passed between processes to, for instance,
    instantly update a web app with fresh new data.
  prefs: []
  type: TYPE_NORMAL
- en: With PubSub, we publish a message to a specific channel, this channel can then
    be picked up by any amount of subscribers. The publishing mechanism doesn't care
    who's listening or how many, it chats away regardless.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will create a publishing process and a subscribing process.
    For publishing, we'll extend our `quotes.js` file from the previous recipe *Storing
    and retrieving data with Redis*, and we'll write the code to a new file for the
    subscription mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's create a new directory, copy `quotes.js` from the previous recipe, and
    rename it to `quotes_publish.js`. We will also create a file called `quotes_subscribe.js`.
    We'll need to ensure that Redis is running. If it isn't installed and running
    globally, we can navigate to the directory Redis was unpacked to and run `./redis-server`
    from the `src` folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In `quotes_publish.js` we add one extra line of code inside our first conditional
    statement, just after our `client.sadd` call.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: This means every time we add an author and quote, we publish the quote to a
    channel named after the author. We subscribe to channels using `quotes_subscribe.js`,
    so let's code it.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, it must require the `redis` module and create a client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: We're going to provide the option to subscribe to multiple channels, again using
    the command line as our elementary input method. To achieve this, we'll loop through
    `process.argv:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we are subscribing to channels, we need to listen to messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'We can test our PubSub functionality by first running `quotes_subscribe.js`
    along with some specified authors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Then we open a new terminal and run several authors and quotes through `quotes_publish.js`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see it in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/7188-04-04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Only the channels we subscribed to appeared on the `quotes_subscribe.js` terminal.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We access the Redis `PUBLISH` command in `quotes_publish.js` via `client.publish`,
    setting the channel name by author name.
  prefs: []
  type: TYPE_NORMAL
- en: In `quotes_subscribe.js` we loop through any arguments given via command line.
    (We apply `forEach` to `process.argv.slice(2)`. This removes the first two elements
    of the `process.argv` array, which would hold the command (`node`) and the path
    to our script. Each relevant argument is passed to `client.subscribe`, telling
    Redis we wish to `SUBSCRIBE` to that channel.
  prefs: []
  type: TYPE_NORMAL
- en: When a message arrives due to a subscription, the `redis` module `client` will
    emit a `message` event. We listen for this event and pass the incoming `channel`
    and `msg` (which will be `author` and `quote` accordingly) to `console.log`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Finally, we'll take a look at Redis security.
  prefs: []
  type: TYPE_NORMAL
- en: Redis authentication
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can set authentication for Redis with the `redis.conf` file, found in the
    directory we installed Redis to. To set a password in `redis.conf`, we simply
    add (or uncomment) `requirepass ourpassword`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we make sure that our Redis server points to the configuration file. If
    we are running it from the `src` directory, we would initiate with the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'If we wanted to set a password quickly we could say:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'We could set a password from within Node with the `CONFIG SET` Redis command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: To authenticate with a Redis server within Node, we can use the `redis` module's
    `auth` method, before any other calls (that is, prior to `client.ready)`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: The password has to be sent before any other commands. The `redis` module's
    `auth` function takes of things like reconnections by pushing the password into
    the `redis` module's internal operations. Essentially, we can call `auth` at the
    top of our code and never concern ourselves with authentication for that script
    again.
  prefs: []
  type: TYPE_NORMAL
- en: Securing Redis from external connections
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If there was no need for external connections to Redis, we could bind it to
    `127.0.0.1`, inhibiting all external traffic.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can achieve this with a configuration file, for instance `redis.conf`, and
    add (or uncomment):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, if running from the `src` folder, initialize our Redis server with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we could do it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Or in Node with the `redis` module''s `config` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If we installed Redis via a package manager it may already be configured to
    block external connections.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Accessing CouchDB changes stream with Cradle* discussed in this chapter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Storing and retrieving data with Redis* discussed in this chapter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
