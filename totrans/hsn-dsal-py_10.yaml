- en: Sorting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sorting means reorganizing the data in such as way that it is in the order of
    smallest to largest. Sorting is one of the most important issues in data structures
    and computing. Data is regularly sorted before being sorted, as it can then very
    efficiently be retrieved, be it a collection of names, telephone numbers, or items
    on a simple to-do list.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll study some of the most important and popular sorting
    techniques, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Bubble sort
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Insertion sort
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selection sort
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Quick sort
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Heap sort
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we compare different sorting algorithms by considering their
    asymptotic behavior. Some of the algorithms are relatively easy to develop, but
    may perform poorly, whereas other algorithms are slightly more complex to implement,
    but show good performance in sorting the list when we have a long lists.
  prefs: []
  type: TYPE_NORMAL
- en: After sorting, it becomes much easier to conduct search operations on a collection
    of items. We'll start with the simplest of all sorting algorithms; that is, the
    bubble sort algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All source code used to explain the concepts of this chapter is provided in
    the GitHub repository at the following link: [https://github.com/PacktPublishing/Hands-On-Data-Structures-and-Algorithms-with-Python-Second-Edition/tree/master/Chapter10](https://github.com/PacktPublishing/Hands-On-Data-Structures-and-Algorithms-with-Python-Second-Edition/tree/master/Chapter10).
  prefs: []
  type: TYPE_NORMAL
- en: Sorting algorithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sorting means arranging all the items in a list in ascending order of their
    magnitude. We will be discussing some of the most important sorting algorithms,
    which each have different performance attributes with respect to runtime complexity.
    Sorting algorithms are categorized by their memory usage, complexity, recursion,
    and whether they are comparison-based, among other considerations.
  prefs: []
  type: TYPE_NORMAL
- en: Some of the algorithms use more CPU cycles, and, as such, have bad asymptotic
    values. Other algorithms chew on more memory and other computing resources as
    they sort a number of values. Another consideration is how sorting algorithms
    lend themselves to being expressed recursively, iteratively, or both. There are
    algorithms that use comparison as the basis for sorting elements. An example of
    this is the bubble sort algorithm. Examples of a non-comparison sorting algorithm
    are the bucket sort and pigeonhole sort algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: Bubble sort algorithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The idea behind the bubble sort algorithm is very simple. Given an unordered
    list, we compare adjacent elements in the list, and after each comparison, place
    them in the right order of magnitude. This works by swapping adjacent items if
    they are not in the correct order. The process is repeated `n-1` times for a list
    of `n` items. In each such iteration, the largest element is arranged in the end.
    For example, in the first iteration, the largest element would be placed in the
    last position of the list, and again, the same process will be followed for the
    remaining `n-1` items. In the second iteration, the second largest element will
    be placed at the second-to-last position in the list, and the process will then
    be repeated until the list is sorted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a list with only two elements, {**5**, **2**}, to understand the
    concept of the bubble sort, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/21f97a06-89a0-4128-a1e8-580c48e3d76b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To sort this list, we simply swap the values into the right positions, with **2** occupying
    index **0** and **5** occupying index **1**. To effectively swap these elements,
    we need to have a temporary storage area:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/3e4f61f4-3eb8-413a-bbda-27ab37970caa.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Implementation of the bubble sort algorithm starts with the swap method, illustrated
    in the preceding diagram. First, element **5** will be copied to a temporary location, `temp`.
    Then, element **2** will be moved to index **0**. Finally, **5** will be moved
    from temp to index **1**. At the end of it all, the elements will have been swapped.
    The list will now contain the elements as `[2, 5]`. The following code will swap
    the elements of `unordered_list[j]` with `unordered_list[j+1]` if they are not
    in the right order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have been able to swap a two-element array, it should be simple
    to use this same idea to sort a whole list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider another example to understand the working of bubble sort algorithm
    to sort an unordered list of **6** elements, such as {**45**, **23**, **87**,
    **12**, **32**, **4**}. In the first iteration, we start comparing the first two
    elements, **45** and **23**, and we swap them, as **45** should be placed after
    **23**. Then, we compare the next adjacent values, **45** and **87**, to see whether
    they are in the correct order. Swap them if they are not in the correct order.
    We can see, in the following diagram, that after the first iteration of the bubble
    sort, the largest element, **87**, is placed in the last position of the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/25605a4a-d41e-4ce3-826e-20fb3d1373c6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After the first iteration, we just need to arrange the remaining `(n-1)` elements;
    we repeat the same process by comparing the adjacent elements for the remaining
    five elements. After the second iteration, the second largest element, **45**,
    is placed at the second-to-last position in the list, as shown in the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/da1be0d7-4d4c-4d22-aea5-5f96dee1e07c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we have to compare the remaining `(n-2)` elements to arrange them as
    shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/87da0f01-1e66-4064-8810-5fcc9f1daa5e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Similarly, we compare the remaining elements to sort them, as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/4ccbf25c-3e8e-40f9-a2e7-9ec1141a3987.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, in the last two remaining elements, we place them in the correct order
    to obtain the final sorted list, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/e9d0d690-e962-400f-8610-6b7c2519d5e8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The implementation of the bubble sort algorithm would work in a double-nested
    loop, where the inner loop repeatedly compares and swaps the adjacent elements
    in each iteration for a given list, and the outer loop keeps track of how many
    times the inner loop should be repeated. The implementation of the inner loop
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'It is important to know, when implementing a bubble sort algorithm, how many times
    the loop will need to run to complete all swaps. To sort a list of three numbers,
    for example, `[3, 2, 1]`, we need to swap the elements a maximum of two times.
    This is equal to the length of the list minus 1, and could be written as `iteration_number
    = len(unordered_list)-1`. We subtract 1 because it gives us exactly the maximum
    number of iterations to run. Let''s show this with the following example, where,
    in a list of 3 numbers, by swapping the adjacent elements in exactly two iterations,
    the largest number ends up at the last position in the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/97ed985d-c7fa-4bb3-9a07-2d3d831f886a.png)'
  prefs: []
  type: TYPE_IMG
- en: The `if` statement makes sure that no unnecessary swaps occur if two adjacent
    elements are already in the right order. The inner `for` loop only causes the
    swapping of adjacent elements to occur exactly twice in our list.
  prefs: []
  type: TYPE_NORMAL
- en: 'How many times does this swapping operation have to occur in order for the
    entire list to be sorted? We know that, if we repeat the whole process of swapping
    the adjacent elements a number of times, the list will be sorted. An outer loop
    is used to make this happen. The swapping of elements in the list results in the
    following dynamics:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/22b48f43-84eb-4f09-9156-a48f21eb1d6e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We recognize that a total of four comparisons at most were needed to get our
    list sorted. Therefore, both inner and outer loops have to run `len(unordered_list)-1`
    times for all elements to be sorted, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The same principle is used even if the list contains many elements. There are
    a lot of variations of the bubble sort, too, that minimize the number of iterations
    and comparisons.
  prefs: []
  type: TYPE_NORMAL
- en: For example, there is a variant of the bubble sort algorithm where, if there
    is no swapping within the inner loop, we simply quit the entire sorting process,
    because the absence of any swapping operation in the inner loop suggests that
    the list has already been sorted. In a way, this can help speed up the algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: The bubble sort is an inefficient sorting algorithm that provides worst-case
    and average-case runtime complexity of `O(n²)`, and a best-case complexity of
    `O(n)`. Generally, the bubble sort algorithm should not be used to sort large
    lists. However, on relatively small lists, it performs fairly well.
  prefs: []
  type: TYPE_NORMAL
- en: Insertion sort algorithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The idea of swapping adjacent elements to sort a list of items can also be used
    to implement the insertion sort. An insertion sorting algorithm maintains a sub-list
    that is always sorted, while the other portion of the list remains unsorted. We
    take elements from the unsorted sub-list and insert them in the correct position
    in the sorted sub-list, in such a way that this sub-list remains sorted.
  prefs: []
  type: TYPE_NORMAL
- en: In insertion sorting, we start with one element, assuming it to be sorted, and
    then take another element from the unsorted sub-list and place it at the correct
    position (in relation to the first element) in the sorted sub-list. This means
    that our sorted sub-list now has two elements. Then, we again take another element
    from the unsorted sub-list, and place it in the correct position (in relation
    to the two already sorted elements) in the sorted sub-list. We repeatedly follow
    this process to insert all the elements one by one from the unsorted sub-list
    into the sorted sub-list. The shaded elements denote the ordered sub-lists, and
    in each iteration, an element from the unordered sub-list is inserted at the correct
    position in the sorted sub-list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider an example to understand the working of the insertion sorting
    algorithm. In our example, we''ll be sorting a list of `6` elements: `{45, 23,
    87, 12, 32, 4}`. Firstly, we start with `1` element, assuming it to be sorted,
    then take the next element, `23`, from the unsorted sub-list and insert it at
    the correct position in the sorted sub-list. In the next iteration, we take the
    third element, `87`, from the unsorted sub-list, and again insert it into the
    sorted sub-list at the correct position. We follow the same process until all
    elements are in the sorted sub-list. This whole process is shown in the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/2be1efdb-8fd8-43d6-add6-aede489e3815.png)'
  prefs: []
  type: TYPE_IMG
- en: To understand the implementation of the insertion sorting algorithm, let's take
    another example list of `5` elements, `{5, 1, 100, 2, 10}`, and examine the process
    with a detailed explanation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider the following array:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/52c67297-48cb-4fb1-a6e6-863f02db06bb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The algorithm starts by using a `for` loop to run between the **1** and **4** indices.
    We start from index **1** because we assume the sub-array at index **0** to already
    be in the correctly sorted order:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/c140fcb5-08aa-4ad5-bafe-33fd12a82214.png)'
  prefs: []
  type: TYPE_IMG
- en: 'At the start of the execution of the loop, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'At the beginning of the execution of each run of the `for` loop, the element
    at `unsorted_list[index]` is stored in the `insert_value` variable. Later, when
    we find the appropriate position in the sorted portion of the list, `insert_value`
    will be stored at that index or location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `search_index` is used to provide information to the `while` loop; that
    is, exactly where to find the next element that needs to be inserted into the
    sorted sub-list.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `while` loop traverses the list backward, guided by two conditions: first,
    if `search_index > 0`, then it means that there are more elements in the sorted
    portion of the list; second, for the `while` loop to run, `unsorted_list[search_index-1]`
    must be greater than the `insert_value` variable. The `unsorted_list[search_index-1]` array
    will do either of the following things:'
  prefs: []
  type: TYPE_NORMAL
- en: Point to the element, just before the `unsorted_list[search_index]`, before
    the `while` loop is executed the first time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Point to one element before `unsorted_list[search_index-1]` after the `while`
    loop has been run the first time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In our example list, the `while` loop will be executed because *5 > 1*. In the
    body of the while loop, the element at `unsorted_list[search_index-1]` is stored
    at `unsorted_list[search_index]`. `search_index -= 1` moves the list traversal
    backward until it holds a value of `0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our list now looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/86df775f-a6fb-4bd2-9b93-0038bbdc97dc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After the `while` loop exits, the last known position of `search_index` (which,
    in this case, is `0`) now helps us to know where to insert `insert_value`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/ad028833-87aa-466e-8b28-8cb081f129b8.png)'
  prefs: []
  type: TYPE_IMG
- en: On the second iteration of the `for` loop, `search_index` will have a value
    of **2**, which is the index of the third element in the array. At this point,
    we start our comparison in the leftward direction (toward index **0**). **100**
    will be compared with **5**, but because **100** is greater than **5**, the `while`
    loop will not be executed. **100** will be replaced by itself, because the `search_index` variable
    never got decremented. As such, `unsorted_list[search_index] = insert_value` will
    have no effect.
  prefs: []
  type: TYPE_NORMAL
- en: When `search_index` is pointing at index **3**, we compare **2** with **100**,
    and move **100** to where **2** is stored. We then compare **2** with **5** and
    move **5** to where **100** was initially stored. At this point, the `while` loop
    will break and **2** will be stored in index **1**. The array will be partially
    sorted with the values `[1, 2, 5, 100, 10]`.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding step will occur one last time for the list to be sorted.
  prefs: []
  type: TYPE_NORMAL
- en: The insertion sorting algorithm is considered stable, in the sense that it does
    not change the relative order of elements that have equal keys. It also only requires
    no more memory than that consumed by the list, because it does the swapping in-place.
  prefs: []
  type: TYPE_NORMAL
- en: Insertion sorting algorithm gives a worst-case runtime complexity of **`O(n²)`**,
    and a best-case complexity `O(n)`.
  prefs: []
  type: TYPE_NORMAL
- en: Selection sort algorithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another popular sorting algorithm is the selection sort. The selection sorting
    algorithm begins by finding the smallest element in the list, and interchanges
    it with the data stored at the first position in the list. Thus, it makes the sub-list
    sorted up to the first element. Next, the second smallest element, which is the
    smallest element in the remaining list, is identified and interchanged with the
    second position in the list. This makes the initial two elements sorted. The process
    is repeated, and the smallest element remaining in the list should be swapped
    with the element in the third index on the list. This means that the first three
    elements are now sorted. This process is repeated for `(n-1)` times to sort `n` items.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an example to understand how the algorithm works. We''ll sort
    the following list of 4 elements using the selection sort algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/00f7ef2b-0bcf-4184-995c-2bebd03c2d85.png)'
  prefs: []
  type: TYPE_IMG
- en: Starting at index **0**, we search for the smallest item in the list that exists
    between index **1**, and the index of the last element. When this element has
    been found, it is exchanged with the data found at index **0**. We simply repeat
    this process until the list is fully sorted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Searching for the smallest item within the list is an incremental process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/11f39ec5-3839-4437-9724-52c16ca07749.png)'
  prefs: []
  type: TYPE_IMG
- en: A comparison of elements **2** and **5** selects **2**, as it is the lesser
    value among these two values, and thus, the two elements are swapped.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the swap operation, the array looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/394c7330-7323-4726-88e1-bd3c7546399a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Further, at index **0**, we compare **2** with **65**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/09719f77-d0ec-4f7a-8a48-d1fd6609a8e6.png)'
  prefs: []
  type: TYPE_IMG
- en: Since **65** is greater than **2**, the two elements are not swapped. A further
    comparison is made between the element at index **0**, which is **2**, and the
    element at index **3**, which is **10**. No swap takes place in this case. When
    we get to the last element in the list, we will have the smallest element occupying
    index **0**.
  prefs: []
  type: TYPE_NORMAL
- en: In the next iteration, we start comparing elements from position **1** in the
    index. We repeat the whole process of comparing the element stored at index **1**
    with all the elements, from index **2** through to the last index.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second iteration starts by comparing **5** and **65**, which will look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/d4fd4df3-f7aa-4980-9d86-39af6d2d5108.png)'
  prefs: []
  type: TYPE_IMG
- en: Once we find out that the **5** is the smallest value in the sub-list from indices **1**
    to **3**, we place it at index **1**. Similarly, the next smallest element from
    the sub-lists **2** and **3** indices is placed at index **3**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an implementation of the selection sort algorithm. The argument
    to the function is the unsorted list of items we want to put in ascending order
    of magnitude:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The algorithm begins by using the outer `for` loop to go through the list, `size_of_list`,
    a number of times. Because we pass `size_of_list` to the `range` method, it'll
    produce a sequence from **0** through to `size_of_list-1`.
  prefs: []
  type: TYPE_NORMAL
- en: The inner loop is responsible for going through the list and swap elements if
    we encounter an element less than the element pointed to by `unsorted_list[i]`.
    Notice that the inner loop begins from `i+1` up to `size_of_list-1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The inner loop begins its search for the smallest element from `i+1`, but uses
    the `j` index:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/6a9bbfe0-c944-46d0-8109-daedd157611d.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding diagram shows the direction in which the algorithm searches for
    the next smallest item.
  prefs: []
  type: TYPE_NORMAL
- en: The selection sorting algorithm gives worst-case and best-case runtime complexities
    of `O(n2)`.
  prefs: []
  type: TYPE_NORMAL
- en: Quick sort algorithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The quick sort algorithm is very efficient for sorting. The quick sort algorithm
    falls under the divide and conquer class of algorithms, similar to the merge sort
    algorithm, where we break (divide) a problem into smaller chunks that are much
    simpler to solve (conquer).
  prefs: []
  type: TYPE_NORMAL
- en: List partitioning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The concept behind quick sorting is partitioning a given list or array. To partition
    the list, we first select a pivot. All the elements in the list will be compared
    with this pivot. At the end of the partitioning process, all elements that are
    less than the pivot will be to the left of the pivot, while all elements greater
    than the pivot will lie to the right of the pivot in the array.
  prefs: []
  type: TYPE_NORMAL
- en: Pivot selection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the sake of simplicity, we'll take the first element in an array as the
    pivot. This kind of pivot selection degrades in performance, especially when sorting
    an already sorted list. Randomly picking the middle or last element in the array
    as the pivot does not improve the performance of the quick sort. We will discuss
    a better approach to select the pivot and find the smallest element in a list in
    the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: An illustration with an example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this algorithm, we partition an unsorted array into two sub-arrays, in such
    a way that all the elements on the left side of that partition point (also called
    a pivot) should be smaller than the pivot, and all the elements on the right side
    of the pivot should be greater. After the first iteration of the quick sort algorithm,
    the chosen pivot point is placed in the list at its correct position. After the
    first iteration, we obtain two unordered sub-lists, and follow the same process
    again on these two sub-lists. Thus, the quick sort algorithm partitions the list
    into two parts and recursively applies the quick sort algorithm on these two sub-lists
    to sort the whole list.
  prefs: []
  type: TYPE_NORMAL
- en: We start by choosing a pivot point with which all the items are to be compared,
    and at the end of the first iteration, this value will be placed in its correct
    position in the ordered list. Next, we use two pointers, a left pointer, and a
    right pointer. The left pointer initially points to the value at index **1**,
    and the right pointer points to the value at the last index. The main idea behind
    the quick sort algorithm is to move the items that are on the wrong side of the
    pivot value. So, we start with the left pointer, moving from in a left-to-right
    direction, until we reach a position where the item has a greater value than the
    pivot value. Similarly, we move the right pointer toward the left until we find
    a value less than a pivot value. Next, we swap these two values indicated by the
    left and right pointers. We repeat the same process until both pointers cross
    each other; in other words, when the right pointer index indicates a value less
    than that of the left pointer index.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take an example of a list of numbers, {**45**, **23**, **87**, **12**,
    **72**, **4**, **54**, **32**, **52**}, to understand how the quick sort algorithm
    works. Let's assume that the pivot point in our list is the first element, **45**.
    We move the left pointer from index **1** in a rightward direction, and stop when
    we reach the value **87**, because (**87**>**45**). Next, we move the right pointer
    toward the left, and stop when we find the value **32**, because (**32**<**45**).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we swap these two values, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/7b232879-1527-4f8e-ac01-f56791cc7982.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After that, we repeat the same process and move the left pointer toward the
    right direction, and stop when we find the value **72**, because (**72**>**45**). Next,
    we move the right pointer toward the left and stop when we reach the value 4,
    because (**4**<**45**). Now, we swap these two values, because they are in the
    wrong direction of the pivot value. We repeat the same process and stop once the
    right pointer index value becomes less than the left pointer index. Here, we find
    **4** as the splitting point, and swap it with the pivot value. This is shown
    in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/e05dddc1-22ab-495c-847c-b2765ed7d23c.png)'
  prefs: []
  type: TYPE_IMG
- en: It can be observed that after the first iteration of the quick sort algorithm,
    the pivot value **45** is placed at its correct position in the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we have two sub-lists:'
  prefs: []
  type: TYPE_NORMAL
- en: The sub-list to the left of the pivot value, **45**, has values of less than
    **45**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Another sub-list to the right of the pivot value contains values greater than
    45\. We will apply the quick sort algorithm recursively on these two sub-lists,
    and repeat it until the whole list is sorted.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](Images/18334875-62fb-4170-bb9b-47f0b4b3a210.png)'
  prefs: []
  type: TYPE_IMG
- en: Implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The partitioning step is very important in understanding the implementation
    of the quick sort algorithm, so we will start with an examination of implementing
    the partitioning first.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at another example to understand the implementation. Consider the
    following list of integers. We shall partition this list using the partition function,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/29b930cc-1cd7-4a9c-a5ba-54d2a951a9c5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Consider the following code for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The partition function receives, as its parameters, the indices of the first
    and last elements of the array that we need to partition.
  prefs: []
  type: TYPE_NORMAL
- en: 'The value of the pivot is stored in the `pivot` variable, while its index is
    stored in `pivot_index`. We are not using `unsorted_array[0]`, because when the
    unsorted array parameter is called with a segment of an array, index `0` will
    not necessarily point to the first element in that array. The index of the next
    element to the pivot, that is, the **left pointer**, `first_index + 1`, marks
    the position where we begin to look for an element in the array that is greater
    than the `pivot`, as `greater_than_pivot_index = first_index + 1`. The **right
    pointer** `less_than_pivot_index` variable points to the position of the last
    element in the `less_than_pivot_index = index_of_last_element` list, where we
    begin the search for the element that is less than the pivot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'At the beginning of the execution of the main `while` loop, the array looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/16a3edea-4e3f-4532-82a8-500df977e3b9.png)'
  prefs: []
  type: TYPE_IMG
- en: The first inner `while` loop moves one index to the right until it lands on
    index **2**, because the value at that index is greater than **43**. At this point,
    the first `while` loop breaks and does not continue. At each test of the condition
    in the first `while` loop, `greater_than_pivot_index += 1` is evaluated only if
    the `while` loop's test condition evaluates to `True`. This makes the search for
    an element, greater than the pivot, progress to the next element on the right.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second inner `while` loop moves one index at a time to the left, until
    it lands on index **5**, whose value, **20**, is less than **43**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/5de935b0-20a7-4973-8819-81babd0768f0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'At this point, neither inner `while` loop can be executed any further:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Since `greater_than_pivot_index < less_than_pivot_index`, the body of the `if`
    statement swaps the element at those indexes. The `else` condition breaks the
    infinite loop any time that `greater_than_pivot_index` becomes greater than `less_than_pivot_index`.
    In such a condition, it means that `greater_than_pivot_index` and `less_than_pivot_index`
    have crossed over each other.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our array now looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/b8479f3c-29f3-48f0-9807-ded22d7670e7.png)'
  prefs: []
  type: TYPE_IMG
- en: The `break` statement is executed when `less_than_pivot_index` is equal to **3**
    and `greater_than_pivot_index` is equal to **4**.
  prefs: []
  type: TYPE_NORMAL
- en: 'As soon as we exit the `while` loop, we interchange the element at `unsorted_array[less_than_pivot_index]`
    with that of `less_than_pivot_index`, which is returned as the index of the pivot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The following diagram shows how the code interchanges **4** with **43** as
    the last step in the partitioning process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/31e49e1a-1589-4a9d-9404-1571133a1f64.png)'
  prefs: []
  type: TYPE_IMG
- en: To recap, the first time the `quick_sort` function was called, it was partitioned
    about the element at index **0**. After the return of the partitioning function,
    we obtain the array in the order of [**4**, **3**, **20**, **43**, **89**, **77**].
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, all elements to the right of element **43** are greater than
    **43**, while those to the left are smaller. Thus, the partitioning is complete.
  prefs: []
  type: TYPE_NORMAL
- en: Using the split point **43** with index **3**, we will recursively sort the
    two sub-arrays, [**4**, **30**, **20**] and [**89**, **77**], using the same process
    we just went through.
  prefs: []
  type: TYPE_NORMAL
- en: 'The body of the main `quick_sort` function is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `quick_sort` function is a very simple method, taking up no more than six
    lines of code. The heavy lifting is done by the `partition` function. When the
    `partition` method is called, it returns the partition point. This is the point
    in the `unsorted_array` array where all elements to the left are less than the
    pivot value, and all elements to its right are greater than it.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we print the state of `unsorted_array` immediately after the partition
    progress, we see clearly how the partitioning happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Taking a step back, let's sort the first sub-array after the first partition
    has happened. The partitioning of the `[4, 3, 20]` sub-array will stop when `greater_than_pivot_index`
    is at index `2`, and `less_than_pivot_index` is at index `1`. At that point, the
    two markers are said to have crossed. Because `greater_than_pivot_index` is greater
    than `less_than_pivot_index`, further execution of the `while` loop will cease.
    Pivot `4` will be exchanged with `3`, while index `1` is returned as the partition
    point.
  prefs: []
  type: TYPE_NORMAL
- en: In the quicksort algorithm, the partition algorithm takes `O(n)` time. As the
    quicksort algorithm follows the *divide and conquer* paradigm, it takes `O(log
    n)` time; therefore, the overall average-case runtime complexity of the quicksort
    algorithm is `O(n) * O(log n) = O(n log n)`. The quicksort algorithm gives a worst-case
    runtime complexity of `O(n²)`. The worst-case complexity for the quicksort algorithm
    would be when it selects the worst pivot point every time, and one of the partitions
    always has a single element. For example, if the list is already sorted, the worst-case
    complexity would occur if the partition picks the smallest element as a pivot
    point. When worst-case complexity does occur, the quicksort algorithm can be improved by
    using the randomized quicksort. The quicksort algorithm is very efficient when
    sorting large amounts of data compared to the other aforementioned algorithms
    for sorting.
  prefs: []
  type: TYPE_NORMAL
- en: Heap sort algorithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Chapter 8, *Graphs and Other Algorithms*, we implemented a binary heap data
    structure. Our implementation always made sure that, after an element had been
    removed or added to a heap, the heap order property was maintained, by using the
    `sink()` and `arrange()` helper methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'The heap data structure can be used to implement a sorting algorithm called
    the heap sort. As a recap, let''s create a simple heap with the following items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The heap, `h`, is created and the elements in the `unsorted_list` are inserted.
    After each method call to `insert`, the heap order property is restored by the
    subsequent call to the `float` method. After the loop is terminated, element `4` will
    be at the top of our heap.
  prefs: []
  type: TYPE_NORMAL
- en: The number of elements in our heap is `10`. If we call the `pop` method on the
    `h` heap object 10 times, and store the actual elements being popped, we end up
    with a sorted list. After each `pop` operation, the heap is readjusted to maintain
    the heap order property.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `heap_sort` method is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `for` loop simply calls the `pop` method `self.size` number of times. Now, `sorted_list`
    will contain a sorted list of items after the loop terminates.
  prefs: []
  type: TYPE_NORMAL
- en: The `insert` method is called *n* number of times. Together with the `arrange()` method,
    the `insert` operation takes a worst-case runtime of `O(n log n)`, as does the
    `pop` method. As such, this sorting algorithm incurs a worst-case runtime of `O(n
    log n)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A comparison of the complexities of different sorting algorithms is given in
    the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Algorithm** | **worst-case** | **average-case** | **best-case** |'
  prefs: []
  type: TYPE_TB
- en: '| Bubble sort | `O(n²)` | `O(n²)` | `O(n)` |'
  prefs: []
  type: TYPE_TB
- en: '| Insertion sort | `O(n²)` | `O(n²)` | `O(n)` |'
  prefs: []
  type: TYPE_TB
- en: '| Selection sort | `O(n²)` | `O(n²)` | `O(n²)` |'
  prefs: []
  type: TYPE_TB
- en: '| Quicksort | `O(n²)` | `O(n log n)` | `O(n log n)` |'
  prefs: []
  type: TYPE_TB
- en: '| heapsort | `O(n log n)` | `O(n log n)` | ` O(n Log n)` |'
  prefs: []
  type: TYPE_TB
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored a number of important and popular sorting algorithms,
    which are very useful for many real-world applications. We discussed bubble sort,
    insertion sort, selection sort, quick sort, and heap sort algorithms, along with
    the explanation of their implementation in Python. Quick sort performs much better
    than the other sorting algorithms. Of all the algorithms discussed, quick sort
    preserves the index of the list that it sorts. We'll use this property in the
    next chapter as we explore the selection algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be discussing the concepts related to the selection
    strategy and algorithms.
  prefs: []
  type: TYPE_NORMAL
